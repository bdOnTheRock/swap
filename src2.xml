<db path="C:\bernard\db1\db4">
  <file path="\PieceDb.Consolid\auto\CalcAuto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.auto
{
    public partial class ConfMedianneVirt : TuningBase
    {
        public bool linkconv { get { return _linkconv; } set { _linkconv = value; calcProduct(); } }

        private void calcProduct()
        {
            this.linkProduct = calcProduct(this.v, this.a);
        }

        public decimal calcProduct(decimal dcoeffp, decimal dconvergence)
        {
            var linkProduct = this.linkProduct;
            try
            {
                linkProduct = dcoeffp / dconvergence;
                // 1 0,9 -> 10
                // 0.1 0,99 
            }
            catch
            {
            }

            return linkProduct;
        }

        private void calcConv()
        {
            this.a = calcConv(this.v, this.linkProduct);
        }

        public decimal LinkProduct
        {
            get
            {
                if (linkProduct == 0m)
                    calcProduct();
                return linkProduct;
            }
            set
            {
                linkProduct = value;
                calcConv();

            }
        }

        public decimal calcConv(decimal dcoeffp, decimal linkProduct)
        {
            var dconvergence = this.a;
            try
            {
                // 1- conv = coeff / prod
                dconvergence = dcoeffp / linkProduct; //1/10
            }
            catch
            {

            }
            return dconvergence;
        }

        public void checkCoeffOld()
        {
            if (coeffOldAuto)
            {
                coeffOld = (decimal)pdb.util.Math.Pow(coeffVirt, coeffOldAutoLevel);
            }
        }

        private void verifMaxV()
        {

            var _dxmax = (coeffVirt - 1) * d0;
            var _dx = v * pas;
            if (_dx > _dxmax)
            {
                var vv = _dxmax / pas;
                misc.log("verifMaxV {0}->{1}", v.FormatE(4), vv.FormatE(4));
                v = vv;
            }
        }

        private void verifMaxA()
        {
            var _dxmax = (coeffVirt - 1) * d0;
            var _dx = 2 * a * pas * pas;

            if (_dx > _dxmax)
            {
                var aa = _dxmax / (2 * pas * pas);
                misc.log("verifMaxA {0}->{1}", a.FormatE(4), aa.FormatE(4));
                a = aa;
            }
        }

        private void verifBas()
        {
            var dx = v * pas;
            if (dx < epsilon)
            {
                //dx = epsilon;
                v = epsilon / pas;
            }

            //dx = vv * pas;
            //if (dx < epsilon)
            //{
            //    dx = epsilon;
            //    vv = epsilon / pas;
            //}

            var dv = a * pas;
            if (dv < vepsilon)
            {
                // dv = vepsilon;
                a = vepsilon / pas;

            }

            if (a < aepsilon)
                a = aepsilon;

            if (coeffVirt < 1)
                coeffVirt = 1;
        }
        private decimal _v0;
        //private decimal getLimitedDelta(decimal v0, decimal oldSameDirection)
        //{
        //    var v1 = v0;

        //    if (v0 > 1)
        //    {
        //        if (oldSameDirection > v0)
        //        {
        //            v1 = 2 * v0 - oldSameDirection;
        //            if (v1 < 1)
        //                v1 = 1;
        //        }
        //    }
        //    return v1;
        //}

        private decimal getLimitedDelta(decimal v0, decimal oldSameDirection, bool changeSens)
        {
            var v1 = v0;
            if (!changeSens)
                return v0; 

            if (v0 > 1)
            {
                if (oldSameDirection > v0)
                {
                    int nb = 0;
                    while (true)
                    {
                        nb++;
                        var _v = v1 - 1;
                        if (_v < 1)
                            break;
                        if (nb >= oldSameDirection)
                            break;
                        v1 = _v; 

                    }
                    //v1 = 2 * v0 - oldSameDirection;
                    //if (v1 < 1)
                    //    v1 = 1;
                }
              
               
            }
            return v1;
        }
        /// <summary>
        /// coeff Lot affiché
        /// </summary>
        private decimal coeffLotDisplay = 1;
        /// <summary>
        /// coeff Lot affiché
        /// </summary>
        public decimal CoeffLotDisplay { get { return coeffLotDisplay; } }

        /// <summary>
        /// Variation elastique affichée
        /// </summary>
        private decimal deltaElastiqueDisplay = 0m;

        public decimal DeltaElastiqueDisplay { get { return deltaElastiqueDisplay; } }


        public bool calcAuto(bool selectedByCoeff, int deltaRank)
        {
            decimal coeffLotComp = 1M;
            if (selectedByCoeff)
            {
                var d = deltaRank == 0 ? 1 : deltaRank;
                coeffLot = (decimal)d / (decimal)lot;
                if (coeffLot > 1)
                    coeffLot = 1;
                coeffLotDisplay = coeffLot;
            }
            else if (alwaysUseCoeffLot)
            {
                coeffLotComp = 1 - deltaRank / (decimal)lot;
                if (coeffLotComp < 0)
                    coeffLotComp = 0;
                coeffLotDisplay = coeffLotComp;
            }
            var coeffVirt0 = coeffVirt;
            if (coeffOldSwap)
            {
                coeffVirt = coeffOld;
            }
            var _c0 = coeffVirt;
            _v0 = v;
            var oldSameDirection = Math.Abs(_nbSameDirection);

            // vv = v;
            var dv0 = dv;
            var _a0 = a;

            if (-_nbSameDirectionBox > serialm)
                _nbSameDirectionBox = -serialm;
            if (_nbSameDirectionBox > serialp)
                _nbSameDirectionBox = serialp;

            if (-_nbElastique > serialElastique)
                _nbElastique = -serialElastique;
            if (_nbElastique > serialElastique)
                _nbElastique = serialElastique;


            if (-_nbElastique2 > serialElastique)
                _nbElastique2 = -serialElastique;
            if (_nbElastique2 > serialElastique)
                _nbElastique2 = serialElastique;


            if (_nbAlt < 0)
                _nbAlt = 0;
            if (_nbAlt > serialAlt)
                _nbAlt = serialAlt;

            decimal ecart0 = System.Math.Max(_nbElastique, -_nbElastique2);

            var last = lastAutoDirection;
            var lastDelta_ = this.lastDelta;
            lastAutoDirection = selectedByCoeff;

            var deltaElastique1 = 0m;
            var deltaElastique2 = 0m;

            if (last.HasValue)
            {
                if (last != selectedByCoeff || (checkFall && selectedByCoeff))
                {
                    if (last != selectedByCoeff)
                    {
                        _nbAltHisto++;
                        _nbSameDirection = 0;
                        _nbAlt++;
                    }
                    else
                    {
                        _nbAltHisto = 0;
                    }

                    //if (_nbAltHisto > 1)
                    //{
                    if (selectedByCoeff)
                    {
                        deltaElastique1 = -coeffLot * getLimitedDelta(coeffElastique1dm, oldSameDirection, last != selectedByCoeff);
                        deltaElastique2 = -coeffLot * getLimitedDelta(coeffElastique2dm, oldSameDirection, last != selectedByCoeff);
                     

                        //_nbElastique -= coeffLot * getLimitedDelta(coeffElastique1dm, oldSameDirection); // rapportmp* coeffElastique1r;
                        //_nbElastique2 -= coeffLot * getLimitedDelta(coeffElastique2dm, oldSameDirection); // rapportmp* coeffElastique2;
                    }
                    else
                    {
                        var c = -1M;
                        if (last != selectedByCoeff)
                        {
                            // si coeff ~ 0 je dois avoir +1
                            // si coeff ~ 1 je dois avoir -1
                            c = 1 - 2 * coeffLot;
                        }


                        deltaElastique1 = c * coeffElastique1dp * coeffLotComp;
                        deltaElastique2 = c * coeffElastique2dp * coeffLotComp;
                        //_nbElastique += c * coeffElastique1dp * coeffLotComp;
                        //_nbElastique2 += c * coeffElastique2dp * coeffLotComp;
                    }

                    if (last != selectedByCoeff)
                    {
                        if (_nbAltHisto > 1)
                        {
                            if (currentStaticp > 1 && coeffStaticpRetour > 1)
                            {
                                currentStaticp /= coeffStaticpRetour;
                                if (currentStaticp < 1)
                                    currentStaticp = 1;
                            }
                            if (currentStaticm > 1 && coeffStaticmRetour > 1)
                            {
                                currentStaticm /= coeffStaticmRetour;
                                if (currentStaticm < 1)
                                    currentStaticm = 1;
                            }
                        }
                    }

                    else
                    {
                        if (coeffStaticpRetour > 1 && currentStaticp > coeffStaticpRetour)
                        {
                            currentStaticp /= coeffStaticpRetour;
                            if (currentStaticp < 1)
                                currentStaticp = 1;
                        }
                        currentStaticm *= coeffStaticm;
                    }



                    // }
                    if (_nbSameDirectionBox > 0 && selectedByCoeff)
                        _nbSameDirectionBox--;
                    if (_nbSameDirectionBox < 0 && !selectedByCoeff)
                        _nbSameDirectionBox++;

                }
                else
                {
                    _nbAlt--;
                    _nbAltHisto = 0;


                    if (selectedByCoeff)
                    {
                        _nbSameDirectionBox--;
                        // _nbSameDirection--;

                        deltaElastique1 = coeffLot * coeffElastique1sm;
                        deltaElastique2 = coeffLot * coeffElastique2sm;
                        //_nbElastique += coeffLot * coeffElastique1sm; // coeffElastique1* rapportmp;
                        //_nbElastique2 += coeffLot * coeffElastique2sm; // coeffElastique2r* rapportmp;
                    }
                    else
                    {
                        deltaElastique1 = coeffLotComp * coeffElastique1sp;
                        deltaElastique2 = coeffLotComp * coeffElastique2sp;
                        //_nbElastique += coeffLotComp * coeffElastique1sp;
                        //_nbElastique2 += coeffLotComp * coeffElastique2sp;
                        _nbSameDirectionBox++;
                        // _nbSameDirection++;
                    }
                }

                //if (selectedByCoeff)
                //{
                //    _nbSameDirection -= getLimitedDelta(coeffElastique1dm, oldSameDirection); 
                //}
                //else
                //{
                //    _nbSameDirection++;
                //}
            }

            if (!auto)
                return false;

            var lastProduct = linkProduct;


            var c0 = v;
            //verifHaut();
            //verifBas();
            _nbElastique += deltaElastique1;
            _nbElastique2 += deltaElastique2;

            if (Math.Abs(deltaElastique1) > Math.Abs(deltaElastique2))
                deltaElastiqueDisplay = deltaElastique1;
            else
                deltaElastiqueDisplay = deltaElastique2; 

            if (last.HasValue)
            {
                var aux = a;


                bool applyanti = false;

                lastDelta = null;
                if (last != selectedByCoeff) // if (_nbAltHisto > 1)
                {
                    if (_nbAlt > serialAlt || _nbElastique2 < -serialElastique)
                    {
                        lastDelta = false;
                    }
                }
                else if (checkFall && selectedByCoeff)
                {
                }
                else
                {

                    // bof. pour l'instant seul currentStaticm est géré
                    if (selectedByCoeff)
                    {
                        if (coeffStaticpRetour > 1 && currentStaticp > coeffStaticpRetour)
                        {
                            currentStaticp /= coeffStaticpRetour;
                            if (currentStaticp < 1)
                                currentStaticp = 1;
                        }
                        currentStaticm *= coeffStaticm;

                    }
                    else if (coeffStaticRetourLarge)
                    {

                        if (currentStaticm > 1)
                        {
                            currentStaticm /= coeffStaticmRetour;
                            if (currentStaticm < 1)
                                currentStaticm = 1;
                        }

                        //if (coeffStaticmRetour > 1 && currentStaticm > coeffStaticmRetour)
                        //    currentStaticm /= coeffStaticmRetour;
                        currentStaticp *= coeffStaticp;
                    }
                }
                if (false != lastDelta)
                {

                    if (selectedByCoeff && -_nbSameDirectionBox > serialm)
                        applyanti = true;
                    else if (!selectedByCoeff && _nbSameDirectionBox > serialp)
                        applyanti = true;
                    else if (_nbElastique > serialElastique)
                        applyanti = true;
                    //else if (_nbElastique2 > serialElastique)
                    //    applyanti = true;

                    if (applyanti)
                        lastDelta = true;
                    else
                        lastDelta = null;
                    if (_linkconv)
                        calcConv();


                }



                bool onAugmente = lastDelta.HasValue && (lastDelta_ == null || lastDelta_ == lastDelta);
                if (onAugmente)
                {
                    a *= (1 + aa * coeffLotComp);
                    //verifHaut();
                    //verifBas();
                }
                else
                {
                    decimal ecart1 = System.Math.Max(_nbElastique, -_nbElastique2);


                    if (ecart1 > 0 && ecart1 < ecart0)
                    {
                        if (a > aepsilon)
                        {
                            a /= (1 + aa * coeffLot);
                            if (a < aepsilon)
                                a = aepsilon;
                        }

                        //verifHaut();
                        //verifBas();

                    }
                }

                //if (c0 == v || !onAugmente)
                //{

                //    var ecart1 = System.Math.Max(System.Math.Abs(_nbElastique), System.Math.Abs(_nbElastique2));
                //    if (ecart1 < ecart0)
                //    {
                //        a /= (1 + aa);
                //        if (a < aepsilon)
                //            a = aepsilon;

                //    }
                //}
                //else
                //{
                //    a *= (1 + aa);
                //    verifHaut();
                //    verifBas();

                //}


                // vv += pas * a;



                verifMaxA();

                if (lastDelta.HasValue)
                {
                    //verifMaxA();
                    if (false == lastDelta)
                    {
                        var _v = _v0 - pas * a;
                        var limit = _v0 / vv;
                        if (_v < limit)
                        {
                            _v = limit;
                            a = (_v0 - _v) / pas;
                        }
                        v = _v;

                        if (_linkconv)
                            calcConv();

                    }
                    else if (true == lastDelta)
                    {

                        var _v = _v0 + pas * a;
                        var limit = _v0 * vv;

                        if (_v > limit)
                        {
                            _v = limit;
                            a = (_v - _v0) / pas;
                        }

                        v = _v;
                    }

                    //  verifMaxV();
                    //verifHaut();
                    //verifBas();
                }


                verifMaxV();


                misc.log("convergence {0:0.##}->{1:0.######}", c0, v);
                misc.log("evol convergence {0:0.######}->{1:0.######}", aux, a);
            }

            string montee = selectedByCoeff ? "down" : "up";

            verifBas();
            var _rapportTmp = rapportmp;
            if (selectedByCoeff)
            {
                _rapportTmp = coeffLot * getLimitedDelta(_rapportTmp, oldSameDirection, last != selectedByCoeff);
                //if (rapportmp > 1)
                //{
                //    if (oldSameDirection > rapportmp)
                //    {
                //        _rapportTmp = 2 * rapportmp - oldSameDirection;
                //        if (_rapportTmp < 1)
                //            _rapportTmp = 1;
                //    }
                //}

                coeffVirt -= pas * v * _rapportTmp / currentStaticp;
                _nbSameDirection -= _rapportTmp;
            }
            else
            {
                coeffVirt += coeffLotComp * pas * v / currentStaticm;
                _nbSameDirection++;
            }


            if (selectedByCoeff)
            {
                verifMaxA();
                verifMaxV();

                verifBas();
                coeffVirt = _c0 - pas * v * _rapportTmp / currentStaticp;
                verifBas();
            }




            //verifHaut();
            //verifBas();
            dx = Math.Abs(coeffVirt - _c0);
            if (_c0 > 0)
                dcoeff = 1 + dx / _c0;

            if (selectedByCoeff)
                dx /= _rapportTmp;


            dv = Math.Abs(v - _v0);
            if (dv == 0)
                dv = dv0 * (a / _a0);



            // da = Math.Abs(a - _a0);
            misc.log("{0} {1:0.### ###} {2:0.### ###}->{3:0.### ###}", montee, dx, c0, coeffVirt);


            histo.Add(new HistoValue(coeffVirt, dx, a, v / currentStaticm, dv, v));

            checkCoeffOld();

            if (coeffOldSwap)
            {
                coeffOld = coeffVirt;
                coeffVirt = coeffVirt0;
            }

            return dx != 0;
        }

    }
}
]]></content>
  </file>
</db>
