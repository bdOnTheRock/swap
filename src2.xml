<db path="C:\bernard\db1\db4">
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des données morceux dupliqués 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;
        private bool goCompact = true;
        private bool _firstConsolid = true;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private PlayList root = new PlayList("root", null);
        public PlayList Root { get { return root; } }
        private PlayList musique;
        private PlayList classement;
        private PlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new PlayList("musique", root);
            classement = new PlayList("classement", root);
            listes = new PlayList("listes", root);
            albums = new Albums(this);
        }
        /// <summary>
        /// Lance le compactage à la prochaine génération
        /// </summary>
        public void GoCompact() { goCompact = true; }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        //public void buildClassTree()
        //{
        //    buildClassTree(classement);
        //}


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public Albums Albums { get { return albums; } }
        public void invalidateAlbums() { _firstConsolid = false; albums.invalidateAll(true);  }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList, bool makeSort)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                DateTime now = DateTime.Now;
                DateTime debut = now;
                allClassed.Clear();
                allClassedInAlbumEnabled.Clear();
                m_listTrackClassed.Clear(); 
                if (_firstConsolid)
                {
                    listPiece.Clear();
                    listPieceInAlbum.Clear();
                    all.Clear(); 

                    // albums = new Albums(this);
                    VirtualPiece.init();
                   
                   
                 
                    //  htIds = new BgDict<int, Piece>();
                    foreach (ITrackNativeDates track in dbList)
                    {

                        if (!track.isPodcast)
                        {
                            Piece piece = null;
                            int pieceId = track.PieceId;
                            if (htIds.ContainsKey(pieceId))
                            {
                                piece = htIds[pieceId];
                                piece.initRank();
                            }
                            else
                            {
                                piece = new Piece(track);
                                htIds.Add(pieceId, piece);
                            }

                            all.Add(piece);

                        }
                    }
                    // link
                    foreach (Piece piece in all)
                    {
                        int parentId = piece.PieceParentId;
                        if (parentId > 0)
                        {
                            piece.Parent = htIds[parentId];
                        }
                    }

                    // liste FORT + albums

                    albums.checkBuild();
                    logger.log("build albums");
                    foreach (Piece piece in all)
                    {
                        if (piece.Parent == null)
                        {
                            listPiece.Add(piece);
                            foreach (Piece p in piece)
                            {
                                if (albums.check(p))
                                    listPieceInAlbum.Add(p);
                            }
                        }
                    }

                    var confGen = CConf.ConfGen;
                    var min = confGen.AlbumMin;

                    if (_albumVirtual && _firstConsolid)
                    {
                        logger.log("build albums virtuels");
                        var listCandidat = new List<Piece>();
                        var dictTmp = new BgDictString<Album>();
                        foreach (Piece piece in all)
                        {
                            if (piece.Parent == null)
                            {
                                piece.buildVirtualAlbums(listCandidat);
                            }
                        }
                        foreach (Piece p in listCandidat)
                            albums.checkVirtual(p, dictTmp);




                        min = confGen.PathVirtualMin;
                        if (min > 1)
                        {
                            // Suppression des albums virtuel par répertoire avec trop peu de morceaux
                            foreach (var key in new List<string>(dictTmp.Keys))
                            {
                                var a = dictTmp[key];
                                if (a.Virtual && !a.VirtualByArtist)
                                {
                                    if (a.Count < min)
                                        dictTmp.Remove(key);
                                }
                            }
                        }

                        if (confGen.ArtistVirtual)
                        {
                            min = confGen.AristVirtualMin;
                            if (min > 1)
                            {
                                // Suppression des albums artiste avec trop peu de morceaux
                                foreach (var key in new List<string>(dictTmp.Keys))
                                {
                                    var a = dictTmp[key];
                                    if (a.VirtualByArtist)
                                    {
                                        if (a.Count < min)
                                            dictTmp.Remove(key);

                                    }
                                }
                            }
                        }





                        var listAlbums = new List<Album>(dictTmp.Values);

                        listAlbums.Sort(new VirtualAlbumComparer());
                        albums.checkVirtuals(listAlbums, listPieceInAlbum);

                    }

                    albums.buildDone();

                    // Suppression des albums avec trop peu de morceaux
                    min = confGen.AlbumMin;
                    if (min > 1)
                    {
                        // Suppression des albums standards avec trop peu de morceaux
                        var dict = albums.Dict;
                        foreach (var key in new List<string>(dict.Keys))
                        {
                            var a = dict[key];
                            if (!a.Virtual)
                            {
                                if (a.Count < min)
                                    dict.Remove(key);
                            }
                        }
                    }

                }

                now = DateTime.Now; 

                StackAlbum.Instance.init(all);

                misc.log("StackAlbum.Instance.init(all); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                misc.log("allClassed; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 

                if (_firstConsolid)
                    albums.sortVirtual();

                misc.log("makeConsolid:init; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now; 
                Ranking(makeSort);
                misc.log("makeConsolid:fin; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now; 
            }
            finally
            {
                lock (_lock)
                {
                    _firstConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece); // addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbum)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif

        }

        public void buildLists(PlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                // mine.add(sub);
                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }


            //foreach (PlComponent c in ext)
            //{
            //    if (c is CPlayList)
            //    {
            //        var subExt = c as CPlayList;
            //        var sub = new CPlayList(subExt.Name, mine);
            //        sub.ID = subExt.ID;
            //        // mine.add(sub);
            //        buildList(sub, subExt);
            //    }
            //    else
            //    {
            //        var t = c as IFile;
            //        var piece = htIds[t.PieceId];
            //        mine.add(new TrackList(piece));
            //    }
            //}
        }



        internal Album getAlbum(Piece track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort)
        {
            albums.buildStack(makeSort);
            QRanking();
            LRanking();
            QLRanking();


            var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");


            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);
            // if (makeSort)
            albums.makeSort(_firstConsolid);
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");
            DateTime now = DateTime.Now;
            DateTime debut = now; 



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }

            misc.log("piece.Rank.init(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 


            //on ordonne les morceaux top-down => sont privilégiés les plus en vue
            listPiece.Sort(l_pieceComparer);

            misc.log("listPiece.Sort(l_pieceComparer); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 

            //compactage de la liste en tenant compte des mieux notés
            m_list = new CListPiece(listPiece);


            misc.log(" m_list = new CListPiece(listPiece); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 
            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now; 
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }
            logger.log("fin : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now; 
           // Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

            logger.log("total QRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now; 

            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }

            logger.log("total LRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualité +longueur en cas d'égalité
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now; 

            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }
            if (Piece.Compact)
            {
                if (goCompact || CConf.ConfGen.AlbumSort.compactAny)
                {
                    goCompact = false;
                    var l = new List<Piece>(this.listPiece);
                    l.Sort(new CPieceComparerByQualityAndLength2());
                    new Condenseur(m_listQL).gener2();
                }
            }

            //if (CConf.Condensation)
            //{
            //    var l = new List<Piece>(this.listPiece);
            //    l.Sort(new CPieceComparerByQualityAndLength2());
            //    new Condenseur(m_listQL).gener2();

            //}


            logger.log("total QLRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }


        private static volatile object _lockStat = new object();
        //   private static volatile object _lockStat2 = new object();
        private static bool buildingStat;
        const string BUILDING_STATE = @"..\building.txt";
        const string LOADING_EXCEL = @"..\busyExcel.txt";

        private void _buildStat(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 1");
                    return;
                }


                try
                {
                    if (File.Exists(LOADING_EXCEL))
                    {
                        string content = File.ReadAllText(LOADING_EXCEL);
                        misc.log(content);
                        if (content.Contains("BUSY"))
                        {
                            return;
                        }
                    }
                }
                catch (Exception ex)
                {
                    misc.logError("Impossible de lire le fichier lock excel", ex);
                    return;
                }

                buildingStat = true;
            }



            try
            {
                //bool ok = Monitor.TryEnter(_lockStat2, 60 * 1000);
                //if (!ok)
                //{
                //    misc.log("Pas pu entrer pour générer les stats !!!!!!");
                //    return;
                //}


                File.WriteAllText(BUILDING_STATE, "BUILDING");
                bool generDistrib = step % 10 == 0;

                if (_albumSortMode.createCourant)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(m_listQL).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(m_listQL) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                lock (_lockStat)
                {
                    buildingStat = false;
                    File.WriteAllText(BUILDING_STATE, "FREE");
                }
                if (rappel != null)
                    rappel();
            }
        }

        public void builStats(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 0");
                    return;
                }

            }
          //  _buildStat(rappel); 
            new Thread(() => _buildStat(rappel)).Start();

        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table m�tier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\stat\StatBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.stat
{
    class StatBuilder
    {


        private List<Piece> list;
        private StreamWriter st;
        // private int level;
        //private int sub;
        //private int delta;

        private decimal coeff;

        public const int VAL_MAX = 6000;
        private int min;
        private int nbCurrent;
        private int index;
        private Regex reg = new Regex("[6789]");
        public const int NB_MEDIANE = 36;
        private StatConteneur conteneur = new StatConteneur();
        public StatBuilder(IEnumerable<Piece> list)
        {
            this.list = new List<Piece>(list);
            this.list.Reverse();
        }

        private void record()
        {
            st.Write((double)min / 1000);
            st.Write("\t");
            st.WriteLine(nbCurrent);
        }
        private void record3()
        {
            var _min = (decimal)min / 100000m;
            st.Write(_min);
            st.Write("\t");
            var v = (decimal)nbCurrent / coeff;
            st.Write(v.ToString("0.#####"));

            st.Write("\t");
            decimal cur = Piece.getRapport(_min);
            st.WriteLine(cur.ToString("0.######"));
        }

        private void record4()
        {
            var _min = (decimal)min / (10000 * loupeCoeff);
            st.Write(_min);
            st.Write("\t");
            double v = (double)nbCurrent / (double)coeff;
            st.Write(v.ToString("0.#####"));

            st.Write("\t");
            decimal cur = Piece.getRapport(_min);
            st.WriteLine(cur.ToString("0.######"));

        }

        //private void record2()
        //{
        //    conteneur.record(level, sub, min, nbCurrent);
        //}

        //public void gener()
        //{
        //    gener("stats.txt");
        //}

        //public void gener0()
        //{
        //    gener0("stats.txt");
        //}


        //public void gener0(string file)
        //{
        //    decimal EPSILON = 0.00000001m;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;
        //    using (Stream stream = new FileStream(@"..\" + file, FileMode.Create))
        //    {
        //        using (st = new StreamWriter(stream, Encoding.ASCII))
        //        {
        //            try
        //            {
        //                int deltaBase = 10000;
        //                for (int level = 0; level < 4; level++)
        //                {
        //                    deltaBase /= 10;
        //                    int nb = VAL_MAX / deltaBase;
        //                    //  var tab = new int[nb]; 
        //                    for (int sub = 3; sub >= 1; sub--)
        //                    {
        //                        // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
        //                        var delta = sub * deltaBase;
        //                        //   nb =(int)( 6 / sub * Math.Pow(10, 4 - level)); 
        //                        // level = 1 =>600

        //                        // parcourir la liste triée
        //                        // pour chaque pièce comparer classNameAndRating
        //                        int index = 0;
        //                        st.WriteLine();
        //                        st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub);

        //                        min = 0;
        //                        int max = delta;


        //                        var current = list[index].ClassementValueDecimal0;
        //                        nbCurrent = 0;

        //                        bool _end = false;
        //                        while (true)
        //                        {
        //                            if (min >= VAL_MAX)
        //                                break;

        //                            if (current * 1000 + EPSILON >= max || _end)
        //                            {
        //                                //if (!reg.IsMatch(min.ToString()))
        //                                record();

        //                                min = max;
        //                                while (reg.IsMatch(min.ToString()))
        //                                    min += deltaBase;

        //                                max = min + delta;
        //                                nbCurrent = 0;

        //                            }
        //                            else
        //                            {
        //                                nbCurrent++;
        //                                index++;
        //                                if (index >= list.Count)
        //                                {

        //                                    _end = true;
        //                                    continue;
        //                                }
        //                                current = list[index].ClassementValueDecimal0;
        //                            }
        //                        }

        //                    }
        //                }
        //            }
        //            catch (Exception ex)
        //            {
        //                Console.WriteLine(ex);
        //            }
        //            st.WriteLine();

        //            try
        //            {
        //                //phase deux déterminer les tantièmes
        //                //1,2,3..10,20,30..100,
        //                double nbTot = count;
        //                double portion = nbTot;
        //                int K = 1;
        //                decimal valueFrom = 0;

        //                decimal classTo = 6.0m;
        //                decimal classFrom = 0.0m;

        //                List<Tranche> tranches = new List<Tranche>();
        //                const int DETAIL = 1000;

        //                for (int i = 0; i < 6 * DETAIL; i++)
        //                {
        //                    if (reg.IsMatch(i.ToString()))
        //                        continue;
        //                    tranches.Add(new Tranche(i));
        //                }
        //                for (int level = 1; level < 2; level++)
        //                {



        //                    for (int div = 2; div <= NB_MEDIANE; div++)
        //                    {


        //                        //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
        //                        valueFrom = 0;
        //                        int iFrom = 0;
        //                        int iTo = count - 1;
        //                        portion = nbTot / div;
        //                        classFrom = 0;
        //                        for (int sub = 1; sub <= div; sub++)
        //                        {

        //                            double to = sub * portion;
        //                            iTo = 0;
        //                            if (to > 0)
        //                                iTo = (int)to - 1;
        //                            if (iTo >= list.Count)
        //                                iTo = list.Count - 1;
        //                            if (iTo < 0)
        //                                iTo = 0;
        //                            decimal rapport = list[iTo].RapportClassementDecimal;
        //                            classTo = list[iTo].ClassementValueDecimal0;


        //                            //st.Write(classFrom);
        //                            ////st.Write("\t");
        //                            //st.Write(classTo);
        //                            //st.Write("\t");
        //                            ////st.Write(valueFrom);
        //                            ////
        //                            //st.Write(rapport);
        //                            //st.Write("\t");


        //                            //int nb = (iTo - iFrom + 1);                          
        //                            //st.Write(nb);
        //                            //st.Write("\t");
        //                            decimal densite = 0;
        //                            if (rapport != valueFrom)
        //                                densite = 1.0m / ((rapport - valueFrom) * (decimal)div);
        //                            //st.Write("\t");
        //                            //st.Write(densite);
        //                            //st.WriteLine(); 

        //                            for (int i = 0; i < 6 * DETAIL; i++)
        //                            {
        //                                if (i < classFrom * DETAIL)
        //                                    continue;
        //                                if (i > classTo * DETAIL)
        //                                    continue;
        //                                if (reg.IsMatch(i.ToString()))
        //                                    continue;
        //                                Tranche tranche = tranches.Find(t => t.index == i);
        //                                tranche.densites[div - 1] = densite;
        //                            }

        //                            valueFrom = rapport;
        //                            iFrom = iTo;
        //                            classFrom = classTo;
        //                        }
        //                    }
        //                    K *= 10;
        //                }

        //                st.WriteLine();
        //                st.Write("\t");
        //                st.Write("\t");
        //                st.Write("\t");

        //                for (int i = 0; i < NB_MEDIANE; i++)
        //                {
        //                    st.Write(i + 2);
        //                    st.Write("\t");
        //                    st.Write(i + 2);
        //                    st.Write("\t");
        //                }
        //                Tranche last = null;
        //                foreach (Tranche tranche in tranches)
        //                {
        //                    st.WriteLine();
        //                    st.Write((double)tranche.index / DETAIL);
        //                    st.Write("\t");

        //                    for (int i = 0; i < NB_MEDIANE; i++)
        //                    {
        //                        var densite = tranche.densites[i];
        //                        st.Write(densite);
        //                        st.Write("\t");
        //                        if (last == null || last.densites[i] != densite)
        //                        {
        //                            st.Write(densite);
        //                        }
        //                        else
        //                            st.Write(0);
        //                        st.Write("\t");
        //                    }
        //                    last = tranche;
        //                }

        //            }
        //            catch (Exception e)
        //            {
        //                Console.WriteLine(e);
        //            }
        //        }
        //    }
        //}


        //public void gener3(bool generDistrib)
        //{
        //    gener3("stats3.txt", generDistrib);
        //}
        public void gener3(string file, bool generDistrib)
        {
            decimal EPSILON = 0.00000001m;
            int VAL_MAX = StatBuilder.VAL_MAX * 100;
            int count = list.Count;
            if (count == 0)
                return;
            while (true)
            {
                try
                {
                    misc.log("gener " + file);


                    var filename = Path.GetFileNameWithoutExtension(file);
                    var ext = Path.GetExtension(file);
                    string _file = @"..\" + filename + "_med" + ext;
                    string f0 = @"..\" + file;
                    string f0tmp = f0 + ".tmp";
                    string f1tmp = _file + ".tmp";
                    int NBLINE = 65500;
                    int nbLine = 0;
                    using (Stream stream = new FileStream(f0tmp, FileMode.Create))
                    {
                        using (st = new StreamWriter(stream, Encoding.ASCII))
                        {
                            try
                            {
                                int deltaBase = 1000000;
                                for (int level = 5; level >= 0; level--)
                                {
                                    if (nbLine >= NBLINE) break;
                                    deltaBase /= 10;
                                    int nb = VAL_MAX / deltaBase;

                                    for (int sub = 3; sub >= 1; sub--)
                                    {
                                        if (nbLine >= NBLINE) break;
                                        coeff = Math.Pow(6, level - 1) * (decimal)sub;
                                        // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                        var delta = sub * deltaBase;
                                        index = 0;
                                        st.WriteLine(); nbLine++;
                                        st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub); nbLine++;

                                        min = 0;
                                        int max = delta;


                                        decimal current = list[index].ClassementValueDecimal0;
                                        nbCurrent = 0;

                                        bool _end = false;
                                        while (true)
                                        {
                                            if (min >= VAL_MAX)
                                                break;

                                            if (current * 100000 + EPSILON >= max || _end)
                                            {

                                                record3();

                                                nbLine++;
                                                if (nbLine >= NBLINE) break;


                                                min = max;
                                                while (reg.IsMatch(min.ToString()))
                                                    min += deltaBase;

                                                max = min + delta;
                                                nbCurrent = 0;

                                            }
                                            else
                                            {
                                                nbCurrent++;
                                                index++;
                                                if (index >= list.Count)
                                                {

                                                    _end = true;
                                                    continue;
                                                }
                                                current = list[index].ClassementValueDecimal0;
                                            }
                                        }

                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine(ex);
                                throw;
                            }

                        }
                    }

                    File.Copy(f0tmp, f0, true);
                    File.Delete(f0tmp);

                    misc.log("fin gener " + file);

                    if (!generDistrib)
                        return;

                    misc.log("gener distrib " + _file);

                    using (FileStream stream2 = new FileStream(f1tmp, FileMode.Create))
                    {
                        using (st = new StreamWriter(stream2, Encoding.UTF8))
                        {

                            try
                            {
                                //phase deux déterminer les tantièmes
                                //1,2,3..10,20,30..100,
                                double nbTot = count;
                                double portion = nbTot;
                                int K = 1;
                                decimal valueFrom = 0;

                                decimal classTo = 6.0m;
                                decimal classFrom = 0.0m;

                                List<Tranche> tranches = new List<Tranche>();
                                Dict<int, Tranche> dict = new Dict<int, Tranche>();
                                const int DETAIL = 10000;

                                for (int i = 0; i < 6 * DETAIL; i++)
                                {
                                    if (reg.IsMatch(i.ToString()))
                                        continue;
                                    var tranche = new Tranche(i);
                                    tranches.Add(tranche);
                                    dict[i] = tranche;
                                }
                                for (int level = 1; level < 2; level++)
                                {



                                    for (int div = 2; div <= NB_MEDIANE; div++)
                                    {


                                        //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                        valueFrom = 0;
                                        int iFrom = 0;
                                        int iTo = count - 1;
                                        portion = nbTot / div;
                                        classFrom = 0;
                                        for (int sub = 1; sub <= div; sub++)
                                        {

                                            double to = sub * portion;
                                            iTo = 0;
                                            if (to > 0)
                                                iTo = (int)to - 1;
                                            if (iTo >= list.Count)
                                                iTo = list.Count - 1;
                                            if (iTo < 0)
                                                iTo = 0;
                                            decimal rapport = list[iTo].RapportClassementDecimal;
                                            classTo = list[iTo].ClassementValueDecimal0;


                                            //st.Write(classFrom);
                                            ////st.Write("\t");
                                            //st.Write(classTo);
                                            //st.Write("\t");
                                            ////st.Write(valueFrom);
                                            ////
                                            //st.Write(rapport);
                                            //st.Write("\t");


                                            //int nb = (iTo - iFrom + 1);                          
                                            //st.Write(nb);
                                            //st.Write("\t");
                                            decimal densite = 0m;
                                            if (rapport != valueFrom)
                                                densite = 1.0m / ((rapport - valueFrom) * div);
                                            //st.Write("\t");
                                            //st.Write(densite);
                                            //st.WriteLine(); 

                                            for (int i = 0; i < 6 * DETAIL; i++)
                                            {
                                                if (i < classFrom * DETAIL)
                                                    continue;
                                                if (i > classTo * DETAIL)
                                                    continue;
                                                if (reg.IsMatch(i.ToString()))
                                                    continue;
                                                Tranche tranche = dict[i];
                                                //  Tranche tranche = tranches.Find(t => t.index == i);
                                                tranche.densites[div - 1] = densite;
                                            }

                                            valueFrom = rapport;
                                            iFrom = iTo;
                                            classFrom = classTo;
                                        }
                                    }
                                    K *= 10;
                                }

                                st.WriteLine();
                                st.Write("\t");
                                st.Write("\t");
                                st.Write("\t");

                                for (int i = 0; i < NB_MEDIANE; i++)
                                {
                                    st.Write(i + 2);
                                    st.Write("\t");
                                    st.Write(i + 2);
                                    st.Write("\t");
                                }
                                Tranche last = null;
                                foreach (Tranche tranche in tranches)
                                {
                                    st.WriteLine();
                                    st.Write((double)tranche.index / DETAIL);
                                    st.Write("\t");

                                    for (int i = 0; i < NB_MEDIANE; i++)
                                    {
                                        var densite = tranche.densites[i];
                                        st.Write(densite);
                                        st.Write("\t");
                                        if (last == null || last.densites[i] != densite)
                                        {
                                            st.Write(densite);
                                        }
                                        else
                                            st.Write(0);
                                        st.Write("\t");
                                    }
                                    last = tranche;
                                }

                            }
                            catch (Exception e)
                            {
                                Console.WriteLine(e);
                                throw;
                            }
                        }

                    }

                    File.Copy(f1tmp, _file, true);
                    File.Delete(f1tmp);

                    misc.log("fin gener distrib " + _file);
                    break;
                }
                catch (Exception e)
                {
                    misc.log(e.ToString());
                }
            }
        }

        private int loupe;
        private decimal loupeCoeff;
        public int Loupe { set { loupe = value; loupeCoeff = pdb.util.Math.Pow(1000, loupe); } }
        public void gener4(string file)
        {
            decimal EPSILON = 0.00000000001m / loupeCoeff;
            decimal VAL_MAX = StatBuilder.VAL_MAX * 10; // on laisse inchangé pour faire seulement une partie
            int count = list.Count;
            //if (count == 0)
            //    return;
            // misc.log("gener " + file + loupe);

            while (true)
            {
                try
                {
                    var filename = Path.GetFileNameWithoutExtension(file);
                    var ext = Path.GetExtension(file);
                    var str = "";
                    if (loupe > 0)
                        str = loupe.ToString();
                    string _file = @"..\" + filename + "_med" + str + ext;
                    string f0 = @"..\" + filename + str + ext;

                    misc.log("gener " + f0);

                    string f0tmp = f0 + ".tmp";
                    //   string f1tmp = _file + ".tmp";
                    using (Stream stream = new FileStream(f0tmp, FileMode.Create))
                    {
                        using (st = new StreamWriter(stream, Encoding.ASCII))
                        {
                            try
                            {
                                int deltaBase = (int)(100000);
                                for (int level = 4; level >= 0; level--)
                                {
                                    deltaBase /= 10;
                                    //int nb = VAL_MAX / deltaBase;

                                    for (int sub = 3; sub >= 1; sub--)
                                    {
                                        coeff = Math.Pow(6, level - 3 * loupe) * sub; /// loupeCoeff;
                                        // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                        int delta = (int)(sub * deltaBase);
                                        index = 0;
                                        st.WriteLine();
                                        st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub);

                                        min = 0;
                                        var max = delta;

                                        decimal current = 0m;
                                        if (count > 0)
                                            current = list[index].ClassementValueDecimal;
                                        nbCurrent = 0;

                                        bool _end = false;
                                        while (true)
                                        {
                                            if (min >= VAL_MAX)
                                                break;

                                            if (min > 230)
                                            {
                                            }

                                            if (current * 10000 * loupeCoeff + EPSILON >= max || _end)
                                            {

                                                record4();

                                                min = max;
                                                while (reg.IsMatch(min.ToString()))
                                                    min += (int)deltaBase;

                                                max = min + delta;
                                                nbCurrent = 0;

                                            }
                                            else
                                            {
                                                nbCurrent++;
                                                index++;
                                                if (index >= count)
                                                {

                                                    _end = true;
                                                    continue;
                                                }

                                                current = list[index].ClassementValueDecimal;
                                                if (current > 0)
                                                {
                                                }
                                            }
                                        }

                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine(ex);
                                throw;
                            }

                        }
                    }

                    File.Copy(f0tmp, f0, true);
                    File.Delete(f0tmp);

                    misc.log("fin gener " + f0);
                    /*
                    if (!generDistrib)
                        return;

                    misc.log("gener distrib " + _file);

                    using (FileStream stream2 = new FileStream(f1tmp, FileMode.Create))
                    {
                        using (st = new StreamWriter(stream2, Encoding.UTF8))
                        {

                            try
                            {
                                //phase deux déterminer les tantièmes
                                //1,2,3..10,20,30..100,
                                double nbTot = count;
                                double portion = nbTot;
                                int K = 1;
                                decimal valueFrom = 0;

                                decimal classTo = 6.0m;
                                decimal classFrom = 0.0m;

                                List<Tranche> tranches = new List<Tranche>();
                                Dict<int, Tranche> dict = new Dict<int, Tranche>();
                                const int DETAIL = 10000;

                                for (int i = 0; i < 6 * DETAIL; i++)
                                {
                                    if (reg.IsMatch(i.ToString()))
                                        continue;
                                    var tranche = new Tranche(i);
                                    tranches.Add(tranche);
                                    dict[i] = tranche;
                                }
                                for (level = 1; level < 2; level++)
                                {



                                    for (int div = 2; div <= NB_MEDIANE; div++)
                                    {


                                        //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                        valueFrom = 0;
                                        int iFrom = 0;
                                        int iTo = count - 1;
                                        portion = nbTot / div;
                                        classFrom = 0;
                                        for (sub = 1; sub <= div; sub++)
                                        {

                                            double to = sub * portion;
                                            iTo = 0;
                                            if (to > 0)
                                                iTo = (int)to - 1;
                                            if (iTo >= list.Count)
                                                iTo = list.Count - 1;
                                            if (iTo < 0)
                                                iTo = 0;
                                            decimal rapport = list[iTo].RapportClassementDecimal;
                                            classTo = list[iTo].ClassementValueDecimal;


                                            //st.Write(classFrom);
                                            ////st.Write("\t");
                                            //st.Write(classTo);
                                            //st.Write("\t");
                                            ////st.Write(valueFrom);
                                            ////
                                            //st.Write(rapport);
                                            //st.Write("\t");


                                            //int nb = (iTo - iFrom + 1);                          
                                            //st.Write(nb);
                                            //st.Write("\t");
                                            decimal densite = 0m;
                                            if (rapport != valueFrom)
                                                densite = 1.0m / ((rapport - valueFrom) * div);
                                            //st.Write("\t");
                                            //st.Write(densite);
                                            //st.WriteLine(); 

                                            for (int i = 0; i < 6 * DETAIL; i++)
                                            {
                                                if (i < classFrom * DETAIL)
                                                    continue;
                                                if (i > classTo * DETAIL)
                                                    continue;
                                                if (reg.IsMatch(i.ToString()))
                                                    continue;
                                                Tranche tranche = dict[i];
                                                //  Tranche tranche = tranches.Find(t => t.index == i);
                                                tranche.densites[div - 1] = densite;
                                            }

                                            valueFrom = rapport;
                                            iFrom = iTo;
                                            classFrom = classTo;
                                        }
                                    }
                                    K *= 10;
                                }

                                st.WriteLine();
                                st.Write("\t");
                                st.Write("\t");
                                st.Write("\t");

                                for (int i = 0; i < NB_MEDIANE; i++)
                                {
                                    st.Write(i + 2);
                                    st.Write("\t");
                                    st.Write(i + 2);
                                    st.Write("\t");
                                }
                                Tranche last = null;
                                foreach (Tranche tranche in tranches)
                                {
                                    st.WriteLine();
                                    st.Write((double)tranche.index / DETAIL);
                                    st.Write("\t");

                                    for (int i = 0; i < NB_MEDIANE; i++)
                                    {
                                        var densite = tranche.densites[i];
                                        st.Write(densite);
                                        st.Write("\t");
                                        if (last == null || last.densites[i] != densite)
                                        {
                                            st.Write(densite);
                                        }
                                        else
                                            st.Write(0);
                                        st.Write("\t");
                                    }
                                    last = tranche;
                                }

                            }
                            catch (Exception e)
                            {
                                Console.WriteLine(e);
                            }
                        }

                    }

                    File.Copy(f1tmp, _file, true);
                    File.Delete(f1tmp);

                    misc.log("fin gener distrib " + _file);
                     * 
                     * */

                    break;
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }

            }
        }

        //public void gener(string file)
        //{
        //    int count = list.Count;
        //    if (count == 0)
        //        return;
        //    decimal EPSILON = 0.00000001m;

        //    var filename = Path.GetFileNameWithoutExtension(file);
        //    var ext = Path.GetExtension(file);
        //    string _file = @"..\" + filename + "2" + ext;
        //    using (Stream stream = new FileStream(_file, FileMode.Create))
        //    {
        //        using (pdb.util.TextWriter st = new pdb.util.TextWriter(stream, Encoding.ASCII))
        //        {
        //            try
        //            {
        //                int deltaBase = 10000;
        //                for (level = 3; level >= 0; level--)
        //                {
        //                    deltaBase /= 10;
        //                    int nb = VAL_MAX / deltaBase;
        //                    //  var tab = new int[nb]; 
        //                    for (sub = 3; sub >= 1; sub--)
        //                    {
        //                        // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
        //                        var delta = sub * deltaBase;
        //                        int index = 0;


        //                        min = 0;
        //                        int max = delta;


        //                        var current = list[index].ClassementValueDecimal0;
        //                        nbCurrent = 0;

        //                        bool _end = false;
        //                        while (true)
        //                        {
        //                            if (min >= VAL_MAX)
        //                                break;

        //                            if (current * 1000 + EPSILON >= max || _end)
        //                            {
        //                                record2();

        //                                min = max;
        //                                while (reg.IsMatch(min.ToString()))
        //                                    min += deltaBase;

        //                                max = min + delta;
        //                                nbCurrent = 0;

        //                            }
        //                            else
        //                            {
        //                                nbCurrent++;
        //                                index++;
        //                                if (index >= list.Count)
        //                                {

        //                                    _end = true;
        //                                    continue;
        //                                }
        //                                current = list[index].ClassementValueDecimal0;
        //                            }
        //                        }

        //                    }
        //                }

        //                var datas = conteneur.Datas;

        //                var results = new List<ResultLine>();

        //                min = 0;
        //                while (true)
        //                {
        //                    while (reg.IsMatch(min.ToString()))
        //                        min++;
        //                    if (min >= VAL_MAX)
        //                        break;
        //                    results.Add(new ResultLine(min));
        //                    min++;
        //                }

        //                foreach (StatItem item in datas)
        //                {
        //                    var level = item.level;
        //                    var sub = item.sub;
        //                    var _min = item.min;
        //                    var nb = item.nb;
        //                    // Détermination de la colonne
        //                    int col = 3 * level + sub - 1;

        //                    // Détermination du coeff d'expansion / moyenne
        //                    int coeff = (int)Math.Pow(6, level) * sub;

        //                    ResultLine res0 = results.Find(r => r.min == _min);
        //                    int index0 = results.IndexOf(res0);

        //                    for (int i = 0; i < coeff; i++)
        //                    {
        //                        results[index0 + i][col] = (double)nb / (double)coeff;
        //                    }

        //                }


        //                st.Append("min"); st.Append("\t");
        //                for (int l = 0; l < 4; l++)
        //                {
        //                    for (int s = 1; s <= 3; s++)
        //                    {
        //                        st.Append(l); st.Append(" ");
        //                        st.Append(s); st.Append("\t");
        //                    }

        //                }
        //                st.AppendLine();
        //                st.AppendLine();


        //                foreach (ResultLine line in results)
        //                {
        //                    line.getLine(st); st.AppendLine();
        //                }
        //            }
        //            catch (Exception ex)
        //            {
        //                Console.WriteLine(ex);
        //            }

        //            try
        //            {

        //                st.AppendLine();
        //                st.AppendLine();
        //                //phase deux déterminer les tantièmes
        //                //1,2,3..10,20,30..100,
        //                double nbTot = count;
        //                double portion = nbTot;
        //                int K = 1;
        //                decimal valueFrom = 0m;

        //                decimal classTo = 6.0m;
        //                decimal classFrom = 0.0m;

        //                List<Tranche> tranches = new List<Tranche>();
        //                const int DETAIL = 1000;
        //                for (int i = 0; i < 6 * DETAIL; i++)
        //                {
        //                    if (reg.IsMatch(i.ToString()))
        //                        continue;
        //                    tranches.Add(new Tranche(i));
        //                }
        //                for (level = 1; level < 2; level++)
        //                {



        //                    for (int div = 2; div <= NB_MEDIANE; div++)
        //                    {


        //                        //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
        //                        valueFrom = 0;
        //                        int iFrom = 0;
        //                        int iTo = count - 1;
        //                        portion = nbTot / div;
        //                        classFrom = 0;
        //                        for (sub = 1; sub <= div; sub++)
        //                        {

        //                            double to = sub * portion;
        //                            iTo = 0;
        //                            if (to > 0)
        //                                iTo = (int)to - 1;
        //                            if (iTo >= list.Count)
        //                                iTo = list.Count - 1;
        //                            if (iTo < 0)
        //                                iTo = 0;
        //                            var rapport = list[iTo].RapportClassementDecimal;
        //                            classTo = list[iTo].ClassementValueDecimal0;


        //                            //st.Write(classFrom);
        //                            ////st.Write("\t");
        //                            //st.Write(classTo);
        //                            //st.Write("\t");
        //                            ////st.Write(valueFrom);
        //                            ////
        //                            //st.Write(rapport);
        //                            //st.Write("\t");


        //                            //int nb = (iTo - iFrom + 1);                          
        //                            //st.Write(nb);
        //                            //st.Write("\t");
        //                            decimal densite = 0m;
        //                            if (rapport != valueFrom)
        //                                densite = 1.0m / ((rapport - valueFrom) * div);
        //                            //st.Write("\t");
        //                            //st.Write(densite);
        //                            //st.WriteLine(); 

        //                            for (int i = 0; i < 6 * DETAIL; i++)
        //                            {
        //                                if (i < classFrom * DETAIL)
        //                                    continue;
        //                                if (i > classTo * DETAIL)
        //                                    continue;
        //                                if (reg.IsMatch(i.ToString()))
        //                                    continue;
        //                                Tranche tranche = tranches.Find(t => t.index == i);
        //                                tranche.densites[div - 1] = densite;
        //                            }

        //                            valueFrom = rapport;
        //                            iFrom = iTo;
        //                            classFrom = classTo;
        //                        }
        //                    }
        //                    K *= 10;
        //                }

        //                st.AppendLine();
        //                st.Append("\t");
        //                st.Append("\t");
        //                st.Append("\t");

        //                for (int i = 0; i < NB_MEDIANE; i++)
        //                {
        //                    st.Append(i + 2);
        //                    st.Append("\t");
        //                    st.Append(i + 2);
        //                    st.Append("\t");
        //                }
        //                Tranche last = null;
        //                foreach (Tranche tranche in tranches)
        //                {
        //                    st.AppendLine();
        //                    st.Append((double)tranche.index / DETAIL);
        //                    st.Append("\t");


        //                    for (int i = 0; i < NB_MEDIANE; i++)
        //                    {
        //                        var densite = tranche.densites[i];
        //                        st.Append(densite);
        //                        st.Append("\t");
        //                        if (last == null || last.densites[i] != densite)
        //                        {
        //                            st.Append(densite);
        //                        }
        //                        else
        //                            st.Append(0);
        //                        st.Append("\t");
        //                    }
        //                    last = tranche;
        //                }

        //            }
        //            catch (Exception ex)
        //            {
        //                Console.WriteLine(ex);
        //            }
        //        }
        //    }
        //}


    }
}
]]></content>
  </file>
</db>
