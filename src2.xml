<db path="C:\bernard\db1\db4">
   <file path="\pdb.iit\IPlayList.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.obj;

namespace pdb.iit
{
    public interface IPlayList
    {
        void setPrior(int prior); 
        bool mergeList(ICollection<IFile> newElements_, IAbortTask writer, bool writeOnlyEnabled,bool writeOnlyUnRead);  
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;
using pdb.gen.medianne;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion

        private CPiece piece;
        private Piece track;

        // private TrackList track;
        //  private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        //  public TrackList Track { get { return track; } }
        //   public CPiece Piece { get { return piece.Piece; } }
        // public Piece PieceGen { get { return track.Piece; } }

        public CPiece Piece { get { return piece; } }
        public Piece PieceGen { get { return track; } }
        public Piece Master { get { return track.Master; } }
        public bool Played { get { return piece.Played; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            // piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            //OnPropertyChanged("Comment");
            //OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        private int index2;
        public int Index2
        {
            get { return index2; }
            set
            {
                if (value != index2)
                {
                    index2 = value;
                    OnPropertyChanged("Index2");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public bool Empeached { get { return PieceGen.isEmpeached(); } set { PieceGen.Empeached = value; } }
        public int EmpeachedNb { get { return PieceGen.EmpeachedNb; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        private static bool setHumanSelectedUsed;
        private static volatile object _lock = new object();
        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            lock (_lock)
            {
                if (setHumanSelectedUsed)
                    return;
            }

            try
            {
                lock (_lock)
                    setHumanSelectedUsed = true;
                //if (humanSelected != null)
                //{
                //    humanSelected.refresh();
                //   // var b = humanSelected.Grouping; 
                //}
                if (track != humanSelected)
                {
                    humanSelected = track;


                    //  humanSelected.refresh();
                    // var b = humanSelected.Grouping; 
                    int id = 0;
                    if (track != null) id = track.PieceId;
                    if (id != humanSelectedId)
                    {
                        humanSelectedId = id;
                        if (CurrentHumanSelectedChanged != null)
                            CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                    }
                }
            }
            finally
            {
                lock (_lock)
                    setHumanSelectedUsed = false;
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }



        private TrackListViewModel(Piece piece)
            : base(piece)
        {
            this.track = piece;
            this.piece = track.Track as CPiece;
        }
        # region registre
        #region main
        /// <summary>
        /// Registre des tracks présentés dans la grille principale
        /// </summary>
        private static BgDict<int, TrackListViewModel> dict = new BgDict<int, TrackListViewModel>();
        /// <summary>
        /// Récupère ou crée un track dans la grille principale
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public static TrackListViewModel getOrCreate(Piece p)
        {
            var t = dict[p.PieceId];
            if (t == null)
            {
                t = new TrackListViewModel(p);
                dict.Add(p.PieceId, t);
            }
            return t;
        }

        public static TrackListViewModel get(int id)
        {
            return dict[id];
        }
        public static IDictionary<int, TrackListViewModel> Dict { get { return dict; } }
        #endregion
        #region album
        /// <summary>
        /// Registre des tracks présentés dans la grille album
        /// </summary>
        private static BgDict<int, TrackListViewModel> dictA = new BgDict<int, TrackListViewModel>();
        /// <summary>
        /// Récupère ou crée un track dans la grille album
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public static TrackListViewModel getOrCreateA(Piece p)
        {
            var t = dictA[p.PieceId];
            if (t == null)
            {
                t = new TrackListViewModel(p);
                dictA.Add(p.PieceId, t);
            }
            return t;
        }

        public static TrackListViewModel getA(int id)
        {
            return dictA[id];
        }
        public static IDictionary<int, TrackListViewModel> DictA { get { return dictA; } }
        #endregion
        # endregion
        //public TrackListViewModel(TrackList track, PlayListViewModel playlist)
        //    : base(track, playlist)
        //{
        //    //this.track = track;
        //    //this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
        //    //piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
        //    //int id = track.PieceId;
        //    //if (!dictT.ContainsKey(id))
        //    //{
        //    //    var list = new List<TrackListViewModel>();
        //    //    dictT.Add(id, list);
        //    //}

        //    //dictT[id].Add(this);

        //}

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }

        public string ClassementCompact
        {
            get { return PieceGen.ClassementCompact; }
        }

        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.StrClassement;
            }
            set
            {

                // piece.StrClassement = value;
                //if (value != piece.Piece.StrClassement)
                //{

                lock (Albums.LockSort)
                {
                    piece.StrClassement = value;
                    track.invalidateCache(true);

                    //piece.Classement = value;
                    // PieceGen.invalidateCache();
                    var albums = App.gen.Albums;
                    albums.signalClassChange(track);
                    if (DetailClassementViewModel.Instance.Auto)
                        albums.setUrgence();
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    OnPropertyChanged("Classement");

                    App.go(this);
                    // onPropertyChanged("Classement");


                    // }

                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }

        public DateTime Added { get { return piece.Added; } }

        public DateTime FirstAcces
        {
            get
            {
                return track.FirstAcces;
            }
        }



        public DateTime AlbumAdded
        {
            get
            {
                return track.AlbumAdded;
            }
        }

        public int RankAlbum { get { return PieceGen.RankAlbum; } }
        public int RankAlbumZero { get { return PieceGen.RankAlbumZero; } }
        public int RankAlbumReverse { get { return PieceGen.RankAlbumReverse; } }
        public int RankAllAlbum { get { return PieceGen.RankAllAlbum; } }
        public int RankAlbumSt { get { return PieceGen.RankAlbumSt; } }
        public int RankAlbumZeroSt { get { return PieceGen.RankAlbumZeroSt; } }


        public int Rank { get { return PieceGen.Rank.Twice; } }
        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        //public string Comment
        //{
        //    get
        //    {
        //        if (PieceGen.Virtual)
        //            return "";
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        if (PieceGen.Virtual)
        //            return;
        //        //piece.Comment = value; 
        //        if (value != piece.Comment)
        //        {
        //            //  track.Comment = value;
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get { return track.Piece.Grouping; }
        //    set
        //    {
        //        //  piece.Grouping = value;
        //        if (value != track.Piece.Grouping)
        //        {
        //            track.Piece.setGrouping(value, true);
        //            // track.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string File
        {
            get { return piece.Files.PathReduc; }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    if (track.VirtualByArtist)
                        return string.Format("[{0}]", track.Album);
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.setClassement(className, rating);
            PieceGen.invalidateCache(true);

        }

        public string ClassName
        {
            get
            {
                return piece.ClassName;
            }
            set
            {
                piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        //public string ArtWork
        //{
        //    get
        //    {
        //        return piece.ArtWork;
        //    }
        //    set
        //    {
        //        piece.ArtWork = value;
        //    }
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    track.Piece.setGrouping(value, prior);
        //    piece.Grouping = value; // TODO je fait quoi de ça ???
        //    // onPropertyChanged("Grouping");
        //}

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel - 1; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2 - 1; } }

        public decimal Rendement
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Rendement - 1;
            }
        }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.invalidateCache(false);
            parent.PieceGen.invalidateCache(false);

            track.albumMustRefresh();
            parent.track.albumMustRefresh();

            piece.Parent = parent.Piece.Master;
            track.Parent = parent.track;

            track.albumMustRefresh();
            parent.track.albumMustRefresh();

            track.invalidateCache(false);
            parent.PieceGen.invalidateCache(false);
        }

        public void fusion(TrackListViewModel toDelete)
        {

            PieceGen.invalidateCache(false);
            toDelete.PieceGen.invalidateCache(false);

            App.Db.List.fusion(piece, toDelete.Piece);
            PieceGen.invalidateCache(false);
            toDelete.PieceGen.invalidateCache(false);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }

        public string EquivLight
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight;
            }
        }

        public string EquivLight0
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight0;
            }
        }

        public string EquivLightSt
        {
            get
            {

                if (album == null)
                    return "";
                return album.EquivLightSt;
            }
        }

        public decimal ClassementValueLightSt
        {
            get
            {
                if (album == null)
                    return 0;
                return album.ClassementValueLightSt;
            }
        }

        public int AlbumCount
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Count;
            }
        }

        public bool Virtual { get { return PieceGen.Virtual; } }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Hibernator.cs">
    <content><![CDATA[using pdb.it;
using pdb.util;
using System.IO;
using System;
using System.Collections.Generic;
using pdb.iit;

namespace pdb.podcast
{
    class Hibernator
    {
        public int go(ILoader loader, List<TrackInfoItunes> tracks)
        {

            var conf = pdb.podcast.Tuning.Conf.Hibernate;
            if (!conf.enabled)
                return 0;

            var rootIt = pdb.podcast.Tuning.Conf.RootIt;
            var toH = new List<TrackInfoItunes>();
            var dirH = conf.dir;
            var list = conf.list;
            if (!string.IsNullOrEmpty(list))
            {

                var auto = loader.TreePlayList.getComposite("auto");
                if (auto != null)
                {
                    var itl = auto.getComposite(list);
                    if (itl != null)
                    {
                        foreach (var plc in itl)
                        {
                            if (plc is TrackInList)
                            {
                                var t = plc as TrackInList;
                                var piece = t.Piece as TrackInfoItunes;
                                if (piece == null)
                                {
                                    misc.log("plc pas un TrackInfoItunes {0}", plc);
                                    continue;
                                }
                                if (piece.Selected)
                                {
                                    misc.log("non hiberné car selected {0}", piece);
                                    continue;
                                }
                                Program.log.log("hibernation de {0} par liste", piece);
                                toH.Add(piece);
                            }
                        }
                    }
                }
            }

            select(conf, toH, tracks, false);


            int nb = 0;
            int nbNotMax = conf.nbMax;
            DateTime lastNotH = DateTime.MinValue;
            DateTime limit = DateTime.Now.AddDays(1 - conf.delay).Date;
            DateTime limitAdd = DateTime.Now.AddDays(1 - conf.delayAdd).Date;
            DateTime limitPub = DateTime.Now.AddDays(1 - conf.delayPub).Date;
            var dict = getDict(toH);
            DateTime limitFreeWheels = DateTime.MaxValue;
            HashSet<int> hso = new HashSet<int>();
            if (conf.freewheelsDelay > 0)
            {
                limitFreeWheels = pdb.podcast.Tuning.Conf.Date0.AddDays(conf.freewheelsDelay);
                foreach (var ro in rootIt.others)
                {
                    var o = loader.TreePlayList.getComposite(ro.name);
                    if (o != null)
                    {
                        var auto = o.getComposite("_auto");
                        if (auto != null)
                        {

                            foreach (var plc in auto)
                            {
                                if (plc is TrackInList)
                                {
                                    var t = plc as TrackInList;
                                    var piece = t.Piece as TrackInfoItunes;
                                    if (piece == null)
                                    {
                                        misc.log("plc pas un TrackInfoItunes {0}", plc);
                                        continue;
                                    }
                                    if (piece.Selected)
                                    {
                                        continue;
                                    }
                                    hso.Add(piece.PieceId);
                                }
                            }
                        }
                    }
                }
            }
            foreach (var album in dict.Values)
            {
                int nbNotH = 0;
                var listA = album.List;
                listA.Sort(new PodCastComparerInv());
                foreach (TrackInfoItunes track in listA)
                {
                    var fv = FileRegister.Check(track.Location);
                    if (fv.Exists)
                    {
                        bool keep = false;
                        if (track.Pub.Date == lastNotH)
                            keep = true;
                        else if (track.Selected)
                            keep = true;
                        else if (track.Gout == DateTime.MaxValue)
                            keep = true;
                        else if (track.Gout > limit)
                            keep = true;

                        else if (track.Added > limitAdd || track.Pub > limitPub)
                        {
                            if (nbNotH < nbNotMax || nbNotMax <= 0)
                                keep = true;
                        }




                        // en cas de roue libre, je dois en plus vérifier que le track n'est pas présent ailleurs et à venir. 
                        // s'il est absent =>OK pour hiberner
                        // s'il est présent, je vérifie que sa date de publication n'est pas trop proche

                        // 1. vérif parametre actif
                        if (!keep && limitFreeWheels < DateTime.MaxValue)
                        {
                            // 2. vérif présent
                            if (hso.Contains(track.PieceId))
                            {
                                // track à venir
                                if (track.Pub2 > pdb.podcast.Tuning.Conf.Date0)
                                {
                                    // uniquement les track du répertoire last : ils reviendront dans très longtemps
                                    if (track.Pub < limitFreeWheels)
                                    {
                                        keep = true;
                                        continue; 
                                    }
                                }
                            }
                        }


                        if (keep)
                        {
                            nbNotH++;
                            lastNotH = track.Pub.Date;
                            continue;
                        }

                        nb++;
                        track.hibernate(fv, dirH);
                    }
                }
            }


            return nb;
        }

        // private Dictionary<string, Album> dict; 
        private Dictionary<string, Album> getDict(List<TrackInfoItunes> tracks)
        {

            var dict = new Dictionary<string, Album>();
            tracks.Sort(new PodcastComparerPubPub2());
            foreach (TrackInfoItunes track in tracks)
            {
                string album = track.Album;
                string key = album;
                if (string.IsNullOrEmpty(album))
                {
                    misc.log("pas d'album pour " + track.Location);
                    continue;

                }

                if (!dict.ContainsKey(key))
                {
                    Album a = new Album(key);
                    dict.Add(key, a);
                }
                dict[key].add(track);
            }

            return dict;
        }

        public void select(pdb.podcast.Tuning.Hibernate conf, List<TrackInfoItunes> toCheck, List<TrackInfoItunes> tracks, bool import)
        {
            bool critereDate = conf.dateMin > DateTime.MinValue && conf.dateMax < DateTime.Now;
            bool critereAlbum = !string.IsNullOrEmpty(conf.album);
            bool critereLast = conf.nblast > 0;


            //if (import || critereAlbum || critereDate || critereLast)
            //{


            foreach (TrackInfoItunes t in tracks)
            {
                if (!t.isPodcast)
                    continue;
                if (import)
                {
                    //if (t.Present)
                    //    continue;
                }
                else
                {
                    if (!t.Present)
                        continue;
                    if (t.Selected)
                        continue;

                }


                if (!critereDate || t.Pub >= conf.dateMin && t.Pub <= conf.dateMax)
                {
                    if (!critereAlbum || t.Album.ToLower().Contains(conf.album.ToLower()))
                    {
                        toCheck.Add(t);
                    }
                }
            }
            if (critereLast)
            {

                Dictionary<string, Album> dict = new Dictionary<string, Album>();
                toCheck.Sort(new PodCastComparer());
                var source = new List<TrackInfoItunes>(toCheck);
                toCheck.Clear();
                foreach (TrackInfoItunes track in source)
                {
                    string album = track.Album;
                    string key = album;
                    if (string.IsNullOrEmpty(album))
                    {
                        misc.log("pas d'album pour " + track.Location);
                        if (import)
                            toCheck.Add(track);
                        continue;

                    }

                    if (!dict.ContainsKey(key))
                    {
                        Album a = new Album(key);
                        dict.Add(key, a);
                    }
                    dict[key].add(track);
                }

                foreach (Album album in dict.Values)
                {
                    if (critereAlbum)
                    {
                        if (album.Name.ToLower().Contains(conf.album.ToLower()))
                        {
                        }
                        else continue;
                    }

                    var list = album.List;
                    int count = list.Count;
                    int nb = 0;

                    for (int i = count - 1; i >= 0; i--)
                    {
                        var t = list[i];
                        if (!import)
                        {
                            if (t.Selected)
                                continue;
                            if (!t.Present)
                                continue;
                        }
                        if (!critereDate || t.Pub >= conf.dateMin && t.Pub <= conf.dateMax)
                        {
                            if (import)
                            {
                                nb++;
                                toCheck.Add(t);
                                if (nb >= conf.nblast)
                                    break;
                                continue;
                            }


                            if (t.Pub > conf.dateLast)
                            {
                                nb++;
                                if (nb <= conf.nblast)
                                    continue;
                            }

                            toCheck.Add(t);
                        }
                    }
                }
            }
        }

        private class Album
        {
            private string name;
            private List<TrackInfoItunes> list = new List<TrackInfoItunes>();
            public Album(string name)
            {
                this.name = name;
            }
            public void add(TrackInfoItunes track)
            {
                list.Add(track);
            }
            public List<TrackInfoItunes> List { get { return list; } }
            public string Name { get { return name; } }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Loader.cs">
    <content><![CDATA[
using pdb.obj;
using System.Collections.Generic;
using pdb.it;
using pdb.util;
using System;
using pdb.podcast.DB;
using System.Xml;
using pdb.iit;
namespace pdb.podcast
{
    public class Loader : pdb.it.Loader, ILoader
    {
        private bool _import; public bool Import { get { return _import; } }
        public Loader(Conf conf, bool useDetect, bool writeOnlyEnabled, bool writeOnlyUnRead) : base(conf, useDetect, writeOnlyEnabled, writeOnlyUnRead) { TrackInfoItunes.Loader = this; }
        public Loader(Conf conf, bool import, Db db, Action abortList, bool writeOnlyEnabled, bool writeOnlyUnRead) : base(conf, abortList, writeOnlyEnabled, writeOnlyUnRead) { this.db = db; this._import = import; TrackInfoItunes.Loader = this; }
        private Db db;
        protected override void afterCreate(it.PlayList playlist, it.TrackInfoItunes track, int id)
        {
            TrackInfoItunes _track = track as TrackInfoItunes;
            //  db.Check(_track); 
            //if (playlist.isSubList("info"))
            //    _track.Info = true;
            //if (playlist.isSubList("rare"))
            //    _track.Rare = true;
            //if (playlist.isSubList("_auto"))
            //    _track.GlobalSelected = true;
        }

        public override it.TrackInfoItunes create(string location)
        {
            TrackInfoItunes t = null;
            //if (import)
            //{
            //    t = new TrackInfoItunes() { Location = location };
            //}
            //else
            //{
            t = db.get(TrackInfoItunes.getShortName(location));
            if (t == null)
                t = new TrackInfoItunes() { Location = location };
            //}

            t.Present = true;
            return t;
        }

        public override void createTrack(it.TrackInfoItunes piece, bool podcast)
        {
            var track = piece as TrackInfoItunes;
            if (!string.IsNullOrEmpty(track.HibernateLocation))
            {
                misc.moveTree(FileRegister.Check(track.HibernateLocation), track.Location, false);
                track.HibernateLocation = null;
            }

            base.createTrack(piece, true);

        }

        public void loadTracks(bool firstStep, bool forceLoad, List<ITrackInfoItunes> list)
        {
            init();
            reset(firstStep, forceLoad);
            loadTracks(list);
            loadLists();
        }

        public void import(ITrackInfoItunes t)
        {
            var track = t as TrackInfoItunes; 
            if (!track.Present)
            {
                if (track.isPresent())
                {
                    createTrack(track,true);
                    track.Present = true;
                }
                else return;
            }
            track.import();
        }

        public void merge(ITrackInfoItunes t)
        {
            var track = t as TrackInfoItunes; 
            if (!track.Present)
                return;
            track.merge();
        }

        private int nbTrackCreated; public int NbTrackCreated { get { return nbTrackCreated; } }
        public void reviveIfNecessary(ITrackInfoItunes t)
        {
            var track = t as TrackInfoItunes; 
            try
            {
                if (!track.Present)
                {
                    if (track.isPresent())
                    {
                        createTrack(track, true);
                        track.import();
                        track.Present = true;
                        nbTrackCreated++;  
                    }
                }
            }
            catch (Exception ex)
            {
                log.Error(string.Format("Impossible de ressuciter {0}", track), ex);
            }
            

            

        }



        public void removeReadItems(PlayListComposite folder)
        {
            List<PlComponent> toDelete = new List<PlComponent>();
            foreach (PlComponent plc in folder)
            {
                if (plc is TrackInList)
                {
                    var t = plc as TrackInList;
                    var piece = t.Piece as TrackInfoItunes;
                    if (piece == null)
                    {
                        misc.log("plc pas un TrackInfoItunes {0}", plc);
                    }
                    else
                    {
                        if (piece.Played)
                            toDelete.Add(plc);
                    }
                }
                else if (plc is PlayListComposite)
                {
                    removeReadItems(plc as PlayListComposite);
                }
            }

            foreach (PlComponent plc in toDelete)
                plc.Delete();
        }


        public iit.IPlayList getPlayList(PlayListComposite folder, string name, bool buildIf)
        {
            return base.GetPlayList(folder, name, buildIf); 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Menage.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Load;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;
using pdb.podcast.Report;
using System.Text.RegularExpressions;
using iTunesLib;
using System.Collections;
using PlayList = pdb.it.PlayList; 
namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Menage : IAbortTask
    {
        Loader loader;
        private Feeds feeds = new Feeds();
        private static Logger log = Logger.getLogger("Program");

        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;
            BackGroundTaskMgr.recordMsProc();
            pdb.it.PlayList.AbortOpe();
            BackGroundTaskMgr.AbortSpecial();
            BackGroundTaskMgr.Reset();
            loader.saveIds();
            Console.WriteLine("\nFin de l'opération d'enregistrement.");
            Environment.Exit(1);
        }

        public void go()

        {
            Console.CancelKeyPress += Console_CancelKeyPress;

            /*     var s1 = @"C:\zique\Podcasts\Album\file.mp3"; 
                 var s2 = @"C:\zique\Podcasts\Album\file1.mp3";
                 var s3 = @"D:\zique\Podcasts\Album\file.mp3";
                 var s4 = @"D:\zique\Podcasts\Album\file1.mp3"; 
                 Console.WriteLine(s1.CompareTo(s2));

                 Console.WriteLine(Path.GetPathRoot(s1)); 

                 var listTest = new List<string> { s1, s2,s3,s4 };
                 listTest.Sort();

                 foreach (string _s in listTest)
                 {
                     Console.WriteLine(_s); 
                 }
             * */

            //string reponse = Console.ReadLine();
            //Console.WriteLine(reponse + reponse);
            //Environment.Exit(0); 

            try
            {


                // Thread.CurrentThread.Name = "Main";
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);




                var xelt = Conf.Instance.load(false);
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                var itConf = new pdb.it.Conf(xelt);
                loader = new Loader(itConf, false, Conf.OnlyEnabled, Conf.OnlyUnRead);


                misc.log("***********************************************************");
                misc.log("MENAGE:" + Conf.Menage);
                misc.log("***********************************************************");

                loader.init();


                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();
                List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
                List<TrackInfoItunes> list = new List<TrackInfoItunes>();


                listTrack = new List<ITrackInfoItunes>();
                loader.reset(true,true);


                loader.loadTracks(listTrack);
                loader.loadScan("Menage");




                foreach (ITrackInfoItunes _track in listTrack)
                {
                    var t = _track as TrackInfoItunes;
                    string location = t.Location;
                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                    {
                        continue;
                    }
                    dict[location] = t;

                    if (t.isPodcast)
                    {
                        feeds.checkAll(t);
                    }

                }

                // scandir(@"C:\zique\géopolitique");
                // scandir(@"C:\zique\hackit\Music");
                //scandir(@"C:\zique\Podcasts");
                //scandir(@"D:\zique\Podcasts");
                //scandir(@"F:\Podcasts");

                //Console.Read();

                thDelete.Start();

                switch (Conf.Menage)
                {
                    case menage.name:
                        foreach (Feed feed in feeds)
                        {
                            new CompacteurName(feed).compact();
                        }
                        break;

                    case menage.read:

                        foreach (Feed feed in feeds)
                        {
                            var c = new CompacteurRead(feeds,feed); 
                            c.compact();
                            if (c.AllFeeds)
                                break; 
                        }
                        break;
                    default:
                        throw new ArgumentException();

                }




                while (!queueDelete.Empty)
                    Thread.Sleep(1000);

                log.log("fin");

                Console.Read();
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }



        }


        private void scandir(string dir)
        {
            scanFiles(new DirectoryInfo(dir));
        }

        private void scanFiles(DirectoryInfo dir)
        {
            log.log("scan " + dir.FullName);
            foreach (FileInfo file in dir.GetFiles())
            {
                if (dict.ContainsKey(file.FullName))
                    continue;

                // log.log("try to build track from " + file.FullName);

                try
                {
                    var t = loader.createTrack(-1, file.FullName);
                    if (t == null)
                        continue;
                    TrackInfoItunes track = t as TrackInfoItunes;

                    if (track == null)
                        continue;
                    //if (!track.isPodcast)
                    //    continue;

                    log.log("\t==>track créé:" + track);
                    feeds.checkAll(track);

                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }
            }

            foreach (DirectoryInfo sub in dir.GetDirectories())
                scanFiles(sub);
        }

        private class DeleteTask
        {
            public readonly TrackInfoItunes track;
            public readonly string poubelle;
            public DeleteTask(TrackInfoItunes track, string poubelle)
            {
                this.track = track;
                this.poubelle = poubelle;
            }
        }

        private static Thread thDelete = new Thread(loopDelete);
        private static pdb.util.Queue<DeleteTask> queueDelete = new util.Queue<DeleteTask>();

        private static void loopDelete()
        {
            do
            {
                Thread.Sleep(30);
                DeleteTask task = queueDelete.Dequeue();
                if (task == null)
                    continue;
                try
                {
                    delete_(task.track, task.poubelle);
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex);
                }

            } while (true);
        }

        private static void delete(TrackInfoItunes track, string poubelle)
        {
            queueDelete.EnQueue(new DeleteTask(track, poubelle));
        }


        private static void delete_(TrackInfoItunes track, string poubelle)
        {
            try
            {
                Menage.log.log("delete " + track);

                FileInfo f = new FileInfo(track.Location);
                var lecteur = Path.GetPathRoot(f.FullName);
                string dest = f.FullName.Replace(lecteur, poubelle);
                f.moveTree(dest, false);
                track.Delete();
            }
            catch (Exception ex)
            {
                Menage.log.log("impossible de supprimer " + track + " " + ex.ToString());
            }

        }

        private class Compacteur
        {
            private Feed feed;
            private Dict<DateTime, Doublon> doublons = new Dict<DateTime, Doublon>();
            public Compacteur(Feed feed) { this.feed = feed; }
            public void compact()
            {
                var list = feed.Tracks;
                foreach (TrackInfoItunes track in list)
                {
                    var pub = track.Pub.Date;
                    if (track.Album.Contains("RFI"))
                        pub = track.Pub;
                    if (pub > TrackInfoItunes.MIN && pub.DayOfYear > 1)
                    {
                        var doublon = doublons[pub];
                        if (doublon == null)
                            doublons[pub] = new Doublon();

                        doublons[pub].add(track);
                    }
                }

                foreach (Doublon doublon in doublons.Values)
                {
                    doublon.go();
                }
            }

        }

        private class CompacteurName
        {
            private static Regex reg = new Regex(@"[^a-zA-Z]");
            private Feed feed;
            private BgDictString<Doublon> doublons = new BgDictString<Doublon>();
            public CompacteurName(Feed feed) { this.feed = feed; }
            public void compact()
            {
                var list = feed.Tracks;
                foreach (TrackInfoItunes track in list)
                {

                    string name = track.Name;
                    if (name == null)
                        continue;
                    name = reg.Replace(name, "").ToLower();
                    var doublon = doublons[name];
                    if (doublon == null)
                        doublons[name] = new Doublon();

                    doublons[name].add(track);

                }

                foreach (Doublon doublon in doublons.Values)
                {
                    doublon.goName();
                    if (doublon.Break)
                        break;
                }
            }

        }

        private class CompacteurRead
        {
            private Feed feed;
            private Feeds feeds;
            bool allfeeds = false;
            public bool AllFeeds { get { return allfeeds; } }
            public static string POUBELLE = Conf.Poubelle; 
            public CompacteurRead(Feeds feeds, Feed feed) { this.feed = feed; this.feeds = feeds;}
            public void compact()
            {
                POUBELLE = Conf.Poubelle;
                string poubelle = POUBELLE+"Read";

                Console.WriteLine("par album ?  o / n");
                string reponse = Console.ReadLine();
              
                if ("n" == reponse)
                    allfeeds = true;


                List<TrackInfoItunes> tracks = null;
                if (allfeeds)
                {
                    tracks = new List<TrackInfoItunes>(feeds.LoadedTracks.Values);
                }
                else
                    tracks = feed.Tracks;
                var reads = tracks.FindAll(t => t.Played);
                var all = tracks;
                var disabled = tracks.FindAll(t => !t.Enabled);
                List<TrackInfoItunes> list = null;
                string name = feed.Name;
                if (allfeeds)
                    name = "all"; 
                Console.WriteLine(name + " " + reads.Count + " éléments. (total: " + all.Count + ")");
                if (all.Count == 0)
                    return;



                foreach (TrackInfoItunes track in all)
                {
                    Console.WriteLine(track.Played + " " + track + " " + track.Location + " durée:" + track.Duration.TotalMinutes.ToString("0.#") + " min");
                }


                Console.WriteLine("---------------------");
                Console.WriteLine("lus");
                Console.WriteLine("---------------------");
                foreach (TrackInfoItunes track in reads)
                {
                    Console.WriteLine(track.Played + " " + track + " " + track.Location + " durée:" + track.Duration.TotalMinutes.ToString("0.#") + " min");
                }


            PASCOMPRIS: Console.WriteLine(name + ": traiter ? o / n / [0-5] /a /u (unselected) / d (date)");
                 reponse = Console.ReadLine();

                List<TrackInfoItunes> sub = null;
                switch (reponse)
                {

                    case ("o"):
                    case ("a"):
                    case ("u"):
                    case ("d"):
                        if ("o".Equals(reponse))
                        {
                            poubelle = POUBELLE+"Read";
                            list = reads;
                        }
                        else if ("a".Equals(reponse))
                        {
                            poubelle = POUBELLE+"All";
                            list = all;
                        }
                        else if ("u".Equals(reponse))
                        {
                            poubelle = POUBELLE+"Disabled";
                            list = disabled;
                        }
                        else
                        {
                        PASCOMPRISDATE: Console.WriteLine("date min ? ");
                            string datereponse = Console.ReadLine();

                            try
                            {
                                var date = Convert.ToDateTime(datereponse);
                                Console.WriteLine("date min :" + date);
                                poubelle = POUBELLE+"Date";
                                list = all.FindAll(t => t.Pub < date);
                            }
                            catch
                            {
                                goto PASCOMPRISDATE;
                            }
                        }
                        for (int i = 0; i < 6; i++)
                        {
                            sub = list.FindAll(t => t.Rating == 20 * i);
                            if (sub.Count == 0)
                                continue;

                            Console.WriteLine(name + "level " + i + " " + sub.Count);
                            foreach (TrackInfoItunes track in sub)
                            {
                                Console.WriteLine(track.Played + " " + track + " " + track.Location + " durée:" + track.Duration.TotalMinutes.ToString("0.#") + " min");
                            }
                            Console.WriteLine(" traiter ? o / n / e (élément par élément)/ d (date) / f (fini) /b (back)");
                            var subReponse = Console.ReadLine();
                            if ("o".Equals(subReponse))
                            {
                                foreach (TrackInfoItunes track in sub)
                                {
                                    Menage.delete(track, poubelle);
                                }
                            }

                            else if ("e".Equals(subReponse))
                            {
                                foreach (TrackInfoItunes track in sub)
                                {
                                    Console.WriteLine("traiter? (o->oui, n->non f->fini) " + track + " " + track.Location + " durée:" + track.Duration.TotalMinutes.ToString("0.#") + " min");
                                    var ereponse = Console.ReadLine();
                                    if ("o".Equals(ereponse))
                                        Menage.delete(track, poubelle);
                                    else if ("f".Equals(ereponse))
                                        break;
                                    else if ("n".Equals(ereponse))
                                        continue;
                                    else
                                        goto PASCOMPRIS;
                                }
                            }
                            else if ("f".Equals(subReponse)) break;
                            else if ("b".Equals(subReponse))
                                goto PASCOMPRIS; 
                            else
                            {
                                try
                                {
                                    var date = Convert.ToDateTime(subReponse);
                                    Console.WriteLine("date min :" + date);

                                    foreach (TrackInfoItunes track in sub.FindAll(t => t.Pub < date))
                                    {
                                        Menage.delete(track, poubelle);
                                    }

                                }
                                catch
                                {
                                }
                            }
                        }
                        break;
                    case ("0"):
                    case ("1"):
                    case ("2"):
                    case ("3"):
                    case ("4"):
                    case ("5"):
                        poubelle = POUBELLE+"Read";
                        list = reads;
                        int level = Convert.ToInt16(reponse);
                        sub = list.FindAll(t => t.Rating <= 20 * level);
                        foreach (TrackInfoItunes track in sub)
                        {
                            Menage.delete(track, poubelle);
                        }
                        break;
                    case ("n"): break;
                    default: goto PASCOMPRIS;

                }

            }

        }

        private class Doublon
        {
            private int rating;
            private bool read;
            List<TrackInfoItunes> list = new List<TrackInfoItunes>();
            private bool _break;
            public bool Break { get { return _break; } }
            public void add(TrackInfoItunes track)
            {
                list.Add(track);
                if (track.Played)
                    read = true;
                var _rating = track.Rating;
                if (_rating > rating)
                    rating = _rating;
            }



            public void go()
            {
                if (list.Count < 2)
                    return;

                foreach (TrackInfoItunes track in list)
                {
                    //+ track + " " + track.Location + " durée:" + track.Duration.TotalMinutes.ToString("0.#") + " min");
                    Menage.log.log("{0} {1} durée:{2} min", track.Pub, track.Location, track.Duration.TotalMinutes.ToString("0.#"));
                }

                foreach (TrackInfoItunes track in list)
                {
                    if (read)
                    {
                        if (!track.Played)
                        {
                            try
                            {
                                track.makeRead();
                            }
                            catch (Exception e)
                            {
                                Menage.log.log(e.ToString());
                            }
                        }
                    }
                    if (track.Rating < rating)
                        track.Rating = rating;
                }

                list.Sort(new TrackComparer());

                Menage.log.log("tri");
                foreach (TrackInfoItunes track in list)
                {
                    Menage.log.log("{0} {1} durée:{2} min", track.Pub, track.Location, track.Duration.TotalMinutes.ToString("0.#"));

                }

                Menage.log.log("conservation " + list[0]);
                for (int i = 1; i < list.Count; i++)
                    Menage.delete(list[i], CompacteurRead.POUBELLE+@"auto\");


            }

            public void goName()
            {
                if (list.Count < 2)
                    return;

                foreach (TrackInfoItunes track in list)
                {
                    Menage.log.log("{0} {1} durée:{2} min", track.Pub, track.Location, track.Duration.TotalMinutes.ToString("0.#"));
                }

                //foreach (TrackInfoItunes track in list)
                //{
                //    if (read)
                //    {
                //        if (!track.Played)
                //        {
                //            try
                //            {
                //                track.makeRead();
                //            }
                //            catch (Exception e)
                //            {
                //                Menage.log.log(e.ToString());
                //            }
                //        }
                //    }
                //    if (track.Rating < rating)
                //        track.Rating = rating;
                //}

                list.Sort(new TrackComparer());

                Menage.log.log("liste:");
                foreach (TrackInfoItunes track in list)
                {
                    Menage.log.log("{0} {1} durée:{2} min", track.Pub, track.Location, track.Duration.TotalMinutes.ToString("0.#"));
                }


                for (int i = 0; i < list.Count; i++)
                {
                    TrackInfoItunes track = list[i];
                    Console.WriteLine(string.Format("?delete? o/n/0/00 '{0}' {1} {2} {3} {4} ?", track.Name, track.Pub, track.Added, track.Location, track.Duration.TotalMinutes.ToString("0.#")));
                    var subReponse = Console.ReadLine();
                    if ("o".Equals(subReponse))
                        Menage.delete(track, CompacteurRead.POUBELLE+@"auto\");
                    else if ("0".Equals(subReponse))
                        break;
                    else if ("00".Equals(subReponse))
                    {
                        _break = true;
                        break;
                    }

                }
            }




            /// <summary>
            /// Compareur en vue de dégager celui qu'on garde
            /// </summary>
            private class TrackComparer : IComparer<TrackInfoItunes>
            {
                public int Compare(TrackInfoItunes x, TrackInfoItunes y)
                {
                    return x.Location.CompareTo(y.Location);
                }
            }
        }



      


     



#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} intégrés {6} supprimés", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendée Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                                break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Comment = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.iit;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Albums;
using pdb.podcast.Auto;
using pdb.podcast.Delta;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Sort;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;
using PlayList = pdb.it.PlayList;
using pdb.podcast.Date0;
using pdb.podcast.Notes;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static ILoader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto;
        static int step = -1;
        static Program _instance = new Program();
        // static bool calculRoots = false;
        static List<HashSet<int>> lists = null;
        static AlbumMgr albumMgr = AlbumMgr.Instance;

        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        public static Chrono chrono = new Chrono();
        private static Logger logChrono;
        private static DB.Db db;

        //public static DB.Db Db { get { return db; } }


        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {

            Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono", true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true;

            FileRegister.init(new BgDictString0<FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true;

                loader.saveIds();
                //if (db != null)
                //    db.write();

                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                Console.WriteLine("\nFin de l'opération d'enregistrement.");
                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Memory.End();
                Exporter.Abort();

                //if (_writeDb != null)
                //{
                //    misc.log("attente writeDb");
                //    _writeDb.Wait();
                //}
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                if (db != null)
                    db.write();
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}

        #region Task


        private List<ITrackInfoItunes> loadTracks(bool firstStep, bool forceLoad)
        {
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
            loader.loadTracks(firstStep, forceLoad, listTrack);

            return listTrack;

        }
        #endregion


        private static void SyncDb(List<TrackInfoItunes> list, bool checkInOut)
        {
            if (db == null)
                return;
            log.log("SyncDb checkInOut= " + checkInOut); 
            foreach (TrackInfoItunes t in list)
            {
                if (checkInOut)
                    t.checkInOut();
                var tdb = db.get(t);
                if (tdb == null)
                {
                    log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                    continue;
                }
                tdb.synch(t);

            }
            log.log("Fin SyncDb checkInOut= " + checkInOut); 

        }

        public void go(string[] args)
        {
            TrackInfoItunes.AlbumMgr = albumMgr;
            int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            if (countArgs > 0)
                confFile = args[0];
            bool _fin = false;

            Album.logDebug = Logger.getLogger("pubDebug", false);
            Album.log = Logger.getLogger("pub2", Album.logDebug, true);
            Album.logDebug.NoReset = true;
            Album.log.NoReset = true;
            Hibernator hibernator = new Hibernator();
            DateRefBuilder dateRefBuilder = new DateRefBuilder();
            try
            {

                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start(60);

                // bool firstLoad = true;


                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                TrackInfoItunes.setDate0(Conf.Date0);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                TrackInfoItunes.PlayedLevel = Conf.DateLevel;
                var itConf = new pdb.it.Conf(xelt);

                // loader = new Loader(itConf, true);
                bool import = Conf.Import.enabled || Conf.Import.merge;
                db = new DB.Db();


                if (Conf.UseMock)
                    loader = new MockLoader(itConf.DefaultFolder);
                else
                    loader = new Loader(itConf, import, db, 
                        () =>
                        {
                            misc.Pre = "[Load " + step + "] ";

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.AbortSpecial();
                            //   Thread.Sleep(1000); 
                            //  BackGroundTaskMgr.Start(); 
                        }, Conf.OnlyEnabled, Conf.OnlyUnRead)

                   ;
                // loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder;

                db.load();
                //  db.write(); return; 

                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();

                List<TrackInfoItunes> listIt = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);




                bool firstlaunched = false;
                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}"));
                        chrono.reset("Program");

                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.setConf(xelt);
                        //loader.Conf = new it.Conf(xelt);
                        // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut", true);
                        List<TrackInfoItunes> list = null;
                        DirConf root = null;
                        if (step == 0 || !Conf.Simulation)
                        {
                            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();


                            listTrack = loadTracks(step == 0, AutoBuilder.MustUpdate);
                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();

                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            // listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {

                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                // loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            //    loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            listIt = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            GroupStat trackStat = new GroupStat();

                            loader.saveIds();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    dictLoc[t.Location] = t;
                                    listIt.Add(t);
                                    if (!t.Played)
                                        trackStat.recordTrack(t, typeState.all);
                                    trackStat.recordTrack(t, typeState.all);
                                }
                            }

                            db.recordIt(listIt);
                            chrono.bip("loadTracks", true);


                            // ici on peut faire la verification des doublons - track hibernés et re-téléchargés par ce con d'itunes
                            var albumConsolid = new AlbumConsolid();
                            foreach (TrackAlbum album in albumMgr.List)
                            {
                                albumConsolid.consolid(album);
                            }

                            log.log("nb123={0} nb12={1} nb13={2} nb23={3} nb1={4} nb2={5} nb3={6} nb0={7}, nb3n={8}",
                                AlbumConsolid.nb123, AlbumConsolid.nb12, AlbumConsolid.nb13, AlbumConsolid.nb23,
                                AlbumConsolid.nb1, AlbumConsolid.nb2, AlbumConsolid.nb3, AlbumConsolid.nb0, AlbumConsolid.nb3n);

                            if (Conf.Import.enabled)
                            {
                                var listImport = new List<TrackInfoItunes>();
                                hibernator.select(Conf.Import, listImport, db.Tracks, true);

                                foreach (TrackInfoItunes tdb in listImport)
                                {
                                    loader.import(tdb);
                                }
                            }
                            else if (Conf.Import.merge)
                            {
                                foreach (TrackInfoItunes t in listIt)
                                    loader.merge(t);
                            }

                            root = Conf.DirConf;
                            var feeds = root.Feeds;

                            list = db.Tracks;
                            foreach (TrackInfoItunes track in list)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds", true);

                            var loaded = feeds.Loaded;
                            loaded.Sort(new PodCastComparer());


                            xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            loader.setConf(xelt);

                            if (Conf.Freewheel)
                            {
                                Freewheel(root);
                                log.log("Freewheel : fin sans enregistrement DB");
                                return; 
                            }


                            if (Conf.Sort.selectionBefore)
                            {



                                //***************** Lancement "pour de vrai" ***************************************

                                LimitItemLoader.ModeSelection = true;

                                loadCandidat(root);
                                chrono.bip("loadCandidat(root)");
                                //  AutoBuilder.test(); 
                                // standAlone(root); 
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root)");
                                //**********************************************************************************




                            }


                            if (Conf.Sort.checkBefore)
                            {
                                Album.Init();
                                var sorter = new Sorter(Conf.Sort, list);
                                sorter.build();
                                chrono.bip("sorter.build();", true);


                                if (Album.NbRepeches > 0)
                                {
                                    log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                    _fin = true;
                                }
                            }

                            if (Conf.Import.enabled || Conf.Import.merge)
                            {
                                _fin = true;

                            }

                           

                            if (_fin)
                            {
                                log.log("fin sans enregistrement DB");
                                //  db.write();


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, false);
                                //****************************************
                                return;
                            }


                            if (Album.NbModif > 0)
                            {
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                            }
                            bool changeDate = false; 
                            if ( Conf.Sort.enabled == Tuning.Sort.sortMode.once_all)
                            {
                                changeDate = dateRefBuilder.auto(loaded);
                                TrackInfoItunes.setDate0(Conf.Date0);
                                double offsetIni = dateRefBuilder.getOffset();
                                AutoBuilder.Offset = offsetIni;
                            }
                            AutoBuilder.init(true);
                            if (Conf.Sort.stopOnOffset && changeDate)
                            {
                                log.log("fin cause stopOnOffset");                              
                                return; 
                            }
                            AutoBuilder.Offset = 0;
                            chrono.bip("AutoBuilder.init(true)");
                            xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            loader.setConf(xelt);
                            dateRefBuilder.saveCurrent();
                            ContexteBuilder.Instance.init(loaded);



                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            trackStat.report(descTrack);
                            log.log(descTrack.ToString());

                            var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            var trackFile = DescBuilder.create("Tracks", sbT);
                            trackStat.report(trackFile);
                            sbT.Flush();

                            asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            chrono.bip("desc tracks", true);
                            Logger.LogConsole = false;
                            //        loader.loadLists();
                            Logger.LogConsole = true;
                            chrono.bip("load list", true);

                        }
                        list = db.Tracks;


                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program");
                            root = Conf.DirConf;
                            var feeds = root.Feeds;
                            foreach (TrackInfoItunes track in feeds.getSelectedTracks())
                            {
                                track.clearLists();
                            }

                            feeds.clearSelectedTracks();

                            chrono.bip("track.clearLists", true);

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;




                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true;
                            AutoBuilder.init(true);
                            chrono.bip("AutoBuilder.init(true)");
                            loadCandidat(root);
                            chrono.bip("loadCandidat(root)");
                            //  AutoBuilder.test(); 
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            chrono.bip("Selection(root)");
                            //**********************************************************************************

                            Album.Init();
                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.reset || Conf.Sort.enabled == Tuning.Sort.sortMode.once || (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all && !firstlaunched))
                            {
                                var sorter = new Sorter(Conf.Sort, list);
                                sorter.build();
                                _fin = Conf.Sort.enabled == Tuning.Sort.sortMode.once || Conf.Sort.enabled == Tuning.Sort.sortMode.reset;
                            }

                            firstlaunched = true;

                            if (Album.NbRepeches > 0)
                            {
                                log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                _fin = true;
                            }



                            if (!_fin) // && Album.NbModif == 0)
                            {

                                //***************** Lancement "pour de faux" ***************************************
                                AutoBuilder.Init3();
                                chrono.bip("AutoBuilder.Init3()"); 
                                LimitItemLoader.ModeSelection = false;
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root) 2"); 
                                LimitItemLoader.ModeSelection = true;
                                //**********************************************************************************
                            }
                            Exporter.TopCopy();
                            chrono.bip("selection"); 




                            // Conf.date00Consume();
                            TrackInfoItunes.setDate0(Conf.Date0);

                            int iii = 0;
                            while (!BackGroundTaskMgr.ConfirmEnd(10))
                            {
                                iii++;
                                if (iii == 60)
                                    iii = 0;
                                if (iii == 0)
                                {
                                    log.log("Attente Classement");
                                }
                                Thread.Sleep(100);
                            }






                            if (_fin || Album.NbModif > 0)
                            {
                                log.log("{0} éléments ont la Pub2 modifiée", Album.NbModif);
                                SyncDb(list, true); 
                                //foreach (TrackInfoItunes t in list)
                                //{
                                //    var tdb = db.get(t);
                                //    if (tdb == null)
                                //    {
                                //        log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                //        continue;
                                //    }
                                //    tdb.synch(t);

                                //}

                                db.writeAsync();

                                if (_fin)
                                {
                                    log.log("fin");
                                    return;
                                }
                                // continue;
                            }




                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    //if (count == 1)
                                    //    s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu"); 

                            if (Conf.GenFeed)
                            {
                                foreach (RootItItem rootItem in Conf.RootIt)
                                {
                                    var fAuto = loader.TreePlayList.getComposite(rootItem.name);
                                    var fFeeds = fAuto.getComposite("Feed");

                                    if (fFeeds != null)
                                    {
                                        scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                    }

                                }
                            }


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root, false);
                            //****************************************



                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                            //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            chrono.bip("AutoBuilder.init(false)"); 
                            bool cangoAuto = AutoBuilder.Check(feeds);

                            chrono.bip("AutoBuilder"); 
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");

                                postReport(root, true);

                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false;
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true;
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                //  tw = new StringBuilder();
                                //feeds.rapportPreSelected(tw);
                                //asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false;
                                log.log(sb2.ToString());
                                Logger.LogConsole = true;


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false;
                                log.log(sb3.ToString());
                                Logger.LogConsole = true;
                                chrono.bip("rapport", true); 
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 

                        SyncDb(list, true);
                        db.writeAsync();


                        Logger.CreateNullLoggers = false;


                        lists = null;
                        WritePlayList(root);




                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;

                            Dictionary<string, Dictionary<int, TrackInfoItunes>> depots = new Dictionary<string, Dictionary<int, TrackInfoItunes>>();
                            foreach (SelectParam p in listP)
                            {

                                listS = new List<TrackInfoItunes>();
                                if (!string.IsNullOrEmpty(p.name))
                                {
                                    // Compatibilité anciennes listes
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                    buildList("_" + p.level, listS, prior, folder);
                                }
                                else
                                {

                                    var pp = p.Clone() as SelectParam;
                                    feeds.buildFirstSelectedTrackLevel(listS, p);

                                    var l = new List<TrackInfoItunes>();

                                    pp.nb = int.MaxValue;
                                    var selector = new TrackSelector(pp);
                                    foreach (TrackInfoItunes t in listS)
                                    {
                                        if (selector.select(t))
                                            l.Add(t);
                                    }

                                    string path = p.path;
                                    if (!string.IsNullOrWhiteSpace(path))
                                        buildList(path, l, prior);

                                    string[] _depots = p.depot;
                                    if (_depots != null)
                                    {
                                        foreach (string depot in _depots)
                                        {
                                            if (!depots.ContainsKey(depot))
                                                depots.Add(depot, new Dictionary<int, TrackInfoItunes>());

                                            var dep = depots[depot];
                                            foreach (TrackInfoItunes t in l)
                                            {
                                                if (!dep.ContainsKey(t.DbId))
                                                    dep.Add(t.DbId, t);
                                            }
                                        }
                                    }
                                }
                            }

                            foreach (KeyValuePair<string, Dictionary<int, TrackInfoItunes>> kvp in depots)
                            {
                                string path = kvp.Key;

                                var l = new List<TrackInfoItunes>(kvp.Value.Values);
                                l.Sort(new PodcastComparerPubPub2());
                                buildList(path, l, prior);
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);

                        var listSelected = root.Feeds.getSelectedTracks();

                        var sorterafter = new Sorter(Conf.Sort, list);
                        //    sorter.build();

                        foreach (TrackInfoItunes s in listSelected)
                        {
                            s.updateNative();
                        }






                        //if (Conf.Hibernate.enabled)
                        //{
                        //    Hibernator hibernator = new Hibernator();
                        //    var nb = hibernator.go(loader); 
                        //    if (nb >0)
                        //    {
                        //        misc.log("{0} elements hibernés", nb);
                        //        misc.log("fin ");
                        //        return; 
                        //    }

                        //}


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                log.log("Attente Classement");
                            }
                            Thread.Sleep(100);
                        }



                        //if (Conf.Sort.enabled >= Tuning.Sort.sortMode.once_all)
                        //{
                        //    var sorter = new Sorter(Conf.Sort, list);
                        //    sorter.build();
                        //}

                        int nbH = 0;
                        _fin = false;
                        if (Conf.Hibernate.enabled)
                        {
                            nbH = hibernator.go(loader, list);
                            if (nbH > 0)
                            {
                                log.log("{0} elements hibernés", nbH);
                                _fin = true;
                            }
                        }

                        if (loader.NbTrackCreated > 0)
                        {
                            log.log("{0} éléments ont été recréés", loader.NbTrackCreated);
                            _fin = true;
                        }

                        if (Album.NbRepeches > 0)
                        {
                            log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                            _fin = true;
                        }

                     
                       




                        if (_fin)
                        {


                            log.log("fin");
                          
                            return;
                        }





                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");



                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in db.Tracks)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogAll(ex.ToString());
                        misc.log(ex.ToString());
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        //private DirConf _attenteWriteHtml;
        // private volatile object _lockReportHtml = new object();
        private bool _end;
        // ThreadUtil thReport;
        DateTime lastReport;

        private void postReport(DirConf dir, bool force)
        {
            if (force || lastReport.AddSeconds(10) < DateTime.Now)
            {
                try
                {
                    reportHtml(dir);
                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                lastReport = DateTime.Now;
            }
            //if (thReport == null)
            //{
            //    lock (_lockReportHtml)
            //    {
            //        if (thReport == null)
            //        {
            //            thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
            //            thReport.Start();
            //        }
            //    }
            //}

            //lock (_lockReportHtml)
            //    _attenteWriteHtml = dir;
        }

        //private void loopReportHtml()
        //{
        //    DirConf traite = null;
        //    while (!_end)
        //    {
        //        Thread.Sleep(1000);
        //        if (_attenteWriteHtml == null)
        //            continue;
        //        lock (_lockReportHtml)
        //        {
        //            if (_attenteWriteHtml == null)
        //                continue;
        //            traite = _attenteWriteHtml;
        //            _attenteWriteHtml = null;
        //        }
        //        reportHtml(traite);
        //    }
        //}


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
                //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
                //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders, false);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders, false);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders, false);
        }

        public static void buildList(string path, List<TrackInfoItunes> list_, int prior)
        {
            bool absolutePath = path.StartsWith(@"\");
            var tab = path.Split('\\');
            int count = tab.GetLength(0);
            var folder = new List<string>();

            foreach (string s in tab)
            {
                if (!string.IsNullOrWhiteSpace(s))
                    folder.Add(s);
            }

            buildList(list_, prior, folder, absolutePath);
        }



        public static void buildList(List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            var newf = new List<string>(folders);
            int count = newf.Count;

            string name = newf[count - 1];
            newf.RemoveAt(count - 1);
            buildList(name, list_, prior, newf, absolutePath);
        }

       

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            try
            {
                if (Conf.Simulation)
                    return;
                if (Conf.UseMock)
                {
                    var sb = new StringBuilder();
                    foreach (string f in folders)
                    {
                        sb.Append(f); sb.Append(@"\");
                    }
                    sb.Append(name);
                    log.logNoDate("---------------------------");
                    log.log("liste {0}", sb.ToString());
                    if (list_ != null)
                    {
                        foreach (TrackInfoItunes t in list_)
                        {
                            log.logNoDate(t.ToString());
                        }
                    }
                    return;
                }

                if (list_ != null)
                {
                    foreach (TrackInfoItunes track in list_)
                    {
                        loader.reviveIfNecessary(track);
                    }
                }
              


                var rootIt = Conf.RootIt;
                RootItItem currentRoot = rootIt.roots[0];
                int count = rootIt.roots.Count;

                if (list_ != null)
                {
                    //   log.log("build list {0}",name);
                    //  var list = new List<IFile>(list_);
                    if (lists == null)
                    {
                        lists = new List<HashSet<int>>();
                        foreach (var item in rootIt.roots)
                        {
                            lists.Add(new HashSet<int>());
                        }
                        var list__ = new List<TrackInfoItunes>(list_);
                        list__.Sort(new PodcastComparerPubPub2());



                        int countTrack = list_.Count;

                        long size = 0;
                        int j = 0;
                        int indexRoot = 0;

                        //    HashSet<int> current = lists[0]; 

                        while (true)
                        {
                            if (j >= countTrack)
                                break;
                            TrackInfoItunes track = list__[j];
                            size += track.Size;
                            if (size <= currentRoot.size)
                            {
                                lists[indexRoot].Add(track.DbId);
                                // track.IndexRoot = indexRoot;
                            }
                            else
                            {

                                size = 0;
                                //  size += track.Size;
                                indexRoot++;
                                if (indexRoot >= count)
                                    break;
                                currentRoot = rootIt.roots[indexRoot];
                                continue;
                            }
                            j++;
                        }

                    }
                }


                for (int r = 0; r < count; r++)
                {
                    currentRoot = rootIt.roots[r];
                    folders = new List<string>(folders);
                    PlayListComposite folder = null;

                    if (absolutePath)
                    {
                        if (r > 0)
                            throw new Exception("un chemin absolu ne peut pas être géré dans une partition");
                        // folders[0] = folders[0].Substring(1);
                        folder = loader.TreePlayList;

                    }
                    else
                        folder = loader.TreePlayList.getComposite(currentRoot.name);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(currentRoot.name);


                    var nname = name;
                    if (name.Contains(Path.DirectorySeparatorChar.ToString()))
                    {
                        var tab = name.Split(Path.DirectorySeparatorChar);
                        string str = null;
                        for (int i = 0; i < tab.GetLength(0); i++)
                        {
                            if (str != null)
                                folders.Add(str);
                            if (!string.IsNullOrEmpty(tab[i]))
                                str = tab[i];
                        }
                        if (!string.IsNullOrEmpty(str))
                            nname = str;
                    }
                    List<IFile> l = null; 
                   
                    if (list_ != null)
                    {
                        l = new List<IFile>();
                        foreach (TrackInfoItunes t in list_)
                        {
                            if (lists[r].Contains(t.DbId))
                                l.Add(t);
                        }
                    }
                   

                    for (int i = 0; i < folders.Count; i++)
                    {
                        var aux = folder;
                        folder = folder.getComposite(folders[i]);
                        if (folder == null)
                            folder = loader.getOrCreateFolder(aux, folders[i], l==null? true : l.Count > 0);
                        if (folder == null)
                            return;
                    }

                    //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
                    var playlist = loader.getPlayList(folder, nname, l == null ? true : l.Count > 0);
                    if (playlist != null)
                    {
                        if (prior < int.MaxValue && prior >= 0)
                            playlist.setPrior(prior);
                        //if (list.Count > 0)


                        playlist.mergeList(l, _instance, Conf.OnlyEnabled, Conf.OnlyUnRead); 
                        //  loader.mergeList(playlist, l, false, _instance, null);
                        //else
                        //    loader.removeList(folder, name);
                    }



                    //log.log("clear list {0}", name); 
                    //loader.ClearList(playlist);
                    //log.log("add items {0}", name); 
                    //foreach (TrackInfoItunes track in list)
                    //    loader.addItemToList(playlist, track); 

                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }


        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildGlobalList(string path, List<TrackInfoItunes> list_, int prior)
        {
            PlayListComposite folder = null;
            List<string> folders = new List<string>();
            string nname = "";
            if (Conf.UseMock)
                return;
            try
            {

                var tab = path.Split(Path.DirectorySeparatorChar);
                string str = null;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    if (str != null)
                        folders.Add(str);
                    if (!string.IsNullOrEmpty(tab[i]))
                        str = tab[i];
                }
                if (!string.IsNullOrEmpty(str))
                    nname = str;

                folder = loader.TreePlayList;





                var l = new List<IFile>();
                foreach (TrackInfoItunes t in list_)
                {
                    if (t.Present)
                        l.Add(t);
                }

                for (int i = 0; i < folders.Count; i++)
                {
                    var aux = folder;
                    folder = folder.getComposite(folders[i]);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(aux, folders[i], l.Count > 0);
                    if (folder == null)
                        return;
                }


                var playlist = loader.getPlayList(folder, nname, l.Count > 0);
                if (playlist != null)
                {
                    if (prior < int.MaxValue && prior >= 0)
                        playlist.setPrior(prior);


                    playlist.mergeList(l, _instance, Conf.OnlyEnabled, Conf.OnlyUnRead); 

                }



            }

            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }




        }

        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            DateTime now = DateTime.Now;

            fLoader.Action(pre);
            var ts = (DateTime.Now - now).TotalMilliseconds;
            if (ts > 1 && Conf.LogDir && pre > action.none && pre < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", pre, dir.getPath(), ts.ToString("0"));
            }

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());

            now = DateTime.Now; ts = (DateTime.Now - now).TotalMilliseconds;
            fLoader.Action(post);

            if (ts > 1 && Conf.LogDir && post > action.none && post < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", post, dir.getPath(), (DateTime.Now - now).TotalMilliseconds.ToString("0"));
            }


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void Freewheel(DirConf dir)
        {
            recursif(dir, action.freewheel, action.none); 
        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
            List<TrackInfoItunes> list = null;
            //  var list = db.Tracks.FindAll(t => t.Present);
            //var list = db.Tracks.FindAll(t => t.isConcernedBySelection); 
            if (Conf.UseMock)
                list = db.Tracks.FindAll(t => t.isConcernedBySelection);
            else
                list = db.Tracks.FindAll(t => t.Present && t.isConcernedBySelection);
            foreach (SelectParamBase listeGlobal in Conf.GlobalListes)
            {
                var selector = new TrackSelector(listeGlobal);
                var l = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (selector.select(t))
                        l.Add(t);
                }

                buildGlobalList(listeGlobal.path, l, 2);

            }

            foreach (Note note in Conf.Notes)
            {
                var builder = new NoteBuilder(note);
                builder.build(list);
                foreach (ListNote listNote in builder.Depot)
                {
                    var path = string.Format(@"{0}\{1}", note.path, listNote.Note.ToString("00"));
                    var _l = listNote.List;
                    buildGlobalList(path, _l, 2);
                }
            }

            var contextB = ContexteBuilder.Instance;

            if (contextB.Enabled)
            {

                var selected = dir.getListe();
                selected.Sort(new PodCastComparer());

                //   contextB.init(selected); 
                var listContext = new List<TrackInfoItunes>();
                contextB.buildList(selected, listContext);

                buildList("_contexte", listContext, 2);
            }



        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                                break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Comment = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\FeedsLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;

namespace pdb.podcast.Load
{
    public enum action
    {
        none,
        loadCandidat,
        //standAlone,
        phase2,
        selectionPre,
        selectionPost,
        writeLists,
        freewheel,
        writeTracksPre,
        writeTracksPost
    }
    /// <summary>
    /// Chargeur de répertoire
    /// </summary>
    public class FeedsLoader
    {
        /// <summary>
        /// Registre des albums
        /// </summary>
        private Feeds feeds;
        /// <summary>
        /// Répertoire considéré
        /// </summary>
        private DirConf dir;

      
        private LimitsLoader limitsLoader; 
      //  private Logger log;

      

        public FeedsLoader(DirConf dir)
        {
            this.feeds = dir.Feeds;
            this.dir = dir;
            limitsLoader = new LimitsLoader(dir); 
         //   log = Logger.getLogger(dir.getPath() + "\\dir", false); 
        }

        public void init(DirConf dir)
        {
            this.feeds = dir.Feeds;
            this.dir = dir;
            limitsLoader.init(dir); 
        }



        private Load.Albums albums;

        internal Albums Albums
        {
            get
            {
                if (albums != null)
                    return albums;
                var parent = dir.Parent; 
                if (parent == null)
                    throw new ArgumentException();
                if (parent.Parent == null)
                {
                    albums = new Albums(dir);
                    return albums; 
                }
                albums = parent.Loader.Albums;
                return albums; 

            }
            set
            {
                albums = value; 
            }
        }

        public LimitsLoader LimitsLoader { get { return limitsLoader;  } }


        public void Action(action action)
        {
            switch (action)
            {
                case action.loadCandidat: //log.log("{0} Récupération des candidats", dir);
                    limitsLoader.loadCandidats(); 
                     break;
               // case Load.action.standAlone: standAlone(); break;
                case action.phase2: limitsLoader.phase2(); break;
                case action.selectionPre: limitsLoader.SelectionPre(); break;
                case action.selectionPost:  limitsLoader.SelectionPost(); break;
                case action.writeLists: limitsLoader.WriteLists(); break;
                case action.freewheel: limitsLoader.Freewheel(); break;
                case action.writeTracksPre: limitsLoader.WriteTracksPre(); break;
                case action.writeTracksPost: limitsLoader.WriteTracksPost(); break; 
                default:
                    break;
            }
        }

    

        ///// <summary>
        ///// Constitution de la liste
        ///// </summary>
        //private void LoadCandidats()
        //{
        //    // 1. récupérer les candidat (logique locale Feed (nb, feedDuration...); 
        //    //log.log("****************************************************************************************");
        //    //log.log("Récupération des candidats"); 
        //    //log.log("****************************************************************************************");
            
        //    log.log( "{0} Récupération des candidats", dir);
        //    limitsLoader.loadCandidats(); 
        //    //string feedName = null;
        //    //bool histo = dir.Histo;
        //    //bool? histoAll = dir.HistoAll;
        //    //if (histo)
        //    //    feedName = dir.Name;

        //    //var logList = new List<TrackInfoItunes>();

        //    //foreach (var feed in feeds)
        //    //{
        //    //    if (true.Equals(histoAll) || !histo || (histo && false.Equals(histoAll) && feed.Name.Equals(feedName)))
        //    //    {
        //    //        var feedLoader = getLoader(feed.Name); // new FeedLoader(dir, feed, this, false);
        //    //        feedLoader.loadCandidats();
        //    //    }
        //    //}
        //}

       

        //private void standAlone()
        //{
        //    log.log("{0} standAlone", dir); 
        //    bool dirHisto = dir.Histo;



        //    for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
        //    {
        //        var limit = dir.Limites[i];
        //        foreach (LimitItem item in limit.Items)
        //        {
        //            int levelMin = limit.Level;
        //            int ratingMin = levelMin * 20;
        //            int duration = item.Duration;
        //            var DurationMax = TimeSpan.FromMinutes(duration);
        //            TimeSpan currentDuration = new TimeSpan();
        //            //bool durationLimitAtteinte = false;

        //            if (item.Nb == 0 || item.FeedDuration == 0 || item.Duration == 0)
        //                continue;


        //            var _depot = new SequentialDictString<TrackInfoItunes>();
        //            depot(_depot, item, depotType.load);

        //            var list = _depot.List;
        //            if (dirHisto)
        //                list.Sort(new PodCastComparer());
        //            else
        //                list.Sort(new PodCastComparerInv());

        //            foreach (TrackInfoItunes candidat in list)
        //            {
        //                if (candidat.Rating < ratingMin)
        //                    continue;
        //                if (dir.Info.HasValue)
        //                {
        //                    bool bInfo = dir.Info.Value;
        //                    if (candidat.Info != bInfo)
        //                        continue;
        //                }

        //                if (dir.Rare.HasValue)
        //                {
        //                    bool bRare = dir.Rare.Value;
        //                    if (candidat.Rare != bRare)
        //                        continue;
        //                }

        //                if (!control(candidat, item,false))
        //                    continue;

        //                // enregistrement pour stockage et stats
        //              //  dir.recordTrackStandAlone(candidat, item);
        //                currentDuration += candidat.Duration;




        //                candidat.select(selectMode.standAlone, item);

        //                //  feeds.recordTrack(candidat, item);

        //                if (currentDuration > DurationMax)
        //                {
        //                    //if (!durationLimitAtteinte)
        //                    //{
        //                    //Logger.getLogger(dir.getPath() + "\\dir", false).log("duration {0}", (currentDuration + candidat.Duration).TotalMinutes.ToString("0"));
        //                    //item.DurationLimitAtteinte = true;
        //                    //}
        //                    //durationLimitAtteinte = true;
        //                    break;
        //                }

        //            }


        //        }
        //    }
        //}



        //private FeedLoader getLoader(string album)
        //{
        //    var loader = loaders.Find(l => l.feed.Name == album);
        //    if (loader == null)
        //    {
        //        loader = new FeedLoader(dir, feeds[album], this);
        //        loaders.Add(loader);
        //    }
        //    return loader;
        //}

        //private void depot(IDictionary<string, TrackInfoItunes> depot, LimitItem item, depotType type)
        //{
        //    foreach (var loader in loaders)
        //    {
        //        loader.depot(depot, item, type);
        //    }
        //}



        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //   // getLoader(track.Album).recordTrackFromChild(track, itemSource);
        //    limitsLoader.recordTrackFromChild(track, itemSource, transmitTotal); 
        //}

    


        //private bool control(TrackInfoItunes track, LimitItem item, bool select)
        //{
        //    //var loader = getLoader(track.Album);
        //    //return loader.control(track, item,select);
        //}

        ///// <summary>
        ///// Enregistrement d'un candidat 1ere phase
        ///// </summary>
        ///// <param name="track"></param>
        //public void recordCandidat(TrackInfoItunes track)
        //{
        //    string location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    if (!dict.ContainsKey(location))
        //    {
        //        dict.Add(location, track);
        //    }
        //}

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Tuning;
using pdb.util;
using System.Collections.Generic;
using System.Xml;
using System;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public class LimitsLoader
    {
        private DirConf dir;
        //  private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
        // public loadState state;
        //  private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
            var limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
            //  log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void init(DirConf dir)
        {
            this.dir = dir;
            var limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].init(this, limit[i]);
            }
        }

        //public void getLoaders(List<LimitItemLoader> list)
        //{
        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].getLoaders(list);
        //    }
        //}

        private bool candidatLoaded;
        public void loadCandidats()
        {
            if (candidatLoaded)
            {
                foreach (LimitLoader item in limites)
                {
                    item.reset();
                }
                return;
            }
            try
            {
                var feeds = dir.Feeds;
                string feedName = null;
                bool histo = dir.Histo;
                bool? histoAll = dir.HistoAll;
                if (histo && false.Equals(histoAll))
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();



                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null)
                    {
                        if (track.Album != feedName)
                            continue;
                    }

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    loaded.Add(track);
                }

                if (histo)
                {
                    loaded.Sort(new PodcastComparerPubPub2());
                    //if (Conf.Albums.checkPub)
                    //    loaded.Sort(new PodCastComparer());
                    //else
                    //    loaded.Sort(new PodCastComparerPub2());
                }
                else
                    loaded.Sort(new PodCastComparerInv());


                //   for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    limit.loadCandidats(loaded);

                }


            }
            finally
            {
                //state = loadState.selection;
                candidatLoaded = true;
            }
        }

        private bool recordGuests;
        public void phase2()
        {
            // state = loadState.selection;
            if (dir.Cascading)
                recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        //public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        //{

        //    if (!recordGuests)
        //        return;


        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].recordGuest(track, item);
        //    }
        //}

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
        //    }
        //}


        public void Freewheel()
        {
            var lfolders = dir.Folders;
            buildListPrior("_auto", null, lfolders);
        }

        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                var list = dir.getListe();

                var limits = dir.Limites;
                var usegenPrior = Conf.GenUsePrior;
                var exclugenPrior = Conf.GenExcluPrior;

                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    List<TrackInfoItunes> items;
                    foreach (LimitItemLoader item in limit.Items)
                    {
                        // var index = limit.index(item);
                        //if (Conf.WriteItems)
                        //{
                        //    items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                        //    buildList(item.Item.ID, items, "_sel");
                        //}

                        //if (Conf.WritePreSel)
                        //{
                        //    items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                        //    buildList(item.Item.ID, items, "_sel0");
                        //}
                        //if (Conf.WriteUse)
                        //{
                        //    items = item.use;
                        //    buildList(item.Item.ID, usegenPrior, items, "_use");
                        //}
                        //if (Conf.WriteExclu)
                        //{
                        //    var limite = item.Item;
                        //    items = item.use.FindAll(t => t.Exclu == limite);
                        //    buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                        //}

                    }
                }

                //if (dir.Parent == null)
                //{
                if (dir.Parent == null)
                {

                    var lfolders = dir.Folders;

                    buildListPrior("_auto", list, lfolders);



                    foreach (SelectParamBase listeSuppl in Conf.Listes)
                    {
                        var selector = new TrackSelector(listeSuppl);
                        var l = new List<TrackInfoItunes>();
                        foreach (TrackInfoItunes t in list)
                        {
                            if (selector.select(t))
                                l.Add(t);
                        }

                        buildListPrior(listeSuppl.name, l, lfolders);
                    }

                    //var lHisto = list.FindAll(t => t.Histo);
                    //buildList("_histo", lHisto, lfolders);

                    //var lPasHisto = list.FindAll(t => !t.Histo);
                    //buildList("_pasHisto", lPasHisto, lfolders);

                    //var lSerie = list.FindAll(t => t.Serial);
                    //buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        //private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        //{
        //    Program.buildList(name, list, folders);
        //}
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders, false);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0;
            foreach (TrackInfoItunes track in list)
            {
                nb++;
                writer.StartElement("t");
                writer.SetAttribute("dt", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));

                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }

                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                writer.SetAttribute("track", track.Name);

                if (track.Pub2 > track.Pub)
                {
                    writer.SetAttribute("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                    writer.SetAttribute("e", (track.Pub2 - track.Pub).TotalDays.ToString("0.#"));
                }
                if (nb <= nbmax)
                {
                    WriteCause(dir.CauseRegister.Get(track), true, true);
                    WriteCause(dir.CauseRegister.Get(track), true, false);
                    WriteCause(dir.CauseRegister.Get(track), false, true);
                    WriteCause(dir.CauseRegister.Get(track), false, false);

                }
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodcastComparerPubPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion

            #region long
            writer.StartElement("longs");

            var longs = items.FindAll(t => !t.isConcernedBySelection); 
            writeTrackList(longs, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (false != dir.HistoAll)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;


                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    try
                    {
                        writer.StartElement("i");
                        writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                        var sb = new StringBuilder();
                        lim.writeStatHeader(sb);
                        lim.Stat.Total.buildValues(sb);
                        writer.SetAttribute("stats", sb.ToString());

                        writeTracks(dir, lim.Stat, null, false);
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }

                    finally
                    {
                        writer.EndElement();
                    }
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes, bool strict, bool ok)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses(strict, ok, ok))
            {
                string str = "cause";
                if (strict)
                    str += "strict";
                if (!ok)
                    str += "nok";
                writer.StartElement(str);


                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString());
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause > 0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0;
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list = dir.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break;
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        if (track.Pub2 > track.Pub)
                            writer.SetAttribute("pub2", track.Pub2);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes, true, true);
                        WriteCause(causes, true, false);

                        WriteCause(causes, false, true);
                        WriteCause(causes, false, false);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {

            //log.log("{0} Selection", dir);

            //for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                limit.Selection();

            }

        }

        public override string ToString()
        {
            return dir.ToString();
        }

    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.ordo.conf;
using pdb.podcast.Auto;
using pdb.util;

namespace pdb.podcast.Tuning
{
    public enum menage
    {
        none,
        read,
        name
    }
    public class Conf
    {
        string SOV = "..\\sov\\";
        //private static string CONF_FILE = @"..\conf.xml";
        #region membres
        private DirConf root;
        private XmlElement xDir;
        private bool buildLimitMulti;
        private bool single;
        private Move move;
        private bool deleteDoublon;
        private bool getDescription;
        private int volumeMin = int.MinValue;
        private bool simulation;
        private string copyAll;
        private int maxScan = 10;
        private ConfOrdo ordo = new ConfOrdo();
        private menage menage = menage.none;
        private string poubelle = "";
        // private string zique;
        private bool writePlayLists;
        private bool writePreSel;
        private bool writeItems;
        private bool writeUse;
        private bool writeExclu;
        private bool genFeed;
        private int genFeedPrior = 11;
        private int genUsePrior = 11;
        private int genExcluPrior = 11;
        //private bool transmit = true;
        //private bool transmitTotal = true;
        //private bool transmitTotalGuest = true;
        private bool? cascading = null;
        private bool autoBlock;

        private ConfDate dates = new ConfDate();

        private List<SelectParam> selectParams = new List<SelectParam>();
        private List<Note> notes = new List<Note>();
        private Journal journal;
        private RootIt rootIt = new RootIt();
        private bool onlyEnabled = true;
        private bool onlyUnRead = true;
        private bool checkExist = true;

        // private Auto auto = null;
        private bool logGen = true;
        //private DateTime date0;
        //private DateTime date00;
        private double deltaOpen = 70;
        private Html html = new Html();

        private bool autoSequence = true;
        private bool borderVirtual;
        private bool borderIdem;
        private bool borderGranSlam;
        private bool borderTb;
        private bool autoSelect;
        private bool logDir;

        private Export export = new Export();
        private Hibernate import = new Hibernate();
        private Sort.Sort sort = new Sort.Sort();
        private Hibernate hibernate = new Hibernate();
        private Db db = new Db();
        private ConfAlbums albums = new ConfAlbums();
        private Listes listes = new Listes();
        private Listes globalListes = new Listes();

        private bool checkPub = true;

        private bool useMock;
        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        private bool freewheel = false; 


        private Contexte contexte = new Contexte();
        private DateRef dateRef = new DateRef(); 
        #endregion
        public static readonly Conf Instance = new Conf();
        private static bool started;
        private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
        public void setConfFile(string conf)
        {
            this.confFile = new FileInfo(@"..\" + conf);

            if (!Directory.Exists(SOV))
                Directory.CreateDirectory(SOV);

            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            File.Copy(confFile.FullName, string.Format("{0}{1}_{2}", SOV, timeStamp, confFile.Name), true);
        }

        #region getters
        public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
        public static bool Single { get { return Instance.single; } }
        public static DirConf DirConf { get { return Instance.root; } }
        public static Move Move { get { return Instance.move; } }
        public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
        public static bool GetDescription { get { return Instance.getDescription; } }
        public static int VolumeMin { get { return Instance.volumeMin; } }
        public static bool Simulation { get { return Instance.simulation; } }
        public static string CopyAll { get { return Instance.copyAll; } }
        public static ConfOrdo Ordo { get { return Instance.ordo; } }
        public static int MaxScan { get { return Instance.maxScan; } }
        public static menage Menage { get { return Instance.menage; } }
        public static string Poubelle { get { return Instance.poubelle; } }
        public static bool WritePlayLists { get { return Instance.writePlayLists; } }
        public static bool WritePreSel { get { return Instance.writePreSel; } }
        public static bool WriteItems { get { return Instance.writeItems; } }
        public static bool WriteUse { get { return Instance.writeUse; } }
        public static bool WriteExclu { get { return Instance.writeExclu; } }
        public static bool GenFeed { get { return Instance.genFeed; } }
        public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
        public static int GenUsePrior { get { return Instance.genUsePrior; } }
        public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

        //public static bool Transmit { get { return Instance.transmit; } }
        //public static bool TransmitTotal { get { return Instance.transmitTotal; } }
        //public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
        public static bool? Cascading { get { return Instance.cascading; } }
        public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
        public static DateTime DateLevel { get { return Instance.dates.Level; } }
      
        internal static Journal Journal { get { return Instance.journal; } }
        internal static RootIt RootIt { get { return Instance.rootIt; } }

        public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
        public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }
        public static bool CheckExist { get { return Instance.checkExist; } }

        public static bool AutoBlock { get { return Instance.autoBlock; } }
        public static bool LogGen { get { return Instance.logGen; } }

        internal static Html Html { get { return Instance.html; } }

        public static bool AutoSequence { get { return Instance.autoSequence; } }
        public static bool BorderVirtual { get { return Instance.borderVirtual; } }
        public static bool BorderIdem { get { return Instance.borderIdem; } }
        public static bool BorderGranSlam { get { return Instance.borderGranSlam; } }
        public static bool BorderTb { get { return Instance.borderTb; } }
        public static bool AutoSelect { get { return Instance.autoSelect; } }
        public static Export Export { get { return Instance.export; } }
        internal static Hibernate Import { get { return Instance.import; } }
        public static Sort.Sort Sort { get { return Instance.sort; } }
        public static ConfAlbums Albums { get { return Instance.albums; } }
        internal static Hibernate Hibernate { get { return Instance.hibernate; } }
        internal static Db Db { get { return Instance.db; } }
        /// <summary>
        /// muy important. on calcule les dates max avec pub plutôt que Pub2
        /// </summary>
        //  public static bool CheckPub { get { return Instance.checkPub; } }
        public static bool UseMock { get { return Instance.useMock; } }
        public static bool LogDir { get { return Instance.logDir; } }
        public static double DeltaOPen { get { return Instance.deltaOpen; } }
        internal static Listes Listes { get { return Instance.listes; } }
        internal static Listes GlobalListes { get { return Instance.globalListes; } }
        internal static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
        internal static List<Note> Notes { get { return Instance.notes; } }

        internal static Contexte Contexte { get { return Instance.contexte; } }
        internal static DateRef DateRef { get { return Instance.dateRef; } }

        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        public static bool Freewheel { get { return Instance.freewheel; } }
        //  public static string Zique { get { return Instance.zique; } }
        #endregion

        private DateTime lastModif = DateTime.MinValue;
        private FileInfo confFile;
        public FileInfo ConfFile { get { return confFile; } }
        #region load

        public XmlElement load(bool waitForModification)
        {

            while (true)
            {
                confFile.Refresh();
                if (!confFile.Exists)
                    throw new ApplicationException(confFile + " n'existe pas !!");
                DateTime dt = confFile.LastWriteTime;
                if (dt > lastModif || !waitForModification)
                    break;
                Thread.Sleep(1000);
            }

            lastModif = confFile.LastWriteTime;

            XmlDocument l_doc = new XmlDocument();
            l_doc.Load(confFile.FullName);

            XmlElement xroot = l_doc.DocumentElement;
            XMLTool l_xmlConf = new XMLTool(xroot);

            string str = l_xmlConf.getNodeValue("volumeMin");
            if (!string.IsNullOrEmpty(str))
                volumeMin = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("maxScan");
            if (!string.IsNullOrEmpty(str))
                maxScan = Convert.ToInt32(str);

            buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
            simulation = l_xmlConf.getBoolValue("simulation");
            //   zique = l_xmlConf.getNodeValue("zique");

            deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
            getDescription = l_xmlConf.getBoolValue("getDescription");
            copyAll = l_xmlConf.getNodeValue("copyAll");

            poubelle = l_xmlConf.getNodeValue("poubelle");

            str = l_xmlConf.getNodeValue("menage");
            if (!string.IsNullOrEmpty(str))
                menage = (menage)(Enum.Parse(typeof(menage), str, true));

            writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
            writePreSel = l_xmlConf.getBoolValue("writePreSel");
            writeItems = l_xmlConf.getBoolValue("writeItems");
            writeUse = l_xmlConf.getBoolValue("writeUse");
            writeExclu = l_xmlConf.getBoolValue("writeExclu");
            genFeed = l_xmlConf.getBoolValue("genFeed");
            str = l_xmlConf.getNodeValue("genFeedPrior");
            if (!string.IsNullOrEmpty(str))
                genFeedPrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genUsePrior");
            if (!string.IsNullOrEmpty(str))
                genUsePrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genExcluPrior");
            if (!string.IsNullOrEmpty(str))
                genExcluPrior = Convert.ToInt32(str);

            //transmit = l_xmlConf.getBoolValue("transmit");
            //transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
            //transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
            onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
            onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
            checkExist = l_xmlConf.getBoolValue("checkExist", true);
            str = l_xmlConf.getNodeValue("cascading");
            if (!string.IsNullOrEmpty(str))
                cascading = "true".Equals(str);
            //  cascading = l_xmlConf.getBoolValue("cascading");

            //str = l_xmlConf.getNodeValue("date0");
            //if (!string.IsNullOrEmpty(str))
            //    date0 = Convert.ToDateTime(str);

            //str = l_xmlConf.getNodeValue("date00");
            //if (!string.IsNullOrEmpty(str))
            //    date00 = Convert.ToDateTime(str);

            var xDateRef = l_xmlConf.NodeLookUp("dateRef");
            dateRef = new DateRef(xDateRef);

            var xDates = l_xmlConf.NodeLookUp("playedDates");
            dates = new ConfDate(xDates);

            logGen = l_xmlConf.getBoolValue("logGen");
            var createNullLoggerOrg = Logger.CreateNullLoggers;

            Logger.CreateNullLoggers = !logGen;
            xDir = l_xmlConf.NodeLookUp("dir");

            var rootLimit = new Limits();
            buildLimit(xDir, rootLimit, null);

            AutoBuilder.clear();
            root = DirConf.getDir(rootLimit, xDir.Attributes["name"].InnerText, null); //new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
            root.build(null, xDir);
            buildDirChilds(xDir, root);
            root.Init();

            // AutoBuilder.getLoaders(); 

            XmlElement xMove = l_xmlConf.NodeLookUp("move");
            move = new Move(xMove);

            ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

            selectParams.Clear();

            var xSelect = l_xmlConf.NodeLookUp("select");
            if (xSelect != null)
            {
                foreach (XmlNode xsub in xSelect)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        selectParams.Add(new SelectParam(xSelect, x));
                }
            }

            notes.Clear();
            var xNotes = l_xmlConf.NodeLookUp("notes");
            if (xNotes != null)
            {
                foreach (XmlNode xsub in xNotes)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        notes.Add(new Note(x));
                }
            }

            journal = null;
            var xJournal = XMLTool.NodeLookUp(xroot, "journal");
            if (xJournal != null)
            {
                journal = new Tuning.Journal();
                buildLimitItem(xJournal, xJournal, journal);
                var xxJournal = new XMLTool(xJournal);
                journal.NbJour = xxJournal.getIntAttValue("nbJour");
            }

            rootIt = new Tuning.RootIt(l_xmlConf.NodeLookUp("rootIt")); //  l_xmlConf.getNodeValue("rootIt");

            autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
            //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
            //if (xAuto == null)
            //    auto = null;
            //else
            //    auto = new Auto(xAuto);

            XmlElement xHtml = l_xmlConf.NodeLookUp("html");
            html = new Html(xHtml);

            autoSequence = l_xmlConf.getBoolValue("autoSequence", true);
            borderVirtual = l_xmlConf.getBoolValue("borderVirtual", false);
            borderIdem = l_xmlConf.getBoolValue("borderIdem", false);
            borderGranSlam = l_xmlConf.getBoolValue("borderGranSlam", false);
            borderTb = l_xmlConf.getBoolValue("borderTb", false);
            autoSelect = l_xmlConf.getBoolValue("autoSelect", false);
            checkPub = l_xmlConf.getBoolValue("checkPub", false);
            useMock = l_xmlConf.getBoolValue("useMock ", false);
            logDir = l_xmlConf.getBoolValue("logDir ", false);

            freewheel = l_xmlConf.getBoolValue("freewheel", false); 

            var xExport = l_xmlConf.NodeLookUp("export"); // export = l_xmlConf.getNodeValue("export");
            export = new Tuning.Export(xExport);

            var xImport = l_xmlConf.NodeLookUp("import"); // export = l_xmlConf.getNodeValue("export");
            import = new Tuning.Hibernate(xImport);

            var xSort = l_xmlConf.NodeLookUp("sort");
            sort = new Tuning.Sort.Sort(xSort);


            var xAlbums = l_xmlConf.NodeLookUp("albums");
            albums = new ConfAlbums(xAlbums);

            var xHibernate = l_xmlConf.NodeLookUp("hibernate");
            hibernate = new Hibernate(xHibernate);


            var xDb = l_xmlConf.NodeLookUp("db");
            db = new Db(xDb);


            Logger.CreateNullLoggers = createNullLoggerOrg;
            var xlistes = l_xmlConf.NodeLookUp("listes");
            listes = new Listes(xlistes);

            var xglobal = l_xmlConf.NodeLookUp("global");
            globalListes = new Listes(xglobal);


            var xContext = l_xmlConf.NodeLookUp("context");
            contexte = new Contexte(xContext); 
            started = true;
            return xroot;

        }

        #region limites

        private void buildDirChilds(XmlNode node, DirConf parent)
        {
            AutoBuilder.setClient(parent, node);
            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "auto")
                {
                    AutoBuilder.build(child, parent);
                }
                else
                {
                    if (child.Name == "dir")
                    {
                        string name = (child.Attributes["name"].InnerText);
                        Limits childLimite = parent.Limites.Clone() as Limits;
                        DirConf sub = DirConf.getDir(childLimite, name, parent); // new DirConf(childLimite, name, parent);
                        sub.buildR(xDir, child);

                        //if (child.Attributes["d"] != null)
                        //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);



                        if (child.Attributes["all"] != null)
                        {
                            sub.HistoAll = child.Attributes["all"].Value == "true";
                        }
                        if (child.Attributes["serial"] != null)
                        {
                            sub.Serial = child.Attributes["serial"].Value == "true";
                        }

                        if (child.Attributes["cascading"] != null)
                            sub.Cascading = child.Attributes["cascading"].Value == "true";
                        if (child.Attributes["selectionPre"] != null)
                            sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                        //if (child.Attributes["transmit"] != null)
                        //    sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                        //if (child.Attributes["transmitTotal"] != null)
                        //    sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                        //if (child.Attributes["transmitTotalGuest"] != null)
                        //    sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                        buildLimit(child, childLimite, sub);
                        parent.addChild(sub);
                        if (!started)
                            misc.log(sub.display());
                        buildDirChilds(child, sub);
                        sub.Init();

                    }
                }
            }

        }

        private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
        {
            string strTd = child.InnerText;
            if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
                item.Td = Convert.ToInt32(strTd);

            AutoBuilder.setClient(item, child);

            //foreach (XmlNode sub in child.ChildNodes)
            //{
            //    if (sub.Name == "auto")
            //        AutoBuilder.build(sub, item);
            //}

            item.build(parent, child);

            //var dAtt0 = parent.Attributes["d"];
            //if (dAtt0 != null)
            //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

            //var dAtt = child.Attributes["d"];
            //if (dAtt != null)
            //    item.Duration = Convert.ToSingle(dAtt.InnerText);

            //var cAtt0 = parent.Attributes["c"];
            //if (cAtt0 != null)
            //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

            //var cAtt = child.Attributes["c"];
            //if (cAtt != null)
            //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

            //var fdAtt0 = parent.Attributes["fd"];
            //if (fdAtt0 != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

            //var fdAtt = child.Attributes["fd"];
            //if (fdAtt != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

            //var nbAtt0 = parent.Attributes["nb"];
            //if (nbAtt0 != null)
            //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
            //var nbAtt = child.Attributes["nb"];
            //if (nbAtt != null)
            //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

            //var dateAtt0 = parent.Attributes["date"];
            //if (dateAtt0 != null)
            //    item.DateMin = getDate(dateAtt0.InnerText);
            //var dateAtt = child.Attributes["date"];
            //if (dateAtt != null)
            //    item.DateMin = getDate(dateAtt.InnerText);

            //var dateAtt0Max = parent.Attributes["maxdate"];
            //if (dateAtt0Max != null)
            //    item.DateMax = getDate(dateAtt0Max.InnerText);
            //var dateAttMax = child.Attributes["maxdate"];
            //if (dateAttMax != null)
            //    item.DateMax = getDate(dateAttMax.InnerText);
        }

        //private static bool date00Consumed;
        //public static void date00Consume() { date00Consumed = true; }

        public static DateTime Date0
        {
            get
            {
                return Instance.dateRef.date0; 
            }
        }

      

        public static DateTime getDate(string str)
        {
            if (string.IsNullOrWhiteSpace(str))
                return DateTime.MaxValue;
            double d = -1;
            if (Date0 > DateTime.MinValue)
            {

                if (double.TryParse(str, out d))
                {
                    return Date0.AddDays(d);
                }
            }
            return Convert.ToDateTime(str);
        }

        private void buildLimit(XmlNode node, Limits limits, DirConf dir)
        {

            Limit[] tab = new Limit[Limits.NB];

            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "list")
                {

                    int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                    Limit limit = new Limit(level);
                    var items = new List<LimitItem>();

                    double tdMin = 0;
                    foreach (XmlNode xItem in child.ChildNodes)
                    {
                        //if (xItem.Name == "auto")
                        //{
                        //    AutoBuilder.build(xItem, limit);
                        //}
                        //else 
                        if (xItem.Name == "td")
                        {
                            var item = new LimitItem(limit);
                            item.TdMin = tdMin;
                            buildLimitItem(child, xItem, item);


                            var itemTd = item.Td;
                            if (itemTd < int.MaxValue)
                                tdMin = item.Td;
                            items.Add(item);
                        }
                    }

                    if (items.Count == 0)
                    {
                        var defaultItem = new LimitItem(limit);
                        buildLimitItem(child, child, defaultItem);
                        items.Add(defaultItem);
                    }

                    limit.Items = items;

                    //var dAtt = child.Attributes["d"];
                    //if (dAtt != null)
                    //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                    //var fdAtt = child.Attributes["fd"];
                    //if (fdAtt != null)
                    //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                    //var nbAtt = child.Attributes["nb"];
                    //if (nbAtt != null)
                    //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                    tab[level] = limit;
                }

            }

            Limit current = null;
            bool oneTabAtLeast = false;
            //  LimitItem currentItem = null;

            double currentDuration = int.MaxValue;
            double lcurrentDuration = int.MaxValue;
            double currentContrib = int.MaxValue;
            double currentFeedDuration = int.MaxValue;
            // double lcurrentFeedDuration = int.MaxValue;
            int currentNb = int.MaxValue;
            int lcurrentNb = int.MaxValue;

            double currentTd = int.MaxValue;

            double currentTdMin = int.MaxValue;
            DateTime currentDateMin = DateTime.MinValue;
            DateTime currentDateMax = DateTime.MaxValue;
            bool currentOverwrite = false;

            for (int i = 0; i < Limits.NB; i++)
            {

                //if (tab[i] != null)
                //{

                if (tab[i] != null)
                {
                    current = tab[i];
                    oneTabAtLeast = true;

                }

                if (!oneTabAtLeast)
                    current = limits[i];

                var _limit = limits[i];
                _limit.Level = i;
                limits[i].Parent = limits;

                //foreach (LimitItem currentItem in current.Items)
                //{

                if (_limit.Items.Count != current.Items.Count)
                {
                    _limit.Items.Clear();
                }

                for (int j = 0; current != null && j < current.Items.Count; j++)
                {

                    var currentItem = current.Items[j];
                    // if (currentItem.Duration < int.MaxValue)
                    currentDuration = currentItem.Duration;
                    currentOverwrite = currentItem.OverwriteConf;
                    lcurrentDuration = currentItem.LoadDuration;
                    //if (currentItem.Contribution < int.MaxValue)
                    currentContrib = currentItem.Contribution;
                    // if (currentItem.FeedDuration < int.MaxValue)
                    currentFeedDuration = currentItem.FeedDuration;
                    //  lcurrentFeedDuration = currentItem.LoadFeedDuration;

                    //   if (currentItem.Nb < int.MaxValue)
                    currentNb = currentItem.Nb;
                    lcurrentNb = currentItem.LoadNb;
                    //  if (currentItem.Td < int.MaxValue)
                    currentTd = currentItem.Td;
                    currentTdMin = currentItem.TdMin;

                    currentDateMin = currentItem.DateMin;
                    currentDateMax = currentItem.DateMax;
                    //}
                    //}

                    //if (current != null)
                    //{
                    LimitItem _limitItem = null;
                    if (j >= _limit.Items.Count)
                    {
                        _limitItem = currentItem.Clone() as LimitItem;
                        _limit.Items.Add(_limitItem);
                        _limitItem.Limit = _limit;

                    }
                    else
                    {
                        _limitItem = _limit.Items[j];

                    }
                    //if (currentDuration < int.MaxValue)
                    _limitItem.setDuration(currentDuration, false); // Duration = currentDuration;
                    _limitItem.LoadDuration = lcurrentDuration;
                    //if (currentContrib < int.MaxValue)
                    //    _limitItem.Contribution = currentContrib;
                    // if (currentFeedDuration < int.MaxValue)
                    _limitItem.setFeedDuration(currentFeedDuration, false); // FeedDuration = currentFeedDuration;
                    // _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                    // if (currentNb < int.MaxValue)
                    _limitItem.setNbMax(currentNb, false);
                    _limitItem.LoadNb = lcurrentNb;
                    //   if (currentTd < int.MaxValue)
                    _limitItem.Td = currentTd;
                    _limitItem.TdMin = currentTdMin;
                    _limitItem.DateMin = currentDateMin;
                    _limitItem.setDateMax(currentDateMax, false);
                    _limitItem.Contribution = currentContrib;
                    _limitItem.OverwriteConf = currentOverwrite;



                    if (dir != null)
                    {
                        if (_limitItem.Duration == int.MaxValue)
                            _limitItem.setDuration(dir.Duration, true); // Duration = dir.Duration;
                        if (_limitItem.LoadDuration == int.MaxValue)
                            _limitItem.LoadDuration = dir.LoadDuration;
                        if (_limitItem.Contribution == int.MaxValue)
                            _limitItem.Contribution = dir.Contribution;
                        if (_limitItem.Td == int.MaxValue)
                            _limitItem.Td = dir.Td;
                        if (_limitItem.Nb == int.MaxValue)
                            _limitItem.setNbMax(dir.Nb, true);
                        if (_limitItem.LoadNb == int.MaxValue)
                            _limitItem.LoadNb = dir.LoadNb;
                        if (_limitItem.FeedDuration == int.MaxValue)
                            _limitItem.setFeedDuration(dir.FeedDuration, true);
                        //if (_limitItem.LoadFeedDuration == int.MaxValue)
                        //    _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                        if (_limitItem.DateMin == DateTime.MinValue)
                            _limitItem.DateMin = dir.DateMin;
                        if (_limitItem.DateMax == DateTime.MaxValue)
                            _limitItem.setDateMax(dir.DateMax, true);
                    }

                    _limitItem.setParent(dir);

                }

                //}
                // }

            }

        }
        #endregion
        #endregion

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Hibernate.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Xml;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Configuration de l'hibernation
    /// </summary>
    class Hibernate : TuningBase
    {
        /// <summary>
        /// Interrupteur
        /// </summary>
        public bool enabled;

        public bool merge; 
        /// <summary>
        /// Liste It indiquant les tracks à hiberner
        /// </summary>
        public string list;
        /// <summary>
        /// Répertoire de stockage des tracks hibernés
        /// </summary>
        public string dir;
        /// <summary>
        /// Date min pour hiberner
        /// </summary>
        public DateTime dateMin;
        /// <summary>
        /// DateMax
        /// </summary>
        public DateTime dateMax=DateTime.MaxValue;
        /// <summary>
        /// filtre sur nom de l'album
        /// </summary>
        public string album;
        /// <summary>
        /// derniers items à garder au chaud
        /// </summary>
        public int nblast=-1;
        /// <summary>
        /// Date max pour conserver les derniers items au chaux
        /// </summary>
        public DateTime dateLast;

        /// <summary>
        /// Délai après déselection pour autoriser l'hibernation
        /// </summary>
        public double delay = 8;

        /// <summary>
        /// Délai min après ajout pour autoriser l'hibernation
        /// </summary>
        public double delayAdd = 8;
        /// <summary>
        /// Délai min pour autoriser l'hibernation par parrort à la date de publication
        /// </summary>
        public double delayPub = 8;

        /// <summary>
        /// nombre max d'item conservés alors que pas sélectionnés
        /// </summary>
        public int nbMax;
        /// <summary>
        /// On n'hiberne pas les items à venir déjà chargés.
        /// </summary>
        public double freewheelsDelay = -1;
        public Hibernate()
        {
        }

        public Hibernate(XmlElement node)
            : base(node)
        {

            if (node == null)
                return;
            builds("list", v => list = v);
            builds("dir", v => dir = v);
            if (!string.IsNullOrEmpty(dir) && !dir.EndsWith("\\"))
                dir +="\\"; 
            buildb("enabled", v => enabled = v);
            buildb("merge", v => merge = v);
            buildDate("dateMin", v => dateMin = v);
            buildDate("dateMax", v => dateMax = v);
            builds("album", v => album = v);
            buildi("nblast", v => nblast = v);
            buildi("nbMax", v => nbMax = v);

            buildDate("dateLast", v => dateLast = v);
            buildd("delay", v => delay = v);
            buildd("delayAdd", v => delayAdd = v);
            buildd("delayPub", v => delayPub = v);
            buildd("freewheelsDelay", v => freewheelsDelay = v); 
            //buildd("dLast", v => dLast = v);
            //if (dateLast == DateTime.MinValue && dLast > 0)
            //    dateLast = DateTime.Now.AddDays(-dLast); 
        }


        
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates, IEnumerable<Piece>, IItem
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual bool VirtualByArtist { get { return false; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }
        public static bool Compact;

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
            // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }
        public int RankAlbumZero { get { if (album == null) return 0; return album.RankZero; } }
        public int RankAlbumSt { get { if (album == null) return 0; return album.RankSt; } }
        public int RankAlbumZeroSt { get { if (album == null) return 0; return album.RankZeroSt; } }




        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



       // public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public decimal ClassementValueLight { get { if (album == null) return 0; return album.ClassementValueLight; } }
        public decimal ClassementValueLight0 { get { if (album == null) return 0; return album.ClassementValueLightZero; } }
        public decimal ClassementValueLightSt { get { if (album == null) return 0; return album.ClassementValueLightSt; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Moved = value; } }
        public bool MovedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Moved;
                    default:
                        return false;
                }
            }
        }

        public bool isEmpeached()
        {
            if (album == null) return false;
            return album.Empeached;
        }

        public int EmpeachedNb { get { if (album == null) return 0; return album.EmpeachedNb; } }

        public bool Empeached { get { if (album == null) return false; return album.Empeached && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Empeached = value; } }
        public bool EmpeachedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Empeached;
                    default:
                        return false;
                }
            }
        }
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get { if (album == null) return false; return album.Empeached1 && this == album.Next; } set { if (album != null) album.Empeached1 = value; } }
        public bool AlmostFree { get { if (album == null) return false; return album.AlmostFree && this == album.Next; } }
        public bool AlmostFree1 { get { if (album == null) return false; return album.AlmostFree1 && this == album.Next; } }

        public bool AlbumRecentlyUpdated { get { return StackValue > 0 && SelectedMotif == selectedCoeff.noCoeff; } }
        public bool AlbumRecentlyUpdatedMain
        {
            get
            {
                if (StackValue == 0) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return true;
                    default:
                        return false;
                }
            }
        }


        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch();
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache(true);

        }

        public string ClassementCompact
        {
            get
            {
                if (parent != null)
                    return parent.ClassementCompact;
                if (Compact)
                {
                    if (string.IsNullOrEmpty(_classementCompact))
                        return ClassementCache.strClassement;
                    return _classementCompact;
                }
                else
                    return ClassementCache.strClassement;

            }
        }
        private static ClassementHash classementHash = new ClassementHash();
        private ClassementCache _classementCache;
        private ClassementCache ClassementCache
        {
            get
            {


                if (_classementCache == null)
                {
                    if (parent != null)
                        _classementCache = parent.ClassementCache;
                    if (_classementCache == null)
                    {
                        if (Compact)
                        {
                            if (string.IsNullOrEmpty(_classementCompact))
                                _classementCache = classementHash.getCache(track.ClassName, track.Rating);
                            else
                                _classementCache = classementHash.getCache(_classementCompact);
                        }
                        else
                            _classementCache = classementHash.getCache(track.ClassName, track.Rating);

                    }
                }
                return _classementCache;
            }
        }

        private string _classementCompact;



        /// <summary>
        /// Compacte le classement - returne OK si fait
        /// </summary>
        /// <param name="classement"></param>
        /// <returns></returns>
        public bool setClassementCompact(string classement)
        {
            invalidateCache(true);
            _classementCompact = classement;
            var _compact = classementHash.getCache(_classementCompact);
            var org = classementHash.getCache(track.ClassName, track.Rating);
            if (org.ClassementValueDecimal < _compact.ClassementValueDecimal)
            {
                _classementCompact = null;
                _classementCache = org;
                return false;
            }
            else
            {
                _classementCache = _compact;
                return true;
            }
        }




        public decimal ClassementValueDecimal0
        {
            get
            {
                if (Compact)
                    return classementHash.getCache(track.ClassName, track.Rating).ClassementValueDecimal;
                else
                    return ClassementValueDecimal;

            }
        }
        public virtual void invalidateCache(bool razCompact)
        {

            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
            //  _classementProvisoireRecent = null;

            if (parent != null)
                parent.invalidateCache(razCompact);
            else
            {
                _classementCache = null;
                if (Compact)
                {
                    if (razCompact)
                        _classementCompact = null;
                }
                foreach (Piece p in childs)
                {
                    if (Compact)
                    {
                        if (razCompact)
                            p._classementCompact = null;
                    }
                    p._classementCache = null;
                }
            }


        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        // private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                return ClassementCache.ClassNameAndRating;
            }
        }

        // private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                return ClassementCache.ClassementValueDecimal;
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }

        // private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                return ClassementCache.RapportClassement;
                //if (parent != null)
                //    return parent.RapportClassement;
                //if (_rapportClassement != -1)
                //    return _rapportClassement;

                //decimal resultat = 0;
                //try
                //{
                //    return getRapport(ClassNameAndRating);
                //}
                //catch
                //{
                //}
                //_rapportClassement = resultat;
                //// _classementVirtuel = resultat; 
                //return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        private const int END_EQUIV = 13;
        private const int NB_DEC_EQUIV = 8;
        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            int lastNotNull = 0;
            int firstNotNull = -1;
            int i = 0;
            for (; i < END_EQUIV; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);

                if (a > 0)
                {
                    lastNotNull = i;
                    if (firstNotNull < 0)
                        firstNotNull = i;
                }
                if (i >= _ok + NB_DEC_EQUIV + 2)
                    break;
            }
            var str = sb.ToString();
            sb = new StringBuilder();
            int indexPt = lastNotNull - 1;
            if ((lastNotNull - firstNotNull) > NB_DEC_EQUIV)
                indexPt--;
            //if (str.Length == 5)
            //    indexPt--; 

            for (int j = 0; j <= lastNotNull; j++)
            {

                sb.Append(str[j]);
                if (j == indexPt)
                    sb.Append('.');

            }
            str = sb.ToString(); // str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        //public string Comment
        //{
        //    get
        //    {
        //        //if (string.IsNullOrEmpty(track.Comment))
        //        //    gen.writeComment(this);
        //        return track.Comment;
        //    }
        //    set
        //    {
        //        //if (track.Comment != value)
        //        //{
        //        try
        //        {
        //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //            track.Comment = value;
        //        }
        //        catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
        //        //}
        //    }
        //}

        //public virtual string Grouping
        //{
        //    get
        //    {
        //        if (string.IsNullOrEmpty(track.Grouping))
        //        {
        //            gen.writeGrouping(this);
        //        }
        //        return track.Grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (track.Grouping != value)
        //    //    //{
        //    //        try
        //    //        {
        //    //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //    //            track.Grouping = value;
        //    //        }
        //    //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //    //    //}
        //    //}

        //}





        //public virtual void setGrouping(string value, bool prior)
        //{
        //    try
        //    {
        //        //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //        track.setGrouping(value, prior);
        //    }
        //    catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //}

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation();
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        //public string ArtWork
        //{
        //    get { return track.ArtWork; }
        //    set { track.ArtWork = value; }
        //}

        public DateTime FirstAcces
        {
            get
            {
                var min = DateTime.MaxValue;
                foreach (DateTime dt in Dates)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }
                foreach (DateTime dt in DatesClassementBrut)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }

                return min;
            }
        }

        public DateTime Added
        {
            get
            {
                return track.Added;
            }
        }

        public virtual DateTime AlbumAdded
        {
            get
            {
                return album.AlbumAdded;
            }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {
                var list = DatesClassement;
                if (list.Count == 0)
                    return null;
                var dc = list[0];

                if (dc == DateTime.MinValue)
                    return null;
                if (dc == DateTime.MaxValue)
                    return null;

                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {

                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > Piece.SeuilProvisoire)
                        return true;
                }
                return false;

            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }




        //public void writeCommentGrouping()
        //{
        //    var mode = CConf.ConfGen.WriteComment;
        //    writeComment(mode);
        //    var modeg = CConf.ConfGen.WriteGrouping;
        //    writeGrouping(modeg);

        //}

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        //public void writeComment(writeGrouping mode)
        //{
        //    if (parent != null)
        //        return;
        //    if (mode == Tuning.writeGrouping.none)
        //        return;


        //    if (mode == Tuning.writeGrouping.mix)
        //    {
        //        StringBuilder sbEnd = new StringBuilder();

        //        sbEnd.Append(ClassName);
        //        sbEnd.Append(".");
        //        sbEnd.Append((RatingCmp / 20).ToString());
        //        sbEnd.Append(ClassEvol);
        //        string strEnd = sbEnd.ToString();
        //        string found = "";

        //        string[] tab = Comment.Split(' ');
        //        int count = tab.GetLength(0);
        //        if (count > 0)
        //        {
        //            found = tab[count - 1];
        //            if (found.Equals(strEnd))
        //                return;
        //        }
        //        writeComment(Tuning.writeGrouping.all);
        //    }

        //    StringBuilder sb = new StringBuilder();
        //    //string l_pref = "";
        //    //string l_str = "";

        //    string l_strList = ClassName;
        //    //if (ClassPlayList != null)
        //    //    l_strList = ClassName;

        //    ////if (m_classement.Imported)
        //    ////{
        //    //if (l_strList != ClassName)
        //    //{
        //    //    sb.Append("m (");
        //    //    sb.Append(ClassName);
        //    //    sb.Append(") "); 
        //    //  //  l_pref = "m (" + ClassName + ") ";
        //    //}
        //    ////}
        //    int l_rank = Rank.Twice;

        //    if (l_rank > 0)
        //    {
        //        CTuning.format(sb, l_rank);
        //        sb.Append(" ");
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }


        //        var r = CTuning.Rapport(Rank.Quality);






        //        var quality = CConf.Select.Quality;
        //        //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
        //        //{
        //        double tx0 = Convert.ToInt32(1000 * r);
        //        sb.Append(tx0.ToString());
        //        sb.Append(" ");
        //        //}

        //        //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
        //        var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
        //        //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //getTx(m_rank.Lenght)
        //        //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


        //        sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
        //        //if (l_tx < 100 || l_tx >= 1000)
        //        //    sb.Append(l_tx.ToString("G2", en));
        //        //else
        //        //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



        //        sb.Append(" ");
        //        var rest = r;

        //        for (int i = 0; i < 4; i++)
        //        {
        //            var ee = rest * 6.0m;
        //            int e = (int)System.Math.Floor(ee);
        //            rest = ee - e;
        //            sb.Append(e);
        //        }



        //        sb.Append(" ");


        //        //sb.Append(l_tx2.ToString());
        //        //sb.Append(" ");
        //        //sb.Append((100 * m_rank.SortValue).ToString("0"));
        //        //sb.Append(" ");

        //        //sb.Append(Dates.Count.ToString()); sb.Append(" ");

        //        //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

        //        //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

        //        //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



        //        sb.Append(l_strList);
        //        sb.Append(".");
        //        sb.Append((RatingCmp / 20).ToString());

        //    }

        //    sb.Append(ClassEvol);



        //    Comment = sb.ToString();
        //    //Comment = l_pref + l_str + ClassEvol;
        //}

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 1;
                return RapportClassement / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 1;
                return RapportClassement / _classementVirtuel2;
            }
        }




        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        //private bool haveToUpdateGrouping = false;
        //public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        //public void writeGrouping(writeGrouping writeGrouping)
        //{
        //    var cat = CConf.ConfGen.DisplayCategories;
        //    //if (!CConf.ConfGen.WithOrder)
        //    //    cat = minCategories; 
        //    if (writeGrouping == Tuning.writeGrouping.none)
        //        return;

        //    //if (m_rank.Twice <= 0)
        //    //    return;
        //    if (haveToUpdateGrouping)
        //    {
        //        setGrouping(getGroup(cat), true);
        //    }

        //    else if (writeGrouping == Tuning.writeGrouping.mix)
        //    {
        //        bool haveToUpdate = false;
        //        string org = Grouping;
        //        if (org != null)
        //        {
        //            string[] data = org.Split(' ');

        //            try
        //            {
        //                foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
        //                {
        //                    DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
        //                    //displayCategory found = cat.Find(c => (int)c == (int)mode);
        //                    if (found != null)
        //                    {
        //                        int indexOfTime = cat.IndexOf(found);

        //                        string timeValue = data[indexOfTime];
        //                        string newValue = getTimeValue(mode, found.mode);
        //                        if (!newValue.Equals(timeValue))
        //                        {
        //                            haveToUpdate = true;
        //                            break;
        //                        }
        //                    }
        //                }
        //            }
        //            catch
        //            {
        //                haveToUpdate = true;
        //            }
        //        }
        //        else
        //        {
        //            haveToUpdate = true;
        //        }
        //        if (haveToUpdate)
        //            setGrouping(getGroup(cat), true);
        //    }
        //    else
        //        setGrouping(getGroup(cat), false);
        //}



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    int rank = album.Rank.Sort;
                    rank = 1 + gen.Albums.Count - rank;
                    return rank;
                }
                return 0;
            }
        }

        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            sb.Append(RankAlbumReverse);
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
            //gen.Albums.invalidate(Master); 
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == parent)
                    return;
                var old = parent;
                if (old != null)
                    old.albumMustRefresh();
                parent = value;
                if (parent == null)
                {
                    if (old != null)
                    {
                        old.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = parent.Master;
                    this.PieceParentId = value.MasterId;
                    parent.addChild(this);
                }
                if (album != null)
                    this.album.mustRefresh();
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            childs.Add(child);
        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return track.ExportStatus; // exportState;
            }
            set
            {
                track.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        //public List<string> getIntermediaryPath()
        //{
        //    var list = new List<string>();
        //    foreach (var path in track.RelativesPath)
        //    {

        //        var tab = path.Split('\\');
        //        var sb = new StringBuilder();

        //        sb.Append(@"\");
        //        var count = tab.GetLength(0);
        //        for (int i = 0; i < count; i++)
        //        {
        //            var _s = tab[i];
        //            if (string.IsNullOrEmpty(_s))
        //                continue;

        //            var s = sb.ToString();
        //            if (!string.IsNullOrEmpty(s))
        //            {
        //                if (s.Length >= 2)
        //                {
        //                    list.Add(s);
        //                }
        //            }



        //            if (i > 0)
        //                sb.Append(@"\");
        //            sb.Append(_s);
        //        }
        //    }


        //    return list;


        //}


        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString(), false);

                    if (virt != null)
                        list.Add(virt);

                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in this)
                {
                    var virt = createVirtualAlbum(p.Artist, true);
                    if (virt == null)
                        continue;
                    list.Add(virt);
                }

            }

        }

        private Piece createVirtualAlbum(string path, bool artist)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2)
                return null;
            var virt = new VirtualAlbumPiece(track, Master, path, artist);
            return virt;
        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        public static DateTime SeuilCompact;
        // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true;
                }
                return false;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        public bool ClassementACompacter
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilCompact)
                        return false;
                }
                return true;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        public bool ClassementProvisoire
        {
            get
            {
                if (RapportClassement == 0)
                    return false;
                var str = ClassName;
                int count = str.Length;
                if (count < 4)
                    return true;
                if (count >= 8)
                    return false;

                var tab = str.ToCharArray();
                int nb = 0;
                for (int i = 0; i < count; i++)
                {
                    if (nb > 0)
                        nb++;
                    else
                    {
                        if (tab[i] != '0')
                        {
                            nb++;
                        }
                    }
                }
                if (nb >= NB_CHAR_COMPLETE)
                    return false;

                return true;

            }
        }

        public bool Played { get { return track.Played; } }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }
    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\TrackList.cs">
    <content><![CDATA[
using System;
using System.Collections.Generic;
using pdb.obj;
using System.Diagnostics;

namespace pdb.gen
{
    public class TrackListCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            if (source is Piece)
                return new TrackList(source as Piece);
            else
                throw new ApplicationException(source + " n'est pas du bon type");
        }
    }
    public class TrackList : PlComponent, ITrackMetaData, IFile, ITrackNativeDates
    {

        private Piece piece;
        public TrackList(Piece piece)
        {
            if (piece == null)
                Debugger.Launch();
            this.piece = piece;
        }
        public override string ToString()
        {
            var parent = Parent;
            if (parent == null)
                return piece.ToString();

            return parent.getPath() + " " + piece.ToString();
        }
        public Piece Piece { get { return piece; } }

        public string Name { get { return piece.Name; } set { piece.Name = value; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } set { piece.Enabled = value; } }
        public bool Virtual { get { return piece.Virtual; } }
        public bool Played { get { return piece.Played; } }
        public string ClassName
        {
            get
            {
                return piece.ClassName;
            }
            set
            {
                piece.ClassName = value;
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
            }
        }

        //public string Comment
        //{
        //    get
        //    {
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        piece.Comment = value;
        //    }
        //}

        bool ITrackMetaData.Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
            }
        }

        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set { piece.Duration = value; }

        }

        //public string ArtWork
        //{
        //    get
        //    {
        //        return piece.ArtWork;
        //    }
        //    set
        //    {
        //        piece.ArtWork = value;
        //    }
        //}

        

        //public string Grouping
        //{
        //    get { return piece.Grouping; }
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    piece.setGrouping(value, prior);
        //}



       // public bool FirstClass { get { return piece.FirstClass; } set { piece.FirstClass = value; } }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
            }
        }

        public string Album
        {
            get
            {
                return piece.Album;
            }
            set
            {
                piece.Album = value;
            }
        }

        string ITrackReference.Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
            }
        }

        public int TrackNumber
        {
            get
            {
                return piece.TrackNumber;
            }
            set
            {
                piece.TrackNumber = value;
            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.ClassPlayLists; }
        }

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    piece.AddPlayList(a_playList);
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    piece.removePlayList(list);
        //}

        public int PieceId
        {
            get { return piece.PieceId; }
        }


        public int PieceParentId
        {
            get { return piece.PieceParentId; }
            set { piece.PieceParentId = value; }
        }




        public TrackIdentity Key
        {
            get { return piece.Key; }
        }

        public void setClassement(string className, int rating)
        {
            piece.setClassement(className, rating);
        }

        public List<DateTime> Dates
        {
            get { return piece.Dates; }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return piece.ClassEvol; }
        }

        public List<string> RelativesPath
        {
            get { return piece.RelativesPath; }
        }


        public exportState ExportStatus
        {
            get
            {
                return piece.ExportStatus;
            }
            set
            {
                piece.ExportStatus = value;
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return piece.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation() ;
        }


        public DateTime Added
        {
            get { return piece.Added;  }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CPiece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.type;
using pdb.obj;
using pdb.util;
using pdb.db.piece;
using System.Diagnostics;


namespace pdb.db.obj
{

    /// <summary>
    /// Métadonnées d'un fichier
    /// </summary>
    /// <remarks>On veut pouvoir merger les modifications venant de deux sources
    /// exemeple : un modifie le classement, l'autre l'année
    /// Pour cela, il est envisagé d'enregistrer pour chaque modification effectué par le client
    /// tout simplement la date de cette modification
    /// le merge se baserait ainsi sur la comparaison entre les dates de modification
    /// source 1 date modif d1' pour classement > d1
    /// source 2 date modif d2' pour année > d2
    /// 
    /// On pourrait aussi se baser sur un flag => mettre à jour
    /// ainsi on gagnerait de la place, mais on perdrait la date de derniere mise à jour
    /// et se poserait aussi la question de quand retirer le flaf "mettre à jour"
    /// 
    /// On peut aussi établir un historique
    ///
    ///</remarks>
    /// 

    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }

    public class CPiece : IData, ITrackMetaData, ITrackNativeDates, ITrackPlayListRecorder, ITrackPlayListReport, IDataObserver, ITrackInfoItunes, IItem
    {
        private static Logger logTrack = Logger.getLogger("Track");
        //  private static NullTrack NullTrack = new NullTrack();
        private const string TOKEN_PIECE = "piece";

        private const string TOKEN_DISABLED = "disabled";
      //  private const string TOKEN_ARTWORK = "artWork";
        private const string TOKEN_DURATION = "duration";
        private const string TOKEN_ADDED = "added";

        #region "Composants"
        private CListDate m_dates;
        private CListFile m_files;
        private CPieceReference m_ref;
        private CPieceInfo m_infos;
        private CPieceClassement m_classement;
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private DateTime added;
        private CPieceChecked m_Enabled = new CPieceChecked();


        //private String m_comment = "";
        //private string grouping = ""; 
       // private string artWork = "";
        #endregion

        //private class StringEventArgs : EventArgs
        //{
        //    public StringEventArgs(String value) { this.Value = value; }
        //    readonly public String Value;
        //}


        public DateTime Added { get { return added; } }
        public void setAdded(DateTime dt) { added = dt; }

        private void checkNative()
        {
            //if (native == null)
            //{
            //    StackTrace st = new StackTrace();
            //    logTrack.logNoDate("native null " + this + " " + st.ToString());
            //}
        }
        //   public void makeFirstClass() { if (native == null) return; native.makeFirstClass(); }
        //public bool FirstClass
        //{
        //    get
        //    {
        //        if (native == null) return false;
        //        return native.FirstClass;
        //    }
        //    set { if (native == null) return; native.FirstClass = value; }
        //}
        public bool HasNoNative { get { return native == null; } }
        //private void OnCommentChange(String value)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.Comment = value;
        //}
        //private void OnGroupingChange(String value, bool prior)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.setGrouping(value, prior);
        //}
        private void OnNameChange(string value) { if (native == null) return; native.Name = value; }
        private void OnAlbumChanged(String value) { if (native == null) return; native.Album = value; }
        private void OnArtistChanged(String value) { if (native == null) return; native.Artist = value; }
        private void OnUncheck() { if (native == null) return; native.Enabled = false; }



        //private EventHandler<StringEventArgs> commentChanged;
        //private EventHandler<StringEventArgs> groupingChanged;
        //private EventHandler<StringEventArgs> albumChanged;
        //private EventHandler<StringEventArgs> artistChanged;


        private List<IReference> referenceObs = new List<IReference>();
        public void addReferenceObs(IReference obs) { if (!referenceObs.Contains(obs)) referenceObs.Add(obs); }
        public void removeReferenceObs(IReference obs) { referenceObs.Remove(obs); }
        private void OnReferenceChanged() { for (int i = 0; i < referenceObs.Count; i++) { referenceObs[i].referenceChange(this); } }


        #region logs
        private void valueChangedHandler()
        {

            //m_ref.AlbumData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Album", args); };
            //m_ref.ArtistData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Artist", args); };
            //m_ref.NameData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Name", args); };
            //m_infos.YearData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Year", args); };
            //Classement.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Classement", args); };

            //m_ref.AlbumData.changeLocalValueByNative += (o, args) => { langChangeByNative("Album", args); };
            //m_ref.ArtistData.changeLocalValueByNative += (o, args) => { langChangeByNative("Artist", args); };
            //m_ref.NameData.changeLocalValueByNative += (o, args) => { langChangeByNative("Name", args); };
            //m_infos.YearData.changeLocalValueByNative += (o, args) => { langChangeByNative("Year", args); };
            //Classement.changeLocalValueByNative += (o, args) => { langChangeByNative("Classement", args); };

            //m_ref.AlbumData.change += new EventHandler(Ref_change);
            //m_ref.NameData.change += new EventHandler(Ref_change);
            //m_ref.ArtistData.change += new EventHandler(Ref_change);
            //m_ref.TrackData.change += new EventHandler(Ref_change);
            Files.Observer = this;
            m_ref.Observer = this;
            m_infos.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
        }


        private void logChange(String typeChange, String typeData, object Old, object New)
        {
            logTrack.log("{0}:{1} from '{2}' to '{3}' {4}", typeChange, typeData, Old, New, this);
        }
        //private void logChangeByRemote(String typeData, object Old, object New)
        //{
        //    logChange("change by remote", typeData, Old, New);
        //}
        //private void langChangeByNative(String typeData, object Old, object New)
        //{
        //    logChange("change by native", typeData, Old, New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}

        //private void langChangeByNative(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}

        #endregion


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        public void keyGener()
        {
            try
            {
                key = new TrackIdentity(this);
            }
            catch
            {
                logTrack.log("pb de clé " + this);
                throw;
            }
        }

        #endregion

        #region constructeurs





        /// <summary>
        /// création d'un morceau vide
        /// </summary>
        /// <remarks></remarks>
        public CPiece()
        {

            m_dates = new CListDate();
            m_files = new CListFile();
            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();
            m_classement = new CPieceClassement();
            valueChangedHandler();
        }

        public CPiece(string location, string baseClassement)
            : this()
        {
            m_files.add(new CFile(location));
            m_classement = new CPieceClassement(baseClassement);
            valueChangedHandler();
        }

        public CPiece(string location)
            : this()
        {
            m_files.add(new CFile(location));
            valueChangedHandler();
        }

        public void initClassementIfEmpty(string classement)
        {
            m_classement.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            m_classement.eraseClassement();
        }


        private ITrackInfoItunes native = null;

        public void recordJustReadTrack()
        {
            ListDates.check(DateTime.Now);
        }

        public CPiece(ITrackInfoItunes ext)
        {
            native = ext;
            //  ext.registerDependency(this); 

            m_classPlayLists = ext.ClassPlayLists;
            //m_playList = ext.PLayLists;

            string className = ext.ClassName; // getClassName(ext); 

            m_dates = new CListDate();
            ListDates.check(ext.PlayedDate);

            m_files = new CListFile();
            Files.add(new CFile(ext.Location));
            m_ref = new CPieceReference(ext.Artist, ext.Album, ext.Name, ext.TrackNumber);
#if VOL
            m_infos = new CPieceInfo(ext.Year, ext.Volume);
#else
            m_infos = new CPieceInfo(ext.Year);
#endif
           // this.artWork = ext.ArtWork;

            m_classement = new CPieceClassement(className, ext.Rating);
            //m_comment = ext.Comment;
            //grouping = ext.Grouping; 

            m_duration = ext.Duration;

            bool enabled = ext.Enabled;
            if (enabled)
                Checked.Enable();
            else
                Checked.Disable();

            //m_ref.AlbumData.changeNativeValue += (o, args) =>  { if (native == null) return; native.Album = args.Value; };
            //m_ref.ArtistData.changeNativeValue += (o, args) => { if (native == null) return; native.Artist = args.Value; };
            //m_ref.NameData.changeNativeValue += (o, args) => { if (native == null) return; native.Name = args.Value; };
            //m_ref.TrackData.changeNativeValue += (o, args) => { if (native == null) return; native.TrackNumber = args.Value; };
            //m_infos.YearData.changeNativeValue += (o, args) => { if (native == null) return; native.Year = args.Value; };
            //Classement.changeNativeValue += (o, args) => { if (native == null) return; native.Rating = args.Value.Rating; native.ClassName = args.Value.ClassList; };

            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            //  m_Enabled.checkedChanged += (o, args) => { if (native == null) return; native.Enabled = false; };





            valueChangedHandler();


        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList(ITrackNative track)
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        /// <summary>
        /// construction à partir de la base maison 
        /// </summary>
        /// <param name="a_xml"></param>
        /// <remarks></remarks>
        public CPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);
            m_id = xmlTool.getIntAttValue("id");
            deleted = xmlTool.getBoolAttValue("deleted");
            m_ref = new CPieceReference(a_xml);
            m_infos = new CPieceInfo(a_xml);

            parentID = xmlTool.getIntAttValue("parent");
            if (parentID < 0)
            {
                m_dates = new CListDate(a_xml);
                m_files = new CListFile(a_xml);
                m_classement = new CPieceClassement(a_xml);
                var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);
                {
                    if (xDisabled != null)
                    {
                        if (xDisabled.InnerText == "false")
                            Checked.Enable();
                        else
                            Checked.Disable();
                    }
                }
            }
            else
            {
                m_dates = new CListDate();
                m_files = new CListFile();
                m_classement = new CPieceClassement();

            }





            var xtool = new XMLTool(a_xml);
          //  artWork = xtool.getNodeValue(TOKEN_ARTWORK);
            //Comment = xtool.getNodeValue("classement");
            //_grouping = xtool.getNodeValue("grouping");
            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xtool.getNodeValue(TOKEN_DURATION);




            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }

            string strAdded = "";
            var attAdded = a_xml.Attributes[TOKEN_ADDED];
            if (attAdded != null)
                strAdded = attAdded.Value;
            else
                strAdded = xtool.getNodeValue(TOKEN_ADDED);

            if (!string.IsNullOrEmpty(strAdded))
            {
                try
                {
                    added = Convert.ToDateTime(strAdded);
                }
                catch (Exception ex)
                {
                    log(string.Format("impossible de parser {0} {1} {2}", strAdded, this, ex));
                }
            }


            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            valueChangedHandler();

        }


        ///// <summary>
        ///// construction à partir de la base propriétaire
        ///// </summary>
        ///// <param name="a_ref"></param>
        ///// <param name="a_file"></param>
        ///// <param name="a_info"></param>
        ///// <param name="a_rating"></param>
        ///// <param name="a_date"></param>
        ///// <remarks></remarks>
        //public CPiece(CPieceReference a_ref, string a_file, CPieceInfo a_info, int a_rating, System.DateTime a_date, TimeSpan a_duration, bool a_bEnabled)
        //{

        //    m_dates = new CListDate();
        //    ListDates.check(a_date);

        //    m_files = new CListFile();
        //    Files.@add(new CFile(a_file));

        //    m_ref = a_ref;
        //    m_infos = a_info;

        //    m_classement = new CPieceClassement(a_rating);
        //    m_duration = a_duration;
        //    if (a_bEnabled)
        //    {
        //        m_Enabled.True();
        //    }
        //    else
        //    {
        //        m_Enabled.False();
        //    }
        //    valueChangedHandler();

        //}

        #endregion


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackMetaData other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.Location) || m_ref.DefinedEquals(other.Artist, other.Album, other.Name, other.TrackNumber));
        //}


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(CPiece other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.m_files) || m_ref.DefinedEquals(other.m_ref));
        //}

        public bool checkFile(CPiece other)
        {
            return Files.HasOnePathInCommonWith(other.Files);
        }



        private void raiseChangeRefEvent()
        {
            if (isRefchanged)
            {
                isRefchanged = false;
                OnReferenceChanged();
            }
        }

        /// <summary>
        /// rapatrie les info d'une piece vers l'autre
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>cas d'égalité enre les deux : doublons de la même liste</remarks>

        public void merge(CPiece other)
        {

            if (!m_ref.AlbumData.choose(other.m_ref.AlbumData))
            {
                log("merge album between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.AlbumData.mergeManual(other.m_ref.AlbumData);
            }

            if (!m_ref.ArtistData.choose(other.m_ref.ArtistData))
            {
                log("merge artist between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.ArtistData.mergeManual(other.m_ref.ArtistData);
            }
            if (!m_ref.NameData.choose(other.m_ref.NameData))
            {
                log("merge name between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.NameData.mergeManual(other.m_ref.NameData);
            }
            if (!m_ref.TrackData.choose(other.m_ref.TrackData))
            {
                log("merge trackNumber between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.TrackData.mergeManual(other.m_ref.TrackData);
            }




            if (!m_infos.YearData.choose(other.m_infos.YearData))
            {
                log("merge infos between " + this.ToString() + "[" + this.Year + "]" + " and " + other.ToString() + "[" + other.Year + "]");
                m_infos.YearData.mergeManual(other.m_infos.YearData);
            }

            if (!Classement.choose(other.Classement))
            {
                log("merge classement between " + this.ToString() + "[" + this.ClassList + ":" + this.Rating + "]" + " and " + other.ToString() + "[" + other.ClassList + ":" + other.Rating + "]");
                Classement.mergeManual(other.Classement);
            }

            addData(other);
            raiseChangeRefEvent();
        }


        /// <summary>
        /// Simple ajout de données venant du doublon
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>Utilisé par legacy pour génération d'une liste propre à partir de la liste native
        /// Les fichiers auront préalablement été triés par classement</remarks>
        public void mergeDataFrom(CPiece other)
        {
            try
            {
                m_ref.mergeDataFrom(other.m_ref);
                m_infos.YearData.mergeAll(other.m_infos.YearData, mergePriority.none);
                Classement.mergeAll(other.Classement, mergePriority.none);

                addData(other);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + @"\r\n" + other.ToString() + @"\r\n" + e.ToString());
            }
        }


        // <summary>
        // addition sans collision des dates et fichiers
        // </summary>

        // <remarks></remarks>

        private void addData(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);
        }


        public void addDataLink(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);


            Classement.mergeOnlyVersion(other.Classement);
            other.Classement.mergeOnlyVersion(Classement);
        }




        public void consolid(CPiece remote, mergePriority a_priority)
        {

            try
            {
                m_ref.consolid(remote.m_ref, a_priority);
                Classement.Consolid(remote.Classement, a_priority);
                m_infos.consolid(remote.m_infos, a_priority);

                if (remote.added > DateTime.MinValue && remote.added < DateTime.MaxValue && remote.added != added)
                    added = remote.added; 

                Checked.Consolid(remote.Checked, a_priority);

                if (m_duration.TotalMilliseconds < 2)
                    this.m_duration = remote.m_duration;
                else if (remote.m_duration.TotalMilliseconds < 2)
                    remote.m_duration = this.m_duration;
                else if (a_priority == mergePriority.right)
                    m_duration = remote.m_duration;

                addData(remote);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }


        public mergePriority checklegacyModifString(CPieceData<String> data, String native)
        {

            mergePriority l_consistencyComp = data.Value.compareByConsistency(native);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (data.Imported) return mergePriority.right;
            return mergePriority.left;
        }


        /// <summary>
        /// piece de la liste native consolidée ou mise à jour 
        /// suivant le cas par le fichier maison
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        public void legacyConsolid(CPiece l_native)
        {



            //TODO éviter de créer un objet juste pour la comparaison
            //en fait très complexe de casser le modèle. A la place, on abonne le track natif aux modifications éventuelles de la DB



            //this.grouping = l_native.Grouping;
            //this.m_comment = l_native.Comment; 







            l_native.m_ref.legacyConsolid(this.m_ref);
            l_native.m_infos.legacyConsolid(this.m_infos);

            l_native.setClassPlayList(this);
            l_native.Classement.LegacyConsolid(this.Classement);
            l_native.Checked.LegacyConsolid(this.Checked);

            //   native.synchroLegacy(this);  //plus besoin de synchro dans l'autre sens, on n'utilise pas l'objet créé ==> en fait si : on modifie directement le track

            addData(l_native);

            this.m_playList = l_native.PLayLists;
            this.m_classPlayLists = l_native.ClassPlayLists;
            this.m_duration = l_native.Duration;
            raiseChangeRefEvent();

            //On court-circuite la liste intermédiaire pour toujours pointer directement vers le trackInfoItunes
            this.native = l_native.native;

            checkNative();
        }

        /// <summary>
        /// Synchro directe entre la Db et le track Itunes (mode daemon)
        /// </summary>
        public void SynchroNative()
        {
            checkNative();
            if (native == null)
                return;

            m_ref.SynchroNative(native);
#if VOL
            m_infos.SynchroNative(native.Year, native.Volume);
#else
            m_infos.SynchroNative(native.Year);
#endif
            var newClassList = getClassName(native);
            Classement newCl = new Classement(newClassList, native.Rating);
            Classement.SynchroNative(newCl);
            Checked.SynchroNative(native.Enabled);

            this.ListDates.merge(native.PlayedDate);



            //  this.m_playList = native.PLayLists;
            this.m_classPlayLists = native.ClassPlayLists;
            if (native.Duration.TotalMilliseconds > 1)
                this.m_duration = native.Duration;
            raiseChangeRefEvent();
        }

        public void removeVersions()
        {
            m_ref.removeVersions();
            Classement.removeVersions();
        }



        public void Menage()
        {
            //  misc.log("ménage {0}", this); 
            Classement.Menage(this);
        }




        //public void synchroLegacy(CPiece native)
        //{
        //    this.m_classPlayLists = native.m_classPlayLists;

        //    this.ID = native.ID;
        //}

        private List<CPlayList> m_classPlayLists = new List<CPlayList>();
        private List<CPlayList> m_playList = new List<CPlayList>();
        public void AddPlayList(CPlayList a_playList)
        {
            if (a_playList.isClassSubList())
            {
                m_classPlayLists.Add(a_playList);
            }
            m_playList.Add(a_playList);
        }
        public void removePlayList(CPlayList list)
        {
            if (list.isClassSubList())
                m_classPlayLists.Remove(list);
            m_playList.Remove(list);
        }

        public bool belongsTo(string a_list)
        {
            foreach (CPlayList l_pl in m_playList)
            {
                if (l_pl.isSubList(a_list))
                    return true;
            }
            return false;
        }

        ////définit la liste qui le classe
        //public void setClassPlayList()
        //{
        //    int count =  m_classPlayLists.Count; 
        //    if (count > 0)
        //    {
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //        }
        //        Classement.ClassList = m_classPlayLists[0].Name;
        //    }
        //}


        private void setClassPlayList(ITrackNative pieceDb)
        {
            string dbClasslist = pieceDb.ClassName;
            int count = m_classPlayLists.Count;
            if (count > 0)
            {
                string className = m_classPlayLists[0].Name;
                if (count > 1)
                {
                    m_classPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in m_classPlayLists)
                    {
                        className = list.Name;
                        if (className == dbClasslist)
                            continue;
                        break;
                    }
                }

                if (!className.Equals(Classement.Value.ClassList) && className.Equals(Classement.LastValue.ClassList))
                {
                    misc.log("Classement:setClassPlayList {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                    return;
                }

                Classement.ClassList = className;

            }
        }

        public string getClassName(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            var firstStep = getClassName_(native);
            if (!firstStep.Equals(Classement.Value.ClassList) && firstStep.Equals(Classement.LastValue.ClassList))
            {
                misc.log("Classement:getClassName {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                return dbClasslist;
            }
            else
                return firstStep;
        }

        public string getClassName_(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            string className = dbClasslist;
            int count = native.ClassPlayLists.Count;
            if (count > 0)
            {
                className = native.ClassPlayLists[0].Name;
                if (count > 1)
                {
                    native.ClassPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in native.ClassPlayLists)
                    {
                        className = list.Name;
                        if (className.Equals(dbClasslist))
                            continue;
                        break;
                    }
                }
            }
            return className;
        }

        //utilisé par le player maison
        public void setClassPlayList(String name)
        {
            Classement.ClassList = name;
            // TODO Gérer l'absence de classList
        }

        private CPlayList ClassPlayList
        {
            get
            {
                if (m_classPlayLists.Count > 0)
                    return m_classPlayLists[0];
                return null;
            }
        }

        public List<CPlayList> PLayLists { get { return m_playList; } }

        public String ClassName { get { return Classement.ClassList; } set { } }

        public List<CPlayList> ClassPlayLists
        {
            get
            {
                return m_classPlayLists;
            }
        }



        /// <summary>
        /// 
        /// </summary>
        /// <param name="a_sw"></param>
        /// <remarks></remarks>
        /// 
        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, TOKEN_PIECE);

            m_ref.write(a_sw);
            m_infos.write(a_sw);

            Classement.write(a_sw);

            Files.write(a_sw);
            ListDates.write(a_sw);

            if (!Checked.Enabled)
                XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());
            //if (artWork.NotNullOrEmpty())
            //    XMLTool.writeValue(a_sw, TOKEN_ARTWORK, artWork);
            if (m_duration.TotalMilliseconds > 1)
                XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);
            if (added > DateTime.MinValue)
                XMLTool.writeValue(a_sw, TOKEN_ADDED, added.ToString());

            XMLTool.closeBalise(a_sw, TOKEN_PIECE);
        }




        public void write(XmlWriter w)
        {
            try
            {
                w.WriteStartElement(TOKEN_PIECE);
                if (PieceId > 0)
                    w.WriteAttributeString("id", PieceId.ToString());
                if (parent != null)
                    w.WriteAttributeString("parent", parent.PieceId.ToString());
                if (added > DateTime.MinValue)
                    w.WriteAttributeString(TOKEN_ADDED, added.ToString());
                if (parent == null)
                {
                    if (m_duration.TotalMilliseconds > 1)
                        w.WriteAttributeString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
                }

                m_ref.write(w);
                m_infos.write(w);

                if (parent == null)
                {
                    Classement.write(w);
                    Files.write(w);
                    ListDates.write(w);

                    if (!Checked.Enabled)
                        w.WriteElementString(TOKEN_DISABLED, "");
                }



                //if (artWork.NotNullOrEmpty())
                //    w.WriteElementString(TOKEN_ARTWORK, artWork);



                w.WriteEndElement();
            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0} {1}", this, ex);
                throw;
            }
        }


        public void writeDeleted(XmlWriter w)
        {
            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            w.WriteAttributeString("deleted", "true");
            w.WriteEndElement();

        }

        public void writeDiff(XmlWriter w, CPiece lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }

            if (!HasChange(lastFull))
                return;

            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            if (parent != null)
                w.WriteAttributeString("parent", parent.PieceId.ToString());
            if (added != lastFull.added)
                w.WriteAttributeString("added", added.ToString()); 

            m_ref.writeDiff(w, lastFull.m_ref);
            m_infos.writeDiff(w, lastFull.m_infos);

            if (parent == null)
            {
                Classement.writeDiff(w, lastFull.Classement);
                Files.writeDiff(w, lastFull.Files);
                ListDates.writeDiff(w, lastFull.ListDates);

                if (!Checked.Enabled && lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "");

                if (Checked.Enabled && !lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "false");

                if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                    w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
            }






            w.WriteEndElement();
        }

        public bool HasChange(CPiece lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }
            if (PieceParentId != lastFull.PieceParentId)
                return true;

            if (m_ref.HasChanged(lastFull.m_ref))
                return true;
            if (m_infos.HasChange(lastFull.m_infos))
                return true;

            if (parent == null)
            {
                if (Classement.HasChange(lastFull.Classement))
                    return true;
                if (Files.HasChange(lastFull.Files))
                    return true;
                if (ListDates.HasChange(lastFull.ListDates))
                    return true;
            }

            if (Checked.Enabled != lastFull.Checked.Enabled)
                return true;

            if (added != lastFull.Added)
                return true; 

            //if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
            //    return true;

            return false;
        }

        #endregion

        public void setClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);
            if (cl.Equals(Classement.Value))
                return;
            Classement.Value = cl;

        }




        public CListFile Files
        {
            get { if (parent == null) return m_files; return parent.m_files; }
        }


        public IList<DateTime> Dates
        {
            get { return ListDates.Dates; }
        }

        public DateTime PlayedDate
        {
            get { return ListDates.LastModif; }
        }

        public string ClassList
        {
            get { return Classement.ClassList; }
        }

        public int Rating
        {
            get { return Classement.Rating; }
            set { Classement.Rating = value; }
        }

        public int RatingCmp
        {
            get
            {
                if (Rating < 0)
                    return 0;
                return Rating;
            }
        }
        public CPieceReference Reference
        {
            get { return m_ref; }
        }
        public string Name
        {
            get { return m_ref.Name; }
            set { m_ref.Name = value; }
        }
        public string Album
        {
            get { return m_ref.Album; }
            set
            {
                if (!m_ref.Album.Equals(value))
                {
                    m_ref.Album = value;
                    OnAlbumChanged(value);
                }
            }
        }
        public string Artist
        {
            get { return m_ref.Artist; }
            set
            {
                if (!m_ref.Artist.Equals(value))
                {
                    m_ref.Artist = value;
                    OnArtistChanged(value);
                }
            }
        }
        public int TrackNumber { get { return m_ref.TrackNumber; } set { m_ref.TrackNumber = value; } }
        public int DurationInSec
        {
            get { return Convert.ToInt32(Duration.TotalSeconds); }
        }
        //public TimeSpan Duration
        //{
        //    get { return m_duration; }
        //    set
        //    {
        //        if (value.TotalMilliseconds > 1)
        //            m_duration = value;
        //    }
        //}
        public int Year
        {
            get { return m_infos.Year; }
            set { m_infos.Year = value; }
        }
#if VOL
        public int Volume { get { return m_infos.Volume; } set { m_infos.Volume = value; } }
#endif
        public bool Enabled
        {
            get { return Checked.Enabled; }
            set
            {
                if (value)
                    Checked.Enable();
                else
                    Checked.Disable();
            }
        }
        public CPieceInfo Infos
        {
            get { return m_infos; }
        }

       // public string ArtWork { get { return artWork; } set { artWork = value; } }


        /// <summary>
        /// ID interne
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
        private int parentID = -1;
        public int PieceId
        {
            get { return m_id; }
        }

        public int PieceParentId
        {
            get { return parentID; }
            set { parentID = value; }
        }

        public int MasterId
        {
            get
            {
                if (parentID < 0)
                    return m_id;
                return parentID;
            }
        }

        public CPiece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }


        public void setId(int value)
        {
            if (m_id == value)
                return; 
            if (value > 0)
            {
                key = null; 
                if (m_id > 0)
                    misc.log("id from {0} to {1} {2}", m_id, value, this);
                m_id = value;
            }
        }

        public CPieceClassement Classement { get { if (parent == null) return m_classement; return parent.m_classement; } }
        public TimeSpan Duration
        {
            get { if (parent == null) return m_duration; return parent.m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    if (parent == null)
                        m_duration = value;
                    else
                        parent.m_duration = value;
                }
            }
        }
        public CListDate ListDates { get { if (parent == null) return m_dates; return parent.m_dates; } }
        private CPieceChecked Checked { get { if (parent == null) return m_Enabled; return parent.m_Enabled; } }
        //  private CListFile Files { get { if (parent == null) return m_files; return parent.m_files; } }
        public Classement getClassement() { return Classement.Value; }





        //Sub synchroClassFrom(ByVal a_list As CListPiece)
        //    Dim l_piece As CPiece = a_list.getPiece(Me)
        //    m_classement = l_piece.m_classement
        //End Sub

        public override string ToString()
        {
            var parent = " ";
            if (PieceParentId >= 0)
                parent = string.Format(" ({0}) ", PieceParentId);
            return string.Format("{0} {1}{2}{3} {4} {5}", Classement.Value, PieceId, parent, Name, Album, getLocation());
            //String location = Location;
            //return location == "" ? Files.File : location;
        }
        //public string File
        //{
        //    get { return Files.File; }
        //}
        public string PathAndRef
        {
            get { return getLocation() + " " + m_ref.ToString(); }
        }
        //private string _location;
        public string Location
        {

            get
            {
                return Files.Path;
                //if (_location == null)
                //_location =  Files.Path;
                //return _location; 


            }
        }
        public string getLocation()
        {
            return Files.getLocation();
        }

        public bool Exists { get { return Files.Exists; } }

        //public bool classListToUpdate()
        //{
        //    string l_strList = "";
        //    if (ClassPlayList != null)
        //        l_strList = ClassPlayList.Name;

        //    //if (Classement.Imported)
        //    //{
        //    if (l_strList != ClassList)
        //    {
        //        return true;
        //    }
        //    //}
        //    return false;
        //}

        //private string _comment;
        //public string Comment
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return "";
        //        if (_comment == null)
        //        {
        //            if (native != null)
        //                _comment = native.Comment;
        //        }
        //        return _comment;

        //        //string l_pref = "";
        //        //string l_str = "";

        //        //string l_strList = "";
        //        //if (ClassPlayList != null)
        //        //    l_strList = ClassPlayList.Name;

        //        //if (Classement.Imported)
        //        //{
        //        //    if (l_strList != ClassList)
        //        //    {
        //        //        l_pref = "m (" + ClassList + ") ";
        //        //    }
        //        //}
        //        //int l_rank = m_rank.Twice;
        //        //if (l_rank > 0)
        //        //{
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }

        //        //    double l_tx = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Goodness, CConf.Sort.Quality));
        //        //    double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //    //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //    //getTx(m_rank.Lenght)
        //        //    l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();
        //        //}

        //        //return l_pref + l_str + getClassementEvol();

        //    }
        //    set
        //    {
        //        if (parent != null)
        //            return;
        //        if (value != _comment)
        //        {
        //            _comment = value;
        //            //if (value != Comment)
        //            //{
        //            // m_comment = value;
        //            OnCommentChange(value);
        //        }
        //        // }
        //    }
        //}
        //private string _grouping;
        //public string Grouping
        //{
        //    get
        //    {
        //        if (_grouping == null)
        //        {
        //            if (native != null)

        //                _grouping = native.Grouping;
        //        }
        //        return _grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (value != Grouping)
        //    //    //{
        //    //    //  grouping = value;
        //    //    OnGroupingChange(value);
        //    //    //}
        //    //}
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    if (value != _grouping)
        //    {
        //        _grouping = value;
        //        OnGroupingChange(value, prior);
        //    }
        //}

        //private static double getTx(int rank)
        //{
        //    if (rank <= 0)
        //        return 0;
        //    return (Math.Log(Convert.ToDouble(CTuning.Total) / Convert.ToDouble(rank)) / Math.Log(2));
        //}

        //public int QRank
        //{
        //    get { return m_rank.Goodness; }
        //    set { m_rank.Goodness = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}




        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return Classement.isClassListNumeric;
            }
        }

        //  public String ClassNameAndRating { get { return Classement.ClassNameAndRating; } }



        #region "calcul liste dynamiques"
        // Private m_bCanPlay As Boolean = True
        public delegate bool canPlayDel(int a_base);
        //public bool canPlay(int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    if (a_base <= 0)
        //        return true;
        //    DateTime now = DateTime.Now;
        //    bool l_bRet = ListDates.canPlay(now, Delta, a_base);
        //    if (!l_bRet)
        //    {
        //        Console.WriteLine(" " + Comment + " " + Location);
        //    }

        //    return l_bRet;
        //}

        // private CListDate m_datesModifClassement = null;
        private CListDate DatesClassement_
        {
            get
            {
                //if (m_datesModifClassement == null)
                //    m_datesModifClassement = Classement.Dates;
                return Classement.Dates;
            }
        }

        //public bool mustPlayToPreciseClassement(DateTime now, int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    bool bRet = !DatesClassement.canPlay(now, Delta, a_base);
        //    bool bLastModif = DatesClassement.LastModif > DatesPlayed.LastModif;


        //    if (CConf.CheckModifStrict)
        //        // on ne retient que s'i n'a pas été lu depuis la dernière modif.
        //        // encore en cours : j'écoute puis je modifie
        //        bRet = bRet && bLastModif;

        //    if (a_base == 0)
        //        return bLastModif;
        //    return bRet;
        //}

        public String getClassementEvol()
        {
            DateTime playedCorr = ListDates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= m_duration;
            }
            catch (Exception)
            {
                logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, m_duration);
            }
            if (DatesClassement_.LastModif > playedCorr)
            {
                return Classement.Evol;
            }
            return "";

        }

        public static double LogBase = 2.0;
        public static double Scale = 0.1;
        //private TimeSpan Delta
        //{

        //    get
        //    {
        //        if (m_rank.Goodness < 0)
        //            return TimeSpan.MaxValue;
        //        long l_ticks = Convert.ToInt64(new TimeSpan(1, 0, 0, 0).Ticks * Scale);

        //        double r = CPieceInListComparer.Calc(this, CConf.Select);
        //        //     Rapport(m_rank.Goodness, CConf.Sort.Quality)
        //        if (r == -1)
        //            return TimeSpan.MaxValue;

        //        long l_nt = long.MaxValue;
        //        try
        //        {
        //            l_nt = Convert.ToInt64(l_ticks / r);
        //        }
        //        catch (Exception ex)
        //        {
        //        }

        //        return new TimeSpan(l_nt);
        //    }
        //}



        //Sub reinitCanPlay()
        //    m_bCanPlay = True
        //End Sub

        #endregion

        #region "COM"

        //public void checkComRating(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        if (Rating < 0)
        //            return;
        //        //if (!Classement.Imported)
        //        //    return;

        //        int l_trackRating = a_track.Rating;
        //        if (l_trackRating != Rating)
        //        {
        //            log("change rating from " + l_trackRating + " to " + Rating + " " + Location);
        //            a_track.Rating = Rating;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Rating {0} for {1}", Rating, this);
        //    }

        //}


        //public void checkComInfo(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        //if (!m_infos.YearData.Imported)
        //        //    return;
        //        if (Year <= 0) return;
        //        if (a_track.Year != Year)
        //        {
        //            log("change year from " + a_track.Year + " to " + Year + " " + Location);
        //            a_track.Year = Year;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Year {0} for {1}", Year, this);
        //    }

        //}

        //public void checkComRef(ITrackMetaData a_track)
        //{

        //    if (m_ref == null)
        //        return;


        //    string l_trackArtist = a_track.Artist.TrimSafe();
        //    string l_trackAlbum = a_track.Album.TrimSafe();
        //    string l_trackName = a_track.Name.TrimSafe();
        //    int l_trackNumber = a_track.TrackNumber;

        //    if (l_trackArtist != m_ref.Artist)// && m_ref.ArtistData.Imported)
        //    {
        //        log("change Artist from " + l_trackArtist + " to " + m_ref.Artist + " " + Location);
        //        try { a_track.Artist = m_ref.Artist.TrimSafe(); }
        //        catch { misc.log("unable to change Artist {0} for {1}", Artist, this); }
        //    }
        //    if (l_trackAlbum != m_ref.Album) // && m_ref.AlbumData.Imported)
        //    {
        //        log("change Album from " + l_trackAlbum + " to " + m_ref.Album + " " + Location);
        //        try { a_track.Album = m_ref.Album; }
        //        catch { misc.log("unable to change Album {0} for {1}", Album, this); }
        //    }
        //    if (l_trackName != m_ref.Name) // && m_ref.NameData.Imported)
        //    {
        //        log("change Name from " + l_trackName + " to " + m_ref.Name + " " + Location);
        //        try
        //        {
        //            a_track.Name = m_ref.Name.TrimSafe();
        //        }
        //        catch { misc.log("unable to change Name {0} for {1}", Name, this); }
        //    }
        //    if (l_trackNumber != m_ref.TrackNumber && TrackNumber >= 0)//&& m_ref.TrackData.Imported)
        //    {
        //        log("change Track from " + l_trackNumber + " to " + m_ref.TrackNumber + " " + Location);
        //        try { a_track.TrackNumber = TrackNumber; }
        //        catch { misc.log("unable to change TrackNumber {0} for {1}", TrackNumber, this); }
        //    }


        //}


        //public void checkComComment(ITrackMetaData a_track)
        //{
        //    try
        //    {

        //        string l_pieceComment = Comment.Trim();
        //        String l_trackComment = a_track.Comment;
        //        if (l_trackComment == null) l_trackComment = "";
        //        l_trackComment = l_trackComment.Trim();
        //        if (l_trackComment != l_pieceComment)
        //        {
        //            misc.logNoDate("write comment from " + a_track.Comment + " to " + l_pieceComment + " " + Location);
        //            // If l_pieceComment.Trim = "" Then Throw New ApplicationException(Me.ToString() & " set comment to null")
        //            a_track.Comment = l_pieceComment;
        //        }

        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Comments {0} for {1}", Comment, this);
        //    }
        //}

        //public void checkComEnabled(ITrackMetaData a_track)
        //{
        //    if (m_Enabled.isFalse && a_track.Enabled)
        //    {
        //        misc.log("disable {0}", this);
        //        a_track.Enabled = false;
        //    }
        //}

        //public void checkComDate(ITrackInfo a_track)
        //{
        //    //Dim l_date As String = a_track.EQ

        //}
        #endregion


        public bool isPodcast
        {
            get { return Files.isPodcast; }
        }
        private void log(String txt)
        {
            logTrack.log(txt);
        }



        List<DateTime> ITrackPlayedDates.Dates
        {
            get { return new List<DateTime>(ListDates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return new List<DateTime>(DatesClassement_.Dates); }
        }

        public DateTime LastModifClass { get { return m_classement.LastModif; } }

        public string ClassEvol
        {
            get { return getClassementEvol(); }
        }





        public void changeNativeValueAlbum(string value)
        {
            if (native == null)
                return;
            native.Album = value;
        }

        public void changeNativeValueArtist(string value)
        {
            if (native == null) return; native.Artist = value;
        }

        public void changeNativeValueName(string value)
        {
            if (native == null) return; native.Name = value;
        }

        public void changeNativeValueTrack(int value)
        {
            if (native == null) return; native.TrackNumber = value;
        }

        public void changeNativeValueYear(int value)
        {
            if (native == null) return; native.Year = value;
        }

        public void changeNativeValueClassement(Classement value)
        {
            if (native == null)
                return;
            native.Rating = value.Rating; native.ClassName = value.ClassList;
        }
#if VOL
        public void changeNativeValueVolume(int value)
        {
            if (native == null) return;
            native.Volume = value;
        }
#endif

        public void changeByRemote(string type, object Old, object New)
        {
            logChange("change by remote", type, Old, New);
        }

        public void changeByNative(string type, object Old, object New)
        {
            logChange("change by native", type, Old, New);
        }

        private bool isRefchanged;
        public void RefChange()
        {
            isRefchanged = true;
        }

        public void unCheck()
        {
            if (native == null) return; native.Enabled = false;
        }

        public void changeLocalValueByRemoteAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void change()
        {
            throw new NotImplementedException();
        }

        public void setClassement(string className, int rating)
        {
            Classement.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return Classement.ToString();
            }
            set
            {
                setClassement(value);
            }
        }

        public long Size
        {
            get
            {
                var ret = Files.Size;
                if (ret <= 0)
                    return 0;
                return ret;
            }
        }


        private CPiece parent;

        public void setParent(CPiece parent)
        {
            this.parent = parent;
        }
        public CPiece Parent
        {
            get { return parent; }
            set
            {
                var _oldParent = parent;

                if (value == null)
                {

                    PieceParentId = -1;
                    if (_oldParent != null)
                    {
                        addDataLink(_oldParent);
                    }
                    parent = null;
                    return;
                }
                else
                {
                    value.Master.addDataLink(this);
                    parent = value.Master;
                    PieceParentId = parent.PieceId;
                }



            }
        }

        private bool deleted;
        public bool Deleted
        {
            get { return deleted; }
            set
            {
                if (value != deleted)
                {
                    if (value)
                        misc.log("Suppression de {0}", this);
                    deleted = value;
                }
            }
        }

        private List<string> _RelativesPath;
        public List<string> RelativesPath
        {
            get
            {
                if (_RelativesPath == null)
                {
                    _RelativesPath = new List<string>();
                    foreach (CFile f in m_files)
                    {
                        _RelativesPath.Add(f.File);
                    }
                }
                return _RelativesPath;
            }
        }


        private exportState _exportState;
        public exportState ExportStatus
        {
            get
            {
                return _exportState;
            }
            set
            {
                _exportState = value;
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return Classement.getDates();
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }


        public bool Played
        {
            get { return Dates.Count > 0; }
        }
    }
}






]]></content>
  </file>
  <file path="\pieceDb.iT\Loader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.obj;
using pdb.util;
using System.Diagnostics;
using pdb.it.detect;
using System.Collections;
using pdb.it.auto;
using pdb.it.persistance;
using pdb.ordo;
using System.Threading.Tasks;
using pdb.iit;

namespace pdb.it
{

    public class Loader : ITrackBuilder, IAbortTask
    {
        private Action abortList;
        protected Logger log = Logger.getLogger("Loader");
        private iTunesApp app;
        private IITSource mainLibrairy;
        private IITPlaylistCollection mainPlayLists;
        //  private IITUserPlaylist BIB;
        private PlayList root = PlayList.create("root", null);
        private List<PlayList> logicals = new List<PlayList>();
        private bool listLoaded;
        //private CPlayList rootComposite = new PlayListComposite("root");
        private String m_defaultFolder = @"D:\zique\";
        private String _dBLegacyPath = "";
        private String _dBLegacyDir = "";
        private XmlElement contentXml;

        private ITrackBuilder trackBuilder;
        private List<ITrackInfoItunes> list;
        public ITrackBuilder TrackBuilder { set { trackBuilder = value; } }
        private IPlayListFilter filterPlaylist = new PlayListDefaultFilter();
        public IPlayListFilter PlayListFilter { set { filterPlaylist = value; } }
        public int VolumeMin = -125;

        public bool Slave { get { return conf.slave; } }

        private bool checkSong;

        private bool writeOnlyEnabled;
        private bool writeOnlyUnRead;


        private BgDict<int, TrackInfoItunes> m_htPieces = new BgDict<int, TrackInfoItunes>();
        private BgDictString<TrackInfoItunes> m_htLoc = new BgDictString<TrackInfoItunes>();
        private BgDict<int, IITFileOrCDTrack> m_htTracks = new BgDict<int, IITFileOrCDTrack>();

        public void getNatives(ArrayList list)
        {
            foreach (IITFileOrCDTrack t in m_htTracks.Values)
                list.Add(t);
        }

        // private Dictionary<string, IITFileOrCDTrack> m_htFileTracks = new Dictionary<string, IITFileOrCDTrack>();

        //   private Dictionary<int, TrackInList> m_htPiecesInAList = new Dictionary<int, TrackInList>();
        private BgDict<int, PlayListComposite> m_htPlayLists = new BgDict<int, PlayListComposite>();
        private PlayListRegister m_htLegacyPLayList; // Dictionary<int, IITUserPlaylist>();

        /// <summary>
        /// index des listes suivant persistantID (Xml) 
        /// </summary>
        private BgDictString<PlayList> persistentIDs = new BgDictString<PlayList>();

        #region parsing natif asynchrone
        //  private bool bParsingNativeAsync = true;
        //  private ThreadUtil loopbgLoadTracksNative;

        /// <summary>
        /// dictionnaire des Tracks musique par ID
        /// </summary>
        private BgDict<int, IITFileOrCDTrack> dictTracks = new BgDict<int, IITFileOrCDTrack>();

        private TracksDb persist;
        /// <summary>
        /// dictionnaire tracks par location
        /// </summary>
        //   private BgDictString<IITFileOrCDTrack> locationTrack = new BgDictString<IITFileOrCDTrack>();
        //  private TrackDb persistTracks; 
        //  private BgDictString<IITFileOrCDTrack> locationTrack = new BgDictString<IITFileOrCDTrack>();
        /// <summary>
        /// dictionnaires des tracks de playlist par ID (pas l'ID du track de liste mais l'ID du track de bib)
        /// </summary>
        private BgDict<int, IITFileOrCDTrack> dictTrackList = new BgDict<int, IITFileOrCDTrack>();

        /// <summary>
        /// Cumul des dictionnaires des tracks de playList par location
        /// </summary>
        // private BgDictString<IITFileOrCDTrack> memoTrackList = new BgDictString<IITFileOrCDTrack>();
        //  private TrackDb memoTrackList;

        private BgDictString<TrackInList> dictTrackInList = new BgDictString<TrackInList>();

        private BgDictString<TrackInList> logicalDictTrackInList = new BgDictString<TrackInList>();
        private BgDictString<TrackInList> logicalDictTrackInListDeleted = new BgDictString<TrackInList>();


        private static string getKey(string path, string location)
        {
            return String.Concat(path, ":", location).ToLower();
        }

        /// <summary>
        /// Récupération d'un track base ou liste pour ajout de trackListe
        /// </summary>
        /// <param name="location"></param>
        /// <returns></returns>
        public TrackId getAnyTrackByLocation(string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            var t = persist.getTrack(location);
            if (t == null)
            {
                if (FileRegister.Exist(location)) //  File.Exists(location))
                    loadScan("recherche location" + location);
            }
            return t;
        }



        public TrackInList getTrackInList(string path, string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            return dictTrackInList[getKey(path, location)];
        }

        public void recordTrackList(string pl, IITFileOrCDTrack track, int trackDataBaseID, string location, bool memo)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(location))
            {
                StackTrace st = new StackTrace();
                log.log("Loader::recordTrackList location nulle " + st.ToString());
                return;
            }
            //if (!dictTrackList.ContainsKey(trackDataBaseID))
            dictTrackList[trackDataBaseID] = track;
            var key = getKey(pl, location);
            persist.recordTrackList(key, location, track);
            //if (!locationTrack.ContainsKey(location))
            //    locationTrack.record(location, track);

            //if (memo && !memoTrackList.ContainsKey(key))
            //    memoTrackList.record(key, track);

            //  return id;

        }

        public void invalidationTrack(TrackInfoItunes info)
        {
            log.log("invalidation track lors de modification " + info);

            dictTracks.Remove(info.ID);
            dictTrackList.Remove(info.ID);
            persist.invalidation(info.Location);
        }

        public void invalidationTrackInList(string pl, TrackInList tl, IITUserPlaylist _pl)
        {
            log.log("invalidation trackinList " + tl);
            removeTrackInList(pl, tl, _pl);
        }

        /// <summary>
        /// Appelé en cas d'erreur ajout trackList
        /// </summary>
        /// <param name="location"></param>
        /// <param name="id"></param>
        public void invalidationLocation(string location)
        {
            log.log("invalidation track (AddTrack)" + location);
            persist.invalidation(location);
        }


        //public void recordTrackList(PlayList pl, IITFileOrCDTrack track, string location)
        //{

        //    if (!locationTrack.ContainsKey(location))
        //        locationTrack[location] = track;
        //    var key = getKey(pl, location);
        //    memoTrackList[key] = track;
        //}

        public TrackId getMemoTrackList(string path, IITUserPlaylist pl, string location)
        {
            var key = getKey(path, location);
            return persist.getTrackList(key, path, pl);
            // return memoTrackList.getTrackList(key, pl); //  [key];
        }



        private static bool erreurTrackList;
        public static bool ErreurTrackKist { get { return erreurTrackList; } set { erreurTrackList = value; } }



        public void recordTrackInList(string pl, TrackInList track, bool verifDoublon)
        {
            if (track == null)
                return;
            string key = getKey(pl, track.Location);
            //if (dictTrackInList.ContainsKey(key))
            //{
            //    if (verifDoublon)
            //    {
            //        string txt = "pas deux fois le même élément de liste \r\n" + track + "\r\n" + track.Location;
            //        log.log(txt);

            //        throw new ApplicationException(txt);
            //    }
            //}
            //else
            if (!dictTrackInList.ContainsKey(key))
                dictTrackInList[key] = track;
            // dictTrackInList[getKey(pl, track.Location)] = track;
        }

        public void removeTrackInList(string pl, TrackInList track, IITUserPlaylist plt)
        {
            if (track == null)
                return;
            string key = getKey(pl, track.Location);
            if (dictTrackInList.ContainsKey(key))
                dictTrackInList.Remove(key);


            persist.removeTrackList(key, track.Location, plt);

            dictTrackList.Remove(track.TrackDataBaseId);
            //  locationTrack.remove(track.Location);

        }

        public void removeTrackInList(string pl, string location, int TrackDataBaseId, IITUserPlaylist plt)
        {

            string key = getKey(pl, location);
            if (dictTrackInList.ContainsKey(key))
                dictTrackInList.Remove(key);


            persist.removeTrackList(key, location, plt);

            dictTrackList.Remove(TrackDataBaseId);
            //  locationTrack.remove(track.Location);
        }

        public void removeTrack(TrackInfoItunes track)
        {
            persist.removeTrack(track.Location);
        }
        /// <summary>
        /// Utilisé pour vérifier avant l'ajout que le track existe
        /// </summary>
        /// <param name="pl"></param>
        /// <param name="track"></param>
        /// <returns></returns>
        public bool LogicalContainsTrackInList(string pl, string location)
        {
            if (string.IsNullOrEmpty(location))
                return false;
            string key = getKey(pl, location);
            return logicalDictTrackInList.ContainsKey(key);
        }

        public bool LogicalTrackInListDeleted(string pl, string location)
        {
            if (string.IsNullOrEmpty(location))
                return false;
            string key = getKey(pl, location);
            return logicalDictTrackInListDeleted.ContainsKey(key);
        }


        public void LogicalRecordTrackInList(string pl, TrackInList track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            string key = getKey(pl, location);
            logicalDictTrackInListDeleted.Remove(key);
            logicalDictTrackInList.Add(key, track);
        }

        public void LogicalRemoveTrackInList(string pl, TrackInList track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            string key = getKey(pl, location);
            logicalDictTrackInList.Remove(key);
            logicalDictTrackInListDeleted.Add(key, track);
        }



        #endregion






        private bool modeXml = true;
        private bool deleteFile;
        private bool errorAccess;
        private bool singleThread;

        //public static Loader Instance
        //{
        //    get
        //    {
        //        if (_instance == null)
        //            _instance = new Loader();
        //        return _instance;
        //    }
        //}


        private Conf conf = new Conf();

        public Conf Conf
        {
            set
            {
                conf = value;
                if (detector != null)
                    detector.Conf = value.Detect;

                PlayList.Conf = conf;
                if (player != null)
                    player.Conf = value;
                TrackWrapper.SingleThread = conf.SingleThread;
                ItUtil.SingleThread = conf.SingleThread;
                singleThread = conf.SingleThread;
                checkSong = conf.checkSong;

            }
        }

        public void setConf(XmlElement xelt)
        {
            Conf = new Conf(xelt);
        }

        public bool ModeXml { set { modeXml = value; } }
        private Loader(bool deleteFile, bool writeOnlyEnabled, bool writeOnlyUnRead)
        {
            this.deleteFile = deleteFile;
            this.writeOnlyEnabled = writeOnlyEnabled;
            this.writeOnlyUnRead = writeOnlyUnRead;

        }



        #region events
        private string currentReading = "";
        void app_OnPlayerPlayingTrackChangedEvent(object iTrack)
        {

            log.log("app_OnPlayerPlayingTrackChangedEvent:" + iTrack);
            checkChangeSong();
        }

        void app_OnPlayerPlayEvent(object iTrack)
        {
            try
            {
                log.log("app_OnPlayerPlayEvent:" + iTrack);
                checkChangeSong();

            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

        }

        private string currentSong;
        private DateTime currentSongDt;
        private void getCurrentSong()
        {
            if (!checkSong)
                throw new ArgumentException("checkSong!");
            getCurrentTrack();
            getCurrentPlayList();
            currentSongDt = DateTime.Now;


            try
            {

                if (_currentTrack != null)
                {
                    getPlayerState();

                    //BackGroundTaskMgr.Playing = _playerState != ITPlayerState.ITPlayerStateStopped;
                    currentSong = _currentTrack.Location + " " + _playerState.ToString();
                }
            }
            catch { }
            getCurrentPlayList();
        }
        private string CurrentSong
        {
            get
            {
                if (!checkSong)
                    return "";
                if ((DateTime.Now - currentSongDt).TotalMinutes > 1)
                {
                    getCurrentSong();
                }

                return currentSong;
            }
        }

        private PlayListComposite _currentPlayList;
        private DateTime _currentPlayListTempo;
        private void getCurrentPlayList()
        {
            if (!checkSong)
                throw new ArgumentException();
            _currentPlayListTempo = DateTime.Now;
            try
            {
                enter();
                var _cur = app.CurrentPlaylist;
                if (_cur == null)
                    _currentPlayList = null;
                else
                    _currentPlayList = m_htPlayLists[_cur.playlistID];
            }
            finally
            {
                release();
            }
        }
        private IITFileOrCDTrack _currentTrack;
        private void getCurrentTrack()
        {
            if (!checkSong)
                throw new ArgumentException();
            currentTrackTempo = DateTime.Now;
            try
            {
                enter();
                _currentTrack = TrackWrapper.create(app.CurrentTrack);
                _currentTrackLocation = "";
                if (_currentTrack != null)
                    _currentTrackLocation = _currentTrack.Location;
            }
            finally
            {
                release();
            }
        }
        public PlayListComposite CurrentPlaylist
        {
            get
            {
                return null;
                if ((DateTime.Now - _currentPlayListTempo).TotalMinutes > 1)
                {
                    getCurrentPlayList();
                }
                return _currentPlayList;
            }
        }
        private DateTime currentTrackTempo;
        public IITFileOrCDTrack CurrentTrack
        {
            get
            {
                if (!checkSong)
                    return null;
                if ((DateTime.Now - currentTrackTempo).TotalMinutes > 1)
                {
                    getCurrentTrack();
                }
                return _currentTrack;
            }

        }
        private string _currentTrackLocation;
        public string CurrentTrackLocation
        {
            get
            {
                if (!checkSong)
                    return null;
                if ((DateTime.Now - currentTrackTempo).TotalMinutes > 1)
                {
                    getCurrentTrack();
                }
                return _currentTrackLocation;

            }
        }

        private ITPlayerState _playerState;
        private void getPlayerState()
        {
            currentStateTempo = DateTime.Now;
            try
            {
                enter();
                _playerState = app.PlayerState;
            }
            finally
            {
                release();
            }
        }
        private DateTime currentStateTempo;
        public ITPlayerState PlayerState
        {
            get
            {
                if (!checkSong)
                    return ITPlayerState.ITPlayerStateStopped;
                if ((DateTime.Now - currentStateTempo).TotalMinutes > 1)
                    getPlayerState();
                return _playerState;
            }
        }


        private void checkChangeSong()
        {
            if (!checkSong)
                return;
            getCurrentSong();

            var track = CurrentTrackLocation;
            if (!track.Equals(currentReading))
            {
                currentReading = track;
                PlayComputedTrack();
            }

        }
        #endregion



        private bool useDetect;
        public Loader(Conf conf, bool useDetect,  bool writeOnlyEnabled, bool writeOnlyUnRead)
            : this(conf.DeleteFile, writeOnlyEnabled, writeOnlyUnRead)
        {
            this.Conf = conf;
            this.m_defaultFolder = conf.DefaultFolder;
            if (!m_defaultFolder.EndsWith(@"\"))
                m_defaultFolder += @"\";
            this.useDetect = useDetect;

            this.player = new AutoPlayer(this, conf);

        }

        public Loader(Conf conf, Action abortList, bool writeOnlyEnabled, bool writeOnlyUnRead)
            : this(conf, true, writeOnlyEnabled, writeOnlyUnRead)
        {
            this.abortList = abortList;
        }

        public void saveIds()
        {
            if (persist != null)
                persist.record();
        }

        private bool initialized;

        public void init()
        {
            if (initialized)
                return;
            initialized = true;
            app = new iTunesApp();

            mainLibrairy = app.LibrarySource;
            mainPlayLists = mainLibrairy.Playlists;

            TrackInfoItunes.Loader = this;
            PlayList.Loader = this;
            //BackGroundTaskMgr.Async = true;
            //BackGroundTaskMgr.start(); 
            trackBuilder = this;
            m_htLegacyPLayList = new PlayListRegister(this.app);
            m_htLegacyPLayList.load("init");

            app.OnPlayerPlayEvent += new _IiTunesEvents_OnPlayerPlayEventEventHandler(app_OnPlayerPlayEvent);
            app.OnPlayerPlayingTrackChangedEvent += new _IiTunesEvents_OnPlayerPlayingTrackChangedEventEventHandler(app_OnPlayerPlayingTrackChangedEvent);


            detector = new Detector(app.LibraryXMLPath, logDetect, conf.Detect);
            if (useDetect)
                detector.start();


            string file = app.LibraryXMLPath;
            // bool exists = File.Exists(file);
            //while (!File.Exists(file))
            //    Thread.Sleep(30);
            m_defaultFolder = getDefaultFolder();
            log.log(m_defaultFolder);

            log.log("suppression:{0} erreur accès:{1}", deleteFile, errorAccess);

            FileInfo fTrack = new FileInfo(_dBLegacyDir + conf.DbTrack);
            DirectoryInfo dir = fTrack.Directory;
            if (!dir.Exists) dir.Create();
            // persistTracks = new TrackDb(app, f.FullName);

            var fTrackList = new FileInfo(_dBLegacyDir + conf.DbTrackList);
            dir = fTrackList.Directory;
            if (!dir.Exists) dir.Create();
            //memoTrackList = new TrackDb(app, f.FullName);

            persist = new TracksDb(app, fTrack.FullName, fTrackList.FullName, conf.ProxyTrack, conf.ProxyTrackList, conf.PersistIt, conf.SingleThread);








            //if (deleteFile)
            //{

            //    //  log.log("suppression de " + file);
            //    while (true)
            //    {
            //        try
            //        {
            //            //if (!errorAccess)
            //            log.log("suppression de " + file);
            //            File.Delete(app.LibraryXMLPath);
            //            break;
            //        }
            //        catch (Exception e)
            //        {
            //            // log.log("error acces " + file);
            //            errorAccess = true;
            //            Thread.Sleep(1000);
            //        }
            //    }
            //}



            //if (deleteFile && errorAccess)
            //    log.log("finalement pas suppression de " + file + " car erreur accès");


        }

        private void enter()
        {
            if (singleThread)
            {
                BgTask.chrono.bip("l:ent0");
                Locker.Enter();
                BgTask.chrono.bip("l:ent1");
            }
        }
        private void release()
        {
            if (singleThread)
                Locker.Release();
        }

        # region detect
        //  private bool waitForNextSong;


        // public bool WaitForNextSong { get { return waitForNextSong; } set { waitForNextSong = value; } }



        private DateTime lastLoad;
        //private DateTime confirmLoad = DateTime.MaxValue;
        private string currentSongWhenLoaded = "";
        private Detector detector;

        public void logDetect(string info)
        {
            log.logNoDate("------------------------------------------------------------------------------------");
            log.log(info);
            log.logNoDate("------------------------------------------------------------------------------------");
        }

        public bool detectModif() { return !detector.canLoad(); }

        public void checkDetect(DateTime ini)
        {
            detector.check(ini);
        }

        public void exception()
        {
            currentSongWhenLoaded = "-";
        }
        public void reset(bool firstStep, bool forceLoad)
        {
            string _current = CurrentSong;
            log.log("reset ::firstStep {0} forceLoad {1} currentSongWhenLoaded :{2} currentSong:{3}", firstStep, forceLoad, currentSongWhenLoaded, _current);

            if (!forceLoad)
                detector.reset();
            //  DateTime lastLoad = DateTime.Now;
            // string currentSongWhenLoaded = "";

            //if (waitForNextSong)
            //    currentSongWhenLoaded = CurrentSong;


            //if (!deleteFile && firstStep)
            //    lastLoad = DateTime.MinValue;
            bool canread = false;

            FileInfo fLibrary = new FileInfo(app.LibraryXMLPath);
            bool condition = false;

            while (!canread)
            {

                try
                {
                    Thread.Sleep(1000);
                    _current = CurrentSong;
                    fLibrary.Refresh();
                    if (fLibrary.Exists)
                    {
                        //DateTime dt = fLibrary.LastWriteTime;
                        ////if (lastLoad == DateTime.MinValue)
                        ////{
                        ////    lastLoad = dt;
                        ////    confirmLoad = dt.AddSeconds(conf.Confirm);
                        ////    condition = true;
                        ////    log.logNoDate("------------------------------------------------------------------------------------");
                        ////    log.log("temps chargement:{0} confirm :{1}", lastLoad, confirmLoad);
                        ////    log.logNoDate("------------------------------------------------------------------------------------");
                        ////}
                        DateTime now = DateTime.Now;
                        TimeSpan _delta = now - lastLoad;


                        if (condition)
                        {
                            bool load = true;
                            if (!forceLoad)
                                load = detector.canLoad();
                            //if (now > confirmLoad)
                            //{
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    log.log("temps de confirmation dépassé {0}", confirmLoad);
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    load = true;
                            //}
                            //else if (dt > lastLoad)
                            //{
                            //    nbTick++;
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    log.log("library modifiée {0} {1}", dt, nbTick);
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    lastLoad = dt;

                            //    if (nbTick <= conf.TickRefresh)
                            //    {
                            //        int delta = conf.ConfirmTick; // (nbTick <= 1) ? conf.Confirm : conf.ConfirmTick;
                            //        DateTime dt0 = dt; // (nbTick <= 1) ? DateTime.Now : dt;
                            //        var _confirmLoad = dt0.AddSeconds(delta);
                            //        var _confirmLoad2 = lastLoad.AddSeconds(conf.Confirm);
                            //        if (_confirmLoad2 > _confirmLoad)
                            //            _confirmLoad = _confirmLoad2; 
                            //        if (_confirmLoad > confirmLoad)
                            //            confirmLoad = _confirmLoad;
                            //        log.log("confirm {0}", confirmLoad);
                            //    }

                            //}

                            if (load)
                            {
                                DateTime ini = DateTime.Now;
                                try
                                {

                                    log.logNoDate("***********************************************************************");
                                    log.log("chargement library {0} {1}", _current, _delta);
                                    log.logNoDate("***********************************************************************");
                                    DateTime __tick = DateTime.Now;
                                    XmlDocument doc = new XmlDocument();
                                    doc.XmlResolver = null;
                                    contentXml = null;

                                    gcCollect();
                                    string itXml = app.LibraryXMLPath;
                                    doc.Load(itXml);



                                    var root = doc.DocumentElement;
                                    contentXml = root.ChildNodes[0] as XmlElement;

                                    doc = null;
                                    root = null;
                                    gcCollect();
                                    if (!forceLoad)
                                    {

                                        if (conf.Detect.CancelLoad && !detector.canLoad())
                                        {
                                            log.log("Abort car modif fichiers");
                                            continue;
                                        }
                                        checkDetect(ini);
                                        detector.signalLoad();
                                        canread = true;
                                        lastLoad = DateTime.Now;
                                        condition = false;
                                    }

                                    //   confirmLoad = DateTime.MaxValue;
                                    currentSongWhenLoaded = _current;
                                    log.logNoDate("***********************************************************************");
                                    log.log("fin chargement library {0} ", (DateTime.Now - __tick));
                                    log.logNoDate("***********************************************************************");


                                    return;
                                }
                                catch (Exception ex)
                                {

                                    log.log(ex.ToString());
                                    Thread.Sleep(1000);
                                    //nbTick++;
                                    //dt = fLibrary.LastWriteTime;

                                    //int delta = (nbTick <= 1) ? conf.Confirm : conf.ConfirmTick;
                                    //DateTime dt0 = dt; // (nbTick <= 1) ? DateTime.Now : dt;

                                    //var _confirmLoad = dt0.AddSeconds(delta);
                                    //if (_confirmLoad > confirmLoad)
                                    //    confirmLoad = _confirmLoad;
                                    //var _confirmLoad2 = lastLoad.AddSeconds(conf.Confirm);
                                    //if (_confirmLoad2 > _confirmLoad)
                                    //    _confirmLoad = _confirmLoad2; 
                                    //log.log("confirm {0}", confirmLoad);
                                }
                            }
                            else
                            {
                                misc.Pre = "[Load " + detector.Limit.ToLongTimeString() + "] ";
                                continue;
                            }
                        }



                        //  log.log("library modifiée {0}", dt);

                        bool conditionWait = false;
                        bool conditionNoWait = false;


                        if (conf.WaitForNextSong)
                        {
                            conditionWait = _current != currentSongWhenLoaded;
                        }
                        else
                        {
                            conditionNoWait = _delta > conf.Refresh;
                        }




                        if (firstStep || forceLoad || conditionWait || conditionNoWait || _delta > conf.RefreshMax)
                        {

                            condition = true;
                            if (!forceLoad)
                                detector.reset();
                            checkChangeSong();
                            if (abortList != null)
                                abortList();
                            // lastLoad = dt;

                            //if (firstStep)
                            //    confirmLoad = dt.AddSeconds(conf.Confirm);
                            //else
                            //{
                            //    log.log("library modifiée {0} attente modif {1}", dt, (nbTick + 1));
                            //    // if (nbTick <= 1)
                            //    confirmLoad = now.AddSeconds(conf.Confirm);
                            //    log.log("confirm {0}", confirmLoad);


                            //}

                        }
                        //}
                    }


                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }

                if (!canread)
                {
                    Thread.Sleep(100);
                    if (!condition)
                    {
                        if (conf.WaitForNextSong)
                            Thread.Sleep(conf.Delay);
                    }
                }

            }


        }

        #endregion

        #region Infos

        //public CPiece getPiece(IITTrack track)
        //{
        //    return m_htPieces[track.TrackDatabaseID];
        //}


        //public IITFileOrCDTrack getPieceInList(PieceInAList trackList)
        //{
        //    return m_htPiecesInAList[trackList.ID];
        //}

        //public void deleteTrackInList(PieceInAList trackList)
        //{
        //    TrackInList track = m_htPiecesInAList[trackList.ID];
        //    track.Delete();
        //    //   track.Track.Delete();
        //    m_htPiecesInAList.Remove(trackList.ID);
        //}

        private String getDefaultFolder()
        {
            string path = app.LibraryXMLPath;

            _dBLegacyDir = Path.GetDirectoryName(path) + Path.DirectorySeparatorChar;
            _dBLegacyPath = _dBLegacyDir + "iTunes Library.itl";

            String uri = "";

            String token = "<key>Music Folder</key><string>";
            //<key>Music Folder</key><string>file://localhost/F:/bernard/zique/</string>
            log.log("load {0}", path);

            while (true)
            {
                try
                {
                    foreach (String line in File.ReadAllLines(path))
                    {
                        if (line.Contains(token))
                        {
                            Regex regex = new Regex("<string>(.+)</string>");
                            Match m = regex.Match(line);
                            if (!m.Success) return "";
                            uri = m.Groups[1].Value;
                            return new Uri(uri).LocalPath.Replace("\\\\localhost\\", "");
                        }
                    }
                }
                catch
                {
                    errorAccess = true;
                    Thread.Sleep(30);
                }
            }
        }
        public String DefaultFolder
        {
            get
            {
                return m_defaultFolder;
            }
        }
        #endregion



        //public void replace(TrackInfoItunes native, TrackInfoItunes local)
        //{
        //    local.ID = native.ID;
        //    if (m_htPieces.ContainsKey(native.ID))
        //    {
        //        m_htPieces.Remove(native.ID);
        //    }
        //    native.synchroLegacy(local);
        //    m_htPieces[native.ID] = local;
        //}

        #region chargement



        public TrackInfoItunes getInfo(int trackDataBaseId)
        {
            return m_htPieces[trackDataBaseId];
        }

        public void loadTracks(List<ITrackInfoItunes> list)
        {
            lock (this)
            {
                erreurTrackList = false;
                this.list = list;

                //   m_htPieces = new Dictionary<int, TrackInfoItunes>();
                m_htTracks = new BgDict<int, IITFileOrCDTrack>();
                // private Dictionary<string, IITFileOrCDTrack> m_htFileTracks = new Dictionary<string, IITFileOrCDTrack>();
                // m_htPiecesInAList = new Dictionary<int, TrackInList>();
                m_htPlayLists = new BgDict<int, PlayListComposite>();
                persistentIDs = new BgDictString<PlayList>();
                // m_htLegacyPLayList.load("loadTracks"); //  = new Dictionary<int, IITUserPlaylist>();


                /// <summary>
                /// dictionnaire asynchrone
                /// </summary>
                //dictTracks = new BgDict<int, IITFileOrCDTrack>();
                //locationTrack = new BgDict<string, IITFileOrCDTrack>();
                //dictTrackList = new BgDict<int, IITFileOrCDTrack>();
                dictTrackInList = new BgDictString<TrackInList>();

                log.log("DEBUT loadTracks");
                if (!modeXml)
                {
                    loadTracksNative();
                    return;
                }


                //XmlDocument test = new XmlDocument();
                //test.Load(@"C:\Users\bd\Music\iTunes\test.xml");
                //var trackTest = new TrackInfoItunes(test.DocumentElement); 
                //  list = new List<TrackInfoItunes>();

                //recherche du noeud contenant les données Track
                XmlNode xtracks = null;
                for (int i = 0; i < contentXml.ChildNodes.Count; i += 2)
                {
                    XmlNode aux = contentXml.ChildNodes[i];
                    if (aux.InnerText == "Tracks")
                    {
                        xtracks = contentXml.ChildNodes[i + 1];
                        break;
                    }
                }

                //   int nb = 0;
                int count = xtracks.ChildNodes.Count;
                bool impair = false;
                foreach (XmlNode xTrack in xtracks.ChildNodes)

                // for (int i = 0; i < count; i += 2)
                {
                    impair = !impair;
                    if (impair)
                        continue;

                    //  var xTrack = xtracks.ChildNodes[i + 1];
                    //int ID = TrackInfoItunes.getID(xTrack);
                    string loc = TrackInfoItunes.getLocation(xTrack);
                    //TrackInfoItunes track = trackBuilder.create(xTrack);


                    TrackInfoItunes track = null;
                    if (m_htLoc.ContainsKey(loc))
                    {
                        track = m_htLoc[loc];
                        track.build(xTrack);

                    }
                    //  log.log("add track {0}", track);

                    else
                    {
                        track = create(loc);
                        track.build(xTrack);
                        if (track.Strange)
                            continue;



                        m_htPieces.Add(track.ID, track);
                        m_htLoc.Add(loc, track);
                    }

                    string location = track.Location;
                    if (string.IsNullOrEmpty(location))
                    {
                        log.log("phase load :: suppression du track sans localisation " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }
                    else if (!FileRegister.Exist(location)) // conf.CheckFileExist && !File.Exists(location))
                    {
                        log.log("phase load :: suppression du track absent " + track.Album + "/" + track.Name + " " + location);
                        track.Delete();
                        continue;
                    }




                    list.Add(track);
                    //  track.Index = nb;
                    //   nb++;

#if VERIF
                track.verif();
#endif
                }
                log.log("FIN loadTracks");
            }

        }

        //private void buildIndexesTracks()
        //{
        //    int count = list.Count;
        //    for (int i = 0; i < count; i++)
        //    {
        //        list[i].Index = i;
        //    }
        //}

        private void bgLoadTracksNative()
        {

            try
            {



                IITTrackCollection tracks = null;
                int count = 0;
                IEnumerator enumerator = null;
                try
                {
                    enter(); tracks = app.LibraryPlaylist.Tracks;
                    count = tracks.Count;
                    enumerator = tracks.GetEnumerator();
                }
                finally { release(); }

                int i = 0;
                while (true)
                //int count  = tracks.Count; 
                //for (int i= 1; i<=count; i++)
                {
                    while (BackGroundTaskMgr.PauseKeyBoard)
                        Thread.Sleep(100);
                    bool _cont = false;

                    try
                    { enter(); _cont = enumerator.MoveNext(); }
                    finally { release(); }
                    if (!_cont)
                        break;
                    i++;

                    try
                    {
                        IITFileOrCDTrack track = null;
                        try
                        {
                            enter();
                            //   var t = tracks[i];
                            track = TrackWrapper.create(enumerator.Current as IITFileOrCDTrack);
                        }
                        finally
                        {
                            release();
                        }
                        if (track == null)
                            continue;

                        //if (t.Kind == ITTrackKind.ITTrackKindFile)
                        //{
                        //lock (this)
                        //{
                        // IITFileOrCDTrack track = t as IITFileOrCDTrack;
                        int l_id = 0;
                        string location = "";
                        try
                        {
                            enter();
                            l_id = track.TrackDatabaseID;
                        }
                        finally
                        {
                            release();
                        }
                        try
                        {
                            enter();
                            location = track.Location;
                        }
                        finally
                        {
                            release();
                        }
                        if (i % 1000 == 0)
                            log.log("scan {0}/{1} id:{2} {3}", i, count, l_id, location);


                        if (location == null)
                        {
                            log.log("suppression du track sans localisation " + track.Album + "/" + track.Name);
                            try
                            {
                                enter(); track.Delete();
                            }
                            finally
                            {
                                release();
                            }
                            continue;
                        }
                        else
                        {

                            //  log.log("bg Add track " + location);
                            dictTracks[l_id] = track;
                            dictTrackList[l_id] = track;
                            this.persist.recordTrack(location, track);


                        }

                    }
                    catch (Exception e)
                    {
                        log.log(e.ToString());
                    }
                }
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
                log.log("!!!!!!!!!!!!!!!!!!!>>>!!!!!!!!!!!!!!!!!>>>>>>!!!!!!!!!!!!!!!!!!>>>>FIN bgLoadTracksNative ");
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
            }
            finally
            {
                lock (this)
                    scanLoaded = false;

                //list = new CListPieceWithoutPodcast(m_htPieces.Values);
            }
        }

        public void loadTracksNative()
        {

            IITTrackCollection tracks = app.LibraryPlaylist.Tracks;

            foreach (IITTrack t in tracks)
            {
                if (t.Kind == ITTrackKind.ITTrackKindFile)
                {
                    IITFileOrCDTrack track = TrackWrapper.create(t);
                    string location = "";
                    try
                    {
                        location = track.Location;
                    }
                    catch
                    {
                    }
                    log.log("add track " + location);

                    if (location.isNullorEmpty())
                    {
                        log.log("suppression du track sans localisation " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }
                    if (!FileRegister.Exist(location)) //  File.Exists(location))
                    {
                        log.log("Suppression du track absent " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }



                    //if (persist.containsTrack(location))
                    //{
                    //    log.log("suppression du track doublon " + track.Album + "/" + track.Name + " " + track.Location);
                    ////    track.Delete();
                    //    continue;
                    //}

                    persist.recordTrack(location, track);
                    //              String l_strFile = track.Location.Replace(m_defaultFolder, "");
                    int l_id = track.TrackDatabaseID;

                    //string l_Artist = track.Artist.TrimSafe();
                    //string l_Album = track.Album.TrimSafe();
                    //string l_Name = track.Name.TrimSafe();
                    //int l_trackNumber = -1;
                    //if (track.TrackNumber > 100) track.TrackNumber = 0;
                    //if (track.TrackNumber > 0)
                    //{
                    //    l_trackNumber = track.TrackNumber;
                    //}

                    //CPieceReference l_details = new CPieceReference(l_Artist, l_Album, l_Name, l_trackNumber);

                    //int l_year = -1; if (track.Year > 0) l_year = track.Year;
                    //CPieceInfo l_infos = new CPieceInfo(l_year);

                    //int l_rating = 0; if (track.Rating > 0) l_rating = track.Rating;


                    //DateTime l_date = DateTime.MinValue; if (track.PlayedDate > DateTime.MinValue) l_date = track.PlayedDate;

                    //int l_duration = track.Duration;
                    //bool l_enabled = track.Enabled;


                    //CPiece l_piece = new CPiece(l_details, l_strFile, l_infos, l_rating, l_date, l_duration, l_enabled);
                    TrackInfoItunes l_piece = create(location);
                    l_piece.build(track);
                    //new TrackInfoItunes(track);
                    l_piece.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                    m_htTracks[l_id] = track;
                    m_htPieces[l_id] = l_piece;
                    //l_piece.ID = l_id;
                    //   buildArt(track); 
                    list.Add(l_piece);
                    //  log.log("add track {0}", l_piece);

                }
            }

            log.log("FIN LoadTracksNative ");
            //list = new CListPieceWithoutPodcast(m_htPieces.Values);
        }

        ///// <summary>
        ///// Récupération d'un track  Itunes en fonction de son index
        ///// </summary>
        ///// <param name="id"></param>
        ///// <returns></returns>
        //public IITFileOrCDTrack getTrack(string location)
        //{
        //    if (m_htFileTracks.ContainsKey(location))
        //        return m_htFileTracks[location];

        //    foreach (IITTrack t in app.LibraryPlaylist.Tracks)
        //    {
        //        if (t.Kind == ITTrackKind.ITTrackKindFile)
        //        {
        //            IITFileOrCDTrack track = t as IITFileOrCDTrack;
        //            string _loc = track.Location;
        //            if (!m_htFileTracks.ContainsKey(_loc))
        //            {
        //                m_htFileTracks.Add(_loc, track);
        //                if (location.Equals(_loc))
        //                    return track;
        //            }
        //        }
        //    }

        //    return null;



        //}
        /// <summary>
        /// Récupération d'un track en vue de le supprimmer
        /// </summary>
        /// <param name="trackInfoItunes"></param>
        /// <returns></returns>
        public TrackId getTrackTrack(TrackInfoItunes trackInfoItunes)
        {
            IITFileOrCDTrack _track = null;
            int ID = trackInfoItunes.ID;

            _track = dictTracks[ID].check(trackInfoItunes.Location);
            TrackPersistantId _id = null;
            TrackId trackId = persist.getTrackTrack(trackInfoItunes.Location);

            if (trackId != null)
            {
                _id = trackId.Id;
                _track = trackId.Track.check(trackInfoItunes.Location);
            }
            #region complique
            if (conf.ComplexSearch)
            {
                if (_track == null)
                {
                    try
                    {
                        enter();
                        int index = list.IndexOf(trackInfoItunes);
                        if (index >= 0)
                            _track = TrackWrapper.create(app.LibraryPlaylist.Tracks[index + 1]).check(trackInfoItunes.Location);


                        if (_track == null)
                        {
                            loadScan("recherche TrackTrack " + trackInfoItunes.Location);
                            return null;
                        }

                        string attendu = trackInfoItunes.Location;
                        string mesure = _track.Location;
                        persist.recordTrack(mesure, _track); // [mesure] = _track;
                        dictTracks[_track.TrackDatabaseID] = _track;

                        if (attendu.Equals(mesure))
                        {
                            //    log.log("-->bg Add track via getTrack: " + _track.Location);
                            // dictTracks[ID] = _track;
                        }
                        else
                        {

                            //   log.log("-->bg Add BAD track via getTrack attendu :{0}, mesuré {1}", attendu, mesure);
                            loadScan("TrackTrack attendu " + attendu + " <> mesuré " + mesure);
                            return null;
                        }
                    }
                    finally { release(); }
                }
            }
            #endregion
            if (_track == null)
                loadScan("?");

            return new TrackId(_id, _track);
        }



        /// <summary>
        /// Récupération d'un track en vue de le modifier
        /// </summary>
        /// <param name="trackInfoItunes"></param>
        /// <returns></returns>
        public IITFileOrCDTrack getTrack(TrackInfoItunes trackInfoItunes)
        {
            IITFileOrCDTrack _track = null;
            int ID = trackInfoItunes.ID;
            //  TrackPersistantId _id = null;
            int IDFound = -1;
            try
            {

                _track = dictTracks[ID];

                if (_track == null)
                {
                    var _t = persist.getTrack(trackInfoItunes.Location);
                    if (_t != null && _t.Track != null)
                    {
                        _track = _t.Track;
                        //_id = _t.Id;
                    }
                }
                BgTask.chrono.bip("getT");
                #region complique
                if (conf.ComplexSearch)
                {
                    if (_track == null)
                    {
                        try
                        {
                            enter();
                            //loadScan("recherche track " + trackInfoItunes);
                            int index = list.IndexOf(trackInfoItunes);
                            if (index >= 0)
                                _track = TrackWrapper.create(app.LibraryPlaylist.Tracks[index + 1]).check(trackInfoItunes.Location);

                            if (_track != null)
                            {
                                IDFound = _track.TrackDatabaseID;
                                dictTracks[IDFound] = _track;
                                dictTrackList[IDFound] = _track;
                                persist.recordTrack(_track); // [_track.Location] = _track;


                                if (IDFound == ID)
                                { //    log.log("getTrack by ID: " + trackInfoItunes.Location);
                                }
                                else if (_track.Location == trackInfoItunes.Location)
                                    log.log("getTrack by location: " + trackInfoItunes.Location);
                                else
                                {
                                    _track = null;
                                }
                            }
                        }
                        finally { release(); }

                    }


                    if (_track == null || _track.TrackDatabaseID != ID)
                    {
                        loadScan("recherche track 2 " + trackInfoItunes);
                        _track = dictTrackList[ID];
                    }


                    if (_track == null || _track.TrackDatabaseID != ID)
                    {
                        loadScan("recherche track 4 " + trackInfoItunes);
                        _track = null;
                    }
                }

                #endregion



            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
                loadScan("recherche track Exception " + trackInfoItunes);
            }

            #region complique
            if (conf.ComplexSearch)
            {
                if (_track != null)
                {
                    IDFound = _track.TrackDatabaseID;
                    dictTracks[IDFound] = _track;
                    dictTrackList[IDFound] = _track;
                    persist.recordTrack(_track);
                }
            }
            #endregion

            // return new TrackId(_id, _track);
            return _track;
        }

        void Track_classNameChanged(object sender, TrackInfoItunes.TrackClassNameEventArgs e)
        {
            TrackInfoItunes track = sender as TrackInfoItunes;
            updateClassList(track);
        }

        private void updateClassList(TrackInfoItunes piece)
        {

            List<CPlayList> copy = new List<CPlayList>();
            foreach (CPlayList list in piece.ClassPlayLists)
            {
                PieceInAList pieceInList = list.getPieceInList(piece);
                if (pieceInList != null)
                {

                    // deleteTrackInList(pieceInList);
                    pieceInList.Delete();
                    //    list.remove(pieceInList);
                    copy.Add(list); //  piece.removePlayList(list);
                }
            }

            String plName = piece.ClassName;
            setClassPlayList(piece, plName);

            foreach (CPlayList list in copy)
            {
                piece.removePlayList(list);
            }


        }

        public IEnumerable<ITrackInfoItunes> ListAllTracks { get { return list; } }
        public IEnumerable<ITrackInfoItunes> ListTracks { get { return list.FindAll(t => !t.isPodcast); } }
        public IEnumerable<ITrackInfoItunes> ListPodCast { get { return list.FindAll(t => t.isPodcast); } }
        public void loadListsNative()
        {
            IITSourceCollection sources = app.Sources;

            for (int i = 1; i <= sources.Count; i++)
            {
                loadPlayListsNative(sources[i]);
            }
            //   Console.WriteLine(root.ToString());
        }

        private bool scanLoaded;
        public void loadScan(string raison)
        {
            if (scanLoaded)
                return;

            lock (this)
            {
                if (scanLoaded)
                    return;
                scanLoaded = true;

                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
                log.log("!!!!!!!!!!!!!!!!!!!>>>!!!>>>>DEBUT bgLoadTracksNative ( " + raison + " ) ");
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");


                var loopbgLoadTracksNative = new ThreadUtil(bgLoadTracksNative, "BgT");
                // loopbgLoadTracksNative.Name = "BgT";
                loopbgLoadTracksNative.Start();
            }
        }
        public void loadLists()
        {
            lock (this)
            {
                log.log("Début load list");
                DateTime begin = DateTime.Now;
                // persistentIDs = new Dictionary<string, PlayList>();
                if (listLoaded)
                {
                    foreach (PlayList logical in logicals)
                    {
                        logical.DeleteBase();
                    }
                }
                root.DeleteChilds(); // = new PlayList("root", null);
                gcCollect();
                if (!modeXml)
                {
                    loadListsNative();
                    return;
                }
                // IITSourceCollection sources = app.Sources;


                //for (int i = 1; i <= sources.Count; i++)
                //{
                //    IITSource source = sources[i];
                //    var playlists = source.Playlists;

                //    foreach (IITPlaylist pl in playlists)
                //    {
                //        if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
                //        {
                //            var upl = pl as IITUserPlaylist;
                //            recordlegacyPlayList(upl);
                //        }
                //        checkDetect(begin);
                //    }
                //}


                //if (bParsingNativeAsync)
                //{
                //    Thread loopbgLoadTracksNative = new Thread(bgLoadTracksNative);
                //    loopbgLoadTracksNative.Name = "BgT";
                //    loopbgLoadTracksNative.Start();
                //}



                XmlNode xPlaylists = null;
                int count = contentXml.ChildNodes.Count;
                for (int i = 0; i < count; i += 2)
                {
                    XmlNode aux = contentXml.ChildNodes[i];
                    if (aux.InnerText == "Playlists")
                    {
                        xPlaylists = contentXml.ChildNodes[i + 1];
                        break;
                    }
                    continue;
                }


                foreach (XmlNode xDist in xPlaylists.ChildNodes)
                {
                    string KEY = "key";
                    int ID = -1;
                    string persistentID = null;
                    string parentPersistentID = null;
                    bool forgetIt = false;
                    bool folder = false;
                    string name = null;
                    XmlNode contentList = null;
                    int count2 = xDist.ChildNodes.Count;
                    for (int i = 0; i < count2; i += 2)
                    {
                        XmlNode meta = xDist.ChildNodes[i];
                        string value = xDist.ChildNodes[i + 1].InnerText;
                        if (meta.Name == KEY)
                        {
                            switch (meta.InnerText)
                            {
                                case "Master": forgetIt = true; break;
                                case "Distinguished Kind": forgetIt = true; break;
                                case "Name": name = value; break;
                                case "Playlist ID": ID = Convert.ToInt32(value); break;
                                case "Playlist Persistent ID": persistentID = value; break;
                                case "Folder": folder = true; break;
                                case "Parent Persistent ID": parentPersistentID = value; break;
                                case "Playlist Items": contentList = xDist.ChildNodes[i + 1]; break;

                            }

                        }
                    }

                    if (forgetIt)
                        continue;
                    PlayList parent = null;


                    if (parentPersistentID == null)
                        parent = root;
                    else parent = persistentIDs[parentPersistentID];

                    IITUserPlaylist upl = null;
                    try
                    {
                        upl = m_htLegacyPLayList.getItPl(ID, name);
                    }
                    catch
                    {
                        log.log("impossible de charger la liste " + ID + " " + name);
                        throw;
                    }
                    PlayList current = addChildPlayList2(upl, parent, name, ID, persistentID);
                    log.log("add pl {0}", current);

                    if (folder)
                        continue;
                    if (contentList == null)
                        continue;
                    bool _blogic = false;
                    if (listLoaded)
                    {
                        foreach (PlayList logical in logicals)
                        {
                            if (current.isSubList(logical))
                            {
                                _blogic = true;
                                break;
                            }
                        }
                        if (_blogic)
                            continue;
                    }


                    bool go = filterPlaylist.consider(current);
                    if (!go) continue;

                    ////    if (current.isSubList("gen")) continue;
                    //    if (current.isSubList("auto")) continue;
                    //    if (current.isSubList("d")) continue;
                    //    if (current.isSubList("c")) continue;




                    int countList = contentList.ChildNodes.Count;
                    int ii = 0;
                    foreach (XmlNode xdictTrack in contentList.ChildNodes)
                    {
                        int id = Convert.ToInt32(xdictTrack.ChildNodes[1].InnerText);

                        TrackInfoItunes piece = m_htPieces[id];
                        if (piece == null)
                            continue;

                        TrackInList plPiece = new TrackInList(current, piece, id);
                        plPiece.ID = ID * 1000 * 1000 + ii;
                        current.add(plPiece);
                        //current.addPiece(piece);
                        ii++;
                        afterCreate(current, piece, id);
                    }



                    //   current.scanTracks();



#if VERIF
                current.verif();
#endif
                    log.log("{0} elts", current.ChildsCount);
                }

                if (listLoaded)
                    reintegrateLogical();



                contentXml = null;
                gcCollect();

                checkDetect(begin);
                listLoaded = true;
                log.log("Fin de load Lists");
            }






        }

        private void reintegrateLogical()
        {
            foreach (PlayList pl in logicals)
                pl.reintegrate();
        }

        protected virtual void afterCreate(PlayList playlist, TrackInfoItunes track, int id)
        {
        }

        //private void loadPlayLists(IITSource source)
        //{
        //    log.log("Loader:loadPlayLists source");
        //    IITPlaylist pl;
        //    IITUserPlaylist upl;

        //    for (int index = 1; index <= source.Playlists.Count; index++)
        //    {
        //        pl = source.Playlists[index];
        //        log.log("Loader:loadPlayLists check {0}", pl.Name);
        //        if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
        //        {
        //            upl = pl as IITUserPlaylist;
        //            recordlegacyPlayList(upl);


        //            if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone ||
        //                upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
        //            {

        //                PlayListComposite parent = null;
        //                IITUserPlaylist iparent = upl.get_Parent();
        //                if (iparent != null)
        //                {
        //                    parent = m_htPlayLists[iparent.playlistID];
        //                }
        //                else
        //                {
        //                    parent = root;
        //                }


        //                CPlayList current = addChildPlayList(parent, upl);

        //                if (current.isSubList("gen")) continue;
        //                if (current.isSubList("auto")) continue;
        //                if (current.isSubList("d")) continue;
        //                if (current.isSubList("c")) continue;

        //                log.log("add pl {0}", current);




        //                //current.ID = upl.playlistID;
        //                //m_htPlayLists.Add(upl.playlistID, current);

        //                //parent.add(current);


        //                if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
        //                {
        //                    foreach (IITTrack t in upl.Tracks)
        //                    {
        //                        if (t.Kind == ITTrackKind.ITTrackKindFile)
        //                        {
        //                            IITFileOrCDTrack track = t as IITFileOrCDTrack;
        //                            if (!track.Podcast)
        //                            {
        //                                TrackInfoItunes piece = m_htPieces[track.TrackDatabaseID];
        //                                TrackInList plPiece = new TrackInList(piece, track);
        //                                plPiece.ID = track.trackID;
        //                                m_htPiecesInAList.Add(plPiece.ID, plPiece);
        //                                current.add(plPiece);
        //                                current.addPiece(piece);
        //                            }
        //                        }
        //                    }
        //                    log.log("{0} elts", current.ChildsCount);
        //                }


        //            }

        //        }
        //    }

        //}

        private void loadPlayListsNative(IITSource source)
        {
            log.log("Loader:loadPlayLists source");
            IITPlaylist pl;
            IITUserPlaylist upl;

            for (int index = 1; index <= source.Playlists.Count; index++)
            {
                pl = source.Playlists[index];
                log.log("Loader:loadPlayLists check {0}", pl.Name);
                if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
                {
                    upl = pl as IITUserPlaylist;
                    recordlegacyPlayList(upl);


                    if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone ||
                        upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                    {

                        PlayListComposite parent = null;
                        IITUserPlaylist iparent = upl.get_Parent();
                        if (iparent != null)
                        {
                            parent = m_htPlayLists[iparent.playlistID];
                        }
                        else
                        {
                            parent = root;
                        }


                        CPlayList current = addChildPlayList(parent, upl);

                        // if (current.isSubList("gen")) continue;
                        if (current.isSubList("auto")) continue;
                        if (current.isSubList("d")) continue;
                        if (current.isSubList("c")) continue;

                        log.log("add pl {0}", current);




                        //current.ID = upl.playlistID;
                        //m_htPlayLists.Add(upl.playlistID, current);

                        //parent.add(current);


                        if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                        {
                            foreach (IITTrack t in upl.Tracks)
                            {
                                if (t.Kind == ITTrackKind.ITTrackKindFile)
                                {
                                    IITFileOrCDTrack track = TrackWrapper.create(t); // as IITFileOrCDTrack;
                                    if (!track.Podcast)
                                    {
                                        TrackInfoItunes piece = m_htPieces[track.TrackDatabaseID];
                                        TrackInList plPiece = new TrackInList(piece, track);
                                        plPiece.ID = track.trackID;
                                        // m_htPiecesInAList.Add(plPiece.ID, plPiece);
                                        current.add(plPiece);
                                        // current.addPiece(piece);
                                    }
                                }
                            }
                            log.log("{0} elts", current.ChildsCount);
                        }


                    }

                }
            }

        }

        private CPlayList addChildPlayList(PlayListComposite parent, IITPlaylist iSubList)
        {
            CPlayList subList = new CPlayList(iSubList.Name);
            subList.ID = iSubList.playlistID;
            //  if (m_htPlayLists.ContainsKey(subList.ID))
            m_htPlayLists.Add(subList.ID, subList);
            m_htLegacyPLayList.recordlegacyPlayList(iSubList as IITUserPlaylist);

            parent.add(subList);
            return subList;
        }

        private PlayList addChildPlayList2(IITUserPlaylist upl, PlayList parent, string name, int ID, string persistentID)
        {
            try
            {
                enter();
                if (!m_htPlayLists.ContainsKey(ID))
                {
                    PlayList subList = null;
                    //bool subListIsGenerated = false; // listLoaded && parent.isSubList(gen);
                    //bool subListIsGen = false; // = parent == root && name == "gen";


                    if (listLoaded)
                    {
                        foreach (PlayList logical in logicals)
                        {
                            if (logical.Parent != null && parent != null)
                            {
                                if (parent.isSubList(logical))
                                {
                                    subList = parent.getComposite(ID) as PlayList;
                                    break;
                                }
                            }
                        }
                    }

                    if (subList == null)
                    {

                        var strLists = conf.LogicalLists;
                        for (int l = 0; l < strLists.Count; l++)
                        {
                            if (subList != null)
                                break;
                            string strList = strLists[l];
                            string path = strList; // "root" + strList;
                            string[] parts = path.Split('\\');
                            int count = parts.GetLength(0);
                            PlayListComposite current = root;
                            for (int i = 0; i < count; i++)
                            {
                                string part = parts[i];
                                if (string.IsNullOrEmpty(part))
                                    continue;
                                var plPart = current.getComposite(part) as PlayList;
                                //if (plPart == null)
                                //{
                                //    if (listLoaded)
                                //        break;
                                //}
                                if (i == count - 1)
                                {
                                    if (name == part)
                                    {
                                        if (listLoaded)
                                        {
                                            PlayList pl = logicals.Find(lo => lo.Name == name);
                                            if (pl.Parent == null)
                                            {
                                                current.add(pl);
                                                subList = pl;
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            subList = PlayList.create(name, parent, upl);
                                            if (!logicals.Contains(subList))
                                                logicals.Add(subList);
                                            break;

                                        }
                                    }
                                }

                                current = plPart;
                                if (current == null)
                                    break;
                            }

                        }
                    }

                    //if (listLoaded)
                    //{
                    //    foreach (PlayList logical in logicals)
                    //    {
                    //        if (parent.isSubList(logical))
                    //        {
                    //            subList = parent.getComposite(name) as PlayList;
                    //        }
                    //    }
                    //}



                    //if (subListIsGenerated)
                    //    subList = parent.getComposite(name) as PlayList;
                    //else if (subListIsGen && listLoaded)
                    //{
                    //    subList = gen;
                    //    root.add(gen);
                    //}

                    if (subList == null)
                        subList = PlayList.create(name, parent, upl);
                    //if (subListIsGen)
                    //    gen = subList;

                    if (m_htPlayLists.ContainsKey(ID))
                    {
                        var str = string.Format("zarb:ID{0} subList.ID {1} clé existante {2} {3}", ID, subList.ID, subList.getPath(), m_htPlayLists[ID].getPath());

                    }
                    else
                    {

                        subList.ID = ID;

                        m_htPlayLists.Add(subList.ID, subList);
                        persistentIDs.Add(persistentID, subList);
                    }

                }




            }
            finally { release(); }




            return persistentIDs[persistentID]; // subList;
        }




        private void recordlegacyPlayList(IITUserPlaylist upl)
        {
            //  log.log(upl.playlistID + " " + upl.Name);
            //  m_htLegacyPLayList.Add(upl.playlistID, upl);
        }

        //private void recordlegacyPlayList(IITUserPlaylist upl, int index)
        //{
        //    log.log(upl.playlistID + " " + upl.Name);
        //    m_htLegacyPLayList.Add(index, upl);
        //}

        #endregion

        #region manip
        public PlayListComposite getOrCreateFolder(String folder)
        {
            PlayListComposite plFolder = root.getComposite(folder);
            if (plFolder == null)
            {
                IITPlaylist itFolder = app.createFolder(folder);
                recordlegacyPlayList(itFolder as IITUserPlaylist);
                plFolder = addChildPlayList(root, itFolder);
            }
            return plFolder;
        }

        public PlayListComposite getOrCreateFolder(PlayListComposite folder, String name, bool buildIf)
        {
            PlayListComposite pSub = folder.getComposite(name);
            if (pSub == null && buildIf)
            {
                IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                IITPlaylist itSub = itFolder.createFolder(name);

                pSub = addChildPlayList(folder, itSub);
            }
            return pSub;
        }

        public CPlayList getList(PlayListComposite folder, String name)
        {
            lock (this)
            {
                PlayListComposite plist = folder.getComposite(name);

                if (plist == null)
                {
                    IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                    var itPlist = itFolder.createPlaylist(name);
                    recordlegacyPlayList(itPlist);
                    plist = addChildPlayList(folder, itPlist);
                }
                return plist as CPlayList;
            }

        }

        public PlayList GetPlayList(PlayListComposite folder, string name, bool buildIf)
        {
            if (folder == null)
                return null;
            lock (this)
            {
                PlayListComposite plist = folder.getComposite(name);

                if (plist == null && buildIf)
                {
                    IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                    IITPlaylist itPlist = itFolder.createPlaylist(name);
                    recordlegacyPlayList(itPlist as IITUserPlaylist);
                    plist = addChildPlayList(folder, itPlist);

                    return PlayList.create(name, folder as CPlayList, itPlist as IITUserPlaylist);
                }

                return plist as PlayList;
            }


        }

        public void mergeList(CPlayList playlist, ICollection<IFile> newElements_, bool withOrder, IAbortTask writer, IBgTask task)
        {
            PlayList pl = playlist as PlayList;
            if (pl == null)
            {
                log.log("pas un PLayList {0}", playlist);
                return;
            }

            withOrder = !pl.VerifyDoublon;
            if (withOrder)
                pl.mergeListWithOrder(newElements_, writer, task); 
            else
                pl.mergeList(newElements_, writer, writeOnlyEnabled, writeOnlyUnRead);
        }




        public void removeList(PlayListComposite folder, String name)
        {
            PlayListComposite plist = folder.getComposite(name);
            if (plist != null)
            {
                IITPlaylist itPlist = m_htLegacyPLayList.getItPl(plist.ID, plist.Name);
                itPlist.Delete();
                m_htLegacyPLayList.Remove(plist.ID, plist.Name);
                m_htPlayLists.Remove(plist.ID);
                folder.remove(plist);
            }
        }

        public void SynchronizePodcast()
        {
            log.log("UpdateIPod");
            app.UpdateIPod();
        }

        public void addList(PlayListComposite folder, String name, ICollection<IFile> list)
        {
            lock (this)
            {
                IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                IITUserPlaylist itPlist = itFolder.createPlaylist(name);
                recordlegacyPlayList(itPlist as IITUserPlaylist);

                if (list.Count == 0) return;

                //   String[] paths = new String[list.Count+1];

                //for(int i=0; i<list.Count; i++)
                //{
                //    paths[i+1] = list[i].Path ; 
                //}
                //   object objPath = (object)paths;
                //   itPlist.AddFiles(ref objPath); 



                foreach (IFile piece in list)
                {
                    itPlist.AddFile(piece.Location);
                }
            }
        }
        #endregion

        /// <summary>
        /// Rangement de la classList
        /// </summary>
        /// <param name="track"></param>
        /// <param name="orgClassName"></param>
        /// <param name="newClassName"></param>
        public void setClassPlayList(TrackInfoItunes track, string orgClassName, string newClassName)
        {
            lock (this)
            {

                //1. Suppression
                var list = new List<CPlayList>(track.ClassPlayLists);
                foreach (CPlayList pl in list)
                {
                    if (pl.Name.Equals(newClassName))
                        continue;
                    var trackInList = pl.getPieceInList(track);
                    if (trackInList != null)
                        trackInList.Delete();
                }

                //2. vérif que la liste cible ne contient pas déjà le track
                foreach (CPlayList pl in list)
                {
                    if (!pl.Name.Equals(newClassName))
                        continue;
                    var trackInList = pl.getPieceInList(track);
                    if (trackInList != null)
                        return;
                }

                //3. ajout
                PlayList newpl = getClassPlayList(newClassName);
                newpl.Add(track.Location, "setClassPlayList", true);

            }


        }

        public PlayList getFolderOrList(PlayList root, string name, bool findFolder)
        {
            if (root == null)
                root = this.root;
            var current = root;

            foreach (PlComponent plComponent in current)
            {
                if (plComponent is PlayListComposite)
                {
                    var plComposite = plComponent as PlayListComposite;
                    if (plComposite.Name == name)
                    {
                        var playList = plComposite as PlayList;
                        var specialKind = ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone;
                        if (findFolder)
                            specialKind = ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder;
                        if (playList.ItPlayList.SpecialKind == specialKind)
                        {
                            return playList;

                        }
                    }

                }
            }

            return null;

        }

        private PlayList searchClassList(PlayList current, string listName)
        {
            foreach (PlComponent plComponent in current)
            {
                if (plComponent is PlayListComposite)
                {

                    var plComposite = plComponent as PlayListComposite;
                    var name = plComposite.Name;

                    bool sameBase = true;

                    for (int i = 0; i < listName.Length && i < name.Length; i++)
                    {
                        if (!listName[i].Equals(name[i]))
                        {
                            sameBase = false;
                            break;
                        }
                    }

                    if (!sameBase)
                        continue;

                    var playList = plComposite as PlayList;
                    var subSearch = searchClassList(playList, listName);

                    if (subSearch != null)
                        return subSearch;

                    if (name.Equals(listName))
                    {
                        if (playList.ItPlayList.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                            return playList;
                    }

                }
            }
            return null;
        }


        private PlayList getClassPlayList(string listName)
        {
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;
                var classement = root.getComposite(CPlayList.CLASSEMENT) as PlayList;

                var search = searchClassList(classement, listName);
                if (search != null)
                    return search;
                var current = classement;

                for (int i = 0; i < listName.Length - 1; i++)
                {
                    String FolderOrList = listName.Substring(0, i + 1);
                    PlayList found = getFolderOrList(current, FolderOrList, true);

                    if (found == null)
                    {
                        IITUserPlaylist itFolder = current.ItPlayList.createFolder(FolderOrList);
                        recordlegacyPlayList(itFolder as IITUserPlaylist);
                        found = PlayList.create(FolderOrList, current, itFolder);
                    }
                    current = found as PlayList;
                }

                var last = getFolderOrList(current, listName, false);
                if (last == null)
                {

                    IITUserPlaylist itPlayList = current.ItPlayList.createPlaylist(listName);
                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    last = PlayList.create(listName, current, itPlayList);


                }

                return last as PlayList;
            }

        }


        private PlayList getClassPlayList__OLD(string listName)
        {
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;
                var classement = root.getComposite(CPlayList.CLASSEMENT) as PlayList;
                var current = classement;

                for (int i = 0; i < listName.Length - 1; i++)
                {
                    String FolderOrList = listName.Substring(0, i + 1);
                    PlayList found = getFolderOrList(current, FolderOrList, true);

                    if (found == null)
                    {
                        IITUserPlaylist itFolder = current.ItPlayList.createFolder(FolderOrList);
                        recordlegacyPlayList(itFolder as IITUserPlaylist);
                        found = PlayList.create(FolderOrList, current, itFolder);
                    }
                    current = found as PlayList;
                }

                var last = getFolderOrList(current, listName, false); // current.getComposite(listName);
                if (last == null)
                {
                    //if (current.ItPlayList.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                    //{
                    IITUserPlaylist itPlayList = current.ItPlayList.createPlaylist(listName);
                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    last = PlayList.create(listName, current, itPlayList);
                    //}

                }

                return last as PlayList;
            }

        }


        public PlayList getOrCreatePlayList(PlayList root, string listName, bool isFolder)
        {
            if (_aborted)
                return null;
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;

                if (root == null)
                    root = this.root;


                var pl = getFolderOrList(root, listName, isFolder);

                if (pl == null)
                {
                    if (_aborted)
                        return null;
                    IITUserPlaylist itPlayList = null;
                    if (isFolder)
                    {
                        if (root == this.root)
                            itPlayList = app.createFolder(listName);
                        else
                            itPlayList = root.ItPlayList.createFolder(listName);

                    }
                    else
                    {
                        if (root == this.root)
                            itPlayList = app.createPlaylist(listName);
                        else
                            itPlayList = root.ItPlayList.createPlaylist(listName);
                    }

                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    pl = PlayList.create(listName, root, itPlayList);
                }

                return pl;
            }
        }

        //public PlayList getOrCreatePlayList(string listName, bool isFolder)
        //{
        //    return getOrCreatePlayList(this.root, listName, isFolder);
        //}



        public void setClassPlayList(ITrackMetaData piece, String listName)
        {
            lock (this)
            {
                if (String.IsNullOrEmpty(listName)) return;
                //String listName = piece.ClassList;
                IITUserPlaylist itCurrent;
                PlayListComposite classement = getOrCreateFolder(CPlayList.CLASSEMENT);

                PlayListComposite current = classement;


                if (listName.isInteger())
                {

                    for (int i = 0; i < listName.Length; i++)
                    {
                        String FolderOrList = listName.Substring(0, i + 1);

                        PlayListComposite subList = current.getComposite(FolderOrList);
                        //  PlayListComposite parent = current.Parent; 
                        IITUserPlaylist itSubList;
                        // IITUserPlaylist itParent = m_htLegacyPLayList[parent.ID]; 
                        if (subList == null)
                        {
                            itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name);

                            if (itCurrent.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                            {

                                var currentName = itCurrent.Name;
                                // suppression et mémorisation des pistes
                                var listAux = new List<ITrackMetaData>();
                                foreach (IITFileOrCDTrack track in itCurrent.Tracks)
                                {
                                    ITrackMetaData pieceToMove = m_htPieces[track.TrackDatabaseID];
                                    listAux.Add(pieceToMove);
                                    // m_htPiecesInAList.Remove(track.trackID);
                                    track.Delete();
                                }

                                // suppression de la liste
                                PlayListComposite parent = current.Parent;
                                IITUserPlaylist itParent = m_htLegacyPLayList.getItPl(parent.ID, parent.Name);

                                itCurrent.Delete();
                                parent.remove(current);
                                m_htPlayLists.Remove(current.ID);

                                // création durépertoire                                                       
                                itCurrent = itParent.createFolder(currentName) as IITUserPlaylist;
                                recordlegacyPlayList(itCurrent);
                                current = addChildPlayList(parent, itCurrent);

                                //remplacement de la liste supprimée
                                IITUserPlaylist itRempl = itCurrent.createPlaylist(currentName) as IITUserPlaylist;
                                recordlegacyPlayList(itRempl);
                                PlayListComposite rempl = addChildPlayList(current, itRempl);

                                // ajout des morceaux
                                foreach (ITrackMetaData pieceToMove in listAux)
                                {
                                    IITOperationStatus status = itRempl.AddFile(pieceToMove.Location);
                                    IITFileOrCDTrack track = TrackWrapper.create(status.Tracks[1]); // as IITFileOrCDTrack;

                                    TrackInList plPiece = new TrackInList(pieceToMove, track);
                                    plPiece.ID = track.trackID;
                                    //  m_htPiecesInAList.Add(plPiece.ID, plPiece);
                                    rempl.add(plPiece);
                                }

                            }
                            itSubList = i < listName.Length - 1 ? itCurrent.createFolder(FolderOrList) as IITUserPlaylist : itCurrent.createPlaylist(FolderOrList) as IITUserPlaylist;
                            recordlegacyPlayList(itSubList as IITUserPlaylist);
                            subList = addChildPlayList(current, itSubList);
                        }
                        current = subList;
                    }

                }
                else
                {
                    PlayListComposite subList = current.getComposite(listName);
                    if (subList == null)
                    {
                        itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name); // [current.ID];
                        IITPlaylist itSubList = itCurrent.createPlaylist(listName);
                        recordlegacyPlayList(itSubList as IITUserPlaylist);
                        subList = addChildPlayList(current, itSubList);
                    }
                    current = subList;
                }

                itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name); //  [current.ID];
                if (itCurrent.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                {
                    PlayListComposite sub = current.getComposite(itCurrent.Name);
                    if (sub == null)
                    {
                        IITUserPlaylist itSubList = itCurrent.createPlaylist(itCurrent.Name) as IITUserPlaylist;
                        recordlegacyPlayList(itSubList);
                        sub = addChildPlayList(current, itSubList);
                    }
                    current = sub;
                    itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name);
                }


                {
                    IITOperationStatus status = itCurrent.AddFile(piece.Location);
                    if (status == null)
                    {
                        log.log("unable to add {0}", piece);
                        return;
                    }

                    IITFileOrCDTrack track = TrackWrapper.create(status.Tracks[1]); // as IITFileOrCDTrack;

                    if (track == null)
                    {
                        log.log("unable to add {0}", piece);
                        return;
                    }

                    TrackInList plPiece = new TrackInList(piece, track);
                    plPiece.ID = track.trackID;
                    //  m_htPiecesInAList.Add(plPiece.ID, plPiece);
                    current.add(plPiece);
                    TrackInfoItunes trackBib = m_htPieces[track.TrackDatabaseID];
                    CPlayList pl = current as CPlayList;
                    //if (pl != null)
                    //    pl.addPiece(trackBib);

                }
            }


        }
        //public ITrackMetaData getTrack(ITrackMetaData piece)
        //{
        //    TrackInfoItunes track = piece as TrackInfoItunes; 
        //    if (track == null || !exists(piece) )
        //        return new TrackInfoItunes(getNewTrack(piece));

        //    return track;
        //}


        //public IITFileOrCDTrack AddFile(IITUserPlaylist pl, string location)
        //{
        //    IITFileOrCDTrack track = null;
        //    IITOperationStatus status = pl.AddFile(location);
        //    if (status == null)
        //    {
        //        log.log("{0} : unable to AddFile {0}", pl.Name, location);
        //        return null;
        //    }
        //    while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
        //    {
        //        Thread.Sleep(30);
        //    }

        //    track = status.Tracks[1] as IITFileOrCDTrack;
        //    return track;
        //}


        public virtual void createTrack(TrackInfoItunes piece, bool podcast)
        {

            try
            {
                log.log(String.Format("create track for {0}", piece.ToString()));
                IITFileOrCDTrack track = null;
                IITOperationStatus status = app.LibraryPlaylist.AddFile(piece.Location);
                if (status == null)
                {
                    log.log(String.Format("unable to load track {0}", piece.ToString()));
                    return;
                }
                while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
                {
                    Thread.Sleep(30);
                }

                track = TrackWrapper.create(status.Tracks[1]);

                if (track.Location == null)
                {
                    log.log(String.Format("track sans localaisation {0}", piece));
                    piece.TrackTrack = new NoTrack(piece);
                    return;
                }

                if (m_htTracks.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    piece.TrackTrack = track;
                    return; // m_htTracks[track.TrackDatabaseID];
                }

                m_htTracks.Add(track.TrackDatabaseID, track);

                if (m_htPieces.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    piece.TrackTrack = track;
                    return; // m_htTracks[track.TrackDatabaseID];
                }

                // intern.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);


                //var id = persist.recordTrack(track);
                //intern.PersistantId = id;

                m_htPieces.Add(track.TrackDatabaseID, piece);
                m_htLoc.Add(piece.Location, piece);
                piece.TrackTrack = track;

                if (podcast)
                {
                    track.Genre = "Podcast";
                }
            }
            catch (Exception e)
            {
                log.log(e.ToString());
            }

        }

        public TrackInfoItunes getNewTrack(IFile piece)
        {

            TrackInfoItunes intern = null;
            try
            {
                log.log(String.Format("create track for {0}", piece.ToString()));
                IITFileOrCDTrack track = null;
                IITOperationStatus status = app.LibraryPlaylist.AddFile(piece.Location);
                if (status == null)
                {
                    log.log(String.Format("unable to load track {0}", piece.ToString()));
                    return null;
                }
                while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
                {
                    Thread.Sleep(30);
                }

                track = TrackWrapper.create(status.Tracks[1]);
                if (m_htTracks.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    return m_htPieces[track.TrackDatabaseID]; // m_htTracks[track.TrackDatabaseID];
                }
                if (track.Location == null)
                {
                    log.log(String.Format("track sans localaisation {0}", piece));
                    return null;
                }

                intern = create(track.Location);
                intern.build(track);
                // intern.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                m_htTracks.Add(track.TrackDatabaseID, track);
                //var id = persist.recordTrack(track);
                //intern.PersistantId = id;

                m_htPieces.Add(track.TrackDatabaseID, intern);
                m_htLoc.Add(track.Location, intern);
            }
            catch (Exception e)
            {
                log.log(e.ToString());
            }
            return intern;
        }



        private TrackInfoItunes getNewTrack(ITrackNative piece)
        {

            //PlayListComposite plNew = root.getComposite("news");
            //IITUserPlaylist itNews;
            //if (plNew == null)
            //{
            //    itNews = app.CreatePlaylist("news") as IITUserPlaylist;
            //    recordlegacyPlayList(itNews);
            //    plNew = addChildPlayList(root, itNews);
            //}

            //itNews = m_htLegacyPLayList[plNew.ID];

            //// String[] path = new String[] { piece.Path };
            //IITOperationStatus status = itNews.AddFile(piece.Path);
            //track = status.Tracks[1] as IITFileOrCDTrack;
            //piece.ID = track.TrackDatabaseID;
            //m_htTracks.Add(track.TrackDatabaseID, track);
            //m_htPieces.Add(track.TrackDatabaseID, piece);
            //return track;

            TrackInfoItunes intern = getNewTrack(piece as IFile);

            try
            {
                intern.Artist = piece.Artist;
            }
            catch { log.log("unable to change artist {0}  {1}", piece.Artist, piece); }
            try
            {
                intern.Album = piece.Album;
            }
            catch { log.log("unable to change album  {0}  {1}", piece.Album, piece); }
            try
            {
                intern.Name = piece.Name;
            }
            catch { log.log("unable to change name  {0}  {1}", piece.Name, piece); }
            try
            {
                if (piece.TrackNumber > 100000) intern.TrackNumber = 0;
                if (piece.TrackNumber > 0)
                {
                    intern.TrackNumber = piece.TrackNumber;
                }
                else
                {
                    intern.TrackNumber = 0;
                }
            }
            catch { log.log("unable to change number  {0} {1}", piece.TrackNumber, piece); }
            if (piece.Year > 0) try { intern.Year = piece.Year; }
                catch { log.log("unable to change year  {0} {1}", piece.Year, piece); }

            if (piece.Rating >= 0) try { intern.Rating = piece.Rating; }
                catch { log.log("unable to change rating  {0} {1}", piece.Rating, piece); }

            try
            {
                if (!string.IsNullOrEmpty(piece.ClassName))
                {
                    setClassPlayList(intern, "", piece.ClassName);
                }
            }
            catch
            {
                log.log("unable to change className  {0} {1}", intern.ClassName, piece);
            }

            try { intern.Enabled = piece.Enabled; }
            catch { log.log("unable to change check  {0} {1}", piece.Enabled, piece); }

            return intern;


        }


        //private bool exists(ITrackMetaData piece)
        //{
        //    TrackInfoItunes track = piece as TrackInfoItunes;
        //    if (track == null) return false;
        //    return m_htTracks.ContainsKey(track.ID);
        //}

        public ITrackInfoItunes createLegacyTrack(ITrackNative piece)
        {
            return getNewTrack(piece);
        }

        //public IITTrackCollection Tracks
        //{
        //    get { return app.LibraryPlaylist.Tracks; }
        //}

        public void Disconnect()
        {
            app = null;
            gcCollect();
        }
        private void gcCollect()
        {
            if (conf.GcCollect)
                misc.gcCollect("Loader");
        }
        public String DbPath { get { return _dBLegacyPath; } }
        public string DbDir { get { return _dBLegacyDir; } }

        public void deleteTrack(String location)
        {
            if (location.isNullorEmpty())
            {
                log.log("Loader: unable to delete track, location empty!");
                return;
            }
            location = location.ToLower();
            //     private Dictionary<int, TrackInfoItunes> m_htPieces = new Dictionary<int, TrackInfoItunes>();
            //private Dictionary<int, IITFileOrCDTrack> m_htTracks = new Dictionary<int, IITFileOrCDTrack>();
            // private Dictionary<int, IITFileOrCDTrack> m_htPiecesInAList = new Dictionary<int, IITFileOrCDTrack>();
            // private Dictionary<int, PlayListComposite> m_htPlayLists = new Dictionary<int, PlayListComposite>();
            // private Dictionary<int, IITUserPlaylist> m_htLegacyPLayList = new Dictionary<int, IITUserPlaylist>();
            TrackInfoItunes info = null;
            foreach (TrackInfoItunes _info in m_htPieces.Values)
            {
                if (_info.Location.isNullorEmpty()) continue;
                if (_info.Location.ToLower() == location)
                {
                    info = _info;
                    break;
                }

            }
            if (info == null)
            {
                log.log("Loader:deleteTrack '{0}' non trouvé", location);
                return;
            }

            try
            {
                log.log("Loader:deleteTrack: delete'{0}'", location);
                int ID = info.ID;
                // IITFileOrCDTrack track = info.Track;

                List<TrackInList> listToDelete = new List<TrackInList>();
                //foreach (TrackInList trackInList in info.ClassPlayLists
                //{
                //    if (trackInList.ID == ID)
                //    {
                //        listToDelete.Add(trackInList);
                //    }
                //}

                //foreach (TrackInList trackInList in listToDelete)
                //{
                //    m_htPiecesInAList.Remove(trackInList.ID);
                //    trackInList.Delete();
                //}


                info.Delete();
                list.Remove(info);
                //buildIndexesTracks();
            }
            catch
            {

                log.log("Loader:unable to deleteTrack: '{0}'", location);
            }
        }



        public ITrackInfoItunes createTrack(int id, String location)
        {
            if (!location.isMusic())
                return null;
            //if (location.ToLower().EndsWith(".m3u")) return null;
            //if (location.ToLower().EndsWith(".pls")) return null;
            //if (location.ToLower().EndsWith(".jpg")) return null;
            //if (location.ToLower().EndsWith(".png")) return null;
            return getNewTrack(new FileLocation(location, id));
        }
        private class FileLocation : IFile
        {
            String file;
            int id;
            public FileLocation(String file, int id) { this.file = file; this.id = id; }
            public string Location { get { return file; } }

            public override string ToString()
            {
                return file;
            }



            public int PieceId
            {
                get { return id; }
            }


            public string getLocation()
            {
                return file;
            }
        }


        public PlayListComposite TreePlayList
        {
            get { return root; }
        }



        #region ITrackBuilder Members



        #endregion

        public virtual TrackInfoItunes create(string location)
        {
            return new TrackInfoItunes() { Location = location };
        }

        # region lecture
        private AutoPlayer player;
        public List<TrackInList> NextTracks { set { player.NextTracks = value; } }
        public TrackInList CurrentTrackInList { get { return player.CurrentTrack; } }
        public void PlayComputedTrack()
        {
            player.PlayComputedTrack();
        }
        //private TrackInList nextTrack;
        //private TrackInList currentTrack; 
        //public TrackInList NextTrack
        //{
        //    set
        //    {
        //        if (value == null)
        //            return;
        //        log.log("NextTrack:: old : {0}, new {1}", nextTrack, value);
        //        nextTrack = value;
        //    }
        //    get
        //    {
        //        return nextTrack;
        //    }
        //}

        //public TrackInList CurrentTrackInList
        //{
        //    set
        //    {
        //        if (value == null)
        //            return;
        //        log.log("CurrentTrack:: old : {0}, new {1}", currentTrack, value);
        //        currentTrack = value;
        //    }
        //    get
        //    {
        //        return currentTrack;
        //    }
        //}

        //public void PlayComputedTrack()
        //{
        //    if (conf == null || !conf.AutoPlay)
        //        return;
        //    try
        //    {
        //        if (app.PlayerState != ITPlayerState.ITPlayerStatePlaying)
        //            return;
        //        var usualTrack = CurrentTrackLocation;
        //        if (nextTrack == null)
        //            return;
        //        if (currentTrack == null)
        //            return;
        //        if (usualTrack.Equals(currentTrack.Location))
        //            return;
        //        if (usualTrack.Equals(nextTrack.Location))
        //            return;
        //        log.log("PlayComputedTrack::usualTrack:{0} nextTrack:{1}", usualTrack, nextTrack.Location);
        //        nextTrack.play();
        //        currentReading = nextTrack.Location;
        //        nextTrack = null;


        //    }
        //    catch (Exception e)
        //    {
        //        log.log(e.ToString());
        //    }


        //}
        #endregion

        private bool _aborted;
        public bool Aborted
        {
            get
            {
                return _aborted;
            }
            set
            {
                _aborted = value;
            }
        }
    }

    public static class TrackUtil
    {

    }
}


]]></content>
  </file>
  <file path="\pieceDb.iT\PlayList.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using iTunesLib;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.IO;
using pdb.it.persistance;

namespace pdb.it
{


    public class PlayList : CPlayList, IPlayList, pdb.iit.IPlayList
    {
        private static Loader loader;
        private static Conf conf;
        private static volatile object _lockP = new object();

        private string path;

        public static Loader Loader { set { loader = value; } }
        //  private static int nbReq;
        // private static int nbErr;
        //  private volatile object _lock = new object();
        //private bool scanLaunched = false; 
        // private int indexScan = 1;
        private static BgDictString<int> dictIndex = new BgDictString<int>();
        public static Conf Conf
        {
            set
            {
                conf = value;
                _singleThread = conf.SingleThread;
                scanListLimit = conf.ScanListLimit;
                _gcCollect = conf.GcCollect;
                NbScan = conf.MaxScan;
            }
        }
        private void enter()
        {
            if (_singleThread)
            {
                BgTask.chrono.bip("pl:ent0");
                Locker.Enter();
                BgTask.chrono.bip("pl:ent1");
            }
        }
        private void release()
        {
            if (_singleThread)
                Locker.Release();
        }

        private static bool scanListLimit;
        public static bool ScanListLimit { set { scanListLimit = value; } }
        public bool VerifyDoublon { set { verifyDoublon = value; } get { return verifyDoublon; } }

        private IITUserPlaylist _pl;
        public IITUserPlaylist ItPlayList { get { return _pl; } }

        private static bool _singleThread;
        //  public static bool SingleThread { set { _singleThread = value; } }

        private static bool _gcCollect;

        private bool _abort;
        public static void AbortOpe()
        {
            lock (playLists)
            {
                foreach (PlayList pl in playLists)
                    pl._abort = true;
                //  playLists.Clear();
            }
        }

        public static void StartOpe()
        {
            lock (playLists)
            {
                foreach (PlayList pl in playLists)
                    pl._abort = false;
                //  playLists.Clear();
            }
        }

        private static void addScan(PlayList pl)
        {

            //   log.log("===============>debut scan de {0}", pl);

        }



        private static void removeScan(PlayList pl)
        {

            //   log.log("===============>fin scan de {0}", pl);

        }

        private bool verifyDoublon = true;

        private static List<PlayList> playLists = new List<PlayList>();
        public static PlayList create(string name, CPlayList parent, IITUserPlaylist pl)
        {
            lock (playLists)
            {
                var _pl = new PlayList(name, parent, pl);
                playLists.Add(_pl);
                return _pl;
            }
        }


        public static PlayList create(string name, IITUserPlaylist pl)
        {
            lock (playLists)
            {
                var _pl = new PlayList(name, pl);
                playLists.Add(_pl);
                return _pl;
            }
        }

        protected Logger log;
        public Logger Log { get { return log; } }
        private PlayList(string name, CPlayList parent, IITUserPlaylist pl)
            : base(name, parent)
        {
            this._pl = pl;
            this.path = getPath();
            log = Logger.getLogger(path);
            //this.indexScan = dictIndex[path];
        }
        private PlayList(string name, IITUserPlaylist pl)
            : base(name)
        {
            this._pl = pl;
            this.path = getPath();
            log = Logger.getLogger(path);
            //    this.indexScan = dictIndex[path];
        }
        private static BackGroundTaskMgr _backGroundTaskMgr; //  BackGroundTaskMgr BackGroundTaskMgr("PlayList",false);
        private BackGroundTaskMgr _scanBgMgr;
        private BackGroundTaskMgr _addMgr;
        private static BackGroundTaskMgr _addMgrClassement;
        // private Task task;
        private int nbTaskScan;
        public static int NbScan = 3;

        public bool MaxScan { get { return nbTaskScan > NbScan; } }
        //  private int scanPrior;

        public void updatePriority(scanPriority prior)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                if (prior >= scanPriority.high && isClassSubList())
                    prior = scanPriority.classement;
                BackGroundTaskMgr.checkScanPriority(_scanBgMgr, prior); // _scanBgMgr.Priority = scanPrior;
            }
        }

        public void increasePriority(scanPriority prior)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                if (prior >= scanPriority.high && isClassSubList())
                    prior = scanPriority.classement;
                BackGroundTaskMgr.increaseScanPriority(_scanBgMgr, prior); // _scanBgMgr.Priority = scanPrior;

            }
        }

        public BackGroundTaskMgr ScanMgr
        {
            get
            {
                // getScanMgr();
                return _scanBgMgr;
            }
        }

        private void getScanMgr()
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {

                if (_scanBgMgr == null)
                {
                    lock (this)
                    {
                        if (_scanBgMgr == null)
                        {
                            _scanBgMgr = BackGroundTaskMgr.getMgr("scan " + path, 0);
                            _scanBgMgr.makePersistent();
                        }
                    }
                }

            }
        }
        private void loadScanTracks(bool searchDoublon, PlComponent source)
        {
            scanPriority prior = scanPriority.high;
            if (searchDoublon)
                prior = scanPriority.medium;
            increasePriority(prior);

            TaskScan task = TaskScan.create(this, source);
            //if (currentTaskScan == null)
            //{
            //    lock (this)
            //    {
            //        if (currentTaskScan == null)
            //            task = new TaskScan(this);
            //    }
            //}


            if (task == null)
                return;


            if (scanListLimit)
            {
                if (_backGroundTaskMgr == null)
                {
                    lock (this)
                    {
                        if (_backGroundTaskMgr == null)
                            _backGroundTaskMgr = BackGroundTaskMgr.getMgrlarge("PlayList");
                    }
                }
                _backGroundTaskMgr.add(task);
            }
            else
            {
                //if (currentTaskScan == null)
                //{
                //    lock (this)
                //    {
                //        if (currentTaskScan == null)
                //        {
                var th = new ThreadUtil(task.exec, path);
                th.Start();
                //}

                //}
                //}
            }




            //    return;
            //scanLaunched = true; 
            //_backGroundTaskMgr.add(new Task(this)); // new Thread(_scan).Start();
        }

#if V
       private BgDict<string, TrackInList> dict = new BgDict<string, TrackInList>();
#endif

        //private BackGroundTaskMgr _classement;
        //private BackGroundTaskMgr _trackList;
        //private void checkBgMgrFriends()
        //{
        //    if (_classement == null)
        //        _classement = BackGroundTaskMgr.FindMgr("Classement");
        //    if (_trackList == null)
        //        _trackList = BackGroundTaskMgr.FindMgr("TrackList " + path);

        //}
        //private TaskScan currentTaskScan = null;
        private void _scan(TaskScan task)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                //if (!_scanBgMgr.IsEnd)
                //{
                //    lock (this)
                //    {
                //        if (!_scanBgMgr.IsEnd)
                //        {
                //            log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                //            log.log("ATTENTION TENTATIVE CONCURRENTE DE SCAN");
                //            log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                //            return;
                //        }
                //    }

                //}

            }


            //lock (this)
            //{
            //    if (currentTaskScan != null)
            //    {
            //        log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            //        log.log("ATTENTION TENTATIVE CONCURRENTE DE SCAN LOCK");
            //        log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            //        return;
            //    }
            //    currentTaskScan = task;
            //}



            addScan(this);


            try
            {
                BgDictString<IITTrack> dict = new BgDictString<IITTrack>();
                int count = 0;
                try
                {
                    enter();
                    count = _pl.Tracks.Count;
                }
                finally
                {
                    release();
                }
                var i = dictIndex[path];
                if (i >= count - 1)
                    i = 0;
                i -= 100;
                if (i < 0)
                    i = 0;

                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                log.log("démarrage tâche scan:{0} index:{1} / {2}", path, i, count);
                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");


                int logNb = 0;
                if (i == 0)
                {
                    nbTaskScan++;
                    logNb = TaskScan.logScan(task);
                }

                var sourceScan = task.source;
                int indexSource = IndexOf(sourceScan);
                string fileSource = sourceScan.Location;

                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                log.log("démarrage tâche scan: nbLog:{0} {1} index:{2} / {3} cause:i={4} {5} ", logNb, path, i, count,
                    indexSource, fileSource);
                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");

                if (nbTaskScan > 1)
                {
                    log.logNoDate("--------------------------------------------------------------------------------------------------");
                    log.log("{0} NB SCAN {1}/{2}", this, nbTaskScan, NbScan);

                    log.logNoDate("--------------------------------------------------------------------------------------------------");
                }

                if (MaxScan)
                {
                    log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                    log.log("{0} MAX SCAN {1}", this, nbTaskScan);
                    log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                }



                if (BackGroundTaskMgr.Ordonnancement)
                {
                    while (true)
                    {
                        Scan scanItem = new Scan(this, dict, i);
                        _scanBgMgr.add(scanItem);
                        i++;
                        if (i >= count)
                        {
                            //count = _pl.Tracks.Count;
                            //if (count > i)
                            //{
                            //    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            //    log.log("modification count {0} index:{1} / {2}", path, i, count);
                            //    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            //}
                            //  if (i >= count)
                            break;
                        }
                    }

                    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    log.log("attente fin scan {0} index:{1} / {2}", path, i, count);
                    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");



                }
                else
                {

                    #region old
                    // for (int i = 1; i <= count; i++)
                    // {

                    //foreach (IITTrack t in _pl.Tracks)

                    for (int ii = i; ii < count; i++)

                    //var enumerator = _pl.Tracks.GetEnumerator();
                    //while (enumerator.MoveNext())
                    {
                        var _track = TrackWrapper.create(_pl.Tracks[ii + 1]); // as IITFileOrCDTrack;// enumerator.Current as IITFileOrCDTrack;

                        // IITTrack t = _pl.Tracks[i];
                        if (_track == null)
                            continue;
                        if (task.Abort) // || _abortScan)
                        {
                            log.log("tache abandonnée {0}", this);
                            return;
                        }
                        try
                        {
                            //if (_singleThread && !BackGroundTaskMgr.Ordonnancement)
                            //    Locker.Enter();
                            if (task.Abort) // || _abortScan)
                            {
                                log.log("tache abandonnée {0}", this);
                                return;
                            }
                            //if (t.Kind  == ITTrackKind.ITTrackKindFile)
                            //{
                            //IITFileOrCDTrack _track = t as IITFileOrCDTrack;
                            //if (t == null)
                            //    continue;

                            //  checkBgMgrFriends();

                            //if (BackGroundTaskMgr.Ordonnancement)
                            //{
                            //    Scan scanItem = new Scan(this, dict, i);
                            //    _scanBgMgr.add(scanItem);
                            //}
                            //else
                            //{

#if V
                    TrackInList track =  dict[_track.Location];

#else
                            if (string.IsNullOrEmpty(_track.Location))
                            {
                                log.log("{0}===============>suppression du track de liste sans localisation ", this);
                                _track.Delete();
                                continue;
                            }

                            if (!FileRegister.Exist(_track.Location)) //   conf.CheckFileExist && !File.Exists(_track.Location))
                            {
                                log.log("{0}===============>suppression du track de liste absent du système de fichier", this);
                                _track.Delete();
                                continue;
                            }

                            if (verifyDoublon)
                            {
                                if (dict.ContainsKey(_track.Location))
                                {
                                    log.log("{0} {1}===============>suppression du track de liste en doublon ", this, _track.Location);
                                    _track.Delete();
                                    continue;
                                }
                                dict.Add(_track.Location, _track);
                            }
                            BgTask.chrono.bip("oldscan");
                            loader.recordTrackList(getPath(), _track, _track.TrackDatabaseID, _track.Location, true);

                            TrackInList track = loader.getTrackInList(getPath(), _track.Location);
#endif
                            if (track == null)
                            {
                                //TODO vérifier
                                //log.log("ajout exceptionnel du track {0} à la liste {1}", _track.Location, this);
                                //TrackInfoItunes piece = new TrackInfoItunes(_track);
                                //track = new TrackInList(piece, _track);
                                //add(track);
                                //addPiece(piece);



                            }
                            else
                            {
#if V

#else

#endif

                                track.setTrack(_track);
                            }

                            //}
                            //  }
                        }
                        catch (Exception e)
                        {
                            log.log(e.ToString());
                        }
                        finally
                        {
                            //if (_singleThread && !BackGroundTaskMgr.Ordonnancement)
                            //    Locker.Release();
                        }
                    }

                    #endregion


                }

                if (BackGroundTaskMgr.Ordonnancement)
                {
                    if (_scanBgMgr.Stopped)
                    {
                        log.log("{0} stoppé après la fin de l'empilage, bizarre...", this);
                        _scanBgMgr.start();
                    }
                    while (true)
                    {
                        while (i < count)
                        {
                            i++;
                            Scan scanItem = new Scan(this, dict, i);
                            _scanBgMgr.add(scanItem);
                        }
                        Thread.Sleep(30);
                        if (!_scanBgMgr.IsEnd)
                            continue;
                        int count0 = count;
                        try
                        {
                            enter(); count = _pl.Tracks.Count;
                        }
                        finally { release(); }
                        if (count > count0)
                        {
                            log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            log.log("modification 2 count {0} index:{1} / {2}", path, i, count);
                            log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");

                        }
                        else
                            break;
                    }



                }

            }

            catch (Exception e)
            {
                log.log(e.ToString());
            }

            finally
            {
                log.logNoDate("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                log.log("fin tâche scan:{0}", path);
                log.logNoDate("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                //lock (this)
                //{
                //    TaskScan.remove(task); // currentTaskScan = null;
                //}
                removeScan(this);
            }


        }

        class Scan : BgTaskBase
        {
            private PlayList pl;
            //  private IITFileOrCDTrack _track;
            private BgDictString<IITTrack> dict;
            private string path;
            private int index;

            public Scan(PlayList pl, BgDictString<IITTrack> dict, int index)
                : base("i=" + index.ToString())
            {
                //    this._track = _track;
                this.pl = pl;
                this.dict = dict;
                this.path = pl.getPath();
                this.index = index;
            }

            public override void exec()
            {
                success = true;
                try
                {
                    pl.enter();
                    var _track = TrackWrapper.create(pl._pl.Tracks[index + 1]);
                    if (_track == null)
                        return;
                    string location = _track.Location;
                    if (string.IsNullOrEmpty(location))
                    {
                        pl.log.log("{0} ===============>suppression du track de liste sans localisation ", path);
                        pl.increasePriority(scanPriority.medium);

                        _track.Delete();
                        return;
                    }

                    //this.Desc = _track.Location; 
                    if (pl.verifyDoublon)
                    {
                        if (dict.ContainsKey(location))
                        {
                            pl.log.log("{0} {1} ===============>suppression du track de liste en doublon ", path, location);
                            pl.increasePriority(scanPriority.medium);
                            _track.Delete();
                            return;
                        }
                        dict.Add(location, _track);
                    }
                    BgTask.chrono.bip("spl:t");
                    PlayList.loader.recordTrackList(path, _track, _track.TrackDatabaseID, location, true);

                    TrackInList track = PlayList.loader.getTrackInList(path, location);
                    PlayList.dictIndex[path] = index;

                    if (track == null)
                    {
                        //track = pl.getPieceInList(new FileImpl(location)) as TrackInList;
                        //if (track == null)
                        //{
                        //success = false;  // bonne idée mais au rejeu on supprimme un faux doublon
                        return;
                        //}

                        //PlayList.loader.recordTrackInList(pl, track, false);
                    }

                    BgTask.chrono.bip("spl:t2");
                    track.setTrack(_track);


                }
                catch (Exception e)
                { pl.log.log("NIET " + e.Message); }




                finally
                {
                    pl.release();
                    //bool highPriority = false;
                    //if (pl._trackList != null && pl._trackList.Contains(path))
                    //    highPriority = true;
                    //else if (pl._classement != null && pl._classement.Contains(path))
                    //    highPriority = true;

                    //pl.checkPriority(highPriority);
                }
            }
        }



        private class FileImpl : IFile
        {
            private string location;
            private int id;

            public FileImpl(string location, int id)
            {
                this.location = Location;
                this.id = id;
            }

            #region IFile Members

            public string Location
            {
                get { return location; }
            }

            public int PieceId { get { return id; } }

            public override bool Equals(object obj)
            {
                var o = obj as IFile;
                if (o == null)
                    return false;
                return location.Equals(o.Location);

            }

            public override int GetHashCode()
            {
                return location.GetHashCode();
            }

            public override string ToString()
            {
                return location;
            }

            #endregion


            public string getLocation()
            {
                return location;
            }
        }
        //public override bool Contains(string location)
        //{
        //    bool ret =  base.Contains(location);
        //    if (!ret)
        //        return ret;
        //    return loader.LogicalContainsTrackInList(path, location); 
        //}

        public bool LogicalContainsTrackInList(string location)
        {
            return loader.LogicalContainsTrackInList(path, location);
        }

        public bool LogicalTrackInListDeleted(TrackInList track)
        {
            return loader.LogicalTrackInListDeleted(path, track.Location);
        }

        public void removeTrack(TrackInList track)
        {
            // if (!Contains(track.Location))
            loader.removeTrackInList(path, track, _pl);
            loader.LogicalRemoveTrackInList(path, track);
        }


        public void invalidationTrack(TrackInList track)
        {
            loader.invalidationTrackInList(path, track, _pl);
        }

        //public void locateNextTrack(TrackInList current, IFile nextLocation)
        //{
        //    if (current == null)
        //        return; 
        //    int count = Count;

        //    current.locate();
        //    loader.CurrentTrackInList = current;

        //    var next = getPieceInList(nextLocation) as TrackInList; 

        //    if (next != null)
        //    {
        //        next.locate();
        //        loader.NextTrack = next; 
        //    }
        //}

        public void recordNextTracks(List<IFile> nextLocation)
        {

            var list = new List<TrackInList>();

            foreach (IFile file in nextLocation)
            {
                var track = getPieceInList(file) as TrackInList;
                if (track == null)
                    continue;
                if (!track.Enabled)
                    continue;
                list.Add(track);
            }

            loader.NextTracks = list;
        }


        public void findTrack(TrackInList track)
        {

            string location = track.Location;
            var memo = loader.getMemoTrackList(path, _pl, location);
            if (memo != null && memo.Track != null)
            {
                track.setTrack(memo.Track);
                return;
            }

            #region complique
            bool _ok = false;
            if (conf.ComplexSearch)
            {
                //  loadScanTracks(false);




                int index = IndexOf(track);
                IITFileOrCDTrack _track1 = null;
                IITFileOrCDTrack _track2 = null;
                if (index >= 0)
                {
                    try
                    {
                        BgTask.chrono.bip("plf:0");
                        enter();
                        _track1 = TrackWrapper.create(_pl.Tracks[index + 1]); // as IITFileOrCDTrack;
                    }
                    finally
                    {
                        release();
                    }
                    BgTask.chrono.bip("plf:1");
                    //if (_track == null)
                    try
                    {
                        enter();
                        _track2 = TrackWrapper.create(_pl.Tracks.ItemByPlayOrder[index + 1]); // as IITFileOrCDTrack;
                        BgTask.chrono.bip("plf:2");
                    }
                    finally { release(); }

                }
                //if (_track1 == null || _track2 == null)
                //{
                //    // nbErr++;
                //    loadScanTracks(false, track);
                //    return;
                //}

                string location1 = null;
                string location2 = null;

                //TrackPersistantId id1 = null;
                //TrackPersistantId id2 = null;


                try
                {
                    enter();
                    if (_track1 != null)
                    {
                        location1 = _track1.Location;
                        if (!string.IsNullOrEmpty(location1) && (FileRegister.Exist(location1))) //  conf.CheckFileExist || File.Exists(location1)))
                        {
                            _ok = true;
                            if (location1 != location)
                                loader.recordTrackList(path, _track1, _track1.TrackDatabaseID, location1, true);
                        }
                    }
                    if (_track2 != null)
                    {

                        location2 = _track2.Location;
                        if (!string.IsNullOrEmpty(location2) && (FileRegister.Exist(location2)))
                        {
                            _ok = true;
                            if (location2 != location)
                                loader.recordTrackList(path, _track2, _track2.TrackDatabaseID, location2, true);
                        }
                    }

                    if (!_ok)
                    {
                        loadScanTracks(false, track);
                        return;
                    }


                }
                catch (Exception ex)
                {
                    log.log("findTrack::", ex);
                    //nbErr++;
                    loadScanTracks(false, track);
                    return;
                }
                finally { release(); }

#if V
                            TrackInList track2 = dict[location];
#else
                _ok = false;
                TrackInList track21 = loader.getTrackInList(path, location1);
                TrackInList track22 = loader.getTrackInList(path, location2);
#endif


                if (track21 == track)
                {
                    _ok = true;
                    track21.setTrack(_track1);
                    //log.log("==>track bien retrouvé par index {0}/{1} {2} {3} ", (nbReq - nbErr), nbReq, this, track);
                }

                if (track22 == track)
                {
                    _ok = true;
                    track22.setTrack(_track2);
                    //log.log("==>track bien retrouvé par index {0}/{1} {2} {3} ", (nbReq - nbErr), nbReq, this, track);
                }
            }

            #endregion

            if (!_ok)
                loadScanTracks(false, track);



        }

        private class mergeListWithOrderTask
        {
            private PlayList playlist;
            private ICollection<IFile> newElements_;
            private IAbortTask writer;
            private IBgTask task;
            private Logger log;
            public mergeListWithOrderTask(PlayList playlist, ICollection<IFile> newElements_, IAbortTask writer, IBgTask task)
            {
                this.playlist = playlist;
                this.newElements_ = newElements_;
                this.writer = writer;
                this.task = task;
                log = playlist.log;
            }

            public void launch()
            {
                new Thread(go).Start();
            }

            private void go()
            {
                var newElements = new List<IFile>(newElements_);

                playlist.verifyDoublon = false;

                IITFileOrCDTrack currentPlaying = null;
                string currentAlbum = "----";

                try
                {
                    lock (playlist)
                    {


                        try
                        {
                            if (loader.CurrentPlaylist == playlist)
                            {
                                if (loader.PlayerState == ITPlayerState.ITPlayerStatePlaying)
                                {
                                    currentPlaying = loader.CurrentTrack;
                                    if (currentPlaying != null)
                                        //  currentIndex = currentPlaying.Index;
                                        currentAlbum = currentPlaying.Album;
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            log.log("impossible de déterminer la liste courante", ex);
                        }
                    }


                    // 1. suppression
                    //List<TrackInList> toDelete = new List<TrackInList>();
                    //List<IFile> toAdd = new List<IFile>();



                    //123475
                    //15634


                    // phase 1 
                    int iNew = 0;
                    int iThis = 0;

                    int newCount = newElements.Count;
                    //int thisCount = this.LeafsCount;

                    DateTime debut = DateTime.Now;
                    log.log("debut calcul liste triée " + this);


                    while (true)
                    {
                        if (writer.Aborted || task.Abort || playlist._abort) return;
                        TrackInList currentList = null;
                        if (iThis >= newCount)
                        {
                            currentList = playlist[iThis] as TrackInList;
                            while (currentList != null)
                            {
                                if (writer.Aborted || task.Abort || playlist._abort) return;
                                if (currentAlbum != currentList.Piece.Album)
                                    currentList.Delete();
                                iThis++;
                                currentList = playlist[iThis] as TrackInList;
                            }

                            break;
                        }



                        IFile newCurrent = null;

                        try
                        {
                            newCurrent = newElements[iNew];
                        }
                        catch (Exception ex)
                        {
                            log.log("impossible d'accéder à l'item " + iNew + " " + ex.ToString());
                            break;

                        }



                        var toDelete = new List<IBgTask>();
                        while (true)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            if (iThis >= playlist.LeafsCount)
                                currentList = null;
                            else
                            {
                                currentList = playlist[iThis] as TrackInList; // _pl.Tracks[iThis + 1] as IITFileOrCDTrack;
                            }

                            if (currentList == null)
                                break;
                            // currentListLocation = currentList.Location;
                            if (newCurrent.Location.Equals(currentList.Location))
                            {
                                break;
                            }

                            var _task = currentList.delete();
                            toDelete.Add(_task);


                            iThis++;

                        }

                        if (toDelete.Count > 0)
                            log.log("{0} {1} elt to delete", this, toDelete.Count);



                        while (true)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            var found = toDelete.Find(t => !t.Success);
                            if (found == null)
                                break;
                            Thread.Sleep(30);
                        }



                        if (currentList == null)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            var taskAdd = playlist.Add(newCurrent.Location, string.Format("{0}/{1}", iNew, playlist.LeafsCount), true);

                            while (!taskAdd.Success)
                            {
                                if (writer.Aborted || task.Abort || playlist._abort) return;
                                Thread.Sleep(30);
                            }



                        }
                        else
                        {

                            if (currentAlbum != currentList.Piece.Album && !currentList.Location.Equals(newCurrent.Location))
                                throw new ApplicationException();
                        }

                        iNew++;
                        iThis = iNew;




                    }


                    log.log("fin de lancement liste triée " + (int)((DateTime.Now - debut).TotalMilliseconds) + " ms " + this);


                }

                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }

                //finally
                //{
                //    try
                //    {
                //        bool _break = false;
                //        if (currentPlaying != null)
                //        {

                //            var newCurrent = loader.CurrentTrack;
                //            string location = null;
                //            try
                //            {
                //                location = currentPlaying.Location;
                //                if (location == newCurrent.Location)
                //                    _break = true;
                //            }
                //            catch
                //            {
                //                log.log("track en lecture avant le merge doit etre suprimmé");
                //            }

                //            if (!_break)
                //            {
                //                log.log("retour à l'index " + currentIndex);
                //                var tr = playlist._pl.Tracks.ItemByPlayOrder[currentIndex];
                //                if (tr != null)
                //                {
                //                    tr.Play();
                //                }
                //            }


                //        }
                //    }
                //    catch (Exception ex)
                //    {
                //        log.log(ex.ToString());
                //    }

                //}

            }
        }


        public void mergeListWithOrder(ICollection<IFile> newElements_, IAbortTask writer, IBgTask task)
        {
            new mergeListWithOrderTask(this, newElements_, writer, task).launch();
        }


        //public void mergeList(ICollection<IFile> newElements_, bool withOrder, IAbortTask writer, IBgTask task)
        //{
        //    withOrder = !verifyDoublon;
        //    if (withOrder)
        //        mergeListWithOrder(newElements_, writer, task);
        //    else
        //        mergeList(newElements_, writer);
        //}



        public bool mergeList(ICollection<IFile> newElements_, IAbortTask writer, bool writeOnlyEnabled, bool writeOnlyUnRead)
        {

            if (writer.Aborted || _abort) return true;
            verifyDoublon = true;

            // log.log("mergeList"); 

            string currentAlbum = "----";



            lock (this)
            {


                try
                {
                    if (loader.CurrentPlaylist == this)
                    {
                        if (loader.PlayerState == ITPlayerState.ITPlayerStatePlaying)
                        {
                            var currentPlaying = loader.CurrentTrack;
                            if (currentPlaying != null)
                                currentAlbum = currentPlaying.Album;
                        }
                    }
                }
                catch (Exception ex)
                {
                    log.log("impossible de déterminer la liste courant", ex);
                }
            }

            //    log.log("mergeList::begin"); 

            List<TrackInList> toDeleteRead = new List<TrackInList>();
            List<TrackInList> toDeleteEnabled = new List<TrackInList>();
            List<TrackInList> toDeleteRejet = new List<TrackInList>();
            List<IFile> newElements = null;
            BgDictString<IFile> newElt =new BgDictString<IFile>();
            if (newElements != null)
            {
                newElements = new List<IFile>(newElements_);               
                foreach (IFile elt in newElements_)
                {
                    newElt[elt.Location] = elt;
                }
            }
            //   log.log("mergeList::fin hashtable"); 
            foreach (TrackInList pl in this)
            {
                if (pl.Played && writeOnlyUnRead)
                    toDeleteRead.Add(pl);
                else if (!pl.Enabled && writeOnlyEnabled)
                    toDeleteEnabled.Add(pl);
                else if (newElt[pl.Location] == null)
                {
                    //if ((!conf.AutoPlay || loader.CurrentPlaylist != this) || (conf.DeleteCurrentAlbum || pl.Piece.Album != currentAlbum))
                    toDeleteRejet.Add(pl);
                    //pl.FirstClass = true; 
                }
            }
            // log.log("mergeList::fin determination toDelete"); 
            //foreach (TrackInList pl in this)
            //{
            //    IFile elt = newElements.Find(t => t.Location == pl.Location);
            //    if (elt == null)
            //        toDelete.Add(pl);
            //}


            //Addition
            List<IFile> toAdd = new List<IFile>();
            if (newElements != null)
            {
                foreach (IFile elt in newElements)
                {
                    if (writer.Aborted || _abort) return true;
                    string location = elt.Location;
                    //   bool founded = false;

#if V
             PieceInAList found = dict[location]; 
#else
                    PieceInAList found = loader.getTrackInList(path, location);
#endif

                    if (found == null)
                        toAdd.Add(elt);
                    //foreach (PieceInAList pl in this)
                    //{
                    //    if (pl.Location == location)
                    //    {
                    //        founded = true;
                    //        break;
                    //    }
                    //}

                    //if (!founded)
                    //    toAdd.Add(elt);
                }
            }
            //  log.log("mergeList::fin determination toAdd");

            var toDelete = new List<TrackInList>();
            toDelete.AddRange(toDeleteRead);
            toDelete.AddRange(toDeleteEnabled);
            toDelete.AddRange(toDeleteRejet);

            if (toAdd.Count > 0 || toDelete.Count > 0)
                log.log("{0} add:{1} delete:{2}:read={3} disabled={4} rejet={5}", this, toAdd.Count, toDelete.Count, toDeleteRead.Count, toDeleteEnabled.Count, toDeleteRejet.Count);

            //if (toAdd.Count > 0)
            //    log.log("{0} {1} elt to add", this, toAdd.Count);

            //if (toDelete.Count > 0)
            //    log.log("{0} {1} elt to delete", this, toDelete.Count);




            int count = toAdd.Count;
            for (int i = 0; i < count; i++)

            //foreach (IFile track in toAdd)
            {
                if (writer.Aborted || _abort) return true;
                var e = toAdd[i];
               
                Add(e.Location, string.Format("{0}{1}/{2}", e, i + 1, toAdd.Count), true);

            }

            foreach (TrackInList pl in toDelete)
            {
                if (writer.Aborted || _abort) return true;
                pl.Delete();
            }



            //  log.log("mergeList::fin determination toAdd");
            return true;



        }


        private class AddTrack : BgTaskBase
        {
            private string location;
            //   private string desc;
            private Loader loader;
            private PlayList playlist;
            public AddTrack(string location, string desc, Loader loader, PlayList playlist)
                : base(desc)
            {
                //    this.desc = playlist.path + " "+ location + " " + desc;
                this.loader = loader;
                this.location = location;
                this.playlist = playlist;
            }
            public override void exec()
            {

                if (_abort) return;
                if (playlist.verifyDoublon)
                {

                    if (playlist.Contains(location))
                    {
                        playlist.log.log("vérif 1 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }
                    chrono.bip("v1");

                    if (playlist.LogicalContainsTrackInList(location))
                    {
                        playlist.log.log("vérif 2 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }
                    chrono.bip("v2");


#if V
           //  PieceInAList found = dict[location]; 
#else

                    var found = loader.getTrackInList(playlist.path, location);
#endif

                    if (found != null)
                    {
                        playlist.log.log("vérif 3 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }

                    chrono.bip("v3");

                    var memo = loader.getMemoTrackList(playlist.path, playlist._pl, location);
                    chrono.bip("vm");
                    if (memo != null)
                    {
                        int TrackDatabaseID = -1;
                        string _test = null;
                        try
                        {
                            _test = memo.Track.Location;
                            TrackDatabaseID = memo.Track.TrackDatabaseID;
                        }

                        catch
                        {
                        }
                        if (location == _test)
                        {
                            playlist.log.log("{0} vérif persist :  track déjà ajouté", Desc);
                            success = true;
                            return;
                        }
                        else
                        {
                            loader.removeTrackInList(playlist.path, location, TrackDatabaseID, playlist._pl);
                        }
                        chrono.bip("vm2");
                    }

                }


                IITFileOrCDTrack newTrack = null;
                var sourceTrack = loader.getAnyTrackByLocation(location);

                chrono.bip("fts");

                if (sourceTrack != null)
                {
                    try
                    {

                        if (_abort) return;
                        var st = sourceTrack.Track;
                        if (st is TrackWrapper)
                        {
                            st = (st as TrackWrapper).InnerTrack;
                        }
                        playlist.enter();
                        newTrack = TrackWrapper.create(playlist._pl.AddTrack(st));
                    }
                    catch (Exception ex)
                    {
                        playlist.log.log("{0} Erreur ajout par track {1}", Desc, ex.ToString());
                        loader.invalidationLocation(location);
                    }

                    finally
                    {
                        playlist.release();
                        chrono.bip("Add");

                    }
                }

                if (newTrack == null)
                {
                    try
                    {
                        success = false;
                        if (!conf.PlayListAddFile)
                            return;


                        if (_abort) return;
                        IITOperationStatus status = null;
                        try
                        {
                            playlist.enter();
                            status = playlist._pl.AddFile(location);
                        }

                        finally
                        {
                            playlist.release();
                        }

                        if (status == null)
                        {
                            playlist.log.log("impossible d'ajouter le track par fichier " + location);
                            success = true;
                            return;


                        }
                        while (status.InProgress)
                            Thread.Sleep(30);
                        try { playlist.enter(); newTrack = TrackWrapper.create(status.Tracks[1]); }
                        finally { playlist.release(); } // as IITFileOrCDTrack;
                        playlist.log.log("{0} track ajouté par fichier ", Desc);
                    }
                    catch (Exception ex)
                    {
                        playlist.log.log("{0} Erreur ajout par fichier {1}", Desc, ex.ToString());
                        success = false;
                        return;

                    }

                    finally
                    {
                        chrono.bip("Add2");
                    }


                }


                if (_abort)
                {
                    success = true;
                    return;
                }


                chrono.bip("Add:?");
                var newTrackTrackDatabaseID = newTrack.TrackDatabaseID;
                loader.recordTrackList(playlist.path, newTrack, newTrackTrackDatabaseID, location, true);
                chrono.bip("f1");
                TrackInfoItunes piece = loader.getInfo(newTrackTrackDatabaseID);
                piece.FirstClass = true;
                chrono.bip("f2");
                TrackInList plPiece = new TrackInList(playlist, piece, newTrackTrackDatabaseID);
                chrono.bip("f3");
                loader.LogicalRecordTrackInList(playlist.path, plPiece);


                // new TrackInfoItunes(newTrack);
                //TrackInList t = new TrackInList(  (this, ti, newTrack.TrackDatabaseID);
                plPiece.setTrack(newTrack);
                //if (verifyDoublon)
                playlist.add(plPiece);
                //  playlist.addPiece(piece);

                success = true;

            }



        }
        private bool? isClass;
        private int priority = int.MaxValue;
        public void setPrior(int p) { priority = 0; }
        public int Prior { get { return priority; } }
        // public bool? IsClass { set { isClass = value; } } 
        public override bool isClassSubList()
        {
            if (isClass != null)
                return isClass.Value;

            isClass = base.isClassSubList();
            return isClass.Value;
        }

        public IBgTask Add(string location, string desc, bool async)
        {
            var task = new AddTrack(location, desc, loader, this);
            if (!async)
            {
                task.exec();
                return task;
            }


            if (BackGroundTaskMgr.Ordonnancement)
            {
                if (!isClassSubList())
                {
                    if (_addMgr == null)
                    {
                        lock (_lockP)
                        {
                            if (_addMgr == null)
                            {
                                _addMgr = BackGroundTaskMgr.getMgr("AddTrack " + path, 0);
                            }
                        }
                    }

                    BackGroundTaskMgr.increaseScanPriority(_addMgr, priority);
                    _addMgr.add(task);
                    return task;
                }
                else
                {
                    if (_addMgrClassement == null)
                    {
                        lock (_lockP)
                        {
                            if (_addMgrClassement == null)
                            {
                                _addMgrClassement = BackGroundTaskMgr.getMgr("Classement", 0);
                            }
                        }
                    }
                    _addMgrClassement.addAtFirst(task);
                    return task;
                }
            }
            else
            {
                task.exec();
            }

            return task;

        }


        public override bool add(PlComponent component)
        {
            TrackInList found = null;
            if (verifyDoublon)
            {
                found = loader.getTrackInList(path, component.Location);
                if (found != null)
                {
                    log.log("track déjà ajouté {0} {1}", this, component.Location);
                    loadScanTracks(true, component);
                }
            }

            bool ret = base.add(component);
            if (!ret)
                return ret;

            TrackInList info = component as TrackInList;
            if (info != null)
            {

                if (found == null)
                    loader.recordTrackInList(path, info, verifyDoublon);

            }



            if (info == null)
                return false;

            //     nb++;

#if V
            dict.Add(info.Location, info); 
          //  dict[info.Location] = info; 
#else



#endif


            return ret;


        }

        public void reintegrate()
        {
            foreach (PlComponent t in this)
            {
                if (t is TrackInList)
                    loader.recordTrackInList(path, t as TrackInList, verifyDoublon);
                else if (t is PlayList)
                    (t as PlayList).reintegrate();
            }


        }



        public override bool remove(PlComponent child)
        {
            //    TrackInList track = child as TrackInList;
            //    if (track != null)
            //        track.Delete(); 

            return base.remove(child);
        }




#if VERIF
        public void verif()
        {
            foreach (TrackInList info in this)
            {
                info.verif(); 
            }
        }
#endif
        //private void scanWithoutLimit()
        //{
        //    try
        //    {
        //        _scan(task);
        //    }

        //    catch (Exception e)
        //    {
        //        log.log(e.ToString());
        //    }

        //    task = null;

        //}


        private class TaskScan : BgTaskBase
        {
            private static BgDictString<TaskScan> dict = new BgDictString<TaskScan>();
            private static BgDictString<int> logs = new BgDictString<int>();
            private static volatile object _lock = new object();

            public readonly PlComponent source;
            public static TaskScan create(PlayList playlist, PlComponent source)
            {
                string key = playlist.path;
                if (dict.ContainsKey(key))
                    return null;
                TaskScan task = null;
                lock (_lock)
                {
                    if (dict.ContainsKey(key))
                        return null;
                    task = new TaskScan(playlist, source);
                    dict.Add(key, task);
                    logs[key]++;

                }

                playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                playlist.log.log("creation tâche scan:{0}", key);
                playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                return task;
            }

            public static int logScan(TaskScan task)
            {
                return logs[task.playlist.path];
            }

            private static void remove(TaskScan task)
            {
                dict.Remove(task.playlist.path);
            }


            private TaskScan(PlayList playlist, PlComponent source)
                : base(playlist.path)
            {
                this.playlist = playlist;
                this.source = source;
            }
            private PlayList playlist;
            public override void exec()
            {
                try
                {
                    //if (dict.ContainsKey(playlist.path))
                    //    return;
                    //lock (_lock)
                    //{
                    //    if (dict.ContainsKey(playlist.path))
                    //        return;
                    //    dict.Add(playlist.path, this); 
                    //}
                    playlist._scan(this);

                }
                catch (Exception e)
                {
                    playlist.log.log(e.ToString());

                }

                finally
                {
                    success = true;
                    playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    playlist.log.log("remove tâche scan:{0}", playlist);
                    playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    lock (_lock)
                        dict.Remove(playlist.path);
                }

            }

        }

        public override string ToString()
        {
            return base.ToString() + " " + verifyDoublon;
        }







    }


}
]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using pdb.it.Albums;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        protected static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        protected static IAlbumMgr albumMgr;
        public static IAlbumMgr AlbumMgr { set { albumMgr = value; } get { return albumMgr; } }
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        private TrackPlayListManager listManager = new TrackPlayListManager();
        private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        protected static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);
        protected static BackGroundTaskMgr bgImport = BackGroundTaskMgr.getMgr("Import", 0);
        protected static BackGroundTaskMgr bgHibernate = BackGroundTaskMgr.getMgr("Hibernate", 0);
        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }



        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            albumMgr.setAlbum(this, track.Album);
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;




        }

        public bool Played { get { return this.playCount > 0; } }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present; public bool Present { get { return present; } set { present = value; } }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location": Uri uri = new Uri(value);
                        return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.PlayedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded;


            Fill();
        }



        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0;
            string key = "";
            bool nextIgnore = false;


            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value;
                        break;
                    case "Artist": artist = value; break;
                    case "Album": albumMgr.setAlbum(this, value); break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": PlayedDate = Convert.ToDateTime(value); break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;// Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return TrackTrack;
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        private static BackGroundTaskMgr bgArtist = BackGroundTaskMgr.getMgr("Artist", 0);
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;
                bgArtist.add(new Bgtask(() =>
                {
                    Track.Artist = value;
                    artist = value;
                }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                ));


            }
        }
        protected IAlbum _album;
        public IAlbum TrackAlbum { get { return _album; } set { _album = value; } }
        private static BackGroundTaskMgr bgAlbum = BackGroundTaskMgr.getMgr("Album", 0);
        public virtual string AlbumKey { get { return Album; } }
        public string Album
        {
            get
            {
                return _album.Album;
            }
            set
            {
                if (value == null || value.Equals(_album.Album)) return;
                bgAlbum.add(new Bgtask(() =>
                {
                    // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                    Track.Album = value;
                    albumMgr.setAlbum(this, value);
                }, this,
                "change album from '{0}' to'{1}' {2}", Album, value, this
                ));

            }
        }
        protected string name = "";
        private static BackGroundTaskMgr bgName = BackGroundTaskMgr.getMgr("Name", 0);
        public virtual string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;

                int lengh = 0;
                if (name != null)
                    lengh = name.Length;

                if (value.Length < lengh)
                {
                    log.log("Attention On raccourcit le nom !!! {0}->{1} {2}", name, value, this);
                    // return; 
                }


                var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                bgName.add(bgtaskName);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }

        protected string composer = "";
        private static BackGroundTaskMgr bgComposer = BackGroundTaskMgr.getMgr("Composer", 0);
        public virtual string Composer
        {
            get
            {
                if (present && string.IsNullOrEmpty(composer))
                {
                    var t = Track;
                    if (t != null)
                        composer = t.Composer;
                }
                return composer;
            }
            set
            {
                if (!present)
                {
                    composer = value;
                    return;
                }

                if (value == null || value.Equals(composer)) return;

                var t = Track;
                if (t != null)
                    composer = t.Composer;
                if (value.Equals(composer))
                    return;


                var bgtaskComposer = new BgTaskComposer(this, string.Format("change composer from '{0}' to '{1}' {2}", composer, value, this), value);
                bgComposer.add(bgtaskComposer);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }


        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        private bool firstClass;
        public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        protected static BackGroundTaskMgr bgComment = BackGroundTaskMgr.getMgr("Comment", 0);
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                firstClass = false;
                if (comment != value)
                {
                    try
                    {
                        var tab0 = comment.Split(' ');
                        var tab1 = value.Split(' ');

                        var count0 = tab0.GetLength(0);
                        var count1 = tab1.GetLength(0);

                        if (count0 != count1)
                            firstClass = true;

                        else if (comment.Length > 3)
                        {
                            string org = tab0[count0 - 1];
                            string fin = tab1[count1 - 1];

                            firstClass = !org.Equals(fin);
                        }
                    }

                    catch
                    {
                        firstClass = true;
                    }

                    var sb = new StringBuilder();
                    sb.Append(ClassName);
                    sb.Append(".");
                    sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format("{0} change comment from '{1}' to '{2}' {3}", sb.ToString(), comment, value, this), value);

                    if (firstClass)
                        bgFirstClass.add(task);
                    else
                        bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled = true;
        public bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        private bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        private DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                return playedDate;
            }

            set
            {
                if (playedDate > DateTime.MinValue)
                {
                    var dt = (value - playedDate).TotalHours;
                    if (dt > 2 || dt < -2)
                        playedDate = value;
                    else
                        return;

                }
                playedDate = value;
            }
        }
        protected string location;
        public string Location
        {
            get { return location; }
            set { location = value; }
        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }


        }

        public void setGrouping(string value, bool prior)
        {
            if (!present)
            {
                grouping = value;
                return;
            }
            if (grouping != value)
            {
                bool _delta = false;
                // bool _deltaRank = false; 
                string rankAlbum = "";
                string equivAlbum = "";
                if (value != null)
                {
                    string[] org = grouping.Split(' ');
                    string[] _new = value.Split(' ');

                    int count = org.GetLength(0);
                    if (_new.GetLength(0) != count || count < 3)
                        _delta = true;
                    else
                    {
                        rankAlbum = _new[1];
                        equivAlbum = _new[2];
                        if (!org[1].Equals(_new[1]))
                        {
                            _delta = true;
                        }
                    }
                }

                var sb = new StringBuilder();
                sb.Append(rankAlbum);
                sb.Append(" ");
                sb.Append(equivAlbum);
                sb.Append(" ");
                sb.Append(Album);
                //sb.Append(ClassName);
                //sb.Append(".");
                //sb.Append((Rating / 20).ToString());

                var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

                if (firstClass)
                {
                    bgSeconClass.add(task);
                    return;
                }

                //if (prior)
                //{
                //    bgGroupPrior.add(task);
                //    return;
                //}



                if (_delta)
                {
                    if (prior)
                        bgGroupPrior.add(task);
                    else
                        bgGroup2nd.add(task);
                    return;
                }

                bgg.add(task);

                //if (_delta)
                //    bgGroupDelta.add(task);
                //else
                //{
                //    bgg.add(task);
                //}
                //  grouping = value;
            }
        }



        private int volume;
        private static BackGroundTaskMgr bgVolume = BackGroundTaskMgr.getMgr("Volume", 0);
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgVolume.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        public List<CPlayList> PLayLists
        {
            get { return listManager.PLayLists; }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return listManager.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            listManager.AddPlayList(a_playList);
            // className = listManager.ClassName;
        }

        public void removePlayList(CPlayList list)
        {
            listManager.removePlayList(list);
            // className = listManager.ClassName;
        }


        public string ClassName
        {
            get
            {
                className = listManager.ClassName;
                return className;
            }
            set
            {
                className = listManager.ClassName;
                if (className != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        loader.setClassPlayList(this, className, value);
                        className = value;
                    }, this,
                   "change className from '{0}' to'{1}' {2}", className, value, this));


                    //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
                    //className = value;
                    //OnClassNameChange(value);
                }
            }
        }
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }
        private static BackGroundTaskMgr bgDelete = BackGroundTaskMgr.getMgr("Delete", 10);
        public void Delete()
        {
            if (tracktrack != null)
            {
                log.log("!delete! {0}", this);
                tracktrack.Delete();
            }
            else
                bgDelete.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        protected class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComposer : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComposer(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Composer = value;
                    info.composer = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getLocation()
        {
            return location;
        }

        private DateTime added;
        public virtual DateTime Added
        {
            get { return added; }
            set { added = value; }
        }

    }
}



]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInList.cs">
    <content><![CDATA[using System;
using iTunesLib;
using pdb.obj;
using pdb.util;
using System.Threading;
using pdb.ordo;
using pdb.it.persistance;

namespace pdb.it
{
    public class TrackInList : PieceInAList
    {
        private IITFileOrCDTrack track;
        private PlayList playList;
        //  private int index;
        private int trackDataBaseID;
        private BackGroundTaskMgr backGroundTaskMgr;
        private static BackGroundTaskMgr backGroundTaskMgrClass = BackGroundTaskMgr.getMgr("Classement", 0);
        private BackGroundTaskMgr _scan;

      //  private TrackPersistantId persistentId;

        public TrackInList(ITrackMetaData iTrack, IITFileOrCDTrack track)
            : base(iTrack)
        {
            this.track = track;
            this.trackDataBaseID = track.TrackDatabaseID;

        }


        public TrackInList(PlayList playList, ITrackMetaData iTrack, int trackDataBaseID)
            : base(iTrack)
        {
            this.playList = playList;
            this.trackDataBaseID = trackDataBaseID;
            _scan = playList.ScanMgr;


        }

        private BackGroundTaskMgr getScanMgr()
        {
            if (_scan == null)
            {
                if (playList != null)
                    _scan = playList.ScanMgr;
            }
            return _scan;
        }

        //  public int Index { get { return index; } set { index = value; } }

        public int TrackDataBaseId { get { return trackDataBaseID; } }

#if VERIF
        public void verif()
        {
            playList.getTrack(this);
        }
#endif


        private IITFileOrCDTrack Track
        {
            get
            {
                if (track == null)
                    playList.findTrack(this);
                return track;
            }

        }

        //public void setTrack(IITFileOrCDTrack track, TrackPersistantId persistentId)
        //{
        //    if (track == null)
        //        return;
        //    this.track = track;
        //    this.persistentId = persistentId;
        //}

        //public void setTrack(TrackId track)
        //{
        //    if (track == null)
        //        return;
        //    setTrack(track.Track, track.Id);

        //}

        public void setTrack(IITFileOrCDTrack track)
        {
            if (track == null)
                return;
            this.track = track; 
        }

        public bool TrackIsNull { get { return track == null; } }

     //   public bool FirstClass { get { return Piece.FirstClass; } set { Piece.FirstClass = value; } }

        public IBgTask locate()
        {
            var task = new BgLocate(this);
            BackGroundTaskMgr.checkScanPriority(getScanMgr(), scanPriority.classement);
            backGroundTaskMgrClass.add(task);
            return task;
        }



        public IBgTask delete()
        {
            var task = new BackGroundDelete(this);

            if (playList.isClassSubList())
            {
                BackGroundTaskMgr.checkScanPriority(getScanMgr(), scanPriority.classement);
                backGroundTaskMgrClass.addAtFirst(task);
            }
            else
            {
                BackGroundTaskMgr.checkScanPriority(getScanMgr(), scanPriority.high);
                if (backGroundTaskMgr == null)
                {
                    lock (this)
                    {
                        if (backGroundTaskMgr == null)
                        {
                            if (playList == null)
                                backGroundTaskMgr = BackGroundTaskMgr.getMgr("TrackList", 1);
                            else
                                backGroundTaskMgr = BackGroundTaskMgr.getMgr("TrackList " + playList.getPath(), 1);
                        }
                    }
                }
                if (playList.Prior < int.MaxValue && playList.Prior >= 0)
                    BackGroundTaskMgr.increaseScanPriority(backGroundTaskMgr, playList.Prior);
                backGroundTaskMgr.add(task);
            }

            return task;
        }

        public override void Delete()
        {
            delete();
        }

        private void invalidationTrack()
        {
            playList.invalidationTrack(this);
            track = null;
        }

        public void DeleteSync(IAbortTask writer)
        {
            lock (this)
            {
                DateTime now = DateTime.Now;

                int nb = 0;
                int nb2 = 0;
                // var _track = Track;
                while (Track == null)
                {
                    if (writer.Aborted) return;
                    //if (deleted)
                    //{
                    //    misc.log("DeleteSync verif 1:track déjà supprimé {0} {1} ", playList, this);
                    //    return;
                    //}
                    Thread.Sleep(30);
                    nb++;
                    if (nb == 100)
                    {
                        nb = 0;
                        nb2++;
                        misc.log("attente suppr synchro {0} {1} {2}", nb2, this, playList);
                        if (nb2 > 100)
                        {
                            misc.log("abort attente suppr synchro {0} {1} {2}", nb2, this, playList);
                            return;
                        }
                    }
                }

                misc.log("DeleteSync {0} {1}", (int)((DateTime.Now - now).TotalMilliseconds), this);
                var tr = Track;
                try
                {

                    DeleteBase();
                    removeTrack();
                    //  deleted = true;
                    if (tr == null)
                    {
                        misc.log("DeleteSync : track null {0} {1} ", playList, this);
                        return;
                    }
                    tr.Delete();
                    // misc.log("track supprimé {0} {1} ", track.playList, track);


                }

                catch (Exception e)
                {
                    invalidationTrack();
                    if (!playList.ContainsLeaf(this))
                    {
                        misc.log("DeleteSync verif 2 : track déjà supprimé {0} {1} ", playList, this);
                        return;
                    }
                    misc.log("DeleteSync impossible de supprimer le track de liste " + this + " " + e.Message);

                    // Thread.Sleep(1000 * Try); 
                }
            }


        }


        public void play()
        {
            if (track == null)
            {
                misc.log("impossible de jouer le track {0}, pas trouvé de correspondant", this);
            }
            else
                track.Play();
        }



        public override bool Equals(object obj)
        {
            if (obj is TrackInList)
            {
                TrackInList o = obj as TrackInList;
                return Location.Equals(o.Location);
            }
            else
                return false;
        }

        public override int GetHashCode()
        {
            return Location.GetHashCode(); 
        }

        public void removeTrack()
        {
            playList.removeTrack(this);
        }

        // private bool deleted;

        private class BgLocate : BgTaskBase
        {
            private TrackInList track;
            private IITFileOrCDTrack iTrack;

            public BgLocate(TrackInList track)
                : base(track.ToString())
            {
                this.track = track;
            }

            public override void exec()
            {
                lock (this)
                {
                    iTrack = track.Track;
                    var pl = track.playList;
                    pl.updatePriority(scanPriority.classement);


                    if (iTrack == null)
                    {
                        if (!pl.MaxScan || pl.isClassSubList())
                            return;
                        Loader.ErreurTrackKist = true;
                        iTrack = new NoTrack(track.Piece);
                    }
                    else
                    {
                        success = true;
                        pl.updatePriority(scanPriority.low);
                    }
                }
            }
        }

        private class BackGroundDelete : BgTaskBase
        {
            private TrackInList track;

            public BackGroundDelete(TrackInList track)
                : base(track.ToString())
            {
                this.track = track;

            }

            public override void exec()
            {
                lock (this)
                {
                    if (!track.playList.Contains(track.Location))
                    {
                        track.playList.Log.log("verif 1:track déjà supprimé {0} {1} ", track.playList, track);
                        success = true;
                        return;
                    }

                    if (track.playList.LogicalTrackInListDeleted(track))
                    {
                        track.playList.Log.log("verif 2:track déjà supprimé {0} {1} ", track.playList, track);
                        success = true;
                        return;
                    }


                    chrono.bip("v"); 
                    var _track = track.Track;
                     chrono.bip("tl");
                    var pl = track.playList;
                  
                   
                    // string path = pl.getPath();
                    if (_track == null)
                    {
                        if (!pl.MaxScan || pl.isClassSubList())
                        {
                            pl.updatePriority(scanPriority.high);
                            return;
                        }
                        //    misc.log("NULL {0} {1} ", track.playList, track); 
                        //Thread.Sleep(1000 * Try); 
                        Loader.ErreurTrackKist = true;
                        _track = new NoTrack(track.Piece);
                    }
                    try
                    {

                        track.DeleteBase();
                        chrono.bip("db");
                        track.removeTrack();
                        chrono.bip("rt"); 
                        // track.deleted = true;
                        _track.Delete();
                        chrono.bip("del"); 
                        // misc.log("track supprimé {0} {1} ", track.playList, track);

                        success = true;
                        pl.updatePriority(scanPriority.low);

                        //bool prior = false;

                        //if (track.backGroundTaskMgr != null && track.backGroundTaskMgr.Contains(path))
                        //    prior = true;
                        //else if (TrackInList.backGroundTaskMgrClass.Contains(path))
                        //    prior = true;
                        //pl.checkPriority(prior); 

                    }

                    catch (Exception e)
                    {
                        track.invalidationTrack();
                        //if (!track.playList.ContainsLeaf(track))
                        //{
                        //    misc.log("verif 2 : track déjà supprimé {0} {1} ", track.playList, track);
                        //    //track.DeleteBase();
                        //    //track.removeTrack();
                        //    //success = true;
                        //    //return;
                        //}
                        //else
                        misc.log("impossible de supprimer le track de liste " + track + " " + e.Message);
                        // track.track = null;
                        // Thread.Sleep(1000 * Try); 
                        //  success = true;
                    }
                }
            }


        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\Interfaces.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.obj
{

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }

    /// <summary>
    /// définit chemin d'un fichier
    /// </summary>
    public interface IFile
    {
        String Location { get; }
        string getLocation();
        int PieceId { get; }
    }

    /// <summary>
    /// carte d'identité d'un morceau
    /// </summary>
    public interface ITrackReference
    {
        String Artist { get; set; }
        String Album { get; set; }
        String Name { get; set; }
        int TrackNumber { get; set; }
    }

    // définition non ambigue d'un morceau
    public interface ITrackIdentity : IFile, ITrackReference
    {

        int PieceParentId { get; set; }
        TrackIdentity Key { get; }
    }


    /// <summary>
    /// infos de base du morceau :métafonnées de la piste
    /// </summary> 
    public interface ITrackMetaData : ITrackIdentity
    {

        int Rating { get; set; }
        int Year { get; set; }
     //   String Comment { get; set; }
        bool Enabled { get; set; }
        bool isPodcast { get; }
        DateTime PlayedDate { get; }
        DateTime Added { get; }
        TimeSpan Duration { get; set; }
        bool Played { get; }
      //  string ArtWork { get; set; }
     //   string Grouping { get; }
      //  void setGrouping(string value,bool prior);
       // bool FirstClass { get; set; }
#if VOL
        int Volume { get; set; }
#endif 
    }

    /// <summary>
    /// Supplément d'infos fournies par Db. liste de dates
    /// </summary>
    public interface ITrackPlayedDates
    {
        List<DateTime> Dates { get; }
        List<DateTime> DatesClassement { get; }
        List<DateTime> DatesClassementBrut { get; }
        String ClassEvol { get; }
    }

    /// <summary>
    /// infos max récupérées de iTunes: 
    /// Métadonnées + listes
    /// 
    /// </summary>
    public interface ITrackNative : ITrackMetaData, ITrackPlayListReport
    {
        String ClassName { get; set; }

      //  void registerDependency(ITrackNative local);
     //   void releaseDependency();
    }

    /// <summary>
    /// infos de base + liste de dates
    /// Infos que Db met à dispo
    /// </summary>
    public interface ITrackNativeDates : ITrackNative, ITrackPlayedDates
    {
        void setClassement(string className, int rating);
        List<string> RelativesPath { get; }
        exportState ExportStatus { get; set;}
        
    }

    /// <summary>
    /// Enregistrement des playlists associées au morceau
    /// </summary>
    public interface ITrackPlayListRecorder
    {
        void AddPlayList(CPlayList a_playList);
        void removePlayList(CPlayList list);
    }

    /// <summary>
    /// récupération des infos PlayList du morceau
    /// </summary>
    public interface ITrackPlayListReport
    {
       // List<CPlayList> PLayLists { get; }
        List<CPlayList> ClassPlayLists { get; }
    }

    /// <summary>
    /// abstraction de trackInfoItunes
    /// </summary>
    public interface ITrackInfoItunes : ITrackNative, ITrackPlayListRecorder
    {
       
       
    }

    public class NullTrack : ITrackNative
    {

        #region ITrackNative Members

        public string ClassName
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public void registerDependency(ITrackNative local) { }
       public void releaseDependency() { }

        #endregion

        #region ITrackMetaData Members

        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public int Year
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public string Comment
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        public bool isPodcast
        {
            get { return false; }
        }

        public DateTime PlayedDate
        {
            get { return DateTime.MinValue; }
        }

        public TimeSpan Duration
        {
            get { return new TimeSpan();  }
            set { }
        }

        public string ArtWork
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Grouping
        {
            get
            {
                return "";
            }
            
        }
            
        public void setGrouping(string value, bool prior) { }


        public int Volume { get { return 0; } set { } }

        #endregion

        #region IFile Members

        public string Location
        {
            get { return ""; }
        }

        public string getLocation()
        {
            return "";
        }

        #endregion

        #region ITrackReference Members

        public string Artist
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Album
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Name
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public int TrackNumber
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        #endregion

        #region ITrackPlayListReport Members

        public List<CPlayList> PLayLists
        {
            get { return new List<CPlayList>(); }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return new List<CPlayList>(); }
        }

        #endregion

        public bool FirstClass { get { return false; } set {  } }

        public int PieceId
        {
            get { return -1;  }
        }

        public int PieceParentId
        {
            get { return -1; }
            set { }
        }



        public TrackIdentity Key
        {
            get { return new TrackIdentity(this);  }
        }


        public DateTime Added
        {
            get { return DateTime.MinValue; }
        }


        public bool Played
        {
            get { return false; }
        }
    }





}


]]></content>
  </file>
  <file path="\PieceDb.obj\Metadata.cs">
    <content><![CDATA[using System;
using pdb.obj;

namespace pdb.obj
{
    /// <summary>
    /// Simple conteneur de métadonnées
    /// </summary>
    public class Metadata : ITrackMetaData
    {
        public Metadata()
        {
        }

        public Metadata(string location)
        {
            this.location = location;
        }
        #region ITrackMetaData
        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }
        private int year = -1;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                year = value;
            }
        }

        public string Comment
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public bool isPodcast
        {
            get { return false; }
        }

        public DateTime PlayedDate
        {
            get { return DateTime.MinValue; }
        }

        private TimeSpan duration;
        public TimeSpan Duration
        {
            get
            {
                return duration;
            }
            set
            {
                duration = value;
            }
        }

        public string ArtWork
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Grouping
        {
            get { return ""; }
        }

        public void setGrouping(string value, bool prior)
        {

        }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public int PieceParentId
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public TrackIdentity Key
        {
            get { return null; }
        }
        private string location;
        public string Location
        {
            get { return location; }
        }

        public int PieceId
        {
            get { return -1; }
        }
        private string artist;
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                artist = value;
            }
        }
        private string album;
        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                album = value;
            }
        }
        private string name;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }
        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                trackNumber = value;
            }
        }
        #endregion


        public string getLocation()
        {
            return location; 
        }


        public DateTime Added
        {
            get { return DateTime.MinValue;  }
        }


        public bool Played
        {
            get { throw new NotImplementedException(); }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\PlComponent.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.util;

namespace pdb.obj
{
    public abstract class PlComponent
    {
        private PlayListComposite parent;
        public PlComponent()
        {
        }
        public void setParent(PlayListComposite parent)
        {
            this.parent = parent;
        }
        public PlayListComposite Parent { get { return parent; } }

        public virtual void Delete()
        {
            DeleteBase();
        }

        public void DeleteBase()
        {
            if (parent == null) return;
            parent.remove(this);
            parent = null;

        }

        public override bool Equals(object obj)
        {
            if (obj is PlComponent)
            {
                var o = obj as PlComponent;
                return Location.Equals(o.Location);
            }
            else
                return false;

        }

        public override int GetHashCode()
        {
            return Location.GetHashCode();
        }

        public override abstract string ToString();
        public abstract string Location { get; }
        public virtual string getPath() { return ""; }

        /// <summary>
        /// ID legacy
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
        public virtual int ID
        {
            get { return m_id; }
            set
            {
                if (m_id < 0)
                {
                    m_id = value;
                }
            }
        }

      

    }
    public abstract class PlayListComposite : PlComponent, IEnumerable<PlComponent>
    {
        private String name = "";
        private List<PlComponent> childs = new List<PlComponent>();
        private List<PlComponent> leafs = new List<PlComponent>();
        public PlayListComposite(String name)
        {
            this.name = name;
        }

        public const char SEP = '\\'; 

        protected abstract PlComponent create(object o); 
        public void addObj(object o)
        {
            add(create(o)); 
        }

        public virtual bool add(PlComponent component)
        {
            lock (this)
            {
                childs.Add(component);
                component.setParent(this);
                if (component is PlayListComposite)
                {
                }
                else
                {
                    leafs.Add(component);
                }
                return true;
            }
        }

        public bool HasSubComposites
        {
            get
            {
                return leafs.Count < childs.Count; 
            }
        }

        public List<PlComponent> AllTracks
        {
            get
            {
                var list = new List<PlComponent>();
                buildAllTraks(list);
                return list;
            }
        }

        protected void buildAllTraks(List<PlComponent> container)
        {
            foreach (PlComponent t in this)
            {
                if (t is PlayListComposite)
                    (t as PlayListComposite).buildAllTraks(container); 
                else
                container.Add(t);
            }
          
        }

        public bool Contains(PlComponent pl)
        {
            return childs.Contains(pl);
        }

        public virtual bool Contains(string location)
        {
            if (location == null)
                return false;

            return childs.Exists(p => location.Equals(p.Location));
        }

        public PlComponent Find(Predicate<PlComponent> p)
        {
            return childs.Find(p);
        }

        public int IndexOf(PlComponent leaf)
        {
            return leafs.IndexOf(leaf);
        }

        public bool ContainsLeaf(PlComponent leaf)
        {
            return leafs.Contains(leaf);
        }

        public PlComponent this[int index]
        {
            get
            {
                if (index < 0 || index >= leafs.Count)
                    return null;
                return leafs[index];
            }
        }



        public override string ToString()
        {
            return getPath();          
        }

        public override string getPath()
        {
            if (Parent == null) return name;
            return Parent.getPath() + SEP + name;
        }

        private  PlayListComposite _getFromPath(string[] tab, int index)
        {
            for (; index < tab.GetLength(0); index++)
            {
                string dir = tab[index];
                if (string.IsNullOrEmpty(dir))
                    continue;
                if (dir.Equals(name))
                    continue;
                var sub = getComposite(name);
                if (sub == null)
                    return null;
                return sub._getFromPath(tab, index + 1); 
            }

            return this; 

        }

        public PlayListComposite getFromPath(string path)
        {
            var tab = path.Split(SEP);
            return _getFromPath(tab, 0); 
        }

        public String Name { get { return name; } set { name = value; } }

        public bool isSubList(string a_name)
        {
            if (name == a_name)
                return true;
            if (Parent == null)
                return false;
            return Parent.isSubList(a_name);
        }

        public bool isSubList(PlayListComposite other)
        {
            if (other == this)
                return true;
            if (Parent == null)
                return false;
            return Parent.isSubList(other);
        }

        public virtual void DeleteChilds()
        {
            lock (this)
            {
                try
                {
                    foreach (PlComponent pl in new List<PlComponent>(childs))
                    {
                        var plc = pl as PlayListComposite;
                        if (plc != null)
                        {
                            plc.DeleteChilds();
                        }

                        pl.DeleteBase();

                    }

                    leafs.Clear();
                }
                catch (Exception e)
                {
                    misc.log(e.ToString());
                    throw;
                }
            }

        }
        public int ChildsCount { get { return childs.Count; } }
        public int LeafsCount { get { return leafs.Count; } }
        public List<PlComponent> Leafs { get { return leafs; } }

        public virtual bool remove(PlComponent child)
        {
            leafs.Remove(child);
            return childs.Remove(child);
        }

        public virtual PlayListComposite getComposite(String name)
        {
            foreach (PlComponent item in childs)
            {
                if (item.GetType().IsSubclassOf(typeof(PlayListComposite)))
                {
                    PlayListComposite composite = item as PlayListComposite;
                    if (composite.Name == name)
                        return composite;
                }
            }

            return null;
        }

        public virtual PlayListComposite getComposite(int id)
        {
            foreach (PlComponent item in childs)
            {
                if (item is PlayListComposite)
                {
                    PlayListComposite composite = item as PlayListComposite;
                    if (composite.ID == id)
                        return composite;
                }
            }

            return null;
        }



        public sealed override void Delete()
        {
            DeleteChilds();
            base.Delete();
        }


        public IEnumerator<PlComponent> GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return childs.GetEnumerator();
        }
    }
    public class PieceInAList : PlComponent
    {
        private ITrackMetaData piece;
        public PieceInAList(ITrackMetaData piece)
        {
            if (piece == null)
                throw new ArgumentNullException();
            this.piece = piece; }
        public override string ToString()
        {
            return piece.ToString();
            //var parent = Parent;
            //if (parent == null)
            //    return piece.ToString();

            //return parent.getPath() + " " + piece.ToString();
        }
        public ITrackMetaData Piece { get { return piece; } }

        public bool Played { get { return piece.Played; } }
        public string Name { get { return piece.Name; } }
        public override string Location { get { return piece.Location; } }
        public bool Enabled { get { return piece.Enabled; } }

    }

    public class DefautComponentCreator : IComponentFactor
    {
        public PlComponent create(object source)
        {
            return new PieceInAList(source as ITrackMetaData); 
        }
    }
}]]></content>
  </file>
</db>
