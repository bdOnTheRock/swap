<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.podcast\Feeds.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Report;

namespace pdb.podcast
{
    /// <summary>
    /// ensemble des albums de podcast
    /// </summary>
    public class Feeds : IEnumerable<Feed>
    {
        private Dictionary<string, Feed> dict = new Dictionary<string, Feed>();
        private IDictionary<string, TrackInfoItunes> loaded = new BgDictString0<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        // private SequentialDictString<TrackInfoItunes> preSelected = new SequentialDictString<TrackInfoItunes>();
        private Stat stat = new Stat();

        private bool ignoretrackDisabled = true;
        private bool ignoreTrackRead = true;
        private bool checkExist = true;
        public Feeds()
        {
            ignoretrackDisabled = Conf.OnlyEnabled;
            ignoreTrackRead = Conf.OnlyUnRead;
            checkExist = Conf.CheckExist;

        }
        private static Feeds _instance = new Feeds();

        //public static Feeds Instance { get { return _instance; } }
        //public static Feeds createInstance()
        //{
        //    _instance = new Feeds();          
        //    return _instance;
        //}
        public IDictionary<string, TrackInfoItunes> LoadedTracks { get { return loaded; } }
        public void check(TrackInfoItunes track)
        {

            if (!track.Enabled && ignoretrackDisabled) return;
            if (track.Played && ignoreTrackRead) return;
            if (checkExist && !FileRegister.Exist(track.Location)) return;
            checkAll(track);
        }

        public void check(string album)
        {
            string key = album;
            if (!dict.ContainsKey(key))
            {
                Feed feed = new Feed(key);
                dict.Add(key, feed);
            }

        }

        public bool checkAll(TrackInfoItunes track)
        {

           // string album = track.Album;
            //  string _feed = track.Feed;

            string key = track.AlbumKey;
            //if (!string.IsNullOrEmpty(_feed))
            //    key = _feed;
            if (string.IsNullOrEmpty(key))
            {
                misc.log("pas d'album pour " + track);
                return false;
            }

            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return false;

            if (loaded.ContainsKey(location))
                return false;

            stat.recordTrack(track);

            loaded.Add(location, track);

            if (!dict.ContainsKey(key))
            {
                Feed feed = new Feed(key);
                dict.Add(key, feed);
            }
            return dict[key].check(track);
        }
        private List<TrackInfoItunes> _loaded;
        public List<TrackInfoItunes> Loaded
        {
            get
            {
                if (_loaded == null)
                    _loaded = new List<TrackInfoItunes>(loaded.Values);
                return _loaded;
            }
        }
        public Stat Stat { get { return stat; } }
        public List<Feed> List { get { return new List<Feed>(dict.Values); } }
        //public List<TrackInfoItunes> ListTracks {
        //    get
        //    {
        //        var list = new List<TrackInfoItunes>(dict.Count);
        //        foreach (var feed in dict.Values)
        //        {
        //            list.AddRange(feed.TracksForMulti); 
        //        }
        //        list.Sort(new PodCastComparerInv()); 
        //        return list; 
        //    }

        //}

        //public List<TrackInfoItunes> ListTrackSingle
        //{
        //    get
        //    {
        //        var list = new List<TrackInfoItunes>(dict.Count);
        //        foreach (var feed in dict.Values)
        //        {
        //            list.Add(feed.Track);
        //        }
        //        list.Sort(new PodCastComparerInv()); 
        //        return list;
        //    }

        //}

        //public List<TrackInfoItunes> getLastTracks(int levelMin, int duration, bool? info, bool? rare, int nbMaxByFeed)
        //{
        //    return getTracks(levelMin, duration, info, rare, nbMaxByFeed, false); 
        //    //TimeSpan currentDuration = new TimeSpan();
        //    //var DurationMax = TimeSpan.FromMinutes(duration); 
        //    //int ratingMin = levelMin*20; 
        //    //var aux = new List<TrackInfoItunes>();
        //    //foreach (var feed in dict.Values)
        //    //{
        //    //   aux.AddRange(feed.getLastTracks(nbMaxByFeed,levelMin)); 
        //    //}
        //    //aux.Sort(new PodCastComparerInv());

        //    //var list = new List<TrackInfoItunes>();


        //    //foreach (TrackInfoItunes candidat in aux)
        //    //{
        //    //    if (candidat.Rating < ratingMin) continue;
        //    //    if (info.HasValue)
        //    //    {
        //    //        bool bInfo = info.Value;
        //    //        if (candidat.Info != bInfo) continue; 
        //    //    }

        //    //    if (rare.HasValue)
        //    //    {
        //    //        bool bRare = rare.Value;
        //    //        if (candidat.Rare != bRare) continue; 
        //    //    }


        //    //    if (currentDuration + candidat.Duration > DurationMax)
        //    //        continue;
        //    //    currentDuration += candidat.Duration;
        //    //    list.Add(candidat);
        //    //    candidat.Selected = true; 

        //    //}

        //    //return list; 
        //}


        //public List<TrackInfoItunes> getTracks(Limit limit, DirConf dir, DescBuilder sbDir)
        //{
        //    var aux = new List<TrackInfoItunes>();

        //    foreach (LimitItem item in limit.Items)
        //    {
        //        aux.AddRange(getTracks(item, dir, sbDir)); 
        //    }
        //    return aux; 

        // //   TimeSpan currentDuration = new TimeSpan();
        // // //  int duration = limit.Duration;
        // //   var DurationMax = TimeSpan.FromMinutes(duration);
        // //   int levelMin = limit.Level;
        // //   int ratingMin = levelMin * 20;


        // //   string feedName = null;
        // //   bool histo = dir.Histo;
        // //   bool? histoAll = dir.HistoAll; 
        // //   if (histo)
        // //       feedName = dir.Name;

        // //   if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
        // //       return aux; 

        // //   foreach (var feed in dict.Values)
        // //   {
        // //       if (true.Equals(histoAll) || !histo || (histo && false.Equals(histoAll) && feed.Name.Equals(feedName)))             
        // //           aux.AddRange(feed.getTracks(limit, dir)); 
        // //   }
        // //   if (histo)
        // //       aux.Sort(new PodCastComparer());
        // //   else
        // //       aux.Sort(new PodCastComparerInv());

        // //   var list = new List<TrackInfoItunes>();

        // //   bool? info = dir.Info;
        // //   bool? rare = dir.Rare;

        // //   bool durationLimitAtteinte = false; 


        // //   foreach (TrackInfoItunes candidat in aux)
        // //   {
        // //       if (candidat.Rating < ratingMin) 
        // //           continue;
        // //       if (info.HasValue)
        // //       {
        // //           bool bInfo = info.Value;
        // //           if (candidat.Info != bInfo)
        // //               continue;
        // //       }

        // //       if (rare.HasValue)
        // //       {
        // //           bool bRare = rare.Value;
        // //           if (candidat.Rare != bRare) 
        // //               continue;
        // //       }


        // //       if (currentDuration + candidat.Duration > DurationMax)
        // //       {
        // //           durationLimitAtteinte = true; 
        // //           continue;
        // //       }
        // //       currentDuration += candidat.Duration;
        // //       list.Add(candidat);
        // //       candidat.Selected = true;

        // //   }
        // //   //limit.Append(dir.ToString()); 
        // //   //limit.Append(" "); 
        // //   if (durationLimitAtteinte)
        // //   {
        // //       limit.Append(">>> ");
        // //       //limit.Append(limit.Duration); 
        // //   }

        // //   limit.Append(list.Count); 
        // //   limit.Append(" elts "); 
        // //   limit.Append(currentDuration.TotalMinutes.ToString("0"));
        // //   limit.Append(" min. ");

        // //   var desc = DescBuilder.create();

        // //   limit.rapport(desc);

        // //   foreach (TrackInfoItunes track in list)
        // //   {
        // //       desc.AppendLine();
        // //       desc.Append(track.Pub.ToShortDateString());
        // //       desc.Append(" ");
        // //       desc.Append(track.Album);
        // //       desc.Append(" ");
        // //       desc.Append(track.Name);
        // //       desc.Append(" ");
        // //       desc.Append(track.Rating / 20);
        // //       desc.Append(" info:");
        // //       desc.Append(track.Info);
        // //       desc.Append(" rare:");
        // //       desc.Append(track.Rare); 
        // //   }

        // //   misc.log(desc.ToString()); 



        // //   //for (int i = 0; i < Limits.NB; i++)
        // //   //{
        // //   //    var listLevel = list.FindAll(t => t.Rating == 20 * i);
        // //   //    if (listLevel.Count == 0)
        // //   //        continue;
        // //   //    var contributeurLevel = new Contributeur();
        // //   //    var sb = sbDir.createChild("level " + i); 
        // //   //    contributeurLevel.recordList(null, listLevel);
        // //   //    //sb.AppendLine(); 
        // //   //    //sb.Append("\t"); sb.Append("\t");
        // //   //    //sb.Append("level ");
        // //   //    //sb.Append(i);
        // //   //    //sb.Append(":");
        // //   //    contributeurLevel.rapport(sb);
        // //   //    limit.Append(sb.ToString()); 

        // //   //}


        // //  // misc.log("getTracks {0} {1} ==> {2} {3}", dir, limit, list.Count, currentDuration.TotalMinutes.ToString("0"));

        // ////   misc.log("getTracks levelMin:{0}, duration:{1}, feedDuration:{2}, nbMaxByFeed:{3}, info:{4}, rare:{5}, feedName:{6} ==> {7} {8}", levelMin, duration, feedDuration, nbMaxByFeed, info, rare, feedName, list.Count, currentDuration.TotalMinutes.ToString("0"));

        // //   return list;
        //}


        //public void getTracks(LimitItem limit, DirConf dir)
        //{
        //    TimeSpan currentDuration = new TimeSpan();
        //    int duration = limit.Duration;
        //    var DurationMax = TimeSpan.FromMinutes(duration);
        //    int levelMin = limit.Level;
        //    int ratingMin = levelMin * 20;

        //    var aux = new List<TrackInfoItunes>();

        //    string feedName = null;
        //    bool histo = dir.Histo;
        //    bool? histoAll = dir.HistoAll;
        //    if (histo)
        //        feedName = dir.Name;

        //    var logList = new List<TrackInfoItunes>();

        //    if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
        //        return;


        //    foreach (var feed in dict.Values)
        //    {
        //        if (true.Equals(histoAll) || !histo || (histo && false.Equals(histoAll) && feed.Name.Equals(feedName)))
        //            feed.getTracks(limit, dir);
        //    }
        //    if (histo)
        //        aux.Sort(new PodCastComparer());
        //    else
        //        aux.Sort(new PodCastComparerInv());



        //    bool? info = dir.Info;
        //    bool? rare = dir.Rare;

        //    bool durationLimitAtteinte = false;


        //    foreach (TrackInfoItunes candidat in aux)
        //    {
        //        if (candidat.Rating < ratingMin)
        //            continue;
        //        if (info.HasValue)
        //        {
        //            bool bInfo = info.Value;
        //            if (candidat.Info != bInfo)
        //                continue;
        //        }

        //        if (rare.HasValue)
        //        {
        //            bool bRare = rare.Value;
        //            if (candidat.Rare != bRare)
        //                continue;
        //        }


        //        if (currentDuration + candidat.Duration > DurationMax)
        //        {
        //            durationLimitAtteinte = true;
        //            continue;
        //        }
        //        currentDuration += candidat.Duration;
        //        //if (!dir.List.Contains(candidat))
        //        //{
        //        //    dir.List.Add(candidat);

        //        //}

        //        if (!logList.Contains(candidat))
        //            logList.Add(candidat);
        //        candidat.Selected = true;

        //    }
        //    //limit.Append(dir.ToString()); 
        //    //limit.Append(" "); 
        //    limit.DurationLimitAtteinte = durationLimitAtteinte;
        //    //if (durationLimitAtteinte)
        //    //{
        //    //    limit.Append(">>> ");
        //    //    //limit.Append(limit.Duration); 
        //    //}
        //    //limit.Elt = list.Count;
        //    //limit.DurationFact = currentDuration; 
        //    //limit.Append(list.Count);
        //    //limit.Append(" elts ");
        //    //limit.Append(currentDuration.TotalMinutes.ToString("0"));
        //    //limit.Append(" min. ");
        //    // limit.buildValues(); 

        //    var desc = DescBuilder.create();


        //    //limit.recordList(null, dir.List);
        //    limit.rapport(desc);



        //    foreach (TrackInfoItunes track in logList)
        //    {
        //        desc.AppendLine();
        //        desc.Append(track.Pub.ToShortDateString());
        //        desc.Append(" ");
        //        desc.Append(track.Album);
        //        desc.Append(" ");
        //        desc.Append(track.Name);
        //        desc.Append(" ");
        //        desc.Append(track.Rating / 20);
        //        if (track.Info)
        //            desc.Append(" info ");
        //        // desc.Append(track.Info);
        //        if (track.Rare)
        //            desc.Append(" rare");
        //        // desc.Append(track.Rare);
        //    }

        //    misc.log(desc.ToString());



        //    //for (int i = 0; i < Limits.NB; i++)
        //    //{
        //    //    var listLevel = list.FindAll(t => t.Rating == 20 * i);
        //    //    if (listLevel.Count == 0)
        //    //        continue;
        //    //    var contributeurLevel = new Contributeur();
        //    //    var sb = sbDir.createChild("level " + i); 
        //    //    contributeurLevel.recordList(null, listLevel);
        //    //    //sb.AppendLine(); 
        //    //    //sb.Append("\t"); sb.Append("\t");
        //    //    //sb.Append("level ");
        //    //    //sb.Append(i);
        //    //    //sb.Append(":");
        //    //    contributeurLevel.rapport(sb);
        //    //    limit.Append(sb.ToString()); 

        //    //}


        //    // misc.log("getTracks {0} {1} ==> {2} {3}", dir, limit, list.Count, currentDuration.TotalMinutes.ToString("0"));

        //    //   misc.log("getTracks levelMin:{0}, duration:{1}, feedDuration:{2}, nbMaxByFeed:{3}, info:{4}, rare:{5}, feedName:{6} ==> {7} {8}", levelMin, duration, feedDuration, nbMaxByFeed, info, rare, feedName, list.Count, currentDuration.TotalMinutes.ToString("0"));

        //    return; // logList;

        //}

        Dict<string, TrackInfoItunes> tracks = new Dict<string, TrackInfoItunes>();

        public void recordTrack(TrackInfoItunes track, LimitItem provider)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location)) return;

            if (!selected.ContainsKey(location))
                selected.Add(location, track);
            if (tracks.ContainsKey(location)) return;
            tracks[location] = track;

            Feed feed = dict[track.AlbumKey];
            feed.recordTrack(track, provider);
        }

        //public void recordPreselectedTrack(TrackInfoItunes track, LimitItem provider)
        //{
        //    string location = track.Location;
        //    if (string.IsNullOrEmpty(location)) return;

        //    if (!preSelected.ContainsKey(location))
        //        preSelected.Add(location, track);
        //}

        private void rapportSelected(ITextWriter sb, string name, IEnumerable<LimitItem> providers)
        {
            sb.AppendLine(name);
            foreach (LimitItem provider in providers)
            {
                sb.Append("\t");
                //sb.Append(provider.Dir.getPath());
                //sb.Append(" ");
                sb.AppendLine(provider.ToString());
            }
            sb.AppendLine();
        }


        public List<TrackInfoItunes> getSelectedTracks()
        {
            return new List<TrackInfoItunes>(selected.Values);
        }

        public bool existSelected(string location)
        {
            return selected.ContainsKey(location);
        }


        public void rapportSelected(ITextWriter sb)
        {
            foreach (TrackInfoItunes track in selected.Values)
            {
                sb.AppendLine();
                sb.AppendLine("==================================");
                sb.AppendLine(track.ToString());
                // sb.AppendLine("==================================");

                //rapportSelected(sb, "phase 1", track.Providers1);
                //// rapportSelected(sb, "guests", track.ProvidersGuest);
                //// rapportSelected(sb, "recursif", track.ProvidersRecursif);
                rapportSelected(sb, "selected", track.Providers);
                sb.AppendLine();

            }
        }

        //public void rapportPreSelected(ITextWriter sb)
        //{
        //    foreach (TrackInfoItunes track in preSelected.Values)
        //    {
        //        sb.AppendLine();
        //        sb.AppendLine("==================================");
        //        sb.AppendLine(track.ToString());
        //        // sb.AppendLine("==================================");

        //        //rapportSelected(sb, "phase 1", track.Providers1);
        //        ////  rapportSelected(sb, "guests", track.ProvidersGuest);
        //        //// rapportSelected(sb, "recursif", track.ProvidersRecursif);
        //        //rapportSelected(sb, "selected", track.Providers);
        //        sb.AppendLine();

        //    }
        //}

        public void rapport(ITextWriter sb)
        {
            sb.AppendLine("==================================");
            sb.AppendLine("Feeds");
            sb.AppendLine("==================================");
            foreach (Feed feed in dict.Values)
            {
                feed.rapport(sb);
            }
        }

        //public List<TrackInfoItunes> getTracks(int levelMin, float duration, float feedDuration, bool? info, bool? rare, int nbMaxByFeed, string feedName)
        //{
        //    TimeSpan currentDuration = new TimeSpan();
        //    var DurationMax = TimeSpan.FromMinutes(duration);
        //    int ratingMin = levelMin * 20;
        //    var aux = new List<TrackInfoItunes>();
        //    bool histo = feedName != null;
        //    foreach (var feed in dict.Values)
        //    {
        //        if (feed.Name.Equals(feedName) || !histo)
        //            aux.AddRange(feed.getTracks(levelMin, nbMaxByFeed, feedDuration, histo));
        //    }
        //    if (histo)
        //        aux.Sort(new PodCastComparer());
        //    else
        //        aux.Sort(new PodCastComparerInv());

        //    var list = new List<TrackInfoItunes>();


        //    foreach (TrackInfoItunes candidat in aux)
        //    {
        //        if (candidat.Rating < ratingMin) continue;
        //        if (info.HasValue)
        //        {
        //            bool bInfo = info.Value;
        //            if (candidat.Info != bInfo) continue;
        //        }

        //        if (rare.HasValue)
        //        {
        //            bool bRare = rare.Value;
        //            if (candidat.Rare != bRare) continue;
        //        }


        //        if (currentDuration + candidat.Duration > DurationMax)
        //            continue;
        //        currentDuration += candidat.Duration;
        //        list.Add(candidat);

        //        //if (!candidat.Selected)
        //        //    candidat.SelectMode = selectMode.simple; 
        //        //candidat.Selected = true;

        //    }

        //    misc.log("getTracks levelMin:{0}, duration:{1}, feedDuration:{2}, nbMaxByFeed:{3}, info:{4}, rare:{5}, feedName:{6} ==> {7} {8}", levelMin, duration, feedDuration, nbMaxByFeed, info, rare, feedName, list.Count, currentDuration.TotalMinutes.ToString("0"));

        //    return list;
        //}

        public List<TrackInfoItunes> getSingleSelectedTracks(int levelMin)
        {
            List<TrackInfoItunes> list = new List<TrackInfoItunes>();
            int ratingMin = levelMin * 20;
            foreach (var feed in dict.Values)
            {
                var listFeed = feed.getSelectedTracks;
                listFeed.Sort(new PodCastComparerInv());
                foreach (var track in listFeed)
                {
                    if (track.Rating >= ratingMin)
                    {
                        list.Add(track);
                        break;
                    }
                }

            }
            list.Sort(new PodCastComparerInv());
            return list;
        }


        //public void getSingleSelectedTracks(List<TrackInfoItunes> depot)
        //{
        //    foreach (var feed in dict.Values)
        //    {
        //        feed.buildLastSelectedTrack(depot);
        //    }

        //}

        public void getFirstSelectedTracks(List<TrackInfoItunes> depot, SelectParam param)
        {
            foreach (var feed in dict.Values)
            {
                feed.buildFirstSelectedTrack(depot, param);
            }

        }

        public void buildFirstSelectedTrackLevel(List<TrackInfoItunes> depot, SelectParam param)
        {
            foreach (var feed in dict.Values)
            {
                feed.buildFirstSelectedTrackLevel(depot, param);
            }


            if (param.dateCroissante)
                depot.Sort(new PodCastComparerPub2());
            else
                depot.Sort(new PodCastComparerInv());
        }

        internal List<TrackInfoItunes> buildJournal(Journal journal)
        {
            var depot = new List<TrackInfoItunes>();
            foreach (var feed in dict.Values)
            {
                feed.getSelecTrackJournal(depot, journal);
            }
            depot.Sort(new PodCastComparer());

            TimeSpan totalDurationMax = TimeSpan.FromMinutes(journal.Duration);
            TimeSpan duration = new TimeSpan();
            var list = new List<TrackInfoItunes>();

            foreach (TrackInfoItunes track in depot)
            {
                list.Add(track);
                track.markInJournal();
                duration += track.Duration;
                if (duration > totalDurationMax)
                    break;
            }
            return list;
        }




        public IEnumerator<Feed> GetEnumerator()
        {
            return dict.Values.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return dict.Values.GetEnumerator();
        }

        public Feed this[string album] { get { return dict[album]; } }
        // public List<TrackInfoItunes> PreSel { get { return new List<TrackInfoItunes>(preSelected); } }
    }





}
]]></content>
  </file>
  <file path="\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.iit;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Albums;
using pdb.podcast.Auto;
using pdb.podcast.Delta;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Sort;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static ILoader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto;
        static int step = -1;
        static Program _instance = new Program();
       // static bool calculRoots = false;
        static List<HashSet<int>> lists = null;
        static AlbumMgr albumMgr = AlbumMgr.Instance; 

        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        private static Chrono chrono = new Chrono();
        private static Logger logChrono;
        private static DB.Db db;

        //public static DB.Db Db { get { return db; } }


        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {

            Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono", true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true;

            FileRegister.init(new BgDictString0<FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true;

                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                Console.WriteLine("\nFin de l'opération d'enregistrement.");
                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Memory.End();
                Exporter.Abort();

                //if (_writeDb != null)
                //{
                //    misc.log("attente writeDb");
                //    _writeDb.Wait();
                //}
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                if (db != null)
                    db.write();
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}

        #region Task


        private List<ITrackInfoItunes> loadTracks(bool firstStep, bool forceLoad)
        {
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
            loader.loadTracks(firstStep, forceLoad, listTrack);

            return listTrack;

        }
        #endregion

        public void go(string[] args)
        {
            TrackInfoItunes.AlbumMgr = albumMgr; 
            int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            if (countArgs > 0)
                confFile = args[0];
            bool _fin = false;
            Album.log = Logger.getLogger("pub2", true);
            Hibernator hibernator = new Hibernator();

            try
            {

                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start(10);

                // bool firstLoad = true;


                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                TrackInfoItunes.setDate0(Conf.Date0);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                TrackInfoItunes.PlayedLevel = Conf.DateLevel;
                var itConf = new pdb.it.Conf(xelt);

                // loader = new Loader(itConf, true);
                bool import = Conf.Import.enabled || Conf.Import.merge;
                db = new DB.Db();


                if (Conf.UseMock)
                    loader = new MockLoader(itConf.DefaultFolder);
                else
                    loader = new Loader(itConf, import, db,
                        () =>
                        {
                            misc.Pre = "[Load " + step + "] ";

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.AbortSpecial();
                            //   Thread.Sleep(1000); 
                            //  BackGroundTaskMgr.Start(); 
                        })

                   ;
                // loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder;

                db.load();
                //  db.write(); return; 

                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();

                List<TrackInfoItunes> listIt = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);
                bool firstlaunched = false;
                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}"));
                        chrono.reset("Program");

                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.setConf(xelt);
                        //loader.Conf = new it.Conf(xelt);
                        // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut");

                        if (step == 0 || !Conf.Simulation)
                        {
                            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();


                            listTrack = loadTracks(step == 0, AutoBuilder.MustUpdate);
                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();

                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            // listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {

                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                // loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            //    loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            listIt = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            GroupStat trackStat = new GroupStat();

                            loader.saveIds();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    dictLoc[t.Location] = t;
                                    listIt.Add(t);
                                    if (!t.Played)
                                        trackStat.recordTrack(t, typeState.all);
                                    trackStat.recordTrack(t, typeState.all);
                                }
                            }

                            db.recordIt(listIt);
                            chrono.bip("loadTracks");

                            
                            // ici on peut faire la verification des doublons - track hibernés et re-téléchargés par ce con d'itunes
                            var albumConsolid = new AlbumConsolid(); 
                            foreach (TrackAlbum album in albumMgr.List)
                            {
                                albumConsolid.consolid(album); 
                            }

                            log.log("nb123={0} nb12={1} nb13={2} nb23={3} nb1={4} nb2={5} nb3={6} nb0={7}, nb3n={8}",
                                AlbumConsolid.nb123, AlbumConsolid.nb12, AlbumConsolid.nb13, AlbumConsolid.nb23,
                                AlbumConsolid.nb1, AlbumConsolid.nb2, AlbumConsolid.nb3, AlbumConsolid.nb0, AlbumConsolid.nb3n); 

                            if (Conf.Import.enabled)
                            {
                                var listImport = new List<TrackInfoItunes>();
                                hibernator.select(Conf.Import, listImport, db.Tracks, true);

                                foreach (TrackInfoItunes tdb in listImport)
                                {
                                    loader.import(tdb);
                                }
                            }
                            else if (Conf.Import.merge)
                            {
                                foreach (TrackInfoItunes t in listIt)
                                    loader.merge(t);
                            }


                            if (Conf.Sort.checkBefore)
                            {
                                var sorter = new Sorter(Conf.Sort, listIt);
                                sorter.build();
                                int iii = 0;
                                //while (!BackGroundTaskMgr.ConfirmEnd(10))
                                //{
                                //    iii++;
                                //    if (iii == 60)
                                //        iii = 0;
                                //    if (iii == 0)
                                //    {
                                //        log.log("Attente Classement");
                                //    }
                                //    Thread.Sleep(100);
                                //}


                                if (Album.NbRepeches > 0)
                                {
                                    log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                    _fin = true;
                                }
                            }





                            if (Conf.Import.enabled || Conf.Import.merge)
                            {
                                _fin = true;

                            }

                            db.write();


                            if (_fin)
                            {
                                log.log("fin");
                                return;
                            }

                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            trackStat.report(descTrack);
                            log.log(descTrack.ToString());

                            var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            var trackFile = DescBuilder.create("Tracks", sbT);
                            trackStat.report(trackFile);
                            sbT.Flush();

                            asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            chrono.bip("desc tracks");
                            Logger.LogConsole = false;
                            //        loader.loadLists();
                            Logger.LogConsole = true;
                            chrono.bip("load list");

                        }
                        List<TrackInfoItunes> list2 = new List<TrackInfoItunes>();
                        DirConf root = null;
                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program");

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            var list = db.Tracks;
                            list2 = new List<TrackInfoItunes>(list.Count);
                            foreach (TrackInfoItunes track in list)
                            {
                                var copy = TrackInfoItunes.createCopy(track);
                                track.clearLists();
                                list2.Add(copy);
                                //track.clearLists(); // = selectMode.none;
                            }
                            chrono.bip("track.clearLists");
                            // Feeds.createInstance();
                            root = Conf.DirConf;
                            var feeds = root.Feeds;
                            if (Conf.GenFeed)
                            {
                                foreach (RootItItem rootItem in Conf.RootIt)
                                {
                                    var fAuto = loader.TreePlayList.getComposite(rootItem.name);
                                    var fFeeds = fAuto.getComposite("Feed");

                                    if (fFeeds != null)
                                    {
                                        scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                    }

                                }
                            }

                            foreach (TrackInfoItunes track in list2)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds");

                            //if (Conf.Single)
                            //{
                            //    var listS = new List<TrackInfoItunes>();
                            //    for (int i = 0; i < Limits.NB; i++)
                            //    {
                            //        var list0 = feeds.getTracks(i, int.MaxValue, int.MaxValue, null, null, 1, null); //feeds.ListTrackSingle;
                            //        foreach (var t in list0)
                            //        {
                            //            if (!listS.Contains(t))
                            //                listS.Add(t);
                            //        }

                            //    }

                            //    string[] folder = new string[] { "Select", "tmp" };
                            //    buildList("_auto", listS, 0, folder);
                            //}

                            //var sb = DescBuilder.create();

                            //Création des listes
                            //  oldRoot = root;

                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true;
                            AutoBuilder.init(true);
                            loadCandidat(root);

                            //  AutoBuilder.test(); 
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            //**********************************************************************************
                            Album.Init();
                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.histo|| Conf.Sort.enabled == Tuning.Sort.sortMode.reset || Conf.Sort.enabled == Tuning.Sort.sortMode.once || (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all && !firstlaunched))
                            {
                                var sorter = new Sorter(Conf.Sort, list2);
                                sorter.build();
                                _fin = Conf.Sort.enabled == Tuning.Sort.sortMode.histo || Conf.Sort.enabled == Tuning.Sort.sortMode.once || Conf.Sort.enabled == Tuning.Sort.sortMode.reset;
                            }

                            firstlaunched = true;

                            if (Album.NbRepeches > 0)
                            {
                                log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                _fin = true;
                            }



                            if (!_fin) // && Album.NbModif == 0)
                            {

                                //***************** Lancement "pour de faux" ***************************************
                                AutoBuilder.Init3();
                                LimitItemLoader.ModeSelection = false;
                                phase2(root);
                                Selection(root);
                                LimitItemLoader.ModeSelection = true;
                                //**********************************************************************************
                            }
                            Exporter.TopCopy();
                            chrono.bip("selection");




                            Conf.date00Consume();
                            TrackInfoItunes.setDate0(Conf.Date0);

                            int iii = 0;
                            while (!BackGroundTaskMgr.ConfirmEnd(10))
                            {
                                iii++;
                                if (iii == 60)
                                    iii = 0;
                                if (iii == 0)
                                {
                                    log.log("Attente Classement");
                                }
                                Thread.Sleep(100);
                            }






                            if (_fin || Album.NbModif > 0)
                            {
                                log.log("{0} éléments ont la Pub2 modifiée", Album.NbModif);
                                foreach (TrackInfoItunes t in list2)
                                {
                                    var tdb = db.get(t);
                                    if (tdb == null)
                                    {
                                        log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                        continue;
                                    }
                                    tdb.synch(t);

                                }

                                db.write();

                                if (_fin)
                                {
                                    log.log("fin");
                                    return;
                                }
                               // continue;
                            }




                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    if (count == 1)
                                        s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu");


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root);
                            //****************************************



                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                            //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            bool cangoAuto = AutoBuilder.Check(feeds);
                            chrono.bip("AutoBuilder");
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");



                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false;
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true;
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                //  tw = new StringBuilder();
                                //feeds.rapportPreSelected(tw);
                                //asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false;
                                log.log(sb2.ToString());
                                Logger.LogConsole = true;


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false;
                                log.log(sb3.ToString());
                                Logger.LogConsole = true;
                                chrono.bip("rapport");
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 


                        Logger.CreateNullLoggers = false;


                        lists = null;
                        WritePlayList(root);




                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;
                            //foreach (SelectParam p in listP)
                            //{
                            //    if (p.etendue.Contains("s"))
                            //    {
                            //        listS = new List<TrackInfoItunes>();
                            //        folder = new string[] { "select", "tmp", p.name };
                            //        feeds.getFirstSelectedTracks(listS, p);
                            //        buildList("_select", listS, prior, folder);
                            //    }
                            //}

                            //for (int level = 0; level < Limits.NB; level++)
                            //{
                            Dictionary<string, Dictionary<int, TrackInfoItunes>> depots = new Dictionary<string, Dictionary<int, TrackInfoItunes>>(); 
                            foreach (SelectParam p in listP)
                            {
                                //if (p.etendue.Contains(level.ToString()))
                                //{
                                // p.level = level;
                                listS = new List<TrackInfoItunes>();
                                if (!string.IsNullOrEmpty(p.name))
                                {
                                    // Compatibilité anciennes listes
                                    folder = new string[] { "select", "tmp", p.name };                                   
                                    feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                    buildList("_" + p.level, listS, prior, folder);
                                }
                                else
                                {                                   

                                 
                                    feeds.buildFirstSelectedTrackLevel(listS, p);

                                    var l = new List<TrackInfoItunes>();
                                    var pp = p.Clone() as SelectParam;
                                    pp.nb = int.MaxValue;
                                    var selector = new TrackSelector(pp);
                                    foreach (TrackInfoItunes t in listS)
                                    {
                                        if (selector.select(t))
                                            l.Add(t);
                                    }

                                    string path = p.path; 
                                    if (!string.IsNullOrWhiteSpace(path))
                                        buildList(path, l, prior);

                                    string[] _depots = p.depot;
                                    if (_depots != null)
                                    {
                                        foreach (string depot in _depots)
                                        {
                                            if (!depots.ContainsKey(depot))
                                                depots.Add(depot, new Dictionary<int, TrackInfoItunes>());

                                            var dep = depots[depot];
                                            foreach (TrackInfoItunes t in l)
                                            {
                                                if (!dep.ContainsKey(t.DbId))
                                                    dep.Add(t.DbId, t); 
                                            }
                                        }
                                    }
                                }
                            }

                            foreach (KeyValuePair<string, Dictionary<int, TrackInfoItunes>> kvp in depots)
                            {
                                string path = kvp.Key; 
                                
                                var l = new List<TrackInfoItunes>(kvp.Value.Values);
                                l.Sort(new PodCastComparerPub2());
                                buildList(path, l, prior);
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);

                        foreach (TrackInfoItunes s in root.Feeds.getSelectedTracks())
                        {
                            s.updateNative();
                        }






                        //if (Conf.Hibernate.enabled)
                        //{
                        //    Hibernator hibernator = new Hibernator();
                        //    var nb = hibernator.go(loader); 
                        //    if (nb >0)
                        //    {
                        //        misc.log("{0} elements hibernés", nb);
                        //        misc.log("fin ");
                        //        return; 
                        //    }

                        //}


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                log.log("Attente Classement");
                            }
                            Thread.Sleep(100);
                        }



                        if (Conf.Sort.enabled == Tuning.Sort.sortMode.all)
                        {
                            var sorter = new Sorter(Conf.Sort, list2);
                            sorter.build();

                         
                        }

                        int nbH = 0;
                        _fin = false;
                        if (Conf.Hibernate.enabled)
                        {
                            nbH = hibernator.go(loader, list2);
                            if (nbH > 0)
                            {
                                log.log("{0} elements hibernés", nbH);
                                _fin = true;
                            }
                        }

                        if (loader.NbTrackCreated > 0)
                        {
                            log.log("{0} éléments ont été recréés", loader.NbTrackCreated);
                            _fin = true;
                        }

                        if (Album.NbRepeches > 0)
                        {
                            log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                            _fin = true;
                        }


                        foreach (TrackInfoItunes t in list2)
                        {
                            t.checkInOut();
                            var tdb = db.get(t);
                            if (tdb == null)
                            {
                                log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                continue;
                            }
                            tdb.synch(t);

                        }

                        db.write();

                        if (_fin)
                        {
                          

                            log.log("fin");

                            return;
                        }





                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");



                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in db.Tracks)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogAll(ex.ToString());
                        misc.log(ex.ToString());
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        private DirConf _attenteWriteHtml;
        private volatile object _lockReportHtml = new object();
        private bool _end;
        ThreadUtil thReport;

        private void postReport(DirConf dir)
        {
            if (thReport == null)
            {
                lock (_lockReportHtml)
                {
                    if (thReport == null)
                    {
                        thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
                        thReport.Start();
                    }
                }
            }

            lock (_lockReportHtml)
                _attenteWriteHtml = dir;
        }

        private void loopReportHtml()
        {
            DirConf traite = null;
            while (!_end)
            {
                Thread.Sleep(30);
                if (_attenteWriteHtml == null)
                    continue;
                lock (_lockReportHtml)
                {
                    if (_attenteWriteHtml == null)
                        continue;
                    traite = _attenteWriteHtml;
                    _attenteWriteHtml = null;
                }
                reportHtml(traite);
            }
        }


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
                //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
                //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders,false);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders,false);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders, false);
        }

        public static void buildList(string path, List<TrackInfoItunes> list_, int prior)
        {
            bool absolutePath = path.StartsWith(@"\"); 
            var tab = path.Split('\\');
            int count = tab.GetLength(0);
            var folder = new List<string>();

            foreach (string s in tab)
            {
                if (!string.IsNullOrWhiteSpace(s))
                    folder.Add(s); 
            }

            buildList(list_, prior, folder, absolutePath);
        }



        public static void buildList(List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            var newf = new List<string>(folders);
            int count = newf.Count; 
           
            string name = newf[count-1];
            newf.RemoveAt(count - 1);
            buildList(name, list_, prior, newf, absolutePath); 
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            try
            {
                if (Conf.Simulation)
                    return;
                if (Conf.UseMock)
                {
                    var sb = new StringBuilder();
                    foreach (string f in folders)
                    {
                        sb.Append(f); sb.Append(@"\");
                    }
                    sb.Append(name);
                    log.logNoDate("---------------------------");
                    log.log("liste {0}", sb.ToString());
                    foreach (TrackInfoItunes t in list_)
                    {
                        log.logNoDate(t.ToString());
                    }
                    return;
                }


                foreach (TrackInfoItunes track in list_)
                {
                    loader.reviveIfNecessary(track);

                }


                var rootIt = Conf.RootIt;
                RootItItem currentRoot = rootIt.roots[0];
                int count = rootIt.roots.Count;
                //   log.log("build list {0}",name);
                //  var list = new List<IFile>(list_);
                if (lists==null)
                {
                    lists = new List<HashSet<int>>();
                    foreach (var item in rootIt.roots)
                    {
                        lists.Add(new HashSet<int>()); 
                    }
                    var list__ = new List<TrackInfoItunes>(list_);
                    list__.Sort(new PodCastComparerPub2());



                    int countTrack = list_.Count;

                    long size = 0;
                    int j = 0;
                    int indexRoot = 0;

                //    HashSet<int> current = lists[0]; 

                    while (true)
                    {
                        if (j >= countTrack)
                            break;
                        TrackInfoItunes track = list__[j];
                        size += track.Size;
                        if (size <= currentRoot.size)
                        {
                            lists[indexRoot].Add(track.DbId); 
                           // track.IndexRoot = indexRoot;
                        }
                        else
                        {

                            size = 0;
                          //  size += track.Size;
                            indexRoot++;
                            if (indexRoot >= count)
                                break;
                            currentRoot = rootIt.roots[indexRoot];
                            continue;
                        }
                        j++;
                    }

                }

                for (int r = 0; r < count; r++)
                {
                    currentRoot = rootIt.roots[r];
                    folders = new List<string>(folders);
                    PlayListComposite folder = null;

                    if (absolutePath)
                    {
                        if (r > 0)
                            throw new Exception("un chemin absolu ne peut pas être géré dans une partition");
                       // folders[0] = folders[0].Substring(1);
                        folder = loader.TreePlayList;

                    }
                    else
                        folder = loader.TreePlayList.getComposite(currentRoot.name);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(currentRoot.name);


                    var nname = name;
                    if (name.Contains(Path.DirectorySeparatorChar.ToString()))
                    {
                        var tab = name.Split(Path.DirectorySeparatorChar);
                        string str = null;
                        for (int i = 0; i < tab.GetLength(0); i++)
                        {
                            if (str != null)
                                folders.Add(str);
                            if (!string.IsNullOrEmpty(tab[i]))
                                str = tab[i];
                        }
                        if (!string.IsNullOrEmpty(str))
                            nname = str;
                    }
                  
                    var l = new List<IFile>();
                    foreach (TrackInfoItunes t in list_)
                    {
                        if (lists[r].Contains(t.DbId))
                            l.Add(t); 
                    }

                    for (int i = 0; i < folders.Count; i++)
                    {
                        var aux = folder;
                        folder = folder.getComposite(folders[i]);
                        if (folder == null)
                            folder = loader.getOrCreateFolder(aux, folders[i], l.Count > 0);
                        if (folder == null)
                            return;
                    }

                    //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
                    var playlist = loader.getPlayList(folder, nname, l.Count > 0);
                    if (playlist != null)
                    {
                        if (prior < int.MaxValue && prior >= 0)
                            playlist.setPrior(prior);
                        //if (list.Count > 0)

                        playlist.mergeList(l, false, _instance, null);
                        //  loader.mergeList(playlist, l, false, _instance, null);
                        //else
                        //    loader.removeList(folder, name);
                    }



                    //log.log("clear list {0}", name); 
                    //loader.ClearList(playlist);
                    //log.log("add items {0}", name); 
                    //foreach (TrackInfoItunes track in list)
                    //    loader.addItemToList(playlist, track); 

                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }


        }



        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            DateTime now = DateTime.Now;

            fLoader.Action(pre);
            var ts = (DateTime.Now - now).TotalMilliseconds;
            if (ts > 1 && Conf.LogDir && pre > action.none && pre < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", pre, dir.getPath(), ts.ToString("0"));
            }

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());

            now = DateTime.Now; ts = (DateTime.Now - now).TotalMilliseconds;
            fLoader.Action(post);

            if (ts > 1 && Conf.LogDir && post > action.none && post < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", post, dir.getPath(), (DateTime.Now - now).TotalMilliseconds.ToString("0"));
            }


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                                break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Comment = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.obj;
using pdb.it;
using pdb.podcast.Albums;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        // standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub, ISelectable
    {
        public const string PUB_DATE_FORMAT_COMMENT = "yyyy/MM/dd HH:mm";
        public const string PUB_DATE_FORMAT_DB = "dd/MM/yyyy HH:mm";
        private static Loader loader;
        public new static Loader Loader { set { loader = value; } }

        public new TrackAlbum TrackAlbum { get { return base.TrackAlbum as TrackAlbum; } }

        public override string AlbumKey { get { var alb = TrackAlbum; if (alb == null) return base.AlbumKey; return alb.AlbumKey; } }

        public int AlbumRating { get { return TrackAlbum.AlbumRating; } }
        //  private bool ratingComputed; public bool RatingComputed { get { return ratingComputed; } }

        private void import(IITFileOrCDTrack native)
        {
            misc.log("import {0}", this);
            native.Name = name;

            native.AlbumRating = AlbumRating;
            if (rating != AlbumRating)
                native.Rating = rating;
            native.PlayedDate = this.PlayedDate.ToUniversalTime();
            native.Enabled = this.enabled;
            native.PlayedCount = this.playCount;
            var _comment = buildComment();
            if (!string.IsNullOrEmpty(_comment))
                native.Comment = _comment;
        }

        public string buildComment()
        {
            string comment = pub.ToString(PUB_DATE_FORMAT_COMMENT);
            if (pub2 > pub)
                comment = string.Format("{0}|{1}", Pub2.ToString(PUB_DATE_FORMAT_COMMENT), Pub.ToString(PUB_DATE_FORMAT_COMMENT));
            return comment;
        }

        public void BuildComment()
        {
            var comment = buildComment();
            if (!string.IsNullOrEmpty(comment) && comment != Comment)
                Comment = comment;
        }

        public void import()
        {
            if (!isPresent())
                return;

            try
            {
                var native = TrackTrack;
                if (native == null)
                    native = Track;
                if (native == null)
                {
                    bgClass.add(new BgTaskImport(this));
                }
                else
                    import(native);

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public void merge()
        {
            if (!isPresent())
                return;
            bgClass.add(new BgTaskImport(this));
        }

        public void import(TrackInfoItunes db)
        {
            this._album = db._album;
            // this.albumRating = db.albumRating;
            this.rating = db.rating;
            //this.rare = db.rare;
            //this.info = db.info;
            this.playCount = db.playCount;
            this.PlayedDate = db.PlayedDate;
            this.enabled = db.enabled;
            present = true;
            db.present = true;

            import();
        }

        private DateTime offset;
        public DateTime Offset
        {
            set
            {
                if (offset == DateTime.MinValue)
                    offset = value;
            }
            get { return offset; }
        }

        public override IITFileOrCDTrack Track
        {
            get
            {
                if (track != null)
                    return track;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    // loader.resurrection(this);
                }
                return base.Track;
            }
        }

        public override IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (tracktrack != null)
                    return tracktrack;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    //   loader.resurrection(this);
                }
                return base.TrackTrack;
            }
        }

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        //private static bool _updateNative;
        //public static bool UpdateNative { get { return _updateNative; } set { _updateNative = value; } }
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                    defaultFolder += "Podcasts\\";
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;

        public int DbId { get { return _dbId; } set { if (_dbId <= 0) _dbId = value; } }

        private static int NB = 0;
        private int iddebug;

        public TrackInfoItunes()
        {
            NB++;
            iddebug = NB;
        }

        public bool Deleted { get; set; }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        //  private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        // private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        private LimitItem exclu;
        public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            //var key = item.ID;
            //if (!listLoad0.ContainsKey(key))
            //    listLoad0.Add(key, item);
        }
        //public bool containsload(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listLoad0.ContainsKey(key);
        //}

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        //public bool containsSelect(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listSelected.ContainsKey(key);
        //}
        //public bool isPreselected { get { return listLoad0.Count > 0; } }
        //public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {

                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        public void synch(TrackInfoItunes o)
        {
            _in = o._in;
            _out = o._out;
            pub2 = o.pub2;
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            TrackAlbum.AlbumRating = track.AlbumRating;
            // this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            CheckPlay(this);

            //if (track.PlayedCount > 0)
            //{
            //    played = markAsPlayed(Rating, PlayedDate);
            //}

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Comment != commentByReleaseDate)
                    {
                        misc.log("chgt Comment � partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Comment = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Comment;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Comment)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment à partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Comment = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de gérer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }

        private static DateTime playedLevel = DateTime.MinValue;
        public static DateTime PlayedLevel { set { playedLevel = value; } }
        //public static bool markAsPlayed(int rating, DateTime date)
        //{
        //    if (maxPlayed.ContainsKey(rating))
        //        return date > maxPlayed[rating];
        //    return true;
        //}


        public static void CheckPlay(TrackInfoItunes track)
        {
            track.played = isPlayed(track);
        }


        private static bool isPlayed(TrackInfoItunes track)
        {
            if (track.playCount <= 0)
            {
                if (playedLevel == DateTime.MinValue || track.PlayedDate >= playedLevel)
                    return false;
                // pour les vieux on prend quand même en compte la date de dernière lecture
                return true;
            }

            int rating = track.Rating;
            if (maxPlayed.ContainsKey(rating))
                return track.PlayedDate > maxPlayed[rating];
            return true;

        }


        public string ShortName { get { return getShortName(location); } }
        public static string getShortName(string location) { return misc.getShortPath(location, Exporter.PODCASTS, Exporter.ZIQUE, "Y:"); }

        private string hibernateLocation;
        public string HibernateLocation { get { return hibernateLocation; } set { hibernateLocation = value; } }


        public bool isPresent()
        {
            if (!string.IsNullOrEmpty(hibernateLocation))
                return FileRegister.Exist(hibernateLocation);
            return FileRegister.Exist(location);

            //var path = location;
            //if (_extern)
            //{
            //    var shortName = ShortName;
            //    path = TrackInfoItunes.DefaultFolder + shortName;
            //}
            //if (FileRegister.Exist(location))
            //{
            //    location = path;
            //    return true;
            //}
            //return false;
        }

        public void build(XmlReader reader)
        {

            location = reader.GetAttribute("f");
            if (Path.IsPathRooted(location))
            {
            }
            else
                location = TrackInfoItunes.DefaultFolder + location;


            hibernateLocation = reader.GetAttribute("hl");

            string album = reader.GetAttribute("alb");
            if (album != null)
                albumMgr.setAlbum(this, album);
            name = reader.GetAttribute("name");

            var str = reader.GetAttribute("pub");
            if (!string.IsNullOrEmpty(str))
                pub = Convert.ToDateTime(str);

            str = reader.GetAttribute("pub2");
            if (!string.IsNullOrEmpty(str))
                pub2 = Convert.ToDateTime(str);

            str = reader.GetAttribute("date");
            if (!string.IsNullOrEmpty(str))
            {
                // playCount = 1;
                PlayedDate = Convert.ToDateTime(str);
            }

            str = reader.GetAttribute("nbr");
            if (!string.IsNullOrEmpty(str))
            {
                playCount = Convert.ToInt16(str);
            }

            str = reader.GetAttribute("albumRating");
            if (!string.IsNullOrEmpty(str))
                TrackAlbum.AlbumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                rating = Convert.ToInt32(str);

            if (TrackAlbum.AlbumRating > 0 && rating == 0)
                rating = TrackAlbum.AlbumRating;

            str = reader.GetAttribute("id");
            _dbId = Convert.ToInt32(str);

            //if ("y" == reader.GetAttribute("rare"))
            //    TrackAlbum.Rare = true;
            //if ("y" == reader.GetAttribute("info"))
            //    TrackAlbum.Info = true;
            if ("y" == reader.GetAttribute("disabled"))
                enabled = false;
            else
                enabled = true;
            str = reader.GetAttribute("s");
            if (!string.IsNullOrEmpty(str))
                _size = Convert.ToInt64(str);
            else
                _size = -1;

            str = reader.GetAttribute("d");
            if (!string.IsNullOrEmpty(str))
                Duree = timeSpan.FromSecondes(Convert.ToInt32(str));



            str = reader.GetAttribute("add");
            if (!string.IsNullOrEmpty(str))
                added = Convert.ToDateTime(str);
            str = reader.GetAttribute("add1");
            if (!string.IsNullOrEmpty(str))
                AddedFirst = Convert.ToDateTime(str);

            if (addedFirst == DateTime.MinValue)
                addedFirst = added;



            CheckPlay(this);

        }

        public void readStat(XmlReader reader)
        {
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                _in = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                _out = Convert.ToDateTime(str);
        }

        public bool SelectedByDb { get { return Selected; } }// || _in > _out; } }

        public void readStatGlobal(XmlReader reader)
        {
            DateTime oin = DateTime.MinValue;
            DateTime oout = DateTime.MinValue;
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                oin = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                oout = Convert.ToDateTime(str);

            if (oin > oout)
            {
                //sélectionné
                _gout = DateTime.MaxValue;
                return;
            }

            if (oout > _gout)
                _gout = oout;
        }

        //public void consolidStat()
        //{
        //    if (_in > DateTime.MinValue)
        //    {
        //        if (_in < _gin || _gin == DateTime.MinValue)
        //            _gin = _in; 
        //    }

        //    if (_out > _gout)
        //        _gout = _out; 
        //}



        public override void build(XmlNode xTrack)
        {
            TrackInfoItunes copy = null;
            if (loader.Import || loader.Slave)
            {
                copy = createCopy(this);
            }

            base.build(xTrack);

            TrackAlbum.AlbumRating = 0;

            //  bool ratingComputed = false;
            bool albumRatingComputed = false;
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    //if (key == "Rating Computed")
                    //    ratingComputed = true;
                    if (key == "Album Rating Computed")
                        albumRatingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); AddedFirst = added; break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break; //DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Album Rating": TrackAlbum.AlbumRating = Convert.ToInt32(value); break;
                }

            }
            // gestion des rating
            if (albumRatingComputed)
                TrackAlbum.AlbumRating = 0;

            duree = new util.timeSpan(Duration);


            bool change = false;
            if (copy != null)
            {
                if (copy._album != null)
                    _album = copy._album;
                if (!string.IsNullOrEmpty(copy.name) && copy.name != name)
                {
                    log.log("import cause name '{0}' '{1}' {2}", name, copy.name, this);
                    name = copy.name;
                    change = true;
                }

                if (PlayedDate != copy.PlayedDate)
                {
                    log.log("import cause playDate '{0}' '{1}' {2}", PlayedDate, copy.PlayedDate, this);
                    PlayedDate = copy.PlayedDate;
                    change = true;
                }
                if (playCount != copy.playCount)
                {
                    log.log("import cause playCount '{0}' '{1}' {2}", playCount, copy.playCount, this);
                    change = true;
                    playCount = copy.playCount;
                }
                // albumRating = copy.albumRating;
                if (enabled != copy.enabled)
                {
                    log.log("import cause enabled '{0}' '{1}' {2}", enabled, copy.enabled, this);
                    enabled = copy.enabled;
                    change = true;
                }

                if (rating != copy.rating)
                {
                    log.log("import cause rating '{0}' '{1}' {2}", rating, copy.rating, this);
                    rating = copy.rating;
                    change = true;
                }
                if (pub2 != copy.pub2)
                {
                    log.log("import cause pub2 '{0}' '{1}' {2}", pub2, copy.pub2, this);
                    pub2 = copy.pub2;
                    change = true;
                }


                var comment = buildComment();
                if (!string.IsNullOrEmpty(comment) && comment != Comment)
                {
                    log.log("import cause comment '{0}' '{1}' {2}", Comment, comment, this);
                    change = true;
                }

                //var _comment = buildComment();
                //if (_comment != Comment)
                //    change = true;

                Duration = copy.Duration;
                duree = copy.duree;


            }
            PubLoader.setPub();

            CheckPlay(this);

            if (change)
            {
                import();
            }
        }



        //private PubLoader pubLoader;
        //internal PubLoader PubLoader { get { if (pubLoader == null) pubLoader = new PubLoader(this); return pubLoader; } }
        internal PubLoader PubLoader { get { return new PubLoader(this); } }

        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        private DateTime pub2;
        public DateTime Pub
        {
            get
            {
                return pub;
            }
        }

        public DateTime Pub2
        {
            get { if (pub2 > pub) return pub2; return pub; }
            set
            {
                if (pub2 != value)
                    pub2 = value;
            }
        }


        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        public DateTime Added { get { return added; } }

        /// <summary>
        /// Date de premier ajout; 
        /// </summary>
        private DateTime addedFirst;
        public DateTime AddedFirst
        {
            get { return addedFirst; }

            set
            {
                if (addedFirst == DateTime.MinValue)
                    addedFirst = value;
            }
        }

        private DateTime _in;
        public DateTime In { get { return _in; } }

        private DateTime _out;
        public DateTime Out { get { return _out; } }

        //private DateTime _gin;
        //public DateTime Gin { get { return _gin; } }

        /// <summary>
        /// Dernier out global (MaxValue si encore sélectionné)
        /// </summary>
        private DateTime _gout;
        public DateTime Gout { get { return _gout; } set { _gout = value; } }

        public void checkInOut()
        {
            DateTime now = DateTime.Now;
            if (Selected)
            {
                if (_in == DateTime.MinValue || _out > _in)
                    _in = now;
            }
            else
            {
                if (_in > DateTime.MinValue)
                {
                    if (_out == DateTime.MinValue || _in > _out)
                        _out = now;
                }
            }
        }


        public albumSpec Specif { get { return TrackAlbum.Specif; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        // private bool info;

        public bool Info
        {
            get { return TrackAlbum.Info; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        //  private bool rare;
        public bool Rare
        {
            get { return TrackAlbum.Rare; }
        }

        public bool Actu
        {
            get { return TrackAlbum.Actu; }
        }

        public bool Courant
        {
            get { return TrackAlbum.Courant; }
        }

        public bool Open { get { return TrackAlbum.Open; } }
        public bool Recent { get { return TrackAlbum.Recent; } }

        private bool played;
        public bool Played { get { return played; } }

        private bool globalSelected;
        public bool GlobalSelected { get { return globalSelected; } set { globalSelected = value; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        private bool inJournal = false;

        public bool FreeInJournal { get { return Selected && !inJournal; } }
        public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        public void clearLists()
        {
            selected = selectMode.none;
            exclu = null;
            inJournal = false;
            listSelected = new SequentialDictString<LimitItem>();
            //listLoad0 = new SequentialDictString<LimitItem>();
            //listStandAlone = new SequentialDictString<LimitItem>();
            //indexRoot = -1;
            offset = default(DateTime);
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }
        private string pubInfoShort() { return pub.ToString("dd.MM.yy"); }
        private string getDayOfWeek()
        {
            var strDayOfWeek = "";
            switch (pub.DayOfWeek)
            {
                case DayOfWeek.Friday:
                    strDayOfWeek = "v";
                    break;
                case DayOfWeek.Monday:
                    strDayOfWeek = "l";
                    break;
                case DayOfWeek.Saturday:
                    strDayOfWeek = "s";
                    break;
                case DayOfWeek.Sunday:
                    strDayOfWeek = "d";
                    break;
                case DayOfWeek.Thursday:
                    strDayOfWeek = "j";
                    break;
                case DayOfWeek.Tuesday:
                    strDayOfWeek = "ma";
                    break;
                case DayOfWeek.Wednesday:
                    strDayOfWeek = "me";
                    break;
                default:
                    break;
            }

            return strDayOfWeek;
        }

        // private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void updateNative()
        {
            PubLoader.setPub();


            int volume = Volume;
            if (Album.Contains("RFI"))
            {
                if (volume != -20)
                    Volume = -20;
            }
            else
            {
                if (volume < volumeMin)
                    Volume = volumeMin;
            }


            if (pub > MIN)
            {

                var target = NameWithDate;
                if (!target.Equals(Name))
                    Name = target;
                BuildComment();
                return;

                string infoShort = pubInfoShort();
                string infoPubName = pub.ToString("dd.MM.yyyy");
                string infoPubName2 = pub.ToString("dd/MM/yyyy");
                string infoPubName3 = pub.ToString("dd/MM/yy");
                string infoYear = Year.ToString();
                if (pub.DayOfYear == 1)
                {
                    infoPubName = pub.Year.ToString();
                    infoPubName2 = infoPubName;
                    infoPubName3 = infoPubName;
                    infoShort = infoPubName;
                }

                string name = Name;
                string str = name;

                while (str.Contains("  "))
                    str = str.Replace("  ", " ");

                while (str.Contains(infoShort))
                    str = str.Replace(infoShort, "");
                while (str.Contains(infoPubName))
                    str = str.Replace(infoPubName, "");
                while (str.Contains(infoPubName2))
                    str = str.Replace(infoPubName2, "");
                while (str.Contains(infoPubName3))
                    str = str.Replace(infoPubName3, "");

                str = str.Trim();

                //if (regInfoShort.IsMatch(str))
                //{
                //    var strdate = regInfoShort.Match(str).Groups[1].Value;
                //    str = str.Replace(strdate, "");
                //}



                //Michel Rocard (1/5) l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 17.06.13 l
                var strDayOfWeek = getDayOfWeek();
                var s1 = strDayOfWeek + " ";
                strDayOfWeek = " " + strDayOfWeek;

                while (str.EndsWith(strDayOfWeek))
                    str = str.Remove(str.Length - strDayOfWeek.Length - 1);
                //while (str.EndsWith(s1))
                //    str = str.Remove(str.Length - s1.Length);

                //if (str.Contains(infoPubName))
                //    str = str.Replace(infoPubName, infoShort);
                //else if (name.Contains(infoPubName2))
                //    str = str.Replace(infoPubName2, infoShort);

                //else
                //{
                //    if (!str.Contains(infoShort))
                //    {
                //        str = str + " " + infoShort;
                //    }
                //    else
                //    {
                //        if (Year > 1980 && str.Contains(infoYear))
                //            str = str.Replace(infoYear, "").Trim();
                //    }
                //}
                var strBUG = "30.12.99";
                if (str.Contains(strBUG))
                    str = str.Replace(strBUG, "");

                while (str.Contains("  "))
                    str = str.Replace("  ", " ");

                str = str.Trim();

                str += " ";
                str += infoShort;


                str += strDayOfWeek;

                if (!str.Equals(name))
                    Name = str;

                BuildComment();
            }
        }
        // private LimitItem provider; 
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (!listSelected.ContainsKey(key))
                listSelected.Add(key, limit);



            if (selected == value)
                return;

            selected = value;
            if (isPresent() && !present)
            {
                // loader.resurrection(this);
            }




        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
            }
        }
        //DateTime IPub.Pub2
        //{
        //    get
        //    {
        //        return pub2;
        //    }
        //    set
        //    {
        //        pub2 = value;
        //    }
        //}

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            set
            {
                if (string.IsNullOrEmpty(this.Grouping))
                    setGrouping(this.Comment, true);
                Comment = value;
            }
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        DateTime IPub.Offset { get { return offset; } }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree
        {
            get
            {

                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
                return duree;
            }
            private set
            {
                duree = value;
                if (base.Duration.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
            }
        }


        public string getLogicalName(string t)
        {

            var strBUG = "30.12.99";
            if (t.Contains(strBUG))
                t = t.Replace(strBUG, "").Trim();
            var sw = getDayOfWeek();
            if (t.EndsWith(sw))
                t = t.Remove(t.Length - sw.Length).Trim();
            var strPub = pub.ToString("dd.MM.yyyy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pub.ToString("dd/MM/yyyy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pub.ToString("dd/MM/yy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pubInfoShort();
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            if (t.EndsWith("-"))
                t = t.Remove(t.Length - 1).Trim();

            while (t.Contains("  "))
                t = t.Replace("  ", " ");



            return t;
        }

        public string NameWithDate
        {
            get { return string.Format("{0} {1} {2}", LogicalName, pubInfoShort(), getDayOfWeek()); }
        }

        public string LogicalName
        {
            get
            {
                return getLogicalName(name);
            }
        }

        //public override string Name
        //{
        //    get
        //    {
        //        return name;
        //    }
        //    set
        //    {
        //        if (value == null)
        //        {
        //            log.log("set Name null !!! {0}", this);
        //            return;
        //        }

        //        var thisLog = LogicalName;
        //        var newLog = getLogicalName(value);

        //        if (!thisLog.Equals(newLog, StringComparison.InvariantCultureIgnoreCase))
        //        {
        //            log.log("Modification du nom logique !!! {0}->{1} {2}", thisLog, newLog, this);
        //            return;
        //        }
        //        base.Name = value;
        //    }
        //}



        public override TimeSpan Duration
        {
            get
            {
                var dur = base.Duration;
                if (dur.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
                return base.Duration;
            }

            set
            {
                base.Duration = value;
                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
            }
        }

        private long _size = -1;
        public long Size
        {
            get
            {
                if (_size < 0)
                {
                    var f = FileRegister.Check(Location);
                    if (f.Exists)
                        _size = f.Length;
                    else
                        _size = 0;
                }
                return _size;
            }
        }

        //private int indexRoot = -1;
        //public int IndexRoot { get { return indexRoot; } set { indexRoot = value; } }



        public static void setDate0(DateTime date) { Date0 = date; }
        private static DateTime Date0;
        private timeSpan ts;
        public timeSpan Ts
        {
            get
            {
                if (ts == default(timeSpan))
                {
                    if (Date0 == DateTime.MinValue)
                        throw new ApplicationException("Date0 pas initialisée");
                    ts = new timeSpan(Pub2 - Date0);
                }
                return ts;
            }
        }

        public void hibernate(FileValue fv, string dirH)
        {
            bgClass.add(new BgTaskHibernate(this, fv, dirH));
        }

        protected class BgTaskHibernate : BgTaskDeleteTrackTrack
        {
            private TrackInfoItunes track;
            private FileValue fv;
            string dirH;
            public BgTaskHibernate(TrackInfoItunes track, FileValue fv, string dirH)
                : base(track, string.Format("Hibernate {0}", track))
            {
                this.track = track;
                this.fv = fv;
                this.dirH = dirH;
            }

            public override void exec()
            {
                base.exec();
                if (!success)
                    return;

                if (!string.IsNullOrEmpty(dirH))
                {
                    var dest = misc.copyTree(fv, dirH + track.ShortName, false);
                    track.HibernateLocation = dest;

                    try
                    {
                        File.Delete(track.Location);
                        fv.delete();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }
                }
            }
        }


        private class BgTaskImport : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskImport(TrackInfoItunes info)
                : base(string.Format("import {0}", info.Location))
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    info.import(_track);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

    }
}



]]></content>
  </file>
  <file path="\pdb.podcast\Albums\AlbumMgr.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.it.Albums;
using pdb.util;
using pdb.podcast.Tuning;

namespace pdb.podcast.Albums
{
    public class AlbumMgr : IAlbumMgr
    {
        private Dictionary<string, TrackAlbum> dict = new Dictionary<string, TrackAlbum>();
        public static AlbumMgr Instance = new AlbumMgr();

        private AlbumMgr() { }

        public void setAlbum(it.TrackInfoItunes track, string album)
        {
            var _alb = Get(album);
            var t = track as TrackInfoItunes;          

            var old = t.TrackAlbum;
            if (old != null)
                old.Remove(t);
            track.TrackAlbum = _alb;
            t.TrackAlbum.Add(t);
        }

      

        public TrackAlbum Get(string album)
        {
            var key = album.ToLowerWithoutDiacritics();

            if (dict.ContainsKey(key))
                return dict[key]; 
          //  var t = track as TrackInfoItunes;
            TrackAlbum _alb = null;
            ConfAlbum _conf = Conf.Albums.getItem(album);

           

            if (_conf != null)
                key = _conf.Names;

            if (!dict.ContainsKey(key))
            {
                _alb = new TrackAlbum(album, key); 
                dict.Add(key, _alb);
            }
            else
                _alb = dict[key];
            //var old = t.TrackAlbum;
            //if (old != null)
            //    old.Remove(t);
            // track.TrackAlbum = _alb;

            if (_conf == null)
                _alb.ConfAlbum = Conf.Albums;
            else
                _alb.ConfAlbum = _conf;
            //  t.TrackAlbum.Add(t);

            return _alb; 

        }

        public List<TrackAlbum> List { get { return new List<TrackAlbum>(dict.Values); } }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Albums\TrackAlbum.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;

namespace pdb.podcast.Albums
{
    [Flags]
    public enum albumSpec : byte
    {
        rare = 1,
        recent = 2,
        open = 4,        
        courant = 8,
        actu = 16,
        info = 32
    }


    public class TrackAlbum : pdb.it.Albums.TrackAlbumBase, ISelectable
    {
        private static DateTime dateOPen;
        private albumSpec specif;
        private string key; 
        private List<TrackInfoItunes> list = new List<TrackInfoItunes>();

        public string AlbumKey { get { return key; } }

        static TrackAlbum()
        {
            dateOPen = DateTime.Now.AddDays(-Conf.DeltaOPen);
        }
        public TrackAlbum(string album, string key)
            : base(album)
        {
            this.key = key; 
            //conf = Conf.Albums;

            //foreach (ConfAlbum _album in Conf.Albums.Items)
            //{
            //    foreach (string alb in _album.name)
            //    {
            //        if (alb == this.Album)
            //        {
            //            conf = _album;
            //            return;
            //        }
            //    }
            //}

        }

        public int AlbumRating { get; set; }

        public albumSpec Specif { get { return specif; } }
        public bool Info
        {
            get { return specif.HasFlag(albumSpec.info); }
        }
        public void setInfo() { specif |= albumSpec.info; }

        public bool Rare
        {
            get { return specif.HasFlag(albumSpec.rare); }
        }
        public void setRare() { specif |= albumSpec.rare; }


        public bool Actu
        {
            get { return specif.HasFlag(albumSpec.actu); }
        }
        public void setActu() { specif |= albumSpec.actu; }

        public bool Courant { get { return specif.HasFlag(albumSpec.courant); } }
        public void setCourant() { specif |= albumSpec.courant; }

        public bool Open { get { return specif.HasFlag(albumSpec.open); } }
        private void setOpen()
        {
            if (!specif.HasFlag(albumSpec.open))
                specif |= albumSpec.open;
        }

        public bool Recent { get { return specif.HasFlag(albumSpec.recent); } }
        private void setRecent()
        {
            if (!specif.HasFlag(albumSpec.recent))
                specif |= albumSpec.recent;
        }


        private pdb.podcast.Tuning.ConfAlbum conf;

        public ConfAlbum ConfAlbum { get { return conf; } set { conf = value; } }
        //private bool checkPub;
        //public bool CheckPub { get { return checkPub; } }

        //private bool checkDoublon;
        //public bool CheckDoublon { get { return checkDoublon; } }

        public void Add(TrackInfoItunes track)
        {
            list.Add(track);
            if (track.Pub2 >= Conf.Date0)
                setRecent();
            if (track.Pub2 >= dateOPen)
                setOpen();

        }
        public void Remove(TrackInfoItunes track)
        {
            list.Remove(track);
        }

        public List<TrackInfoItunes> List { get { return list; } }

        public override string ToString()
        {
            return string.Format("{0} ({1})", Album, AlbumKey); 
        }


        public int Rating
        {
            get { return AlbumRating; }
        }




        public util.timeSpan Duree
        {
            get { return util.timeSpan.MaxValue; }
        }

        public LimitItem Exclu
        {
            get
            {
                throw new NotImplementedException();
            }
            set
            {
                throw new NotImplementedException();
            }
        }

        public bool Histo
        {
            get { throw new NotImplementedException(); }
        }

        public DateTime Pub
        {
            get { throw new NotImplementedException(); }
        }

        public DateTime Pub2
        {
            get
            {
                throw new NotImplementedException();
            }
            set
            {
                throw new NotImplementedException();
            }
        }

        public bool Serial
        {
            get { throw new NotImplementedException(); }
        }

        public long Size
        {
            get { throw new NotImplementedException(); }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using pdb.podcast.Tuning;
using pdb.podcast.Albums;


namespace pdb.podcast.DB
{
    public class Db
    {
        public const string CURRENT_VERSION = "2.0";
        const string SEQ_PIECE = "seq";
        const string TOKEN_VERSION = "version";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        private BgDict<int, TrackInfoItunes> dictId = new BgDict<int, TrackInfoItunes>();
        private volatile object _lock = new object();






        string FILE = "..\\db.xml";
        string FILE_STAT = "..\\db_stats.xml";
        private List<string> sources = new List<string>();
        string SOV = "..\\sov\\";
        //   private XmlSerializer xmlSerializer;

        // private bool import;
        private bool loaded;

        public Db()
        {
            var conf = Conf.Db;
            FILE = conf.file;
            FILE_STAT = conf.fileStat;
            SOV = conf.sov;
            foreach (DbSource source in conf.sources)
            {
                sources.Add(source.file);
            }

            // this.import = import;
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};


        }

        public List<TrackInfoItunes> Tracks
        {
            get
            {
                if (!loaded)
                {
                    lock (_lock)
                    {

                    }
                }

                return new List<TrackInfoItunes>(dict.Values);
            }
        }

        public TrackInfoItunes get(string location)
        {
            if (!loaded)
            {
                lock (_lock)
                {

                }
            }
            return dict[location];
        }

        public TrackInfoItunes get(TrackInfoItunes w)
        {
            return dictId[w.DbId];
        }

        public void Check(TrackInfoItunes track)
        {


            var location = track.ShortName;
            if (string.IsNullOrEmpty(location))
                return;
            var dbTrack = dict[location];
            if (dbTrack == null)
            {
                int id = ++pieceSequenceId;
                track.DbId = id;
            }
            else
            {
                track.DbId = dbTrack.DbId;
                //if (import)
                //{
                //    track.import(dbTrack);
                //}
            }
            track.Present = true;
            dict[location] = track;
            dictId[track.DbId] = track;
        }

        public void Import(IEnumerable<TrackInfoItunes> listIt)
        {
            foreach (TrackInfoItunes it in listIt)
            {
                var location = it.ShortName;
                var tdb = dict[location];
                if (tdb == null)
                    continue;

                it.import(tdb);
            }
        }

        public void createIfExist(pdb.it.ITrackBuilder loader, List<TrackInfoItunes> listIt)
        {
            foreach (TrackInfoItunes tdb in dict.Values)
            {
                if (tdb.isPresent())
                {
                    loader.createTrack(tdb, true);
                    tdb.import();
                }
            }
        }



        public void load()
        {
            lock (_lock)
            {
                try
                {
                    var strVersion = "1";
                    TrackAlbum currentAlbum = null;
                    using (XmlReader reader = XmlReader.Create(FILE))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {
                                    var seq = reader.GetAttribute(SEQ_PIECE);
                                    pieceSequenceId = Convert.ToInt32(seq);
                                    strVersion = reader.GetAttribute(TOKEN_VERSION);
                                }
                                else if (reader.Name == "a")
                                {
                                    currentAlbum  = readAlbum(reader);
                                    var toto = currentAlbum.ToString();
                                }
                                else if (reader.Name == "t")
                                {
                                    var t = read(reader,currentAlbum);
                                    dict[t.ShortName] = t;
                                    dictId[t.DbId] = t;
                                }
                            }
                        }

                    }

                    using (XmlReader reader = XmlReader.Create(FILE_STAT))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {

                                }
                                else
                                {
                                    int id = Convert.ToInt32(reader.GetAttribute("id"));


                                    var t = dictId[id];
                                    if (t == null)
                                    {
                                        string loc = reader.GetAttribute("f");
                                        Program.log.log("track {0} dans les stats non vu dans db {1}", id, loc);
                                    }
                                    else
                                    {
                                        t.readStat(reader);
                                        t.readStatGlobal(reader);
                                    }
                                }
                            }
                        }

                    }


                    foreach (string source in sources)
                    {
                        try
                        {
                            using (XmlReader reader = XmlReader.Create(source))
                            {
                                while (reader.Read())
                                {
                                    if (reader.NodeType == XmlNodeType.Element)
                                    {
                                        if (reader.Name == "db")
                                        {

                                        }
                                        else
                                        {
                                            int id = Convert.ToInt32(reader.GetAttribute("id"));


                                            var t = dictId[id];
                                            if (t == null)
                                            {

                                            }
                                            else
                                            {
                                                t.readStatGlobal(reader);
                                            }
                                        }
                                    }
                                }

                            }
                        }

                        catch (Exception ex)
                        {
                            misc.log(ex);
                        }
                    }


                    //using (XmlReader reader = XmlReader.Create(GLOBAL_STAT))
                    //{
                    //    while (reader.Read())
                    //    {
                    //        if (reader.NodeType == XmlNodeType.Element)
                    //        {
                    //            if (reader.Name == "db")
                    //            {

                    //            }
                    //            else
                    //            {
                    //                int id = Convert.ToInt32(reader.GetAttribute("id"));


                    //                var t = dictId[id];
                    //                if (t == null)
                    //                {
                    //                    string loc = reader.GetAttribute("f");
                    //                    Program.log.log("track {0} dans les global stats non vu dans db {1}", id, loc);
                    //                }
                    //                else
                    //                {
                    //                    t.readStatGlobal(reader);
                    //                    t.consolidStat();
                    //                }
                    //            }
                    //        }
                    //    }

                    //}

                }

                finally
                {
                    loaded = true;
                }
            }
        }




        private TrackInfoItunes read(XmlReader reader, TrackAlbum currentAlbum)
        {
            var t = new TrackInfoItunes();
           
            //if (album != null)
            //{
                (t as it.TrackInfoItunes).TrackAlbum = currentAlbum;
                currentAlbum.Add(t);
           // }
            t.build(reader);
            return t;
        }

        private TrackAlbum readAlbum(XmlReader reader)
        {
            string name = reader.GetAttribute("name");
            var album = AlbumMgr.Instance.Get(name); 
            if ("y" == reader.GetAttribute("rare"))
                album.setRare();
            if ("y" == reader.GetAttribute("info"))
                album.setInfo();
            if ("y" == reader.GetAttribute("actu"))
                album.setActu();
            if ("y" == reader.GetAttribute("courant"))
                album.setCourant();

            var str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                album.AlbumRating = Convert.ToInt32(str);

            return album;
        }

        private void write(XmlWriter writer, TrackAlbum album)
        {
            writer.WriteStartElement("a");
            writer.WriteAttributeString("name", album.Album);
            if (album.AlbumRating > 0)
                writer.WriteAttributeString("rating", album.AlbumRating.ToString());
            if (album.Rare)
                writer.WriteAttributeString("rare", "y");
            if (album.Info)
                writer.WriteAttributeString("info", "y");
            if (album.Actu)
                writer.WriteAttributeString("actu", "y");
            if (album.Courant)
                writer.WriteAttributeString("courant", "y");

            writer.WriteAttributeString("spec", album.Specif.ToString());

            var list = album.List;
            list.Sort(new PodCastComparer());

            foreach (TrackInfoItunes t in list)
            {
                if (t.Deleted)
                    listDeleted.Add(t);
                else if (!Conf.Db.purgemissing || t.isPresent())
                    write(writer, t, false);
                else
                    listMissing.Add(t);
            }

            writer.WriteEndElement();

        }

        private static void write(XmlWriter writer, TrackInfoItunes track, bool writeAlbum)
        {
            writer.WriteStartElement("t");
            writer.WriteAttributeString("id", track.DbId.ToString());
            var location = track.Location;
            if (!string.IsNullOrEmpty(location))
            {
                if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                {
                    location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                }


            }
            writer.WriteAttributeString("f", location);
            if (writeAlbum)
                writer.WriteAttributeString("alb", track.Album);
            writer.WriteAttributeString("name", track.Name);
            if (track.Pub > DateTime.MinValue)
                writer.WriteAttributeString("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
            if (track.Pub2 > DateTime.MinValue && track.Pub2 > track.Pub)
                writer.WriteAttributeString("pub2", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
            if (track.PlayedDate > DateTime.MinValue)
                writer.WriteAttributeString("date", track.PlayedDate.ToString());
            if (track.PlayCount > 0)
                writer.WriteAttributeString("nbr", track.PlayCount.ToString());
            //if (track.AlbumRating > 0)
            //    writer.WriteAttributeString("albumRating", track.AlbumRating.ToString());
            if (track.Rating != track.AlbumRating)
                writer.WriteAttributeString("rating", track.Rating.ToString());


            //if (track.RatingComputed)
            //    writer.WriteAttributeString("computed", "y");
            //if (track.Rare)
            //    writer.WriteAttributeString("rare", "y");
            //if (track.Info)
            //    writer.WriteAttributeString("info", "y");
            var duree = track.Duree;
            if (duree.Value > 0)
            {
                writer.WriteAttributeString("d", duree.Value.ToString("0"));
                var size = track.Size;
                if (size > 0)
                    writer.WriteAttributeString("s", size.ToString());
            }
            if (!track.Enabled)
                writer.WriteAttributeString("disabled", "y");

            if (track.Added > DateTime.MinValue)
                writer.WriteAttributeString("add", track.Added.ToString());
            if (track.AddedFirst > DateTime.MinValue && track.AddedFirst < track.Added)
                writer.WriteAttributeString("add1", track.AddedFirst.ToString());




            if (!string.IsNullOrEmpty(track.HibernateLocation))
                writer.WriteAttributeString("hl", track.HibernateLocation);


            writer.WriteEndElement();

        }

        private static void writeStat(XmlWriter writer, TrackInfoItunes track)
        {
            if (track.In > DateTime.MinValue)
            {
                writer.WriteStartElement("t");
                writer.WriteAttributeString("id", track.DbId.ToString());
                var location = track.Location;
                if (!string.IsNullOrEmpty(location))
                {
                    if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                    {
                        location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                    }


                }
                writer.WriteAttributeString("f", location);



                if (track.Out == DateTime.MinValue || track.In < track.Out)
                {
                    writer.WriteAttributeString("in", track.In.ToString());
                    if (track.Out > DateTime.MinValue)
                        writer.WriteAttributeString("out", track.Out.ToString());
                }
                else
                {
                    writer.WriteAttributeString("out", track.Out.ToString());
                    writer.WriteAttributeString("in", track.In.ToString());
                }


                writer.WriteEndElement();
            }

        }

        public void recordIt(IEnumerable<TrackInfoItunes> listIt)
        {
            if (listIt != null)
            {
                foreach (TrackInfoItunes t in listIt)
                    Check(t);
            }
        }

        private List<TrackInfoItunes> listMissing;
        private List<TrackInfoItunes> listDeleted;
        public void write()
        {
            misc.log("db::write");
            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            lock (_lock)
            {
                try
                {
                    if (!Directory.Exists(SOV))
                        Directory.CreateDirectory(SOV);

                    File.Copy(FILE, string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE)), true);
                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }


                listMissing = new List<TrackInfoItunes>();
                listDeleted = new List<TrackInfoItunes>();

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(FILE + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());

                    AlbumMgr mgr = TrackInfoItunes.AlbumMgr as AlbumMgr;
                    var albums = mgr.List;
                    albums.Sort((x, y) => x.Album.CompareTo(y.Album));

                    foreach (TrackAlbum album in albums)
                    {
                        write(writer, album);
                    }

                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE + ".tmp", FILE, true);

                if (listMissing.Count > 0)
                {
                    using (XmlWriter writerMissing = XmlWriter.Create(string.Format("{0}{1}__missing.xml", SOV, timeStamp), settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            write(writerMissing, track, true);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }

                }

                if (listDeleted.Count > 0)
                {
                    using (XmlWriter writerDeleted = XmlWriter.Create(string.Format("{0}{1}__deleted.xml", SOV, timeStamp), settings))
                    {
                        writerDeleted.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            write(writerDeleted, track, true);
                        }
                        writerDeleted.WriteEndDocument();
                        writerDeleted.Flush();
                    }
                }


                using (XmlWriter writer = XmlWriter.Create(FILE_STAT + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    var tracks = Tracks;
                    tracks.Sort(new PodCastComparer());
                    foreach (TrackInfoItunes track in tracks)
                    {
                        if (!Conf.Db.purgemissing || track.isPresent())
                            writeStat(writer, track);
                    }
                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE_STAT + ".tmp", FILE_STAT, true);


                if (listMissing.Count > 0)
                {
                    using (XmlWriter writerMissing = XmlWriter.Create(string.Format("{0}{1}__missing_stat.xml", SOV, timeStamp), settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }

                }

                if (listDeleted.Count > 0)
                {
                    using (XmlWriter writerMissing = XmlWriter.Create(string.Format("{0}{1}__deleted_stat.xml", SOV, timeStamp), settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }

                }

                misc.log("db::fin write");
                //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
            }
        }


        // géopolitique 4 par défaut rating ->80 albumrating ->80 computed =true
        //RFI 0 de temps en temps surcharge pour un par défaut : rating null albumrating->20 computed = true
        //                                  pour un syrchargé  : rating non null ""   
        // adele 1                          pour les défaut   rating:20 album 20 computed
        //                                  pour un surchargé 4 rating 80 album 20 non computed

        //C'est quand même gavant. il fait pas la différence entre les étoiles pleines et creuses
        //prenons adele defaut : 20 /20 computed
        //          autre        80 /20 non computed


        // ayo album zero surcharge 1 deux étoiles creuses => 20/40/computed

        //Ah ok . cas computed 1. album=rating => c'est bien level album
        //                        album != rating => c'est bidon  "étoile creuse"                                
        //        sinon on lit directement level album

        // Quel con j'ai pas vu qu'il y avait RatingComputed et Album Rating computed
        // je me le refele
        //géopolitique ratinet alubm => 80 ratingComputed
        // RFi  defaut rating null album 20 albumcomputed
        //      surchargé   rating 20 idem     
        // adele defaut rating 20 rating computed albumrating 20




    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Load\FeedLimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using timeSpan = pdb.util.timeSpan;
using pdb.podcast.Albums;

namespace pdb.podcast.Load
{
  
    public enum loadState
    {
        loadCandidat,
        standAlone,
        selection,
        end
    }
    //public enum depotType
    //{
    //    load,
    //    rapporte
    //}
    /// <summary>
    /// Chargeur des pistes associées à un item de limite sur un dossier
    /// </summary>
    class FeedLimitItemLoader
    {
        private loadState state;
        /// <summary>
        /// Répertoire
        /// </summary>
        private DirConf dir;
        /// <summary>
        /// Limite
        /// </summary>
        public readonly LimitItem limit;
        /// <summary>
        /// Album
        /// </summary>
        private TrackAlbum album;
        /// <summary>
        /// Chargeur de limite
        /// </summary>
        private LimitsLoader parent;


        ///// <summary>
        ///// Nombre de piste max
        ///// </summary>
        //int nbMax;
        //int loadNbMax;
        /// <summary>
        /// Durée cumulée max
        /// </summary>
        //timeSpan durationMax;
        //timeSpan loadDurationMax;

        ///// <summary>
        ///// Date de publication min
        ///// </summary>
        //DateTime dateMin;

        // private Logger logger;
        //private Logger logLimit;
        //private Logger logItem;

        /// <summary>
        /// Durée cumulée
        /// </summary>
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtuel = new timeSpan();
        timeSpan durationStop = new timeSpan();

        /// <summary>
        /// Nombre total
        /// </summary>
        int nb = 0;
        int nbVirtuel = 0;
        int nbStop = 0;

        private bool? endByFd;
        public bool EndByFd { get { if (endByFd == null) return false; return endByFd.Value; } }

        private bool _okFd; public bool OkFd { get { return _okFd; } }
        private bool _okNb; public bool OkNb { get { return _okNb; } }


        private int _indexv = -1;
        private int _index = -1;

        public int Index { get { return _index;  } }
        public int IndexV { get { return _indexv; } }
        public List<TrackInfoItunes> Candidats { get { return candidats;  } }

        #region refonte
        Contribution virt = new Contribution();
        Contribution current = new Contribution(); 
      
        int count;
        private TrackInfoItunes _nextCandidat;
        private List<TrackInfoItunes> candidats = new List<TrackInfoItunes>();
        private Contribution dict = new Contribution(); 
        public void AddCandidat(TrackInfoItunes track)
        {
            candidats.Add(track);
            count++;
        }
        public int NbV { get { return virt.Nb; } }
        public timeSpan FdV { get { return virt.Duree;  } }
        /// <summary>
        /// Donne les valeurs min pour ajouter un track à partir de valeurs de base
        /// </summary>
        /// <param name="nb"></param>
        /// <param name="fd"></param>
        public void checkV(int nb, timeSpan fd)
        {
            //nb > _nbv && fd > _fdv
            // 1-> je sors nb=1 fd=5 > retenu par exemple nb=0 fd = 5 ridicule mais c'est comme ça
            // step fait un check(0,5) qui ne renvoie rien
            // 2-> check (0,5 ) ? je fais pas indev++ car j'ai déja 5
            //0/0   1/5    2/11    3/16
            // |-----|------|-------|-->
            // debut

            while (true)
            {
                if (virt.Nb > nb)
                    break;
                if (virt.Duree > fd)
                    break; 
                _indexv++;
                if (_indexv >= count)
                    break;
                _nextCandidat = candidats[_indexv];
                virt.add(_nextCandidat); 
            }

        }

        public void reservation(int nb, timeSpan fd)
        {
            while (true)
            {
                
            }
        }

        #endregion
        //public FeedLimitLoaderState getNext(FeedLimitLoaderState current)
        //{
        //    int i = index + 1;
        //    if (i >= candidats.Count)
        //        return null;
        //    var track = candidats[i]; 
        //    var _nb = nb + 1;
        //    var _fd = currentDuration + track.Duree;

        //    var ret = new FeedLimitLoaderState() { track = track }(); 
        //    if (_nb > current.nb)
        //        ret.
        //}

        public void phase2()
        {
            currentDuration = new timeSpan();
            currentDurationVirtuel = new timeSpan();
            durationStop = new timeSpan();
            nb = 0;
            nbVirtuel = 0;
            nbStop = 0;
            state = loadState.selection;
            endByFd = null;
        }


        //private bool loadEqSel;
        //public bool LoadEqSel { get { return loadEqSel; } }

        public FeedLimitItemLoader(LimitItem limit, TrackAlbum album, LimitsLoader parent)
        {
            this.dir = limit.Dir;
            this.limit = limit;

            this.parent = parent;
            this.album = album;


          //  nbMax = limit.Nb;


          //  var feedDuration = limit.FeedDuration;
          //  int rating = limit.Rating;
          ////  durationMax = timeSpan.FromMinutes(feedDuration);


          //  loadDurationMax = durationMax;
          //  loadNbMax = nbMax;

          //  bool loadEqSeld = true;
          //  bool loadEqSeln = true;

          //  //if (limit.Dir.Cascading)
          //  //{
          //  if (limit.LoadNb > nbMax)
          //  {
          //      loadNbMax = limit.LoadNb;
          //      loadEqSeln = false;
          //  }
          //  if (limit.LoadFeedDuration > feedDuration)
          //  {
          //      loadDurationMax = timeSpan.FromMinutes(limit.LoadFeedDuration);
          //      loadEqSeld = false;
          //  }

          //  //}
          //  if (loadEqSeln)
          //      loadNbMax++;
          //  if (loadEqSeld)
          //      loadDurationMax = timeSpan.FromMinutes(loadDurationMax.TotalMinute + 200);

          //  //logItem = Logger.getLogger(limit.ID + "\\" + album, null, false);
            //logLimit = limit.Logger;
        }

        //private void log(string txt)
        //{
        //    logLimit.log(txt);
        //    logItem.log(txt);
        //}

        //private void log(string txt, params object[] other)
        //{

        //    logLimit.log(txt, other);
        //    logItem.log(txt, other);
        //}




        public timeSpan getCurrentDuration(bool real)
        {
            if (real)
                return currentDuration;
            return currentDurationVirtuel;
        }

        public timeSpan getDurationStop(bool real)
        {
            if (durationStop.Value == 0)
                return getCurrentDuration(real);
            return durationStop;
        }

        public int getNb(bool real)
        {

            if (real)
                return nb;
            return nbVirtuel;
        }
        public int getNbStop(bool real)
        {
            if (nbStop == 0)
                return getNb(real);
            return nbStop;
        }

        public int Nb { get { return nb; } }

        public bool control(TrackInfoItunes track, bool select, bool load, bool real, bool increment)
        {
            //if (state == loadState.end)
            //    return false;


            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return false;



            //     string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration.TotalMinutes.ToString("0"), track.ToString());
            string phase = select ? "ctl" : "load";

            //if (!Logger.CreateNullLoggers)
            //{
            //    string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration, track.ToString());

            //    log("-->  {0} ok {1} ", phase, str);
            //}

            var ok = checkStatus(string.Format("-->  {0}", phase), load, track, limit, real, increment);

            if (!ok)
                return false;

            if (select && real && LimitItemLoader.ModeSelection)
            {
                var selected = selectMode.simple;
                if (dir.Histo)
                {
                    selected = selectMode.serial;
                    if (dir.HistoAll.HasValue && dir.HistoAll.Value)
                        selected = selectMode.histo;
                    if (dir.Serial)
                        selected = selectMode.serial;
                }
                else
                {
                    //if (!candidat.Serial && !candidat.Histo)
                    selected = selectMode.simple;
                }

                track.select(selected, limit);
                limit.Dir.Feeds.recordTrack(track, limit);
            }

            //report aux niveaux inférieurs
            if (real)
                parent.recordLimitItemCandidat(track, limit);
            return true;
        }




        private bool checkStatus(string phase, bool load, TrackInfoItunes track, LimitItem itemSource, bool real, bool increment)
        {
            endByFd = null;
            _okFd = true;
            _okNb = true;
            bool ret = true;
            //        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration.TotalMinutes.ToString("0"), track.ToString());
            nbVirtuel = nb;
            currentDurationVirtuel = currentDuration;
            var nbBase = real ? nb : nbVirtuel;

            var _nb = nbBase + 1;
          //  var durationBase =   real ? currentDuration : currentDurationVirtuel;
         //   var dur = durationBase + track.Duree;

            var conf = album.ConfAlbum; 
            
            int _nbMax =  limit.getNb(load, conf); //    load ? limit.LoadNb : (int)(System.Math.Min(limit.Nb, limit.Nb2));
            var __durationMax = limit.getFd(load, conf); //  load ? limit.LoadDuration : System.Math.Min(limit.FeedDuration, limit.Fd2);
            var _durationMax = timeSpan.FromMinutes(__durationMax); 

            bool justStopped = false; 

            if (_nb > _nbMax)
            {
                _okNb = false;
                if (real)
                {
                    if (LimitItemLoader.ModeSelection)
                        limit.NbFeedLimit = true;
                    //if (!Logger.CreateNullLoggers)
                    //{
                    //    string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
                    //    log("{0} stop nb {1} ", phase, str);
                    //}
                    if (state != loadState.end || justStopped)
                    {
                        justStopped = true; 
                        state = loadState.end;
                        nbStop = _nb;
                    }
                }

                endByFd = false;
                ret = false;
            }



            // vérification des valeurs cumulées
            if (currentDuration > _durationMax)
            {
                _okFd = false;
                if (real)
                {

                    //if (!limit.DurationFeedLimit)
                    //{
                    //    //if (!Logger.CreateNullLoggers)
                    //    //{
                    //    //    string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
                    //    //    log("{0} stop d. {1} ", phase, str);
                    //    //}
                    //}
                    if (LimitItemLoader.ModeSelection)
                        limit.DurationFeedLimit = true;
                    if (state != loadState.end || justStopped)
                    {
                        justStopped = true; 
                        state = loadState.end;
                        durationStop = currentDuration;
                    }

                }

                //if (select || durationMax == loadDurationMax)
                //{
                //    if (ret)
                //    {
                //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, false);
                //        limit.signal(tb);
                //    }
                //    //limit.checkBorderFd(track, dur, false);
                //}

                if (endByFd == null)
                    endByFd = true;
                ret = false;
            }
            else
            {
                // endByFd = null;
                //if (select || durationMax == loadDurationMax)
                //{
                //    if (ret)
                //    {
                //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, true);
                //        limit.signal(tb);
                //    }
                //}
            }






            if (increment)
            {
                if (real)
                {
                    nb += 1;
                    currentDuration += track.Duree;
                }

                //currentDurationVirtuel += track.Duree;
                nbVirtuel += 1;
            }
            return ret;

        }

        public override string ToString()
        {
            return string.Format("{0} {1}", album, limit); 
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;

//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    public class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();

        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        // private Logger log;
        timeSpan currentDuration = new timeSpan();
        // timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;



        // List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> selectedByFd = new BgDictString0<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> manageByFd = new BgDictString0<TrackInfoItunes>();
        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            //log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }


        //public timeSpan _durationv;
        //public timeSpan _datev;
        //private timeSpan _fd;
        //public timeSpan Fd { get { return _fd; } }

        public int _nb;

        //public void checkV(AutoBuilder auto, int nb, timeSpan fd, timeSpan d, timeSpan date)
        //{
        //    BgDictString0<TrackInfoItunes> dict = new BgDictString0<TrackInfoItunes>();

        //    int nbMin = int.MaxValue;
        //    timeSpan fdMin = timeSpan.MaxValue;
        //    timeSpan dMin = timeSpan.MaxValue;
        //    timeSpan dateMin = timeSpan.MaxValue;
        //    foreach (FeedLimitItemLoader loader in loaders.Values)
        //    {
        //        loader.checkV(nb, fd);
        //        var _nb = loader.NbV;
        //        var _fd = loader.FdV;
        //        if (_nb > nb && _nb < nbMin)
        //            nbMin = _nb;
        //        if (_fd > fd && fd < fdMin)
        //            fdMin = _fd;
        //        for (int i = 0; i <= loader.IndexV; i++)
        //        {
        //            var track = loader.Candidats[i];
        //            if (dict.ContainsKey(track.Location))
        //                continue;
        //            var _d = currentDuration + track.Duree;
        //            if (_d > d && d < dMin)
        //                dMin = _d;
        //            var _date = track.Ts;
        //            if (_date > date && _date < dateMin)
        //                dateMin = _date;
        //            break;
        //        }



        //    }

        //    this._durationv = dMin;
        //    this._datev = dateMin;
        //    this._nb = nbMin;
        //    this._fd = fdMin;
        //}

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb ==0)
                return;

            if (!limit.OverwriteConf && limit.Nb2 == 0)
                return; 

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            //if (limit.Dir.Cascading)
            //{
            var dd = limit.LoadDuration;
            if (dd > duration)
            {
                loadEqSel = false;
                duration = dd;
            }
            //}

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                var d = candidat.Pub2;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                standAlone.Add(location, candidat);
                Exporter.Record(candidat);

                var loader = getLoader(candidat);
                loader.AddCandidat(candidat);
                continue;



            }

        }




        private FeedLimitItemLoader getLoader(TrackInfoItunes candidat)
        {
            var album = candidat.TrackAlbum;
            var key = album.AlbumKey; 
           
            FeedLimitItemLoader loader = null;
            if (!loaders.ContainsKey(key))
            {
                loader = new FeedLimitItemLoader(limit, album, parent);
                loaders.Add(key, loader);
                if (parent.state == loadState.selection)
                    loader.phase2();
            }
            else
                loader = loaders[key];
            return loader;
        }

        /// <summary>
        /// On supprime tout sauf les standalone
        /// </summary>
        public void reset()
        {
            loaders = new BgDictString0<FeedLimitItemLoader>();
            //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
            // public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
            legacy = new SequentialDictString<TrackInfoItunes>();
            legacyRelax = new SequentialDictString<TrackInfoItunes>();
            selected = new SequentialDictString<TrackInfoItunes>();
            exclu = new SequentialDictString<TrackInfoItunes>();

            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();
            use = new List<TrackInfoItunes>();


            currentDuration = new timeSpan();
            // timeSpan currentDurationVirtual = new timeSpan();
            durationStop = new timeSpan();
            currentContrib = new timeSpan();
            trackDurationMax = new timeSpan();
            trackDurationMin = new timeSpan();
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            //  currentDurationVirtual = new timeSpan();
            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in loaders.Values)
                loader.phase2();
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }



        //private timeSpan getDuration(int nb, timeSpan minfd)
        //{
        //    timeSpan tot = new timeSpan();
        //    foreach (FeedLimitItemLoader feed in loaders.Values)
        //    {
        //        tot += feed.getTotalDurationFor(nb, minfd);
        //    }
        //    return tot;
        //}

        public void Selection()
        {

            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;
            if (relax.Count > 0)
            {
                if (histo)
                    relax.Sort(new PodCastComparer());
                else
                    relax.Sort(new PodCastComparerInv());
                selection(relax, false, false);
            }

            var list = legacy.List;
            if (list.Count > 0)
            {
                if (histo)
                    list.Sort(new PodCastComparer());
                else
                    list.Sort(new PodCastComparerInv());
                selection(list, false, true);
            }





            var list2 = standAlone.List;
            if (list2.Count > 0)
            {
                if (histo)
                    list2.Sort(new PodCastComparer());
                else
                    list2.Sort(new PodCastComparerInv());

                selection(list2, true, true);
            }

        }




        private void selection(List<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.getDuration(); 
           
            var durationMax = timeSpan.FromMinutes(duration);
      
            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {
                TrackInfoItunes candidat = list[index];
                //foreach (TrackInfoItunes candidat in list)
                //{

                //if (candidat.Album == "Géopolitique")
                //{
                //}

                //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
                //{
                //}
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                DateTime d = candidat.TrackAlbum.ConfAlbum.checkPub ? candidat.Pub : candidat.Pub2;
                bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
                var loader = getLoader(candidat);
                bool okTotalDuration = false;
                bool _control = false;

                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                okTotalDuration = currentDuration <= durationMax; 

                bool okprovi = okDate && okTotalDuration;
                // bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                if (!increment) // données venant de sous-dossier (histo, voisins....)
                {
                    _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                }



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {
                    var newDuration = currentDuration; // +candidat.Duree;
                    okTotalDuration = newDuration <= durationMax; 
                    if (manageByFd.ContainsKey(location))
                    {
                        _control = false;
                        if (selectedByFd.ContainsKey(location))
                            _control = true;
                    }
                    else
                    {
                        _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

                    }

                    if (_control)
                    {
                        //currentDurationVirtual += candidat.Duree;
                        if (okDate)
                            currentDuration += candidat.Duree;
                    }


                    // newDuration = currentDuration;
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                    //  okTotalDuration = newDuration <= durationMax;



                    //okTotalDuration = newDuration <= durationMax;
                    //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

                    //if (okDate && _control)
                    //    currentDuration += candidat.Duree;
                    //currentDurationVirtual = currentDuration; // += candidat.Duree;

                    //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

                    //  bool okTotalDuration = newDuration <= durationMax;

                    if (!_selection)
                    {


                        //var _fd = loader.getCurrentDuration(false);

                        //if (_fd > newDuration)
                        //{
                        //    newDuration = _fd;
                        //    okTotalDuration = newDuration <= durationMax;
                        //}
                        //if (_control)
                        //{
                        //}
                        //else
                        //{
                        //    //var fd = loader.getCurrentDuration(true);
                        //    //var nb = loader.getNb(true);

                        //    //newDuration = new timeSpan();
                        //    //foreach (FeedLimitItemLoader l in loaders.Values)
                        //    //    l.phaseTest();
                        //    //for (int j = 0; j <= index; j++)
                        //    //{
                        //    //    TrackInfoItunes t = list[j];
                        //    //    var subloader = getLoader(t.Album);
                        //    //    var subok = subloader.test(nb, fd, t);
                        //    //    if (j >= subloader.IndexBase)
                        //    //    {
                        //    //        if (subok || selectedByFd.ContainsKey(location))
                        //    //            newDuration += t.Duree;
                        //    //    }

                        //    //}
                        //    //// newDuration += getDuration(nb, fd);

                        //    //if (newDuration < currentDuration)
                        //    //{
                        //    //}
                        //    //else if (newDuration > currentDurationVirtual)
                        //    //{
                        //    //}
                        //    //okTotalDuration = newDuration <= durationMax;
                        //}


                        //question fd
                        //if (!loader.LoadEqSel)
                        //{

                        var causeReg0 = limit.Dir.CauseRegister;
                        if (!causeReg0.IsNull)
                        {
                            var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                          loader.OkFd, loader.getDurationStop(okDate)
                          , loader.OkNb, loader.getNbStop(okDate)
                          , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

                            causeReg0.signal(dataRoot);
                        }

                        if (limit.canSignal())
                        {

                            var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                                //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                                //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                                //, okTotalDuration, newDuration, candidat, limit);
                                    loader.OkFd, loader.getCurrentDuration (false)
                            , loader.OkNb, loader.getNb(false)
                            , okTotalDuration, newDuration, candidat, limit);

                            limit.signal(dataAuto);
                        }
                    }




                    //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                    //loader.OkFd, loader.getDurationStop(okDate)
                    //, loader.OkNb, loader.getNbStop(okDate)
                    //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                    //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                    //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                    //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

                    if (Conf.BorderTb)
                    {
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
                        else if (okDate && okTotalDuration)
                        {
                            if (loader.EndByFd)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
                        }
                        //else if (Conf.BorderVirtual)
                        //{
                        //    if (_control)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
                        //    else if (loader.EndByFd)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
                        //}


                        //}

                        //if (!loadEqSel)
                        //{
                        // question d
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                        else if (okDate && _control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okTotalDuration)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                        }


                        // question date
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                        else if (_control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okDate)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                        }

                        //}

                    }


                    ////question duree
                    //if (okDate && _control) // || Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
                    //}

                    ////question fd

                    //if (_control)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

                    //    }
                    //}
                    //else //if (!loader.limit.NbFeedLimit)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                    ////question date
                    //if (_control && okDuration)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
                    //    limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
                    //    limit.signal(tb);
                    //}



                    //if (!_control && !Conf.BorderVirtual)
                    //    continue;
                    if (!okDate)
                        continue;

                    if (!_control)
                        continue;
                    //newDuration = currentDuration;
                    //okTotalDuration = newDuration <= durationMax;
                    if (!okTotalDuration)
                    {
                        //if (!Logger.CreateNullLoggers)
                        //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                        {
                            // currentDuration = newDuration;
                            durationStop = currentDuration;
                        }

                    }

                    if (!okTotalDuration)
                        continue;


                    if (_selection && !newContribut)
                    {
                        // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            // log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }

                    //   currentDuration = newDuration;




                    if (_selection)
                    {
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        limit.Dir.recordTrack(candidat, limit);
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        //  limit.Dir.recordTrack(candidat, limit);

                        selected.Add(location, candidat);

                        if (select)
                            exclu.Add(location, candidat);
                    }





                }

            }
        }


        //private void selection0(List<TrackInfoItunes> list, bool select, bool increment)
        //{
        //    var duration = limit.Duration;
        //    var durationMax = timeSpan.FromMinutes(duration);
        //    var contributionMax = timeSpan.FromMinutes(limit.Contribution);

        //    int count = list.Count;
        //    for (int index = 0; index < count; index++)
        //    {
        //        TrackInfoItunes candidat = list[index];
        //        //foreach (TrackInfoItunes candidat in list)
        //        //{

        //        //if (candidat.Album == "Géopolitique")
        //        //{
        //        //}

        //        //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
        //        //{
        //        //}
        //        var location = candidat.Location;
        //        if (string.IsNullOrEmpty(location))
        //            continue;

        //        //if (_selection && selected.ContainsKey(location))
        //        //    continue;
        //        // vérification à postériori par rapports aux différents niveaux
        //        bool newContribut = candidat.Selected;

        //        DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
        //        bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
        //        var loader = getLoader(candidat.Album);
        //        bool okTotalDuration = false;
        //        bool _control = false;

        //        //tester uniquement fd et nb
        //        // _control = loader.control(candidat, select, false, false);

        //        // var _newDuration = currentDuration;
        //        //if (increment)
        //        //    _newDuration = currentDuration + candidat.Duree;

        //        // savoir si ça passe uniquement avec le critère d
        //        okTotalDuration = currentDuration <= durationMax;

        //        bool okprovi = okDate && okTotalDuration;
        //        bool ok = okDate && okTotalDuration && _control;

        //        // rejouer le controle pour incrémenter nb et fd      
        //        if (!increment) // données venant de sous-dossier (histo, voisins....)
        //        {
        //            _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //        }



        //        //if (!loader.LoadEqSel)
        //        //{

        //        //    if (_control)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
        //        //    else if (loader.EndByFd)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

        //        //}

        //        //if (!increment && !_selection) //!loader.LoadEqSel &&
        //        //{
        //        //    //  if (!loader.OkNb)
        //        //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
        //        //    // if (!loader.OkFd)
        //        //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

        //        //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //        //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //        //}

        //        //if (!control(candidat, select, okDuration))
        //        //    continue;

        //        if (increment)
        //        {
        //            var newDuration = currentDuration + candidat.Duree;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (manageByFd.ContainsKey(location))
        //            {
        //                _control = false;
        //                if (selectedByFd.ContainsKey(location))
        //                    _control = true;
        //            }
        //            else
        //            {
        //                _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

        //            }

        //            if (_control)
        //            {
        //                //currentDurationVirtual += candidat.Duree;
        //                if (okDate)
        //                    currentDuration += candidat.Duree;
        //            }


        //            // newDuration = currentDuration;
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //            //  okTotalDuration = newDuration <= durationMax;



        //            //okTotalDuration = newDuration <= durationMax;
        //            //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

        //            //if (okDate && _control)
        //            //    currentDuration += candidat.Duree;
        //            //currentDurationVirtual = currentDuration; // += candidat.Duree;

        //            //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

        //            //  bool okTotalDuration = newDuration <= durationMax;

        //            if (!_selection)
        //            {


        //                var _fd = loader.getCurrentDuration(false);

        //                if (_fd > newDuration)
        //                {
        //                    newDuration = _fd;
        //                    okTotalDuration = newDuration <= durationMax;
        //                }
        //                if (_control)
        //                {
        //                }
        //                else
        //                {
        //                    //var fd = loader.getCurrentDuration(true);
        //                    //var nb = loader.getNb(true);

        //                    //newDuration = new timeSpan();
        //                    //foreach (FeedLimitItemLoader l in loaders.Values)
        //                    //    l.phaseTest();
        //                    //for (int j = 0; j <= index; j++)
        //                    //{
        //                    //    TrackInfoItunes t = list[j];
        //                    //    var subloader = getLoader(t.Album);
        //                    //    var subok = subloader.test(nb, fd, t);
        //                    //    if (j >= subloader.IndexBase)
        //                    //    {
        //                    //        if (subok || selectedByFd.ContainsKey(location))
        //                    //            newDuration += t.Duree;
        //                    //    }

        //                    //}
        //                    //// newDuration += getDuration(nb, fd);

        //                    //if (newDuration < currentDuration)
        //                    //{
        //                    //}
        //                    //else if (newDuration > currentDurationVirtual)
        //                    //{
        //                    //}
        //                    //okTotalDuration = newDuration <= durationMax;
        //                }


        //                //question fd
        //                //if (!loader.LoadEqSel)
        //                //{
        //                var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //              loader.OkFd, loader.getDurationStop(okDate)
        //              , loader.OkNb, loader.getNbStop(okDate)
        //              , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

        //                limit.Dir.CauseRegister.signal(dataRoot);

        //                var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //                    //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
        //                    //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
        //                    //, okTotalDuration, newDuration, candidat, limit);
        //                        loader.OkFd, _fd// loader.getCurrentDuration (false)
        //                , loader.OkNb, loader.getNb(false)
        //                , okTotalDuration, newDuration, candidat, limit);

        //                limit.signal(dataAuto);
        //            }




        //            //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
        //            //loader.OkFd, loader.getDurationStop(okDate)
        //            //, loader.OkNb, loader.getNbStop(okDate)
        //            //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

        //            //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //            //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //            //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

        //            if (Conf.BorderTb)
        //            {
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
        //                else if (okDate && okTotalDuration)
        //                {
        //                    if (loader.EndByFd)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
        //                }
        //                //else if (Conf.BorderVirtual)
        //                //{
        //                //    if (_control)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
        //                //    else if (loader.EndByFd)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
        //                //}


        //                //}

        //                //if (!loadEqSel)
        //                //{
        //                // question d
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
        //                else if (okDate && _control)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okTotalDuration)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
        //                }


        //                // question date
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
        //                else if (_control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okDate)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
        //                }

        //                //}

        //            }


        //            ////question duree
        //            //if (okDate && _control) // || Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
        //            //}

        //            ////question fd

        //            //if (_control)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

        //            //    }
        //            //}
        //            //else //if (!loader.limit.NbFeedLimit)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
        //            //        limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
        //            //        limit.signal(tb);
        //            //    }
        //            //}
        //            ////question date
        //            //if (_control && okDuration)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
        //            //    limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
        //            //    limit.signal(tb);
        //            //}



        //            //if (!_control && !Conf.BorderVirtual)
        //            //    continue;
        //            if (!okDate)
        //                continue;

        //            if (!_control)
        //                continue;
        //            newDuration = currentDuration;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (!okTotalDuration)
        //            {
        //                //if (!Logger.CreateNullLoggers)
        //                //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

        //                if (_selection)
        //                    limit.DurationLimitAtteinte = true;
        //                if (durationStop.Value == 0)
        //                {
        //                    // currentDuration = newDuration;
        //                    durationStop = currentDuration;
        //                }

        //            }

        //            if (!okTotalDuration)
        //                continue;


        //            if (_selection && !newContribut)
        //            {
        //                // pour l'instant ? on ne gère pas la contribtion en mode rejeu

        //                currentContrib += candidat.Duree;
        //                if (currentContrib > contributionMax)
        //                {
        //                    //  log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
        //                    limit.ContributionLimitAtteinte = true;
        //                    break;
        //                }

        //                use.Add(candidat);
        //            }

        //            //   currentDuration = newDuration;




        //            if (_selection)
        //            {
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                limit.Dir.recordTrack(candidat, limit);
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                //  limit.Dir.recordTrack(candidat, limit);

        //                selected.Add(location, candidat);

        //                if (select)
        //                    exclu.Add(location, candidat);
        //            }





        //        }

        //    }
        //}

        public LimitItem Item { get { return limit; } }
        public override string ToString()
        {
            return limit.ToString();
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;

using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.util;
using pdb.podcast.Report;
using System.Xml;
using pdb.podcast.Selection;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public class LimitsLoader
    {
        private DirConf dir;
        private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
        public loadState state;
      //  private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
            this.limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
          //  log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void getLoaders(List<LimitItemLoader> list)
        {
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].getLoaders(list);
            }
        }

        private bool candidatLoaded;
        public void loadCandidats()
        {
            if (candidatLoaded)
            {
                foreach (LimitLoader item in limites)
                {
                    item.reset();
                }
                return; 
            }
            try
            {
                var feeds = dir.Feeds;
                string feedName = null;
                bool histo = dir.Histo;
                bool? histoAll = dir.HistoAll;
                if (histo && false.Equals(histoAll))
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();



                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null)
                    {
                        if (track.Album != feedName)
                            continue;
                    }

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    loaded.Add(track);
                }

                if (histo)
                    loaded.Sort(new PodCastComparer());
                else
                    loaded.Sort(new PodCastComparerInv());


                for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
                {
                    var limit = limites[i];
                    limit.loadCandidats(loaded);

                }


            }
            finally
            {
                state = loadState.selection;
                candidatLoaded = true;
            }
        }

        private bool recordGuests;
        public void phase2()
        {
            state = loadState.selection;
            if (dir.Cascading)
                recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        {

            if (!recordGuests)
                return;


            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordGuest(track, item);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
            }
        }


        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                var list = dir.getListe();

                var limits = dir.Limites;
                var usegenPrior = Conf.GenUsePrior;
                var exclugenPrior = Conf.GenExcluPrior;

                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    List<TrackInfoItunes> items;
                    foreach (LimitItemLoader item in limit.Items)
                    {
                        // var index = limit.index(item);
                        if (Conf.WriteItems)
                        {
                            items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                            buildList(item.Item.ID, items, "_sel");
                        }

                        if (Conf.WritePreSel)
                        {
                            items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                            buildList(item.Item.ID, items, "_sel0");
                        }
                        if (Conf.WriteUse)
                        {
                            items = item.use;
                            buildList(item.Item.ID, usegenPrior, items, "_use");
                        }
                        if (Conf.WriteExclu)
                        {
                            var limite = item.Item;
                            items = item.use.FindAll(t => t.Exclu == limite);
                            buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                        }

                    }
                }

                //if (dir.Parent == null)
                //{
                if (dir.Parent == null)
                {

                    var lfolders = dir.Folders;

                    buildListPrior("_auto", list, lfolders);

                 

                    foreach (SelectParamBase listeSuppl in Conf.Listes)
                    {
                        var selector = new TrackSelector(listeSuppl);
                        var l = new List<TrackInfoItunes>();
                        foreach (TrackInfoItunes t in list)
                        {
                            if (selector.select(t))
                                l.Add(t); 
                        }
                       // var l = selector.getList(list,listeSuppl); // new List<TrackInfoItunes>();
                        //foreach (TrackInfoItunes t in list)
                        //{
                        //    if (t.Actu != listeSuppl.actu && listeSuppl.actu != null)                            
                        //        continue;
                        //    if (t.Info != listeSuppl.info && listeSuppl.info != null)
                        //        continue;
                        //    if (t.Rare != listeSuppl.rare && listeSuppl.rare != null)
                        //        continue;

                        //    l.Add(t); 
                        //}
                        buildListPrior(listeSuppl.name, l, lfolders);
                    }

                    //var lHisto = list.FindAll(t => t.Histo);
                    //buildList("_histo", lHisto, lfolders);

                    //var lPasHisto = list.FindAll(t => !t.Histo);
                    //buildList("_pasHisto", lPasHisto, lfolders);

                    //var lSerie = list.FindAll(t => t.Serial);
                    //buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, folders);
        }
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders,false);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0;
            foreach (TrackInfoItunes track in list)
            {
                nb++;
                writer.StartElement("t");
                writer.SetAttribute("date", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));

                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }

                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                writer.SetAttribute("track", track.Name);

                if (track.Pub2 > track.Pub)
                    writer.SetAttribute("pub2", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                if (nb <= nbmax)
                {
                    WriteCause(dir.CauseRegister.Get(track), true, true);
                    WriteCause(dir.CauseRegister.Get(track), true, false);
                    WriteCause(dir.CauseRegister.Get(track), false, true);
                    WriteCause(dir.CauseRegister.Get(track), false, false);

                }
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodCastComparerPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (false != dir.HistoAll)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;


                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    writer.StartElement("i");
                    writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());

                    writeTracks(dir, lim.Stat, null, false);

                    writer.EndElement();
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes, bool strict, bool ok)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses(strict, ok, ok))
            {
                string str = "cause";
                if (strict)
                    str += "strict";
                if (!ok)
                    str += "nok";
                writer.StartElement(str);


                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString());
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause > 0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0;
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list = dir.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break;
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        if (track.Pub2 > track.Pub)
                            writer.SetAttribute("pub2", track.Pub2);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes, true, true);
                        WriteCause(causes, true, false);

                        WriteCause(causes, false, true);
                        WriteCause(causes, false, false);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {

            //log.log("{0} Selection", dir);

            for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            {
                var limit = limites[i];
                limit.Selection();

            }

        }

        public override string ToString()
        {
            return dir.ToString();
        }

    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;

namespace pdb.podcast.Sort
{
    class Album
    {
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbRepecheForce = 0;
        public static int NbRepeches { get { return nbrepeches; } }
        public static int NbModif { get { return nbModif; } }
        private bool done;
        public static void Init()
        {
            //lastReads.Clear(); 
            nbrepeches = 0;
            nbModif = 0;
            nbRepecheForce = 0;
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }

        //public void Build(Loader loader)
        //{

        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;
        //    int indexLastRead = -1;
        //    int indexNextSelected = -1;
        //    DateTime lastPlayed = DateTime.MinValue;
        //    TrackSort next = null;
        //    TrackSort reallyLastRead = null;
        //    DateTime currentPub = DateTime.MinValue;
        //    DateTime currentPub2 = DateTime.MinValue;
        //    TrackSort lastRead = null;



        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        if (track.Selected)
        //        {
        //            next = track;
        //            indexNextSelected = i;
        //            break;
        //        }
        //    }

        //    if (next == null)
        //        return;

        //    int nbRead = 0;
        //    int nbTotal = 0;

        //    var histo = conf.getHisto(album.Rare);

        //    DateTime limit = next.Pub.AddDays(-histo);
        //    for (int i = indexNextSelected - 1; i >= 0; i--)
        //    {
        //        var t = list[i];
        //        var dt = t.Pub;
        //        if (dt < limit)
        //            break;

        //        if (t.Played)
        //            nbRead++;

        //        if (t.Played || t.track.Enabled)
        //            nbTotal++;

        //    }
        //    double delta = conf.getIntervalle(album.Rare);
        //    var intervalle = conf.getIntervalle(album.Rare);
        //    var intervalleMin = conf.getIntervalleMin(album.Rare);
        //    if (nbRead > 0 && nbTotal > 0)
        //    {
        //        //  album.Rare ? conf.intervalleR : conf.intervalle;
        //        var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

        //        delta = (intervalle * (double)nbTotal) / (ecouteMax * (double)nbRead);
        //        var coeff = (double)nbTotal / (double)nbRead;

        //        //0.1 => 10
        //        //0.9 => 1.11
        //        coeff -= 1; // 9  0.11
        //        var dminmax = intervalle - intervalleMin;

        //        var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

        //        if (_delta < delta)
        //            delta = _delta;
        //        else
        //        {
        //        }
        //    }


        //    var deltaLecture = (DateTime.Now - reallyLastRead.PlayedDate).TotalDays;



        //    for (int j = 0; j < indexNextSelected; j++)
        //    {
        //        for (int i = j; i < indexNextSelected; i++)
        //        {
        //            var track = list[i];
        //            if (track.Played)
        //            {
        //                reallyLastRead = track;
        //                lastRead = track;
        //                indexLastRead = i;
        //                lastPlayed = track.PlayedDate;
        //                j = i;
        //                break;
        //            }
        //        }
        //        var pub2 = lastRead.Pub2;

        //        if (conf.extPente > 0)
        //        {
        //            var d0 = (DateTime.Now - pub2).TotalDays;
        //            var dl = conf.extDelta;
        //            if (dl == 0)
        //            {
        //                dl = d0;
        //            }

        //            delta = d0 / conf.extPente;
        //            //01/01/2014 ->01/01/2017
        //            //04/01/2017 -> 04/01/2014
        //            var dateLimitEcoule = DateTime.Now.AddDays(-dl);

        //            var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
        //            log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

        //            if (deltaLimiteEcoule > delta)
        //                delta = deltaLimiteEcoule;

        //            if (delta < 1)
        //                delta = 1;



        //        }

        //        if (conf.limitRead && deltaLecture > intervalle)
        //        {
        //            //13 /10 ->7
        //            var _old = delta;

        //            delta += intervalle - deltaLecture;
        //            log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
        //        }

        //        if (delta < intervalleMin)
        //            delta = intervalleMin;

        //        if (delta > intervalle)
        //            delta = intervalle;


        //        DateTime limitFuture = pub2.AddDays(delta);

        //        if (limitFuture.Second > 0)
        //        {
        //            limitFuture = new DateTime(limitFuture.Ticks - limitFuture.Ticks % TimeSpan.TicksPerMinute + TimeSpan.TicksPerMinute);
        //        }


        //        DateTime nextDate = limitFuture;
        //        int nb = 0;
        //        int nblissage = 0;
        //        double deltaMinute = 1;

        //        if (conf.noCollision)
        //            deltaMinute = TimeSpan.FromDays(delta).TotalMinutes;

        //        if (conf.deltaConst)
        //        {

        //        }

        //        else
        //        {
        //            var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
        //            var _deltaRab = limitFuture.AddDays(conf.deltaRab);

        //            for (int i = indexLastRead + 1; i < list.Count; i++)
        //            {
        //                var t = list[i];
        //                if (t.Pub >= limitFuture)
        //                {
        //                    nextDate = t.Pub;
        //                    nblissage++;
        //                    if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
        //                        break;
        //                }
        //                nb++;
        //            }

        //            if (nextDate > limitFuture && nb > 0 && conf.noCollision)
        //                deltaMinute = (nextDate - limitFuture).TotalMinutes / (double)nb;
        //        }

        //        if (deltaMinute < 1)
        //            deltaMinute = 1;



        //        nb = 0;
        //        for (int i = indexLastRead + 1; i < count; i++)
        //        {

        //            var t = list[i];

        //            if (!t.Selected && conf.enabled != sortMode.reset)
        //                continue;
        //            if (!t.track.Enabled)
        //                continue;
        //            var dt = limitFuture.AddMinutes(deltaMinute * nb);
        //            var _delta = (dt - lastRead.Pub2).TotalDays;

        //            if (t.Pub >= dt || conf.enabled == sortMode.reset)
        //                t.increasePub(t.Pub);
        //            else
        //            {
        //                t.increasePub(dt);
        //                nb++;
        //            }


        //        }
        //    }

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        if (!track.Selected)
        //            continue;
        //        var pub2 = track.Pub2;
        //        var newPub = track.getPub();

        //        if (newPub != pub2)
        //        {
        //            writeComment(track, newPub);
        //        }
        //    }









        //    //  log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", delta.ToString("#.##"), nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));









        //    for (int i = 0; i < list.Count; i++)
        //    {
        //        var track = list[i].track;

        //        if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
        //        {
        //            var aux = currentPub2.AddMinutes(1);
        //            log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
        //            track.Pub2 = aux;
        //        }

        //        currentPub = track.Pub;
        //        currentPub2 = track.Pub2;
        //    }


        //}


        public void init()
        {
            done = false;
        }

        public void buildAll()
        {
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

          

            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                var dt = track.Pub2.AddSeconds(1);
                build(false, false, dt, dt);
                if (dt >= Conf.Date0)
                    break; 
            }

            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                applyPub(track); 
            }
        }

        private void build(bool checkSelected, bool apply, DateTime date0, DateTime newDate0)
        {

            int count = list.Count;
            if (count == 0)
                return;
            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <=date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                            
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Pub2 >= date0)
                    {
                        next = track;
                        indexNextSelected = i;
                        break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, false);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, checkSelected, apply, date0, newDate0); 
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }

        public void build()
        {
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            if (conf.enabled == sortMode.histo)
            {
                buildAll();
                return;
            }
            else
            {
                build(true, true, Conf.Date0, Conf.NewDate0);
                return; 
            }

            if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true,true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, true);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, true, true, Conf.Date0, Conf.NewDate0); 
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }


        }

        //private void writeComment(TrackInfoItunes track)
        //{
        //    string comment = track.Pub.ToString("yyyy/MM/dd HH:mm");
        //    if (track.Pub2 > track.Pub)
        //        comment = string.Format("{0}|{1}", track.Pub2.ToString("yyyy/MM/dd HH:mm"), track.Pub.ToString("yyyy/MM/dd HH:mm"));

        //    if (comment != track.Comment)
        //        track.Comment = comment;
        //}

        private void eraseSort(TrackSort track, bool force, bool apply)
        {
            if (!apply)
            {
                track.Pub2 = track.Pub;
                return; 
            }
            if (!force && !track.Selected)
                return;
            if (conf.canGoBack || conf.enabled == sortMode.reset)
            {
                DateTime pub = track.Pub;
                if (track.Pub2 >= Conf.Date0 && pub < Conf.Date0)
                {
                    log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
                    nbrepeches++;
                    // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                }
                else if (track.Pub2 >= Conf.NewDate0 && pub < Conf.NewDate0)
                {
                    log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
                    nbrepeches++;
                    // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                }

                //}
                //else
                //{
                if (track.Pub2 != track.Pub)
                    nbModif++;
                track.Pub2 = track.Pub;
                //}
                track.track.BuildComment();
                // writeComment(track);
            }
        }

        private void applyPub(TrackSort track)
        {
            writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0); 
        }

        private void writeComment(TrackSort track, DateTime dt, bool checkSelected, bool apply, DateTime date0, DateTime newDate0)
        {
            if (!apply)
            {
                track.Pub2 = dt;
                return; 
            }


            if (checkSelected && !track.Selected)
                return;

       
            if (conf.canGoBack)
            {
                if (track.pub20 >= date0 && dt < date0)
                {
                    if (conf.canGoBackButForceSelected)
                    {
                        log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                        nbRepecheForce++;
                        dt = date0.AddMinutes(nbRepecheForce);
                    }
                    else
                    {
                        log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                        nbrepeches++;
                    }
                }

                else if (track.pub20 >= newDate0 && dt < newDate0)
                {

                    if (conf.canGoBackButForceSelected)
                    {
                        log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                        nbRepecheForce++;
                        dt = Conf.Date0.AddMinutes(nbRepecheForce);
                    }
                    else
                    {
                        log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.pub20, dt, newDate0);
                        nbrepeches++;
                    }

                }
            }
            else
            {
                if (dt == track.pub20)
                {
                    log.log("\t{0}\t{1} {2}", track.Pub, dt, track.Name);
                    return;
                }
                else if (dt < track.pub20)
                {
                    log.log("\t{0}\t{1}<=\t{2} {3}", track.Pub, track.pub20, dt, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var strDelta = delta.ToString("0.0");

            if (track.pub20 != dt)
            {

                nbModif++;
                log.log("\t{0}\t{1}=>\t{2}({3}) {4}", track.Pub, track.pub20, dt, strDelta, track.Name);
                track.Pub2 = dt;
            }
            else if (track.pub20 > track.Pub)
            {
                log.log("\t{0}\t{1}({2}) {3}", track.Pub, track.pub20, strDelta, track.Name);
            }


            track.track.BuildComment();
        }

        private static double borne(double coeff, double intervalle, double intervalleMin)
        {
            if (coeff < 1)
                return coeff * intervalleMin;
            coeff -= 1; // 9  0.11
            var dminmax = intervalle - intervalleMin;

            var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

            return _delta;
        }

        private static double borneCumul(double delta, double cumulMin, double cumulMax)
        {
            if (cumulMin < 0 || cumulMax < 0)
                return delta;
            if (delta < cumulMin)
                return delta;
            var coeff = delta / cumulMin;
            return borne(coeff, cumulMax, cumulMin);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Sort\Sorter.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using pdb.podcast.Tuning.Sort;
using pdb.iit;

namespace pdb.podcast.Sort
{
    class Sorter
    {
        private List<TrackInfoItunes> tracks;
        private pdb.podcast.Tuning.Sort.Sort sort;
        private Dictionary<string, Album> dict = new Dictionary<string, Album>();

        public Sorter(pdb.podcast.Tuning.Sort.Sort sort, IEnumerable<TrackInfoItunes> _list)
        {
            this.sort = sort;
            tracks = new List<TrackInfoItunes>();
            //   timeSpan limit = timeSpan.FromMinutes(sort.dureeMin); 
            foreach (TrackInfoItunes t in _list)
            {
                // if (t.Duree >= limit)
                tracks.Add(t);
            }
            tracks.Sort(new PodCastComparer());
        }


        private void check(TrackInfoItunes track)
        {
            var album = track.TrackAlbum;

            string key = album.Album.ToLowerWithoutDiacritics();
            if (string.IsNullOrEmpty(key))
            {
                misc.log("pas d'album pour " + track);
                return;
            }

            if (!dict.ContainsKey(key))
            {
                SortItem item = sort;
                var _surcharge = sort.getItem(key);

                if (_surcharge != null)
                {
                    item = _surcharge;
                    Album found = null;
                    foreach (string sub in _surcharge.name)
                    {
                        if (dict.ContainsKey(sub))
                        {
                            found = dict[sub];
                            found.check(track);
                            return;
                        }
                    }
                }
                else
                {
                    var _rule = sort.getRule(album);
                    if (_rule != null)
                        item = _rule; 
                }


                Album a = new Album(item, album);
                if (_surcharge != null)
                {
                    foreach (string sub in _surcharge.name)
                        dict.Add(sub, a);
                }
                else
                    dict.Add(key, a);
            }
            dict[key].check(track);
        }


        public void build()
        {
            Album.Init();
            foreach (TrackInfoItunes track in tracks)
            {
                check(track);
            }

            foreach (Album a in dict.Values)
            {
                a.init();
            }

            foreach (Album a in dict.Values)
            {
                a.build();
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Xml;

namespace pdb.podcast.Tuning
{
    public class ConfAlbums : ConfAlbum
    {
        public ConfAlbums()
        {
        }

        public ConfAlbums(XmlElement node)
            : base(null,node)
        {
            items = new List<ConfAlbum>(); 
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement && sub.Name == "album")
                {
                    items.Add(new ConfAlbum(node, sub as XmlElement));
                }
            }
        }

        public ConfAlbum getItem(string album)
        {
            foreach (ConfAlbum g in items)
            {
                if (g.name.Contains(album))
                    return g;

            }
            return null;
        }

        private List<ConfAlbum> items = new List<ConfAlbum>();
        public List<ConfAlbum> Items { get { return items; } }
    }

    public class ConfAlbum : LimitItemBase
    {
        public bool checkPub;
        public bool checkDoublon;

        /// <summary>
        /// nom de l'album ou suite d'albums
        /// </summary>
        public List<string> name = new List<string>();
        public readonly string Names; 

        public ConfAlbum() {
        }

        public ConfAlbum(XmlElement parent, XmlElement node)
            : base(parent, node)
        {
            if (node == null)
                return;
            name = new List<string>();
            buildb("checkPub", v => checkPub = v);
            buildb("checkDoublon", v => checkDoublon = v);

            this.build(parent, node); 

            var str = "";
            builds("name", v => str = v);
            Names = str; 

            if (!string.IsNullOrEmpty(str))
            {
                foreach (string album in str.Split('|'))
                {
                    if (!string.IsNullOrWhiteSpace(album))
                        name.Add(album); 
                }
            }
        }
    }

}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.ordo.conf;
using pdb.podcast.Auto;
using pdb.util;

namespace pdb.podcast.Tuning
{
    public enum menage
    {
        none,
        read,
        name
    }
    public class Conf
    {
        //private static string CONF_FILE = @"..\conf.xml";
        #region membres
        private DirConf root;
        private bool buildLimitMulti;
        private bool single;
        private Move move;
        private bool deleteDoublon;
        private bool getDescription;
        private int volumeMin = int.MinValue;
        private bool simulation;
        private string copyAll;
        private int maxScan = 10;
        private ConfOrdo ordo = new ConfOrdo();
        private menage menage = menage.none;
        private string poubelle = "";
        // private string zique;
        private bool writePlayLists;
        private bool writePreSel;
        private bool writeItems;
        private bool writeUse;
        private bool writeExclu;
        private bool genFeed;
        private int genFeedPrior = 11;
        private int genUsePrior = 11;
        private int genExcluPrior = 11;
        private bool transmit = true;
        private bool transmitTotal = true;
        private bool transmitTotalGuest = true;
        private bool? cascading = null;
        private bool autoBlock;

        private ConfDate dates = new ConfDate();

        private List<SelectParam> selectParams = new List<SelectParam>();
        private Journal journal;
        private RootIt rootIt = new RootIt();
        private bool onlyEnabled = true;
        private bool onlyUnRead = true;
        private bool checkExist = true;

        // private Auto auto = null;
        private bool logGen = true;
        private DateTime date0;
        private DateTime date00;
        private double deltaOpen = 60; 
        private Html html = new Html();

        private bool autoSequence = true;
        private bool borderVirtual;
        private bool borderIdem;
        private bool borderGranSlam;
        private bool borderTb;
        private bool autoSelect;
        private bool logDir;

        private Export export = new Export();
        private Hibernate import = new Hibernate();
        private Sort.Sort sort = new Sort.Sort();
        private Hibernate hibernate = new Hibernate();
        private Db db = new Db();
        private ConfAlbums albums = new ConfAlbums();
        private Listes listes = new Listes();


        private bool checkPub = true;

        private bool useMock;


        #endregion
        public static readonly Conf Instance = new Conf();
        private static bool started;
        private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
        public void setConfFile(string conf)
        {
            this.confFile = new FileInfo(@"..\" + conf);
        }

        #region getters
        public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
        public static bool Single { get { return Instance.single; } }
        public static DirConf DirConf { get { return Instance.root; } }
        public static Move Move { get { return Instance.move; } }
        public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
        public static bool GetDescription { get { return Instance.getDescription; } }
        public static int VolumeMin { get { return Instance.volumeMin; } }
        public static bool Simulation { get { return Instance.simulation; } }
        public static string CopyAll { get { return Instance.copyAll; } }
        public static ConfOrdo Ordo { get { return Instance.ordo; } }
        public static int MaxScan { get { return Instance.maxScan; } }
        public static menage Menage { get { return Instance.menage; } }
        public static string Poubelle { get { return Instance.poubelle; } }
        public static bool WritePlayLists { get { return Instance.writePlayLists; } }
        public static bool WritePreSel { get { return Instance.writePreSel; } }
        public static bool WriteItems { get { return Instance.writeItems; } }
        public static bool WriteUse { get { return Instance.writeUse; } }
        public static bool WriteExclu { get { return Instance.writeExclu; } }
        public static bool GenFeed { get { return Instance.genFeed; } }
        public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
        public static int GenUsePrior { get { return Instance.genUsePrior; } }
        public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

        public static bool Transmit { get { return Instance.transmit; } }
        public static bool TransmitTotal { get { return Instance.transmitTotal; } }
        public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
        public static bool? Cascading { get { return Instance.cascading; } }
        public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
        public static DateTime DateLevel { get { return Instance.dates.Level; } }
        internal static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
        internal static Journal Journal { get { return Instance.journal; } }
        internal static RootIt RootIt { get { return Instance.rootIt; } }

        public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
        public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }
        public static bool CheckExist { get { return Instance.checkExist; } }

        public static bool AutoBlock { get { return Instance.autoBlock; } }
        public static bool LogGen { get { return Instance.logGen; } }

        internal static Html Html { get { return Instance.html; } }

        public static bool AutoSequence { get { return Instance.autoSequence; } }
        public static bool BorderVirtual { get { return Instance.borderVirtual; } }
        public static bool BorderIdem { get { return Instance.borderIdem; } }
        public static bool BorderGranSlam { get { return Instance.borderGranSlam; } }
        public static bool BorderTb { get { return Instance.borderTb; } }
        public static bool AutoSelect { get { return Instance.autoSelect; } }
        public static Export Export { get { return Instance.export; } }
        internal static Hibernate Import { get { return Instance.import; } }
        public static Sort.Sort Sort { get { return Instance.sort; } }
        public static ConfAlbums Albums { get { return Instance.albums; } }
        internal static Hibernate Hibernate { get { return Instance.hibernate; } }
        internal static Db Db { get { return Instance.db; } }
        /// <summary>
        /// muy important. on calcule les dates max avec pub plutôt que Pub2
        /// </summary>
      //  public static bool CheckPub { get { return Instance.checkPub; } }
        public static bool UseMock { get { return Instance.useMock; } }
        public static bool LogDir { get { return Instance.logDir; } }
        public static double DeltaOPen { get { return Instance.deltaOpen; } }
        internal static Listes Listes { get { return Instance.listes; } }



        //  public static string Zique { get { return Instance.zique; } }
        #endregion

        private DateTime lastModif = DateTime.MinValue;
        private FileInfo confFile;
        public FileInfo ConfFile { get { return confFile; } }
        #region load

        public XmlElement load(bool waitForModification)
        {

            while (true)
            {
                confFile.Refresh();
                if (!confFile.Exists)
                    throw new ApplicationException(confFile + " n'existe pas !!");
                DateTime dt = confFile.LastWriteTime;
                if (dt > lastModif || !waitForModification)
                    break;
                Thread.Sleep(1000);
            }

            lastModif = confFile.LastWriteTime;

            XmlDocument l_doc = new XmlDocument();
            l_doc.Load(confFile.FullName);

            XmlElement xroot = l_doc.DocumentElement;
            XMLTool l_xmlConf = new XMLTool(xroot);

            string str = l_xmlConf.getNodeValue("volumeMin");
            if (!string.IsNullOrEmpty(str))
                volumeMin = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("maxScan");
            if (!string.IsNullOrEmpty(str))
                maxScan = Convert.ToInt32(str);

            buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
            simulation = l_xmlConf.getBoolValue("simulation");
            //   zique = l_xmlConf.getNodeValue("zique");

            deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
            getDescription = l_xmlConf.getBoolValue("getDescription");
            copyAll = l_xmlConf.getNodeValue("copyAll");

            poubelle = l_xmlConf.getNodeValue("poubelle");

            str = l_xmlConf.getNodeValue("menage");
            if (!string.IsNullOrEmpty(str))
                menage = (menage)(Enum.Parse(typeof(menage), str, true));

            writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
            writePreSel = l_xmlConf.getBoolValue("writePreSel");
            writeItems = l_xmlConf.getBoolValue("writeItems");
            writeUse = l_xmlConf.getBoolValue("writeUse");
            writeExclu = l_xmlConf.getBoolValue("writeExclu");
            genFeed = l_xmlConf.getBoolValue("genFeed");
            str = l_xmlConf.getNodeValue("genFeedPrior");
            if (!string.IsNullOrEmpty(str))
                genFeedPrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genUsePrior");
            if (!string.IsNullOrEmpty(str))
                genUsePrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genExcluPrior");
            if (!string.IsNullOrEmpty(str))
                genExcluPrior = Convert.ToInt32(str);

            transmit = l_xmlConf.getBoolValue("transmit");
            transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
            transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
            onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
            onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
            checkExist = l_xmlConf.getBoolValue("checkExist", true);
            str = l_xmlConf.getNodeValue("cascading");
            if (!string.IsNullOrEmpty(str))
                cascading = "true".Equals(str);
            //  cascading = l_xmlConf.getBoolValue("cascading");

            str = l_xmlConf.getNodeValue("date0");
            if (!string.IsNullOrEmpty(str))
                date0 = Convert.ToDateTime(str);

            str = l_xmlConf.getNodeValue("date00");
            if (!string.IsNullOrEmpty(str))
                date00 = Convert.ToDateTime(str);

            var xDates = l_xmlConf.NodeLookUp("playedDates");
            dates = new ConfDate(xDates);

            logGen = l_xmlConf.getBoolValue("logGen");
            var createNullLoggerOrg = Logger.CreateNullLoggers;

            Logger.CreateNullLoggers = !logGen;
            XmlElement xDir = l_xmlConf.NodeLookUp("dir");

            var rootLimit = new Limits();
            buildLimit(xDir, rootLimit, null);

            root = DirConf.getDir(rootLimit, xDir.Attributes["name"].InnerText, null); //new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
            root.build(null, xDir);
            buildDirChilds(xDir, root);

            // AutoBuilder.getLoaders(); 

            XmlElement xMove = l_xmlConf.NodeLookUp("move");
            move = new Move(xMove);

            ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

            selectParams.Clear();

            var xSelect = l_xmlConf.NodeLookUp("select");
            if (xSelect != null)
            {
                foreach (XmlNode xsub in xSelect)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        selectParams.Add(new SelectParam (xSelect, x));
                }
            }

            journal = null;
            var xJournal = XMLTool.NodeLookUp(xroot, "journal");
            if (xJournal != null)
            {
                journal = new Tuning.Journal();
                buildLimitItem(xJournal, xJournal, journal);
                var xxJournal = new XMLTool(xJournal);
                journal.NbJour = xxJournal.getIntAttValue("nbJour");
            }

            rootIt = new Tuning.RootIt(l_xmlConf.NodeLookUp("rootIt")); //  l_xmlConf.getNodeValue("rootIt");

            autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
            //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
            //if (xAuto == null)
            //    auto = null;
            //else
            //    auto = new Auto(xAuto);

            XmlElement xHtml = l_xmlConf.NodeLookUp("html");
            html = new Html(xHtml);

            autoSequence = l_xmlConf.getBoolValue("autoSequence", true);
            borderVirtual = l_xmlConf.getBoolValue("borderVirtual", false);
            borderIdem = l_xmlConf.getBoolValue("borderIdem", false);
            borderGranSlam = l_xmlConf.getBoolValue("borderGranSlam", false);
            borderTb = l_xmlConf.getBoolValue("borderTb", false);
            autoSelect = l_xmlConf.getBoolValue("autoSelect", false);
            checkPub = l_xmlConf.getBoolValue("checkPub", false);
            useMock = l_xmlConf.getBoolValue("useMock ", false);
            logDir = l_xmlConf.getBoolValue("logDir ", false);

            var xExport = l_xmlConf.NodeLookUp("export"); // export = l_xmlConf.getNodeValue("export");
            export = new Tuning.Export(xExport);

            var xImport = l_xmlConf.NodeLookUp("import"); // export = l_xmlConf.getNodeValue("export");
            import = new Tuning.Hibernate(xImport);

            var xSort = l_xmlConf.NodeLookUp("sort");
            sort = new Tuning.Sort.Sort(xSort);


            var xAlbums = l_xmlConf.NodeLookUp("albums");
            albums = new ConfAlbums(xAlbums);

            var xHibernate = l_xmlConf.NodeLookUp("hibernate");
            hibernate = new Hibernate(xHibernate);


            var xDb = l_xmlConf.NodeLookUp("db");
            db = new Db(xDb);


            Logger.CreateNullLoggers = createNullLoggerOrg;
            var xlistes = l_xmlConf.NodeLookUp("listes");
            listes = new Listes(xlistes);

            started = true;
            return xroot;

        }

        #region limites

        private void buildDirChilds(XmlNode node, DirConf parent)
        {
            AutoBuilder.setClient(parent, node);
            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "auto")
                {
                    AutoBuilder.build(child, parent);
                }
                else
                {
                    if (child.Name == "dir")
                    {
                        string name = (child.Attributes["name"].InnerText);
                        Limits childLimite = parent.Limites.Clone() as Limits;
                        DirConf sub = DirConf.getDir(childLimite, name, parent); // new DirConf(childLimite, name, parent);
                        sub.build(node, child);
                        //if (child.Attributes["d"] != null)
                        //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);



                        if (child.Attributes["all"] != null)
                        {
                            sub.HistoAll = child.Attributes["all"].Value == "true";
                        }
                        if (child.Attributes["serial"] != null)
                        {
                            sub.Serial = child.Attributes["serial"].Value == "true";
                        }

                        if (child.Attributes["cascading"] != null)
                            sub.Cascading = child.Attributes["cascading"].Value == "true";
                        if (child.Attributes["selectionPre"] != null)
                            sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                        if (child.Attributes["transmit"] != null)
                            sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                        if (child.Attributes["transmitTotal"] != null)
                            sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                        if (child.Attributes["transmitTotalGuest"] != null)
                            sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                        buildLimit(child, childLimite, sub);
                        parent.addChild(sub);
                        if (!started)
                            misc.log(sub.display());
                        buildDirChilds(child, sub);

                    }
                }
            }

        }

        private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
        {
            string strTd = child.InnerText;
            if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
                item.Td = Convert.ToInt32(strTd);

            AutoBuilder.setClient(item, child);

            //foreach (XmlNode sub in child.ChildNodes)
            //{
            //    if (sub.Name == "auto")
            //        AutoBuilder.build(sub, item);
            //}

            item.build(parent, child);

            //var dAtt0 = parent.Attributes["d"];
            //if (dAtt0 != null)
            //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

            //var dAtt = child.Attributes["d"];
            //if (dAtt != null)
            //    item.Duration = Convert.ToSingle(dAtt.InnerText);

            //var cAtt0 = parent.Attributes["c"];
            //if (cAtt0 != null)
            //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

            //var cAtt = child.Attributes["c"];
            //if (cAtt != null)
            //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

            //var fdAtt0 = parent.Attributes["fd"];
            //if (fdAtt0 != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

            //var fdAtt = child.Attributes["fd"];
            //if (fdAtt != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

            //var nbAtt0 = parent.Attributes["nb"];
            //if (nbAtt0 != null)
            //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
            //var nbAtt = child.Attributes["nb"];
            //if (nbAtt != null)
            //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

            //var dateAtt0 = parent.Attributes["date"];
            //if (dateAtt0 != null)
            //    item.DateMin = getDate(dateAtt0.InnerText);
            //var dateAtt = child.Attributes["date"];
            //if (dateAtt != null)
            //    item.DateMin = getDate(dateAtt.InnerText);

            //var dateAtt0Max = parent.Attributes["maxdate"];
            //if (dateAtt0Max != null)
            //    item.DateMax = getDate(dateAtt0Max.InnerText);
            //var dateAttMax = child.Attributes["maxdate"];
            //if (dateAttMax != null)
            //    item.DateMax = getDate(dateAttMax.InnerText);
        }

        private static bool date00Consumed;
        public static void date00Consume() { date00Consumed = true; }

        public static DateTime Date0
        {
            get
            {
                if (Instance.date00 == DateTime.MinValue || date00Consumed)
                    return Instance.date0;
                return Instance.date00;
            }
        }

        public static DateTime NewDate0
        {
            get
            {
                return Instance.date0;
            }
        }

        public static DateTime getDate(string str)
        {
            //int delta = -1;
            double d = -1;
            if (Date0 > DateTime.MinValue)
                //{
                //    if (int.TryParse(str, out delta))
                //    {
                //        int dt = delta;
                //        if (delta % 365 == 0)
                //        {
                //            dt = delta / 365;
                //            return Date0.AddYears(dt);
                //        }

                //        if (delta % 30 == 0)
                //        {
                //            dt = delta / 30;
                //            return Date0.AddMonths(dt);
                //        }
                //        return Date0.AddDays(delta);
                //    }
                //    else
                if (double.TryParse(str, out d))
                {
                    return Date0.AddDays(d);
                }
            //       }

            return Convert.ToDateTime(str);
        }

        private void buildLimit(XmlNode node, Limits limits, DirConf dir)
        {

            Limit[] tab = new Limit[Limits.NB];

            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "list")
                {

                    int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                    Limit limit = new Limit(level);
                    var items = new List<LimitItem>();

                    double tdMin = 0;
                    foreach (XmlNode xItem in child.ChildNodes)
                    {
                        //if (xItem.Name == "auto")
                        //{
                        //    AutoBuilder.build(xItem, limit);
                        //}
                        //else 
                        if (xItem.Name == "td")
                        {
                            var item = new LimitItem(limit);
                            item.TdMin = tdMin;
                            buildLimitItem(child, xItem, item);
                           

                            var itemTd = item.Td;
                            if (itemTd < int.MaxValue)
                                tdMin = item.Td;
                            items.Add(item);
                        }
                    }

                    if (items.Count == 0)
                    {
                        var defaultItem = new LimitItem(limit);
                        buildLimitItem(child, child, defaultItem);
                        items.Add(defaultItem);
                    }

                    limit.Items = items;

                    //var dAtt = child.Attributes["d"];
                    //if (dAtt != null)
                    //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                    //var fdAtt = child.Attributes["fd"];
                    //if (fdAtt != null)
                    //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                    //var nbAtt = child.Attributes["nb"];
                    //if (nbAtt != null)
                    //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                    tab[level] = limit;
                }

            }

            Limit current = null;
            bool oneTabAtLeast = false;
            //  LimitItem currentItem = null;

            double currentDuration = int.MaxValue;
            double lcurrentDuration = int.MaxValue;
            double currentContrib = int.MaxValue;
            double currentFeedDuration = int.MaxValue;
            double lcurrentFeedDuration = int.MaxValue;
            int currentNb = int.MaxValue;
            int lcurrentNb = int.MaxValue;

            double currentTd = int.MaxValue;

            double currentTdMin = int.MaxValue;
            DateTime currentDateMin = DateTime.MinValue;
            DateTime currentDateMax = DateTime.MaxValue;
           bool currentOverwrite = false; 

            for (int i = 0; i < Limits.NB; i++)
            {

                //if (tab[i] != null)
                //{

                if (tab[i] != null)
                {
                    current = tab[i];
                    oneTabAtLeast = true;

                }

                if (!oneTabAtLeast)
                    current = limits[i];

                var _limit = limits[i];
                _limit.Level = i;
                limits[i].Parent = limits;

                //foreach (LimitItem currentItem in current.Items)
                //{

                if (_limit.Items.Count != current.Items.Count)
                {
                    _limit.Items.Clear();
                }

                for (int j = 0; current != null && j < current.Items.Count; j++)
                {

                    var currentItem = current.Items[j];
                    // if (currentItem.Duration < int.MaxValue)
                    currentDuration = currentItem.Duration;
                    currentOverwrite = currentItem.OverwriteConf; 
                    lcurrentDuration = currentItem.LoadDuration;
                    //if (currentItem.Contribution < int.MaxValue)
                    currentContrib = currentItem.Contribution;
                    // if (currentItem.FeedDuration < int.MaxValue)
                    currentFeedDuration = currentItem.FeedDuration;
                    lcurrentFeedDuration = currentItem.LoadFeedDuration;

                    //   if (currentItem.Nb < int.MaxValue)
                    currentNb = currentItem.Nb;
                    lcurrentNb = currentItem.LoadNb;
                    //  if (currentItem.Td < int.MaxValue)
                    currentTd = currentItem.Td;
                    currentTdMin = currentItem.TdMin;

                    currentDateMin = currentItem.DateMin;
                    currentDateMax = currentItem.DateMax;
                    //}
                    //}

                    //if (current != null)
                    //{
                    LimitItem _limitItem = null;
                    if (j >= _limit.Items.Count)
                    {
                        _limitItem = currentItem.Clone() as LimitItem;
                        _limit.Items.Add(_limitItem);
                        _limitItem.Limit = _limit;

                    }
                    else
                    {
                        _limitItem = _limit.Items[j];

                    }
                    //if (currentDuration < int.MaxValue)
                    _limitItem.setDuration(currentDuration, false); // Duration = currentDuration;
                    _limitItem.LoadDuration = lcurrentDuration;
                    //if (currentContrib < int.MaxValue)
                    //    _limitItem.Contribution = currentContrib;
                    // if (currentFeedDuration < int.MaxValue)
                    _limitItem.setFeedDuration(currentFeedDuration, false); // FeedDuration = currentFeedDuration;
                    _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                    // if (currentNb < int.MaxValue)
                    _limitItem.setNbMax(currentNb, false);
                    _limitItem.LoadNb = lcurrentNb;
                    //   if (currentTd < int.MaxValue)
                    _limitItem.Td = currentTd;
                    _limitItem.TdMin = currentTdMin;
                    _limitItem.DateMin = currentDateMin;
                    _limitItem.setDateMax(currentDateMax, false);
                    _limitItem.Contribution = currentContrib;
                  _limitItem.OverwriteConf = currentOverwrite; 



                    if (dir != null)
                    {
                        if (_limitItem.Duration == int.MaxValue)
                            _limitItem.setDuration(dir.Duration, true); // Duration = dir.Duration;
                        if (_limitItem.LoadDuration == int.MaxValue)
                            _limitItem.LoadDuration = dir.LoadDuration;
                        if (_limitItem.Contribution == int.MaxValue)
                            _limitItem.Contribution = dir.Contribution;
                        if (_limitItem.Td == int.MaxValue)
                            _limitItem.Td = dir.Td;
                        if (_limitItem.Nb == int.MaxValue)
                            _limitItem.setNbMax(dir.Nb, true);
                        if (_limitItem.LoadNb == int.MaxValue)
                            _limitItem.LoadNb = dir.LoadNb;
                        if (_limitItem.FeedDuration == int.MaxValue)
                            _limitItem.setFeedDuration(dir.FeedDuration, true);
                        if (_limitItem.LoadFeedDuration == int.MaxValue)
                            _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                        if (_limitItem.DateMin == DateTime.MinValue)
                            _limitItem.DateMin = dir.DateMin;
                        if (_limitItem.DateMax == DateTime.MaxValue)
                            _limitItem.setDateMax(dir.DateMax, true);
                    }

                    _limitItem.setParent(dir);

                }

                //}
                // }

            }

        }
        #endregion
        #endregion

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\LimitItem.cs">
    <content><![CDATA[using System;
using pdb.util;
using pdb.podcast.Report;
using pdb.podcast.Auto;
using System.Collections.Generic;
using pdb.podcast.Selection;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Item de limite concernant la durée 
    /// </summary>
    public class LimitItem : LimitItemBase//, IBuilderSource, IBorder
    {


        /// <summary>
        /// Détailler le rapport - à bouger
        /// </summary>
        public static bool includeDetail;


        public int Level { get { return limit.Level; } }
        public int Rating { get { return limit.Level * 20; } }



        private Limit limit;
        private TripleStat stats = new TripleStat();


        public override string ToString()
        {
            if (nb == 0 || feedDuration == 0)
                return Dir.ToString() + string.Format("\\{0}", limit.Level);
            return Dir.ToString() + string.Format("\\{0}:{1} {2} {3} {4} {5} {6} {7} {8} {9}", limit.Level, getS("d", duration), getS("c", contribution), getS("fd", feedDuration), getS("nb", nb), getS("td", td), getS("tdMin", tdMin), getS("date", dateMin), getS("dateMax", dateMax), getS("dateMax2",dateMax2));
        }

        private static string getS(string desc, int v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}={1}", desc, v);
            return "";
        }

        private static string getS(string desc, double v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}={1}", desc, v);
            return "";
        }

        private static string getS(string desc, DateTime v)
        {
            if (v > DateTime.MinValue && v < DateTime.MaxValue)
                return string.Format("{0}={1}", desc, v);
            return "";
        }



        public void recordTrackMoy(TrackInfoItunes track, int countItems)
        {
            stats.recordTrack(track, countItems);
        }


        private bool durationLimitAtteinte;
        private bool contributionLimitAtteinte;
        private bool durationFeedLimit;
        private bool nbFeedLimit;
        public bool DurationLimitAtteinte { get { return durationLimitAtteinte; } set { durationLimitAtteinte = value; } }
        public bool ContributionLimitAtteinte { get { return contributionLimitAtteinte; } set { contributionLimitAtteinte = value; } }
        //private bool loadDurationLimitAtteinte;
        //public bool LoadDurationLimitAtteinte { get { return loadDurationLimitAtteinte; } set { loadDurationLimitAtteinte = value; } }

        public bool DurationFeedLimit { set { durationFeedLimit = value; } get { return durationFeedLimit; } }
        public bool NbFeedLimit { set { nbFeedLimit = value; } get { return nbFeedLimit; } }

        #region border
        //public bool checkPub(TrackInfoItunes candidat)
        //{
        //    var d = candidat.Pub;
        //    if (d < dateMin)
        //        return false;
        //    if (d > dateMax)
        //        return false;
        //    return true;
        //}
        #endregion
        //#region border
        ///// <summary>
        ///// track In le plus près de la limite dateMin
        ///// </summary>
        //TrackInfoItunes borderDateMinIn;
        ///// <summary>
        ///// Track rejeté le plus près de la limite dateMin
        ///// </summary>
        //TrackInfoItunes borderDateMinOut;

        ///// <summary>
        ///// track In le plus près de la limite dateMax
        ///// </summary>
        //TrackInfoItunes borderDateMaxIn;
        ///// <summary>
        ///// Track rejeté le plus près de la limite dateMax
        ///// </summary>
        //TrackInfoItunes borderDateMaxOut;

        ///// <summary>
        ///// Dernier accepté par rapport à la durée totale
        ///// </summary>
        //TrackInfoItunes borderDurationIn;
        ///// <summary>
        ///// Premier rejeté par rapport à la durée totale
        ///// </summary>
        //TrackInfoItunes borderDurationOut;

        //TimeSpan borderDurationValueIn;
        //TimeSpan borderDurationValueOut;

        ///// <summary>
        ///// Dernier accepté par rapport à la durée de feed
        ///// </summary>
        //TrackInfoItunes borderFdIn;
        ///// <summary>
        ///// Premier rejeté par rapport à la durée Feed
        ///// </summary>
        //TrackInfoItunes borderFdOut;

        //TimeSpan borderFdValueIn;
        //TimeSpan borderFdValueOut; 

        //public void clearBorder()
        //{
        //    borderDateMinIn = null;
        //    borderDateMinOut = null;
        //    borderDateMaxIn = null; 
        //    borderDateMaxOut = null;
        //    borderDurationIn = null;
        //    borderDurationOut = null;
        //    borderDurationValueIn = new TimeSpan();
        //    borderDurationValueOut = new TimeSpan();

        //    borderFdIn = null;
        //    borderFdOut = null;
        //    borderFdValueIn = new TimeSpan();
        //    borderFdValueOut = new TimeSpan(); 
        //}



        //// --------vIn----limit ------vout
        //public void checkBorderFd(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        //{
        //    if (selected && duration.TotalMinutes <= this.feedDuration )
        //    {
        //        if (borderFdIn == null || duration > borderFdValueIn )
        //        {
        //            borderFdIn = candidat;
        //            borderFdValueIn = duration;
        //        }
        //    }
        //    else if (!selected && duration.TotalMinutes > this.feedDuration)
        //    {
        //        if (borderFdOut == null || duration < borderFdValueOut)
        //        {
        //            borderFdOut = candidat;
        //            borderFdValueOut = duration;
        //        }
        //    }
        //    else
        //    {
        //    }
        //    }

        //public void checkBorderDuration(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        //{
        //    if (selected && duration.TotalMinutes <= this.duration)
        //    {
        //        borderDurationIn = candidat;
        //        borderDurationValueIn = duration;
        //    }
        //    else if (!selected && duration.TotalMinutes > this.duration)
        //    {
        //        if (borderDurationOut == null)
        //        {
        //            borderDurationOut = candidat;
        //            borderDurationValueOut = duration;
        //        }
        //    }
        //    else
        //    {
        //    }
        //}

        //public void checkBorderDates(TrackInfoItunes candidat, bool selected)
        //{
        //    // ---minOut --limit ---minIn ----
        //    var d = candidat.Pub;
        //    if (d < dateMin)
        //    {
        //        if (borderDateMinOut == null ||d > borderDateMinOut.Pub )
        //            borderDateMinOut = candidat;
        //    }
        //    else if (d>=dateMin && selected)
        //    {
        //        if (borderDateMinIn == null || d < borderDateMinIn.Pub)
        //            borderDateMinIn = candidat;

        //    }
        //    // ---maxIn --limit ---maxOut ----
        //    if (d > dateMax)
        //    {
        //        if (borderDateMaxOut == null || d < borderDateMaxOut.Pub)
        //            borderDateMaxOut = candidat;
        //    }
        //    else if (d <= dateMax &&selected)
        //    {
        //        if (borderDateMaxIn == null || d >borderDateMaxIn.Pub )
        //            borderDateMaxIn = candidat;
        //    }
        //}



        //#endregion

        public void writeStat(ITextWriter sbRapport)
        {
            writeStatHeader(sbRapport);
            stats.buildValues(sbRapport);

        }

        private LimitItemStat stat;
        internal LimitItemStat Stat
        {
            set
            {
                if (stat == null)
                    stat = value;
            }
            get { return stat; }
        }

        public void writeStatHeader(ITextWriter sbRapport)
        {
            //    if (loadDurationLimitAtteinte)
            //        sbRapport.Append("d");
            //    else
            //        sbRapport.Append(" ");

            if (durationLimitAtteinte)
                sbRapport.Append("d");
            else
                sbRapport.Append(" ");



            if (durationFeedLimit)
                sbRapport.Append("f");
            else
                sbRapport.Append(" ");

            if (nbFeedLimit)
                sbRapport.Append("n");
            else
                sbRapport.Append(" ");

            if (contributionLimitAtteinte)
                sbRapport.Append("c");
            else
                sbRapport.Append(" ");
            sbRapport.Append(" ");

        }

        public void getToTaux(ITextWriter sb)
        {

        }

        public void rapport(DescBuilder sb)
        {
            sb.Append("\t");
            //sb.Append(Dir.getPath());
            //sb.Append(" ");
            sb.Append(ToString());
            sb.Append(" ");
        }

        public DirConf Dir { get { return limit.Dir; } }
        public string id = null;
        public string ID
        {
            get
            {
                if (id == null)
                {
                    int index = limit.index(this);
                    if (index >= 0)
                        id = Dir.getPath() + "\\" + Level + "\\_" + (index + 1);
                    else
                        id = Dir.getPath() + "\\_" + Level;

                }
                return id;
            }
        }
       // private Logger logger;

        public LimitItem(Limit limit)
        {
            this.limit = limit;
        }
        //public Logger Logger
        //{
        //    get
        //    {
        //        if (logger == null)
        //        {
        //            logger = Logger.getLogger(ID, false);
        //        }
        //        return logger;
        //    }
        //}

        public object Clone()
        {
            var limitiItem = new LimitItem(limit) { nb = this.nb, Td = this.td, TdMin = this.tdMin, DateMin = this.dateMin, Contribution = this.contribution, Stat = this.stat, dateMax2 = this.dateMax2, Duration2 = this.duration2, Nb2 = this.nb2, Fd2 = this.fd2, overwriteConf = this.overwriteConf };
            limitiItem.duration = this.duration;
            limitiItem.feedDuration = this.feedDuration;
            limitiItem.dateMax = this.dateMax;
            return limitiItem;

        }

        public Limit Limit { set { limit = value; } get { return limit; } }


        public List<TrackInfoItunes> getSelectedTracks()
        {
            if (stat == null)
                return new List<TrackInfoItunes>();
            return new List<TrackInfoItunes>(stat.Total.Use.List);
        }

        public double getTotalSize()
        {
            if (stat == null)
                return -1;
            return stat.Total.Use.getTotalSize();
        }

        public string getEmpreinte()
        {
            if (stat == null)
                return "NULL";
            return stat.Total.Use.getEmpreinte();
        }


        //public void addBorderObs(IBorderTransmit auto)
        //{
        //    throw new NotImplementedException();
        //}

        public void signal(TrackBorderItem tb)
        {
            // en attendant d'implémenter les autos pour limitItem
            if (tb == null)
                return;
            switch (tb.type)
            {
                case borderType.d: if (!hduration) return;
                    break;
                case borderType.fd: if (!hfeedDuration) return;
                    break;
                case borderType.maxdate: if (!hdateMax) return;
                    break;
                case borderType.nb: if (!hNb) return;
                    break; 
                default:
                    return;
            }
            limit.signal(tb);

        }

        public bool canSignal()
        {
            return limit.Dir.canSignal(); 
        }
        public void signal(CauseDatas cd)
        {
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null)
                    continue;
                var type = data.type;

                switch (type)
                {
                    case borderType.d: if (!hduration) cd.datas[i].Virtuel = true;
                        break;
                    case borderType.fd: if (!hfeedDuration) cd.datas[i].Virtuel = true;
                        break;
                    case borderType.maxdate: if (!hdateMax) cd.datas[i].Virtuel = true;
                        break;
                    case borderType.nb:
                        if (!hNb)
                            cd.datas[i].Virtuel = true; break;
                    default:
                        cd.datas[i].Virtuel = true; break;
                }

                if (cd.datas[i] != null && !cd.datas[i].Virtuel)
                    nb++;

            }

            //if (nb <= 1) // OUAILLE ? 
            //    return;
         

            this.limit.signal(cd);
        }


        public IDictionary<string, TrackInfoItunes> getAllTracks()
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\LimitItemBase.cs">
    <content><![CDATA[using pdb.podcast.Auto;
using System;
using System.Xml;
using pdb.util;

namespace pdb.podcast.Tuning
{

    public class LimitItemBase : TuningBase
    {
        public LimitItemBase()
        {
        }

        public LimitItemBase(XmlElement parent, XmlElement node) : base(parent,node)
        {
        }

        /// <summary>
        /// temps total de tous les flux associés à cette limite
        /// </summary>
        protected double duration = int.MaxValue;
        protected double duration2 = int.MaxValue;
        /// <summary>
        /// Temps total phase load de tous les flux associés à cette limite
        /// </summary>
        protected double loadDuration = int.MaxValue; 

        protected LimitItemBase parent;
        const double MAX = int.MaxValue;


        delegate void setf(double value);
        delegate void setI(int value);
        delegate void setd(DateTime value);
        delegate void setDouble(double value);
        delegate void setb(bool value); 

        public bool isChildOf(LimitItemBase p)
        {
            if (p == null)
                return true;
            if (this == p)
                return true;
            if (parent == null)
                return false;
            return parent.isChildOf(p); 

        }

        public void setParent(LimitItemBase parent)
        {
            this.parent = parent;
        }

        /// <summary>
        /// Contribution max de cette limite
        /// </summary>
        protected double contribution = int.MaxValue;
        /// <summary>
        /// nombre d'éléments max
        /// </summary>
        protected int nb = int.MaxValue;

        protected int lNb = int.MaxValue;

        /// <summary>
        /// durée totale du flux
        /// </summary>
        protected double feedDuration = int.MaxValue;
        protected timeSpan _fd = timeSpan.FromSecondes(int.MaxValue);

        protected double lFd = int.MaxValue; 

        /// <summary>
        /// durée max de chaque track
        /// </summary>
        protected double td = int.MaxValue;

        /// <summary>
        /// Durée min de chaque track
        /// </summary>
        protected double tdMin = 0;

        protected DateTime dateMin;

        protected DateTime dateMax = DateTime.MaxValue;

        protected DateTime dateMax2 = DateTime.MaxValue;

        protected int nb2 = int.MaxValue;

        protected double fd2 = int.MaxValue;

        protected bool overwriteConf; public bool OverwriteConf { get { return overwriteConf; } set { overwriteConf = value; } }

        protected DateTime offset;
        public DateTime Offset { get { return offset; } }

        public bool hduration; 
        public double Duration
        {
            get
            {
                if (parent == null || duration < MAX)
                    return duration;
                return parent.Duration;
            }
        //    set { duration = value; }
        }
        public void setDuration(double value, bool hduration)
        {
            this.duration = value;
            this.hduration = hduration; 
        }


        public double Duration2 { get { return duration2; } set { duration2 = value; } }
       

        public double LoadDuration
        {
            get
            {
                if (parent == null || loadDuration < MAX)
                    return loadDuration;
                return parent.LoadDuration;
            }
            set { loadDuration = value; }
        }
        public double Contribution
        {
            get
            {
                if (parent == null || contribution < MAX)
                    return contribution;
                return parent.Contribution;
            }

            set { contribution = value; }
        }
        public double FeedDuration
        {
            get
            {
                if (parent == null || feedDuration < MAX)
                    return feedDuration;
                return parent.FeedDuration;
            }
          //  set { feedDuration = value; }
        }

        public timeSpan Fd { get { return _fd; } }

        
        public bool hfeedDuration; 
        public void setFeedDuration(double value, bool hduration)
        {
            this.feedDuration = value;
            this._fd = timeSpan.FromMinutes(value); 
            this.hfeedDuration = hduration;
        }

        public double Fd2 { get { return fd2; } set { fd2 = value; } }
       
        public double LoadFeedDuration
        {
            get
            {
                if (parent == null || lFd < MAX)
                    return lFd;
                return parent.LoadFeedDuration;
            }
            set { lFd = value; }
        }

        public int Nb
        {
            get
            {
                if (parent == null || nb < int.MaxValue)
                    return nb;
                return parent.Nb;
            }
           // set { nb = value; }
        }

        public int Nb2 { get { return nb2; } set { nb2 = value; } }

        public int getNb(bool load, LimitItemBase conf)
        {
            if (load)
                return LoadNb;
            int __nb = nb;
            int __nb2 = nb2;
            if (!overwriteConf && conf.nb2 < __nb2)
                __nb2 = conf.nb2;
            if (__nb2 < __nb)
                __nb = __nb2;
            return __nb; 
           
        }

        public double getFd(bool load, LimitItemBase conf)
        {
            if (load)
                return LoadFeedDuration;
            double __fd = FeedDuration ;
            double __fd2 = fd2;
            if (!overwriteConf && conf.fd2 < __fd2)
                __fd2 = conf.nb2;
            if (__fd2 < __fd)
                __fd = __fd2;
            return __fd;

        }

        public double getDuration()
        {
          
            double __d = Duration;
            double __d2 = Duration2;
          
            if (__d2 < __d)
                __d = __d2;
            return __d;

        }

        public int LoadNb
        {
            get
            {
                if (parent == null || lNb < int.MaxValue)
                    return lNb;
                return parent.LoadNb;
            }
            set { lNb = value; }
        }


        /// <summary>
        /// durée max de chaque track
        /// </summary>
        public double Td { set { td = value; } get { return td; } }
        /// <summary>
        /// Durée min de chaque track
        /// </summary>
        public double TdMin
        {
            set { tdMin = value; }
            get
            {
                if (parent == null || tdMin < MAX)
                    return tdMin;
                return parent.TdMin;
            }
        }
        public DateTime DateMin { set { dateMin = value; } get { return dateMin; } }
        public DateTime DateMax {
            //set { dateMax = value; } 
            get { return dateMax; } }
        public DateTime DateMax2 { get { return dateMax2; } set { dateMax2 = value; } }
        public bool hdateMax;
        public void setDateMax(DateTime value, bool hdateMax)
        {
            this.dateMax = value;
            this.hdateMax = hdateMax; 
        }

        public bool hNb;
        public void setNbMax(int value, bool hNb)
        {
            this.nb = value;
            this.hNb = hNb; 
        }

        public void build(XmlNode parent, XmlNode child)
        {
            buildf(parent, child, "d", (v) => duration = v);
            buildf(parent, child, "d2", (v) => duration2 = v);
            buildf(parent, child, "ld", (v) => loadDuration = v);
            buildf(parent, child, "c", (v) => contribution = v);
            buildf(parent, child, "fd", (v) => feedDuration = v);
            buildf(parent, child, "fd2", (v) => fd2 = v);
            buildf(parent, child, "lfd", (v) => lFd = v);
            buildi(parent, child, "nb", (v) => nb = v);
            buildi(parent, child, "nb2", (v) => nb2 = v);
            //double nbd = 0; 
            //buildDouble(parent, child, "nb", (v) => nbd = v);
           // nb = (int)Math.Round(nbd); 
            buildi(parent, child, "lnb", (v) => lNb = v);
            buildd(parent, child, "date", (v) => dateMin = v);
            buildd(parent, child, "maxdate", (v) => dateMax = v);
            buildd(parent, child, "maxdate2", (v) => dateMax2 = v);
            buildb(parent, child, "overwriteConf", (v) => overwriteConf = v);

            if (td == int.MaxValue)
                buildf(parent, child, "tdmax", v => td = v);

            if (tdMin == 0)
                buildf(parent, child, "tdmin", v => tdMin = v); 
           
            int _offset = 0;
            buildi(parent, child, "offsety", (v) => _offset = v);
            if (_offset >0)
            {
                offset = DateTime.Now.AddYears(-_offset); 
            }
        }

        private void buildf(XmlNode parent, XmlNode child, string name, setf setf)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setf(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setf(Convert.ToDouble(att.InnerText));
        }

        private void buildi(XmlNode parent, XmlNode child, string name, setI seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt16(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt16(att.InnerText));
        }

        private void buildd(XmlNode parent, XmlNode child, string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Conf.getDate(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Conf.getDate(att.InnerText));
        }

        private void buildDouble(XmlNode parent, XmlNode child, string name, setDouble setDouble)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setDouble(Convert.ToDouble (att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setDouble(Convert.ToDouble(att.InnerText));
        }

        private void buildb(XmlNode parent, XmlNode child, string name, setb setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(readBool(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(readBool(att.InnerText));
        }

    }


}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Sort.cs">
    <content><![CDATA[using System.Xml;
using pdb.util;
using System;
using System.Collections.Generic;
using pdb.podcast.Albums;

namespace pdb.podcast.Tuning.Sort
{
    public enum sortMode
    {
        no,
        reset,
        once,
        once_all,
        all,
        histo
    }

    public enum histoMode
    {
        /// <summary>
        /// Démarrage de l'histo sur Date0
        /// </summary>
        fix,
        /// <summary>
        /// Démarrage de l'histo sur le premier sélectionné
        /// </summary>
        selected,
        /// <summary>
        /// Démarrage de l'histo sur le dernier lu
        /// </summary>
        read

    }
    public class SortItem : SelectParamBase
    {
        /// <summary>
        /// nom de l'album ou suite d'albums
        /// </summary>
        public List<string> name = new List<string>();

        public sortMode enabled;
        public bool checkBefore;
        /// <summary>
        /// prise en compte des longs podcasts
        /// </summary>
        public double dureeMin;
        /// <summary>
        /// intervalle max entre deux écoutes (une semaine)
        /// </summary>
        private double intervalle = 7;
        /// <summary>
        /// intervalle min entre deux écoutes (un jour)
        /// </summary>
        private double intervalleMin = 1;
        /// <summary>
        /// intervalle max entre deux écoutes pour un rare
        /// </summary>
        private double intervalleR;
        /// <summary>
        /// intervalle min entre deux écoutes pour un rare
        /// </summary>
        private double intervalleMinR = 7;
        /// <summary>
        /// nb d'écoutes maximum dans l'intervalle (typiquement 5)
        /// </summary>
        private double ecouteMax;
        /// <summary>
        /// nb d'écoutes maximum dans l'intervalle pour un rare
        /// </summary>
        private double ecouteMaxR;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute
        /// </summary>
        private double histo;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute pour un rare
        /// </summary>
        private double histoR;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : nombre minimum d'éléments à prendre en compte
        /// </summary>
        public int deltaNbMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'éléments à prendre en compte
        /// </summary>
        public int deltaNbRab;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : intervalle minimum à prendre en compte en jours
        /// </summary>
        public double deltaMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'intervalle à prendre en compte
        /// </summary>
        public double deltaRab;

        /// <summary>
        /// pas d'empilage des tracks repoussés
        /// </summary>
        public bool noCollision;
        /// <summary>
        /// recalcul peut entrainer une date plus récente
        /// </summary>
        public bool canGoBack;
        /// <summary>
        /// recalcul peut entrainer une date plus récente, mais si ça le rend non séléctionné, on bricole pour qu'il soit quand même selectionné
        /// </summary>
        public bool canGoBackButForceSelected;
        /// <summary>
        /// écart constant entre les poscasts repoussés
        /// </summary>
        public bool deltaConst;

        /// <summary>
        /// Date0 lors de l'écoute du dernier podcast externe
        /// </summary>
        public DateTime extLast0;
        /// <summary>
        /// Décalage entre date du podcast supplémentaire et la date0
        /// </summary>
        public double extDelta;
        /// <summary>
        /// coefficient permettant le calcul de la prochaine date en fonction du retard entre la date0 et maintenant
        /// </summary>
        public double extPente;
        /// <summary>
        /// check de la date de dernière lecture
        /// </summary>
        public bool limitRead;
        /// <summary>
        /// Dans le calcul de delta ne pas inclure les non-selectionnés
        /// </summary>
        public bool deltaCheckSelected;
        /// <summary>
        /// handicap pour les nouveaux podcasts
        /// </summary>
        public int totalMin;
        /// <summary>
        /// Coefficient de rappel vers la valeur initiale 
        /// </summary>
        public double elastique = 1;

        /// <summary>
        /// Cumul max de retard pour les non-rares
        /// </summary>
        public double cumulMax = -1;

        /// <summary>
        /// Cumul max de retard pour les rares
        /// </summary>
        public double cumulMaxR = -1;

        /// <summary>
        /// Cumul min de retard pour les non-rares
        /// </summary>
        public double cumulMin = -1;

        /// <summary>
        /// Cumul min de retard pour les rares
        /// </summary>
        public double cumulMinR = -1;


        public histoMode histoMode;

        private ITrackSelector selector;

        public SortItem()
        {
        }

        public SortItem(XmlElement parent, XmlElement node)
            : base(parent, node)
        {

            if (node == null)
                return;
            var str = "";
            builds("name", v => str = v);

            if (!string.IsNullOrEmpty(str))
            {
                foreach (string album in str.Split('|'))
                {
                    if (!string.IsNullOrWhiteSpace(album))
                        name.Add(album.ToLowerWithoutDiacritics());
                }
            }

            builds("enabled", v => str = v);

            if (!string.IsNullOrEmpty(str))
                enabled = (sortMode)Enum.Parse(typeof(sortMode), str);

            buildd("dureeMin", v => dureeMin = v);
            buildd("intervalle", v => intervalle = v);
            buildd("intervalleMin", v => intervalleMin = v);
            buildd("intervalleR", v => intervalleR = v);
            buildd("intervalleMinR", v => intervalleMinR = v);
            buildd("histo", v => histo = v);
            buildd("histoR", v => histoR = v);
            buildd("ecouteMax", v => ecouteMax = v);
            buildd("ecouteMaxR", v => ecouteMaxR = v);

            buildDate("extLast0", v => extLast0 = v);
            buildd("extDelta", v => extDelta = v);
            buildd("extPente", v => extPente = v);




            buildb("deltaConst", v => deltaConst = v);

            buildb("noCollision", v => noCollision = v);
            buildb("checkBefore", v => checkBefore = v);
            buildb("limitRead", v => limitRead = v);
            buildb("canGoBack", v => canGoBack = v);
            buildb("deltaCheckSelected", v => deltaCheckSelected = v);

            #region lissage
            buildi("deltaNbMin", v => deltaNbMin = v);
            buildi("deltaNbRab", v => deltaNbRab = v);

            buildd("deltaMin", v => deltaMin = v);
            buildd("deltaRab", v => deltaRab = v);

            #endregion

            builds("histoMode", v => str = v);
            histoMode = (histoMode)Enum.Parse(typeof(histoMode), str);

            buildi("totalMin", v => totalMin = v);

            buildd("elastique", v => elastique = v);


            buildd("cumulMin", v => cumulMin = v);
            buildd("cumulMinR", v => cumulMinR = v);
            buildd("cumulMax", v => cumulMax = v);
            buildd("cumulMaxR", v => cumulMaxR = v);
            this.selector = new TrackSelector(this);
        }

        public double getIntervalle(bool rare)
        {
            return rare && intervalleR > 0 ? intervalleR : intervalle;
        }
        public double getIntervalleMin(bool rare)
        {
            return rare && intervalleMinR > 0 ? intervalleMinR : intervalleMin;
        }
        public double getHisto(bool rare)
        {
            return rare && histoR > 0 ? histoR : histo;
        }
        public double getEcouteMax(bool rare)
        {
            return rare && ecouteMaxR > 0 ? ecouteMaxR : ecouteMax;
        }

        internal bool select(ISelectable album)
        {
            return selector.select(album);
        }

        public double getCumulMax(bool rare)
        {
            return rare && cumulMaxR > 0 ? cumulMaxR : cumulMax;
        }
        public double getCumulMin(bool rare)
        {
            return rare && cumulMinR > 0 ? cumulMinR : cumulMin;
        }


    }
    public class Sort : SortItem
    {
        private List<SortItem> items = new List<SortItem>();
        private List<SortItem> rules = new List<SortItem>();

        public SortItem getItem(string key)
        {
            foreach (SortItem g in items)
            {
                if (g.name.Contains(key))
                    return g;

            }
            return null;
        }

        public SortItem getRule(TrackAlbum album)
        {
            foreach (SortItem r in rules)
            {
                if (r.select(album))
                    return r;
            }

            return null;
        }
        public Sort()
        {

        }

        public Sort(XmlElement node)
            : base(null, node)
        {
            if (node == null)
                return;
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    if (sub.Name == "album")
                    {
                        items.Add(new SortItem(node, sub as XmlElement));
                    }
                    else if (sub.Name == "rule")
                    {
                        rules.Add(new SortItem(node, sub as XmlElement));
                    }
                }
            }


        }




    }
}]]></content>
  </file>
  <file path="\pdb.util\TuningBase.cs">
    <content><![CDATA[using System;
using System.Xml;

namespace pdb.util
{
    /// <summary>
    /// affecte une chaîne
    /// </summary>
    /// <param name="value"></param>
    public delegate void sets(string value);
    /// <summary>
    /// Affecte un double
    /// </summary>
    /// <param name="value"></param>
    public delegate void setd(double value);
    /// <summary>
    /// Affecte un décimal
    /// </summary>
    /// <param name="value"></param>
    public delegate void setdec(decimal value);
    /// <summary>
    /// Affecte un entier
    /// </summary>
    /// <param name="value"></param>
    public delegate void seti(int value);
    /// <summary>
    /// Affecte un entier nullable
    /// </summary>
    /// <param name="value"></param>
    public delegate void setin(int? value);
    /// <summary>
    /// Affecte un booléen
    /// </summary>
    /// <param name="value"></param>
    public delegate void setb(bool value);
    /// <summary>
    /// Affecte un booléen nullable
    /// </summary>
    /// <param name="value"></param>
    public delegate void setbn(bool? value);
    /// <summary>
    /// Affecte une date
    /// </summary>
    /// <param name="value"></param>
    public delegate void setDate(DateTime value);

    [Serializable]
    public enum dbMode
    {
        full,
        diff
    }

    [Serializable]
    public class TuningBase : ICloneable
    {
        public const string DIR_CONF = @"..\conf\";
       
        [NonSerialized]
        protected XmlElement parent;
        [NonSerialized]
        protected XmlElement child;

        public TuningBase()
            : this(null, null)
        {
        }

        public TuningBase(XmlElement node) : this(null, node) { }

        public TuningBase(XmlElement parent, XmlElement child)
        {
            this.parent = parent;
            this.child = child;
        }
        protected XmlWriter w;
        public virtual void save(XmlWriter w) { this.w = w; }

        protected void writeStart(string name)
        {
            w.WriteStartElement(name);
        }
        protected void writeEnd()
        {
            w.WriteEndElement();
        }
        protected void write(string name, object value)
        {
            string val = "";
            if (value != null)
            {
                if (value is bool || value is bool?)
                    val = (bool)value ? "true" : "false";
                else
                    val = value.ToString();
            }
            w.WriteAttributeString(name, val);
        }


        /// <summary>
        /// Charge un double
        /// </summary>
        /// <param name="name"></param>
        /// <param name="setd"></param>
        protected void buildd(string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
        }
        /// <summary>
        /// Charge un décimal
        /// </summary>
        /// <param name="name"></param>
        /// <param name="setd"></param>
        protected void builddec(string name, setdec setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDecimal(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDecimal(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDecimal(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDecimal(elt.InnerText));
        }
        /// <summary>
        /// Charge un entier
        /// </summary>
        /// <param name="name"></param>
        /// <param name="seti"></param>
        protected void buildi(string name, seti seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }
        /// <summary>
        /// Charge un entier nullable
        /// </summary>
        /// <param name="name"></param>
        /// <param name="seti"></param>
        protected void buildin(string name, setin seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }
        /// <summary>
        /// Charge une chaîne
        /// </summary>
        /// <param name="name"></param>
        /// <param name="sets"></param>
        protected void builds(string name, sets sets)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                sets(att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                sets(att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                sets(elt.InnerText);
            elt = child[name];
            if (elt != null)
                sets(elt.InnerText);
        }
        /// <summary>
        /// Charge un booléen
        /// </summary>
        /// <param name="name"></param>
        /// <param name="setb"></param>
        protected void buildb(string name, setb setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setb(readBool(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setb(readBool(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setb(readBool(elt.InnerText)); 
            elt = child[name];
            if (elt != null)
                setb(readBool(elt.InnerText)); 
        }
        /// <summary>
        /// Charge un booléen nullable
        /// </summary>
        /// <param name="str"></param>
        /// <param name="setb"></param>
        private void _buildbn(string str, setbn setb)
        {            
           setb(readBoolNullable(str)); 
        }

        public static bool? readBoolNullable(string str)
        {
            switch (str)
            {
                case "y":
                case "Y":
                case "o":
                case "O": 
                case "1": 
                case "true":return true;
                case "n":
                case "N":
                case "0":
                case "false": return false;
                default: return null; 
            }
        }

        public static bool readBool(string str)
        {
            return readBoolNullable(str).Value; 
        }
        /// <summary>
        /// Construction d'un bool nullable
        /// </summary>
        /// <param name="name"></param>
        /// <param name="setb"></param>
        protected void buildbn(string name, setbn setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                _buildbn(att.InnerText, setb);

            att = child.Attributes[name];
            if (att != null)
                _buildbn(att.InnerText, setb);


            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                _buildbn(elt.InnerText, setb);
            elt = child[name];
            if (elt != null)
                _buildbn(elt.InnerText, setb);
        }
        /// <summary>
        /// Charge une date
        /// </summary>
        /// <param name="name"></param>
        /// <param name="setDate"></param>
        protected void buildDate(string name, setDate setDate)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setDate(Convert.ToDateTime(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setDate(Convert.ToDateTime(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setDate(Convert.ToDateTime(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setDate(Convert.ToDateTime(elt.InnerText));
        }

        public virtual object Clone()
        {
            return this.MemberwiseClone(); 
        }
    }
}
]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using pdb.it.Albums;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        protected static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        protected static IAlbumMgr albumMgr;
        public static IAlbumMgr AlbumMgr { set { albumMgr = value; } get { return albumMgr; } }
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        private TrackPlayListManager listManager = new TrackPlayListManager();
        private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        protected static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);

        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }



        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            albumMgr.setAlbum(this, track.Album);
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;




        }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present; public bool Present { get { return present; } set { present = value; } }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location": Uri uri = new Uri(value);
                        return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.PlayedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded;


            Fill();
        }



        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0;
            string key = "";
            bool nextIgnore = false;


            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value;
                        break;
                    case "Artist": artist = value; break;
                    case "Album": albumMgr.setAlbum(this, value); break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": PlayedDate = Convert.ToDateTime(value); break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;// Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return TrackTrack;
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;

                bgClass.add(new Bgtask(() =>
                {
                    Track.Artist = value;
                    artist = value;
                }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                ));


            }
        }
        protected IAlbum _album;
        public IAlbum TrackAlbum { get { return _album; } set { _album = value; } }

        public virtual string AlbumKey { get { return Album; } }
        public string Album
        {
            get
            {
                return _album.Album;
            }
            set
            {
                if (value == null || value.Equals(_album.Album)) return;
                bgClass.add(new Bgtask(() =>
                {
                    // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                    Track.Album = value;
                    albumMgr.setAlbum(this, value);
                }, this,
                "change album from '{0}' to'{1}' {2}", Album, value, this
                ));

            }
        }
        protected string name = "";
        public virtual string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;

                int lengh = 0;
                if (name != null)
                    lengh = name.Length;

                if (value.Length < lengh)
                {
                    log.log("Attention On raccourcit le nom !!! {0}->{1} {2}", name, value,this );
                   // return; 
                }


                var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                bgClass.add(bgtaskName);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }
        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        private bool firstClass;
        public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                firstClass = false;
                if (comment != value)
                {
                    try
                    {
                        var tab0 = comment.Split(' ');
                        var tab1 = value.Split(' ');

                        var count0 = tab0.GetLength(0);
                        var count1 = tab1.GetLength(0);

                        if (count0 != count1)
                            firstClass = true;

                        else if (comment.Length > 3)
                        {
                            string org = tab0[count0 - 1];
                            string fin = tab1[count1 - 1];

                            firstClass = !org.Equals(fin);
                        }
                    }

                    catch
                    {
                        firstClass = true;
                    }

                    var sb = new StringBuilder();
                    sb.Append(ClassName);
                    sb.Append(".");
                    sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format("{0} change comment from '{1}' to '{2}' {3}", sb.ToString(), comment, value, this), value);

                    if (firstClass)
                        bgFirstClass.add(task);
                    else
                        bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled = true;
        public bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        private bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        private DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                return playedDate;
            }

            set
            {
                if (playedDate > DateTime.MinValue)
                {
                    var dt = (value - playedDate).TotalHours;
                    if (dt > 2 || dt < -2)
                        playedDate = value;
                    else
                        return;

                }
                playedDate = value;
            }
        }
        protected string location;
        public string Location
        {
            get { return location; }
            set { location = value; }
        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }


        }

        public void setGrouping(string value, bool prior)
        {
            if (!present)
            {
                grouping = value;
                return;
            }
            if (grouping != value)
            {
                bool _delta = false;
                // bool _deltaRank = false; 
                string rankAlbum = "";
                string equivAlbum = "";
                if (value != null)
                {
                    string[] org = grouping.Split(' ');
                    string[] _new = value.Split(' ');

                    int count = org.GetLength(0);
                    if (_new.GetLength(0) != count || count < 3)
                        _delta = true;
                    else
                    {
                        rankAlbum = _new[1];
                        equivAlbum = _new[2];
                        if (!org[1].Equals(_new[1]))
                        {
                            _delta = true;
                        }
                    }
                }

                var sb = new StringBuilder();
                sb.Append(rankAlbum);
                sb.Append(" ");
                sb.Append(equivAlbum);
                sb.Append(" ");
                sb.Append(Album);
                //sb.Append(ClassName);
                //sb.Append(".");
                //sb.Append((Rating / 20).ToString());

                var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

                if (firstClass)
                {
                    bgSeconClass.add(task);
                    return;
                }

                //if (prior)
                //{
                //    bgGroupPrior.add(task);
                //    return;
                //}



                if (_delta)
                {
                    if (prior)
                        bgGroupPrior.add(task);
                    else
                        bgGroup2nd.add(task);
                    return;
                }

                bgg.add(task);

                //if (_delta)
                //    bgGroupDelta.add(task);
                //else
                //{
                //    bgg.add(task);
                //}
                //  grouping = value;
            }
        }



        private int volume;
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        public List<CPlayList> PLayLists
        {
            get { return listManager.PLayLists; }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return listManager.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            listManager.AddPlayList(a_playList);
            // className = listManager.ClassName;
        }

        public void removePlayList(CPlayList list)
        {
            listManager.removePlayList(list);
            // className = listManager.ClassName;
        }


        public string ClassName
        {
            get
            {
                className = listManager.ClassName;
                return className;
            }
            set
            {
                className = listManager.ClassName;
                if (className != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        loader.setClassPlayList(this, className, value);
                        className = value;
                    }, this,
                   "change className from '{0}' to'{1}' {2}", className, value, this));


                    //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
                    //className = value;
                    //OnClassNameChange(value);
                }
            }
        }
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }

        public void Delete()
        {
            if (tracktrack != null)
            {
                log.log("!delete! {0}", this);
                tracktrack.Delete();
            }
            else
                bgClass.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        protected class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getLocation()
        {
            return location;
        }

        private DateTime added;
        public virtual DateTime Added
        {
            get { return added; }
            set { added = value; }
        }

    }
}



]]></content>
  </file>
</db>
