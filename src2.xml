<db path="C:\bernard\db1\db4">
  <file path="\pdb.player\App.xaml">
    <content><![CDATA[<Application x:Class="pdb.player.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:util="clr-namespace:pdb.player.Vue.Util"
             StartupUri="Player.xaml">
    <Application.Resources>
        <util:StringFormatConverter x:Key="StringFormater" />
        <util:TimeFormatConverter x:Key="TimeSpan" />
        <util:IntFormatConverter x:Key="Int" />
        <util:DecimalFormatConverter x:Key="decimal" />
        <util:DecimalFormatEConverter x:Key="decimalE" />
        <util:DecimalFormatElConverter x:Key="decimalEl" />
        <util:ClFormatConverter x:Key="cl" />
       
        <util:BgColorFormatConverter x:Key="colorExport" />
        <util:BgColorFormatConverter0 x:Key="colorExport0" />
        <util:BgColorFormatConverter00 x:Key="colorExport00" />
        <util:ForeColorFormatConverter x:Key="foreColor" />
        <util:ColorDispoConverter x:Key="dispo" />
        <util:BoolToVis x:Key="boolVis" />
        <util:SortModeConverter x:Key="sortAlbum" />
        <util:DateConverter  x:Key="date" />
        <util:DateToDelaiConverter x:Key="delai" />
        <util:SelectedMotifConverter x:Key="motif" />
        <util:FontConverter x:Key="fontWeight" />
        <Style TargetType="{x:Type CheckBox}" x:Key="cb">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type CheckBox}">
                        <StackPanel Orientation="Horizontal">
                            <Image x:Name="checkboxImage" Source="/Vue/images/cbCoche.png" />
                            <ContentPresenter/>
                        </StackPanel>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsChecked" Value="True">
                                <Setter TargetName="checkboxImage" Property="Source" Value="/Vue/images/cbCoche.png"/>
                            </Trigger>
                            <Trigger Property="IsChecked" Value="False">
                                <Setter TargetName="checkboxImage" Property="Source" Value="/Vue/images/cbDecoche.png"/>
                            </Trigger>                            
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Application.Resources>
    
</Application>
]]></content>
  </file>
  <file path="\pdb.player\pdb.player.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{4166FA60-B33F-4496-9352-EDD8F3214021}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.player</RootNamespace>
    <AssemblyName>pdb.player</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;NONI</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;COMPACT</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>pdb.player.App</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.AXVLC, Version=1.0.0.0, Culture=neutral, processorArchitecture=x86">
      <SpecificVersion>False</SpecificVersion>
      <EmbedInteropTypes>False</EmbedInteropTypes>
      <HintPath>bin\Interop.AXVLC.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="policy.2.0.taglib-sharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=db62eba44689b5b0, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\policy.2.0.taglib-sharp.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="taglib-sharp, Version=2.1.0.0, Culture=neutral, PublicKeyToken=db62eba44689b5b0, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\taglib-sharp.dll</HintPath>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="Xceed.Wpf.Toolkit">
      <HintPath>libs\Extended WPF Toolkit Binaries\Xceed.Wpf.Toolkit.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="model\ArtWorkManager.cs" />
    <Compile Include="model\Equalization.cs" />
    <Compile Include="ViewModel\AllTracksViewModel.cs" />
    <Compile Include="ViewModel\BibViewModel.cs" />
    <Compile Include="ViewModel\BibViewModelBase.cs" />
    <Compile Include="ViewModel\BibViewModelTree.cs" />
    <Compile Include="ViewModel\Colors\ColorViewModel.cs" />
    <Compile Include="ViewModel\Colors\Couleurs.cs" />
    <Compile Include="ViewModel\Colors\MementoColor.cs" />
    <Compile Include="ViewModel\Commande\CommandeBase.cs" />
    <Compile Include="ViewModel\Commande\CoulHistoryBack.cs" />
    <Compile Include="ViewModel\Commande\CreateListCmd.cs" />
    <Compile Include="ViewModel\Commande\DeleteCmd.cs" />
    <Compile Include="ViewModel\Commande\Explorer.cs" />
    <Compile Include="ViewModel\Commande\ImportCmd.cs" />
    <Compile Include="ViewModel\Commande\InfoCmd.cs" />
    <Compile Include="ViewModel\Commande\Link\LinkRegister.cs" />
    <Compile Include="ViewModel\Commande\Link\RecordFather.cs" />
    <Compile Include="ViewModel\Commande\Play.cs" />
    <Compile Include="ViewModel\Commande\PlayList\AddToList.cs" />
    <Compile Include="ViewModel\Commande\PlayList\CheckCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastClassement.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastRead.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCompress.cs" />
    <Compile Include="ViewModel\Commande\PlayList\PlayListCommande.cs" />
    <Compile Include="ViewModel\Commande\RecordClassement.cs" />
    <Compile Include="ViewModel\DetailAlbumViewModel.cs" />
    <Compile Include="ViewModel\DetailClassementViewModel.cs" />
    <Compile Include="ViewModel\gen\ListWriter.cs" />
    <Compile Include="ViewModel\InfoViewModel.cs" />
    <Compile Include="ViewModel\Interfaces.cs" />
    <Compile Include="ViewModel\PlayerViewModel.cs" />
    <Compile Include="ViewModel\StatItemViewModel.cs" />
    <Compile Include="ViewModel\TrackListViewModel.cs" />
    <Compile Include="ViewModel\PlayListViewModel.cs" />
    <Compile Include="ViewModel\ViewModelBase.cs" />
    <Compile Include="Vue\Adorn\AdornedControl.cs" />
    <Compile Include="Vue\Adorn\AdornerPlacement.cs" />
    <Compile Include="Vue\Adorn\FrameworkElementAdorner.cs" />
    <Compile Include="Vue\AlbumCtl.xaml.cs">
      <DependentUpon>AlbumCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BarAdorner.cs" />
    <Compile Include="Vue\BibCtl.xaml.cs">
      <DependentUpon>BibCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BrowsePlayList.xaml.cs">
      <DependentUpon>BrowsePlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ClassementCtl.xaml.cs">
      <DependentUpon>ClassementCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfAlbumSortW.xaml.cs">
      <DependentUpon>ConfAlbumSortW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfExport.xaml.cs">
      <DependentUpon>ConfExport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfFilterW.xaml.cs">
      <DependentUpon>ConfFilterW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfImport.xaml.cs">
      <DependentUpon>ConfImport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfMedianneW.xaml.cs">
      <DependentUpon>ConfMedianneW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfVirt.xaml.cs">
      <DependentUpon>ConfVirt.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfCouleurs.xaml.cs">
      <DependentUpon>ConfCouleurs.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\Debug.xaml.cs">
      <DependentUpon>Debug.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\Miscellaneous.xaml.cs">
      <DependentUpon>Miscellaneous.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\DataGridPlayList.xaml.cs">
      <DependentUpon>DataGridPlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\EnhancedDataGrid.cs" />
    <Compile Include="Vue\FolderBrowserDialog.xaml.cs">
      <DependentUpon>FolderBrowserDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialogW.xaml.cs">
      <DependentUpon>FolderBrowserDialogW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\getNb.xaml.cs">
      <DependentUpon>getNb.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Info.xaml.cs">
      <DependentUpon>Info.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Memento.cs" />
    <Compile Include="Vue\PlayerControler.xaml.cs">
      <DependentUpon>PlayerControler.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StatCtl.xaml.cs">
      <DependentUpon>StatCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StateBar.xaml.cs">
      <DependentUpon>StateBar.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StringDialog.xaml.cs">
      <DependentUpon>StringDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Util\BaseConverter.cs" />
    <Compile Include="Vue\Util\GradiantBuilder.cs" />
    <Compile Include="Vue\Util\StringFormatConverter.cs" />
    <Compile Include="Vue\Util\Utils.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Player.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Player.xaml.cs">
      <DependentUpon>Player.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="Vue\AlbumCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BibCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BrowsePlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ClassementCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfAlbumSortW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfExport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfFilterW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfImport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfMedianneW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfVirt.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfCouleurs.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\Debug.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\Miscellaneous.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\DataGridPlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialogW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\getNb.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Vue\Info.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\PlayerControler.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StatCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StateBar.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StringDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="app.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <AppDesigner Include="Properties\" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\engine\pdb.player.engine.build\pdb.player.engine.build.csproj">
      <Project>{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}</Project>
      <Name>pdb.player.engine.build</Name>
    </ProjectReference>
    <ProjectReference Include="..\engine\pdb.player.engine\pdb.player.engine.csproj">
      <Project>{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}</Project>
      <Name>pdb.player.engine</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823d1d-851c-456b-ac4c-b0beec173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{c2b34ca9-3bb2-464f-8691-5f5b7cb2b997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Consolid\pdb.gen.csproj">
      <Project>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</Project>
      <Name>pdb.gen</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Db\pdb.db.csproj">
      <Project>{43D27B47-E615-451D-AD25-67C5B8447C4A}</Project>
      <Name>pdb.db</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\Toolbar-MP3-Forward-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Pause-icon.png" />
    <Resource Include="Vue\images\Toolbar-MP3-Play-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Rewind-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Stop-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\cbCoche.png" />
    <Resource Include="Vue\images\cbDecoche.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.player\ViewModel\AllTracksViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.player.ViewModel.Commande.Link;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.Commande;
using pdb.util;
using System.Globalization;
using pdb.gen.auto;

namespace pdb.player.ViewModel
{
    public enum listDisplay
    {
        all,
        onlyDisabled,
        onlyEnabled
    }

    public class AllTracksViewModel : List<TrackListViewModel>, INotifyCollectionChanged, INotifyPropertyChanged
    {
        public event NotifyCollectionChangedEventHandler CollectionChanged;
        public event PropertyChangedEventHandler PropertyChanged;
        //   private List<TrackListViewModel> tracks;
        private Dictionary<int, TrackListViewModel> dict;
        private object _lock = new object();
        private PlayListViewModel parent;
        private DispatcherOperation ope;



        private bool? onlyDisabled;
        private bool onlyFathers;
        public AllTracksViewModel(PlayListViewModel parent, bool? onlyDisabled, bool onlyFathers)
        {
            this.parent = parent;
            this.onlyDisabled = onlyDisabled;
            this.onlyFathers = onlyFathers;
            //   this.mode = mode; 
            build();
            PlayerViewModel.Instance.resumeChange += playerResumeChange;
            PlayerViewModel.autoChange += new EventHandler(PlayerViewModel_autoChange);
            //TrackListViewModel.CurrentHumanSelectedChanged += PlayerViewModel_autoChange; 
        }

        void PlayerViewModel_autoChange(object sender, EventArgs e)
        {
            OnPropertyChanged("AutoResume");
        }


        void playerResumeChange(object sender, EventArgs e)
        {
            OnPropertyChanged("TV");
            OnPropertyChanged("Resume");
            OnPropertyChanged("AutoResume");
        }

        public string Resume
        {
            get
            {
                return PlayerViewModel.Instance.Resume;
            }
            set
            {

            }
        }

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (CollectionChanged == null)
            //    {
            //    }
            //    else
            //    {
            //        CollectionChanged(this, e); 
            //    }
            //    return; 
            //}

            //dispatcher.Invoke(DispatcherPriority.DataBind, new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e);



            var eventHandler = CollectionChanged;
            if (eventHandler != null)
            {
                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (NotifyCollectionChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        // Invoke handler in the target dispatcher's thread
                        {
                            ope =
                               dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                            handler, this, e);
                            ope.Completed += ope_Completed;


                        }
                        else // Execute handler as is
                            handler(this, e);
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
            else
            {
            }

            // PlayerViewModel.Instance.makeResume();

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("AllTracksViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
            PlayerViewModel.Instance.makeResume();
        }


        protected virtual void OnPropertyChanged(string propertyName)
        {
            var eventHandler = PropertyChanged;
            if (eventHandler == null)
            {
                //   int toto = 0;
            }
            else
            {
                //var dispatcher = Dispatcher.CurrentDispatcher;
                //if (dispatcher.CheckAccess())
                //    PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
                //else
                //    dispatcher.Invoke(new Action<string>(OnPropertyChanged), propertyName);

                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (PropertyChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                          handler, this, new PropertyChangedEventArgs(propertyName));
                        else // Execute handler as is
                            handler(this, new PropertyChangedEventArgs(propertyName));
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
        }

        public void refresh()
        {
            build();
            foreach (TrackListViewModel track in this)
                track.refresh();

        }

        //public void init()
        //{
        //    refresh();
        //    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        //}

        public TrackListViewModel TV { get { return TrackListViewModel.HumanSelected; } }

        public void build()
        {
            lock (_lock)
            {
                var list = new List<TrackListViewModel>();
                var dict = new Dictionary<int, TrackListViewModel>();
                buildAllTraks(list, dict, onlyDisabled, onlyFathers);
                if (this.dict == null)
                {
                    this.dict = new Dictionary<int, TrackListViewModel>();
                    foreach (TrackListViewModel track in list)
                    {
                        Add(track);
                        this.dict.Add(track.PieceId, track);
                        // track.PropertyChanged += track_PropertyChanged;
                    }

                    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
                }
                else
                {

                    foreach (TrackListViewModel newTrack in list)
                    {
                        if (!this.dict.ContainsKey(newTrack.PieceId))
                        {
                            Add(newTrack);
                            this.dict.Add(newTrack.PieceId, newTrack);
                            // newTrack.PropertyChanged += track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, newTrack));
                        }
                    }

                    foreach (TrackListViewModel track in new List<TrackListViewModel>(this))
                    {
                        if (!dict.ContainsKey(track.PieceId))
                        {
                            Remove(track);
                            this.dict.Remove(track.PieceId);
                            // track.PropertyChanged -= track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, track));
                        }
                    }
                }
            }

            //Clear(); 
            //foreach (TrackListViewModel track in parent.Tracks)
            //    Add(track); 
        }

        //void track_PropertyChanged(object sender, PropertyChangedEventArgs e)
        //{
        //    switch (e.PropertyName)
        //    {
        //        case "Duration":
        //        case "Enabled":
        //            PlayerViewModel.Instance.makeResume();
        //            break;
        //    }
        //}

        public List<TrackListViewModel> AllTracks
        {
            get
            {
                build();
                return this;
            }
        }

        public List<TrackListViewModel> Tracks
        {
            get
            {
                return parent.Tracks;
            }
        }

        protected void buildAllTraks(List<TrackListViewModel> container, Dictionary<int, TrackListViewModel> dict, bool? onlyDisabled, bool onlyFathers)
        {
            foreach (TrackListViewModel t in parent.Tracks)
            {
                if (!t.Enabled || true != onlyDisabled)
                {
                    if (onlyDisabled == null && t.Enabled)
                    {
                        if (!t.PieceGen.ClassementProvisoireRecent)
                            continue;
                    }
                    if (t.PieceParentId < 0 || !onlyFathers)
                    {
                        if (!t.Virtual || PlayerViewModel.Instance.WithVirtualAlbum)
                        {

                            if (!dict.ContainsKey(t.PieceId))
                            {
                                dict.Add(t.PieceId, t);
                                container.Add(t);
                                //  t.Index = container.Count; 
                            }
                        }
                    }
                }

            }

            foreach (PlayListViewModel pl in parent)
            {
                AllTracksViewModel other = pl.AlltracksVm;
                //if (true == onlyDisabled)
                //    other = pl.AlltracksVmd;
                //else
                //    other = pl.AlltracksVm;
                other.buildAllTraks(container, dict, onlyDisabled, onlyFathers);
            }
        }

        #region cmd

        private ICommand _contextCmdCheck;
        public ICommand ContextCmdCheck { get { if (_contextCmdCheck == null) _contextCmdCheck = new CheckCmd(); return _contextCmdCheck; } }

        private ICommand _contextCmdUnCheck;
        public ICommand ContextCmdUnCheck { get { if (_contextCmdUnCheck == null) _contextCmdUnCheck = new UnCheckCmd(); return _contextCmdUnCheck; } }


        private ICommand _contextLinkFather;
        public ICommand LinkFather { get { if (_contextLinkFather == null) _contextLinkFather = new LinkFather(); return _contextLinkFather; } }

        private ICommand _contextLinkChild;
        public ICommand LinkChild { get { if (_contextLinkChild == null) _contextLinkChild = new LinkChild(); return _contextLinkChild; } }

        private ICommand _contextLinkFusion;
        public ICommand LinkFusion { get { if (_contextLinkFusion == null) _contextLinkFusion = new LinkFusion(); return _contextLinkFusion; } }

        private ICommand _contextUnLink;
        public ICommand LinkReset { get { if (_contextUnLink == null) _contextUnLink = new LinkReset(); return _contextUnLink; } }

        private ICommand _contextExport;
        public ICommand Export { get { if (_contextExport == null) _contextExport = new ExportCmd(); return _contextExport; } }

        private ICommand _contextExportCompress;
        public ICommand ExportCompress { get { if (_contextExportCompress == null) _contextExportCompress = new ExportCompress(); return _contextExportCompress; } }

        private ICommand _contextDelete;
        public ICommand DeleteTrack { get { if (_contextDelete == null) _contextDelete = new DeleteCmd(); return _contextDelete; } }

        private ICommand _contexExplorer;
        public ICommand Explorer { get { if (_contexExplorer == null) _contexExplorer = new Explorer(); return _contexExplorer; } }



        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(App.Instance); return _ContextCmdAddToList; } }

        private ICommand _ContextCmdDbDeleteClassement;
        public ICommand ContextCmdDbDeleteClassement { get { if (_ContextCmdDbDeleteClassement == null) _ContextCmdDbDeleteClassement = new DbDeleteLastClassement(); return _ContextCmdDbDeleteClassement; } }

        private ICommand _ContextCmdDbDeleteRead;
        public ICommand ContextCmdDbDeleteRead { get { if (_ContextCmdDbDeleteRead == null) _ContextCmdDbDeleteRead = new DbDeleteLastRead(); return _ContextCmdDbDeleteRead; } }


        #endregion

        public TrackListViewModel HumanSelected
        {
            get
            {
                return TrackListViewModel.HumanSelected;
            }
        }

        #region from Ihm
        private TrackListViewModel selectedTrack;
        public TrackListViewModel SelectedTrack
        {
            get
            {
                return selectedTrack;
            }
            set
            {
                selectedTrack = value;
                TrackListViewModel.setHumanSelected(parent, value); //  .HumanSelected = value;
                if (selectedTrack != null)
                    selectedTrack.IsSelected = true;
            }
        }
        #endregion

        private int nbAlbumMoved;

        public int NbAlbumMoved
        {
            get { return nbAlbumMoved; }
        }

        private int nbEmpeached;
        public int NbEmpeached { get { return nbEmpeached; } }

        private void writeConf(StringBuilder sb, ConfMedianneVirt conf)
        {
            var coeff = conf.coeffVirt;
            if (coeff == 1)
                coeff = conf.CoeffOld;
            sb.Append((coeff - 1).FormatE(3)); sb.Append("\t "); //(3,3,9));                  

            sb.Append((conf.v).FormatE(3)); sb.Append("\t ");  //sb.Append("m  ");

            sb.Append(conf.a.FormatE(3)); sb.Append("\t ");
            if (conf.CoeffStaticmRetour > 1)
            {
                sb.Append(conf.CurrentStaticm.FormatE(3)); sb.Append("\t ");
            }


            sb.Append(conf.Serial); sb.Append(" ");
            //  sb.Append(conf.SerialBox); sb.Append(" ");
            // sb.Append(conf.Alt); sb.Append(" ");
            sb.Append(conf.AltHisto); sb.Append("  ");
            sb.Append(conf.Elastique.ToString("0.##")); sb.Append(" ");
            sb.Append(conf.Elastique2.ToString("0.##")); sb.Append(" ");
            sb.Append(conf.DeltaElastiqueDisplay.ToString("0.##")); sb.Append(" ");
            var coeffLot = conf.CoeffLotDisplay; 
            if (coeffLot <1m)
                sb.Append(coeffLot.ToString("#.##"));
        }

        private void check(StringBuilder sb, StringBuilder sb2)
        {
            sb.Append(" ");
            sb2.Append(" ");

            while (sb.Length < sb2.Length)
                sb.Append(" ");
            while (sb2.Length < sb.Length)
                sb2.Append(" ");

        }

        //private void writeConf(StringBuilder sb, ConfMedianneVirt conf, StringBuilder sb2, ConfMedianneVirt conf2)
        //{
        //    sb.Append((conf.coeffVirt - 1).FormatE(4));
        //    sb2.Append((conf2.coeffVirt - 1).FormatE(4));

        //    check(sb, sb2); 

        //    sb.Append((conf.v).FormatE(4));
        //    sb2.Append((conf2.v).FormatE(4));
        //    check(sb, sb2); 

        //    sb.Append(conf.a.FormatE(4));
        //    sb2.Append(conf2.a.FormatE(4));
        //    check(sb, sb2); 

        //    sb.Append(conf.CurrentStaticm.FormatE(3));
        //    sb2.Append(conf2.CurrentStaticm.FormatE(3));
        //    check(sb, sb2);

        //    sb.Append(conf.Serial);
        //    sb2.Append(conf2.Serial);
        //    check(sb, sb2);
        //    //  sb.Append(conf.SerialBox); sb.Append(" ");
        //    // sb.Append(conf.Alt); sb.Append(" ");
        //    sb.Append(conf.AltHisto); 
        //    sb2.Append(conf2.AltHisto);
        //    check(sb, sb2);


        //    sb.Append(conf.Elastique.ToString("0.##"));
        //    sb2.Append(conf2.Elastique.ToString("0.##"));

        //    check(sb, sb2); 
        //    sb.Append(conf.Elastique2.ToString("0.##"));
        //    sb2.Append(conf2.Elastique2.ToString("0.##"));
        //}

        public string AutoResume
        {
            get
            {

                try
                {
                    var confM = App.gen.SortAlbumMode.ComposantsUtiles[0];
                    var conf = confM.Main;
                    var min = confM.Min;
                    var sb = new StringBuilder();



                    //if (min.Use)
                    //{
                    //    var sb2 = new StringBuilder();
                    //    writeConf(sb, conf, sb2, min);
                    //    sb.AppendLine();
                    //    sb.Append(sb2.ToString()); 
                    //}

                    //else
                    //    writeConf(sb, conf);


                    writeConf(sb, conf);
                    if (min.Use)
                    {
                        sb.AppendLine();
                        writeConf(sb, min);
                    }


                    return sb.ToString();

                }
                catch
                {
                    return "";
                }
            }
        }
        public string NbAlbumMovedDesc
        {
            get
            {
                if (nbAlbumMoved < 0)
                    return "";
                if (nbAlbumMoved == 0)
                    return "pas d'album en quarantaine";
                return string.Format("{0} albums en quarantaine", nbAlbumMoved);
            }
        }

        public void setNbAlbum(int nbanavailable, int empeches, int moved)
        {
            if (nbanavailable != this.nbAlbumMovedUnavailable)
            {
                this.nbAlbumMovedUnavailable = nbanavailable;
                OnPropertyChanged("NbAlbumMovedUnavailable");
            }

            if (empeches != nbEmpeached)
            {
                nbEmpeached = empeches;
                OnPropertyChanged("NbEmpeached");
            }

            if (moved != nbAlbumMoved)
            {
                nbAlbumMoved = moved;
                OnPropertyChanged("NbAlbumMoved");
            }
        }

        //public void setNbAlbumMoved(int nb)
        //{
        //    if (nb != nbAlbumMoved)
        //    {
        //        nbAlbumMoved = nb;
        //        OnPropertyChanged("NbAlbumMoved");
        //        OnPropertyChanged("NbAlbumMovedDesc");
        //    }

        //}

        private int nbAlbumMovedUnavailable;
        public int NbAlbumMovedUnavailable
        {
            get
            {
                return nbAlbumMovedUnavailable;
            }

            //set
            //{
            //    if (value != nbAlbumMovedUnavailable)
            //    {
            //        nbAlbumMovedUnavailable = value;
            //        OnPropertyChanged("NbAlbumMovedUnavailable");
            //    }
            //}
        }

    }


}
]]></content>
  </file>
   <file path="\PieceDb.Consolid\albums\AlbumComparer.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using pdb.gen.medianne;
using pdb.gen.Tuning;

namespace pdb.gen.albums
{
    //public enum albumSortMode
    //{
    //    /// <summary>
    //    /// tri sur moyenne quand aucun des albums n'a défini sa médianne
    //    /// </summary>
    //    strict,
    //    /// <summary>
    //    /// tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
    //    /// </summary>
    //    mix,
    //    /// <summary>
    //    /// Tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
    //    /// </summary>
    //    mixLight,
    //    /// <summary>
    //    /// Tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
    //    /// </summary>
    //    mixLight2,
    //    /// <summary>
    //    /// Calcul médianne quasi strict, qq miettes pour éviter le zero
    //    /// </summary>
    //    medQuasi,
    //    /// <summary>
    //    /// Calcul Médianne moins strict
    //    /// </summary>
    //    medLight,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe2,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe3,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 4 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe4,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 5 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe5,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 6 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe6,
    //    /// <summary>
    //    /// Calcul medLight, on virtualise jusqu'à 10 morceaux pour avoir une estimation basse
    //    /// </summary>
    //    medLightSafe10,
    //    /// <summary>
    //    /// tri uniquement sur la moyenne
    //    /// </summary>
    //    light

    //}
    class AlbumClassComparer : IComparer<Album>
    {
        private ConfAlbumSort mode;
        private ConfMedianne zero;
        private bool useSt;
        public AlbumClassComparer(ConfAlbumSort mode, bool useSt, ConfMedianne zero)
        {
            this.mode = mode;
            this.useSt = useSt;
            this.zero = zero;
        }
        private void calc(ref decimal xx, ref decimal yy, Album x, Album y, ConfMedianne cmpt)
        {
            switch (cmpt.type)
            {
                case medianneMode.none:
                    break;
                case medianneMode.strict: xx = x.ClassementValue; yy = y.ClassementValue;
                    break;
                case medianneMode.light:
                    if (useSt)
                    {
                        if (zero == null)
                        {
                            xx = x.ClassementValueLightSt;
                            yy = y.ClassementValueLightSt;
                        }
                        else
                        {
                            xx = x.ClassementValueLightZeroSt;
                            yy = y.ClassementValueLightZeroSt;
                        }
                    }
                    else
                    {
                        if (zero == null)
                        {
                            xx = x.ClassementValueLight;
                            yy = y.ClassementValueLight;
                        }

                        else
                        {
                            xx = x.ClassementValueLightZero;
                            yy = y.ClassementValueLightZero;
                        }
                    }
                    break;
                case medianneMode.moy: xx = x.ClassementMoy; yy = y.ClassementMoy;
                    break;
                default:
                    break;
            }
        }

        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;


            int cmp = 0;




            decimal xx = 0;
            decimal yy = 0;

            var composants = mode.ComposantsUtiles;
            if (composants.Count > 1)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    var cmpt2 = composants[1];
                    calc(ref xx, ref yy, x, y, cmpt2);
                    cmp = xx.CompareTo(yy);
                    if (cmp != 0)
                        return cmp;
                }

            }

            var cmpt = composants[0];
            if (zero != null)
                cmpt = zero;
            calc(ref xx, ref yy, x, y, cmpt);

            cmp = xx.CompareTo(yy);
            if (cmp != 0)
                return cmp;

            //if (mode == albumSortMode.light)
            //{
            //    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //    if (cmp != 0)
            //        return cmp;
            //}
            //else if (mode == albumSortMode.mix)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.mixLight)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.mixLight2)
            //{
            //    if (x.ClassementValue == 0m || y.ClassementValue == 0m)
            //    {
            //        cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //    else
            //    {
            //        cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //}

            //else if (mode == albumSortMode.medLight
            //    || mode == albumSortMode.medQuasi
            //    || mode == albumSortMode.medLightSafe
            //    || mode == albumSortMode.medLightSafe2
            //    || mode == albumSortMode.medLightSafe3
            //    || mode == albumSortMode.medLightSafe4
            //    || mode == albumSortMode.medLightSafe5
            //    || mode == albumSortMode.medLightSafe6
            //    || mode == albumSortMode.medLightSafe10
            //    )
            //{
            //    cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            //    if (cmp != 0)
            //        return cmp;
            //}


            cmp = x.Count.CompareTo(y.Count);
            if (cmp != 0)
                return -cmp; 

            var xNext = x.Next;
            var yNext = y.Next;
            if (xNext == null && yNext == null)
            {

            }
            else
            {
                if (xNext == null)
                    return 1;

                if (yNext == null)
                    return -1;

                cmp = xNext.Duration.CompareTo(yNext.Duration);
                if (cmp != 0)
                    return cmp;
            }

            cmp = x.ClassementValue.CompareTo(y.ClassementValue);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementValueLight.CompareTo(y.ClassementValueLight);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            if (cmp != 0)
                return cmp;

            int i = 0;
            var t1 = -2m;
            var t2 = -2m;

            var lx = new List<Piece>(x);
            var ly = new List<Piece>(y);
            while (true)
            {
                t1 = x.getTrackSortValue(i, lx);
                t2 = y.getTrackSortValue(i, ly);

                cmp = t1.CompareTo(t2);
                if (cmp != 0)
                    return cmp;



                if (t1 == 0)
                    break;

                i++;

            }
            cmp = x.DurationValue.CompareTo(y.DurationValue);
            if (cmp != 0)
                return cmp;
            return -x.Name.CompareTo(y.Name);

        }
    }

    //class AlbumClassComparerStack : IComparer<Album>
    //{
    //    public int Compare(Album x, Album y)
    //    {
    //        //int cmp = x.StackIndex.CompareTo(y.StackIndex);
    //        //if (cmp != 0)
    //        //    return cmp;
    //        return x.Rank.Sort.CompareTo(y.Rank.Sort);
    //    }
    //}

    class AlbumClassComparer2 : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            return x.Rank.Sort.CompareTo(y.Rank.Sort);
        }
    }

    class VirtualPieceComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
          // mode normal
            if (x.PieceId == y.PieceId)
                return 0; 
            int cmp = x.Artist.CompareTo(y.Artist); 
            if (cmp != 0)
                return cmp; 
            cmp = x.Master.Album.CompareTo(y.Master.Album); 
            if (cmp != 0)
                return cmp;
            var xt = x.MasterTrackNumber > 0 ? x.MasterTrackNumber : x.TrackNumber;
            var yt = y.MasterTrackNumber > 0 ? y.MasterTrackNumber : y.TrackNumber;

            cmp = xt.CompareTo(yt);
            if (cmp != 0)
                return cmp;
            var xx = "";
            var yy = "";

            var xpath = x.getLocation();
            var ypath = y.getLocation();
            if (xpath == ypath)
                return 0;
         
            return xpath.CompareTo(ypath);
            // mode inverse

        }
    }


    class AlbumSortComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;

            if (x.Rank.SortValue == 0)
            {

            }

            var xx = x.getFirstTrackSortValue();
            var yy = y.getFirstTrackSortValue();

            return xx.CompareTo(yy);

        }
    }

    class AlbumRestComparer : IComparer<Album>
    {
        static AlbumSortComparer subCmp = new AlbumSortComparer();
        const decimal EPSILON = 0.00001m;
        public int Compare(Album x, Album y)
        {
            var xx = x.Rank.TimeRest;
            var yy = y.Rank.TimeRest;
            int cmp = 0;
            if (System.Math.Abs(xx - yy) >= EPSILON)
                cmp = xx.CompareTo(yy);
            if (cmp == 0)
                return subCmp.Compare(x, y);
            return cmp;
        }
    }

   

    class PieceInVirtualAlbumComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            var xt = x.MasterTrackNumber > 0 ? x.MasterTrackNumber : x.TrackNumber;
            var yt = y.MasterTrackNumber > 0 ? y.MasterTrackNumber : y.TrackNumber;

            int cmp = xt.CompareTo(yt); 
            if (cmp != 0)
                return cmp;
            var xx = "";
            var yy = "";

            var xpath = x.getLocation();
            var ypath = y.getLocation();
            if (xpath == ypath)
                return 0; 
            //if (x.Master.TrackNumber <= 0)
            //{
            //    try
            //    { 
            //        cmp = x.TrackNumber.CompareTo(y.TrackNumber); 
            //        if (cmp !=0)
            //            return cmp; 
                  
            //        var xf = Path.GetFileNameWithoutExtension(xpath);
            //        var yf = Path.GetFileNameWithoutExtension(xpath);
            //        cmp = xf.CompareTo(yf);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //    catch
            //    {
            //    }
            //}

            //if (x != null && x.getLocation() != null) xx = x.getLocation();
            //if (y != null && y.getLocation() != null) yy = y.getLocation();
            return xpath.CompareTo(ypath);
        }
    }

    class PieceInAlbumComparer : IComparer<Piece>
    {
        private bool debile(int trackNumber)
        {
            return trackNumber <= 0 || trackNumber > 10000;
        }

        private bool debile(Piece piece)
        {
            return debile(piece.TrackNumber);
        }
        public int Compare(Piece x, Piece y)
        {
            if (debile(x))
            {
                if (debile(y))
                {
                    var f1 = Path.GetFileName(x.getLocation());
                    var f2 = Path.GetFileName(y.getLocation());
                    return f1.CompareTo(f2);
                }
                return -1;
            }
            if (debile(y))
                return 1;
            var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            return x.getLocation().CompareTo(y.getLocation());
        }
    }

    class AllPieceComparer : IComparer<Piece>
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public int Compare(Piece x, Piece y)
        {
            int cmp = albumcomp.Compare(x.PieceAlbum, y.PieceAlbum);
            if (cmp != 0)
                return cmp;
            return -pieceComp.Compare(x, y);
        }
    }

    class AllPieceComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.RankAllAlbum.CompareTo(y.RankAllAlbum);
        }
    }

    class AlbumNameComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            return x.Name.CompareTo(y.Name);
        }
    }

    //class AlbumLastModifClassementComparer : IComparer<Album>
    //{
    //    public int Compare(Album x, Album y)
    //    {


    //        var dtx = x.UpdateClassement;
    //        var dty = y.UpdateClassement;
    //        int cmp =0;
    //        if (dtx == null)
    //        {
    //            if (dty == null)
    //            {
    //            }
    //            else
    //                cmp = -1;
    //        }
    //        else if (dty == null)
    //            cmp = 1;
    //        else
    //            cmp = dtx.Value.CompareTo(dty.Value); 


    //        if (cmp != 0)
    //            return cmp;
    //        return x.Name.CompareTo(y.Name);
    //    }
    //}

    class VirtualAlbumComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            var cmp = x.Name.Length.CompareTo(y.Name.Length);
            if (cmp != 0)
                return cmp;
            return x.Name.CompareTo(y.Name);
        }
    }


}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using pdb.gen.auto;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        // private static PieceExtended index;
        //  public static int Index { get { return index; } }
        private static PieceExtended median;


        //public static DecimalIndex getMedianne(IList<Piece> list, bool main, decimal coeffMedianne)
        //{

        //    return new DecimalIndex() { d = getMedianne_(list, main, coeffMedianne), index = index };
        //}


        public static DecimalPiece getMedianne(IList<PieceExtended> list, bool main, decimal coeffMedianne)
        {
            PieceExtended.Mode = PieceExtended.mode.main;
            var ret = getMedianne_(list, coeffMedianne);
            return new DecimalPiece() { d = ret, index = median };
        }
        private List<PieceExtended> pieces;
        private ConfMedianne mode;
        private int _nbNoAdd;
        public AlbumMedianne(List<PieceExtended> pieces, ConfMedianne mode)
        {
            this.pieces = pieces;
            this.mode = mode;
            this._nbNoAdd = getNoAdd(mode.Main);
        }



        public void buildVirtual(bool combine, bool simple)
        {

            if (!mode.Min.Use)
            {
                buildVirtual0(mode.Main, true);
                align(mode.Main, PieceExtended.mode.main);
            }
            else
            {
                buildVirtual0(mode.Main, true);
                buildVirtual0(mode.Min, false);

                if (combine)
                {
                    foreach (PieceExtended p in pieces)
                        p.Combine();
                    align(mode.Main, PieceExtended.mode.combine);
                }

                if (!simple)
                {
                    align(mode.Main, PieceExtended.mode.main);
                    align(mode.Min, PieceExtended.mode.min);
                }
            }



            //if (!mode.Min.Use)
            //{
            //    buildVirtual0(mode.Main, true);
            //    align(mode.Main, PieceExtended.mode.main);
            //}
            //else if (combine && simple)
            //{
            //    buildVirtual0(mode.Main, true);
            //    buildVirtual0(mode.Min, false);
            //    foreach (PieceExtended p in pieces)
            //        p.Combine();
            //    align(mode.Main, PieceExtended.mode.combine);
            //}
            //else
            //{
            //    buildVirtual0(mode.Main, true);
            //    buildVirtual0(mode.Min, false);
            //    align(mode.Main, PieceExtended.mode.main);
            //    align(mode.Min, PieceExtended.mode.min);

            //    if (combine)
            //    {
            //        foreach (PieceExtended p in pieces)
            //            p.Combine();
            //        align(mode.Main, PieceExtended.mode.combine);
            //    }
            //}
        }

        private int getNoAdd(ConfMedianneVirt modeVirt)
        {

            var safe = modeVirt.safe;
            var _nbNoAdd = 0;

            int i0 = 0;
            int count = pieces.Count;
            if ((modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll) || modeVirt.noAddAll)
                return pieces.Count;
            else if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
            {
                _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
                if (modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll)
                    return _nbNoAdd;
                if (_nbNoAdd > 0)
                    _nbNoAdd--;
            }
            else
            {
                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.VirtualClassement == 0m)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }
            }

            //if (modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll)
            //    return _nbNoAdd;

            if (modeVirt.noAddEnd)
            {
                // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                // morceaux déjà notés
                var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
                _nbNoAdd = _nbNoAdd - nb2;
                if (_nbNoAdd < 0)
                    _nbNoAdd = 0;
            }
            _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

            return _nbNoAdd;
        }

        public void align(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        {
            var count = pieces.Count;
            if (count < 2)
                return;
            PieceExtended.Mode = main;
            pieces.Sort(new PieceCmp0());

            decimal prec = pieces[count - 1].Value;

            var coeffEnabled = modeVirt.CoeffOld;


            for (int j = count - 2; j >= 0; j--)
            {
                var cand = pieces[j].Value;
                bool change = false;
                if (cand == 0)
                    continue;
                if (modeVirt.virtAlignPrec)
                {
                    if (cand < prec)
                    {
                        cand = prec + EPSILON;
                        change = true;
                    }
                }

                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                {

                    // quel serait le score s'il était coché
                    var vu = pieces[j].Value / coeffEnabled;
                    // en plus une petite marge
                    //  vu *= mode.coeffVirt; 
                    if (cand < vu)
                    {
                        cand = vu;
                        change = true;
                    }
                }
                if (change)
                    pieces[j].Value = cand;

                prec = cand;
            }

        }

        //public void align0(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        //{
        //    var count = pieces.Count; 
        //    if (count < 2)
        //        return;
        //    pieces.Sort(new PieceCmp0()); 
        //    //if (main== PieceExtended.mode.main)
        //    //    pieces.Sort(new PieceCmp());
        //    //else if (main == PieceExtended.mode.min)
        //    //    pieces.Sort(new PieceCmp2());
        //    //else
        //    //    pieces.Sort(new PieceCmp3());
        //    decimal prec = 0m;

        //    var coeffEnabled = modeVirt.CoeffOld;

        //    if (modeVirt.virtAlignPrec)
        //    {
        //        //if (_nbNoAdd < pieces.Count)
        //            prec = pieces[_nbNoAdd].Value;
        //    }

        //    for (int j = _nbNoAdd - 1; j >= 0; j--)
        //    {
        //        if (j < pieces.Count)
        //        {

        //            if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //            {
        //                var cand = pieces[j].Value;
        //                if (modeVirt.virtAlignPrec)
        //                {
        //                    if (cand < prec)
        //                        cand = prec + EPSILON;
        //                }

        //                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                {

        //                    // quel serait le score s'il était coché
        //                    var vu = pieces[j].Value / coeffEnabled;
        //                    // en plus une petite marge
        //                    //  vu *= mode.coeffVirt; 
        //                    if (cand < vu)
        //                        cand = vu;
        //                }
        //                pieces[j].Value = cand;

        //            }

        //            prec = pieces[j].Value;
        //        }
        //    }
        //}

        public void buildVirtual0(ConfMedianneVirt modeVirt, bool main)
        {
            DateTime limitDC = DateTime.Now.AddDays(-modeVirt.virtDelay);
            var coeffEnabled = modeVirt.CoeffOld;

            var _coeffVirt = modeVirt.coeffVirt;
            var safe = modeVirt.safe;
            int i0 = 0;

            int count = pieces.Count;
            PieceClassementComparer cmp = null;
            PieceExtended.Mode = main ? PieceExtended.mode.main : PieceExtended.mode.min;

            if (coeffEnabled > 1)
            {
                for (int i = 0; i < count; i++)
                {
                    var p = pieces[i];

                    if (p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
                        p.setCoeff(coeffEnabled, main);
                }
            }

            cmp = new PieceClassementComparer(false, main ? PieceExtended.mode.main : PieceExtended.mode.min);
            pieces.Sort(cmp);

            int indexV = 0;
            int nbAdd = 0;
            var _zero = mode.zero;
            i0 = count - 1;


            int _count = System.Math.Min(count, i0 + safe);
            decimal[] virt = null; // = new decimal[_count];
            //_nbNoAdd = System.Math.Min(safe, _nbNoAdd);
            var _coeffVirt0 = _coeffVirt;

            if (modeVirt.noAdd)
            {
                if (_coeffVirt > 1)
                {
                    if (modeVirt.coeffVirtAuto && (modeVirt.coeffVirtAutoAll || count < safe))
                    // if (count < safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;


                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < pieces.Count)
                        {
                            var dc = pieces[j].Piece.UpdateClassement;

                            if (modeVirt.noVirtZero && pieces[j].Empty)
                                continue; 

                            if (modeVirt.forceCoeffVirt)
                                _coeff *= _coeffVirt;
                            else if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
                                _coeff *= _coeffVirt;


                            if (pieces[j].Empty)
                                continue;
                            if (dc == null || dc.Value < limitDC)
                            {
                                pieces[j].Coeff = _coeff; // Value = pieces[j].Value / _coeff;
                            }
                            //pieces[j].EffectMain = coeffEnabled < _coeff;

                        }
                    }
                }

            }
            else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = pieces[i].Value;
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= _coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
            }
            else
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    decimal courant = pieces[0].Value;
                    for (int i = 1; i < _count; i++)
                    {
                        if (pieces[i].Value <= _zero)
                        {
                            courant /= _coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = pieces[i].Value;
                    }
                }
            }

            decimal value = int.MaxValue;


            if (!modeVirt.noAdd)
            {
                int ii = 0;
                if (virt == null)
                    virt = new decimal[_count];
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = pieces[ii].Value;
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (modeVirt.lissage || value <= _zero)
                        {
                            if (value <= _zero)
                                nbAdd++;
                            value = calc;
                            pieces[ii].Value = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (modeVirt.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= safe)
                            continue;
                        pieces[i].Value = 0m;
                    }

                }
                if (mode.removeFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces[i].Value = 0m;
                    }
                }
            }



            if (mode.deleteFirst)
            {
                for (int i = 0; i < nbAdd; i++)
                {
                    pieces.RemoveAt(0);
                }
            }

        }

        //public static int buildVirtual(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, bool main, bool combine, ref int i0)
        //{
        //    var coeffEnabled = modeVirt.CoeffOld;

        //    var _coeffVirt = modeVirt.coeffVirt;
        //    var safe = modeVirt.safe;
        //    if (combine)
        //    {
        //        coeffEnabled = mode.Main.CoeffOld * mode.Min.CoeffOld;
        //        _coeffVirt = mode.Main.coeffVirt * mode.Min.coeffVirt;
        //        safe = (int)Math.Max(mode.Main.safe, mode.Min.safe);
        //    }


        //    //   var coeff = 1 / coeffEnabled; 
        //    int count = pieces.Count;
        //    PieceClassementComparer cmp = new PieceClassementComparer(false);
        //    pieces.Sort(cmp);
        //    //if (coeffEnabled != 1)
        //    //{
        //    if (coeffEnabled > 1)
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            var p = pieces[i];
        //            //  var rapportClassement = p.RapportClassement;
        //            if (coeffEnabled != 1m && p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
        //            {
        //                p.setCoeff(coeffEnabled, main);
        //                //rapportClassement /= coeffEnabled;
        //            }

        //            //p.setClassementVirtuel(rapportClassement);
        //            //if (!main)
        //            //    p.setClassementVirtuel2(rapportClassement);
        //        }
        //    }

        //    cmp = new PieceClassementComparer(false, main ? PieceExtended.mode.main : PieceExtended.mode.min);
        //    pieces.Sort(cmp);
        //    // }

        //    int indexV = 0;
        //    int nbAdd = 0;


        //    // List<Piece> _pieces = pieces;
        //    var _zero = mode.zero;


        //    //if (modeVirt.safe > 0)
        //    //{
        //    i0 = count - 1;
        //    int _nbNoAdd = 0;




        //    if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
        //    {
        //        _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
        //        if (_nbNoAdd > 0)
        //            _nbNoAdd--;
        //    }
        //    else if (modeVirt.noAddAll)
        //        _nbNoAdd = pieces.Count;
        //    else
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            var pp = pieces[i];
        //            if (pp.VirtualClassement == 0m)
        //            {
        //                i0 = i;
        //                _nbNoAdd = count - i0;
        //                break;
        //            }
        //        }
        //    }

        //    if (modeVirt.noAddEnd)
        //    {
        //        // var nb1 = pieces.Count<Piece>(p => p.Enabled);
        //        // morceaux déjà notés
        //        var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
        //        _nbNoAdd = _nbNoAdd - nb2;
        //        if (_nbNoAdd < 0)
        //            _nbNoAdd = 0;
        //    }
        //    //if (i0 == 0)
        //    //    return 0;
        //    //}

        //    //for (int i00 = 1; i00 <= i0; i00++)
        //    //{
        //    //    decimal coeff = (decimal)i00 / (decimal)i0;
        //    //List<decimal> _list = new List<decimal>();
        //    //for (int i = 0; i < pieces.Count; i++)
        //    //    _list.Add(pieces[i].getVirtual(main));
        //    //for (int i = i00; i < count; i++)
        //    //    _list[i] = 0m;
        //    //liste partielle originale
        //    //  List<decimal> _list0 = new List<decimal>(_list);
        //    int _count = System.Math.Min(count, i0 + safe);
        //    decimal[] virt = new decimal[_count];
        //    _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

        //    if (modeVirt.noAdd)
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            // var coeffEnabled = modeVirt.coeffOld; 

        //            if (count < safe && modeVirt.coeffVirtAuto)
        //            {
        //                if (modeVirt.coeffVirtAdjust)
        //                    _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
        //                else
        //                {
        //                    // ex 2^10 = 1024
        //                    // je veux obtenir 1024 avec 3
        //                    _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
        //                }
        //            }

        //            decimal _coeff = 1m;
        //            decimal prec = 0m;
        //            if (modeVirt.virtAlignPrec)
        //            {
        //                if (_nbNoAdd < pieces.Count)
        //                    prec = pieces[_nbNoAdd].Value;
        //            }

        //            for (int j = _nbNoAdd - 1; j >= 0; j--)
        //            {
        //                if (j < pieces.Count)
        //                {

        //                    if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //                    {
        //                        _coeff *= _coeffVirt;
        //                        var cand = pieces[j].Value / _coeff;
        //                        if (modeVirt.virtAlignPrec)
        //                        {
        //                            if (cand < prec)
        //                                cand = prec + EPSILON;
        //                        }

        //                        if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                        {
        //                            // quel serait le score s'il était coché
        //                            var vu = pieces[j].Value / coeffEnabled;
        //                            // en plus une petite marge
        //                            //  vu *= mode.coeffVirt; 
        //                            if (cand < vu)
        //                                cand = vu;
        //                        }
        //                        pieces[j].Value = cand;
        //                        // pieces[j].EffectMain = coeffEnabled < _coeff;
        //                    }
        //                    else if (modeVirt.forceCoeffVirt)
        //                        _coeff /= _coeffVirt;
        //                    prec = pieces[j].Value;
        //                }
        //            }
        //        }

        //    }
        //    else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            for (int i = 0; i < i0; i++)
        //            {
        //                decimal _coeff = 1m;
        //                decimal _base = pieces[i].Value;
        //                for (int j = i + 1; j < _count; j++)
        //                {
        //                    _coeff /= _coeffVirt;
        //                    virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
        //                }
        //            }
        //        }
        //    }
        //    else
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            decimal courant = pieces[0].Value;
        //            for (int i = 1; i < _count; i++)
        //            {
        //                if (pieces[i].Value <= _zero)
        //                {
        //                    courant /= _coeffVirt;
        //                    virt[i] = courant;
        //                }
        //                else
        //                    courant = pieces[i].Value;
        //            }
        //        }
        //    }

        //    decimal value = int.MaxValue;
        //    int ii = 0;
        //    if (modeVirt.noAdd)
        //    {
        //        //for (ii = 1; ii < count && ii < _count; ii++)
        //        //{
        //        //    var calc = virt[ii];
        //        //    if (calc > 0m)
        //        //        list[ii] = calc;
        //        //}
        //    }
        //    else
        //    {
        //        for (ii = 1; ii < count && ii < _count; ii++)
        //        {
        //            value = pieces[ii].Value;
        //            var calc = virt[ii];
        //            if (value < calc)
        //            {
        //                if (modeVirt.lissage || value <= _zero)
        //                {
        //                    if (value <= _zero)
        //                        nbAdd++;
        //                    value = calc;
        //                    pieces[ii].Value = value;
        //                }

        //            }
        //            else
        //                indexV = ii;
        //        }
        //        if (modeVirt.removeEpsilon)
        //        {
        //            // j'ai 5 virtuel alors que j'ai deux safe
        //            ///xx---
        //            int nb = 0;
        //            for (int i = indexV + 1; i < _count; i++)
        //            {
        //                nb++;
        //                if (nb <= safe)
        //                    continue;
        //                pieces[i].Value = 0m;
        //            }

        //        }
        //        if (mode.removeFirst)
        //        {
        //            for (int i = 0; i < nbAdd; i++)
        //            {
        //                pieces[i].Value = 0m;
        //            }
        //        }
        //    }

        //    //for (int i = 0; i < _list.Count && i < pieces.Count; i++)
        //    //{
        //    //    pieces[i].setValue(_list[i], main); 
        //    //    //if (main)
        //    //    //    pieces[i].setClassementVirtuel(_list[i]);
        //    //    //else
        //    //    //    pieces[i].setClassementVirtuel2(_list[i]);
        //    //}

        //    if (mode.deleteFirst)
        //    {
        //        for (int i = 0; i < nbAdd; i++)
        //        {
        //            pieces.RemoveAt(0);
        //        }
        //    }

        //    if (modeVirt.reSort || mode.removeFirst || modeVirt.noAdd)
        //    {
        //        //_list.Sort();
        //        //_list.Reverse();
        //        if (main)
        //            pieces.Sort(new PieceCmp());
        //        else
        //            pieces.Sort(new PieceCmp2());
        //    }



        //    if (modeVirt.noAdd)
        //        nbAdd = _nbNoAdd;
        //    //}
        //    return nbAdd;
        //}


        public DecimalPiece getMedianneLight(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        {

            DecimalPiece ret0 = new DecimalPiece();
            DecimalPiece ret = ret0;
            try
            {
                var _zero = mode.zero;

                PieceExtended.Mode = main;
                //foreach (PieceExtended p in pieces)
                //    p.Mode = main;

                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = median;
                ret = ret0;


                int i0 = 0;
                int count = pieces.Count;


                ret = calcmedianneVirt(modeVirt);
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<PieceExtended>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }




            }
            finally
            {


            }

            return ret;
        }






        //public static DecimalIndex getMedianneLight(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, PieceExtended.mode main, bool combine)
        //{

        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {
        //        var _zero = mode.zero;


        //        foreach (PieceExtended p in pieces)
        //            p.Mode = main;

        //        var medianne = getMedianne_(pieces, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;
        //        ret = ret0;
        //        //if (pieces.Count == 1)
        //        //    return ret0;

        //        int i0 = 0;
        //        int count = pieces.Count;
        //        int nbAdd = buildVirtual(pieces, mode, modeVirt, main, combine, ref i0);
        //        //if (mode.combine && mode.simple)
        //        //{
        //        //    int i1 = 0;
        //        //    buildVirtual(pieces, mode, mode.Min, false, ref i1);
        //        //    foreach (var p in pieces)
        //        //    {
        //        //        p.setClassementVirtuelCombine();
        //        //    }
        //        //}
        //        ret = calcmedianneVirt(pieces, mode, modeVirt, main, nbAdd, System.Math.Min(i0, modeVirt.safe));
        //        if (mode.expEnabled != 0)
        //        {
        //            int _nb = pieces.Count<PieceExtended>(p => !p.Enabled);
        //            decimal _c = (decimal)_nb / (decimal)count;
        //            _c = Math.Pow(_c, mode.expEnabled);
        //            ret.d *= _c;
        //        }




        //    }
        //    finally
        //    {


        //    }

        //    return ret;
        //}

        private class PieceCmp0 : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.RapportClassement.CompareTo(y.RapportClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }


        private class PieceCmp : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }

        private class PieceCmp2 : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }

        private class PieceCmp3 : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }




        //private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        //{
        //    var _list = new List<decimal>(list);
        //    int count = _list.Count;

        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        if (_list[count - i - 1] > conf.zero)
        //        {

        //            if (conf.removeLast == removeLast.non)
        //                break;
        //            _nbSupp++;
        //            if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                break;
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}


        private DecimalPiece calcmedianneVirt(ConfMedianneVirt confc)
        {
            var _list = new List<PieceExtended>(pieces);
            var classes = _list.FindAll(p => p.VirtualClassement > mode.zero);

            if (confc.oldAsZero)
                classes = _list.FindAll(p => p.LastClassementRecent);

            int count = _list.Count;

            int nbEnabled = classes.Count<PieceExtended>(p => p.Enabled);
            int nbDisabled = classes.Count<PieceExtended>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


            DecimalPiece ret = new DecimalPiece() { d = 0m, index = null }; // 0m; // decimal ret = int.MinValue;
            if (pieces.Count > 0)
                ret.index = pieces[0];
            int _nbSupp = 0;
            decimal coeffp = 1m;

            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {
                int ilast = _list.Count - 1;
                var last = _list[ilast];
                if (i > 0)
                {
                    if (last.VirtualClassement <= mode.zero)
                        _list.RemoveAt(ilast);
                    else
                        break;
                    ilast = _list.Count - 1;
                    if (ilast < 0)
                        break;
                    last = _list[ilast];
                    if (mode.puissance > 1m)
                    {
                        if (coeffp < 1e-15m)
                            coeffp = 1e-15m / (decimal)i;
                        else if (coeffp < 1e-12m)
                        {
                            coeffp = 1e-12m / ((decimal)i * i);
                            if (coeffp < 1e-15m)
                                coeffp = 1e-15m / (decimal)i;
                        }
                        else
                            coeffp /= mode.puissance;

                        if (coeffp < 1e-15m)
                            coeffp = 1e-15m / (decimal)i;
                        else if (coeffp < 1e-12m)
                        {
                            coeffp = 1e-12m / ((decimal)i * i);
                            if (coeffp < 1e-15m)
                                coeffp = 1e-15m / (decimal)i;
                        }

                        if (coeffp < 0)
                            coeffp = 0;
                    }
                }

                var aux = getMedianne_(_list, mode.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = last;
                }


                var coeff0 = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (mode.quasi > 1)
                    coeff0 = Math.Pow(coeff0, mode.quasi);

                decimal coeff = coeff0;
                if (coeff < coeffp)
                {
                }
                else
                {
                    coeff = coeffp;
                }





                if (coeff == 0m)
                    break;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = median;
                    ret.indexBorderEffect = last;
                }

                ret.indexBorderMin = last;
                var p = last;

                if (p.VirtualClassement > mode.zero && (!confc.oldAsZero || p.LastClassementRecent))
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--;

                    if (!p.Enabled || !mode.removeEnabled || mode.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((mode.removeLast == removeLast.non || mode.removeLast == removeLast.unselected) && nbEnabled < 0)
                            break;

                        if (mode.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break;
                        }
                        _nbSupp++;
                    }
                }


            }


            return ret;
        }

        //private static DecimalIndex calcmedianneVirt(IList<PieceExtended> list, ConfMedianne conf, ConfMedianneVirt confc, bool main, int nbAdd, int nbDel)
        //{
        //    var _list = new List<PieceExtended>(list);
        //    var classes = _list.FindAll(p => p.VirtualClassement > conf.zero);

        //    if (confc.oldAsZero)
        //        classes = _list.FindAll(p => p.LastClassementRecent);

        //    int count = _list.Count;

        //    int nbEnabled = classes.Count<PieceExtended>(p => p.Enabled);
        //    int nbDisabled = classes.Count<PieceExtended>(p => !p.Enabled);
        //    int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    //int _nbSuppDisabled = 0;
        //    //int _nbSuppEnabled = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {
        //            //var d = _list[count - i];
        //            //if (d.Enabled)
        //            //    nbEnabled--;
        //            //else
        //            //    nbDisabled--;

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        ret.indexBorderMin = count - i - 1;
        //        var p = _list[count - i - 1];

        //        if (p.VirtualClassement > conf.zero && (!confc.oldAsZero || p.LastClassementRecent))
        //        {
        //            // je regarde si le morceau est désactivé
        //            // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
        //            if (p.Enabled)
        //                nbEnabled--;
        //            else
        //                nbDisabled--;
        //            nbdispo--;

        //            if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
        //            {
        //                //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
        //                //if (priseEncompte)
        //                //{
        //                if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected) && nbEnabled < 0)
        //                    break;

        //                if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
        //                {
        //                    if (nbdispo < 0)
        //                        break;
        //                }

        //                _nbSupp++;
        //                if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                    break;
        //                // }


        //            }
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}



        //private static decimal getMedianne_(IList<PieceExtended> list, bool main, decimal coeffMedianne)
        //{
        //    var l = new List<decimal>();
        //    foreach (PieceExtended p in list)
        //    {
        //        if (main)
        //            l.Add(p.VirtualClassement); 
        //        else
        //            l.Add(p.VirtualClassement2); 
        //    }

        //    return CalcMedianne.getMedianneDec(l, coeffMedianne); 
        //}

        private static decimal getMedianne_(IList<Piece> list, bool main, decimal coeffMedianne)
        {
            var l = new List<decimal>();
            foreach (Piece p in list)
            {
                if (main)
                    l.Add(p.VirtualClassement);
                else
                    l.Add(p.VirtualClassement2);
            }

            return CalcMedianne.getMedianneDec(l, coeffMedianne);
        }


        private static decimal getMedianne_(IList<PieceExtended> list, decimal coeffMedianne)
        {

            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1 || coeffMedianne == 1)
            {
                median = list[0];
                return median.Value;
            }

            if (coeffMedianne == 1)
            {
                median = list[count - 1];
                return median.Value;
            }

            var medianne = coeffMedianne * (count - 1);

            var index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].Value;
            var val1 = list[i1].Value;
            median = list[index];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
            {
                return val0;
            }
            median = list[i1];
            return val1;

            //if (Math.Abs(medianne - i1) < PRECISION)
            //{
            //    median = list[i1];
            //    return val1;
            //}
            //if (val1 < PRECISION)
            //{
            //    median = list[i1];
            //    return val1;
            //}
            //var dx = medianne - index;


            //// var ret = val0 + pente * dx;


            //// moyenne avec calcul de log
            //var log0 = Math.Log(val0 + EPSILON_LOG);
            //var log1 = Math.Log(val1 + EPSILON_LOG);
            //// pente = log1 - log0;
            //var log = log0 + (log1 - log0) * dx;
            //return Math.Exp(log) - EPSILON_LOG;


        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\auto\ConfMedianneVirt.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using Math = pdb.util.Math;
using StringBuilder = pdb.util.StringBuilder;

namespace pdb.gen.auto
{
    public partial class ConfMedianneVirt : TuningBase
    {
        [NonSerialized]
        const string PATH_DYN = "..\\dynamic";
        private string Path { get { return string.Format("{0}{1}", DIR_CONF, fdata); } }
        private string PathC { get { return string.Format("{0}{1}", DIR_CONF, fdatac); } }
        private string PathDiff { get { return string.Format("{0}{1}", DIR_CONF, fdiff); } }
        private string PathDiffTmp { get { return string.Format("{0}{1}", DIR_CONF, fdiffTmp); } }
        // private string PathLastFull { get { return string.Format("{0}{1}", DIR_CONF, flast); } }
        const string PATH_DYN_DIFF = "..\\dynamic_diff";


        const int NB_HISTO = 1000000;
        public int safe;
        public decimal coeffVirt = 1m;
        public double virtDelay = 1.0;



        public string name;


        /// <summary>
        /// lié au mode db
        /// </summary>
        public dbMode mode;
        /// <summary>
        /// fichier ou est consigné l'historique courant
        /// </summary>
        public string fdata;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique
        /// </summary>
        public string fdiff;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique en mode full en vue de la sauvegarfe
        /// </summary>
        public string fdiffTmp;
        ///// <summary>
        ///// fichier ou est consigné la dernière sauvegarde full de l'historique
        ///// </summary>
        //public string flast;
        /// <summary>
        /// Fichier historique compressé
        /// </summary>
        public string fdatac;

        public int indexDiff = 0;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        /// <summary>
        /// calcul du coeff en fonction du nombre de pistes
        /// </summary>
        public bool coeffVirtAuto;
        /// <summary>
        ///  calcul du coeff en fonction du nombre de pistes dans tous les cas
        /// </summary>
        public bool coeffVirtAutoAll;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool noVirtZero; 
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;

        public int serialp = 1;
        public int serialm = 1;
        public int serialAlt = 1;
        public decimal serialElastique = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique1dm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique1dp = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique2dm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique2dp = 1m;






        /// <summary>
        /// Coeff appliqué à _nbElastique quand  pas chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique1sm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand pas chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique1sp = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand pas chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique2sm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand pas chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique2sp = 1m;


        //public decimal coeffElastique1 = 1m;
        //public decimal coeffElastique2 = 1m;

        //public decimal coeffElastique1r = 1m;
        //public decimal coeffElastique2r = 1m;

        /// <summary>
        /// pas de calcul
        /// </summary>
        public decimal pas = 0.1m;
        /// <summary>
        /// vitesse : augmentation ou diminution du coeff virtuel
        /// </summary>
        public decimal v;

        /// <summary>
        /// variation de la vitesse en proportion
        /// </summary>
        public decimal vv = 1.1m;

        ///// <summary>
        ///// Vitesse virtuelle : pour calculer l'accélaration en tenant compte des contraintes en simulant un augmentation. Mauvaise idée. toujours egal à v en cas de contrainte
        ///// </summary>
        //private decimal vv;
        /// <summary>
        /// borne visant à limiter le delta entre deux pas
        /// </summary>
        public decimal d0 = 0.01m;
        //  public decimal dcoeffm;


        /// <summary>
        /// accélération : augmentation ou diminution de la vitesse
        /// </summary>
        public decimal a;
        //public decimal a0 =0.01m;
        //public decimal dconvergence01;
        /// <summary>
        /// variation de l'accélération en proportion
        /// </summary>
        public decimal aa = 0.01m;
        /// <summary>
        ///accélaration plancher
        /// </summary>
        public decimal aepsilon = 0.001m;

        /// <summary>
        /// ecart min entre deux positions
        /// </summary>
        private decimal epsilon = 0.001m * 0.001m;
        /// <summary>
        /// ecart de vitesse entre deux positions
        /// </summary>
        private decimal vepsilon = 0.001m * 0.001m;

        private bool? lastDelta;
        private bool? lastAutoDirection;
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        private decimal _nbSameDirection;
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        private int _nbSameDirectionBox;
        /// <summary>
        /// nb allez/retour pour calcul
        /// </summary>
        private int _nbAlt;
        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique;

        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique2;
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        private int _nbAltHisto;

        /// <summary>
        /// Quand plusieurs montées consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticp = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticm = 1;

        /// <summary>
        /// Après plusieurs montées consécutives : retour au coeff nominal 
        /// </summary>
        private decimal coeffStaticpRetour = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : retour au coeff nominal 
        /// </summary>
        private decimal coeffStaticmRetour = 1;
        public decimal CoeffStaticmRetour { get { return coeffStaticmRetour; } }

        /// <summary>
        /// Retour mode large
        /// </summary>
        private bool coeffStaticRetourLarge;

        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des montées consécutives
        /// </summary>
        private decimal currentStaticp = 1;
        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des descentes consécutives
        /// </summary>
        private decimal currentStaticm = 1;
        public decimal CurrentStaticm { get { return currentStaticm; } }

        /// <summary>
        /// On gere spécifiquement le cas des descentes consécutives
        /// </summary>
        public bool checkFall;

        /// <summary>
        /// Rapport de vitesse négative / vitesse positive
        /// </summary>
        private decimal rapportmp = 1m;
        /// <summary>
        /// anti atténuation
        /// </summary>
        //public decimal danticonvergence = 1m;
        //public decimal danticonvergence0;
        //public decimal danticonvergence01;

        //public decimal danticonvdeltap = 1m;
        //public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        private List<HistoValue> histo = new List<HistoValue>();
        //  private List<decimal> histoDiff = new List<decimal>();

        private decimal coeffOld = 1m;

        public bool oldAsZero;
        private bool coeffOldAuto;
        public bool coeffOldSwap;
        public int coeffOldAutoLevel;
        private bool use;
        /// <summary>
        /// On mesure l'écart gagné. lot est le nombre min de rang pour prise en compte totale de la baisse
        /// </summary>
        private double lot=1.0;
        /// <summary>
        /// coeff lot
        /// </summary>
        private decimal coeffLot = 1M;

        /// <summary>
        /// en mode non-exclusif on utilise le complément du coeffLot
        /// </summary>
        private bool alwaysUseCoeffLot; 

        public bool Use { get { return use; } }

        public ConfMedianneVirt()
        { }

        public ConfMedianneVirt(ConfMedianneVirt o, bool raz)
            : this(o)
        {
            if (raz)
            {
                // safe = 0;
                coeffOld = 1;
                coeffVirt = 1;
            }
        }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            name = o.name;
            mode = o.mode;
            fdata = o.fdata;
            fdatac = o.fdatac;
            fdiff = o.fdiff;
            fdiffTmp = o.fdiffTmp;
            //  flast = o.flast;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAutoAll = o.coeffVirtAutoAll;

            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            noVirtZero = o.noVirtZero; 
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            //dcoeffp = o.dcoeffp;
            //dcoeffm = o.dcoeffm;
            //dconvergence = o.dconvergence;
            //dconvdeltap = o.dconvdeltap;
            //dconvdeltam = o.dconvdeltam;
            //danticonvergence = o.danticonvergence;
            //danticonvdeltap = o.danticonvdeltap;
            //danticonvdeltam = o.danticonvdeltam;

            pas = o.pas;
            v = o.v;
            d0 = o.d0;
            a = o.a;
            aa = o.aa;
            aepsilon = o.aepsilon;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            serialAlt = o.serialAlt;

            serialElastique = o.serialElastique;
            coeffElastique1dm = o.coeffElastique1dm;
            coeffElastique1dp = o.coeffElastique1dp;
            coeffElastique1sm = o.coeffElastique1sm;
            coeffElastique1sp = o.coeffElastique1sp;
            coeffElastique2dm = o.coeffElastique2dm;
            coeffElastique2dp = o.coeffElastique2dp;
            coeffElastique2sm = o.coeffElastique2sm;
            coeffElastique2sp = o.coeffElastique2sp;


            _nbSameDirection = o._nbSameDirection;
            _nbSameDirectionBox = o._nbSameDirectionBox;
            _nbAlt = o._nbAlt;
            _nbAltHisto = o._nbAltHisto;
            _nbElastique = o._nbElastique;
            _nbElastique2 = o._nbElastique2;

            coeffOld = o.coeffOld;
            coeffOldAuto = o.coeffOldAuto;
            coeffOldSwap = o.coeffOldSwap;
            oldAsZero = o.oldAsZero;
            coeffOldAutoLevel = o.coeffOldAutoLevel;
            epsilon = o.epsilon;

            //dconvergence0 = o.dconvergence0;
            //dconvergence01 = o.dconvergence01;
            //danticonvergence0 = o.danticonvergence0;
            //danticonvergence01 = o.danticonvergence01;

            lastDelta = o.lastDelta;
            use = o.use;
            coeffStaticRetourLarge = o.coeffStaticRetourLarge;
            alwaysUseCoeffLot = o.alwaysUseCoeffLot; 
            this.checkFall = o.checkFall;
            this.virtDelay = o.virtDelay;
            this.lot = o.lot;
            this.coeffLot = o.coeffLot; 
            histo = new List<HistoValue>(o.histo);

        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var str = "";
            builds("mode", v => str = v);
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);
            builds("name", v => name = v);
            builds("fdata", v => fdata = v);
            builds("fdatac", v => fdatac = v);
            builds("fdiff", v => fdiff = v);
            builds("fdiffTmp", v => fdiffTmp = v);
            // builds("flast", v => flast = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAutoAll", v => coeffVirtAutoAll = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("noVirtZero", v => noVirtZero = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);

            builddec("pas", v => pas = v);
            builddec("v", vv => v = vv);
            builddec("dv", v => dv = v);
            builddec("d0", v => d0 = v);
            builddec("a", v => a = v);
            builddec("aa", v => aa = v);
            builddec("vepsilon", v => vepsilon = v);
            builddec("aepsilon", v => aepsilon = v);


            //builddec("dcoeffp", v => dcoeffp = v);
            //builddec("dcoeffm", v => dcoeffm = v);
            //builddec("dconvergence", v => dconvergence = v);
            //builddec("dconvergence0", v => dconvergence0 = v);
            //builddec("dconvergence01", v => dconvergence01 = v);
            //builddec("dconvdeltap", v => dconvdeltap = v);
            //builddec("dconvdeltam", v => dconvdeltam = v);

            //builddec("danticonvergence", v => danticonvergence = v);
            //builddec("danticonvergence0", v => danticonvergence0 = v);
            //builddec("danticonvergence01", v => danticonvergence01 = v);
            //builddec("danticonvdeltap", v => danticonvdeltap = v);
            //builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serialAlt", v => serialAlt = v);
            buildi("elastique", v => serialElastique = v);


            builddec("coeffElastique1dm", v => coeffElastique1dm = v);
            builddec("coeffElastique1dp", v => coeffElastique1dp = v);
            builddec("coeffElastique1sm", v => coeffElastique1sm = v);
            builddec("coeffElastique1sp", v => coeffElastique1sp = v);
            builddec("coeffElastique2dm", v => coeffElastique2dm = v);
            builddec("coeffElastique2dp", v => coeffElastique2dp = v);

            builddec("coeffElastique2sm", v => coeffElastique2sm = v);
            builddec("coeffElastique2sp", v => coeffElastique2sp = v);


            builddec("serial", v => _nbSameDirection = v);
            buildi("serialBox", v => _nbSameDirectionBox = v);
            buildi("serialAltC", v => _nbAlt = v);
            buildi("serialAltH", v => _nbAltHisto = v);
            builddec("elastiqueC", v => _nbElastique = v);
            builddec("elastiqueC2", v => _nbElastique2 = v);


            builddec("coeffOld", v => coeffOld = v);
            buildb("oldAsZero", v => oldAsZero = v);
            buildb("coeffOldAuto", v => coeffOldAuto = v);
            buildb("coeffOldSwap", v => coeffOldSwap = v);
            buildi("coeffOldAutoLevel", v => coeffOldAutoLevel = v);
            builddec("epsilon", v => epsilon = v);

            buildbn("lastDelta", v => lastDelta = v);

            builddec("coeffStaticp", v => coeffStaticp = v);
            builddec("coeffStaticm", v => coeffStaticm = v);

            builddec("coeffStaticpRetour", v => coeffStaticpRetour = v);
            builddec("coeffStaticmRetour", v => coeffStaticmRetour = v);
            buildb("coeffStaticRetourLarge", v => coeffStaticRetourLarge = v);


            builddec("currentStaticp", v => currentStaticp = v);
            builddec("currentStaticm", v => currentStaticm = v);
            builddec("rapportmp", v => rapportmp = v);

            buildb("use", v => use = v);
            buildb("checkFall", v => checkFall = v);
            buildd("virtDelay", v => virtDelay = v);

            buildd("lot", v => lot = v);
            builddec("coeffLot", v => coeffLot = v);
            buildb("alwaysUseCoeffLot", v => alwaysUseCoeffLot = v); 


            HistoValue last = null;
            var xhisto = XMLTool.NodeLookUp(child, "histo");
            if (xhisto != null)
            {
                foreach (XmlElement sub in xhisto.ChildNodes)
                {
                    var _nevw = new HistoValue(sub.InnerText, last);
                    histo.Add(_nevw);
                    last = _nevw;
                }
            }
            else
            {

                if (File.Exists(Path))
                {
                    var lines = File.ReadAllLines(Path);
                    for (int i = 0; i < lines.GetLength(0); i++)
                    {
                        try
                        {
                            var line = lines[i];

                            if (string.IsNullOrEmpty(line))
                                continue;
                            var _nevw = new HistoValue(line, last);
                            histo.Add(_nevw);
                            last = _nevw;
                        }
                        catch (Exception ex)
                        {
                            misc.log(string.Format("impossible de lire la ligne n° {0}:{1}", i + 1, lines[i]), ex);
                            throw;
                        }
                    }
                    indexDiff = histo.Count;

                    //if (histo.Count >0 )
                    //    coeffVirt = getCoeff(histo[histo.Count -1]);


                }

                if (File.Exists(PathDiff))
                {
                    var histoDiff = new List<HistoValue>();
                    var lines = File.ReadAllLines(PathDiff);
                    for (int i = 0; i < lines.GetLength(0); i++)
                    {
                        try
                        {
                            var line = lines[i];
                            if (string.IsNullOrEmpty(line))
                                continue;

                            var _nevw = new HistoValue(line, last);
                            histoDiff.Add(_nevw);
                            last = _nevw;
                        }
                        catch (Exception ex)
                        {
                            misc.log(string.Format("impossible de lire la ligne n° {0}:{1}", i + 1, lines[i]), ex);
                            throw;
                        }

                    }

                    if (mode == dbMode.full)
                    {
                        histo.AddRange(histoDiff);
                        indexDiff = histo.Count;
                    }
                    else
                    {
                        indexDiff = histo.Count - histoDiff.Count;
                    }

                }



                if (mode == dbMode.full)
                {
                    PathDiff.Sov("0");                    
                }
                   

                if (histo.Count > 0)
                {
                    int index = histo.Count - 1;
                    decimal current = histo[index].coeff;
                    //coeffVirt = getCoeff(current);
                    bool? sens = null;

                    int nbSerie = 0;
                    // decimal delta = 0m;

                    var rr = 1;
                    //if (dcoeffp > 0)
                    //    rr = dcoeffm / dcoeffp;
                    if (rr > 0)
                    {
                        while (true)
                        {
                            index--;
                            if (index < 0)
                                break;
                            var aux = histo[index].coeff;
                            var _sens = current > aux;
                            if (sens == null)
                            {
                                sens = _sens;
                                lastAutoDirection = !_sens;

                                // delta = current - aux;
                            }


                            if (sens != _sens)
                                break;
                            current = aux;
                            nbSerie++;

                        }

                        //_nbSameDirection = nbSerie;
                        //dcoeffp = Math.Abs(delta); dcoeffm = dcoeffp * rr;

                    }
                }
            }

            checkCoeffOld();
            //if (histoDiff.Count > 0)
            //    coeffVirt = getCoeff(histo[histo.Count - 1]); 

        }



        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("name", name);
            write("mode", mode);
            write("use", use);
            write("serial", _nbSameDirection);
            write("elastiqueC", _nbElastique);
            write("elastiqueC2", _nbElastique2);

            write("coeffVirt", coeffVirt);
            write("coeffOld", coeffOld);
            write("serialBox", _nbSameDirectionBox);
            write("serialAltC", _nbAlt);
            write("serialAltH", _nbAltHisto);

            write("coeffStaticp", coeffStaticp);
            write("coeffStaticm", coeffStaticm);
            write("coeffStaticpRetour", coeffStaticpRetour);
            write("coeffStaticmRetour", coeffStaticmRetour);
            write("coeffStaticRetourLarge", coeffStaticRetourLarge);
            write("currentStaticp", currentStaticp);
            write("currentStaticm", currentStaticm);

            write("lastDelta", lastDelta);

            write("serialAlt", serialAlt);
            write("elastique", serialElastique);

            write("fdata", fdata);
            write("fdatac", fdatac);
            write("fdiff", fdiff);
            write("fdiffTmp", fdiffTmp);


            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAutoAll", coeffVirtAutoAll);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("noVirtZero", noVirtZero);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);

            write("pas", pas);
            write("v", v);
            write("dv", dv);
            write("d0", d0);
            write("a", a);
            write("aa", aa);
            write("aepsilon", aepsilon);
            write("vepsilon", vepsilon);
            write("rapportmp", rapportmp);

            //write("dcoeffp", dcoeffp);
            //write("dcoeffm", dcoeffm);
            //write("dconvergence", dconvergence);
            //write("dconvergence0", dconvergence0);
            //write("dconvergence01", dconvergence01);
            //write("dconvdeltap", dconvdeltap);
            //write("dconvdeltam", dconvdeltam);

            //write("danticonvergence", danticonvergence);
            //write("danticonvergence0", danticonvergence0);
            //write("danticonvergence01", danticonvergence01);
            //write("danticonvdeltap", danticonvdeltap);
            //write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);

            write("checkFall", checkFall);





            write("oldAsZero", oldAsZero);
            write("coeffOldAuto", coeffOldAuto);
            write("coeffOldSwap", coeffOldSwap);

            write("coeffOldAutoLevel", coeffOldAutoLevel);
            write("epsilon", epsilon);

            write("coeffElastique1dm", coeffElastique1dm);
            write("coeffElastique1dp", coeffElastique1dp);
            write("coeffElastique1sm", coeffElastique1sm);
            write("coeffElastique1sp", coeffElastique1sp);


            write("coeffElastique2dm", coeffElastique2dm);
            write("coeffElastique2dp", coeffElastique2dp);
            write("coeffElastique2sm", coeffElastique2sm);
            write("coeffElastique2sp", coeffElastique2sp);

            write("virtDelay", virtDelay);
            write("lot", lot);
            write("coeffLot", coeffLot);
            write("alwaysUseCoeffLot", alwaysUseCoeffLot); 


            var sb = new StringBuilder();
            var sbDiff = new StringBuilder();
            var sbc = new StringBuilder();




            //if (modeDiff)
            //{
            //    histoDiff = null;
            //}
            //else
            //{
            //    if (histoDiff != null)
            //    {
            //        histo.AddRange(histoDiff);
            //        histoDiff = null;
            //    }

            //    if (File.Exists(PathDiff))
            //        File.Delete(PathDiff);
            //}

            int count = histo.Count;
            HistoValue last = null;
            for (int i = 0; i < count; i++)
            {
                histo[i].write(sb);
                histo[i].writeDiff(sbc, last);

                if (i >= indexDiff)
                    histo[i].writeDiff(sbDiff, last);

                last = histo[i];
            }


            if (!string.IsNullOrEmpty(fdata))
            {
                AsyncFileWriter.Instance.post(Path, sb.ToString());
                if (mode == dbMode.diff)
                    AsyncFileWriter.Instance.post(PathDiff, sbDiff.ToString());
                else
                    AsyncFileWriter.Instance.post(PathDiffTmp, sbDiff.ToString());


                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);
            }

            if (!string.IsNullOrEmpty(fdatac))
            {
                AsyncFileWriter.Instance.post(PathC, sbc.ToString());
            }


            writeEnd();
        }
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        public decimal Serial { get { return _nbSameDirection; } set { _nbSameDirection = value; } }
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        public int SerialBox { get { return _nbSameDirectionBox; } }
        /// <summary>
        /// nb allez-retours pour calcul
        /// </summary>
        public int Alt { get { return _nbAlt; } }
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        public int AltHisto { get { return _nbAltHisto; } }
        /// <summary>
        /// Position de l'élastique. Positif : tend à agrandir le delta. du à plusieurs séries dans le même sens. Négatif : tend à diminuer le delta. du à plusieurs allez-retours consécutifs
        /// </summary>
        public decimal Elastique { get { return _nbElastique; } }
        public decimal Elastique2 { get { return _nbElastique2; } }
        public decimal dv = 0;
        public decimal dx = 0m;
        public decimal dcoeff = 1;
        //  public decimal da;
        public decimal AccelerationRapport { get { return dv / epsilon; } }
        public decimal VitesseRapport { get { return dx / epsilon; } }
        public decimal danticonvergenceMin
        {
            get
            {
                return epsilon;
            }
        }




        public decimal CoeffOld
        {
            get { return coeffOld; }
            set { coeffOld = value; checkCoeffOld(); }
        }

        public bool CoeffOldAuto
        {
            get { return coeffOldAuto; }
            set { coeffOldAuto = value; checkCoeffOld(); }
        }

        //private decimal getCoeff(decimal coeffT) { return Math.Pow(coeffT, (1.0m / safe)); }


    }
}
]]></content>
  </file>
</db>
