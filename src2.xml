<db path="C:\bernard\db1\db4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.obj;
using pdb.gen.albums;
using System.Linq;
using System.Linq.Expressions;
using System.Windows.Input;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static Logger logPerf = Logger.getLogger("Perf");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public static DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Normal;

        public static void setDispatcherPriority()
        {
            var str = CConf.DispatcherPriority;
            if (!string.IsNullOrEmpty(str))
            {
                DISPATCHER_PRIORITY = (DispatcherPriority)Enum.Parse(typeof(DispatcherPriority), str);
            }
        }

        private class UIItem
        {
            public readonly Action action;
            public readonly IClient client;
            public UIItem(Action action, IClient client)
            {
                this.action = action;
                this.client = client;
            }
        }

        private pdb.util.Queue<UIItem> uiItems = new util.Queue<UIItem>();
        // private DispatcherTimer uiTimer;


        static ILogger logDispatch;
        public static void Dispatch(Action action, IClient client)
        {
            Instance.dispatch(action, client);
        }
        public void dispatch(Action action, IClient client)
        {
            if (!client.HasLog)
                client.Log = logDispatch;
            //if (uiTimer == null)
            //{

            //    lock (_lock)
            //    {
            //        if (uiTimer == null)
            //        {
            //            uiTimer = new DispatcherTimer();

            //        }
            //    }
            //}

            if (!CheckAccess())
            {
                client.log("async");
                client.isAsync = true;
                Dispatcher.BeginInvoke(action, DISPATCHER_PRIORITY);
            }
            else
            {
                Dispatcher.BeginInvoke(action, DISPATCHER_PRIORITY);
                //action();
            }
        }

        //public void dispatchLessPrior(Action action, IClient client)
        //{
        //    Dispatcher.BeginInvoke(action, DispatcherPriority.ApplicationIdle);
        //}



        private void syncAction(Action action, IClient client)
        {
            client.log("debut Effectif");
            action();
            client.log("fin");
        }

        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            var xmlConf = CConf.loadConf();
            setDispatcherPriority();
            pdb.player.ViewModel.Colors.MementoColor.recover();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private string lastMessage;
        private void CheckException(string from, object sender, object ex)
        {
            if (ex is Exception)
            {
                var mess = (ex as Exception).Message;
                if (mess == lastMessage)
                {
                    displayMsg = true;
                }
                lastMessage = mess;

            }
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        private static bool changing;
        public static void setChanging() { changing = true; }
        public static void releaseChanging() { changing = false; }
        public static void invalidateAlbums()
        {
            if (gen == null)
                return;

            gen.invalidateAlbums();
            if (changing)
                return;
            go();
        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                var xmlConf = CConf.loadConf();
                setDispatcherPriority();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                logDispatch = Logger.getLogger("Dispatch");
                misc.init(log);



                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");



                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                gen.FilterNext = CConf.ConfGen.FilterNext;
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0);
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                //  Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }

        private static void resetOneCl()
        {
            lock (_lock)
            {
                try
                {
                    var conf = CConf.ZeroWorkConf;
                    if (conf.enabled)
                    {

                        // CPieceClassement.DateMin = DateTime.MinValue;
                        //   Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                        var oldKepp = new List<Piece>();

                        var _albums = gen.Albums;
                        foreach (var album in _albums.List)
                        {
                            if (album.Name=="Early Magic")
                            { }
                            var l = album.Tracks;
                            foreach (Piece t in l)
                            {
                                if (t.Keep)
                                {
                                    t.setKeep(0); //t.Keep = false;
                                    oldKepp.Add(t);
                                    //t.resetMedianneCompact();
                                    //t.invalidateCache(true); 
                                }
                            }
                        }
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            Classement pluspetitNonNull = null;
                            Piece min = null;
                            Piece firstZero = null;
                            int nbnotes = 0;
                            int nbRecent = 0;
                            if (album.Name == "Maxime Le Forestier")
                            {

                            }

                             if (album.Name=="Early Magic")
                            { }
                            //foreach (Piece t in l)
                            //{
                            //    var cl = t.DeepClassement; // p.Classement.DbValue;
                            //    // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                            //    if (cl.isPositive())// > zer0d)
                            //    {
                            //        nbnotes++;
                            //        if (t.LastClassementRecent || !t.Enabled)
                            //        {
                            //            if (!conf.alwaysKeep)
                            //            {
                            //                min = null;
                            //                break;
                            //            }

                            //            nbRecent++;
                            //            continue;
                            //        }
                            //        if (pluspetitNonNull == null || cl < pluspetitNonNull)
                            //        {
                            //            pluspetitNonNull = cl;
                            //            min = t;
                            //        }
                            //    }
                            //    else
                            //    {
                            //        if (conf.keep2Enabled)
                            //        {
                            //            if (t.Enabled && !t.LastClassementRecent)
                            //            {
                            //                if (firstZero == null)
                            //                {
                            //                    if (min == null || conf.alwaysKeep2)
                            //                    {
                            //                        firstZero = t;
                            //                    }
                            //                }
                            //            }
                            //        }
                            //    }
                            //}


                            foreach (Piece t in l)
                            {
                                var cl = t.DeepClassement; // p.Classement.DbValue;
                                                           // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);

                                bool isNote = cl.isPositive();
                                bool isRecent = t.LastClassementRecent || !t.Enabled;
                                if (isRecent)
                                    nbRecent++;
                                if (isNote)
                                    nbnotes++;
                                if (isNote)
                                {
                                    if (isRecent)
                                    {
                                        if (!conf.alwaysKeep)
                                        {
                                            min = null;
                                            break;
                                        }
                                        continue;
                                    }
                                    if (pluspetitNonNull == null || cl < pluspetitNonNull)
                                    {
                                        pluspetitNonNull = cl;
                                        min = t;
                                    }
                                }
                                else
                                {
                                    if (conf.keep2Enabled)
                                    {
                                        if (!isRecent)
                                        {
                                            if (firstZero == null)
                                            {
                                                if (min == null || conf.alwaysKeep2)
                                                {
                                                    firstZero = t;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            decimal coeff1 = -1;
                            decimal coeff2 = -1;

                            if (min != null)
                            {
                                if (coeff1 < 0)
                                    coeff1 = ((decimal)nbRecent + 1) / (l.Count + 1);
                                if (coeff2 < 0)
                                    coeff2 = (decimal)nbnotes / l.Count;
                                var coeff = coeff1 * coeff2;
                                min.setKeep(coeff);
                            }
                            if (firstZero != null)
                            {
                                if (nbnotes == 0)
                                    nbnotes++;
                                try
                                {
                                    if (coeff2 < 0)
                                        coeff2 = (decimal)nbnotes / l.Count;

                                    firstZero.setKeep(-coeff2);
                                }
                                catch (Exception ex)
                                {
                                    misc.log(ex);
                                }
                            }



                        }

                        foreach (Piece t in oldKepp)
                        {

                            if (!t.Keep)
                            {
                                t.resetMedianneCompact();
                                t.invalidateCache(true);
                            }
                        }


                    }
                }
                finally
                {
                    //  CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                }
            }
        }



        private static void goInit()
        {
            var client = new SimpleClient("goInit\t", logPerf);
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;



            gen.ConsolidInit(Db.List.getList());
            client.log(" gen.ConsolidInit(Db.List.getList());");
            if (CConf.ZeroWorkConf.enabled)
            {

                resetOneCl();
                client.log("resetOneCl");
                //CPieceClassement.DateMin = DateTime.MinValue;
                ////Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                //Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                ////foreach (Piece p in gen.sortByClass())
                ////{
                ////    decimal clValue = p.ClassementValueDecimal(false) ;
                ////    if (clValue > zer0d)
                ////    {
                ////        if (clValue >= zer0d)
                ////        {
                ////            var dPiece = Db.getPiece(p.PieceId);
                ////            var strNewCl = "0000" + dPiece.getClassement().ToString();
                ////            var newCl = Classement.create(strNewCl);
                ////            p.Enabled = true;

                ////            p.setClassement(newCl.ClassList, newCl.Rating);
                ////            dPiece.Classement.eraseClassement2(newCl);
                ////        }
                ////        else
                ////            p.Enabled = false;
                ////    }
                ////}

                //var _albums = gen.Albums;
                //foreach (var album in _albums.List)
                //{
                //    var l = album.Tracks;
                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in l)
                //    {
                //        decimal clValue = t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        (min.Track as CPiece).Classement.keepValue();
                //    }
                //}
                ////    foreach (Piece t in l)
                ////    {
                ////        if (t.Parent == null)
                ////        {
                ////            decimal clValue = t.ClassementValueDecimal(false);
                ////            if (t.isClassListNumeric && clValue > zer0d)
                ////            {
                ////                if (clValue > pluspetitNonNull)
                ////                {
                ////                    var dPiece = Db.getPiece(t.PieceId);
                ////                    t.Enabled = true;
                ////                    t.setClassement("0", 0);
                ////                    dPiece.Classement.eraseClassement2();
                ////                }
                ////            }
                ////        }
                ////    }
                ////}

                ////gen.MakeConsolid(Db.List.getList(), true);
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
            }

            gen.MakeConsolid(null, true, true, client);
            //  if (CConf.ConfGen.LimitList <= 0)
            gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            client.log("creation bib");
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, client, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
            client.log("Fin goInit");
        }

        private static bool mustBuildCompleteAlbums(TrackListViewModel currentTrack)
        {
            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.RankAlbumReverse.CompareTo(y.RankAlbumReverse));
            int count = tracks.Count;
            int rank0 = currentTrack.RankAlbumReverse;

            int i = 0;
            // recherche trou avant ex rank0=3 pas de 1 ni de 2
            for (; i < count; i++)
            {
                var t = tracks[i];
                if (t.RankAlbumReverse >= rank0)
                    break;

                if (t.RankAlbumReverse > i + 1)
                    return true;
            }

            //if (i + 1 < count && tracks[i + 1].RankAlbumReverse > rank0 + 1)
            //{
            //    return true;
            //}

            return false;
        }

        private static void buildAffectedAlbumsWhenCurrentTrackChange(TrackListViewModel currentTrack, IDictionary<string, Album> dict, HashSet<Album> depot, bool navQuick)
        {
            if (currentTrack == null)
                return;
            TrackListViewModel item = currentTrack;
            var cl = item.PieceGen.getClassement(true);
            var _dict = dict;  // new Dictionary<string,Album>(); 

            //foreach (Album album in dict.Values)
            //{
            //    var current = album.PlusPetitEnabled; 
            //    if (current == null || cl<=current.getClassement(true))
            //        _dict.Add(album.Key, album); 
            //}

            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
            int count = tracks.Count;

            //int index = -1;
            //for (int i = 0; i < count; i++)
            //{
            //    var t = tracks[i];
            //    if (t.PieceId == currentTrack.PieceId)
            //    {
            //        index = i;
            //        break;
            //    }
            //}

            //if (index < 0)
            //{
            //    foreach (Album a in dict.Values)
            //        depot.Add(a);
            //    return;
            //}

            var hs = new HashSet<int>();
            if (navQuick)
                hs.Add(item.MasterId);
            int index = -1;
            try
            {
                while (true)
                {
                    index++;
                    if (index >= count)
                        return;

                    var t = tracks[index];
                    if (!hs.Add(t.MasterId))
                        continue;
                    if (navQuick && t.album == item.album)
                        continue;
                    //if (t.album == item.album)
                    //    continue;

                    if (_dict.ContainsKey(t.album.Key))
                    {
                        depot.Add(t.album);
                        if (depot.Count >= _dict.Count)
                            return;
                    }
                    else
                        break;

                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
            finally
            {

            }
        }

        private void automateNextTrack()
        {
            var client = new SimpleClient("automateNextTrack\t");
            this.dispatch(
                () =>
                {
                    PlayerViewModel.Instance.goToFirst();
                    App.go();
                }, client);
            //if (!CheckAccess())
            //    Dispatcher.BeginInvoke(new Action(this.automateNextTrack), App.DISPATCHER_PRIORITY);
            //else
            //{
            //    PlayerViewModel.Instance.forwardAuto();
            //    App.go();
            //}
        }

        static int nbGo = 0;
        static bool classementChange;
        private static SimpleClient client;
        public static bool Indispo { get; set; }
        private static void _go()
        {
            gen.Albums.endParallelSort();
            bool classementChange = App.classementChange;
            var _currentTrack = App._currentTrack;
            nbGo++;
            bool urgence = false;
            if (client != null)
            {
                client.log("FIN new step");
                client.cancel();
            }

            client = new SimpleClient("<--- chrono " + nbGo + "\t", logPerf);
            var clientArgs = new ClientEventArgs(client);

            try
            {

                bool reInit = !gen.AlbumBuild;
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                //   gen.compact(); 
                if (detailClassementViewModel != null)
                    detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;

                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;

                urgence = gen.Urgence && TrackListViewModel.CurrentPlaying == _currentTrack;
                if (!urgence)
                {
                    Db.saveAsync();
                    Memento.Instance.save();
                }
                client.log(string.Format("debut classementChange={0} gen.ClassementChanged={1} gen.Urgence={2} _currentTrack={3}", classementChange, gen.ClassementChanged, gen.Urgence, _currentTrack));
                if (PlayerViewModel.Instance.CreateRot)
                {
                    if (urgence)
                        PlayerViewModel.Instance.modeFirst();
                    if (gen.ClassementChanged)
                    {
                        classementChange = true;
                        App.classementChange = true;
                    }

                    if (!urgence && classementChange)
                    {
                        resetOneCl();
                        client.log("resetOneCl");
                        App.classementChange = false;
                    }

                    if (_currentTrack != null)
                    {
                        int nbAlbums = 0;
                        // bool sortDone = false;
                        if (urgence)
                        {
                            var affectedAlbums = gen.Albums.GetAndInvalidateAlbums(_currentTrack.PieceGen);
                            bool mustComplete = mustBuildCompleteAlbums(_currentTrack);

                            if (!mustComplete)
                            {

                                //}

                                var depot = new HashSet<Album>();
                                buildAffectedAlbumsWhenCurrentTrackChange(_currentTrack, affectedAlbums, depot, CConf.ConfGen.NavQuick);
                                if (depot.Count == 0)
                                {
                                    if (_currentTrack == TrackListViewModel.CurrentPlaying)
                                    {
                                        log.log("pas de makeSort. on passe au suivant on verra après");
                                        _currentTrack = null;
                                        gen.Urgence = false;

                                        App.Instance.automateNextTrack();
                                        return;

                                    }
                                    else
                                    {
                                        log.log("trop naze c'est trop long");
                                        gen.Urgence = false;

                                    }


                                }
                                //}
                                //}
                                else
                                {
                                    log.log("depot:");
                                    nbAlbums = gen.Albums.makeSort(depot, log);
                                    //sortDone = true;
                                }

                            }
                            else
                            {
                                log.log("y a des trous dans la raquette on force le makesort");
                                gen.Urgence = false;
                            }
                            //if (!sortDone && gen.Urgence)
                            //{
                            //    log.log("affected albums");
                            //    nbAlbums = gen.Albums.makeSort(_currentTrack.PieceGen, log);
                            //}
                            client.log(string.Format("makeSort partial {0} elt", nbAlbums));
                            _currentTrack.refresh();
                            while (Indispo)
                                Thread.Sleep(100);
                            if (nbAlbums > 0)
                            {
                                if (refreshAlbum != null)
                                    refreshAlbum("", clientArgs);
                                client.log("refreshAlbum");
                            }
                        }
                    }

                    _currentTrack = null;


                    // if (__end || __go) return;


                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 

                    while (Indispo)
                        Thread.Sleep(100);
                    gen.MakeConsolid(null, _updateStats, classementChange, client); //   bib.Musique.Tracks);
                    if (reInit)
                        gen.buildMusiqueAgain();
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                        setDispatcherPriority();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    while (Indispo)
                        Thread.Sleep(100);
                    gen.createRot(CConf.ListBase, client, App.bib);
                    if (reInit)
                        bib.syncMusique();
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();

                    while (Indispo)
                        Thread.Sleep(100);
                    if (refresh != null)
                        refresh(PHASE2, clientArgs);
                    client.log("refresh après createRot");


                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats && !urgence)
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => { if (detailClassementViewModel != null) detailClassementViewModel.IhmInDispo = ihmInDispo.none; });

                        }
                        else
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                        }
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    _currentTrack = null;
#if EXPORT
                    ExportCmd.CalculExport();
#endif
                    if (_updateStats && !urgence)
                    {
                        _updateStats = false;
                    }
                }
                client.log("FIN _go()");
                if (urgence && !DetailClassementViewModel.Instance.Auto)
                    go(false);

                if (classementChange && !urgence)
                    gen.Albums.parallelSort();

                if (!urgence && TrackListViewModel.HumanSelectedIsBusy)
                {
                    if (refreshArtWork != null)
                        refreshArtWork.BeginInvoke("toto", clientArgs, null, null);
                }


            }


        }

        public static event EventHandler<ClientEventArgs> refresh;
        public static event EventHandler<ClientEventArgs> refreshAlbum;
        public static event EventHandler<ClientEventArgs> refreshArtWork;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                return null;
                case MessageBoxResult.No:
                return false;
                case MessageBoxResult.None:
                return null;
                case MessageBoxResult.OK:
                return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\pdb.player.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{4166FA60-B33F-4496-9352-EDD8F3214021}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.player</RootNamespace>
    <AssemblyName>pdb.player</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;NONI</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;COMPACT</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>pdb.player.App</StartupObject>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG;COMPACT</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="policy.2.0.taglib-sharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=db62eba44689b5b0, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\policy.2.0.taglib-sharp.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Runtime.Serialization" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="taglib-sharp, Version=2.1.0.0, Culture=neutral, PublicKeyToken=db62eba44689b5b0, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\taglib-sharp.dll</HintPath>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="Xceed.Wpf.Toolkit">
      <HintPath>libs\Extended WPF Toolkit Binaries\Xceed.Wpf.Toolkit.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="model\ArtWorkManager.cs" />
    <Compile Include="model\Equalization.cs" />
    <Compile Include="ViewModel\AllTracksViewModel.cs" />
    <Compile Include="ViewModel\BibViewModel.cs" />
    <Compile Include="ViewModel\BibViewModelBase.cs" />
    <Compile Include="ViewModel\BibViewModelTree.cs" />
    <Compile Include="ViewModel\Colors\ColorViewModel.cs" />
    <Compile Include="ViewModel\Colors\Couleurs.cs" />
    <Compile Include="ViewModel\Colors\MementoColor.cs" />
    <Compile Include="ViewModel\Commande\CommandeBase.cs" />
    <Compile Include="ViewModel\Commande\CoulHistoryBack.cs" />
    <Compile Include="ViewModel\Commande\CreateListCmd.cs" />
    <Compile Include="ViewModel\Commande\DeleteCmd.cs" />
    <Compile Include="ViewModel\Commande\Explorer.cs" />
    <Compile Include="ViewModel\Commande\ImportCmd.cs" />
    <Compile Include="ViewModel\Commande\InfoCmd.cs" />
    <Compile Include="ViewModel\Commande\Link\LinkRegister.cs" />
    <Compile Include="ViewModel\Commande\Link\RecordFather.cs" />
    <Compile Include="ViewModel\Commande\Play.cs" />
    <Compile Include="ViewModel\Commande\PlayList\AddToList.cs" />
    <Compile Include="ViewModel\Commande\PlayList\CheckCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastClassement.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastRead.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCompress.cs" />
    <Compile Include="ViewModel\Commande\PlayList\PlayListCommande.cs" />
    <Compile Include="ViewModel\Commande\RecordClassement.cs" />
    <Compile Include="ViewModel\Commande\RefreshAlbum.cs" />
    <Compile Include="ViewModel\DetailAlbumViewModel.cs" />
    <Compile Include="ViewModel\DetailClassementViewModel.cs" />
    <Compile Include="ViewModel\ClientEventArgs.cs" />
    <Compile Include="ViewModel\gen\ListWriter.cs" />
    <Compile Include="ViewModel\InfoViewModel.cs" />
    <Compile Include="ViewModel\Interfaces.cs" />
    <Compile Include="ViewModel\PlayerViewModel.cs" />
    <Compile Include="ViewModel\PochetteViewModel.cs" />
    <Compile Include="ViewModel\StatItemViewModel.cs" />
    <Compile Include="ViewModel\TrackListViewModel.cs" />
    <Compile Include="ViewModel\PlayListViewModel.cs" />
    <Compile Include="ViewModel\ViewModelBase.cs" />
    <Compile Include="Vue\Adorn\AdornedControl.cs" />
    <Compile Include="Vue\Adorn\AdornerPlacement.cs" />
    <Compile Include="Vue\Adorn\FrameworkElementAdorner.cs" />
    <Compile Include="Vue\AlbumCtl.xaml.cs">
      <DependentUpon>AlbumCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BarAdorner.cs" />
    <Compile Include="Vue\BibCtl.xaml.cs">
      <DependentUpon>BibCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BrowsePlayList.xaml.cs">
      <DependentUpon>BrowsePlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ClassementCtl.xaml.cs">
      <DependentUpon>ClassementCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfAlbumSortW.xaml.cs">
      <DependentUpon>ConfAlbumSortW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfExport.xaml.cs">
      <DependentUpon>ConfExport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfFilterW.xaml.cs">
      <DependentUpon>ConfFilterW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfImport.xaml.cs">
      <DependentUpon>ConfImport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfMedianneW.xaml.cs">
      <DependentUpon>ConfMedianneW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfVirt.xaml.cs">
      <DependentUpon>ConfVirt.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfCouleurs.xaml.cs">
      <DependentUpon>ConfCouleurs.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\Debug.xaml.cs">
      <DependentUpon>Debug.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\Miscellaneous.xaml.cs">
      <DependentUpon>Miscellaneous.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\DataGridPlayList.xaml.cs">
      <DependentUpon>DataGridPlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\EnhancedDataGrid.cs" />
    <Compile Include="Vue\FolderBrowserDialog.xaml.cs">
      <DependentUpon>FolderBrowserDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialogW.xaml.cs">
      <DependentUpon>FolderBrowserDialogW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\getNb.xaml.cs">
      <DependentUpon>getNb.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Info.xaml.cs">
      <DependentUpon>Info.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Memento.cs" />
    <Compile Include="Vue\PlayerControler.xaml.cs">
      <DependentUpon>PlayerControler.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Pochette.xaml.cs">
      <DependentUpon>Pochette.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StatCtl.xaml.cs">
      <DependentUpon>StatCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StateBar.xaml.cs">
      <DependentUpon>StateBar.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StringDialog.xaml.cs">
      <DependentUpon>StringDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Util\BaseConverter.cs" />
    <Compile Include="Vue\Util\GradiantBuilder.cs" />
    <Compile Include="Vue\Util\StringFormatConverter.cs" />
    <Compile Include="Vue\Util\Utils.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Player.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Player.xaml.cs">
      <DependentUpon>Player.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="Vue\AlbumCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BibCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BrowsePlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ClassementCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfAlbumSortW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfExport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfFilterW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfImport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfMedianneW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfVirt.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfCouleurs.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\Debug.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\Miscellaneous.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\DataGridPlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialogW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\getNb.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Vue\Info.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\PlayerControler.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Pochette.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StatCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StateBar.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StringDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="app.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <AppDesigner Include="Properties\" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\engine\pdb.player.engine.build\pdb.player.engine.build.csproj">
      <Project>{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}</Project>
      <Name>pdb.player.engine.build</Name>
    </ProjectReference>
    <ProjectReference Include="..\engine\pdb.player.engine\pdb.player.engine.csproj">
      <Project>{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}</Project>
      <Name>pdb.player.engine</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823d1d-851c-456b-ac4c-b0beec173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{c2b34ca9-3bb2-464f-8691-5f5b7cb2b997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Consolid\pdb.gen.csproj">
      <Project>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</Project>
      <Name>pdb.gen</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Db\pdb.db.csproj">
      <Project>{43D27B47-E615-451D-AD25-67C5B8447C4A}</Project>
      <Name>pdb.db</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\Toolbar-MP3-Forward-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Pause-icon.png" />
    <Resource Include="Vue\images\Toolbar-MP3-Play-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Rewind-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Stop-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\cbCoche.png" />
    <Resource Include="Vue\images\cbDecoche.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>rem copy $(TargetDir)\*.*  $(TargetDir)\..\..\..\PieceDb3Ref\pdb.player\bin  /Y</PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using pdb.podcast.Tuning;
using pdb.podcast.Albums;


namespace pdb.podcast.DB
{
    public class Db
    {
        public const string CURRENT_VERSION = "2.0";
        const string SEQ_PIECE = "seq";
        const string TOKEN_VERSION = "version";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        private BgDictString<TrackInfoItunes> dictUrl = new BgDictString<TrackInfoItunes>();
        private BgDict<int, TrackInfoItunes> dictId = new BgDict<int, TrackInfoItunes>();
        //  private Dictionary<string, TrackAlbum> dictAlbum;
        private volatile object _lock = new object();
        private AlbumMgr albumMgr = AlbumMgr.Instance;






        string FILE = "..\\db.xml";
        string FILE_STAT = "..\\db_stats.xml";
        //string HUMAN_FILE = "..\\dbh.xml";
        private List<string> sources = new List<string>();
        string SOV = "..\\sov\\";
        string zipSov;
        //   private XmlSerializer xmlSerializer;

        // private bool import;
        private bool loaded;
        private bool writing;
        public bool Writing { get { return writing; } }

        public Db()
        {
            var conf = Conf.Db;
            FILE = conf.file;
            FILE_STAT = conf.fileStat;
            SOV = conf.sov;
            zipSov = conf.sovZip.Replace("[date]", DateTime.Now.Date.ToString("yy-MM-dd"));
            foreach (DbSource source in conf.sources)
            {
                sources.Add(source.file);
            }

            // AlbumMgr albums = AlbumMgr.Instance;
            // dictAlbum = albums.Dict;

            // this.import = import;
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};


        }

        public List<TrackInfoItunes> Tracks
        {
            get
            {
                if (!loaded)
                {
                    lock (_lock)
                    {

                    }
                }

                var l = new List<TrackInfoItunes>(dictId.Values);
                return l;
            }
        }

        public TrackInfoItunes get(string location)
        {
            if (!loaded)
            {
                lock (_lock)
                {

                }
            }
            var shortName = TrackInfoItunes.getShortName(location);
            return dict[shortName];
        }

        //public TrackAlbum getAlbum(string album)
        //{
        //    return albumMgr.getOrNull(album); 
        //    //var key = album.toKey();
        //    //if (dictAlbum.ContainsKey(key))
        //    //    return dictAlbum[key];
        //    //return null;
        //}
        //public TrackAlbum create(string album)
        //{
        //    var key = album.toKey();
        //    var TrackAlbum = new TrackAlbum(album, key);
        //    dictAlbum.Add(key, TrackAlbum);
        //    return TrackAlbum;
        //}

        public TrackInfoItunes get(TrackInfoItunes w)
        {
            return dictId[w.DbId];
        }

        public TrackInfoItunes getByUrl(string url)
        {
            return dictUrl[url];
        }

        public void CheckToDownload(TrackInfoItunes track)
        {
            var url = track.Url;
            if (string.IsNullOrEmpty(url))
                throw new ArgumentException(string.Format("track={0} url NULL", track));
            if (dictUrl.ContainsKey(url))
                throw new ArgumentException(string.Format("track={0} url existe:{1}", track, url));
            dictUrl.Add(url, track);
            int id = ++pieceSequenceId;
            track.DbId = id;
            dictId[track.DbId] = track;
        }

        public void Check(TrackInfoItunes track)
        {
            var location = track.ShortName;
            var url = track.Url;
            if (string.IsNullOrEmpty(location) & string.IsNullOrEmpty(url))
                return;
            TrackInfoItunes dbTrack = null;
            if (!string.IsNullOrEmpty(location))
                dbTrack = dict[location];
            if (dbTrack == null && !string.IsNullOrEmpty(url))
                dbTrack = dictUrl[url];
            //if (dbTrack == null)
            //{
            //    var album = track.TrackAlbum; 
            //    if (album != null && album != TrackAlbum.NULL)
            //    {
            //        var mode = album.DownLoadMode;
            //        TrackInfoItunes org = null;
            //        var list = album.List.FindAll(t => !string.IsNullOrEmpty(t.Location));


            //        switch (mode)
            //        {
            //            case downloadMode.none:
            //                break;
            //            case downloadMode.no:
            //                break;
            //            case downloadMode.last: org = list.Find(t => t.Pub == track.Pub);
            //                break;
            //            case downloadMode.onePerDay: org = list.Find(t => t.Pub.Date == track.Pub.Date);
            //                break;
            //            case downloadMode.onePerMin: org = list.Find(t => t.Pub == track.Pub);
            //                break;
            //            case downloadMode.multiple: org = list.Find(t => t.Pub == track.Pub && t.LogicalName == track.LogicalName);
            //                break;
            //            default:
            //                break;
            //        }

            //        if (org != null && !string.IsNullOrEmpty(org.Location))
            //            dbTrack = dict[org.Location]; 

            //    }
            //}
            if (dbTrack == null)
            {
                int id = ++pieceSequenceId;
                track.DbId = id;
                albumMgr.setAlbum(track, track.Album);
            }
            else
            {
                if (dbTrack != track)
                {
                    track.DbId = dbTrack.DbId;
                    dbTrack.Album = track.Album;
                    if (string.IsNullOrEmpty(dbTrack.Location))
                    {
                        dbTrack.Location = track.Location;
                    }

                    if (string.IsNullOrEmpty(track.Location))
                    {
                        track.Location = dbTrack.Location;
                    }

                    if (string.IsNullOrEmpty(dbTrack.Url))
                    {
                        dbTrack.Url = track.Url;
                    }

                    if (string.IsNullOrEmpty(track.Url))
                    {
                        track.Url = dbTrack.Url;
                    }

                    dbTrack.merge(track);
                }

                //if (import)
                //{
                //    track.import(dbTrack);
                //}
            }
            if (track.Pub2 < track.Pub)
            {
                var pub2 = track.Pub2.truncateToMinute();
                var pub = track.Pub.truncateToMinute();
                if (pub2 < pub)
                    track.Pub2 = pub;
            }

            location = track.ShortName;
            if (!string.IsNullOrEmpty(location))
            {
                track.Present = true;
                dict[location] = track;
            }
            if (!string.IsNullOrEmpty(url))
                dictUrl[url] = track;
            dictId[track.DbId] = track;



        }

        //public void Import(IEnumerable<TrackInfoItunes> listIt)
        //{
        //    foreach (TrackInfoItunes it in listIt)
        //    {
        //        var location = it.ShortName;
        //        var tdb = dict[location];
        //        if (tdb == null)
        //            continue;

        //        it.import(tdb);
        //    }
        //}

        //public void createIfExist(pdb.it.ITrackBuilder loader, List<TrackInfoItunes> listIt)
        //{
        //    foreach (TrackInfoItunes tdb in dict.Values)
        //    {
        //        if (tdb.isPresent())
        //        {
        //            loader.createTrack(tdb, true);
        //            tdb.import();
        //        }
        //    }
        //}



        public void load()
        {
            lock (_lock)
            {
                try
                {
                    var strVersion = "1";
                    TrackAlbum currentAlbum = null;
                    // string currentAlbumName = null;
                    using (XmlReader reader = XmlReader.Create(FILE))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {
                                    var seq = reader.GetAttribute(SEQ_PIECE);
                                    pieceSequenceId = Convert.ToInt32(seq);
                                    strVersion = reader.GetAttribute(TOKEN_VERSION);
                                }
                                else if (reader.Name == "a")
                                {
                                    currentAlbum = readAlbum(reader);
                                    // currentAlbumName = currentAlbum.Album.toKey();
                                    //if (dictAlbum.ContainsKey(currentAlbumName))
                                    //{
                                    //    currentAlbum = dictAlbum[currentAlbumName];
                                    //}
                                    //else
                                    //    dictAlbum.Add(currentAlbumName, currentAlbum);
                                }
                                else if (reader.Name == "t")
                                {
                                    var t = read(reader, currentAlbum);
                                    dict[t.ShortName] = t;
                                    if (!string.IsNullOrEmpty(t.Url))
                                        dictUrl[t.Url] = t;
                                    dictId[t.DbId] = t;
                                }

                                else if (reader.Name == "u")
                                {
                                    currentAlbum.Urls.Add(reader.GetAttribute("url"));
                                }
                            }
                        }

                    }

                    using (XmlReader reader = XmlReader.Create(FILE_STAT))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {

                                }
                                else
                                {
                                    int id = Convert.ToInt32(reader.GetAttribute("id"));


                                    var t = dictId[id];
                                    if (t == null)
                                    {
                                        string loc = reader.GetAttribute("f");
                                        Program.log.log("track {0} dans les stats non vu dans db {1}", id, loc);
                                    }
                                    else
                                    {
                                        t.readStat(reader);
                                        t.readStatGlobal(reader);
                                    }
                                }
                            }
                        }

                    }


                    foreach (string source in sources)
                    {
                        try
                        {
                            using (XmlReader reader = XmlReader.Create(source))
                            {
                                while (reader.Read())
                                {
                                    if (reader.NodeType == XmlNodeType.Element)
                                    {
                                        if (reader.Name == "db")
                                        {

                                        }
                                        else
                                        {
                                            int id = Convert.ToInt32(reader.GetAttribute("id"));


                                            var t = dictId[id];
                                            if (t == null)
                                            {

                                            }
                                            else
                                            {
                                                t.readStatGlobal(reader);
                                            }
                                        }
                                    }
                                }

                            }
                        }

                        catch (Exception ex)
                        {
                            misc.log(ex);
                        }
                    }


                    //using (XmlReader reader = XmlReader.Create(GLOBAL_STAT))
                    //{
                    //    while (reader.Read())
                    //    {
                    //        if (reader.NodeType == XmlNodeType.Element)
                    //        {
                    //            if (reader.Name == "db")
                    //            {

                    //            }
                    //            else
                    //            {
                    //                int id = Convert.ToInt32(reader.GetAttribute("id"));


                    //                var t = dictId[id];
                    //                if (t == null)
                    //                {
                    //                    string loc = reader.GetAttribute("f");
                    //                    Program.log.log("track {0} dans les global stats non vu dans db {1}", id, loc);
                    //                }
                    //                else
                    //                {
                    //                    t.readStatGlobal(reader);
                    //                    t.consolidStat();
                    //                }
                    //            }
                    //        }
                    //    }

                    //}

                }

                finally
                {
                    loaded = true;
                }
            }
        }


        private void readUrl(XmlReader reader, TrackAlbum currentAlbum)
        {
        }

        private TrackInfoItunes read(XmlReader reader, TrackAlbum currentAlbum)
        {
            var t = new TrackInfoItunes();

            //if (album != null)
            //{
            t.TrackAlbum = currentAlbum;

            // }
            t.build(reader);
            if (t.Name.StartsWith("Jean-François Copé, sur les Les Républicains"))
            {
            }

            currentAlbum.Add(t, true);
            return t;
        }

        private TrackAlbum readAlbum(XmlReader reader)
        {
            string name = reader.GetAttribute("name");
            var album = albumMgr.Get(name);
            if ("y" == reader.GetAttribute("rare"))
                album.setRare();
            if ("y" == reader.GetAttribute("info"))
                album.setInfo();
            if ("y" == reader.GetAttribute("actu"))
                album.setActu();
            if ("y" == reader.GetAttribute("courant"))
                album.setCourant();


            var str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                album.AlbumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("note");
            if (!string.IsNullOrEmpty(str))
                album.Note = Convert.ToDouble(str);

            str = reader.GetAttribute("download");
            if (!string.IsNullOrEmpty(str))
                album.DownLoadMode = (downloadMode)Enum.Parse(typeof(downloadMode), str, true);
            else
                album.DownLoadMode = downloadMode.none;

            return album;
        }

        private void write(XmlWriter writer, TrackAlbum album)
        {
            writer.WriteStartElement("a");
            try
            {
                writer.WriteAttributeString("name", album.Album);
                if (album.AlbumRating > 0)
                    writer.WriteAttributeString("rating", album.AlbumRating.ToString());
                if (album.Note != 0)
                    writer.WriteAttributeString("note", album.Note.ToString("0.##"));
                if (album.Rare)
                    writer.WriteAttributeString("rare", "y");
                else if (album.RareEffect)
                    writer.WriteAttributeString("rareEffect", "y");
                if (album.Info)
                    writer.WriteAttributeString("info", "y");
                if (album.Actu)
                    writer.WriteAttributeString("actu", "y");
                if (album.Courant)
                    writer.WriteAttributeString("courant", "y");

                writer.WriteAttributeString("spec", album.Specif.ToString());
                if (album.DownLoadMode > downloadMode.none)
                    writer.WriteAttributeString("download", album.DownLoadMode.ToString());

                var list = album.List;
                list.Sort(new TrackComparer());
                // list.Sort(new PodCastComparer());

                TrackInfoItunes last = null;
                var l2 = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (t.TrackAlbum == null || t.TrackAlbum == TrackAlbum.NULL)
                        t.TrackAlbum = album;  // = album; 
                    //if (t.Deleted)
                    //    listDeleted.Add(t);
                    // else
                    if (!Conf.Db.purgemissing || (string.IsNullOrEmpty(t.Location) && !string.IsNullOrEmpty(t.Url)) || t.isPresent())
                    {
                        l2.Add(t); // write(writer, t, false);
                        last = t;
                    }
                    else
                        listMissing.Add(t);
                }
                if (last != null)
                {
                    writer.WriteAttributeString("lastPub", last.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                    writer.WriteAttributeString("last", last.Name);
                }

                foreach (string url in album.Urls)
                {
                    writer.WriteStartElement("u");
                    writer.WriteAttributeString("url", url);
                    writer.WriteEndElement();
                }

                foreach (TrackInfoItunes t in l2)
                {
                    write(writer, t, false);
                }
            }
            catch (Exception ex)
            {
                misc.log("impossible d'enregistrer {0} {1}", album.Album, ex);
            }
            writer.WriteEndElement();

        }

        private static void write(XmlWriter writer, TrackInfoItunes track, bool writeAlbum)
        {
            try
            {
                writer.WriteStartElement("t");
                writer.WriteAttributeString("id", track.DbId.ToString());
                if (track.Pub > DateTime.MinValue)
                    writer.WriteAttributeString("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                var location = track.Location;
                if (!string.IsNullOrEmpty(location))
                {
                    if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                    {
                        location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                    }


                }
                writer.WriteAttributeString("f", location);
                if (writeAlbum)
                    writer.WriteAttributeString("alb", track.Album);
                else if (track.TrackAlbum.Album.toKey() != track.Album.toKey())
                    writer.WriteAttributeString("alb", track.Album);
                if (track.Note < int.MaxValue && track.isConcernedBySelection)
                    writer.WriteAttributeString("note", track.Note.ToString("0.##"));
                writer.WriteAttributeString("name", track.Name);

                if (track.Pub2 > DateTime.MinValue && track.Pub2 > track.Pub)
                    writer.WriteAttributeString("pub2", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                if (track.PlayedDate > DateTime.MinValue)
                    writer.WriteAttributeString("date", track.PlayedDate.ToString());
                if (track.PlayCount > 0)
                    writer.WriteAttributeString("nbr", track.PlayCount.ToString());
                //if (track.AlbumRating > 0)
                //    writer.WriteAttributeString("albumRating", track.AlbumRating.ToString());
                if (track.Rating != track.AlbumRating)
                    writer.WriteAttributeString("rating", track.Rating.ToString());


                //if (track.RatingComputed)
                //    writer.WriteAttributeString("computed", "y");
                //if (track.Rare)
                //    writer.WriteAttributeString("rare", "y");
                //if (track.Info)
                //    writer.WriteAttributeString("info", "y");
                var duree = track.Duree;
                if (duree.Value > 0)
                {
                    writer.WriteAttributeString("d", duree.Value.ToString("0"));
                    var size = track.Size;
                    if (size > 0)
                        writer.WriteAttributeString("s", size.ToString());
                }
                if (!track.Enabled)
                    writer.WriteAttributeString("disabled", "y");

                if (track.Added > DateTime.MinValue)
                    writer.WriteAttributeString("add", track.Added.ToString());
                if (track.AddedFirst > DateTime.MinValue && track.AddedFirst < track.Added)
                    writer.WriteAttributeString("add1", track.AddedFirst.ToString());

                if (!string.IsNullOrEmpty(track.Description))
                    writer.WriteAttributeString("desc", track.Description);

                if (!string.IsNullOrEmpty(track.LongDescription))
                    writer.WriteAttributeString("ldesc", track.LongDescription);

                try
                {
                    var comment = track.Comment;
                    if (!string.IsNullOrEmpty(comment))
                    {
                        var build = track.buildComment();
                        if (comment != build)
                            writer.WriteAttributeString("comment", comment);
                    }
                }
                catch (Exception ex)
                {
                    misc.log("impossible de vérifier comment de {0} id={1} {2}", track, track.DbId, ex);
                }


                if (!string.IsNullOrEmpty(track.HibernateLocation))
                    writer.WriteAttributeString("hl", track.HibernateLocation);

                if (!string.IsNullOrEmpty(track.Url))
                    writer.WriteAttributeString("url", track.Url);

            }
            catch (Exception ex)
            {
                misc.log("impossible d'enregistrer {0} {1} {2}", track.DbId, track, ex);
            }

            writer.WriteEndElement();

        }

        private static void writeStat(XmlWriter writer, TrackInfoItunes track)
        {
            if (track.In > DateTime.MinValue)
            {
                writer.WriteStartElement("t");
                writer.WriteAttributeString("id", track.DbId.ToString());
                var location = track.Location;
                if (!string.IsNullOrEmpty(location))
                {
                    if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                    {
                        location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                    }


                }
                writer.WriteAttributeString("f", location);



                if (track.Out == DateTime.MinValue || track.In < track.Out)
                {
                    writer.WriteAttributeString("in", track.In.ToString());
                    if (track.Out > DateTime.MinValue)
                        writer.WriteAttributeString("out", track.Out.ToString());
                }
                else
                {
                    writer.WriteAttributeString("out", track.Out.ToString());
                    writer.WriteAttributeString("in", track.In.ToString());
                }


                writer.WriteEndElement();
            }

        }

        public void recordIt(IEnumerable<TrackInfoItunes> listIt)
        {
            using (System.IO.StreamWriter sw = new StreamWriter(@"..\load.txt"))
            {
                if (listIt != null)
                {
                    foreach (TrackInfoItunes t in listIt)
                    {
                        Check(t);
                        sw.Write(t.ID);
                        sw.Write("\t");
                        sw.Write(t.Location);
                        sw.Write("\t");
                        sw.WriteLine(t.Url);
                    }
                }
            }
        }

        private List<TrackInfoItunes> listMissing;
        private List<TrackInfoItunes> listDeleted;
        private class TrackComparer : IComparer<TrackInfoItunes>
        {
            public virtual int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                int cmp = x.Pub.CompareTo(y.Pub);
                if (cmp != 0)
                    return cmp;
                return x.DbId.CompareTo(y.DbId);
            }
        }

        private class TrackComparerInv : TrackComparer
        {
            public override int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                return -base.Compare(x, y);
            }
        }

        public void writeAsync()
        {
            new ThreadUtil(write, "db.write").Start();
        }
        public void write()
        {
            misc.log("db::write");
            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            var listZip = new List<string>();
            lock (_lock)
            {
                writing = true;
                try
                {
                    if (!Directory.Exists(SOV))
                        Directory.CreateDirectory(SOV);
                    ZipUtil.Exe = @"C:\Program Files\7-Zip\7z.exe";
                    // ZipUtil.Enter();
                    //ZipUtil.CompressAsync(zipSov, FILE, true); 
                    var destCopy = string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE));
                    File.Copy(FILE, destCopy, true);
                    listZip.Add(destCopy);
                    //  ZipUtil.CompressAsync(zipSov, timeStamp, new List<string> { destCopy }, false); 

                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                finally
                {
                    // ZipUtil.Release();
                }


                listMissing = new List<TrackInfoItunes>();
                listDeleted = new List<TrackInfoItunes>();

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(FILE + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());

                    //AlbumMgr mgr = TrackInfoItunes.AlbumMgr as AlbumMgr;
                    var albums = albumMgr.List;

                    //albums.Sort(new TrackComparer()); 
                    albums.Sort((x, y) => x.Album.CompareTo(y.Album));

                    foreach (TrackAlbum album in albums)
                    {
                        write(writer, album);
                    }

                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE + ".tmp", FILE, true);



                if (listMissing.Count > 0)
                {
                    string missing = string.Format("{0}{1}__missing.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(missing, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            write(writerMissing, track, true);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }

                    listZip.Add(missing);

                }

                if (listDeleted.Count > 0)
                {
                    var deleted = string.Format("{0}{1}__deleted.xml", SOV, timeStamp);
                    using (XmlWriter writerDeleted = XmlWriter.Create(deleted, settings))
                    {
                        writerDeleted.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            write(writerDeleted, track, true);
                        }
                        writerDeleted.WriteEndDocument();
                        writerDeleted.Flush();
                    }
                    listZip.Add(deleted);
                }
                var destCopyStat = string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE_STAT));
                if (File.Exists(FILE_STAT))
                {
                    File.Copy(FILE_STAT, destCopyStat, true);
                    listZip.Add(destCopyStat);
                }

                using (XmlWriter writer = XmlWriter.Create(FILE_STAT + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    var tracks = Tracks;
                    tracks.Sort(new PodCastComparer());
                    foreach (TrackInfoItunes track in tracks)
                    {
                        if (!Conf.Db.purgemissing || (string.IsNullOrEmpty(track.Location) && !string.IsNullOrEmpty(track.Url)) || track.isPresent())
                            writeStat(writer, track);
                    }
                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE_STAT + ".tmp", FILE_STAT, true);

                // listZip.Add(FILE_STAT); 

                if (listMissing.Count > 0)
                {
                    var missing = string.Format("{0}{1}__missing_stat.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(missing, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }
                    listZip.Add(missing);

                }

                if (listDeleted.Count > 0)
                {
                    var deletedStat = string.Format("{0}{1}__deleted_stat.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(deletedStat, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }
                    listZip.Add(deletedStat);

                }
                misc.log("db::fin write");
                ZipUtil.Compress(zipSov, null, listZip, false, false);
                misc.log("db::fin write et zip");
                //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                writing = false;
            }
        }


        // géopolitique 4 par défaut rating ->80 albumrating ->80 computed =true
        //RFI 0 de temps en temps surcharge pour un par défaut : rating null albumrating->20 computed = true
        //                                  pour un syrchargé  : rating non null ""   
        // adele 1                          pour les défaut   rating:20 album 20 computed
        //                                  pour un surchargé 4 rating 80 album 20 non computed

        //C'est quand même gavant. il fait pas la différence entre les étoiles pleines et creuses
        //prenons adele defaut : 20 /20 computed
        //          autre        80 /20 non computed


        // ayo album zero surcharge 1 deux étoiles creuses => 20/40/computed

        //Ah ok . cas computed 1. album=rating => c'est bien level album
        //                        album != rating => c'est bidon  "étoile creuse"                                
        //        sinon on lit directement level album

        // Quel con j'ai pas vu qu'il y avait RatingComputed et Album Rating computed
        // je me le refele
        //géopolitique ratinet alubm => 80 ratingComputed
        // RFi  defaut rating null album 20 albumcomputed
        //      surchargé   rating 20 idem     
        // adele defaut rating 20 rating computed albumrating 20




    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\pdb.gen.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.gen</RootNamespace>
    <AssemblyName>pdb.gen</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;COMPACT_</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="albums\Album.cs" />
    <Compile Include="albums\AlbumComparer.cs" />
    <Compile Include="albums\AlbumMedianne.cs" />
    <Compile Include="albums\Albums.cs" />
    <Compile Include="albums\DecimalPiece.cs" />
    <Compile Include="albums\IPieceAlbum.cs" />
    <Compile Include="albums\PieceExtended.cs" />
    <Compile Include="albums\PieceExtendedSimple.cs" />
    <Compile Include="albums\PieceSort.cs" />
    <Compile Include="albums\StackAlbum.cs" />
    <Compile Include="albums\VirtualAlbumPiece.cs" />
    <Compile Include="auto\CalcAuto.cs" />
    <Compile Include="auto\ConfMedianneVirt.cs" />
    <Compile Include="auto\HistoValue.cs" />
    <Compile Include="auto\Medianne.cs" />
    <Compile Include="auto\MedianneDriver.cs" />
    <Compile Include="CalcEquiv.cs" />
    <Compile Include="ClassementCache.cs" />
    <Compile Include="Consolid.cs" />
    <Compile Include="CLegacyListWriter.cs" />
    <Compile Include="CRank.cs" />
    <Compile Include="IListWriter.cs" />
    <Compile Include="ListPiece.cs" />
    <Compile Include="CPieceComparer.cs" />
    <Compile Include="ListSelection.cs" />
    <Compile Include="ListWriterMgr.cs" />
    <Compile Include="medianne\enums.cs" />
    <Compile Include="pertinence\TrackBuilder.cs" />
    <Compile Include="Piece.cs" />
    <Compile Include="CalcDate.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="stat\ClassStruct.cs" />
    <Compile Include="stat\Condenseur.cs" />
    <Compile Include="stat\DynamicStatBuilder.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="stat\MedianneValue.cs" />
    <Compile Include="stat\NewClassement.cs" />
    <Compile Include="stat\StatBuilder.cs" />
    <Compile Include="stat\StatConteneur.cs" />
    <Compile Include="TrackList.cs" />
    <Compile Include="Tuning\CConf.cs" />
    <Compile Include="Tuning\CConfQL.cs" />
    <Compile Include="Tuning\CConfSort.cs" />
    <Compile Include="Tuning\ConfAlbumSort.cs" />
    <Compile Include="Tuning\ConfFilter.cs" />
    <Compile Include="Tuning\ConfGen.cs" />
    <Compile Include="Tuning\ConfMedianne.cs" />
    <Compile Include="Tuning\CTuning.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\GroupingDisplay.cs" />
    <Compile Include="Tuning\Import.cs" />
    <Compile Include="Tuning\ZeroWorkConf.cs" />
    <Compile Include="Util.cs" />
    <Compile Include="VirtualAlbumPieceLight.cs" />
    <Compile Include="Virtuel\VirtualPiece.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.IO;

namespace pdb.gen.albums
{
    public enum virtualMode
    {
        none = 0,
        artist = 1,
        path = 2,
        year = 3,
        extended = 4,
        added = 5,
        list = 6,
        word = 7
    }

    public enum sortDone : byte
    {
        none,
        phaseUn,
        phaseDeux
    }

    public class Album : IEnumerable<Piece>
    {
        const int NB_DEC = 3;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        const int A_REFAIRE_CAUSE_COMPACT = -10;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
#if GEN2
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;
#endif
        private sortDone sortStatus;

        private int nbRecent;
        private int nbDone;
        public int Recents { get { return nbRecent; } }
        public int NbDone { get { return nbDone; } }
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }


            return ret; ;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
#if GEN2
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
#else
                return ClassementValueLightSt;
#endif
            }
        }
        //  private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero
        {
            get
            {
#if GEN2
                return classementValueLightZero;
#else
                return ClassementValueLight;
#endif
            }
        }
        public decimal Rendement
        {
            get
            {
#if GEN2
                if (classementValueLight == 0) return 1; return classementValueLightZero / classementValueLight;
#else
                return 1;
#endif
            }
        }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private virtualMode mode;
        public virtualMode VirtualMode { get { return mode; } }
        //  private bool _virtual;
        public bool Virtual { get { return mode > virtualMode.none; } }
        public void setVirtual(virtualMode mode) { this.mode = mode; }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return this.mode == virtualMode.artist; } }
        private Piece pluspetitEnabled;
        public Piece PlusPetitEnabled { get { return pluspetitEnabled; } }
        private int stackValue;
        private DateTime majDate;
        public DateTime MajDate { get { return majDate; } }

        public int StackValue
        {
            get
            {

                return stackValue;
            }
            set
            {
                if (value > 0 && this.Name == "\\")
                {
                }
                else
                    stackValue = value;
            }
        }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, mode);
                return key;
            }
        }

        public Album(string name, virtualMode mode)
        {
            this.name = name;
            this.mode = mode;
            quality = CRank.MAX;
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            quality = CRank.MAX;
        }
        private int quality;
        public int Quality
        {
            get { return quality; }
            set { quality = value; }
        }

        public int RankAlbumReverse
        {
            get
            {
                return Albums.RankZero - quality; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
            }
        }

        private decimal timeRest = decimal.MaxValue;
        public decimal TimeRest { get { return timeRest; } set { timeRest = System.Math.Round(value, NB_DEC); } }
        public string Name { get { return name; } }

        public override string ToString()
        {
            return string.Format("{0} {1} {2} elts", name, mode, Count);
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0
        {
            get
            {
#if GEN2
                return Piece.getClassementEquiv(classementValueLightZero);
#else
                return EquivLight;
#endif
            }
        }

        //// private string moyenne = "";
        //public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return StackIndex == stackSize; } }
        public bool AlmostFree1 { get { return StackIndex == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (build)
                throw new ApplicationException("déjà buildé");
            piece.PieceAlbum = this;


            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                quality = CRank.MAX;
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public void ClearAndMenage()
        {
            if (mode == virtualMode.word && name == "029")
            {
            }
            if (mode != virtualMode.none)
            {
                foreach (Piece p in list)
                    p.setParent(null);
            }
            Clear();
        }

        public void ConsolidChilds()
        {
            foreach (Piece p in list)
                p.consolidChild();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && !p.ClassmentPositive())
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                var exists = FileRegister.Exist(next.Location);
                return false == exists;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return false; } }// selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<IPieceAlbum> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {
                #region calcul virtuel



                DecimalPiece med = null;
#if GEN2
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;
#endif



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                // bool combineNow = mode.combine && mode.simple;
#if GEN2
                if (real)
                    _albumMedianne.buildVirtual(mode.combine, mode.simple);
                else
                {
#else
                if (mode.Main.coeffVirt > 1)
                    _albumMedianne.buildVirtual(true, mode.simple);
                else
                    list.Sort(new PieceClassementComparer(false));
#endif
#if GEN2
            }
#endif
#if GEN2

                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    med1 = med; med2 = med;

                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, pieceExtendedMode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }

                    if (mode.combine && !mode.simple)
                    {
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    }


                }

                
                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }
#else
                med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);
                var median = med.index;

                if (median != null)
                {
                    resultGlobalMin = median.getSimpleCause();
                }
#endif















                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, pieceExtendedMode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var cnext = cause.Next;
                if (cnext != null)
                {
                    if (cnext.UseCompact && !cnext.Empty)
                    {
                        if (cnext.Piece.ClassementRecentCompact)
                        {
                            cnext.UseCompact = false;
                            return A_REFAIRE_CAUSE_COMPACT;
                        }
                    }
                }
                classementValueLight = med.d;
                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    //if (mode.combine && !mode.simple)
                    //{
                    //    _albumMedianne.buildVirtual(true);
                    //    med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                    //    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    //}
                    //else
                    //{
                    //    if (true == cause.selectedMotifMin)
                    //        med = med2;
                    //    else
                    //        med = med1;
                    //}




                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

#if GEN2
                    foreach (var p in list)
                        p.finalyse();

#endif


                    if (cause.motifUp)
                    {
                        if (cause.selectedMotifMin.HasValue)
                        {
                            if (true == cause.selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else if (selectedMotifMin.HasValue)
                        {
                            if (true == selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else
                        {
                            if (true == resultGlobalMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }


                    }

                    try
                    {
                        if (med.index != null)
                            pluspetitEnabled = med.index.Piece;
                        if (med.index != null) med.index.Piece.MedianneLight = true;
                        if (med.indexBorder != null) med.indexBorder.Piece.Border = true;
                        if (med.indexBorderEffect != null) med.indexBorderEffect.Piece.BorderEffect = true;
                        if (med.indexBorderMin != null) med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public IPieceAlbum Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<IPieceAlbum> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;
            bool forceKeep = mode.forceKeep;
            bool forceKeep2 = mode.forceKeep2;
            bool dontDownByKeep = mode.dontDownByKeep;


            // PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            IPieceAlbum nextZero1 = null;
#if GEN2
            IPieceAlbum nextZero2 = null;
             IPieceAlbum min2 = null;
                Classement _min2 = null;
              Classement _minzero2 = null;
#endif

            IPieceAlbum min1 = null;

            IPieceAlbum min = null;
            Classement _min1 = null;

            Classement _minzero1 = null;

            bool realZero = false;
            IPieceAlbum Next = null;

            IPieceAlbum firstKeep = null;
            IPieceAlbum firstKeep2 = null;
            foreach (IPieceAlbum p in list)
            {
                if (p.Piece.Keep)
                {
                    if (forceKeep && p.Piece.KeepCoeff > 0)
                    {
                        if (firstKeep == null)
                            firstKeep = p;
                    }
                    if (p.Piece.KeepCoeff < 0)
                    {
                        if (firstKeep2 == null)
                            firstKeep2 = p;
                    }

                    //min= firstInAlbumEmpty; 
                    //break;
                }
                var v1 = p.Classement;
#if GEN2
                var v2 = p.Classement2;
#endif

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            if (!p.Piece.Keep || !dontDownByKeep)
                            {
                                _minzero1 = v1;
                                nextZero1 = p;
                                if (v1.isZero())
                                    realZero = true;
                            }
                        }
                    }
#if GEN2

                    if (v2.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2.isZero())
                                realZero = true;
                        }

                    }

#endif

                    if (v1.isPositive() && v1 < _min1)
                    {
                        if (!p.Piece.Keep || !dontDownByKeep)
                        {
                            _min1 = v1;
                            min1 = p;
                        }
                    }
#if GEN2
                    if (v2.isPositive() && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }
#endif

                    if (p.Empty)
                        break;
                }
            }
            Classement _min = null;
#if GEN2
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;

            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }
#else
            min = min1;
            _min = _min1;
#endif

            IPieceAlbum nextZero = null;
            Classement _minzero = null;
#if GEN2
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }
#else
            nextZero = nextZero1; _minzero = _minzero1;
#endif

            //if (firstInAlbumEmpty != null)
            //{
            //    Next = firstInAlbumEmpty;
            //    cause.selectedMotifMin = cause.resultByFirstMin;
            //    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
            //}
            //else
            //{

            if (nextZero != null)
            {
                decimal _minValue = _min == null ? int.MaxValue : _min.RapportClassement;
                decimal _minZeroValue = _minzero == null ? int.MaxValue : _minzero.RapportClassement;
                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane

                    if (_minValue < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.ClassementValueLightZero > classementValueLight + EPSILON || (classementValueLight > 0 && this.ClassementValueLightZero / classementValueLight > 1 + EPSILON)) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_minValue < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minZeroValue < classementValueLight)
                    {
                        classementValueLight = _minZeroValue;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {

                        classementValueLight = _min == null ? int.MaxValue : _min.RapportClassement;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min.RapportClassement;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }
            //}

            if (Next == nextZero)
            {
                bool refact = false;

                if (firstKeep2 != null)
                {
                    if (forceKeep2)
                    {
                        Next = firstKeep2; refact = true;
                    }
                    else if (firstKeep2.Piece.DeepClassement.isZero())
                    {
                        Next = firstKeep2; refact = true;
                    }
                }
                else if (firstKeep != null)
                {
                    Next = firstKeep; refact = true;
                }

                if (refact)
                {
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                }
            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            if (real && min != null)
                this.pluspetitEnabled = min.Piece;
            return cause;



        }


        private bool makesort(List<Piece> list, List<IPieceAlbum> listE, ConfMedianne mode, ConfMedianne mode0, int nbrepeat)
        {
            int count = list.Count;

            if (sortStatus == sortDone.none)   //(!sort0Done)
            {
                // list.Sort(new CPieceComparerByQualityAndLength());
                var listSortedValues = new List<decimal>();
                //classed = false;
                //for (int i = 0; i < count; i++)
                //{
                //    listSortedValues.Add(list[i].Rank.SortValue);
                //    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                //        classed = true;
                //}
                ////misc.log("make sort Duration {0}", name); 
                //m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                //  listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                {
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                }
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                //   decimal moy = 0m;
                decimal offset = Album.conf.AlbumMoyOffset;
#if GEN2
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement(true);

                    p.setClassementVirtuel(rapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;
#endif

                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }
                if (sortStatus < sortDone.phaseUn)
                    sortStatus = sortDone.phaseUn;
                //   sort0Done = true;

            }


            if (sortStatus >= sortDone.phaseDeux)
                return false;

            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;
            selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;

#if GEN2
            classementValueLightZeroSt = -1;
           
            classementValueLightZero = makeSort(listE, mode0, false);
            if (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }
#endif
            classementValueLight = makeSort(listE, mode, true);
            if (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }

            //   classementValueLightZero = A_REFAIRE_CAUSE_COMPACT;


            //   while (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLightZero = makeSort(listE, mode0, false);
            //   }

            ////   var _classementValueLight = makeSort(listE, mode, true);

            //   while (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLight = makeSort(listE, mode, true);
            //   }
#if GEN2
            var coeff1 = mode.Main.coeffVirt;
            var coeff2 = mode.Min.CoeffOld;
            var rendementmax = 1m;

            if (mode.combine)
                rendementmax = coeff1 * coeff2;
            else
                rendementmax = pdb.util.Math.Max(coeff1, coeff2);
            if (Rendement > 6 * rendementmax + 1e-6m)
            {
                nbrepeat++;
                sortStatus = sortDone.none;
                if (nbrepeat >= 3)
                {
                    // classementValueLight = classementValueLightZero;
                    return true;
                }
                return makesort(list, listE, mode, mode0, nbrepeat);

            }
#endif
            return true;
        }



        public bool makeSort(ConfMedianne mode, ConfMedianne mode0, ILogger logger, double dureeMinToLog) //IList<double> reference, IList<Piece> pieces)
        {

            if (sortStatus >= sortDone.phaseDeux)
                return false;
            DateTime nowa = DateTime.Now;
            var ts = (nowa - majDate);
            try
            {

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return false;
                if (count == 1401)
                { }
                if (this.name == "Early Magic")
                {

                }

                var listE = new List<IPieceAlbum>(count);

                //if (CConf.ResetOneCl)
                //{

                //    // CPieceClassement.DateMin = DateTime.MinValue;
                //    decimal zer0d = 0;
                //    Piece oldKeep = null;


                //    foreach (Piece t in list)
                //    {
                //        if (t.Keep)
                //        {
                //            t.Keep = false;
                //            oldKeep = t;
                //            break;
                //        }
                //    }


                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in list)
                //    {
                //        var cl = t.DeepClassement; // p.Classement.DbValue;
                //        decimal clValue = Piece.classementHash.getCache(cl).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {

                //            if (t.LastClassementRecent || !t.Enabled)
                //            {
                //                min = null;
                //                break;
                //            }
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        min.Keep = true;
                //        var r = min.RapportClassement(true);
                //        if (r <= 0)
                //        {
                //        }
                //    }



                //    if (oldKeep != null && !oldKeep.Keep)
                //    {
                //        oldKeep.resetMedianneCompact();
                //        oldKeep.invalidateCache(true);
                //    }
                //}


                atLeastOneEnabled = false;
                int _nbr = 0;
                int _nbdone = 0;


                for (int i = 0; i < count; i++)
                {
                    var p = list[i];


                    if (sortStatus < sortDone.phaseDeux) //  (!sortDone)
                        p.resetMedianneCompact();
                    if (p.Enabled)
                    {
                        atLeastOneEnabled = true;

                    }
                    if (!p.Enabled && p.ClassmentPositive())
                        _nbdone++;
                    if (p.LastClassementRecent)
                        _nbr++;
#if GEN2
                    var pp = new PieceExtended(p);
#else
                    var pp = p;
#endif
                    if (p.Name=="Sharp Dressed Man")
                    { }
                    if (p.Keep)
                    {

                    }
                    if (mode.Main.coeffVirt > 1)
                        listE.Add(new PieceExtendedSimple(pp));
                    else
                        listE.Add(pp);
                }

                nbRecent = _nbr;
                nbDone = _nbdone;


                bool ret = makesort(list, listE, mode, mode0, 0);

                sortStatus = sortDone.phaseDeux;

                majDate = DateTime.Now;
                var duree = (majDate - nowa);
                if (duree.TotalMilliseconds > dureeMinToLog)
                    logger.log(string.Format("make Sort {0}| {1} {2}", ts.toString(), duree.toString(), this));

                return ret;
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return false;
        }



        public void mustRefresh()
        {
            build = false;
            sortStatus = sortDone.none;

            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
            albumAdded = DateTime.MaxValue;
        }

        public void refreshLight()
        {
            if (sortStatus == sortDone.phaseDeux)
                sortStatus = sortDone.phaseUn;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
        }



        //public decimal getTrackSortValue(int index, List<Piece> list)
        //{
        //    if (index < 0 || index >= list.Count)
        //        return 0;
        //    return list[index].RapportClassement(true);
        //}

        //decimal firstTrackSortValue = -1;
        //public decimal getFirstTrackSortValue()
        //{
        //    if (firstTrackSortValue == -1)
        //    {
        //        int count = list.Count;
        //        if (count == 0)
        //            return -1;
        //        var _list = new List<Piece>(list);
        //        _list.Sort(new PieceSortComparer());
        //        firstTrackSortValue = _list[count - 1].Rank.SortValue;
        //    }
        //    return firstTrackSortValue;
        //}
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            timeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> RawList
        {
            get
            {
                return new List<Piece>(list);
            }
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        //private CRank m_rank = new CRank();

        //public CRank Rank { get { return m_rank; } }



        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            quality = CRank.MAX;
            // rankStack = -1;
        }

        //public int QRank
        //{
        //    get { return m_rank.Quality; }
        //    set { m_rank.Quality = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}


        #endregion

        #region tri



        #endregion

        [Flags]
        private enum unsortMode : byte
        {
            album = 1,
            artist = 2

        }
        const char SEP = '\\';
        const int MAX_PATH_LEVEL = 10;

        public void addPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            paths.Add(p);
                        }
                        ilevel++;
                    }
                    // paths.Add(path);
                }
            }
        }

        public bool containsPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    if (paths.Contains(path))
                        return true; //paths.Add(path);
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            if (paths.Contains(p))
                                return true;
                        }
                        ilevel++;
                    }

                }
            }
            return false;
        }
        public void sortVirtual()
        {
            if (this.VirtualMode == virtualMode.none)
                return;
            var list = this.list.ToList<Piece>();
            int count = list.Count;
            if (count == 0)
                return;
            list.Sort((x, y) =>
            {
                var cmp = x.MasterTrackNumberForTri.CompareTo(y.MasterTrackNumberForTri);
                if (cmp != 0)
                    return cmp;
                return x.Location.CompareTo(y.Location);
            });
            var dictArtist = new Dictionary<string, List<Piece>>();
            var dictAlbum = new Dictionary<int, string>();
            var dictDir = new Dictionary<string, List<Piece>>();
            DirSort.reset();
            foreach (Piece p in list)
            {

                DirSort.record(p);
            }

            DirSort.go();


            foreach (Piece p in list)
            {
                if (p.TrackNumber == 0)
                {
                    p.TrackNumber = list.Count + p.MasterTrackNumber;
                }
            }

            list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;

            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}

            //var list2 = new List<Piece>(list);
            //list2.Sort(new VirtualPieceComparer());

            var hs = new HashSet<int>();
            var unsorted = new List<Piece>();
            Piece pp = list[0];
            hs.Add(pp.PieceId); unsorted.Add(pp);
            //string currentArtist = pp.Artist;
            //string currentAlbum = pp.Master.Album;


            int indexC = 0;
            //  bool singleAlbum = false;
            string currentArtist = Album.getKey(pp.Artist, virtualMode.artist);
            unsortMode mode = unsortMode.album | unsortMode.artist;
            if (VirtualByArtist)
                mode = unsortMode.album;

            HashSet<string> artists = new HashSet<string>();
            HashSet<string> albums = new HashSet<string>();
            artists.Add(currentArtist);
            albums.Add(pp.Master.PieceAlbum.Key);
            //  HashSet<string> paths = new HashSet<string>();
            //int pathlevel = 0;
            //  bool found = false;
            int nbc = 0;
            while (unsorted.Count < count)
            {
                nbc++;
                //int indexAlbum = -1;
                //int indexArtist = -1;


                // addPath(pp, paths, pathlevel);

                artists.Clear();
                albums.Clear();
                //    paths.Clear();
                artists.Add(currentArtist);
                albums.Add(pp.Master.PieceAlbum.Key);


                for (int i = 0; i < count; i++)
                {

                    var p = list[i];
                    if (hs.Contains(p.PieceId))
                        continue;

                    if (mode == 0)
                    {
                        hs.Add(p.PieceId);
                        unsorted.Add(p);
                        pp = p;
                        // indexAlbum = -1;
                        indexC = i;
                        continue;
                    }
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        var artist = p.Artist;
                        if (p.Artist != pp.Artist)
                        {
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            if (currentArtist != cartist)
                            {
                                if (!artists.Contains(cartist))
                                {
                                    if (mode.HasFlag(unsortMode.album))
                                    {
                                        if (albums.Contains(p.Master.PieceAlbum.Key))
                                        {
                                            //if (albums.Count <= 1)
                                            //    indexArtist = i;
                                            continue;
                                        }
                                    }

                                    //if (pathlevel <= MAX_PATH_LEVEL)
                                    //{
                                    //    if (containsPath(p, paths, pathlevel))
                                    //        continue;
                                    //}

                                    hs.Add(p.PieceId);
                                    unsorted.Add(p);
                                    pp = p;
                                    //indexAlbum = -1;
                                    //indexArtist = -1;

                                    albums.Add(pp.Master.PieceAlbum.Key);
                                    artists.Add(cartist);
                                    //  addPath(pp, paths, pathlevel); 
                                    indexC = i;
                                    currentArtist = cartist;
                                    //   found = true;
                                    continue;

                                }
                            }
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                    {
                        var album = p.Master.PieceAlbum.Key;
                        if (!albums.Contains(album))
                        {
                            //if (pathlevel <= MAX_PATH_LEVEL)
                            //{
                            //    if (containsPath(p, paths, pathlevel))
                            //        continue;
                            //}
                            hs.Add(p.PieceId);
                            unsorted.Add(p);
                            pp = p;
                            indexC = i;
                            //indexAlbum = -1;
                            albums.Add(album);
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            artists.Add(cartist);
                            currentArtist = cartist;
                            //   found = true;
                            //  addPath(pp, paths, pathlevel); 
                        }
                    }
                }


                //if (indexAlbum >= 0)
                //{
                //    // pas trouvé d'autre artiste, on se rabat sur l'album
                //    var p = list2[indexAlbum];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexAlbum;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else if (indexArtist >= 0)
                //{
                //    // on a trouvé un autre artiste sur le même album. pas si mal
                //    var p = list2[indexArtist];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexArtist;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else
                //{
                //    // rien trouvé de spécial
                //    if (indexC == 0 && !singleAlbum)
                //    {
                //        singleAlbum = true;
                //    }
                //    indexC = 0;

                //}

                if (indexC == 0)
                {

                    //if (found)
                    //{
                    //    found = false;
                    //}
                    //else
                    //{
                    //{
                    //    if (paths.Count == 0)
                    //    {
                    //        pathlevel = MAX_PATH_LEVEL; 
                    //    }
                    //    if (pathlevel < MAX_PATH_LEVEL)
                    //    {
                    //        pathlevel++;
                    //    }
                    //    else
                    //    {
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        if (mode.HasFlag(unsortMode.album))
                            // on cherche les artistes différents ( éventuellement même album ) 
                            mode &= ~unsortMode.album;
                        else
                        {
                            // on abandonne la recherche artiste et on réactive la recherche album
                            mode &= ~unsortMode.artist;
                            mode |= unsortMode.album;
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                        // on est en mode single album; 
                        mode &= ~unsortMode.album;

                    //pathlevel = 0;
                    //  }
                }
                //}
                // }
                indexC = 0;

            }

            for (int i = 0; i < unsorted.Count; i++)
            {
                unsorted[i].TrackNumber = i + 1;
            }



            //foreach (Piece p in list)
            //{
            //    if (p == null)
            //        continue;
            //    var artist = p.Artist;
            //    FileInfo file = null;
            //    try
            //    {
            //        file = new System.IO.FileInfo(p.Location);
            //    }
            //    catch
            //    {
            //        continue;
            //    }
            //    var dirAlbum = file.Directory;
            //    var dirArtist = dirAlbum.Parent;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = dirArtist.FullName;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = "-";
            //    if (!dictArtist.ContainsKey(artist))
            //        dictArtist.Add(artist, new List<Piece>());
            //    dictArtist[artist].Add(p);

            //    var _album = p.Master.Album;
            //    if (string.IsNullOrEmpty(_album))
            //        _album = dirAlbum.FullName;
            //    dictAlbum.Add(p.PieceId, _album);

            //    //if (!dictAlbum.ContainsKey(_album))
            //    //    dictAlbum.Add(_album, new List<Piece>());
            //    //dictAlbum[_album].Add(p);


            //}

            //foreach (List<Piece> l in dictArtist.Values)
            //{
            //    //
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //var listUnSortArtist = new List<Piece>(list);
            //listUnSortArtist.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));

            //var listUnSortAlbum = new List<Piece>();

            //List<Piece> aux = new List<Piece>();
            //int current = 0;

            //foreach (Piece p in listUnSortArtist)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {
            //        //aux.Add(p);
            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            string xa = x.Master.Album;
            //            string ya = y.Master.Album;
            //            if (dictAlbum.ContainsKey(x.PieceId))
            //                xa = dictAlbum[x.PieceId];
            //            else
            //            { }
            //            if (dictAlbum.ContainsKey(y.PieceId))
            //                ya = dictAlbum[y.PieceId];
            //            else
            //            { }
            //            var cmp = xa.CompareTo(ya);
            //            return cmp;
            //        });

            //        listUnSortAlbum.AddRange(aux);
            //        aux.Clear();

            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    string xa = x.Master.Album;
            //    string ya = y.Master.Album;
            //    if (dictAlbum.ContainsKey(x.PieceId))
            //        xa = dictAlbum[x.PieceId];
            //    else
            //    { }
            //    if (dictAlbum.ContainsKey(y.PieceId))
            //        ya = dictAlbum[y.PieceId];
            //    else
            //    { }
            //    var cmp = xa.CompareTo(ya);
            //    return cmp;
            //});

            //listUnSortAlbum.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnSortAlbum.Count; i++)
            //{
            //    listUnSortAlbum[i].TrackNumber = i + 1;
            //}

            //aux.Clear();
            //current = 0;
            //var listUnsortTrack = new List<Piece>();

            //foreach (Piece p in listUnSortAlbum)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {

            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            var xt = x.MasterTrackNumber;
            //            var yt = y.MasterTrackNumber;
            //            int cmp = 0;
            //            if (xt <= 0 || yt <= 0)
            //            {
            //                try
            //                {
            //                    cmp = x.Location.CompareTo(y.Location);
            //                }
            //                catch
            //                {
            //                }
            //            }
            //            cmp = xt.CompareTo(yt);
            //            return cmp;
            //        });

            //        listUnsortTrack.AddRange(aux);
            //        aux.Clear();
            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    var xt = x.MasterTrackNumber;
            //    var yt = y.MasterTrackNumber;
            //    int cmp = 0;
            //    if (xt <= 0 || yt <= 0)
            //    {
            //        try
            //        {
            //            cmp = x.Location.CompareTo(y.Location);
            //        }
            //        catch
            //        {
            //        }
            //    }
            //    cmp = xt.CompareTo(yt);
            //    return cmp;
            //});

            //listUnsortTrack.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnsortTrack.Count; i++)
            //{
            //    listUnsortTrack[i].TrackNumber = i + 1;
            //}




            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;
            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}
        }

        public bool isSameOf(Album o)
        {
            if (o == this)
                return false;
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && mode == o.mode;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }
        private DateTime albumAdded = DateTime.MaxValue;
        public DateTime AlbumAdded
        {
            get
            {
                if (albumAdded < DateTime.MaxValue)
                    return albumAdded;
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                albumAdded = min;
                return albumAdded;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, virtualMode mode)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();

                if (mode == virtualMode.word)
                {
                    __album = string.Format("¤¤[{0}]", __album);
                    return __album;
                }
                if (mode == virtualMode.list)
                {
                    __album = string.Format("/{0}", __album);
                    return __album;
                }

                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (mode == virtualMode.artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }
                else if (mode == virtualMode.year)
                {
                    if (_album.Length == 3)
                        __album = string.Format("£[{0}0']", __album);
                    else
                        __album = string.Format("£[{0}]", __album);
                }
                else if (mode == virtualMode.extended)
                {
                    __album = string.Format("¤[{0}]", __album);
                }
                else if (mode == virtualMode.added)
                {
                    __album = string.Format("<{0}>", __album);
                }

            }
            return __album;

        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using pdb.gen.auto;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        // private static PieceExtended index;
        //  public static int Index { get { return index; } }
        private static IPieceAlbum median;


        //public static DecimalIndex getMedianne(IList<Piece> list, bool main, decimal coeffMedianne)
        //{

        //    return new DecimalIndex() { d = getMedianne_(list, main, coeffMedianne), index = index };
        //}


        public static DecimalPiece getMedianne(IList<IPieceAlbum> list, bool main, decimal coeffMedianne)
        {
            PieceExtended.Mode = pieceExtendedMode.main;
            var ret = getMedianne_(list, coeffMedianne);
            return new DecimalPiece() { d = ret, index = median };
        }
        private List<IPieceAlbum> pieces;
        private ConfMedianne mode;
        private int _nbNoAdd;
        public AlbumMedianne(List<IPieceAlbum> pieces, ConfMedianne mode)
        {
            this.pieces = pieces;
            this.mode = mode;
            this._nbNoAdd = getNoAdd(mode.Main);
        }



        public void buildVirtual(bool combine, bool simple)
        {

            if (!mode.Min.Use)
            {
                buildVirtual0(mode.Main, true);
                align(mode.Main, pieceExtendedMode.main);
            }
            else
            {
                buildVirtual0(mode.Main, true);
                buildVirtual0(mode.Min, false);

                if (combine)
                {
                    foreach (IPieceAlbum p in pieces)
                        p.Combine();
                    align(mode.Main, pieceExtendedMode.combine);
                }

                if (!simple)
                {
                    align(mode.Main, pieceExtendedMode.main);
                    align(mode.Min, pieceExtendedMode.min);
                }
            }



            //if (!mode.Min.Use)
            //{
            //    buildVirtual0(mode.Main, true);
            //    align(mode.Main, PieceExtended.mode.main);
            //}
            //else if (combine && simple)
            //{
            //    buildVirtual0(mode.Main, true);
            //    buildVirtual0(mode.Min, false);
            //    foreach (PieceExtended p in pieces)
            //        p.Combine();
            //    align(mode.Main, PieceExtended.mode.combine);
            //}
            //else
            //{
            //    buildVirtual0(mode.Main, true);
            //    buildVirtual0(mode.Min, false);
            //    align(mode.Main, PieceExtended.mode.main);
            //    align(mode.Min, PieceExtended.mode.min);

            //    if (combine)
            //    {
            //        foreach (PieceExtended p in pieces)
            //            p.Combine();
            //        align(mode.Main, PieceExtended.mode.combine);
            //    }
            //}
        }

        private int getNoAdd(ConfMedianneVirt modeVirt)
        {

            var safe = modeVirt.safe;
            var _nbNoAdd = 0;

            int i0 = 0;
            int count = pieces.Count;
            if ((modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll) || modeVirt.noAddAll)
                return pieces.Count;
            else if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
            {
                _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
                if (modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll)
                    return _nbNoAdd;
                if (_nbNoAdd > 0)
                    _nbNoAdd--;
            }
            else
            {
                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.Empty)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }
            }

            //if (modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll)
            //    return _nbNoAdd;

            if (modeVirt.noAddEnd)
            {
                // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                // morceaux déjà notés
                var nb2 = pieces.Count<IPieceAlbum>(p => !p.Enabled && !p.Empty);
                _nbNoAdd = _nbNoAdd - nb2;
                if (_nbNoAdd < 0)
                    _nbNoAdd = 0;
            }
            _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

            return _nbNoAdd;
        }

        public void align(ConfMedianneVirt modeVirt, pieceExtendedMode main)
        {
            var count = pieces.Count;
            if (count < 2)
                return;
            PieceExtended.Mode = main;
          //  pieces.Sort(new PieceCmp0());

            decimal prec = pieces[count - 1].Value;

            var coeffEnabled = modeVirt.CoeffOld;


            for (int j = count - 2; j >= 0; j--)
            {
                var cand = pieces[j].Value;
                bool change = false;
                if (cand == 0)
                    continue;
                if (modeVirt.virtAlignPrec)
                {
                    if (cand < prec)
                    {
                        cand = prec + EPSILON;
                        change = true;
                    }
                }

                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                {

                    // quel serait le score s'il était coché
                    var vu = pieces[j].Value / coeffEnabled;
                    // en plus une petite marge
                    //  vu *= mode.coeffVirt; 
                    if (cand < vu)
                    {
                        cand = vu;
                        change = true;
                    }
                }
                if (change)
                    pieces[j].Value = cand;

                prec = cand;
            }

        }

        //public void align0(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        //{
        //    var count = pieces.Count; 
        //    if (count < 2)
        //        return;
        //    pieces.Sort(new PieceCmp0()); 
        //    //if (main== PieceExtended.mode.main)
        //    //    pieces.Sort(new PieceCmp());
        //    //else if (main == PieceExtended.mode.min)
        //    //    pieces.Sort(new PieceCmp2());
        //    //else
        //    //    pieces.Sort(new PieceCmp3());
        //    decimal prec = 0m;

        //    var coeffEnabled = modeVirt.CoeffOld;

        //    if (modeVirt.virtAlignPrec)
        //    {
        //        //if (_nbNoAdd < pieces.Count)
        //            prec = pieces[_nbNoAdd].Value;
        //    }

        //    for (int j = _nbNoAdd - 1; j >= 0; j--)
        //    {
        //        if (j < pieces.Count)
        //        {

        //            if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //            {
        //                var cand = pieces[j].Value;
        //                if (modeVirt.virtAlignPrec)
        //                {
        //                    if (cand < prec)
        //                        cand = prec + EPSILON;
        //                }

        //                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                {

        //                    // quel serait le score s'il était coché
        //                    var vu = pieces[j].Value / coeffEnabled;
        //                    // en plus une petite marge
        //                    //  vu *= mode.coeffVirt; 
        //                    if (cand < vu)
        //                        cand = vu;
        //                }
        //                pieces[j].Value = cand;

        //            }

        //            prec = pieces[j].Value;
        //        }
        //    }
        //}

        public void buildVirtual0(ConfMedianneVirt modeVirt, bool main)
        {
            DateTime limitDC = DateTime.Now.AddDays(-modeVirt.virtDelay);
            var coeffEnabled = modeVirt.CoeffOld;

            var _coeffVirt = modeVirt.coeffVirt;
            var safe = modeVirt.safe;
            int i0 = 0;

            int count = pieces.Count;
            PieceClassementComparer cmp = null;
            PieceExtended.Mode = main ? pieceExtendedMode.main : pieceExtendedMode.min;

            if (coeffEnabled > 1)
            {
                for (int i = 0; i < count; i++)
                {
                    var p = pieces[i];

                    if (p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
                        p.setCoeff(coeffEnabled, main);
                }
            }

            cmp = new PieceClassementComparer(false, main ? pieceExtendedMode.main : pieceExtendedMode.min);
            pieces.Sort(cmp);

            int indexV = 0;
            int nbAdd = 0;
            var _zero = mode.zero;
            i0 = count - 1;


            int _count = System.Math.Min(count, i0 + safe);
            decimal[] virt = null; // = new decimal[_count];
            //_nbNoAdd = System.Math.Min(safe, _nbNoAdd);
            var _coeffVirt0 = _coeffVirt;

            if (modeVirt.noAdd)
            {
                if (_coeffVirt > 1)
                {
                    if (modeVirt.coeffVirtAuto && (modeVirt.coeffVirtAutoAll || count < safe))
                    // if (count < safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;


                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < pieces.Count)
                        {

                            if (modeVirt.noVirtZero && pieces[j].Empty)
                                continue;

                            if (modeVirt.forceCoeffVirt)
                                _coeff *= _coeffVirt;
                            else if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
                                _coeff *= _coeffVirt;


                            if (pieces[j].Empty)
                                continue;
                            var dc = pieces[j].Piece.UpdateClassement;
                            if (dc == null || dc.Value < limitDC)
                            {
                                pieces[j].Coeff = _coeff; // Value = pieces[j].Value / _coeff;
                            }
                            //pieces[j].EffectMain = coeffEnabled < _coeff;

                        }
                    }
                }

            }
            else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = pieces[i].Value;
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= _coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
            }
            else
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    decimal courant = pieces[0].Value;
                    for (int i = 1; i < _count; i++)
                    {
                        if (pieces[i].Value <= _zero)
                        {
                            courant /= _coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = pieces[i].Value;
                    }
                }
            }

            decimal value = int.MaxValue;


            if (!modeVirt.noAdd)
            {
                int ii = 0;
                if (virt == null)
                    virt = new decimal[_count];
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = pieces[ii].Value;
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (modeVirt.lissage || value <= _zero)
                        {
                            if (value <= _zero)
                                nbAdd++;
                            value = calc;
                            pieces[ii].Value = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (modeVirt.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= safe)
                            continue;
                        pieces[i].Value = 0m;
                    }

                }
                if (mode.removeFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces[i].Value = 0m;
                    }
                }
            }



            if (mode.deleteFirst)
            {
                for (int i = 0; i < nbAdd; i++)
                {
                    pieces.RemoveAt(0);
                }
            }

        }

        //public static int buildVirtual(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, bool main, bool combine, ref int i0)
        //{
        //    var coeffEnabled = modeVirt.CoeffOld;

        //    var _coeffVirt = modeVirt.coeffVirt;
        //    var safe = modeVirt.safe;
        //    if (combine)
        //    {
        //        coeffEnabled = mode.Main.CoeffOld * mode.Min.CoeffOld;
        //        _coeffVirt = mode.Main.coeffVirt * mode.Min.coeffVirt;
        //        safe = (int)Math.Max(mode.Main.safe, mode.Min.safe);
        //    }


        //    //   var coeff = 1 / coeffEnabled; 
        //    int count = pieces.Count;
        //    PieceClassementComparer cmp = new PieceClassementComparer(false);
        //    pieces.Sort(cmp);
        //    //if (coeffEnabled != 1)
        //    //{
        //    if (coeffEnabled > 1)
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            var p = pieces[i];
        //            //  var rapportClassement = p.RapportClassement;
        //            if (coeffEnabled != 1m && p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
        //            {
        //                p.setCoeff(coeffEnabled, main);
        //                //rapportClassement /= coeffEnabled;
        //            }

        //            //p.setClassementVirtuel(rapportClassement);
        //            //if (!main)
        //            //    p.setClassementVirtuel2(rapportClassement);
        //        }
        //    }

        //    cmp = new PieceClassementComparer(false, main ? PieceExtended.mode.main : PieceExtended.mode.min);
        //    pieces.Sort(cmp);
        //    // }

        //    int indexV = 0;
        //    int nbAdd = 0;


        //    // List<Piece> _pieces = pieces;
        //    var _zero = mode.zero;


        //    //if (modeVirt.safe > 0)
        //    //{
        //    i0 = count - 1;
        //    int _nbNoAdd = 0;




        //    if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
        //    {
        //        _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
        //        if (_nbNoAdd > 0)
        //            _nbNoAdd--;
        //    }
        //    else if (modeVirt.noAddAll)
        //        _nbNoAdd = pieces.Count;
        //    else
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            var pp = pieces[i];
        //            if (pp.VirtualClassement == 0m)
        //            {
        //                i0 = i;
        //                _nbNoAdd = count - i0;
        //                break;
        //            }
        //        }
        //    }

        //    if (modeVirt.noAddEnd)
        //    {
        //        // var nb1 = pieces.Count<Piece>(p => p.Enabled);
        //        // morceaux déjà notés
        //        var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
        //        _nbNoAdd = _nbNoAdd - nb2;
        //        if (_nbNoAdd < 0)
        //            _nbNoAdd = 0;
        //    }
        //    //if (i0 == 0)
        //    //    return 0;
        //    //}

        //    //for (int i00 = 1; i00 <= i0; i00++)
        //    //{
        //    //    decimal coeff = (decimal)i00 / (decimal)i0;
        //    //List<decimal> _list = new List<decimal>();
        //    //for (int i = 0; i < pieces.Count; i++)
        //    //    _list.Add(pieces[i].getVirtual(main));
        //    //for (int i = i00; i < count; i++)
        //    //    _list[i] = 0m;
        //    //liste partielle originale
        //    //  List<decimal> _list0 = new List<decimal>(_list);
        //    int _count = System.Math.Min(count, i0 + safe);
        //    decimal[] virt = new decimal[_count];
        //    _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

        //    if (modeVirt.noAdd)
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            // var coeffEnabled = modeVirt.coeffOld; 

        //            if (count < safe && modeVirt.coeffVirtAuto)
        //            {
        //                if (modeVirt.coeffVirtAdjust)
        //                    _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
        //                else
        //                {
        //                    // ex 2^10 = 1024
        //                    // je veux obtenir 1024 avec 3
        //                    _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
        //                }
        //            }

        //            decimal _coeff = 1m;
        //            decimal prec = 0m;
        //            if (modeVirt.virtAlignPrec)
        //            {
        //                if (_nbNoAdd < pieces.Count)
        //                    prec = pieces[_nbNoAdd].Value;
        //            }

        //            for (int j = _nbNoAdd - 1; j >= 0; j--)
        //            {
        //                if (j < pieces.Count)
        //                {

        //                    if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //                    {
        //                        _coeff *= _coeffVirt;
        //                        var cand = pieces[j].Value / _coeff;
        //                        if (modeVirt.virtAlignPrec)
        //                        {
        //                            if (cand < prec)
        //                                cand = prec + EPSILON;
        //                        }

        //                        if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                        {
        //                            // quel serait le score s'il était coché
        //                            var vu = pieces[j].Value / coeffEnabled;
        //                            // en plus une petite marge
        //                            //  vu *= mode.coeffVirt; 
        //                            if (cand < vu)
        //                                cand = vu;
        //                        }
        //                        pieces[j].Value = cand;
        //                        // pieces[j].EffectMain = coeffEnabled < _coeff;
        //                    }
        //                    else if (modeVirt.forceCoeffVirt)
        //                        _coeff /= _coeffVirt;
        //                    prec = pieces[j].Value;
        //                }
        //            }
        //        }

        //    }
        //    else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            for (int i = 0; i < i0; i++)
        //            {
        //                decimal _coeff = 1m;
        //                decimal _base = pieces[i].Value;
        //                for (int j = i + 1; j < _count; j++)
        //                {
        //                    _coeff /= _coeffVirt;
        //                    virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
        //                }
        //            }
        //        }
        //    }
        //    else
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            decimal courant = pieces[0].Value;
        //            for (int i = 1; i < _count; i++)
        //            {
        //                if (pieces[i].Value <= _zero)
        //                {
        //                    courant /= _coeffVirt;
        //                    virt[i] = courant;
        //                }
        //                else
        //                    courant = pieces[i].Value;
        //            }
        //        }
        //    }

        //    decimal value = int.MaxValue;
        //    int ii = 0;
        //    if (modeVirt.noAdd)
        //    {
        //        //for (ii = 1; ii < count && ii < _count; ii++)
        //        //{
        //        //    var calc = virt[ii];
        //        //    if (calc > 0m)
        //        //        list[ii] = calc;
        //        //}
        //    }
        //    else
        //    {
        //        for (ii = 1; ii < count && ii < _count; ii++)
        //        {
        //            value = pieces[ii].Value;
        //            var calc = virt[ii];
        //            if (value < calc)
        //            {
        //                if (modeVirt.lissage || value <= _zero)
        //                {
        //                    if (value <= _zero)
        //                        nbAdd++;
        //                    value = calc;
        //                    pieces[ii].Value = value;
        //                }

        //            }
        //            else
        //                indexV = ii;
        //        }
        //        if (modeVirt.removeEpsilon)
        //        {
        //            // j'ai 5 virtuel alors que j'ai deux safe
        //            ///xx---
        //            int nb = 0;
        //            for (int i = indexV + 1; i < _count; i++)
        //            {
        //                nb++;
        //                if (nb <= safe)
        //                    continue;
        //                pieces[i].Value = 0m;
        //            }

        //        }
        //        if (mode.removeFirst)
        //        {
        //            for (int i = 0; i < nbAdd; i++)
        //            {
        //                pieces[i].Value = 0m;
        //            }
        //        }
        //    }

        //    //for (int i = 0; i < _list.Count && i < pieces.Count; i++)
        //    //{
        //    //    pieces[i].setValue(_list[i], main); 
        //    //    //if (main)
        //    //    //    pieces[i].setClassementVirtuel(_list[i]);
        //    //    //else
        //    //    //    pieces[i].setClassementVirtuel2(_list[i]);
        //    //}

        //    if (mode.deleteFirst)
        //    {
        //        for (int i = 0; i < nbAdd; i++)
        //        {
        //            pieces.RemoveAt(0);
        //        }
        //    }

        //    if (modeVirt.reSort || mode.removeFirst || modeVirt.noAdd)
        //    {
        //        //_list.Sort();
        //        //_list.Reverse();
        //        if (main)
        //            pieces.Sort(new PieceCmp());
        //        else
        //            pieces.Sort(new PieceCmp2());
        //    }



        //    if (modeVirt.noAdd)
        //        nbAdd = _nbNoAdd;
        //    //}
        //    return nbAdd;
        //}


        public DecimalPiece getMedianneLight(ConfMedianneVirt modeVirt, pieceExtendedMode main)
        {

            DecimalPiece ret0 = new DecimalPiece();
            DecimalPiece ret = ret0;
            try
            {
                var _zero = mode.zero;

                PieceExtended.Mode = main;
                //foreach (PieceExtended p in pieces)
                //    p.Mode = main;

                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = median;
                ret = ret0;


                int i0 = 0;
                int count = pieces.Count;


                ret = calcmedianneVirt(modeVirt);
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<IPieceAlbum>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }




            }
            finally
            {


            }

            return ret;
        }






        //public static DecimalIndex getMedianneLight(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, PieceExtended.mode main, bool combine)
        //{

        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {
        //        var _zero = mode.zero;


        //        foreach (PieceExtended p in pieces)
        //            p.Mode = main;

        //        var medianne = getMedianne_(pieces, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;
        //        ret = ret0;
        //        //if (pieces.Count == 1)
        //        //    return ret0;

        //        int i0 = 0;
        //        int count = pieces.Count;
        //        int nbAdd = buildVirtual(pieces, mode, modeVirt, main, combine, ref i0);
        //        //if (mode.combine && mode.simple)
        //        //{
        //        //    int i1 = 0;
        //        //    buildVirtual(pieces, mode, mode.Min, false, ref i1);
        //        //    foreach (var p in pieces)
        //        //    {
        //        //        p.setClassementVirtuelCombine();
        //        //    }
        //        //}
        //        ret = calcmedianneVirt(pieces, mode, modeVirt, main, nbAdd, System.Math.Min(i0, modeVirt.safe));
        //        if (mode.expEnabled != 0)
        //        {
        //            int _nb = pieces.Count<PieceExtended>(p => !p.Enabled);
        //            decimal _c = (decimal)_nb / (decimal)count;
        //            _c = Math.Pow(_c, mode.expEnabled);
        //            ret.d *= _c;
        //        }




        //    }
        //    finally
        //    {


        //    }

        //    return ret;
        //}

        private class PieceCmp0 : IComparer<IPieceAlbum>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(IPieceAlbum x, IPieceAlbum y)
            {
                int cmp = x.Classement.CompareTo(y.Classement); //   x.RapportClassement.CompareTo(y.RapportClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }


        //private class PieceCmp : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}

        //private class PieceCmp2 : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}

        //private class PieceCmp3 : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}




        //private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        //{
        //    var _list = new List<decimal>(list);
        //    int count = _list.Count;

        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        if (_list[count - i - 1] > conf.zero)
        //        {

        //            if (conf.removeLast == removeLast.non)
        //                break;
        //            _nbSupp++;
        //            if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                break;
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}


        private DecimalPiece calcmedianneVirt(ConfMedianneVirt confc)
        {
            int count = pieces.Count;
            var _list = new List<IPieceAlbum>();

            //1=> 1
            //2 =>3
            //3==>5
            int count1 = int.MaxValue;
            for (int i = 0; i < count && i < count1; i++)
            {
                var p = pieces[i];
                if (p.Classement.isZero() && count1 == int.MaxValue)
                {
                    var c = i;
                    count1 = 2 * i - 1;
                }

                _list.Add(p);
            }

            var classes = pieces.FindAll(p => !p.Empty);

            if (confc.oldAsZero)
                classes = pieces.FindAll(p => p.LastClassementRecent);



            int nbEnabled = classes.Count<IPieceAlbum>(p => p.Enabled);
            int nbDisabled = classes.Count<IPieceAlbum>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled);




            DecimalPiece ret = new DecimalPiece() { d = 0m, index = null }; // 0m; // decimal ret = int.MinValue;
            if (pieces.Count > 0)
                ret.index = pieces[0];
            int _nbSupp = 0;
            decimal coeffp = 1m;

            bool beginBorder = false;
            count1 = _list.Count;
            for (int i = 0; i < count1; i++)
            {
                int ilast = _list.Count - 1;
                var last = _list[ilast];
                if (i > 0)
                {
                    if (last.Empty)
                        _list.RemoveAt(ilast);
                    else
                        break;
                    ilast = _list.Count - 1;
                    if (ilast < 0)
                        break;
                    last = _list[ilast];
                    if (mode.puissance > 1m)
                    {
                        if (coeffp < 1e-15m)
                            coeffp = 1e-15m / (decimal)i;
                        else if (coeffp < 1e-12m)
                        {
                            coeffp = 1e-12m / ((decimal)i * i);
                            if (coeffp < 1e-15m)
                                coeffp = 1e-15m / (decimal)i;
                        }
                        else
                            coeffp /= mode.puissance;

                        if (coeffp < 1e-15m)
                            coeffp = 1e-15m / (decimal)i;
                        else if (coeffp < 1e-12m)
                        {
                            coeffp = 1e-12m / ((decimal)i * i);
                            if (coeffp < 1e-15m)
                                coeffp = 1e-15m / (decimal)i;
                        }

                        if (coeffp < 0)
                            coeffp = 0;
                    }
                }

                var aux = getMedianne_(_list, mode.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = last;
                }
                int offset = 0;
                if (count1 < count)
                    offset = count - count1;

                var coeff0 = 1 - ((decimal)i + offset) / (decimal)count; // (decimal)count - i / (decimal)count;
                if (mode.quasi > 1)
                    coeff0 = Math.Pow(coeff0, mode.quasi);

                decimal coeff = coeff0;
                if (coeff < coeffp)
                {
                }
                else
                {
                    coeff = coeffp;
                }





                if (coeff == 0m)
                    break;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = median;
                    ret.indexBorderEffect = last;
                }

                ret.indexBorderMin = last;
                var p = last;

                if (!p.Empty && (!confc.oldAsZero || p.LastClassementRecent))
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--;

                    if (!p.Enabled || !mode.removeEnabled || mode.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((mode.removeLast == removeLast.non || mode.removeLast == removeLast.unselected) && nbEnabled < 0)
                            break;

                        if (mode.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break;
                        }
                        _nbSupp++;
                    }
                }


            }


            return ret;
        }

        //private static DecimalIndex calcmedianneVirt(IList<PieceExtended> list, ConfMedianne conf, ConfMedianneVirt confc, bool main, int nbAdd, int nbDel)
        //{
        //    var _list = new List<PieceExtended>(list);
        //    var classes = _list.FindAll(p => p.VirtualClassement > conf.zero);

        //    if (confc.oldAsZero)
        //        classes = _list.FindAll(p => p.LastClassementRecent);

        //    int count = _list.Count;

        //    int nbEnabled = classes.Count<PieceExtended>(p => p.Enabled);
        //    int nbDisabled = classes.Count<PieceExtended>(p => !p.Enabled);
        //    int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    //int _nbSuppDisabled = 0;
        //    //int _nbSuppEnabled = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {
        //            //var d = _list[count - i];
        //            //if (d.Enabled)
        //            //    nbEnabled--;
        //            //else
        //            //    nbDisabled--;

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        ret.indexBorderMin = count - i - 1;
        //        var p = _list[count - i - 1];

        //        if (p.VirtualClassement > conf.zero && (!confc.oldAsZero || p.LastClassementRecent))
        //        {
        //            // je regarde si le morceau est désactivé
        //            // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
        //            if (p.Enabled)
        //                nbEnabled--;
        //            else
        //                nbDisabled--;
        //            nbdispo--;

        //            if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
        //            {
        //                //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
        //                //if (priseEncompte)
        //                //{
        //                if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected) && nbEnabled < 0)
        //                    break;

        //                if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
        //                {
        //                    if (nbdispo < 0)
        //                        break;
        //                }

        //                _nbSupp++;
        //                if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                    break;
        //                // }


        //            }
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}



        //private static decimal getMedianne_(IList<PieceExtended> list, bool main, decimal coeffMedianne)
        //{
        //    var l = new List<decimal>();
        //    foreach (PieceExtended p in list)
        //    {
        //        if (main)
        //            l.Add(p.VirtualClassement); 
        //        else
        //            l.Add(p.VirtualClassement2); 
        //    }

        //    return CalcMedianne.getMedianneDec(l, coeffMedianne); 
        //}

        //private static decimal getMedianne_(IList<Piece> list, bool main, decimal coeffMedianne)
        //{
        //    var l = new List<decimal>();
        //    foreach (Piece p in list)
        //    {
        //        if (main)
        //            l.Add(p.VirtualClassement);
        //        else
        //            l.Add(p.VirtualClassement2);
        //    }

        //    return CalcMedianne.getMedianneDec(l, coeffMedianne);
        //}


        private static decimal getMedianne_(IList<IPieceAlbum> list, decimal coeffMedianne)
        {

            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1 || coeffMedianne == 1)
            {
                median = list[0];
                return median.Value;
            }

            if (coeffMedianne == 1)
            {
                median = list[count - 1];
                return median.Value;
            }

            var medianne = coeffMedianne * (count - 1);

            var index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].Value;

            median = list[index];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
            {
                return val0;
            }
            median = list[i1];
            var val1 = list[i1].Value;
            return val1;

            //if (Math.Abs(medianne - i1) < PRECISION)
            //{
            //    median = list[i1];
            //    return val1;
            //}
            //if (val1 < PRECISION)
            //{
            //    median = list[i1];
            //    return val1;
            //}
            //var dx = medianne - index;


            //// var ret = val0 + pente * dx;


            //// moyenne avec calcul de log
            //var log0 = Math.Log(val0 + EPSILON_LOG);
            //var log1 = Math.Log(val1 + EPSILON_LOG);
            //// pente = log1 - log0;
            //var log = log0 + (log1 - log0) * dx;
            //return Math.Exp(log) - EPSILON_LOG;


        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\PieceExtendedSimple.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.obj;

namespace pdb.gen.albums
{
    class PieceExtendedSimple : IPieceAlbum
    {
        private Piece piece;
        private decimal coeff = 1m;
        private decimal value = -1;
        private Classement classement = null;
    
        public PieceExtendedSimple(Piece piece)
        {
            this.piece = piece;
        }
        public Classement Classement
        {
            get
            {             
                if (classement != null)
                    return classement;

                if (coeff == 1m)
                    classement = piece.getClassement(true);
                else if (coeff == 0)
                    classement = Classement.ZERO;
                else
                    classement = Classement.create(Value);
              
                return classement;
            }
        }

        public decimal Coeff
        {
            set
            {
                if (coeff != value)
                {
                    coeff = value;
                    this.value = -1;
                    this.classement = null;
                }

            }
        }

        public bool Empty
        {
            get
            {
                return Value ==0; 
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
        }

        public bool LastClassementRecent
        {
            get
            {
                return piece.LastClassementRecent;
            }
        }

        public Piece Piece
        {
            get
            {
                return piece;
            }
        }

        public bool UseCompact
        {
            get
            {
                return piece.UseCompact;
            }

            set
            {
                piece.UseCompact = value;
            }
        }

        public decimal Value
        {
            get
            {
                if (value >= 0)
                    return value;              
                else
                    value = piece.getClassement(true).RapportClassement / coeff;               
                return value;
            }

            set
            {
                if (value != this.value)
                {
                    this.value = value;
                    classement = null;                   
                }
            }
        }

        public void Combine()
        {

        }

        public bool getCauseUp(bool? natureCause)
        {           
            return coeff > 1;
        }

        public bool? getSimpleCause()
        {
            return null;
        }

        public void setCoeff(decimal coeff, bool main)
        {
            Coeff = coeff;
        }

        public override string ToString()
        {
            return string.Format("{0:0.#} {1} {2}", coeff, Classement, piece);
        }
    }
}
]]></content>
  </file>
</db>
