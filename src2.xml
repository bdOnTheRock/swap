<db path="C:\bernard\db1\db4">
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.obj;
using pdb.it;
using pdb.podcast.Albums;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        // standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub, ISelectable
    {
        public const string PUB_DATE_FORMAT_COMMENT = "yyyy/MM/dd HH:mm";
        public const string PUB_DATE_FORMAT_DB = "dd/MM/yyyy HH:mm";
        private static Loader loader;
        public new static Loader Loader { set { loader = value; } }

        public new TrackAlbum TrackAlbum { get { return base.TrackAlbum as TrackAlbum; } }

        public override string AlbumKey { get { var alb = TrackAlbum; if (alb == null) return base.AlbumKey; return alb.AlbumKey; } }

        public int AlbumRating { get { return TrackAlbum.AlbumRating; } }
        //  private bool ratingComputed; public bool RatingComputed { get { return ratingComputed; } }

      

        public DateTime getDate()
        {
            return TrackAlbum.ConfAlbum.checkPub ? Pub : Pub2;
        }

        private void import(IITFileOrCDTrack native)
        {
            misc.log("import {0}", this);
            native.Name = name;

            native.AlbumRating = AlbumRating;
            if (rating != AlbumRating)
                native.Rating = rating;
            native.PlayedDate = this.PlayedDate.ToUniversalTime();
            native.Enabled = this.enabled;
            native.PlayedCount = this.playCount;
            var _comment = buildComment();
            if (!string.IsNullOrEmpty(_comment))
                native.Grouping = _comment;
            var _composer = buildComposer();
            if (!string.IsNullOrEmpty(_composer))
                native.Composer = _composer;

        }

        public string buildComment()
        {
            string comment = pub.ToString(PUB_DATE_FORMAT_COMMENT);
            if (pub2 > pub)
                comment = string.Format("{0}|{1}| {2}",
                    pub2.ToString(PUB_DATE_FORMAT_COMMENT),
                    pub.ToString(PUB_DATE_FORMAT_COMMENT),
                    (pub2 - pub).TotalDays.ToString("#00.#"));
            return comment;
        }

        public string buildComposer()
        {
            string comment = pub.ToString(PUB_DATE_FORMAT_COMMENT);
            //if (pub2 > pub)
            //    comment = string.Format("{0}|{1}", Pub2.ToString(PUB_DATE_FORMAT_COMMENT), Pub.ToString(PUB_DATE_FORMAT_COMMENT));
            return comment;
        }

        public void BuildComment()
        {
            var comment = buildComment();
            if (!string.IsNullOrEmpty(comment) && comment != Grouping)
            {
                //if (!string.IsNullOrEmpty(Grouping))
                //    File.AppendAllText("..\\groupingIni.txt", string.Format("{0};{1};{2}\r\n",DbId,Location,Grouping));
                Grouping = comment;
            }
               
        }

        public void BuildComposer()
        {
            var composer = buildComposer();
            //  Composer = composer;
            if (!string.IsNullOrEmpty(composer) && composer != Composer)
                Composer = composer;
        }

        public void import()
        {
            if (!isPresent())
                return;

            try
            {
                var native = TrackTrack;
                if (native == null)
                    native = Track;
                if (native == null)
                {
                    bgImport.add(new BgTaskImport(this));
                }
                else
                    import(native);

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public void merge()
        {
            if (!isPresent())
                return;
            bgImport.add(new BgTaskImport(this));
        }

        public void import(TrackInfoItunes db)
        {
            this._album = db._album;
            // this.albumRating = db.albumRating;
            this.rating = db.rating;
            //this.rare = db.rare;
            //this.info = db.info;
            this.playCount = db.playCount;
            this.PlayedDate = db.PlayedDate;
            this.enabled = db.enabled;
            present = true;
            db.present = true;

            import();
        }

        private DateTime offset;
        public DateTime Offset
        {
            set
            {
                if (offset == DateTime.MinValue)
                    offset = value;
            }
            get { return offset; }
        }

        public override IITFileOrCDTrack Track
        {
            get
            {
                if (track != null)
                    return track;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    // loader.resurrection(this);
                }
                return base.Track;
            }
        }

        public override IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (tracktrack != null)
                    return tracktrack;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    //   loader.resurrection(this);
                }
                return base.TrackTrack;
            }
        }

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        //private static bool _updateNative;
        //public static bool UpdateNative { get { return _updateNative; } set { _updateNative = value; } }
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                    defaultFolder += "Podcasts\\";
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;

        public int DbId { get { return _dbId; } set { if (_dbId <= 0) _dbId = value; } }

        //private static int NB = 0;
        //private int iddebug;

        public TrackInfoItunes()
        {
            //NB++;
            //iddebug = NB;
        }

        public bool Deleted { get; set; }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        //  private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        // private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        //private LimitItem exclu;
        //public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            //var key = item.ID;
            //if (!listLoad0.ContainsKey(key))
            //    listLoad0.Add(key, item);
        }
        //public bool containsload(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listLoad0.ContainsKey(key);
        //}

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        //public bool containsSelect(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listSelected.ContainsKey(key);
        //}
        //public bool isPreselected { get { return listLoad0.Count > 0; } }
        //public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {

                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        public void synch(TrackInfoItunes o)
        {
            _in = o._in;
            _out = o._out;
            pub = o.pub; 
            Pub2 = o.pub2;
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            TrackAlbum.AlbumRating = track.AlbumRating;
            // this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            CheckPlay(this);

            //if (track.PlayedCount > 0)
            //{
            //    played = markAsPlayed(Rating, PlayedDate);
            //}

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                Pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Grouping != commentByReleaseDate)
                    {
                        misc.log("chgt Comment à partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Grouping = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Grouping;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Grouping)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment à partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Grouping = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de gérer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }

        private static DateTime playedLevel = DateTime.MinValue;
        public static DateTime PlayedLevel { set { playedLevel = value; } }
        //public static bool markAsPlayed(int rating, DateTime date)
        //{
        //    if (maxPlayed.ContainsKey(rating))
        //        return date > maxPlayed[rating];
        //    return true;
        //}


        public static void CheckPlay(TrackInfoItunes track)
        {
            track.played = isPlayed(track);
        }


        private static bool isPlayed(TrackInfoItunes track)
        {
            var playDate = track.PlayedDate;
            if (track.playCount <= 0)
            {
                if (playDate == DateTime.MinValue)
                    return false;
                if (playedLevel == DateTime.MinValue || playDate >= playedLevel)
                    return false;
                // pour les vieux on prend quand même en compte la date de dernière lecture
                return true;
            }

            int rating = track.Rating;
            if (maxPlayed.ContainsKey(rating))
            {
                if (playDate > maxPlayed[rating])
                    return true;
                else
                    return false;
            }
            return true;

        }


        public string ShortName { get { return getShortName(location); } }
        public static string getShortName(string location) { return misc.getShortPath(location, Exporter.PODCASTS, Exporter.ZIQUE, "Y:"); }

        private string hibernateLocation;
        public string HibernateLocation { get { return hibernateLocation; } set { hibernateLocation = value; } }


        public bool isPresent()
        {
            if (!string.IsNullOrEmpty(hibernateLocation))
                return FileRegister.Exist(hibernateLocation);
            return FileRegister.Exist(location);

            //var path = location;
            //if (_extern)
            //{
            //    var shortName = ShortName;
            //    path = TrackInfoItunes.DefaultFolder + shortName;
            //}
            //if (FileRegister.Exist(location))
            //{
            //    location = path;
            //    return true;
            //}
            //return false;
        }

        public void build(XmlReader reader)
        {

            location = reader.GetAttribute("f");
            if (Path.IsPathRooted(location))
            {
            }
            else
                location = TrackInfoItunes.DefaultFolder + location;

            FileRegister.Push(location);
            hibernateLocation = reader.GetAttribute("hl");

            string album = reader.GetAttribute("alb");
            if (album != null)
                albumMgr.setAlbum(this, album);
            name = reader.GetAttribute("name");

            var str = reader.GetAttribute("pub");
            if (!string.IsNullOrEmpty(str))
                Pub = Convert.ToDateTime(str);

            str = reader.GetAttribute("pub2");
            if (!string.IsNullOrEmpty(str))
                Pub2 = Convert.ToDateTime(str);
            else
                Pub2 = Pub;

            str = reader.GetAttribute("date");
            if (!string.IsNullOrEmpty(str))
            {
                // playCount = 1;
                PlayedDate = Convert.ToDateTime(str);
            }

            str = reader.GetAttribute("nbr");
            if (!string.IsNullOrEmpty(str))
            {
                playCount = Convert.ToInt16(str);
            }

            str = reader.GetAttribute("albumRating");
            if (!string.IsNullOrEmpty(str))
                TrackAlbum.AlbumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                rating = Convert.ToInt32(str);

            if (TrackAlbum.AlbumRating > 0 && rating == 0)
                rating = TrackAlbum.AlbumRating;

            str = reader.GetAttribute("id");
            _dbId = Convert.ToInt32(str);

            //if ("y" == reader.GetAttribute("rare"))
            //    TrackAlbum.Rare = true;
            //if ("y" == reader.GetAttribute("info"))
            //    TrackAlbum.Info = true;
            if ("y" == reader.GetAttribute("disabled"))
                enabled = false;
            else
                enabled = true;
            str = reader.GetAttribute("s");
            if (!string.IsNullOrEmpty(str))
                _size = Convert.ToInt64(str);
            else
                _size = -1;

            str = reader.GetAttribute("d");
            if (!string.IsNullOrEmpty(str))
                Duree = timeSpan.FromSecondes(Convert.ToInt32(str));



            str = reader.GetAttribute("add");
            if (!string.IsNullOrEmpty(str))
                added = Convert.ToDateTime(str);
            str = reader.GetAttribute("add1");
            if (!string.IsNullOrEmpty(str))
                AddedFirst = Convert.ToDateTime(str);

            if (addedFirst == DateTime.MinValue)
                addedFirst = added;

            Description = reader.GetAttribute("desc");
            LongDescription = reader.GetAttribute("ldesc");
            Comment = reader.GetAttribute("comment"); 




            CheckPlay(this);

        }

        public void readStat(XmlReader reader)
        {
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                _in = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                _out = Convert.ToDateTime(str);
        }

        public bool SelectedByDb { get { return Selected; } }// || _in > _out; } }

        public void readStatGlobal(XmlReader reader)
        {
            DateTime oin = DateTime.MinValue;
            DateTime oout = DateTime.MinValue;
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                oin = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                oout = Convert.ToDateTime(str);

            if (oin > oout)
            {
                //sélectionné
                _gout = DateTime.MaxValue;
                return;
            }

            if (oout > _gout)
                _gout = oout;
        }

        //public void consolidStat()
        //{
        //    if (_in > DateTime.MinValue)
        //    {
        //        if (_in < _gin || _gin == DateTime.MinValue)
        //            _gin = _in; 
        //    }

        //    if (_out > _gout)
        //        _gout = _out; 
        //}



        public override void build(XmlNode xTrack)
        {
            TrackInfoItunes copy = null;
            if (loader.Import || loader.Slave)
            {
                copy = createCopy(this);
            }

            base.build(xTrack);

            TrackAlbum.AlbumRating = 0;

            //  bool ratingComputed = false;
            bool albumRatingComputed = false;
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    //if (key == "Rating Computed")
                    //    ratingComputed = true;
                    if (key == "Album Rating Computed")
                        albumRatingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); AddedFirst = added; break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break; //DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Album Rating": TrackAlbum.AlbumRating = Convert.ToInt32(value); break;
                }

            }
            // gestion des rating
            if (albumRatingComputed)
                TrackAlbum.AlbumRating = 0;

            duree = new util.timeSpan(Duration);


            bool change = false;
            if (copy != null)
            {
                if (copy._album != null)
                    _album = copy._album;
                if (!string.IsNullOrEmpty(copy.name) && copy.name != name)
                {
                    log.log("import cause name '{0}' '{1}' {2}", name, copy.name, this);
                    name = copy.name;
                    change = true;
                }

                if (PlayedDate != copy.PlayedDate)
                {
                    log.log("import cause playDate '{0}' '{1}' {2}", PlayedDate, copy.PlayedDate, this);
                    PlayedDate = copy.PlayedDate;
                    change = true;
                }
                if (playCount != copy.playCount)
                {
                    log.log("import cause playCount '{0}' '{1}' {2}", playCount, copy.playCount, this);
                    change = true;
                    playCount = copy.playCount;
                }
                // albumRating = copy.albumRating;
                if (enabled != copy.enabled)
                {
                    log.log("import cause enabled '{0}' '{1}' {2}", enabled, copy.enabled, this);
                    enabled = copy.enabled;
                    change = true;
                }

                if (rating != copy.rating)
                {
                    log.log("import cause rating '{0}' '{1}' {2}", rating, copy.rating, this);
                    rating = copy.rating;
                    change = true;
                }
                if (pub2 != copy.pub2)
                {
                    log.log("import cause pub2 '{0}' '{1}' {2}", pub2, copy.pub2, this);
                    pub2 = copy.pub2;
                    change = true;
                }


                var comment = buildComment();
                if (!string.IsNullOrEmpty(comment) && comment != Grouping)
                {
                    log.log("import cause comment '{0}' '{1}' {2}", Grouping, comment, this);
                    change = true;
                }


                //var composer = buildComposer();
                //if (!string.IsNullOrEmpty(composer) && composer != Composer)
                //{
                //    log.log("import cause composer '{0}' '{1}' {2}", Composer, composer, this);
                //    change = true;
                //}

                //var _comment = buildComment();
                //if (_comment != Comment)
                //    change = true;

                Duration = copy.Duration;
                duree = copy.duree;


            }
            PubLoader.setPub();

            CheckPlay(this);

            if (change)
            {
                import();
            }
        }



        //private PubLoader pubLoader;
        //internal PubLoader PubLoader { get { if (pubLoader == null) pubLoader = new PubLoader(this); return pubLoader; } }
        internal PubLoader PubLoader { get { return new PubLoader(this); } }

        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        private DateTime pub2;
        public DateTime Pub
        {
            get
            {
                return pub;
            }
            private set
            {
                pub = value;
                if (pub2 < pub)
                    pub2 = pub;
            }
        }

        public DateTime Pub2
        {
            get { return pub2; }
            set
            {
                if (value > pub)
                    pub2 = value;
                else
                    pub2 = pub;

            }
        }


        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        new public DateTime Added { get { return added; } }

        /// <summary>
        /// Date de premier ajout; 
        /// </summary>
        private DateTime addedFirst;
        public DateTime AddedFirst
        {
            get { return addedFirst; }

            set
            {
                if (addedFirst == DateTime.MinValue)
                    addedFirst = value;
            }
        }

        private DateTime _in;
        public DateTime In { get { return _in; } }

        private DateTime _out;
        public DateTime Out { get { return _out; } }

        //private DateTime _gin;
        //public DateTime Gin { get { return _gin; } }

        /// <summary>
        /// Dernier out global (MaxValue si encore sélectionné)
        /// </summary>
        private DateTime _gout;
        public DateTime Gout { get { return _gout; } set { _gout = value; } }

        public void checkInOut()
        {
            DateTime now = DateTime.Now;
            if (Selected)
            {
                if (_in == DateTime.MinValue || _out > _in)
                    _in = now;
            }
            else
            {
                if (_in > DateTime.MinValue)
                {
                    if (_out == DateTime.MinValue || _in > _out)
                        _out = now;
                }
            }
        }


        public albumSpec Specif { get { return TrackAlbum.Specif; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        // private bool info;

        public bool Info
        {
            get { return TrackAlbum.Info; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        //  private bool rare;
        public bool Rare
        {
            get { return TrackAlbum.Rare; }
        }
        public bool RareEffect
        {
            get { return TrackAlbum.RareEffect; }
        }

        public bool Actu
        {
            get { return TrackAlbum.Actu; }
        }

        public bool Courant
        {
            get { return TrackAlbum.Courant; }
        }

        public bool Open { get { return TrackAlbum.Open; } }
        public bool Recent { get { return TrackAlbum.Recent; } }
        public bool UnAn { get { return TrackAlbum.UnAn; } }

        private bool played;
        public bool Played { get { return played; } }

        //private bool globalSelected;
        //public bool GlobalSelected { get { return globalSelected; } set { globalSelected = value; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        // private bool inJournal = false;

        //public bool FreeInJournal { get { return Selected && !inJournal; } }
        //public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        public void clearLists()
        {
            selected = selectMode.none;
            //  exclu = null;
            //  inJournal = false;
            listSelected.Clear();// = new SequentialDictString<LimitItem>();
            //listLoad0 = new SequentialDictString<LimitItem>();
            //listStandAlone = new SequentialDictString<LimitItem>();
            //indexRoot = -1;
            offset = default(DateTime);
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }
        private string pubInfoShort() { return pub.ToString("dd.MM.yy"); }
        private string getDayOfWeek()
        {
            var strDayOfWeek = "";
            switch (pub.DayOfWeek)
            {
                case DayOfWeek.Friday:
                    strDayOfWeek = "v";
                    break;
                case DayOfWeek.Monday:
                    strDayOfWeek = "l";
                    break;
                case DayOfWeek.Saturday:
                    strDayOfWeek = "s";
                    break;
                case DayOfWeek.Sunday:
                    strDayOfWeek = "d";
                    break;
                case DayOfWeek.Thursday:
                    strDayOfWeek = "j";
                    break;
                case DayOfWeek.Tuesday:
                    strDayOfWeek = "ma";
                    break;
                case DayOfWeek.Wednesday:
                    strDayOfWeek = "me";
                    break;
                default:
                    break;
            }

            return strDayOfWeek;
        }

        // private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void updateNative()
        {
            PubLoader.setPub();


            int volume = Volume;
            if (Album.Contains("RFI"))
            {
                if (volume != -20)
                    Volume = -20;
            }
            else
            {
                if (volume < volumeMin)
                    Volume = volumeMin;
            }


            if (pub > MIN)
            {

                var target = NameWithDate;
                if (!target.Equals(Name))
                    Name = target;
                BuildComment();
                BuildComposer();
                return;

                string infoShort = pubInfoShort();
                string infoPubName = pub.ToString("dd.MM.yyyy");
                string infoPubName2 = pub.ToString("dd/MM/yyyy");
                string infoPubName3 = pub.ToString("dd/MM/yy");
                string infoYear = Year.ToString();
                if (pub.DayOfYear == 1)
                {
                    infoPubName = pub.Year.ToString();
                    infoPubName2 = infoPubName;
                    infoPubName3 = infoPubName;
                    infoShort = infoPubName;
                }

                string name = Name;
                string str = name;

                while (str.Contains("  "))
                    str = str.Replace("  ", " ");

                while (str.Contains(infoShort))
                    str = str.Replace(infoShort, "");
                while (str.Contains(infoPubName))
                    str = str.Replace(infoPubName, "");
                while (str.Contains(infoPubName2))
                    str = str.Replace(infoPubName2, "");
                while (str.Contains(infoPubName3))
                    str = str.Replace(infoPubName3, "");

                str = str.Trim();

                //if (regInfoShort.IsMatch(str))
                //{
                //    var strdate = regInfoShort.Match(str).Groups[1].Value;
                //    str = str.Replace(strdate, "");
                //}



                //Michel Rocard (1/5) l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 17.06.13 l
                var strDayOfWeek = getDayOfWeek();
                var s1 = strDayOfWeek + " ";
                strDayOfWeek = " " + strDayOfWeek;

                while (str.EndsWith(strDayOfWeek))
                    str = str.Remove(str.Length - strDayOfWeek.Length - 1);
                //while (str.EndsWith(s1))
                //    str = str.Remove(str.Length - s1.Length);

                //if (str.Contains(infoPubName))
                //    str = str.Replace(infoPubName, infoShort);
                //else if (name.Contains(infoPubName2))
                //    str = str.Replace(infoPubName2, infoShort);

                //else
                //{
                //    if (!str.Contains(infoShort))
                //    {
                //        str = str + " " + infoShort;
                //    }
                //    else
                //    {
                //        if (Year > 1980 && str.Contains(infoYear))
                //            str = str.Replace(infoYear, "").Trim();
                //    }
                //}
                var strBUG = "30.12.99";
                if (str.Contains(strBUG))
                    str = str.Replace(strBUG, "");

                while (str.Contains("  "))
                    str = str.Replace("  ", " ");

                str = str.Trim();

                str += " ";
                str += infoShort;


                str += strDayOfWeek;

                if (!str.Equals(name))
                    Name = str;

                BuildComment();
                BuildComposer();
            }
        }
        // private LimitItem provider; 
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (!listSelected.ContainsKey(key))
                listSelected.Add(key, limit);



            if (selected == value)
                return;

            selected = value;
            //if (isPresent() && !present)
            //{
            //    // loader.resurrection(this);
            //}




        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                this.Pub = value;
            }
        }
        //DateTime IPub.Pub2
        //{
        //    get
        //    {
        //        return pub2;
        //    }
        //    set
        //    {
        //        pub2 = value;
        //    }
        //}

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            //set
            //{
            //    if (string.IsNullOrEmpty(this.Grouping))
            //        setGrouping(this.Comment, true);
            //    Comment = value;
            //}
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        DateTime IPub.Offset { get { return offset; } }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree
        {
            get
            {

                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
                return duree;
            }
            private set
            {
                duree = value;
                if (base.Duration.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
            }
        }


        public string getLogicalName(string t)
        {

            var strBUG = "30.12.99";
            if (t.Contains(strBUG))
                t = t.Replace(strBUG, "").Trim();
            var sw = getDayOfWeek();
            if (t.EndsWith(sw))
                t = t.Remove(t.Length - sw.Length).Trim();
            var strPub = pub.ToString("dd.MM.yyyy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pub.ToString("dd/MM/yyyy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pub.ToString("dd/MM/yy");
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            strPub = pubInfoShort();
            if (t.EndsWith(strPub))
                t = t.Remove(t.Length - strPub.Length).Trim();
            if (t.EndsWith("-"))
                t = t.Remove(t.Length - 1).Trim();

            while (t.Contains("  "))
                t = t.Replace("  ", " ");



            return t;
        }

        public string NameWithDate
        {
            get { return string.Format("{0} {1} {2}", LogicalName, pubInfoShort(), getDayOfWeek()); }
        }

        public string LogicalName
        {
            get
            {
                return getLogicalName(name);
            }
        }

        //public override string Name
        //{
        //    get
        //    {
        //        return name;
        //    }
        //    set
        //    {
        //        if (value == null)
        //        {
        //            log.log("set Name null !!! {0}", this);
        //            return;
        //        }

        //        var thisLog = LogicalName;
        //        var newLog = getLogicalName(value);

        //        if (!thisLog.Equals(newLog, StringComparison.InvariantCultureIgnoreCase))
        //        {
        //            log.log("Modification du nom logique !!! {0}->{1} {2}", thisLog, newLog, this);
        //            return;
        //        }
        //        base.Name = value;
        //    }
        //}



        public override TimeSpan Duration
        {
            get
            {
                var dur = base.Duration;
                if (dur.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
                return base.Duration;
            }

            set
            {
                base.Duration = value;
                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
            }
        }

        private long _size = -1;
        public long Size
        {
            get
            {
                if (_size < 0)
                {
                    var f = FileRegister.Check(Location);
                    if (f.Exists)
                        _size = f.Length;
                    else
                        _size = 0;
                }
                return _size;
            }
        }

        //private int indexRoot = -1;
        //public int IndexRoot { get { return indexRoot; } set { indexRoot = value; } }



        public static void setDate0(DateTime date) { Date0 = date; }
        private static DateTime Date0;
        private timeSpan ts;
        public timeSpan Ts
        {
            get
            {
                if (ts == default(timeSpan))
                {
                    if (Date0 == DateTime.MinValue)
                        throw new ApplicationException("Date0 pas initialisée");
                    ts = new timeSpan(Pub2 - Date0);
                }
                return ts;
            }
        }

        public void hibernate(FileValue fv, string dirH)
        {
            bgHibernate.add(new BgTaskHibernate(this, fv, dirH));
        }

        /// <summary>
        /// pour minimiser les listes de selection on checke la durée. en effet à l'utilisation on mélange de toute façon avec les longs
        /// </summary>
        public bool isConcernedBySelection
        {
            get
            {
                //if (!enabled)
                //    return false;
                //if (played)
                //    return false;
                var globalDuree = TrackAlbum.ConfAlbum.maxGlobal;
                if (globalDuree > 0)
                {
                    if (Duree.TotalMinute > globalDuree)
                        return false;
                }
                return true;
            }
        }

        public bool isLong
        {
            get
            {
                var globalDuree = TrackAlbum.ConfAlbum.maxGlobal;
                if (globalDuree > 0)
                {
                    if (Duree.TotalMinute > globalDuree)
                        return true;
                }
                return false;
            }
        }

        protected class BgTaskHibernate : BgTaskDeleteTrackTrack
        {
            private TrackInfoItunes track;
            private FileValue fv;
            string dirH;
            public BgTaskHibernate(TrackInfoItunes track, FileValue fv, string dirH)
                : base(track, string.Format("Hibernate {0}", track))
            {
                this.track = track;
                this.fv = fv;
                this.dirH = dirH;
            }

            public override void exec()
            {
                base.exec();
                if (!success)
                    return;

                if (!string.IsNullOrEmpty(dirH))
                {
                    var dest = misc.copyTree(fv, dirH + track.ShortName, false);
                    track.HibernateLocation = dest;

                    try
                    {
                        File.Delete(track.Location);
                        fv.delete();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }
                }
            }
        }


        private class BgTaskImport : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskImport(TrackInfoItunes info)
                : base(string.Format("import {0}", info.Location))
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    info.import(_track);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



    }
}



]]></content>
  </file>
   <file path="\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using pdb.podcast.Tuning;
using pdb.podcast.Albums;


namespace pdb.podcast.DB
{
    public class Db
    {
        public const string CURRENT_VERSION = "2.0";
        const string SEQ_PIECE = "seq";
        const string TOKEN_VERSION = "version";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        private BgDict<int, TrackInfoItunes> dictId = new BgDict<int, TrackInfoItunes>();
        private volatile object _lock = new object();






        string FILE = "..\\db.xml";
        string FILE_STAT = "..\\db_stats.xml";
        string HUMAN_FILE = "..\\dbh.xml";
        private List<string> sources = new List<string>();
        string SOV = "..\\sov\\";
        string zipSov;
        //   private XmlSerializer xmlSerializer;

        // private bool import;
        private bool loaded;
        private bool writing;
        public bool Writing { get { return writing; } }

        public Db()
        {
            var conf = Conf.Db;
            FILE = conf.file;
            FILE_STAT = conf.fileStat;
            SOV = conf.sov;
            zipSov = conf.sovZip.Replace("[date]", DateTime.Now.Date.ToString("yy-MM-dd")); 
            foreach (DbSource source in conf.sources)
            {
                sources.Add(source.file);
            }

            // this.import = import;
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};


        }

        public List<TrackInfoItunes> Tracks
        {
            get
            {
                if (!loaded)
                {
                    lock (_lock)
                    {

                    }
                }

                return new List<TrackInfoItunes>(dict.Values);
            }
        }

        public TrackInfoItunes get(string location)
        {
            if (!loaded)
            {
                lock (_lock)
                {

                }
            }
            return dict[location];
        }

        public TrackInfoItunes get(TrackInfoItunes w)
        {
            return dictId[w.DbId];
        }

        public void Check(TrackInfoItunes track)
        {


            var location = track.ShortName;
            if (string.IsNullOrEmpty(location))
                return;
            var dbTrack = dict[location];
            if (dbTrack == null)
            {
                int id = ++pieceSequenceId;
                track.DbId = id;
                

            }
            else
            {
                track.DbId = dbTrack.DbId;
                //if (import)
                //{
                //    track.import(dbTrack);
                //}
            }
            if (track.Pub2 < track.Pub)
            {
                var pub2 = track.Pub2.truncateToMinute();
                var pub = track.Pub.truncateToMinute();
                if (pub2 < pub)
                    track.Pub2 = pub; 
            }
               
            track.Present = true;
            dict[location] = track;
            dictId[track.DbId] = track;
        }

        public void Import(IEnumerable<TrackInfoItunes> listIt)
        {
            foreach (TrackInfoItunes it in listIt)
            {
                var location = it.ShortName;
                var tdb = dict[location];
                if (tdb == null)
                    continue;

                it.import(tdb);
            }
        }

        public void createIfExist(pdb.it.ITrackBuilder loader, List<TrackInfoItunes> listIt)
        {
            foreach (TrackInfoItunes tdb in dict.Values)
            {
                if (tdb.isPresent())
                {
                    loader.createTrack(tdb, true);
                    tdb.import();
                }
            }
        }



        public void load()
        {
            lock (_lock)
            {
                try
                {
                    var strVersion = "1";
                    TrackAlbum currentAlbum = null;
                    using (XmlReader reader = XmlReader.Create(FILE))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {
                                    var seq = reader.GetAttribute(SEQ_PIECE);
                                    pieceSequenceId = Convert.ToInt32(seq);
                                    strVersion = reader.GetAttribute(TOKEN_VERSION);
                                }
                                else if (reader.Name == "a")
                                {
                                    currentAlbum = readAlbum(reader);
                                }
                                else if (reader.Name == "t")
                                {
                                    var t = read(reader, currentAlbum);
                                    dict[t.ShortName] = t;
                                    dictId[t.DbId] = t;
                                }
                            }
                        }

                    }

                    using (XmlReader reader = XmlReader.Create(FILE_STAT))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {

                                }
                                else
                                {
                                    int id = Convert.ToInt32(reader.GetAttribute("id"));


                                    var t = dictId[id];
                                    if (t == null)
                                    {
                                        string loc = reader.GetAttribute("f");
                                        Program.log.log("track {0} dans les stats non vu dans db {1}", id, loc);
                                    }
                                    else
                                    {
                                        t.readStat(reader);
                                        t.readStatGlobal(reader);
                                    }
                                }
                            }
                        }

                    }


                    foreach (string source in sources)
                    {
                        try
                        {
                            using (XmlReader reader = XmlReader.Create(source))
                            {
                                while (reader.Read())
                                {
                                    if (reader.NodeType == XmlNodeType.Element)
                                    {
                                        if (reader.Name == "db")
                                        {

                                        }
                                        else
                                        {
                                            int id = Convert.ToInt32(reader.GetAttribute("id"));


                                            var t = dictId[id];
                                            if (t == null)
                                            {

                                            }
                                            else
                                            {
                                                t.readStatGlobal(reader);
                                            }
                                        }
                                    }
                                }

                            }
                        }

                        catch (Exception ex)
                        {
                            misc.log(ex);
                        }
                    }


                    //using (XmlReader reader = XmlReader.Create(GLOBAL_STAT))
                    //{
                    //    while (reader.Read())
                    //    {
                    //        if (reader.NodeType == XmlNodeType.Element)
                    //        {
                    //            if (reader.Name == "db")
                    //            {

                    //            }
                    //            else
                    //            {
                    //                int id = Convert.ToInt32(reader.GetAttribute("id"));


                    //                var t = dictId[id];
                    //                if (t == null)
                    //                {
                    //                    string loc = reader.GetAttribute("f");
                    //                    Program.log.log("track {0} dans les global stats non vu dans db {1}", id, loc);
                    //                }
                    //                else
                    //                {
                    //                    t.readStatGlobal(reader);
                    //                    t.consolidStat();
                    //                }
                    //            }
                    //        }
                    //    }

                    //}

                }

                finally
                {
                    loaded = true;
                }
            }
        }




        private TrackInfoItunes read(XmlReader reader, TrackAlbum currentAlbum)
        {
            var t = new TrackInfoItunes();

            //if (album != null)
            //{
            (t as it.TrackInfoItunes).TrackAlbum = currentAlbum;

            // }
            t.build(reader);
            currentAlbum.Add(t, true);
            return t;
        }

        private TrackAlbum readAlbum(XmlReader reader)
        {
            string name = reader.GetAttribute("name");
            var album = AlbumMgr.Instance.Get(name);
            if ("y" == reader.GetAttribute("rare"))
                album.setRare();
            if ("y" == reader.GetAttribute("info"))
                album.setInfo();
            if ("y" == reader.GetAttribute("actu"))
                album.setActu();
            if ("y" == reader.GetAttribute("courant"))
                album.setCourant();

            var str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                album.AlbumRating = Convert.ToInt32(str);

            return album;
        }

        private void write(XmlWriter writer, TrackAlbum album)
        {
            writer.WriteStartElement("a");
            writer.WriteAttributeString("name", album.Album);
            if (album.AlbumRating > 0)
                writer.WriteAttributeString("rating", album.AlbumRating.ToString());
            if (album.Rare)
                writer.WriteAttributeString("rare", "y");
            else if (album.RareEffect)
                writer.WriteAttributeString("rareEffect", "y");
            if (album.Info)
                writer.WriteAttributeString("info", "y");
            if (album.Actu)
                writer.WriteAttributeString("actu", "y");
            if (album.Courant)
                writer.WriteAttributeString("courant", "y");

            writer.WriteAttributeString("spec", album.Specif.ToString());

            var list = album.List;
            list.Sort(new TrackComparer());
            // list.Sort(new PodCastComparer());

            foreach (TrackInfoItunes t in list)
            {
                if (t.Deleted)
                    listDeleted.Add(t);
                else if (!Conf.Db.purgemissing || t.isPresent())
                    write(writer, t, false);
                else
                    listMissing.Add(t);
            }

            writer.WriteEndElement();

        }

        private static void write(XmlWriter writer, TrackInfoItunes track, bool writeAlbum)
        {
            writer.WriteStartElement("t");
            writer.WriteAttributeString("id", track.DbId.ToString());
            var location = track.Location;
            if (!string.IsNullOrEmpty(location))
            {
                if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                {
                    location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                }


            }
            writer.WriteAttributeString("f", location);
            if (writeAlbum)
                writer.WriteAttributeString("alb", track.Album);
            writer.WriteAttributeString("name", track.Name);
            if (track.Pub > DateTime.MinValue)
                writer.WriteAttributeString("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
            if (track.Pub2 > DateTime.MinValue && track.Pub2 > track.Pub)
                writer.WriteAttributeString("pub2", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
            if (track.PlayedDate > DateTime.MinValue)
                writer.WriteAttributeString("date", track.PlayedDate.ToString());
            if (track.PlayCount > 0)
                writer.WriteAttributeString("nbr", track.PlayCount.ToString());
            //if (track.AlbumRating > 0)
            //    writer.WriteAttributeString("albumRating", track.AlbumRating.ToString());
            if (track.Rating != track.AlbumRating)
                writer.WriteAttributeString("rating", track.Rating.ToString());


            //if (track.RatingComputed)
            //    writer.WriteAttributeString("computed", "y");
            //if (track.Rare)
            //    writer.WriteAttributeString("rare", "y");
            //if (track.Info)
            //    writer.WriteAttributeString("info", "y");
            var duree = track.Duree;
            if (duree.Value > 0)
            {
                writer.WriteAttributeString("d", duree.Value.ToString("0"));
                var size = track.Size;
                if (size > 0)
                    writer.WriteAttributeString("s", size.ToString());
            }
            if (!track.Enabled)
                writer.WriteAttributeString("disabled", "y");

            if (track.Added > DateTime.MinValue)
                writer.WriteAttributeString("add", track.Added.ToString());
            if (track.AddedFirst > DateTime.MinValue && track.AddedFirst < track.Added)
                writer.WriteAttributeString("add1", track.AddedFirst.ToString());

            if (!string.IsNullOrEmpty(track.Description))
                writer.WriteAttributeString("desc", track.Description);

            if (!string.IsNullOrEmpty(track.LongDescription))
                writer.WriteAttributeString("ldesc", track.LongDescription);

            var comment = track.Comment;
            if (!string.IsNullOrEmpty(comment))
            {
                var build = track.buildComment(); 
                if (comment != build)
                    writer.WriteAttributeString("comment", comment);
            }


            if (!string.IsNullOrEmpty(track.HibernateLocation))
                writer.WriteAttributeString("hl", track.HibernateLocation);


            writer.WriteEndElement();

        }

        private static void writeStat(XmlWriter writer, TrackInfoItunes track)
        {
            if (track.In > DateTime.MinValue)
            {
                writer.WriteStartElement("t");
                writer.WriteAttributeString("id", track.DbId.ToString());
                var location = track.Location;
                if (!string.IsNullOrEmpty(location))
                {
                    if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                    {
                        location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                    }


                }
                writer.WriteAttributeString("f", location);



                if (track.Out == DateTime.MinValue || track.In < track.Out)
                {
                    writer.WriteAttributeString("in", track.In.ToString());
                    if (track.Out > DateTime.MinValue)
                        writer.WriteAttributeString("out", track.Out.ToString());
                }
                else
                {
                    writer.WriteAttributeString("out", track.Out.ToString());
                    writer.WriteAttributeString("in", track.In.ToString());
                }


                writer.WriteEndElement();
            }

        }

        public void recordIt(IEnumerable<TrackInfoItunes> listIt)
        {
            if (listIt != null)
            {
                foreach (TrackInfoItunes t in listIt)
                    Check(t);
            }
        }

        private List<TrackInfoItunes> listMissing;
        private List<TrackInfoItunes> listDeleted;
        private class TrackComparer : IComparer<TrackInfoItunes>
        {
            public virtual int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                int cmp = x.Pub.CompareTo(y.Pub);
                if (cmp != 0)
                    return cmp;
                return x.DbId.CompareTo(y.DbId);
            }
        }

        private class TrackComparerInv : TrackComparer
        {
            public override int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                return -base.Compare(x, y);
            }
        }

        public void writeAsync()
        {
            new ThreadUtil(write, "db.write").Start();
        }
        public void write()
        {
            misc.log("db::write");
            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            var listZip = new List<string>();
            lock (_lock)
            {
                writing = true;
                try
                {
                    if (!Directory.Exists(SOV))
                        Directory.CreateDirectory(SOV);
                    ZipUtil.Exe = @"C:\Program Files (x86)\7-Zip\7z.exe";
                    // ZipUtil.Enter();
                    //ZipUtil.CompressAsync(zipSov, FILE, true); 
                    var destCopy = string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE));
                    File.Copy(FILE, destCopy, true);
                    listZip.Add(destCopy);
                    //  ZipUtil.CompressAsync(zipSov, timeStamp, new List<string> { destCopy }, false); 

                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                finally
                {
                    // ZipUtil.Release();
                }


                listMissing = new List<TrackInfoItunes>();
                listDeleted = new List<TrackInfoItunes>();

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(FILE + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());

                    AlbumMgr mgr = TrackInfoItunes.AlbumMgr as AlbumMgr;
                    var albums = mgr.List;

                    //albums.Sort(new TrackComparer()); 
                    albums.Sort((x, y) => x.Album.CompareTo(y.Album));

                    foreach (TrackAlbum album in albums)
                    {
                        write(writer, album);
                    }

                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE + ".tmp", FILE, true);



                if (listMissing.Count > 0)
                {
                    string missing = string.Format("{0}{1}__missing.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(missing, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            write(writerMissing, track, true);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }

                    listZip.Add(missing);

                }

                if (listDeleted.Count > 0)
                {
                    var deleted = string.Format("{0}{1}__deleted.xml", SOV, timeStamp);
                    using (XmlWriter writerDeleted = XmlWriter.Create(deleted, settings))
                    {
                        writerDeleted.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            write(writerDeleted, track, true);
                        }
                        writerDeleted.WriteEndDocument();
                        writerDeleted.Flush();
                    }
                    listZip.Add(deleted);
                }
                var destCopyStat = string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE_STAT));
                if (File.Exists(FILE_STAT))
                {
                    File.Copy(FILE_STAT, destCopyStat, true);
                    listZip.Add(destCopyStat);
                }

                using (XmlWriter writer = XmlWriter.Create(FILE_STAT + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    var tracks = Tracks;
                    tracks.Sort(new PodCastComparer());
                    foreach (TrackInfoItunes track in tracks)
                    {
                        if (!Conf.Db.purgemissing || track.isPresent())
                            writeStat(writer, track);
                    }
                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE_STAT + ".tmp", FILE_STAT, true);

                // listZip.Add(FILE_STAT); 

                if (listMissing.Count > 0)
                {
                    var missing = string.Format("{0}{1}__missing_stat.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(missing, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }
                    listZip.Add(missing);

                }

                if (listDeleted.Count > 0)
                {
                    var deletedStat = string.Format("{0}{1}__deleted_stat.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(deletedStat, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }
                    listZip.Add(deletedStat);

                }
                misc.log("db::fin write");
                ZipUtil.Compress(zipSov, null, listZip, false, false);
                misc.log("db::fin write et zip");
                //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                writing = false;
            }
        }


        // géopolitique 4 par défaut rating ->80 albumrating ->80 computed =true
        //RFI 0 de temps en temps surcharge pour un par défaut : rating null albumrating->20 computed = true
        //                                  pour un syrchargé  : rating non null ""   
        // adele 1                          pour les défaut   rating:20 album 20 computed
        //                                  pour un surchargé 4 rating 80 album 20 non computed

        //C'est quand même gavant. il fait pas la différence entre les étoiles pleines et creuses
        //prenons adele defaut : 20 /20 computed
        //          autre        80 /20 non computed


        // ayo album zero surcharge 1 deux étoiles creuses => 20/40/computed

        //Ah ok . cas computed 1. album=rating => c'est bien level album
        //                        album != rating => c'est bidon  "étoile creuse"                                
        //        sinon on lit directement level album

        // Quel con j'ai pas vu qu'il y avait RatingComputed et Album Rating computed
        // je me le refele
        //géopolitique ratinet alubm => 80 ratingComputed
        // RFi  defaut rating null album 20 albumcomputed
        //      surchargé   rating 20 idem     
        // adele defaut rating 20 rating computed albumrating 20




    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;
using System.Linq;
using System.Linq.Expressions;
using System.Text.RegularExpressions;
namespace pdb.podcast.Sort
{
    class Album
    {
        const string DATE_FORMAT = "dd/MM/yy HH:mm";
        const string DAY_FORMAT = "dd/MM HH:mm";
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        // private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbModifPertinent = 0;
        private static int nbRepecheForce = 0;
        private static DateTime dateRepeche = DateTime.MaxValue; public static DateTime DateRepeche { get { return dateRepeche; } }
        private static List<TrackSort> repeches = new List<TrackSort>();
        public static int NbRepeches { get { return repeches.Count; } }
        public static int NbModif { get { return nbModif; } }
        public static int NbModifPertinent { get { return nbModifPertinent; } }

        private bool done;

        //  bool checkSelected, apply;
        DateTime date0; //, newDate0;
        DateTime date1;
        public static void Init()
        {
            //lastReads.Clear(); 
            //nbrepeches = 0;
            repeches.Clear();
            nbModif = 0; nbModifPertinent = 0;
            nbRepecheForce = 0;
            dateRepeche = DateTime.MaxValue;
        }

        public static void Bilan()
        {
            if (dateRepeche < DateTime.MaxValue)
                log.log("*************Date minimum:" + dateRepeche);
            repeches.Sort((x, y) => x.Pub2.CompareTo(y.Pub2));
            foreach (TrackSort t in repeches)
                log.log(string.Format("date={0} {1}", t.Pub2, t));
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;
        public static Logger logDebug;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }



        public void init()
        {
            //done = false;
        }

        //public void buildAll()
        //{
        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;

        //    checkSelected = false;
        //    apply = false;

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        var dt = track.Pub2.AddSeconds(1);
        //        date0 = dt;
        //        newDate0 = dt;
        //        build();
        //        if (dt >= Conf.Date0)
        //            break;
        //    }

        //    apply = true;
        //    date0 = Conf.Date0;
        //    newDate0 = Conf.NewDate0;
        //    // writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        writeComment(track, track.Pub2);
        //    }
        //}

        private void build0()
        {
            int count = list.Count;
            if (count == 0)
                return;



            TrackSort.Date0 = date0;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    if (track.Pub2 < track.Pub)
                        track.Pub2 = track.Pub;
                    if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                    {
                        var aux = currentPub2.AddMinutes(1);
                        log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                        track.Pub2 = aux;
                    }
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                            indexNextSelected = i;
                        }
                    }
                    else
                        break;
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var rare = album.Rare;
            var intervalleMin0 = conf.getIntervalleMin0(rare);
            var intervalle = conf.getIntervalle(rare, lastRead.DureeEnHeure, intervalleMin0);
            var intervalleMin = conf.getIntervalleMin(rare, lastRead.DureeEnHeure);

            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(rare);
            double cumulMax = conf.getCumulMax(rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = intervalle; // conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    // var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    double rapport = (double)_nbRead / (double)_nbTotal;

                    var coeff = 1 / rapport;

                    if (conf.dureeCoeff)
                    {
                        coeff = conf.getCoeff(rare, coeff, lastRead.DureeEnHeure);
                    }

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);



                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                {
                    double _coeff = deltaLimiteEcoule / delta;
                    delta = borne(_coeff, intervalle, intervalleMin);
                }

                if (delta < 1)
                    delta = 1;




                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }





            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();

            DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * delta).truncateToMinute();
            //var cumul = (limitFuture - next.Pub).TotalDays;
            //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
            //if (dtaux > limitFutureRab)
            //    limitFutureRab = dtaux; 
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = delta;
            if (conf.extPente > 0)
                deltaAtterrissage = delta0;


            if (conf.deltaConst || conf.extPente > 0)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                for (int i = indexLastRead + 2; i < count; i++)
                {
                    var t = list[i];
                    if (conf.useVirtuel)
                    {
                        // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                        dt = dt.AddDays(intervalleMin0);
                    }
                    else
                        dt = t.Pub;


                    nb++;
                    if (dt > limitFuture)
                    {
                        nextDate = dt;
                        nblissage++;
                        if (dt <= _deltaMin)
                            continue;
                        if (dt <= _deltaRab)
                            continue;
                        if (nb <= conf.deltaNbMin)
                            continue;
                        if (nblissage <= conf.deltaNbRab)
                            continue;
                        if (dt <= limitFutureRab)
                            continue;

                        break;


                        //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                        //    break;
                    }

                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            //  nb = 0;
            // bool enRetard = limitFuture < date0;
            TrackSort last = next;
            DateTime lastPub2 = limitFuture;
            int indexDepart = indexLastRead + 1;



            bool erased = false;

            if (conf.vacances)
                deltaAtterrissage = delta;

            for (int i = indexDepart; i < count; i++)
            {
                var t = list[i];
                if (erased && conf.erasedDone)
                {
                    eraseSort(t, "");
                    continue;
                }

                DateTime dt = lastPub2;

                if (i == indexDepart && !conf.useVirtuel2)
                {
                    dt = limitFuture;
                }
                else
                {

                    //if (conf.deltaCheckSelected)
                    //{
                    //    if (!t.Selected)
                    //        continue;
                    //    if (!t.Enabled)
                    //        continue;
                    //}
                    var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                    if (conf.useVirtuel2)
                        dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                    else
                        dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
                    if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1)
                    {
                        var dt2 = dt;
                        if (conf.useVirtuel2)
                            dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                        else
                            dt2 = lastPub2.AddDays(delta).truncateToMinute();
                        //if (dt2 <= date0)
                        dt = dt2;
                        //else
                        //    dt = date0.AddMinutes(1);
                    }


                }



                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset || erased && conf.erasedDone)
                {
                    erased = true;
                    eraseSort(t, "");
                }
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }


                    //if (dt > DateTime.Now)
                    //{
                    //}

                    //if ((dt - t.Pub).TotalDays > 100)
                    //{
                    //}

                    writeComment(t, dt, "");
                    //nb++;
                }


                last = t;
                lastPub2 = dt;


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }

        private void build()
        {

            int count = list.Count;
            if (count == 0)
                return;


            // bool rare = album.Rare;

            TrackSort.Date0 = date0;

            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;

            // 1. ordre
            for (int i = 0; i < count; i++)
            {
                var track = list[i];


                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    if (track.Pub2 < track.Pub)
                        track.Pub2 = track.Pub;

                    if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                    {
                        var aux = currentPub2.AddMinutes(1);
                        log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                        track.Pub2 = aux;
                    }
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }



            int index0 = 0;
            int indexCourant = 0;

            TrackSort next = null;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played)
                {
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastRead = track;
                    }
                    else
                        break;

                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                        }
                    }
                    else
                        break;
                }
            }

            if (indexLastRead < 0)
                return;


            indexCourant = indexLastRead;

            if (conf.vacances || !conf.recheck)
                index0 = indexCourant;
            else
            {
                index0 = 0;
                indexLastRead = -1;
                lastRead = null;

            }
            bool firstSel = false;


           // DateTime lastPlayed = DateTime.MinValue;

            if (lastRead == null)
            {
                for (int i = index0; i < count; i++)
                {
                    var track = list[i];

                    if (track.Played) // && track.PlayedDate > lastPlayed)
                    {
                        indexLastRead = i;
                       // lastPlayed = track.PlayedDate;

                        lastRead = track;
                        index0 = i;
                        break;
                    }

                }
            }

            if (lastRead == null)
                return;

            TrackSort last = lastRead;
            DateTime lastPub2 = lastRead.Pub2;

            while (true)
            {
                if (index0 >= count - 1)
                    break;

                if (this.album.Album == "Les nouveaux chemins de la connaissance" && index0 >= indexCourant - 10)
                {
                }

                var current = list[index0];
                bool played = current.Played;


                //  int indexNextSelected = -1;

                //  TrackSort next = null;

                // 2. Détermination lastRead et next






                bool rare = album.Rare;

                var futur = conf.getFutur(rare);
                int nbFutur = 0;
                int nbRestant = 0;
                double intervalleFactMin = 1;
                double intervalleFactMoy = 1;
                double intervalleX = 0;

                // DateTime lastExists = lastRead.Pub;

                DateTime finFutur = DateTime.Now;

                if (futur > 0)
                {
                    finFutur = current.Pub.AddDays(futur);
                    if (finFutur > DateTime.Now)
                        finFutur = DateTime.Now;
                    // chopper l'intervalle majoritaire pour éviter le poids des erreurs. 
                    Dict<int, int> spectreDelta = new Dict<int, int>();
                    DateTime lastExists = lastRead.Pub;
                    for (int i = index0; i < count; i++)
                    {
                        nbRestant++;
                        var t = list[i].Pub;



                        if (t < finFutur)
                        {
                            nbFutur++;


                            var dp = (int)(System.Math.Round((t - lastExists).TotalDays, 0, MidpointRounding.AwayFromZero));
                            lastExists = t;
                            if (dp > 0)
                                spectreDelta[dp]++;
                        }
                        else if (nbRestant >= TrackAlbum.NB_MIN_POUR_FREQUENT)
                        {

                            break;
                        }
                    }

                    if (nbFutur == 0)
                        nbFutur = 1;
                    var deltaTotal = (finFutur - current.Pub).TotalDays;
                    if (deltaTotal > 0)
                    {
                        intervalleFactMoy = deltaTotal / (double)nbFutur;
                        intervalleX = (intervalleFactMoy - 1) / 6;
                    }

                    var choices = spectreDelta.Keys.ToList();
                    choices.Sort((x, y) => x.CompareTo(y));

                    int max = 0;
                    int dpMaj = 1;
                    for (int i = 0; i < choices.Count; i++)
                    {
                        int k = choices[i];
                        var r = spectreDelta[k];
                        if (r > max)
                        {
                            max = r;
                            dpMaj = k;
                        }
                    }

                    intervalleFactMin = dpMaj;

                    if (nbRestant < TrackAlbum.NB_MIN_POUR_FREQUENT && !rare)
                    // if (nbFutur < TrackAlbum.NB_MIN_POUR_FREQUENT && !rare)
                    {
                        // this.album.RareEffect = true;
                        rare = true;
                    }
                }

                double duree = current.DureeEnHeure;
                var intervalleMin0 = conf.getIntervalleMin0(rare);
                var intervalleMin0Var = conf.getIntervalleMin0Var(intervalleX, intervalleFactMin);

                var intervalle = conf.getIntervalle(rare, duree, intervalleMin0);
                var intervalleVar = conf.getIntervalleVar(rare, intervalleX, duree, intervalleMin0Var);

                var intervalleCorrec = intervalle;
                var intervalleCorrecVar = intervalleVar;
                var intervalleMin = conf.getIntervalleMin(rare, duree);
                var intervalleMinVar = conf.getIntervalleMinVar(rare, intervalleX, duree);


                var atterissageMin = conf.getAtterrissageMin(rare);
                var atterissageMinVar = conf.getatterrissageMinVar(intervalleX, intervalleFactMin);

                double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                DateTime pub2 = lastRead.Pub2;

                double delta0Corr = deltaLastRead0;

                double cumulMin = conf.getCumulMin(rare);
                double cumulMax = conf.getCumulMax(rare);

                if (pub2 > lastRead.Pub && conf.extPente == 0)
                {
                    if (conf.elastique < 1)
                    {
                        delta0Corr = deltaLastRead0 * conf.elastique;
                        pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                    }


                    //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                    //{
                    //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                    //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                    //}
                }


                var _played = played ? current : lastRead;
                var deltaLecture = (DateTime.Now - _played.PlayedDate).TotalDays; 
                

                //int nbReads = 0;
                //int nbTotals = 0;

                int nbRead = 0;
                int nbTotal = 0;

                //int _nbRead = 0;
                int _nbTotal = 0;

                var histo = conf.getHisto(rare);
                var nbHisto = conf.getNbHisto(rare);
                double densite = 1;
                double rapport = 1;
                double coeff = 1;
                double coeffVar = 1;

                double delta = intervalle; // conf.getIntervalle(album.Rare);
                double deltaVar = intervalleVar;
                double delta0 = delta;
                double deltaHorizon0 = delta;
                double deltaHorizon0Var = deltaVar;
                double deltaHorizon = delta;
                double deltaHorizonVar = deltaVar;

                bool useTolerance = false; 

                if (histo > 0 || nbHisto > 0)
                {

                    DateTime limit = lastRead.Pub.AddDays(-histo);
                    for (int i = indexLastRead; i >= 0; i--)
                    {
                        var t = list[i];
                        var dt = t.Pub;
                        if (dt < limit && nbTotal >= nbHisto && nbTotal >= conf.totalMin)
                            break;

                        if (t.Played)
                            nbRead++;


                        nbTotal++;

                    }

                    _nbTotal = nbTotal;

                    if (nbRead > 0 && _nbTotal > 0)
                    {
                        if (_nbTotal < conf.totalMin)
                            _nbTotal = conf.totalMin;


                        // var futur = conf.getFutur(rare);

                        if (futur > 0)
                        {


                            double theoric = (finFutur - current.Pub).TotalDays / intervalleMin0;
                            densite = nbFutur / theoric;
                            //if (densite >= 1)
                            //    densite = 1;

                            if (densite < conf.densiteMin && !rare)
                            {
                                rare = true;


                                intervalleMin0 = conf.getIntervalleMin0(rare);
                                intervalleMin0Var = conf.getIntervalleMin0Var(intervalleX, intervalleFactMin);

                                intervalle = conf.getIntervalle(rare, duree, intervalleMin0);
                                intervalleVar = conf.getIntervalleVar(rare, intervalleX, duree, intervalleMin0Var);

                                intervalleCorrec = intervalle;
                                intervalleCorrecVar = intervalleVar;
                                intervalleMin = conf.getIntervalleMin(rare, duree);
                                intervalleMinVar = conf.getIntervalleMinVar(rare, intervalleX, duree);


                                atterissageMin = conf.getAtterrissageMin(rare);
                                atterissageMinVar = conf.getatterrissageMinVar(intervalleX, intervalleFactMin);




                                theoric = (finFutur - current.Pub).TotalDays / intervalleMin0;
                                densite = nbFutur / theoric;
                                //if (densite >= 1)
                                //    densite = 1;
                            }
                            //if (densite < 1)
                            //    rapport = rapport * densite;
                        }


                        //  album.Rare ? conf.intervalleR : conf.intervalle;
                        rapport = (double)nbRead / (double)_nbTotal;
                        coeff = 1 / rapport;

                        if (conf.dureeCoeff)
                            coeff = conf.getCoeff(rare, coeff, duree);

                        coeffVar = coeff;

                        if (conf.coeffDensite)
                        {
                            coeff /= densite;

                            coeffVar *= intervalleFactMoy;
                        }

                        if (conf.honneurAuxVieux && nbRestant < TrackAlbum.NB_MIN_POUR_FREQUENT)
                        {
                            if (nbRestant > 0)
                            {
                                var t = TrackAlbum.NB_MIN_POUR_FREQUENT / nbRestant;
                                coeff *= t;
                                coeffVar *= t;
                            }
                        }

                        var recup = intervalleMin0 - atterissageMin;
                        var recupVar = intervalleMin0Var - atterissageMinVar;


                        delta = intervalle; // conf.getIntervalle(album.Rare);
                        delta0 = delta;
                        deltaHorizon0 = delta;
                        deltaHorizon = delta;


                        deltaHorizon0Var = intervalleVar;
                        deltaHorizonVar = intervalleVar;

                        var rapport2 = 2 * rapport;
                        if (rapport2 > 1)
                            rapport2 = 1; 

                        deltaHorizon0 = intervalleMin0 + recup * (1 - rapport) / rapport + (1 - densite) / (densite * rapport);
                        //deltaHorizon0Var = intervalleMin0Var + recupVar * (1 - rapport) / rapport + (1 - 1 / intervalleFactMoy) / (rapport / intervalleFactMoy); 
                        //deltaHorizon0Var = intervalleFactMoy + ((1 - rapport) / rapport) * (intervalleFactMoy - atterissageMinVar); // ça pue
                        deltaHorizon0Var = (intervalleFactMoy - atterissageMinVar * (1 - rapport2)) / rapport2;
                        // im=7, rapport=0.9

                        //if (deltaHorizon0Var < deltaHorizon0)
                        //    deltaHorizon0Var = deltaHorizon0; 


                        deltaHorizon = deltaHorizon0;
                        deltaHorizonVar = deltaHorizon0Var;

                        if (current.Name.Contains("Philosopher au Maroc aujourd’hui (1/4)"))
                        {
                        }
                      
                        var tolerance = conf.getTolerance(rare);
                        double tolerancePart = 0;
                        if (tolerance > 0)
                        {
                            var ecart0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                            tolerancePart = (tolerance - ecart0) / conf.getNbTolerance(rare);
                            if (deltaHorizon < tolerancePart)
                                deltaHorizon = tolerancePart;
                            else if (conf.toleranceNegative && tolerancePart < 0)
                                deltaHorizon += tolerancePart;


                            if (deltaHorizonVar < tolerancePart)
                            {
                                deltaHorizonVar = tolerancePart;
                                useTolerance = true;
                            }
                            else if (conf.toleranceNegative && tolerancePart < 0)
                                deltaHorizonVar += tolerancePart;
                        }




                        if (deltaHorizon < intervalle)
                            intervalleCorrec = deltaHorizon;

                        if (deltaHorizonVar < intervalleVar)
                            intervalleCorrecVar = deltaHorizonVar;

                        //if (intervalleCorrec < intervalleMin)
                        //    intervalleCorrec = intervalleMin;

                        //if (intervalleCorrecVar < intervalleMinVar)
                        //    intervalleCorrecVar = intervalleMinVar;
                        //0.1 => 10
                        //0.9 => 1.11
                        //coeff -= 1; // 9  0.11
                        //var dminmax = intervalle - intervalleMin;

                        var _delta0 = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
                        var _deltaVar0 = borne(coeffVar, intervalleVar, intervalleMinVar);



                        var _delta = borne(coeff, intervalleCorrec, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
                        var _deltaVar = borne(coeffVar, intervalleCorrecVar, intervalleMinVar);


                        if (conf.horizonFinal)
                        {
                            if (_delta0 < delta)
                                delta = _delta0;
                            else if (_delta0 == delta)
                            { }
                            else
                            { }



                            if (_deltaVar0 < deltaVar)
                                deltaVar = _deltaVar0;
                            else if (_deltaVar0 == deltaVar)
                            { }
                            else
                            { }

                            if (delta > deltaHorizon)
                                delta = deltaHorizon;

                            //if (delta < tolerancePart)
                            //    delta = tolerancePart; 

                            if (deltaVar > deltaHorizonVar)
                                deltaVar = deltaHorizonVar;

                            //if (deltaVar < tolerancePart)
                            //    deltaVar = tolerancePart; 

                        }
                        else
                        {


                            if (_delta < delta)
                                delta = _delta;
                            else if (_delta == delta)
                            { }
                            else
                            { }


                            if (_deltaVar < deltaVar)
                                deltaVar = _deltaVar;
                            else if (_deltaVar == deltaVar)
                            { }
                            else
                            { }
                        }




                    }

                    //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


                    if (conf.intervalleVar)
                    {
                        delta = deltaVar;
                        atterissageMin = atterissageMinVar;
                        intervalleMin = intervalleMinVar;
                        intervalleMin0 = intervalleMin0Var;
                        intervalle = intervalleVar;

                    }


                }



                if (conf.extPente > 0)
                {
                    var d0 = (DateTime.Now - pub2).TotalDays;
                    var dl = conf.extDelta;
                    if (dl == 0)
                    {
                        dl = d0;
                    }

                    delta0 = d0 / conf.extPente;
                    delta = delta0;
                    //01/01/2014 ->01/01/2017
                    //04/01/2017 -> 04/01/2014
                    var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                    var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                    log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                    if (deltaLimiteEcoule > delta)
                    {
                        double _coeff = deltaLimiteEcoule / delta;
                        delta = borne(_coeff, intervalle, intervalleMin);
                    }

                    if (delta < 1)
                        delta = 1;




                    //if (delta > intervalle)
                    //    delta = intervalle;
                }

                if (conf.limitRead && deltaLecture > intervalle)
                {
                    //13 /10 ->7
                    var _old = delta;

                    delta += intervalle - deltaLecture;
                    log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
                }





                if (delta < intervalleMin)
                    delta = intervalleMin;

                if (delta > intervalle)
                    delta = intervalle;



                DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
                TrackSort _next = list[indexLastRead + 1];
                double ecart = (limitFuture - _next.Pub).TotalDays;

                DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * ecart).truncateToMinute();
                //var cumul = (limitFuture - next.Pub).TotalDays;
                //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
                //if (dtaux > limitFutureRab)
                //    limitFutureRab = dtaux; 
                DateTime nextDate = limitFuture;

                int nb = 0;
                int nblissage = 0;
                double deltaAtterrissage = intervalleMin;
                double atterrissageVacance = deltaAtterrissage;

                if (conf.noCollision)
                    deltaAtterrissage = delta;
                if (conf.extPente > 0)
                    deltaAtterrissage = delta0;
                string causes = "";

                if (conf.deltaConst || conf.extPente > 0)
                {
                }

                else
                {
                    var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                    var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                    DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                    var sbCause = new StringBuilder();

                    for (int i = indexLastRead + 2; i < count; i++)
                    {
                        var t = list[i];
                        if (conf.useVirtuel)
                        {
                            // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                            dt = dt.AddDays(intervalleMin0);
                        }
                        else
                            dt = t.Pub;


                        nb++;
                        if (dt > limitFuture)
                        {
                            sbCause = new StringBuilder();
                            nextDate = dt;
                            nblissage++;

                            int nbCause = 0;
                            if (dt <= _deltaMin)
                            {
                                sbCause.Append(" deltaMin");
                                nbCause++;
                            }
                            if (dt <= _deltaRab)
                            {
                                sbCause.Append(" deltaRab");
                                nbCause++;
                            }
                            if (nb <= conf.deltaNbMin)
                            {
                                sbCause.Append(" deltaNbMin");
                                nbCause++;
                            }
                            if (nblissage <= conf.deltaNbRab)
                            {
                                sbCause.Append(" deltaNbRab");
                                nbCause++;
                            }
                            if (dt <= limitFutureRab)
                            {
                                sbCause.Append(" coeffRab");
                                nbCause++;
                            }

                            if (nbCause > 0)
                            {
                                causes = sbCause.ToString();
                                continue;
                            }


                            break;


                            //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                            //    break;
                        }

                    }

                    if (nb > 0 && conf.noCollision) //    (nextDate > limitFuture && nb > 0 && conf.noCollision)
                    {
                        deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (deltaAtterrissage > intervalleMin)
                            deltaAtterrissage = intervalleMin;
                    }
                }

                if (deltaAtterrissage < atterissageMin)
                {
                    causes += " corrigé atterrissageMin";
                    deltaAtterrissage = atterissageMin;

                }


                atterrissageVacance = delta * rapport + deltaAtterrissage * (1 - rapport);


                //string atter = string.Format("{0}->{1}", delta.ToString("0.##"), deltaAtterrissage.ToString("0.##"));
                //if (conf.vacances && deltaAtterrissage != atterrissageVacance)
                string atter = string.Format("{0}:{1}->{2}({3})", intervalleFactMoy.ToString("0.##"), delta.ToString("0.##"), deltaAtterrissage.ToString("0.##"), atterrissageVacance.ToString("0.##"));
                string _usetolerance = useTolerance ? "+" : " "; 
                string deltas = string.Format("{0} ic={1}({2}) h={3} i={4}",_usetolerance, atter,
                   conf.intervalleVar ? intervalleCorrecVar.ToString("0.##") : intervalleCorrec.ToString("0.##"),
                   conf.intervalleVar ? intervalleCorrec.ToString("0.##") : intervalleCorrecVar.ToString("0.##"), deltaHorizon.ToString("0.##"), intervalle.ToString("0.##"));
                //    deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"));
                string stats = string.Format("{0}/{1}={2}% c={3} d={4}% dr={5} r={6}({7})", nbRead, nbTotal, (100 * rapport).ToString("0"), coeff.ToString("0.##"), (densite * 100).ToString("0"), (100 * densite * rapport).ToString("0"),
                    deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"));
                var sbAlbum = new StringBuilder();

                sbAlbum.Append(string.Format("[{0}]", album.Album));
                if (album.Rare) sbAlbum.Append(" rare ");
                else if (rare) sbAlbum.Append(" rare+ ");
                sbAlbum.Append(current.track.Duree.TotalMinute.ToString("0 m"));

                var str = string.Format("{0} {1} lect={2} causes={3}", stats, sbAlbum.ToString(),  deltaLecture.ToString("#,#"), causes);

                if (played)
                {
                    if (index0 >= indexCourant)
                        log.logNoDate(str);
                    else
                        logDebug.logNoDate(str);
                }


                //  nb = 0;
                // bool enRetard = limitFuture < date0;

                //int indexDepart = indexLastRead + 1;
                // int indexNext = index0 + 1;

                if (current != lastRead)
                {
                    var t = current; // list[indexNext];

                    var _deltaAtterrissage = deltaAtterrissage;
                    if (conf.vacances && firstSel)
                        _deltaAtterrissage = atterrissageVacance;

                    DateTime dt = lastPub2;

                    if (index0 == indexLastRead + 1 && !conf.useVirtuel2)
                    {
                        dt = limitFuture;
                    }
                    else
                    {


                        var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                        if (conf.useVirtuel2)
                            dt = lastPub2.AddDays(d * _deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                        else
                            dt = lastPub2.AddDays(_deltaAtterrissage).truncateToMinute();
                        if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1 && t.Pub2 < date1)
                        {
                            var dt2 = dt;
                            if (conf.useVirtuel2)
                                dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                            else
                                dt2 = lastPub2.AddDays(delta).truncateToMinute();
                            //if (dt2 <= date0)
                            dt = dt2;
                            //else
                            //    dt = date0.AddMinutes(1);
                        }


                    }

                    if (!firstSel)
                    {
                        if (dt > date0)
                            firstSel = true;
                    }


                    if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    {

                        eraseSort(t, deltas);
                    }
                    else
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                        {
                            if (__delta > cumulMin)
                            {
                                __delta = borneCumul(__delta, cumulMin, cumulMax);
                                dt = t.Pub.AddDays(__delta).truncateToMinute();
                            }
                        }

                        if (conf.elastique2 < 1)
                        {
                            var deltacorr2 = __delta * conf.elastique2;
                            dt = t.Pub.AddDays(deltacorr2).truncateToMinute();
                        }

                        var dtMin = lastPub2.AddDays(atterissageMin);

                        if (dt < dtMin)
                            dt = dtMin;


                        if (dt > DateTime.Now)
                        {
                        }

                        if ((dt - t.Pub).TotalDays > 100)
                        {
                        }

                        if (t.Pub >= dt)
                            eraseSort(t, deltas);
                        else
                            writeComment(t, dt, deltas);
                        //nb++;
                    }


                    last = t;
                    lastPub2 = dt;

                    if (played)
                    {
                        lastRead = current;
                        //lastPlayed = lastRead.PlayedDate;
                        indexLastRead = index0;
                    }

                }


                index0++;
            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }


        public void Build()
        {
            if (album.Album == "SCIENCE PUBLIQUE")
            {
            }
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            //if (conf.enabled == sortMode.histo)
            //{
            //    buildAll();
            //    return;
            //}
            //else
            //{
            //checkSelected = true;
            //apply = true;
            date0 = Conf.Date0;
            if (conf.deltaConstLate >= 0)
                date1 = date0.AddDays(conf.deltaConstLate);
            // newDate0 = Conf.NewDate0;
            if (conf.extPente > 0 || conf.oldMode)
                build0();
            else
                build();
            return;
            //  }

            #region old
            /* if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true, true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, true);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, true, true, Conf.Date0, Conf.NewDate0);
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            */
            #endregion


        }



        private void eraseSort(TrackSort track, string desc)
        {
            writeComment(track, track.Pub, desc);
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (!checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = track.Pub;
            //    return;
            //}

            ////if (!force && !track.Selected)
            ////    return;
            //if (conf.canGoBack || conf.enabled == sortMode.reset)
            //{
            //    if (!track.Played && track.Enabled)
            //    {
            //        DateTime pub = track.Pub;
            //        if (track.Pub2 >= date0 && pub <date0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //        else if (track.Pub2 >=newDate0 && pub < newDate0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //    }

            //    //}
            //    //else
            //    //{
            //    if (track.Pub2 != track.Pub)
            //        nbModif++;
            //    track.Pub2 = track.Pub;
            //    //}
            //    track.track.BuildComment();
            //    // writeComment(track);
            //}
        }

        //private void applyPub(TrackSort track)
        //{
        //    writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);
        //}

        private void writeComment(TrackSort track, DateTime dt, string desc)
        {
            dt = dt.truncateToMinute();
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = dt;
            //    return;
            //}



            //if (checkSelected && !track.Selected)
            //    return;


            if (conf.canGoBack)
            {
                if (!track.Played && track.Enabled)
                {
                    if (track.pub20 >= date0 && dt < date0)
                    {
                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            repeches.Add(track);
                        }
                        if (dt < dateRepeche)
                            dateRepeche = dt;
                    }

                    //else if (track.pub20 >= newDate0 && dt < newDate0)
                    //{

                    //    if (conf.canGoBackButForceSelected)
                    //    {
                    //        log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                    //        nbRepecheForce++;
                    //        dt = date0.AddMinutes(nbRepecheForce);
                    //    }
                    //    else
                    //    {
                    //        log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.pub20, dt, newDate0);
                    //        repeches.Add(track);
                    //    }

                    //    if (dt < dateRepeche)
                    //        dateRepeche = dt;

                    //}
                }
            }
            else
            {
                if (dt == track.pub20)
                {
                    logDebug.logNoDate("\t{0} {1} {2}\t{3}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), desc, track.Name);
                    return;
                }
                else if (dt < track.pub20)
                {
                    logDebug.logNoDate("\t{0} {1}<= {2} {3}\t{4}", track.Pub.ToString(DATE_FORMAT), track.pub20.ToString(DAY_FORMAT), dt.ToString(DAY_FORMAT), desc, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var delta0 = (track.pub20 - track.Pub).TotalDays;

            var sbDelta = new StringBuilder();
            sbDelta.Append("(");
            var strD0 = delta0.ToString("#.#");
            var strD1 = delta.ToString("#.#");
            if (delta0 > 0)
            {
                sbDelta.Append(strD0);
            }
            if (strD0 != strD1)
            {
                sbDelta.Append("->");
                if (delta > 0)
                    sbDelta.Append(strD1);
            }
            sbDelta.Append(")");

            while (sbDelta.Length < 12)
                sbDelta.Append(" ");

            var strDelta = sbDelta.ToString();

            if (track.pub20 != dt)
            {

                if (track.pub20.truncateToMinute() != dt)
                {
                    //if (track.track.Selected)
                    //{
                    nbModif++;
                    var d = System.Math.Abs((track.pub20 - dt).TotalHours);
                    if (d > 1)
                        nbModifPertinent++;

                    // var str = string.Format("\t{0}\t{1}=>\t{2}({3})\t{4} {5}", track.Pub, track.pub20, dt, strDelta, desc, track.Name);
                    var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), strDelta, desc, track.Name); // ", track.pub20, dt, strDelta, desc, track.Name);
                    if (track.track.Selected)
                        log.logNoDate(str);
                    else
                        logDebug.logNoDate(str);
                    //}
                }
                track.Pub2 = dt;
            }
            else if (track.pub20 > track.Pub)
            {
                // if (track.track.Selected)
                var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), strDelta, desc, track.Name);
                // var str = string.Format("\t{0}\t{1}({2})\t{3} {4}", track.Pub, track.pub20, strDelta, desc, track.Name);
                if (track.track.Selected)
                    log.logNoDate(str);
                else
                    logDebug.logNoDate(str);
            }
            else
            {
                var sbBlanc = new StringBuilder();

                var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), Regex.Replace(dt.ToString(DAY_FORMAT), ".", " "), strDelta, desc, track.Name);
                // var str = string.Format("\t{0} ({1})\t{2} {3}", track.Pub, strDelta, desc,track.Name);
                logDebug.logNoDate(str);
            }


            track.track.BuildComment();
            //  track.track.BuildComposer(); 
        }

        private static double borne(double coeff, double intervalle, double intervalleMin)
        {
            if (coeff <= 1)
                return coeff * intervalleMin;
            if (intervalle <= intervalleMin)
                return intervalle;
            coeff -= 1; // 9  0.11
            var dminmax = intervalle - intervalleMin;

            var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

            return _delta;
        }

        private static double borneCumul(double delta, double cumulMin, double cumulMax)
        {
            if (cumulMin < 0 || cumulMax < 0)
                return delta;
            if (delta < cumulMin)
                return delta;
            var coeff = delta / cumulMin;
            return borne(coeff, cumulMax, cumulMin);
        }

        private double _coeffLecture = -1;
        public double getCoeffLecture(TrackInfoItunes track)
        {
            if (_coeffLecture > 0)
                return _coeffLecture;
            int count = list.Count;
            int index = -1;
            for (int i = 0; i < count; i++)
            {
                if (list[i].track == track)
                {
                    index = i;
                    break;
                }
            }
            if (index < 0)
                return 0;

            var _histo = conf.getHisto(track.Rare);

            if (_histo > 0)
            {
                int nbTotal = 0;
                int nbRead = 0;
                double histo = _histo;




                DateTime limit = track.Pub.AddDays(-histo);
                for (int i = index - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }

                if (nbTotal > 0)
                    _coeffLecture = nbRead / nbTotal;
                else
                    return 0;
            }
            else
                return 0;

            return _coeffLecture;



        }
    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Sort\Album1.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;
using System.Linq;
using System.Linq.Expressions;
using System.Text.RegularExpressions;
namespace pdb.podcast.Sort
{
    class Album
    {
        const string DATE_FORMAT = "dd/MM/yy HH:mm"; 
        const string DAY_FORMAT = "dd/MM HH:mm"; 
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        // private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbModifPertinent = 0;
        private static int nbRepecheForce = 0;
        private static DateTime dateRepeche = DateTime.MaxValue; public static DateTime DateRepeche { get { return dateRepeche; } }
        private static List<TrackSort> repeches = new List<TrackSort>();
        public static int NbRepeches { get { return repeches.Count; } }
        public static int NbModif { get { return nbModif; } }
        public static int NbModifPertinent { get { return nbModifPertinent; } }

        private bool done;

        //  bool checkSelected, apply;
        DateTime date0; //, newDate0;
        DateTime date1;
        public static void Init()
        {
            //lastReads.Clear(); 
            //nbrepeches = 0;
            repeches.Clear();
            nbModif = 0; nbModifPertinent = 0;
            nbRepecheForce = 0;
            dateRepeche = DateTime.MaxValue;
        }

        public static void Bilan()
        {
            if (dateRepeche < DateTime.MaxValue)
                log.log("*************Date minimum:" + dateRepeche);
            repeches.Sort((x, y) => x.Pub2.CompareTo(y.Pub2));
            foreach (TrackSort t in repeches)
                log.log(string.Format("date={0} {1}", t.Pub2, t));
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;
        public static Logger logDebug;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }



        public void init()
        {
            //done = false;
        }

        //public void buildAll()
        //{
        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;

        //    checkSelected = false;
        //    apply = false;

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        var dt = track.Pub2.AddSeconds(1);
        //        date0 = dt;
        //        newDate0 = dt;
        //        build();
        //        if (dt >= Conf.Date0)
        //            break;
        //    }

        //    apply = true;
        //    date0 = Conf.Date0;
        //    newDate0 = Conf.NewDate0;
        //    // writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        writeComment(track, track.Pub2);
        //    }
        //}

        private void build0()
        {
            int count = list.Count;
            if (count == 0)
                return;



            TrackSort.Date0 = date0;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    if (track.Pub2 < track.Pub)
                        track.Pub2 = track.Pub;
                    if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                    {
                        var aux = currentPub2.AddMinutes(1);
                        log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                        track.Pub2 = aux;
                    }
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                            indexNextSelected = i;
                        }
                    }
                    else
                        break;
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var rare = album.Rare;
            var intervalleMin0 = conf.getIntervalleMin0(rare);
            var intervalle = conf.getIntervalle(rare, lastRead.DureeEnHeure, intervalleMin0);
            var intervalleMin = conf.getIntervalleMin(rare, lastRead.DureeEnHeure);

            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(rare);
            double cumulMax = conf.getCumulMax(rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = intervalle; // conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    // var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    double rapport = (double)_nbRead / (double)_nbTotal;

                    var coeff = 1 / rapport;

                    if (conf.dureeCoeff)
                    {
                        coeff = conf.getCoeff(rare, coeff, lastRead.DureeEnHeure);
                    }

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);



                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                {
                    double _coeff = deltaLimiteEcoule / delta;
                    delta = borne(_coeff, intervalle, intervalleMin);
                }

                if (delta < 1)
                    delta = 1;




                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }





            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();

            DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * delta).truncateToMinute();
            //var cumul = (limitFuture - next.Pub).TotalDays;
            //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
            //if (dtaux > limitFutureRab)
            //    limitFutureRab = dtaux; 
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = delta;
            if (conf.extPente > 0)
                deltaAtterrissage = delta0;


            if (conf.deltaConst || conf.extPente > 0)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                for (int i = indexLastRead + 2; i < count; i++)
                {
                    var t = list[i];
                    if (conf.useVirtuel)
                    {
                        // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                        dt = dt.AddDays(intervalleMin0);
                    }
                    else
                        dt = t.Pub;


                    nb++;
                    if (dt > limitFuture)
                    {
                        nextDate = dt;
                        nblissage++;
                        if (dt <= _deltaMin)
                            continue;
                        if (dt <= _deltaRab)
                            continue;
                        if (nb <= conf.deltaNbMin)
                            continue;
                        if (nblissage <= conf.deltaNbRab)
                            continue;
                        if (dt <= limitFutureRab)
                            continue;

                        break;


                        //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                        //    break;
                    }

                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            //  nb = 0;
            // bool enRetard = limitFuture < date0;
            TrackSort last = next;
            DateTime lastPub2 = limitFuture;
            int indexDepart = indexLastRead + 1;



            bool erased = false;

            if (conf.vacances)
                deltaAtterrissage = delta;

            for (int i = indexDepart; i < count; i++)
            {
                var t = list[i];
                if (erased && conf.erasedDone)
                {
                    eraseSort(t,"");
                    continue;
                }

                DateTime dt = lastPub2;

                if (i == indexDepart && !conf.useVirtuel2)
                {
                    dt = limitFuture;
                }
                else
                {

                    //if (conf.deltaCheckSelected)
                    //{
                    //    if (!t.Selected)
                    //        continue;
                    //    if (!t.Enabled)
                    //        continue;
                    //}
                    var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                    if (conf.useVirtuel2)
                        dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                    else
                        dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
                    if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1)
                    {
                        var dt2 = dt;
                        if (conf.useVirtuel2)
                            dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                        else
                            dt2 = lastPub2.AddDays(delta).truncateToMinute();
                        //if (dt2 <= date0)
                        dt = dt2;
                        //else
                        //    dt = date0.AddMinutes(1);
                    }


                }



                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset || erased && conf.erasedDone)
                {
                    erased = true;
                    eraseSort(t,"");
                }
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }


                    //if (dt > DateTime.Now)
                    //{
                    //}

                    //if ((dt - t.Pub).TotalDays > 100)
                    //{
                    //}

                    writeComment(t, dt, "");
                    //nb++;
                }


                last = t;
                lastPub2 = dt;


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }

        private void build()
        {

            int count = list.Count;
            if (count == 0)
                return;


            // bool rare = album.Rare;

            TrackSort.Date0 = date0;

            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;

            // 1. ordre
            for (int i = 0; i < count; i++)
            {
                var track = list[i];


                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    if (track.Pub2 < track.Pub)
                        track.Pub2 = track.Pub;

                    if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                    {
                        var aux = currentPub2.AddMinutes(1);
                        log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                        track.Pub2 = aux;
                    }
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

            //2. si pas recheck on détermine ou on en est

            int index0 = 0;
            int indexCourant = 0;

            TrackSort next = null;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                        }
                    }
                    else
                        break;
                }
            }

            if (indexLastRead < 0)
                return;


            indexCourant = indexLastRead;

            if (conf.vacances || !conf.recheck)
                index0 = indexCourant;
            else
            {
                index0 = 0;
                indexLastRead = -1;
                lastRead = null;

            }
            bool firstSel = false;


            DateTime lastPlayed = DateTime.MinValue;

            if (lastRead == null)
            {
                for (int i = index0; i < count; i++)
                {
                    var track = list[i];

                    if (track.Played) // && track.PlayedDate > lastPlayed)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;

                        lastRead = track;
                        index0 = i;
                        break;
                    }

                }
            }

            if (lastRead == null)
                return;

            TrackSort last = lastRead;
            DateTime lastPub2 = lastRead.Pub2;

            while (true)
            {
                if (index0 >= count - 1)
                    break;

                var current = list[index0];
                bool played = current.Played;
                if (played)
                {
                    lastRead = current;
                    lastPlayed = lastRead.PlayedDate;
                    indexLastRead = index0;
                }

                //  int indexNextSelected = -1;

                //  TrackSort next = null;

                // 2. Détermination lastRead et next






                bool rare = album.Rare;

                var futur = conf.getFutur(rare);
                int nbFutur = 0;
                int nbRestant = 0;
                double intervalleFactMin = 1;
                double intervalleFactMoy = 1;
                double intervalleX = 0;

                // DateTime lastExists = lastRead.Pub;

                DateTime finFutur = DateTime.Now;

                if (futur > 0)
                {
                    finFutur = current.Pub.AddDays(futur);
                    if (finFutur > DateTime.Now)
                        finFutur = DateTime.Now;
                    // chopper l'intervalle majoritaire pour éviter le poids des erreurs. 
                    Dict<int, int> spectreDelta = new Dict<int, int>();
                    DateTime lastExists = lastRead.Pub;
                    for (int i = index0; i < count; i++)
                    {
                        nbRestant++;
                        var t = list[i].Pub;



                        if (t < finFutur)
                        {
                            nbFutur++;


                            var dp = (int)(System.Math.Round((t - lastExists).TotalDays, 0, MidpointRounding.AwayFromZero));
                            lastExists = t;
                            if (dp > 0)
                                spectreDelta[dp]++;
                        }
                        else if (nbRestant >= TrackAlbum.NB_MIN_POUR_FREQUENT)
                        {

                            break;
                        }
                    }

                    if (nbFutur == 0)
                        nbFutur = 1;
                    var deltaTotal = (finFutur - current.Pub).TotalDays;
                    if (deltaTotal > 0)
                    {
                        intervalleFactMoy = deltaTotal / (double)nbFutur;
                        intervalleX = (intervalleFactMoy - 1) / 6;
                    }

                    var choices = spectreDelta.Keys.ToList();
                    choices.Sort((x, y) => x.CompareTo(y));

                    int max = 0;
                    int dpMaj = 1;
                    for (int i = 0; i < choices.Count; i++)
                    {
                        int k = choices[i];
                        var r = spectreDelta[k];
                        if (r > max)
                        {
                            max = r;
                            dpMaj = k;
                        }
                    }

                    intervalleFactMin = dpMaj;

                    if (nbRestant < TrackAlbum.NB_MIN_POUR_FREQUENT && !rare)
                    // if (nbFutur < TrackAlbum.NB_MIN_POUR_FREQUENT && !rare)
                    {
                        // this.album.RareEffect = true;
                        rare = true;
                    }
                }

                double duree = current.DureeEnHeure;
                var intervalleMin0 = conf.getIntervalleMin0(rare);
                var intervalleMin0Var = conf.getIntervalleMin0Var(intervalleX, intervalleFactMin);

                var intervalle = conf.getIntervalle(rare, duree, intervalleMin0);
                var intervalleVar = conf.getIntervalleVar(rare, intervalleX, duree, intervalleMin0Var);

                var intervalleCorrec = intervalle;
                var intervalleCorrecVar = intervalleVar;
                var intervalleMin = conf.getIntervalleMin(rare, duree);
                var intervalleMinVar = conf.getIntervalleMinVar(rare, intervalleX, duree);


                var atterissageMin = conf.getAtterrissageMin(rare);
                var atterissageMinVar = conf.getatterrissageMinVar(intervalleX, intervalleFactMin);

                double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                DateTime pub2 = lastRead.Pub2;

                double delta0Corr = deltaLastRead0;

                double cumulMin = conf.getCumulMin(rare);
                double cumulMax = conf.getCumulMax(rare);

                if (pub2 > lastRead.Pub && conf.extPente == 0)
                {
                    if (conf.elastique < 1)
                    {
                        delta0Corr = deltaLastRead0 * conf.elastique;
                        pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                    }


                    //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                    //{
                    //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                    //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                    //}
                }




                var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

                //int nbReads = 0;
                //int nbTotals = 0;

                int nbRead = 0;
                int nbTotal = 0;

                //int _nbRead = 0;
                int _nbTotal = 0;

                var histo = conf.getHisto(rare);
                var nbHisto = conf.getNbHisto(rare);
                double densite = 1;
                double rapport = 1;
                double coeff = 1;
                double coeffVar = 1;

                double delta = intervalle; // conf.getIntervalle(album.Rare);
                double deltaVar = intervalleVar;
                double delta0 = delta;
                double deltaHorizon0 = delta;
                double deltaHorizon0Var = deltaVar;
                double deltaHorizon = delta;
                double deltaHorizonVar = deltaVar;

                if (histo > 0 || nbHisto > 0)
                {

                    DateTime limit = lastRead.Pub.AddDays(-histo);
                    for (int i = indexLastRead; i >= 0; i--)
                    {
                        var t = list[i];
                        var dt = t.Pub;
                        if (dt < limit && nbTotal >= nbHisto && nbTotal >= conf.totalMin)
                            break;

                        if (t.Played)
                            nbRead++;


                        nbTotal++;

                    }

                    _nbTotal = nbTotal;

                    if (nbRead > 0 && _nbTotal > 0)
                    {
                        if (_nbTotal < conf.totalMin)
                            _nbTotal = conf.totalMin;


                        // var futur = conf.getFutur(rare);

                        if (futur > 0)
                        {


                            double theoric = (finFutur - current.Pub).TotalDays / intervalleMin0;
                            densite = nbFutur / theoric;
                            //if (densite >= 1)
                            //    densite = 1;

                            if (densite < conf.densiteMin && !rare)
                            {
                                rare = true;


                                intervalleMin0 = conf.getIntervalleMin0(rare);
                                intervalleMin0Var = conf.getIntervalleMin0Var(intervalleX, intervalleFactMin);

                                intervalle = conf.getIntervalle(rare, duree, intervalleMin0);
                                intervalleVar = conf.getIntervalleVar(rare, intervalleX, duree, intervalleMin0Var);

                                intervalleCorrec = intervalle;
                                intervalleCorrecVar = intervalleVar;
                                intervalleMin = conf.getIntervalleMin(rare, duree);
                                intervalleMinVar = conf.getIntervalleMinVar(rare, intervalleX, duree);


                                atterissageMin = conf.getAtterrissageMin(rare);
                                atterissageMinVar = conf.getatterrissageMinVar(intervalleX, intervalleFactMin);




                                theoric = (finFutur - current.Pub).TotalDays / intervalleMin0;
                                densite = nbFutur / theoric;
                                //if (densite >= 1)
                                //    densite = 1;
                            }
                            //if (densite < 1)
                            //    rapport = rapport * densite;
                        }


                        //  album.Rare ? conf.intervalleR : conf.intervalle;
                        rapport = (double)nbRead / (double)_nbTotal;
                        coeff = 1 / rapport;

                        if (conf.dureeCoeff)
                            coeff = conf.getCoeff(rare, coeff, duree);

                        coeffVar = coeff;

                        if (conf.coeffDensite)
                        {
                            coeff /= densite;

                            coeffVar *= intervalleFactMoy;
                        }

                        if (conf.honneurAuxVieux && nbRestant < TrackAlbum.NB_MIN_POUR_FREQUENT)
                        {
                            if (nbRestant > 0)
                            {
                                var t = TrackAlbum.NB_MIN_POUR_FREQUENT / nbRestant;
                                coeff *= t;
                                coeffVar *= t;
                            }
                        }

                        var recup = intervalleMin0 - atterissageMin;
                        var recupVar = intervalleMin0Var - atterissageMinVar;


                        delta = intervalle; // conf.getIntervalle(album.Rare);
                        delta0 = delta;
                        deltaHorizon0 = delta;
                        deltaHorizon = delta;


                        deltaHorizon0Var = intervalleVar;
                        deltaHorizonVar = intervalleVar;

                        deltaHorizon0 = intervalleMin0 + recup * (1 - rapport) / rapport + (1 - densite) / (densite * rapport);
                        //deltaHorizon0Var = intervalleMin0Var + recupVar * (1 - rapport) / rapport + (1 - 1 / intervalleFactMoy) / (rapport / intervalleFactMoy); 
                        //deltaHorizon0Var = intervalleFactMoy + ((1 - rapport) / rapport) * (intervalleFactMoy - atterissageMinVar); // ça pue
                        deltaHorizon0Var = (intervalleFactMoy - atterissageMinVar * (1 - rapport)) / rapport;
                        // im=7, rapport=0.9

                        //if (deltaHorizon0Var < deltaHorizon0)
                        //    deltaHorizon0Var = deltaHorizon0; 


                        deltaHorizon = deltaHorizon0;
                        deltaHorizonVar = deltaHorizon0Var;

                        var tolerance = conf.getTolerance(rare);
                        double tolerancePart = 0;
                        if (tolerance > 0)
                        {
                            var ecart0 = (current.Pub2 - current.Pub).TotalDays;
                            tolerancePart = (tolerance - ecart0) / conf.getNbTolerance(rare);
                            if (deltaHorizon < tolerancePart)
                                deltaHorizon = tolerancePart;
                            else if (conf.toleranceNegative && tolerancePart < 0)
                                deltaHorizon += tolerancePart;


                            if (deltaHorizonVar < tolerancePart)
                                deltaHorizonVar = tolerancePart;
                            else if (conf.toleranceNegative && tolerancePart < 0)
                                deltaHorizonVar += tolerancePart;
                        }




                        if (deltaHorizon < intervalle)
                            intervalleCorrec = deltaHorizon;

                        if (deltaHorizonVar < intervalleVar)
                            intervalleCorrecVar = deltaHorizonVar;

                        //if (intervalleCorrec < intervalleMin)
                        //    intervalleCorrec = intervalleMin;

                        //if (intervalleCorrecVar < intervalleMinVar)
                        //    intervalleCorrecVar = intervalleMinVar;
                        //0.1 => 10
                        //0.9 => 1.11
                        //coeff -= 1; // 9  0.11
                        //var dminmax = intervalle - intervalleMin;

                        var _delta0 = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
                        var _deltaVar0 = borne(coeffVar, intervalleVar, intervalleMinVar);



                        var _delta = borne(coeff, intervalleCorrec, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
                        var _deltaVar = borne(coeffVar, intervalleCorrecVar, intervalleMinVar);


                        if (conf.horizonFinal)
                        {
                            if (_delta0 < delta)
                                delta = _delta0;
                            else if (_delta0 == delta)
                            { }
                            else
                            { }



                            if (_deltaVar0 < deltaVar)
                                deltaVar = _deltaVar0;
                            else if (_deltaVar0 == deltaVar)
                            { }
                            else
                            { }

                            if (delta > deltaHorizon)
                                delta = deltaHorizon;

                            //if (delta < tolerancePart)
                            //    delta = tolerancePart; 

                            if (deltaVar > deltaHorizonVar)
                                deltaVar = deltaHorizonVar;

                            //if (deltaVar < tolerancePart)
                            //    deltaVar = tolerancePart; 

                        }
                        else
                        {


                            if (_delta < delta)
                                delta = _delta;
                            else if (_delta == delta)
                            { }
                            else
                            { }


                            if (_deltaVar < deltaVar)
                                deltaVar = _deltaVar;
                            else if (_deltaVar == deltaVar)
                            { }
                            else
                            { }
                        }




                    }

                    //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


                    if (conf.intervalleVar)
                    {
                        delta = deltaVar;
                        atterissageMin = atterissageMinVar;
                        intervalleMin = intervalleMinVar;
                        intervalleMin0 = intervalleMin0Var;
                        intervalle = intervalleVar;

                    }


                }



                if (conf.extPente > 0)
                {
                    var d0 = (DateTime.Now - pub2).TotalDays;
                    var dl = conf.extDelta;
                    if (dl == 0)
                    {
                        dl = d0;
                    }

                    delta0 = d0 / conf.extPente;
                    delta = delta0;
                    //01/01/2014 ->01/01/2017
                    //04/01/2017 -> 04/01/2014
                    var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                    var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                    log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                    if (deltaLimiteEcoule > delta)
                    {
                        double _coeff = deltaLimiteEcoule / delta;
                        delta = borne(_coeff, intervalle, intervalleMin);
                    }

                    if (delta < 1)
                        delta = 1;




                    //if (delta > intervalle)
                    //    delta = intervalle;
                }

                if (conf.limitRead && deltaLecture > intervalle)
                {
                    //13 /10 ->7
                    var _old = delta;

                    delta += intervalle - deltaLecture;
                    log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
                }





                if (delta < intervalleMin)
                    delta = intervalleMin;

                if (delta > intervalle)
                    delta = intervalle;



                DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
                TrackSort _next = list[indexLastRead + 1];
                double ecart = (limitFuture - _next.Pub).TotalDays;

                DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * ecart).truncateToMinute();
                //var cumul = (limitFuture - next.Pub).TotalDays;
                //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
                //if (dtaux > limitFutureRab)
                //    limitFutureRab = dtaux; 
                DateTime nextDate = limitFuture;

                int nb = 0;
                int nblissage = 0;
                double deltaAtterrissage = intervalleMin;
                double atterrissageVacance = deltaAtterrissage;

                if (conf.noCollision)
                    deltaAtterrissage = delta;
                if (conf.extPente > 0)
                    deltaAtterrissage = delta0;
                string causes = "";

                if (conf.deltaConst || conf.extPente > 0)
                {
                }

                else
                {
                    var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                    var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                    DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                    var sbCause = new StringBuilder();

                    for (int i = indexLastRead + 2; i < count; i++)
                    {
                        var t = list[i];
                        if (conf.useVirtuel)
                        {
                            // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                            dt = dt.AddDays(intervalleMin0);
                        }
                        else
                            dt = t.Pub;


                        nb++;
                        if (dt > limitFuture)
                        {
                            sbCause = new StringBuilder();
                            nextDate = dt;
                            nblissage++;

                            int nbCause = 0;
                            if (dt <= _deltaMin)
                            {
                                sbCause.Append(" deltaMin");
                                nbCause++;
                            }
                            if (dt <= _deltaRab)
                            {
                                sbCause.Append(" deltaRab");
                                nbCause++;
                            }
                            if (nb <= conf.deltaNbMin)
                            {
                                sbCause.Append(" deltaNbMin");
                                nbCause++;
                            }
                            if (nblissage <= conf.deltaNbRab)
                            {
                                sbCause.Append(" deltaNbRab");
                                nbCause++;
                            }
                            if (dt <= limitFutureRab)
                            {
                                sbCause.Append(" coeffRab");
                                nbCause++;
                            }

                            if (nbCause > 0)
                            {
                                causes = sbCause.ToString();
                                continue;
                            }


                            break;


                            //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                            //    break;
                        }

                    }

                    if (nb > 0 && conf.noCollision) //    (nextDate > limitFuture && nb > 0 && conf.noCollision)
                    {
                        deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (deltaAtterrissage > intervalleMin)
                            deltaAtterrissage = intervalleMin;
                    }
                }

                if (deltaAtterrissage < atterissageMin)
                {
                    causes += " corrigé atterrissageMin";
                    deltaAtterrissage = atterissageMin;

                }


                atterrissageVacance = delta * rapport + deltaAtterrissage * (1 - rapport);


                //string atter = string.Format("{0}->{1}", delta.ToString("0.##"), deltaAtterrissage.ToString("0.##"));
                //if (conf.vacances && deltaAtterrissage != atterrissageVacance)
                string atter = string.Format("{0}:{1}->{2} ({3})", intervalleFactMoy.ToString("0.##"), delta.ToString("0.##"), deltaAtterrissage.ToString("0.##"), atterrissageVacance.ToString("0.##"));

                string deltas = string.Format("ic={0}({1}) a={2} h0={3} h={4} i={5} r={6} {7}",
                   conf.intervalleVar ? intervalleCorrecVar.ToString("0.##") : intervalleCorrec.ToString("0.##"),
                   conf.intervalleVar ? intervalleCorrec.ToString("0.##") : intervalleCorrecVar.ToString("0.##"), atter, deltaHorizon0.ToString("0.##"), deltaHorizon.ToString("0.##"), intervalle.ToString("0.##"),
                    deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"));
                string stats = string.Format("{0}/{1}={2} c={3} d={4} dr={5}", nbRead, nbTotal, (100 * rapport).ToString("0"), coeff.ToString("0.##"), (densite * 100).ToString("0"), (100 * densite * rapport).ToString("0"));
                var sbAlbum = new StringBuilder();
               
                    sbAlbum.Append(string.Format("[{0}]", album.Album));
                    if (album.Rare) sbAlbum.Append(" rare ");
                    else if (rare) sbAlbum.Append(" rare+ ");
                    sbAlbum.Append(lastRead.track.Duree.TotalMinute.ToString("0 m"));
             
                var str = string.Format("{0} {1} {2} {3} ({4}) lecture={5} causes={6}", stats, sbAlbum.ToString(), lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"), causes);

                if (played)
                {
                    if (index0 >= indexCourant)
                        log.logNoDate(str);
                    else
                        logDebug.logNoDate(str);
                }


                //  nb = 0;
                // bool enRetard = limitFuture < date0;

                //int indexDepart = indexLastRead + 1;
                int indexNext = index0 + 1;

                if (indexNext < count)
                {
                    var t = list[indexNext];

                    var _deltaAtterrissage = deltaAtterrissage;
                    if (conf.vacances && firstSel)
                        _deltaAtterrissage = atterrissageVacance;

                    DateTime dt = lastPub2;

                    if (played && !conf.useVirtuel2)
                    {
                        dt = limitFuture;
                    }
                    else
                    {


                        var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                        if (conf.useVirtuel2)
                            dt = lastPub2.AddDays(d * _deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                        else
                            dt = lastPub2.AddDays(_deltaAtterrissage).truncateToMinute();
                        if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1 && t.Pub2 < date1)
                        {
                            var dt2 = dt;
                            if (conf.useVirtuel2)
                                dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                            else
                                dt2 = lastPub2.AddDays(delta).truncateToMinute();
                            //if (dt2 <= date0)
                            dt = dt2;
                            //else
                            //    dt = date0.AddMinutes(1);
                        }


                    }

                    if (!firstSel)
                    {
                        if (dt > date0)
                            firstSel = true;
                    }


                    if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    {

                        eraseSort(t,deltas);
                    }
                    else
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                        {
                            if (__delta > cumulMin)
                            {
                                __delta = borneCumul(__delta, cumulMin, cumulMax);
                                dt = t.Pub.AddDays(__delta).truncateToMinute();
                            }
                        }

                        if (conf.elastique2 < 1)
                        {
                            var deltacorr2 = __delta * conf.elastique2;
                            dt = t.Pub.AddDays(deltacorr2).truncateToMinute();
                        }

                        var dtMin = lastPub2.AddDays(atterissageMin);

                        if (dt < dtMin)
                            dt = dtMin;


                        if (dt > DateTime.Now)
                        {
                        }

                        if ((dt - t.Pub).TotalDays > 100)
                        {
                        }

                        if (t.Pub >= dt)
                            eraseSort(t,deltas); 
                        else
                            writeComment(t, dt, deltas); 
                        //nb++;
                    }


                    last = t;
                    lastPub2 = dt;

                }

                //for (int i = indexDepart; i < count; i++)
                //{
                //var t = list[i];

                //var _deltaAtterrissage = deltaAtterrissage;
                //if (conf.vacances && firstSel)
                //    _deltaAtterrissage = atterrissageVacance;

                //DateTime dt = lastPub2;

                //if (i == indexDepart && !conf.useVirtuel2)
                //{
                //    dt = limitFuture;
                //}
                //else
                //{


                //    var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                //    if (conf.useVirtuel2)
                //        dt = lastPub2.AddDays(d * _deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                //    else
                //        dt = lastPub2.AddDays(_deltaAtterrissage).truncateToMinute();
                //    if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1 && t.Pub2 < date1)
                //    {
                //        var dt2 = dt;
                //        if (conf.useVirtuel2)
                //            dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                //        else
                //            dt2 = lastPub2.AddDays(delta).truncateToMinute();
                //        //if (dt2 <= date0)
                //        dt = dt2;
                //        //else
                //        //    dt = date0.AddMinutes(1);
                //    }


                //}

                //if (!firstSel)
                //{
                //    if (dt > date0)
                //        firstSel = true;
                //}


                //if (t.Pub >= dt || conf.enabled == sortMode.reset)
                //{

                //    eraseSort(t);
                //}
                //else
                //{
                //    var __delta = (dt - t.Pub).TotalDays;
                //    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                //    {
                //        if (__delta > cumulMin)
                //        {
                //            __delta = borneCumul(__delta, cumulMin, cumulMax);
                //            dt = t.Pub.AddDays(__delta).truncateToMinute();
                //        }
                //    }

                //    if (conf.elastique2 < 1)
                //    {
                //        var deltacorr2 = __delta * conf.elastique2;
                //        dt = t.Pub.AddDays(deltacorr2).truncateToMinute();
                //    }

                //    var dtMin = lastPub2.AddDays(atterissageMin);

                //    if (dt < dtMin)
                //        dt = dtMin;


                //    if (dt > DateTime.Now)
                //    {
                //    }

                //    if ((dt - t.Pub).TotalDays > 100)
                //    {
                //    }

                //    if (t.Pub >= dt)
                //        eraseSort(t);
                //    else
                //        writeComment(t, dt);
                //    //nb++;
                //}


                //last = t;
                //lastPub2 = dt;
                //index0 = i;

                //if (t.Played)
                //{
                //    break;
                //}
                // }
                index0++;
            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }


        public void Build()
        {
            if (album.Album == "SCIENCE PUBLIQUE")
            {
            }
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            //if (conf.enabled == sortMode.histo)
            //{
            //    buildAll();
            //    return;
            //}
            //else
            //{
            //checkSelected = true;
            //apply = true;
            date0 = Conf.Date0;
            if (conf.deltaConstLate >= 0)
                date1 = date0.AddDays(conf.deltaConstLate);
            // newDate0 = Conf.NewDate0;
            if (conf.extPente > 0 || conf.oldMode)
                build0();
            else
                build();
            return;
            //  }

            #region old
            /* if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true, true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, true);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, true, true, Conf.Date0, Conf.NewDate0);
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            */
            #endregion


        }



        private void eraseSort(TrackSort track, string desc)
        {
            writeComment(track, track.Pub, desc);
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (!checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = track.Pub;
            //    return;
            //}

            ////if (!force && !track.Selected)
            ////    return;
            //if (conf.canGoBack || conf.enabled == sortMode.reset)
            //{
            //    if (!track.Played && track.Enabled)
            //    {
            //        DateTime pub = track.Pub;
            //        if (track.Pub2 >= date0 && pub <date0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //        else if (track.Pub2 >=newDate0 && pub < newDate0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //    }

            //    //}
            //    //else
            //    //{
            //    if (track.Pub2 != track.Pub)
            //        nbModif++;
            //    track.Pub2 = track.Pub;
            //    //}
            //    track.track.BuildComment();
            //    // writeComment(track);
            //}
        }

        //private void applyPub(TrackSort track)
        //{
        //    writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);
        //}

        private void writeComment(TrackSort track, DateTime dt, string desc)
        {
            dt = dt.truncateToMinute();
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = dt;
            //    return;
            //}



            //if (checkSelected && !track.Selected)
            //    return;


            if (conf.canGoBack)
            {
                if (!track.Played && track.Enabled)
                {
                    if (track.pub20 >= date0 && dt < date0)
                    {
                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            repeches.Add(track);
                        }
                        if (dt < dateRepeche)
                            dateRepeche = dt;
                    }

                    //else if (track.pub20 >= newDate0 && dt < newDate0)
                    //{

                    //    if (conf.canGoBackButForceSelected)
                    //    {
                    //        log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                    //        nbRepecheForce++;
                    //        dt = date0.AddMinutes(nbRepecheForce);
                    //    }
                    //    else
                    //    {
                    //        log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.pub20, dt, newDate0);
                    //        repeches.Add(track);
                    //    }

                    //    if (dt < dateRepeche)
                    //        dateRepeche = dt;

                    //}
                }
            }
            else
            {
                if (dt == track.pub20)
                {
                    logDebug.logNoDate("\t{0} {1} {2}\t{3}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), desc, track.Name);
                    return;
                }
                else if (dt < track.pub20)
                {
                    logDebug.logNoDate("\t{0} {1}<= {2} {3}\t{4}", track.Pub.ToString(DATE_FORMAT), track.pub20.ToString(DAY_FORMAT), dt.ToString(DAY_FORMAT), desc, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var delta0 = (track.pub20 - track.Pub).TotalDays;

            var sbDelta = new StringBuilder();
            sbDelta.Append("("); 
            var strD0 = delta0.ToString("#.#"); 
            var strD1= delta.ToString("#.#"); 
            if (delta0 > 0)
            {
                sbDelta.Append(strD0);                 
            }
            if (strD0 != strD1)
            {
                sbDelta.Append("->"); 
                if (delta >0)
                    sbDelta.Append(strD1);         
            }
            sbDelta.Append(")");

            while (sbDelta.Length < 12)
                sbDelta.Append(" "); 

            var strDelta = sbDelta.ToString(); 

            if (track.pub20 != dt)
            {

                if (track.pub20.truncateToMinute() != dt)
                {
                    //if (track.track.Selected)
                    //{
                    nbModif++;
                    var d = System.Math.Abs((track.pub20 - dt).TotalHours);
                    if (d > 1)
                        nbModifPertinent++;

                   // var str = string.Format("\t{0}\t{1}=>\t{2}({3})\t{4} {5}", track.Pub, track.pub20, dt, strDelta, desc, track.Name);
                    var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), strDelta, desc, track.Name); // ", track.pub20, dt, strDelta, desc, track.Name);
                    if (track.track.Selected)
                        log.logNoDate(str);
                    else
                        logDebug.logNoDate(str);
                    //}
                }
                track.Pub2 = dt;
            }
            else if (track.pub20 > track.Pub)
            {
                // if (track.track.Selected)
                var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), strDelta, desc, track.Name); 
               // var str = string.Format("\t{0}\t{1}({2})\t{3} {4}", track.Pub, track.pub20, strDelta, desc, track.Name);
                if (track.track.Selected)
                    log.logNoDate(str);
                else
                    logDebug.logNoDate(str);
            }
            else
            {
                var sbBlanc = new StringBuilder();

                var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), Regex.Replace(dt.ToString(DAY_FORMAT), ".", " "), strDelta, desc, track.Name); 
               // var str = string.Format("\t{0} ({1})\t{2} {3}", track.Pub, strDelta, desc,track.Name);
                logDebug.logNoDate(str);
            }


            track.track.BuildComment();
            //  track.track.BuildComposer(); 
        }

        private static double borne(double coeff, double intervalle, double intervalleMin)
        {
            if (coeff <= 1)
                return coeff * intervalleMin;
            if (intervalle <= intervalleMin)
                return intervalle;
            coeff -= 1; // 9  0.11
            var dminmax = intervalle - intervalleMin;

            var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

            return _delta;
        }

        private static double borneCumul(double delta, double cumulMin, double cumulMax)
        {
            if (cumulMin < 0 || cumulMax < 0)
                return delta;
            if (delta < cumulMin)
                return delta;
            var coeff = delta / cumulMin;
            return borne(coeff, cumulMax, cumulMin);
        }

        private double _coeffLecture = -1;
        public double getCoeffLecture(TrackInfoItunes track)
        {
            if (_coeffLecture > 0)
                return _coeffLecture;
            int count = list.Count;
            int index = -1;
            for (int i = 0; i < count; i++)
            {
                if (list[i].track == track)
                {
                    index = i;
                    break;
                }
            }
            if (index < 0)
                return 0;

            var _histo = conf.getHisto(track.Rare);

            if (_histo > 0)
            {
                int nbTotal = 0;
                int nbRead = 0;
                double histo = _histo;




                DateTime limit = track.Pub.AddDays(-histo);
                for (int i = index - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }

                if (nbTotal > 0)
                    _coeffLecture = nbRead / nbTotal;
                else
                    return 0;
            }
            else
                return 0;

            return _coeffLecture;



        }
    }
}]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using pdb.it.Albums;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        protected static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        protected static IAlbumMgr albumMgr;
        public static IAlbumMgr AlbumMgr { set { albumMgr = value; } get { return albumMgr; } }
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        private TrackPlayListManager listManager = new TrackPlayListManager();
        private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        //private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        //private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        // private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        //private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        protected static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);
        protected static BackGroundTaskMgr bgImport = BackGroundTaskMgr.getMgr("Import", 0);
        protected static BackGroundTaskMgr bgHibernate = BackGroundTaskMgr.getMgr("Hibernate", 0);
        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }



        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            albumMgr.setAlbum(this, track.Album);
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;

            fillDesc(track); 




        }

        public bool Played { get { return this.playCount > 0; } }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present; public bool Present { get { return present; } set { present = value; } }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location": Uri uri = new Uri(value);
                        return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.PlayedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded;


            Fill();
        }



        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0;
            string key = "";
            bool nextIgnore = false;


            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value;
                        break;
                    case "Artist": artist = value; break;
                    case "Album": albumMgr.setAlbum(this, value); break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": PlayedDate = Convert.ToDateTime(value); break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;// Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                fillDesc(tracktrack); 
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        private string description;
        private string longDescription;

        public string Description { get { return description; } protected set { description = value; } }
        public string LongDescription { get { return longDescription; } protected set { longDescription = value; } }


        public void fillDesc(IITFileOrCDTrack track)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(description))
                description = track.Description;
            if (string.IsNullOrEmpty(longDescription))
                longDescription = track.LongDescription; 
        }
        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return TrackTrack;

                fillDesc(track); 
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        private static BackGroundTaskMgr bgArtist = BackGroundTaskMgr.getMgr("Artist", 0);
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;
                bgArtist.add(new Bgtask(() =>
                {
                    Track.Artist = value;
                    artist = value;
                }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                ));


            }
        }
        protected IAlbum _album;
        public IAlbum TrackAlbum { get { return _album; } set { _album = value; } }
        private static BackGroundTaskMgr bgAlbum = BackGroundTaskMgr.getMgr("Album", 0);
        public virtual string AlbumKey { get { return Album; } }
        public string Album
        {
            get
            {
                return _album.Album;
            }
            set
            {
                if (value == null || value.Equals(_album.Album)) return;
                bgAlbum.add(new Bgtask(() =>
                {
                    // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                    Track.Album = value;
                    albumMgr.setAlbum(this, value);
                }, this,
                "change album from '{0}' to'{1}' {2}", Album, value, this
                ));

            }
        }
        protected string name = "";
        private static BackGroundTaskMgr bgName = BackGroundTaskMgr.getMgr("Name", 0);
        public virtual string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;

                int lengh = 0;
                if (name != null)
                    lengh = name.Length;

                if (value.Length < lengh)
                {
                    log.log("Attention On raccourcit le nom !!! {0}->{1} {2}", name, value, this);
                    // return; 
                }


                var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                bgName.add(bgtaskName);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }

        protected string composer = "";
        private static BackGroundTaskMgr bgComposer = BackGroundTaskMgr.getMgr("Composer", 0);
        public virtual string Composer
        {
            get
            {
                if (present && string.IsNullOrEmpty(composer))
                {
                    var t = Track;
                    if (t != null)
                        composer = t.Composer;
                }
                return composer;
            }
            set
            {
                if (!present)
                {
                    composer = value;
                    return;
                }

                if (value == null || value.Equals(composer)) return;

                var t = Track;
                if (t != null)
                    composer = t.Composer;
                if (value.Equals(composer))
                    return;


                var bgtaskComposer = new BgTaskComposer(this, string.Format("change composer from '{0}' to '{1}' {2}", composer, value, this), value);
                bgComposer.add(bgtaskComposer);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }


        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        //private bool firstClass;
        //public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        protected static BackGroundTaskMgr bgComment = BackGroundTaskMgr.getMgr("Comment", 0);
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                // firstClass = false;
                if (comment != value)
                {
                    //try
                    //{
                    //    var tab0 = comment.Split(' ');
                    //    var tab1 = value.Split(' ');

                    //    var count0 = tab0.GetLength(0);
                    //    var count1 = tab1.GetLength(0);

                    //    if (count0 != count1)
                    //        firstClass = true;

                    //    else if (comment.Length > 3)
                    //    {
                    //        string org = tab0[count0 - 1];
                    //        string fin = tab1[count1 - 1];

                    //        firstClass = !org.Equals(fin);
                    //    }
                    //}

                    //catch
                    //{
                    //    firstClass = true;
                    //}

                    var sb = new StringBuilder();
                    sb.Append(ClassName);
                    sb.Append(".");
                    sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format("{0} change comment from '{1}' to '{2}' {3}", sb.ToString(), comment, value, this), value);

                    //if (firstClass)
                    //    bgFirstClass.add(task);
                    //else
                    bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled = true;
        public bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        private bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        private DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                return playedDate;
            }

            set
            {
                if (playedDate > DateTime.MinValue)
                {
                    var dt = (value - playedDate).TotalHours;
                    if (dt > 2 || dt < -2)
                        playedDate = value;
                    else
                        return;

                }
                playedDate = value;
            }
        }
        protected string location;
        public string Location
        {
            get { return location; }
            set { location = value; }
        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }

            set
            {
                if (!present)
                {
                    grouping = value;
                    return;
                }
                if (grouping != value)
                {
                    var task = new BgTaskGrouping(this, string.Format("change grouping from '{0}' to'{1}' {2}", grouping, value, this), value);
                    bgg.add(task);
                }
            }


        }

        //public void setGrouping(string value, bool prior)
        //{
        //    if (!present)
        //    {
        //        grouping = value;
        //        return;
        //    }
        //    if (grouping != value)
        //    {
        //        bool _delta = false;
        //        // bool _deltaRank = false; 
        //        string rankAlbum = "";
        //        string equivAlbum = "";
        //        if (value != null)
        //        {
        //            string[] org = grouping.Split(' ');
        //            string[] _new = value.Split(' ');

        //            int count = org.GetLength(0);
        //            if (_new.GetLength(0) != count || count < 3)
        //                _delta = true;
        //            else
        //            {
        //                rankAlbum = _new[1];
        //                equivAlbum = _new[2];
        //                if (!org[1].Equals(_new[1]))
        //                {
        //                    _delta = true;
        //                }
        //            }
        //        }

        //        var sb = new StringBuilder();
        //        sb.Append(rankAlbum);
        //        sb.Append(" ");
        //        sb.Append(equivAlbum);
        //        sb.Append(" ");
        //        sb.Append(Album);
        //        //sb.Append(ClassName);
        //        //sb.Append(".");
        //        //sb.Append((Rating / 20).ToString());

        //        var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

        //        if (firstClass)
        //        {
        //            bgSeconClass.add(task);
        //            return;
        //        }

        //        //if (prior)
        //        //{
        //        //    bgGroupPrior.add(task);
        //        //    return;
        //        //}



        //        if (_delta)
        //        {
        //            if (prior)
        //                bgGroupPrior.add(task);
        //            else
        //                bgGroup2nd.add(task);
        //            return;
        //        }

        //        bgg.add(task);

        //        //if (_delta)
        //        //    bgGroupDelta.add(task);
        //        //else
        //        //{
        //        //    bgg.add(task);
        //        //}
        //        //  grouping = value;
        //    }
        //}



        private int volume;
        private static BackGroundTaskMgr bgVolume = BackGroundTaskMgr.getMgr("Volume", 0);
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgVolume.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        public List<CPlayList> PLayLists
        {
            get { return listManager.PLayLists; }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return listManager.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            listManager.AddPlayList(a_playList);
            // className = listManager.ClassName;
        }

        public void removePlayList(CPlayList list)
        {
            listManager.removePlayList(list);
            // className = listManager.ClassName;
        }


        public string ClassName
        {
            get
            {
                className = listManager.ClassName;
                return className;
            }
            set
            {
                className = listManager.ClassName;
                if (className != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        loader.setClassPlayList(this, className, value);
                        className = value;
                    }, this,
                   "change className from '{0}' to'{1}' {2}", className, value, this));


                    //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
                    //className = value;
                    //OnClassNameChange(value);
                }
            }
        }
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }
        private static BackGroundTaskMgr bgDelete = BackGroundTaskMgr.getMgr("Delete", 10);
        public void Delete()
        {
            if (tracktrack != null)
            {
                log.log("!delete! {0}", this);
                tracktrack.Delete();
            }
            else
                bgDelete.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        protected class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComposer : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComposer(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Composer = value;
                    info.composer = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getLocation()
        {
            return location;
        }

        private DateTime added;
        public virtual DateTime Added
        {
            get { return added; }
            set { added = value; }
        }

    }
}



]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInList.cs">
    <content><![CDATA[using System;
using iTunesLib;
using pdb.obj;
using pdb.util;
using System.Threading;
using pdb.ordo;
using pdb.it.persistance;

namespace pdb.it
{
    public class TrackInList : PieceInAList
    {
        private IITFileOrCDTrack track;
        private PlayList playList;
        //  private int index;
        private int trackDataBaseID;
        private BackGroundTaskMgr backGroundTaskMgr;
        private static BackGroundTaskMgr backGroundTaskMgrClass = BackGroundTaskMgr.getMgr("Classement", 0);
        private BackGroundTaskMgr _scan;

      //  private TrackPersistantId persistentId;

        public TrackInList(ITrackMetaData iTrack, IITFileOrCDTrack track)
            : base(iTrack)
        {
            this.track = track;
            this.trackDataBaseID = track.TrackDatabaseID;
            var piece = Piece;
            if (piece != null)
                piece.fillDesc(track); 

        }

        public new TrackInfoItunes Piece { get { return base.Piece as TrackInfoItunes; } }


        public TrackInList(PlayList playList, ITrackMetaData iTrack, int trackDataBaseID)
            : base(iTrack)
        {
            this.playList = playList;
            this.trackDataBaseID = trackDataBaseID;
            _scan = playList.ScanMgr;


        }

        private BackGroundTaskMgr getScanMgr()
        {
            if (_scan == null)
            {
                if (playList != null)
                    _scan = playList.ScanMgr;
            }
            return _scan;
        }

        //  public int Index { get { return index; } set { index = value; } }

        public int TrackDataBaseId { get { return trackDataBaseID; } }

#if VERIF
        public void verif()
        {
            playList.getTrack(this);
        }
#endif


        private IITFileOrCDTrack Track
        {
            get
            {
                if (track == null)
                    playList.findTrack(this);
                return track;
            }

        }

        //public void setTrack(IITFileOrCDTrack track, TrackPersistantId persistentId)
        //{
        //    if (track == null)
        //        return;
        //    this.track = track;
        //    this.persistentId = persistentId;
        //}

        //public void setTrack(TrackId track)
        //{
        //    if (track == null)
        //        return;
        //    setTrack(track.Track, track.Id);

        //}

        public void setTrack(IITFileOrCDTrack track)
        {
            if (track == null)
                return;         
            this.track = track;

            var piece = Piece;
            if (piece != null)
                piece.fillDesc(track); 
        }

        public bool TrackIsNull { get { return track == null; } }

     //   public bool FirstClass { get { return Piece.FirstClass; } set { Piece.FirstClass = value; } }

        public IBgTask locate()
        {
            var task = new BgLocate(this);
            BackGroundTaskMgr.checkScanPriority(getScanMgr(), scanPriority.classement);
            backGroundTaskMgrClass.add(task);
            return task;
        }



        public IBgTask delete()
        {
            var task = new BackGroundDelete(this);

            if (playList.isClassSubList())
            {
                BackGroundTaskMgr.checkScanPriority(getScanMgr(), scanPriority.classement);
                backGroundTaskMgrClass.addAtFirst(task);
            }
            else
            {
                BackGroundTaskMgr.checkScanPriority(getScanMgr(), scanPriority.high);
                if (backGroundTaskMgr == null)
                {
                    lock (this)
                    {
                        if (backGroundTaskMgr == null)
                        {
                            if (playList == null)
                                backGroundTaskMgr = BackGroundTaskMgr.getMgr("TrackList", 1);
                            else
                                backGroundTaskMgr = BackGroundTaskMgr.getMgr("TrackList " + playList.getPath(), 1);
                        }
                    }
                }
                if (playList.Prior < int.MaxValue && playList.Prior >= 0)
                    BackGroundTaskMgr.increaseScanPriority(backGroundTaskMgr, playList.Prior);
                backGroundTaskMgr.add(task);
            }

            return task;
        }

        public override void Delete()
        {
            delete();
        }

        private void invalidationTrack()
        {
            playList.invalidationTrack(this);
            track = null;
        }

        public void DeleteSync(IAbortTask writer)
        {
            lock (this)
            {
                DateTime now = DateTime.Now;

                int nb = 0;
                int nb2 = 0;
                // var _track = Track;
                while (Track == null)
                {
                    if (writer.Aborted) return;
                    //if (deleted)
                    //{
                    //    misc.log("DeleteSync verif 1:track déjà supprimé {0} {1} ", playList, this);
                    //    return;
                    //}
                    Thread.Sleep(30);
                    nb++;
                    if (nb == 100)
                    {
                        nb = 0;
                        nb2++;
                        misc.log("attente suppr synchro {0} {1} {2}", nb2, this, playList);
                        if (nb2 > 100)
                        {
                            misc.log("abort attente suppr synchro {0} {1} {2}", nb2, this, playList);
                            return;
                        }
                    }
                }

                misc.log("DeleteSync {0} {1}", (int)((DateTime.Now - now).TotalMilliseconds), this);
                var tr = Track;
                try
                {

                    DeleteBase();
                    removeTrack();
                    //  deleted = true;
                    if (tr == null)
                    {
                        misc.log("DeleteSync : track null {0} {1} ", playList, this);
                        return;
                    }
                    tr.Delete();
                    // misc.log("track supprimé {0} {1} ", track.playList, track);


                }

                catch (Exception e)
                {
                    invalidationTrack();
                    if (!playList.ContainsLeaf(this))
                    {
                        misc.log("DeleteSync verif 2 : track déjà supprimé {0} {1} ", playList, this);
                        return;
                    }
                    misc.log("DeleteSync impossible de supprimer le track de liste " + this + " " + e.Message);

                    // Thread.Sleep(1000 * Try); 
                }
            }


        }


        public void play()
        {
            if (track == null)
            {
                misc.log("impossible de jouer le track {0}, pas trouvé de correspondant", this);
            }
            else
                track.Play();
        }



        public override bool Equals(object obj)
        {
            if (obj is TrackInList)
            {
                TrackInList o = obj as TrackInList;
                return Location.Equals(o.Location);
            }
            else
                return false;
        }

        public override int GetHashCode()
        {
            return Location.GetHashCode(); 
        }

        public void removeTrack()
        {
            playList.removeTrack(this);
        }

        // private bool deleted;

        private class BgLocate : BgTaskBase
        {
            private TrackInList track;
            private IITFileOrCDTrack iTrack;

            public BgLocate(TrackInList track)
                : base(track.ToString())
            {
                this.track = track;
            }

            public override void exec()
            {
                lock (this)
                {
                    iTrack = track.Track;
                    var pl = track.playList;
                    pl.updatePriority(scanPriority.classement);


                    if (iTrack == null)
                    {
                        if (!pl.MaxScan || pl.isClassSubList())
                            return;
                        Loader.ErreurTrackKist = true;
                        iTrack = new NoTrack(track.Piece);
                    }
                    else
                    {
                        success = true;
                        pl.updatePriority(scanPriority.low);
                    }
                }
            }
        }

        private class BackGroundDelete : BgTaskBase
        {
            private TrackInList track;

            public BackGroundDelete(TrackInList track)
                : base(track.ToString())
            {
                this.track = track;

            }

            public override void exec()
            {
                lock (this)
                {
                    if (!track.playList.Contains(track.Location))
                    {
                        track.playList.Log.log("verif 1:track déjà supprimé {0} {1} ", track.playList, track);
                        success = true;
                        return;
                    }

                    if (track.playList.LogicalTrackInListDeleted(track))
                    {
                        track.playList.Log.log("verif 2:track déjà supprimé {0} {1} ", track.playList, track);
                        success = true;
                        return;
                    }


                    chrono.bip("v"); 
                    var _track = track.Track;
                     chrono.bip("tl");
                    var pl = track.playList;
                  
                   
                    // string path = pl.getPath();
                    if (_track == null)
                    {
                        if (!pl.MaxScan || pl.isClassSubList())
                        {
                            pl.updatePriority(scanPriority.high);
                            return;
                        }
                        //    misc.log("NULL {0} {1} ", track.playList, track); 
                        //Thread.Sleep(1000 * Try); 
                        Loader.ErreurTrackKist = true;
                        _track = new NoTrack(track.Piece);
                    }
                    try
                    {

                        track.DeleteBase();
                        chrono.bip("db");
                        track.removeTrack();
                        chrono.bip("rt"); 
                        // track.deleted = true;
                        _track.Delete();
                        chrono.bip("del"); 
                        // misc.log("track supprimé {0} {1} ", track.playList, track);

                        success = true;
                        pl.updatePriority(scanPriority.low);

                        //bool prior = false;

                        //if (track.backGroundTaskMgr != null && track.backGroundTaskMgr.Contains(path))
                        //    prior = true;
                        //else if (TrackInList.backGroundTaskMgrClass.Contains(path))
                        //    prior = true;
                        //pl.checkPriority(prior); 

                    }

                    catch (Exception e)
                    {
                        track.invalidationTrack();
                        //if (!track.playList.ContainsLeaf(track))
                        //{
                        //    misc.log("verif 2 : track déjà supprimé {0} {1} ", track.playList, track);
                        //    //track.DeleteBase();
                        //    //track.removeTrack();
                        //    //success = true;
                        //    //return;
                        //}
                        //else
                        misc.log("impossible de supprimer le track de liste " + track + " " + e.Message);
                        // track.track = null;
                        // Thread.Sleep(1000 * Try); 
                        //  success = true;
                    }
                }
            }


        }
    }
}
]]></content>
  </file>
</db>
