<db path="C:\bernard\db1\db4">
 <file path="\pdb.player\ViewModel\Commande\ImportCmd.cs">
    <content><![CDATA[using System;
using System.IO;
using pdb.db;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.gen.pertinence;
using pdb.gen.Tuning;
using pdb.player.engine;
using pdb.util;
using pdb.obj;

namespace pdb.player.ViewModel.Commande
{
    class ImportCmd : CommandeBase
    {
        private IIhm ihm;
        //  public static IIhm Ihm { set { ihm = value; } }
        private IPlayerEngine player;
        //public static IPlayerEngine Player { set { player = value; } }
        CListPiece list;

        private int nbImport;
        private int nbFile;
        private Import conf;
       // private DateTime dtImport;

        public ImportCmd(IIhm ihm, IPlayerEngine player)
        {
            this.ihm = ihm;
            this.player = player;
        }
        public override bool CanExecute(object parameter)
        {
            return true;
        }

        public override void Execute(object parameter)
        {
            conf = ihm.getConfImport("Import");
            string dir = conf.dir;
            if (string.IsNullOrEmpty(dir))
                return;
            if (!ihm.Confirm("Importer le contenu de " + dir + " ?", "Import"))
                return;

          //  dtImport = DateTime.Now;
            list = App.Db.List;

            ChronoData.refreshDate(DateTime.MinValue);
            ChronoData.DateAuto = false;
            nbImport = 0;
            nbFile = 0;

            DirectoryInfo root = new DirectoryInfo(dir);
            import(root);
            ChronoData.DateAuto = true;
            ihm.InfoIHm(string.Format("importation de {0} terminée\r\n {1} fichier{2} importé{2} \r\n{3} fichier{4} pris en compte", dir, nbImport, (nbImport > 1 ? "s" : ""), nbFile, (nbFile > 1 ? "s" : "")), "Import");
            App.go(true);
        }

        private void import(DirectoryInfo dir)
        {
            if (dir.Name == "Podcasts")
                return;
            if (dir.Name.StartsWith("poubelle"))
                return;
            if (dir.Name == "hackit")
                return;
            if (dir.Name == "v1")
                return;
            foreach (FileInfo f in dir.GetFiles())
                import(f);
            foreach (DirectoryInfo sub in dir.GetDirectories())
                import(sub);
        }


        private void import(FileInfo f)
        {
           // CPiece _org = null; 
            try
            {
                if (f.IsMusic())
                {
                   var  _org = list.getPiece(f.FullName);
                    if (_org != null)
                    {
                        if (!conf.consolid)
                        {
                            nbFile++;
                            return;
                        }
                    }

                    App.log.log("chargement de " + f.FullName);
                    var newT = new CPiece(f.FullName);
                    var meta = new Metadata(f.FullName);
                    meta.Album = conf.album;
                    meta.Artist = conf.artist;
                    var year = conf.year;
                    if (year != null)
                        meta.Year = year.Value;
                    if (conf.logical)
                    {
                        TrackBuilder.buildFromFile(meta, conf.bname, conf.balbum, conf.bartist, conf.btrackNumber, conf.byear);
                    }
                    if (!conf.Purelogical)
                    {
                        player.load(meta);
                    }
                    TrackBuilder.correction(meta);
                    if (!string.IsNullOrEmpty(conf.album))
                    {
                        meta.TrackNumber = nbFile + 1;
                    }
                    TrackBuilder.buildFrom(newT, meta);


                    App.log.log("chargé {0} {1} {2} {3} {4}", newT.Year, newT.Artist, newT.Album, newT.Name, newT.TrackNumber);

                    var org = list.getPiece(newT);
                    if (org != null)
                    {
                          App.log.log("référence déjà connue : {0} {1} {2} {3} {4} à l'emplacement {5}", org.Year, org.Artist, org.Album, org.Name, org.TrackNumber, org.Location);

                    }


                    list.AddOrMerge(newT, org);
                    if (org == null)
                    {
                        newT.initClassementIfEmpty("0.0");
                        newT.setAdded(DateTime.Now);
                        nbImport++;
                        App.log.log("importé {0} {1} {2} {3} {4} à l'emplacement {5}", newT.Year, newT.Artist, newT.Album, newT.Name, newT.TrackNumber, newT.Location);
                    }
                    nbFile++;
                    App.Db.saveAsync();

                }
            }
            catch (Exception ex)
            {
                App.log.Error(string.Format("impossible d'importer {0} {1}", f.FullName, ex));
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\CListPiece.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
/// <summary>
/// Liste de pieces contenues dans un fichier
/// Liste de pieces � sauvegarder
/// </summary>
/// <remarks>
/// La liste doit s'assurer de l'absence de doublons
/// maintenir une r�f�rence unique pour un morceau
/// 
/// 
/// </remarks>
namespace pdb.db
{
    public interface IReference
    {
        void referenceChange(CPiece piece);
    }

    public class CListPiece : IData, IReference
    {

        public const string TOKEN_LISTS = "lists";
        public const string TOKEN_LIST = "l";
        public const string TOKEN_FOLDER = "f";
        public const string TOKEN_LIST_NAME = "n";
        public const string TOKEN_LIST_TRACK = "t";

        private System.DateTime m_date = System.DateTime.MinValue;

        private DictRef<CPiece> ht = new DictRef<CPiece>();
        private BgDict<int, CPiece> htIds = new BgDict<int, CPiece>();
        private BgDictString<CPiece> htLoc = new BgDictString<CPiece>();
        private PlayList listes = new PlayList("listes");
        public PlayList Listes { get { return listes; } }

        public const string PIECES = "pieces";
        #region "constructeurs"
        /// <summary>
        /// Création à partir d'une simple collection de Piece
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>recherche doublons - merge manuel �ventuel</remarks>
        public CListPiece(ICollection<CPiece> a_list, System.DateTime a_date)
            : this()
        {
            m_date = a_date;
            init(a_list);

            //foreach (CPiece l_file in a_list)
            //{
            //    htIds[l_file.PieceId] = l_file;
            //    foreach (CFile file in l_file.Files)
            //    {
            //        htLoc[file.Path] = l_file;
            //    }
            //}
            foreach (CPiece piece in a_list)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.setParent(htIds[parentId]);
                }

                //if (!piece.Exists)
                //{
                //    misc.log("absent: {0}", piece.PathAndRef + " " + piece.Comment);
                //}
            }



            //DateTime maxEnabled = DateTime.MinValue;
            //foreach (CPiece l_file in a_list)
            //{
            //    Add(l_file);
            //    //if (l_file.Enabled)
            //    //{
            //    //    var t = l_file.LastModifClass;
            //    //    if (t > maxEnabled)
            //    //        maxEnabled = t;
            //    //}
            //}
            //misc.log("***********************************************************");
            //misc.log("maxEnabled: {0}", maxEnabled);
            //misc.log("***********************************************************");
        }


        public void refresh()
        {
            var list = getList();
            ht = new DictRef<CPiece>();
            htIds = new BgDict<int, CPiece>();
            htLoc = new BgDictString<CPiece>();

            init(list);
        }

        private void init(ICollection<CPiece> a_list)
        {
            foreach (CPiece l_file in a_list)
            {
                htIds[l_file.PieceId] = l_file;
                foreach (CFile file in l_file.Files)
                {
                    htLoc[file.Path] = l_file;
                }
            }

            foreach (CPiece l_file in a_list)
            {
                Add(l_file);
            }
        }

        public CListPiece()
        {

        }

        #endregion


        public void checkId(CPiece toCheck)
        {
            foreach (CFile f in toCheck.Files)
            {
                if (htLoc.ContainsKey(f.Path))
                {
                    var pOrg = htLoc[f.Path];
                    toCheck.setId(pOrg.PieceId);
                    toCheck.PieceParentId = pOrg.PieceParentId;
                }
            }
        }

        /// <summary>
        /// merge de la base locale et distante
        /// </summary>
        /// <param name="a_remote"></param>
        /// <remarks></remarks>
        public void Consolid(CListPiece a_remote)
        {
            log("ListPiece:Consolid");
            mergePriority l_remotePriority = mergePriority.none;
            System.DateTime l_remoteDate = a_remote.m_date;
            if (l_remoteDate > System.DateTime.MinValue && l_remoteDate.AddSeconds(-3) > m_date)
                l_remotePriority = mergePriority.right;
            foreach (CPiece l_file in a_remote)
            {
                Consolid(l_file, l_remotePriority);
            }

        }

        public void bilanNatives()
        {
            misc.log("Bilan Natives");
            foreach (CPiece piece in this)
            {
                if (piece.HasNoNative)
                    misc.logNoDate(piece.ToString());
            }
        }

        private void merge(CPiece org, CPiece cand)
        {
            misc.log("CList:Add MERGE with key {0}: {1} // {2}", org.Key, org, cand);
            org.merge(cand);
        }

        public void AddOrMerge(CPiece piece, CPiece org)
        {
            if (org != null)
            {
                org.consolid(piece, mergePriority.right);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
            }
            htIds[piece.PieceId] = piece;
            foreach (CFile file in piece.Files)
            {
                htLoc[file.Path] = piece;
            }


        }


        public void Add(CPiece piece)
        {
            TrackIdentity key = piece.Key;

            CPiece org = null;

            // recherche d'une piece avec un niveau de d�tail �gal ou inf�rieur
            org = ht[key];


            if (org != null)
            {
                misc.log("CList:Add MERGE {0}", key);
                org.merge(piece);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
                htIds[piece.PieceId] = piece;
                foreach (CFile file in piece.Files)
                {
                    htLoc[file.Path] = piece;
                }

            }
        }


        public void fusion(CPiece master, CPiece toDelete)
        {
            if (master == null)
                return;
            if (toDelete == null)
                return;
            if (master == toDelete)
                return;
            misc.log("CList:Fusion  {0}  {1}", master, toDelete);
            master.addDataLink(toDelete);
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);

        }

        public void delete(CPiece toDelete)
        {
            if (toDelete == null)
                return;
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);
            foreach (CFile file in toDelete.Files)
            {
                htLoc.Remove(file.Path);
            }
        }

        public void referenceChange(CPiece piece)
        {
            piece.keyGener();
            ht.Remove(piece);

            piece.keyGener();
            ht.set(piece, piece.Key);

        }






        public bool Contains(CPiece piece)
        {
            var key = piece.Key;
            return ht[key] != null;
        }

        public void Consolid(CPiece remote, mergePriority a_priority)
        {
            if (remote.PieceParentId > 0)
            {
                if (remote.Parent == null)
                    remote.Parent = htIds[remote.PieceParentId];


            }
            CPiece l_pieceOrg = getPiece(remote);

            if (l_pieceOrg == null)
            {
                if (!remote.Deleted)
                {
                    l_pieceOrg = new CPiece();
                    l_pieceOrg.consolid(remote, a_priority);
                    Add(l_pieceOrg);
                }
                else
                    misc.log("remote deleted!! Pourquoi je le trouve pas ?? {0}", remote);
            }
            else
            {
                if (remote.Deleted && a_priority == mergePriority.right)
                {
                    l_pieceOrg.Deleted = true;
                    return;
                }
                if (remote.PieceParentId > 0)
                {
                    var parent = htIds[remote.PieceParentId];
                    misc.log(l_pieceOrg + " a maintenant un parent: " + parent);
                    l_pieceOrg.PieceParentId = remote.PieceParentId;
                    l_pieceOrg.Parent = parent;
                }
                //if (remote.PieceId > 0 && l_pieceOrg.PieceId < 0)
                //    l_pieceOrg.Parent = htIds[remote.PieceParentId];
                l_pieceOrg.consolid(remote, a_priority);
            }
        }

        /// <summary>
        /// synchro enrte base locale et liste native
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        public void legacyConsolid(CPiece native)
        {
            CPiece l_pieceOrg = getPiece(native);

            if (l_pieceOrg == null)
            {
                log("add from business:" + native.ToString());
                l_pieceOrg = new CPiece(native);
                l_pieceOrg.legacyConsolid(native);
                Add(l_pieceOrg);
            }
            else
            {
                l_pieceOrg.legacyConsolid(native);
            }

        }

        private CPiece getPiece(TrackIdentity key)
        {
            return ht[key];
        }

        public CPiece getPiece(ITrackMetaData a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece getPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece tryGetPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return ht.Try(key);
        }

        public CPiece tryGetPieceWithoutId(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return ht.TryWithoutId(key);
        }

        public CPiece getPiece(string location)
        {
            return htLoc[location];
        }

        public CPiece getPiece(int id)
        {
            return htIds[id];
        }

        public void moveId(int oldId, CPiece piece)
        {

        }

        private bool exists(CPiece a_piece)
        {
            return getPiece(a_piece) != null;
        }

        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, PIECES);
            foreach (CPiece l_piece in this)
            {
                l_piece.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, PIECES);
        }

        public void write(System.Xml.XmlWriter w)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                l_piece.write(w);
            }
            w.WriteEndElement();
            w.WriteStartElement(TOKEN_LISTS);
            writeList(w, listes);
            w.WriteEndElement();
        }

        public void writeDiff(System.Xml.XmlWriter w, CListPiece lastFull)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                var org = lastFull.getPiece(l_piece.PieceId);
                try
                {
                    l_piece.writeDiff(w, org);
                }
                catch (Exception ex)
                {
                    misc.log("impossible d'enregistrer les modifs de " + l_piece, ex.ToString());
                }
            }

            foreach (CPiece org in lastFull)
            {
                var newP = this.getPiece(org.PieceId);
                if (newP == null)
                {
                    org.Deleted = true;
                    org.writeDeleted(w);
                }
            }
            w.WriteEndElement();
        }

        #endregion


        public IEnumerator GetEnumerator()
        {
            return ht.GetEnumerator();
        }

        public int Count
        {
            get { return ht.Count; }
        }
        //public System.Collections.Generic.IEnumerator<CPiece> GetEnumerator1()
        //{
        //    return ht.GetEnumerator1();
        //}
        //System.Collections.Generic.IEnumerator<CPiece> System.Collections.Generic.IEnumerable<CPiece>.GetEnumerator()
        //{
        //    return GetEnumerator1();
        //}

        public List<CPiece> getList()
        {
            var list = new List<CPiece>(ht.Count);
            foreach (CPiece p in ht)
            {
                if (!p.Deleted)
                    list.Add(p);
            }

            Sort(list);

            return list;
        }

        public void Sort(List<CPiece> list)
        {
            list.Sort(new PieceComparer());
        }

        private class PieceComparer : IComparer<CPiece>
        {
            public int Compare(CPiece x, CPiece y)
            {
                int cmp = x.MasterId.CompareTo(y.MasterId);
                if (cmp != 0)
                    return cmp;
                cmp = x.PieceParentId.CompareTo(y.PieceParentId);
                if (cmp != 0)
                    return cmp;
                return x.PieceId.CompareTo(y.PieceId);
            }
        }

        private void log(String txt)
        {
            misc.log(txt);
        }


        #region listes
        public void loadListes(XmlElement xml)
        {
            if (xml == null)
                return;
            buildList(xml, listes);
        }

        private void buildList(XmlElement xparent, PlayList parent)
        {
            foreach (XmlElement xsub in xparent.ChildNodes)
            {
                var tool = new XMLTool(xsub);
                if (xsub.Name == TOKEN_LIST)
                {
                    string name = tool.getAttValue(TOKEN_LIST_NAME);
                    int id = tool.getIntAttValue("id");
                    PlayList sub = new PlayList(name, parent);
                    sub.ID = id;
                    CDb.checkId(sub);
                    buildList(xsub, sub);
                }
                else if (xsub.Name == TOKEN_LIST_TRACK)
                {
                    int id = tool.getIntAttValue("id");
                    var piece = htIds[id];

                    // var tl = new TrackList(piece);
                    parent.add(piece);
                }
            }
        }

        private void writeList(XmlWriter w, PlayList parent)
        {
            foreach (PlayList pl in parent.PlayLists)
            {
                w.WriteStartElement(TOKEN_LIST);
                w.WriteAttributeString("id", pl.ID.ToString());
                w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
                writeList(w, pl);
                w.WriteEndElement();
            }

            foreach (IItem t in parent.Items)
            {
                w.WriteStartElement(TOKEN_LIST_TRACK);
                w.WriteAttributeString("id", t.ID.ToString());
                w.WriteEndElement();
            }
            //foreach (PlComponent c in parent)
            //{
            //    if (c is CPlayList)
            //    {
            //        var pl = c as CPlayList;
            //        w.WriteStartElement(TOKEN_LIST);
            //        w.WriteAttributeString("id", pl.ID.ToString());
            //        w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
            //        writeList(w, pl);
            //        w.WriteEndElement();
            //    }
            //    else if (c is TrackList)
            //    {
            //        var t = c as TrackList;
            //        w.WriteStartElement(TOKEN_LIST_TRACK);
            //        w.WriteAttributeString("id", t.PieceId.ToString());
            //        w.WriteEndElement();
            //    }
            //}
        }

        public void buildLists(PlayList listes)
        {
            this.listes.DeleteChilds();
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                CDb.checkId(sub);
                subExt.ID = sub.ID;

                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }
        }
        #endregion
    }

}






]]></content>
  </file>
</db>
