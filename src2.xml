<db path="C:\bernard\db1\db4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.piece.type;
using pdb.db.obj;
using pdb.gen.albums;


namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            var xmlConf = CConf.loadConf();
            pdb.player.ViewModel.Colors.MementoColor.recover();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        private static bool changing;
        public static void setChanging() { changing = true; }
        public static void releaseChanging() { changing = false; }
        public static void invalidateAlbums()
        {
            if (gen == null)
                return;
            if (changing)
                return; 
            gen.invalidateAlbums(); 
        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                var xmlConf = CConf.loadConf();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");



                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0);
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }

        private static void resetOneCl()
        {
            lock (_lock)
            {
                try
                {
                    if (CConf.ResetOneCl)
                    {

                        // CPieceClassement.DateMin = DateTime.MinValue;
                        Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                        var oldKepp = new List<Piece>(); 

                        var _albums = gen.Albums;
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            foreach (Piece t in l)
                            {                               
                                if (t.Keep)
                                {
                                    t.setKeep(0); //t.Keep = false;
                                    oldKepp.Add(t); 
                                    //t.resetMedianneCompact();
                                    //t.invalidateCache(true); 
                                }
                            }
                        }
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            decimal pluspetitNonNull = int.MaxValue;
                            Piece min = null;
                            int nbnotes = 0; 
                            foreach (Piece t in l)
                            {
                                //si on a au moins un noté on quitte

                                //var p = t.Track as CPiece;


                                var cl = t.DeepClassement; // p.Classement.DbValue;
                                decimal clValue = Piece.classementHash.getCache(cl).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                                if (clValue > zer0d)
                                {
                                    nbnotes++; 
                                    if (t.LastClassementRecent || !t.Enabled)
                                    {
                                        min = null;
                                        break;
                                    }
                                    if (clValue < pluspetitNonNull)
                                    {
                                        pluspetitNonNull = clValue;
                                        min = t;
                                    }
                                }

                            }

                            if (min != null)
                            {
                                var coeff = (decimal)nbnotes / l.Count;
                                coeff *= coeff;
                                min.setKeep(coeff); 
                            }
                        }

                        foreach (Piece t in oldKepp)
                        {
                          
                            if (!t.Keep)
                            {
                                t.resetMedianneCompact();
                                t.invalidateCache(true); 
                            }
                        }


                    }
                }
                finally
                {
                    //  CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                }
            }
        }


        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;




            if (CConf.ResetOneCl)
            {
                gen.ConsolidInit(Db.List.getList());
                resetOneCl();
                //CPieceClassement.DateMin = DateTime.MinValue;
                ////Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                //Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                ////foreach (Piece p in gen.sortByClass())
                ////{
                ////    decimal clValue = p.ClassementValueDecimal(false) ;
                ////    if (clValue > zer0d)
                ////    {
                ////        if (clValue >= zer0d)
                ////        {
                ////            var dPiece = Db.getPiece(p.PieceId);
                ////            var strNewCl = "0000" + dPiece.getClassement().ToString();
                ////            var newCl = Classement.create(strNewCl);
                ////            p.Enabled = true;

                ////            p.setClassement(newCl.ClassList, newCl.Rating);
                ////            dPiece.Classement.eraseClassement2(newCl);
                ////        }
                ////        else
                ////            p.Enabled = false;
                ////    }
                ////}

                //var _albums = gen.Albums;
                //foreach (var album in _albums.List)
                //{
                //    var l = album.Tracks;
                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in l)
                //    {
                //        decimal clValue = t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        (min.Track as CPiece).Classement.keepValue();
                //    }
                //}
                ////    foreach (Piece t in l)
                ////    {
                ////        if (t.Parent == null)
                ////        {
                ////            decimal clValue = t.ClassementValueDecimal(false);
                ////            if (t.isClassListNumeric && clValue > zer0d)
                ////            {
                ////                if (clValue > pluspetitNonNull)
                ////                {
                ////                    var dPiece = Db.getPiece(t.PieceId);
                ////                    t.Enabled = true;
                ////                    t.setClassement("0", 0);
                ////                    dPiece.Classement.eraseClassement2();
                ////                }
                ////            }
                ////        }
                ////    }
                ////}

                ////gen.MakeConsolid(Db.List.getList(), true);
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
            }

            gen.MakeConsolid(Db.List.getList(), true);
            gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
        }

        private static void _go()
        {
            try
            {
                Memento.Instance.save();
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                //   gen.compact(); 
                detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                if (PlayerViewModel.Instance.CreateRot)
                {
                    resetOneCl();
                    if (refreshAlbum != null && _currentTrack != null)
                    {
                        gen.Albums.makeSort(_currentTrack.PieceGen);
                        _currentTrack.refresh();
                        refreshAlbum("", EventArgs.Empty);
                    }

                    _currentTrack = null;


                    // if (__end || __go) return;


                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                    gen.MakeConsolid(Db.List.getList(), _updateStats); //   bib.Musique.Tracks);
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, App.bib);
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();


                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);



                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats)
                        {
                            detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => detailClassementViewModel.IhmInDispo = ihmInDispo.none);

                        }
                        else
                            detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats)
                    {
                        _updateStats = false;
                    }
                }
            }


        }

        public static event EventHandler refresh;
        public static event EventHandler refreshAlbum;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Model\ArtWorkManager.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Media.Imaging;
using pdb.db.obj;
using pdb.db;
using System.IO;
using pdb.util.list;
using pdb.util;
using pdb.gen;

namespace pdb.player.model
{
    public class ImagePriority : IComparable<ImagePriority>
    {
        public readonly string label;
        public readonly int value;
        private ImagePriority(string label, int value)
        {
            this.label = label;
            this.value = value;
        }

        public override string ToString()
        {
            return string.Format("{0}={1}", label, value); 
        }

        public static ImagePriority none = new ImagePriority("none", 0);

        public static List<ImagePriority> Values = new List<ImagePriority> {
            new ImagePriority("front", 1),
            new ImagePriority("large", 1), 
            new ImagePriority("cover", 1) , 
            new ImagePriority("folder", 1) , 
            new ImagePriority("small", -1) , 
            new ImagePriority("inlay", -5) , 
            new ImagePriority("label", -6) , 
            new ImagePriority("inside", -7) , 
            new ImagePriority("book", -8) , 
            new ImagePriority("back", -10) , 
            new ImagePriority("cd", -10) 
        
        };
        //front = 1,
        //large = 1,
        //cover=1,
        //folder = 1,

        //none = 0,

        //small = -1,
        //inlay = -5,
        //label = -6,
        //inside = -7,
        //book = -8,
        //back = -10,
        //cd = -20,


        public int CompareTo(ImagePriority other)
        {
            return value.CompareTo(other.value);
        }
    }
    class Img : IComparable<Img>
    {
        public readonly long size;
        public readonly BitmapImage img;
        public readonly ImagePriority priority;
        public readonly string filename;
       
        static Img()
        {
         
        }



        private static ImagePriority getPriority(string filename)
        {
            if (!string.IsNullOrEmpty(filename))
            {
                var f = Path.GetFileNameWithoutExtension(filename).ToLower();
                foreach (ImagePriority ip in ImagePriority.Values)
                {
                    if (f.EndsWith(ip.label))
                    {
                        return ip;
                    }
                }

                foreach (ImagePriority ip in ImagePriority.Values)
                {
                    if (f.Contains(ip.label))
                    {
                        return ip;
                    }
                }
            }

            return ImagePriority.none;
        }

        public Img(BitmapImage img, long size, string filename)
        {
            this.img = img;
            this.size = size;
            this.filename = filename;
            this.priority = getPriority(filename);
        }

        public override string ToString()
        {
            return string.Format("{0} {1} {2}", FileUtil.HumanReadableSize(size, -1), priority, filename);
        }

        //public Img(BitmapImage img, long size,ImagePriority prior)
        //{
        //    this.img = img;
        //    this.size = size;
        //    this.priority = prior; 
        //}

        public int CompareTo(Img other)
        {
            var cmp = priority.CompareTo(other.priority);
            if (cmp != 0)
                return cmp;
            cmp = size.CompareTo(other.size);
            return cmp;
        }
    }
    class ArtWorkManager
    {
        private Dictionary<string, Img> dicttagLib = new Dictionary<string, Img>();
        private Dictionary<string, Img> dictDir = new Dictionary<string, Img>();
        private Dictionary<string, Img> dictAlbum = new Dictionary<string, Img>();
        private Dictionary<int, BitmapImage> dictPiece = new Dictionary<int, BitmapImage>();
        private static Logger log = Logger.getLogger("Img");


        public BitmapImage get(Piece p)
        {

            var piece = p.Track as CPiece;
            if (p == null)
                return null;
            if (dictPiece.ContainsKey(p.MasterId))
            {
                var i = dictPiece[p.MasterId];
                log.log("récup img par id ");
                return i;

            }

            dictPiece.Add(p.MasterId, null);
            Img max = null;



            foreach (CFile f in piece.Files)
            {
                var filename = f.Path;
                if (dicttagLib.ContainsKey(filename))
                {
                    var _l = dicttagLib[filename];
                    if (_l != null && (max == null || _l.CompareTo(max) > 0))
                    {
                        max = _l;
                    }
                    continue;
                }

                dicttagLib.Add(filename, null);
                try
                {
                    if (FileRegister.ExistNow(f.Path))
                    {

                        var file = TagLib.File.Create(filename);

                        foreach (var pict in file.Tag.Pictures)
                        {
                            try
                            {
                                var bin = pict.Data.Data;
                                var name = pict.Description;

                                using (var stream = new MemoryStream(bin))
                                {
                                    BitmapImage i = new BitmapImage();
                                    i.BeginInit();
                                    i.StreamSource = stream;
                                    i.CacheOption = BitmapCacheOption.OnLoad;
                                    i.EndInit();
                                    i.Freeze();
                                    var size = bin.LongLength;
                                    var img = new Img(i, size, name);

                                    if (max == null || img.CompareTo(max) > 0)
                                    {

                                        max = img;
                                        dicttagLib[filename] = max;

                                    }

                                    log.log("load img from tagLib {0} {1}", filename, FileUtil.HumanReadableSize(size, -1));

                                }
                            }

                            catch
                            {
                            }
                        }

                    }

                }
                catch 
                {
                }
            }


            foreach (CFile f in piece.Files)
            {
                var dir = Path.GetDirectoryName(f.Path);

                if (dictDir.ContainsKey(dir))
                {
                    var _l = dictDir[dir];
                    if (_l != null && (max == null || _l.CompareTo(max) > 0))
                    {
                        max = _l;
                    }
                    continue;
                }

                dictDir.Add(dir, null);
                try
                {
                    if (FileRegister.CheckNow(f.Path).ExistsNow)
                    {
                        var fdir = FileRegister.CheckDir(f.Path);
                        foreach (FileValue fimg in fdir.imgs)
                        {
                            try
                            {
                                var bin = File.ReadAllBytes(fimg.FullName);


                                using (var stream = new MemoryStream(bin))
                                {
                                    BitmapImage i = new BitmapImage();
                                    i.BeginInit();
                                    i.StreamSource = stream;
                                    i.CacheOption = BitmapCacheOption.OnLoad;
                                    i.EndInit();
                                    i.Freeze();
                                    var size = bin.LongLength;

                                    var img = new Img(i, size, fimg.FullName);

                                    if (max == null || img.CompareTo(max) > 0)
                                    {
                                        max = img;
                                    }

                                    var item = dictDir[dir];
                                    if (item == null || img.CompareTo(item) > 0)
                                    {
                                        log.log("récup img par dir {0} {1}", dir, FileUtil.HumanReadableSize(size, -1));
                                        dictDir[dir] = img;
                                    }


                                    log.log("load img from src {0} {1}", fimg.FullName, FileUtil.HumanReadableSize(size, -1));

                                }
                            }

                            catch 
                            {
                            }
                        }
                    }



                }

                catch 
                {
                }

            }
            var album = p.PieceAlbum;
            if (p.Virtual && p.Parent != null)
                album = p.Parent.PieceAlbum;
            if (dictAlbum.ContainsKey(album.Key))
            {
                var img = dictAlbum[album.Key];
                if (max == null || img.CompareTo(max) > 0)
                {
                    log.log("récup img par album {0} {1}", p.PieceAlbum.Key, FileUtil.HumanReadableSize(img.size, -1));
                    max = img;
                }
            }



            if (max == null)
                return null;

            if (dictAlbum.ContainsKey(album.Key))
            {
                dictAlbum[album.Key] = max;
            }
            else
                dictAlbum.Add(album.Key, max);

            dictPiece[p.MasterId] = max.img;
            return max.img;
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\AllTracksViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.player.ViewModel.Commande.Link;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.Commande;
using pdb.util;
using System.Globalization;
using pdb.gen.auto;

namespace pdb.player.ViewModel
{
    public enum listDisplay
    {
        all,
        onlyDisabled,
        onlyEnabled
    }

    public class AllTracksViewModel : List<TrackListViewModel>, INotifyCollectionChanged, INotifyPropertyChanged
    {
        public event NotifyCollectionChangedEventHandler CollectionChanged;
        public event PropertyChangedEventHandler PropertyChanged;
        //   private List<TrackListViewModel> tracks;
        private Dictionary<int, TrackListViewModel> dict;
        private object _lock = new object();
        private PlayListViewModel parent;
        private DispatcherOperation ope;



        private bool? onlyDisabled;
        private bool onlyFathers;
        public AllTracksViewModel(PlayListViewModel parent, bool? onlyDisabled, bool onlyFathers)
        {
            this.parent = parent;
            this.onlyDisabled = onlyDisabled;
            this.onlyFathers = onlyFathers;
            //   this.mode = mode; 
            build();
            PlayerViewModel.Instance.resumeChange += playerResumeChange;
            PlayerViewModel.autoChange += new EventHandler(PlayerViewModel_autoChange);
            //TrackListViewModel.CurrentHumanSelectedChanged += PlayerViewModel_autoChange; 
        }

        void PlayerViewModel_autoChange(object sender, EventArgs e)
        {
            OnPropertyChanged("AutoResume");
        }


        void playerResumeChange(object sender, EventArgs e)
        {
            OnPropertyChanged("TV");
            OnPropertyChanged("Resume");
            OnPropertyChanged("AutoResume");
        }

        public string Resume
        {
            get
            {
                return PlayerViewModel.Instance.Resume;
            }
            set
            {

            }
        }

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (CollectionChanged == null)
            //    {
            //    }
            //    else
            //    {
            //        CollectionChanged(this, e); 
            //    }
            //    return; 
            //}

            //dispatcher.Invoke(DispatcherPriority.DataBind, new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e);



            var eventHandler = CollectionChanged;
            if (eventHandler != null)
            {
                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (NotifyCollectionChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        // Invoke handler in the target dispatcher's thread
                        {
                            ope =
                               dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                            handler, this, e);
                            ope.Completed += ope_Completed;


                        }
                        else // Execute handler as is
                            handler(this, e);
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
            else
            {
            }

            // PlayerViewModel.Instance.makeResume();

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("AllTracksViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
            PlayerViewModel.Instance.makeResume();
        }


        protected virtual void OnPropertyChanged(string propertyName)
        {
            var eventHandler = PropertyChanged;
            if (eventHandler == null)
            {
                //   int toto = 0;
            }
            else
            {
                //var dispatcher = Dispatcher.CurrentDispatcher;
                //if (dispatcher.CheckAccess())
                //    PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
                //else
                //    dispatcher.Invoke(new Action<string>(OnPropertyChanged), propertyName);

                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (PropertyChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                          handler, this, new PropertyChangedEventArgs(propertyName));
                        else // Execute handler as is
                            handler(this, new PropertyChangedEventArgs(propertyName));
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
        }

        public void refresh()
        {
            build();
            foreach (TrackListViewModel track in this)
                track.refresh();

        }

        //public void init()
        //{
        //    refresh();
        //    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        //}

        public TrackListViewModel TV { get { return TrackListViewModel.HumanSelected; } }

        public void build()
        {
            lock (_lock)
            {
                var list = new List<TrackListViewModel>();
                var dict = new Dictionary<int, TrackListViewModel>();
                buildAllTraks(list, dict, onlyDisabled, onlyFathers);
                if (this.dict == null)
                {
                    this.dict = new Dictionary<int, TrackListViewModel>();
                    foreach (TrackListViewModel track in list)
                    {
                        Add(track);
                        this.dict.Add(track.PieceId, track);
                        // track.PropertyChanged += track_PropertyChanged;
                    }

                    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
                }
                else
                {

                    foreach (TrackListViewModel newTrack in list)
                    {
                        if (!this.dict.ContainsKey(newTrack.PieceId))
                        {
                            Add(newTrack);
                            this.dict.Add(newTrack.PieceId, newTrack);
                            // newTrack.PropertyChanged += track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, newTrack));
                        }
                    }

                    foreach (TrackListViewModel track in new List<TrackListViewModel>(this))
                    {
                        if (!dict.ContainsKey(track.PieceId))
                        {
                            Remove(track);
                            this.dict.Remove(track.PieceId);
                            // track.PropertyChanged -= track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, track));
                        }
                    }
                }
            }

            //Clear(); 
            //foreach (TrackListViewModel track in parent.Tracks)
            //    Add(track); 
        }

        //void track_PropertyChanged(object sender, PropertyChangedEventArgs e)
        //{
        //    switch (e.PropertyName)
        //    {
        //        case "Duration":
        //        case "Enabled":
        //            PlayerViewModel.Instance.makeResume();
        //            break;
        //    }
        //}

        public List<TrackListViewModel> AllTracks
        {
            get
            {
                build();
                return this;
            }
        }

        public List<TrackListViewModel> Tracks
        {
            get
            {
                return parent.Tracks;
            }
        }

        protected void buildAllTraks(List<TrackListViewModel> container, Dictionary<int, TrackListViewModel> dict, bool? onlyDisabled, bool onlyFathers)
        {
            foreach (TrackListViewModel t in parent.Tracks)
            {
                if (!t.Enabled || true != onlyDisabled)
                {
                    if (onlyDisabled == null && t.Enabled)
                    {
                        if (!t.PieceGen.ClassementProvisoireRecent)
                            continue;
                    }
                    if (t.PieceParentId < 0 || !onlyFathers)
                    {
                        if (!t.Virtual || PlayerViewModel.Instance.WithVirtualAlbum)
                        {

                            if (!dict.ContainsKey(t.PieceId))
                            {
                                dict.Add(t.PieceId, t);
                                container.Add(t);
                                //  t.Index = container.Count; 
                            }
                        }
                    }
                }

            }

            foreach (PlayListViewModel pl in parent)
            {
                AllTracksViewModel other = pl.AlltracksVm;
                //if (true == onlyDisabled)
                //    other = pl.AlltracksVmd;
                //else
                //    other = pl.AlltracksVm;
                other.buildAllTraks(container, dict, onlyDisabled, onlyFathers);
            }
        }

        #region cmd

        private ICommand _contextCmdCheck;
        public ICommand ContextCmdCheck { get { if (_contextCmdCheck == null) _contextCmdCheck = new CheckCmd(); return _contextCmdCheck; } }

        private ICommand _contextCmdUnCheck;
        public ICommand ContextCmdUnCheck { get { if (_contextCmdUnCheck == null) _contextCmdUnCheck = new UnCheckCmd(); return _contextCmdUnCheck; } }


        private ICommand _contextLinkFather;
        public ICommand LinkFather { get { if (_contextLinkFather == null) _contextLinkFather = new LinkFather(); return _contextLinkFather; } }

        private ICommand _contextLinkChild;
        public ICommand LinkChild { get { if (_contextLinkChild == null) _contextLinkChild = new LinkChild(); return _contextLinkChild; } }

        private ICommand _contextLinkFusion;
        public ICommand LinkFusion { get { if (_contextLinkFusion == null) _contextLinkFusion = new LinkFusion(); return _contextLinkFusion; } }

        private ICommand _contextUnLink;
        public ICommand LinkReset { get { if (_contextUnLink == null) _contextUnLink = new LinkReset(); return _contextUnLink; } }

        private ICommand _contextExport;
        public ICommand Export { get { if (_contextExport == null) _contextExport = new ExportCmd(); return _contextExport; } }

        private ICommand _contextExportCompress;
        public ICommand ExportCompress { get { if (_contextExportCompress == null) _contextExportCompress = new ExportCompress(); return _contextExportCompress; } }

        private ICommand _contextDelete;
        public ICommand DeleteTrack { get { if (_contextDelete == null) _contextDelete = new DeleteCmd(); return _contextDelete; } }

        private ICommand _contexExplorer;
        public ICommand Explorer { get { if (_contexExplorer == null) _contexExplorer = new Explorer(); return _contexExplorer; } }

        private ICommand _contextInfo;
        public ICommand Info { get { if (_contextInfo == null) _contextInfo = new InfoCmd(); return _contextInfo; } }



        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(App.Instance); return _ContextCmdAddToList; } }

        private ICommand _ContextCmdDbDeleteClassement;
        public ICommand ContextCmdDbDeleteClassement { get { if (_ContextCmdDbDeleteClassement == null) _ContextCmdDbDeleteClassement = new DbDeleteLastClassement(); return _ContextCmdDbDeleteClassement; } }

        private ICommand _ContextCmdDbDeleteRead;
        public ICommand ContextCmdDbDeleteRead { get { if (_ContextCmdDbDeleteRead == null) _ContextCmdDbDeleteRead = new DbDeleteLastRead(); return _ContextCmdDbDeleteRead; } }


        #endregion

        public TrackListViewModel HumanSelected
        {
            get
            {
                return TrackListViewModel.HumanSelected;
            }
        }

        #region from Ihm
        private TrackListViewModel selectedTrack;
        public TrackListViewModel SelectedTrack
        {
            get
            {
                return selectedTrack;
            }
            set
            {
                selectedTrack = value;
                TrackListViewModel.setHumanSelected(parent, value); //  .HumanSelected = value;
                if (selectedTrack != null)
                    selectedTrack.IsSelected = true;
            }
        }
        #endregion

        private int nbAlbumMoved;

        public int NbAlbumMoved
        {
            get { return nbAlbumMoved; }
        }

        private int nbEmpeached;
        public int NbEmpeached { get { return nbEmpeached; } }

        private void writeConf(StringBuilder sb, ConfMedianneVirt conf)
        {
            var coeff = conf.coeffVirt;
            if (coeff == 1)
                coeff = conf.CoeffOld;
            sb.Append((coeff - 1).FormatE(3)); sb.Append("\t "); //(3,3,9));                  

            sb.Append((conf.v).FormatE(3)); sb.Append("\t ");  //sb.Append("m  ");

            sb.Append(conf.a.FormatE(3)); sb.Append("\t ");
            if (conf.CoeffStaticmRetour > 1)
            {
                sb.Append(conf.CurrentStaticm.FormatE(3)); sb.Append("\t ");
            }


            sb.Append(conf.Serial); sb.Append(" ");
            //  sb.Append(conf.SerialBox); sb.Append(" ");
            // sb.Append(conf.Alt); sb.Append(" ");
            sb.Append(conf.AltHisto); sb.Append("  ");
            sb.Append(conf.Elastique.ToString("0.##")); sb.Append(" ");
            sb.Append(conf.Elastique2.ToString("0.##")); sb.Append(" ");
            sb.Append(conf.DeltaElastiqueDisplay.ToString("0.##")); sb.Append(" ");
            var coeffLot = conf.CoeffLotDisplay; 
            if (coeffLot <1m)
                sb.Append(coeffLot.ToString("#.##"));
        }

        private void check(StringBuilder sb, StringBuilder sb2)
        {
            sb.Append(" ");
            sb2.Append(" ");

            while (sb.Length < sb2.Length)
                sb.Append(" ");
            while (sb2.Length < sb.Length)
                sb2.Append(" ");

        }

        //private void writeConf(StringBuilder sb, ConfMedianneVirt conf, StringBuilder sb2, ConfMedianneVirt conf2)
        //{
        //    sb.Append((conf.coeffVirt - 1).FormatE(4));
        //    sb2.Append((conf2.coeffVirt - 1).FormatE(4));

        //    check(sb, sb2); 

        //    sb.Append((conf.v).FormatE(4));
        //    sb2.Append((conf2.v).FormatE(4));
        //    check(sb, sb2); 

        //    sb.Append(conf.a.FormatE(4));
        //    sb2.Append(conf2.a.FormatE(4));
        //    check(sb, sb2); 

        //    sb.Append(conf.CurrentStaticm.FormatE(3));
        //    sb2.Append(conf2.CurrentStaticm.FormatE(3));
        //    check(sb, sb2);

        //    sb.Append(conf.Serial);
        //    sb2.Append(conf2.Serial);
        //    check(sb, sb2);
        //    //  sb.Append(conf.SerialBox); sb.Append(" ");
        //    // sb.Append(conf.Alt); sb.Append(" ");
        //    sb.Append(conf.AltHisto); 
        //    sb2.Append(conf2.AltHisto);
        //    check(sb, sb2);


        //    sb.Append(conf.Elastique.ToString("0.##"));
        //    sb2.Append(conf2.Elastique.ToString("0.##"));

        //    check(sb, sb2); 
        //    sb.Append(conf.Elastique2.ToString("0.##"));
        //    sb2.Append(conf2.Elastique2.ToString("0.##"));
        //}

        public string AutoResume
        {
            get
            {

                try
                {
                    var confM = App.gen.SortAlbumMode.ComposantsUtiles[0];
                    var conf = confM.Main;
                    var min = confM.Min;
                    var sb = new StringBuilder();



                    //if (min.Use)
                    //{
                    //    var sb2 = new StringBuilder();
                    //    writeConf(sb, conf, sb2, min);
                    //    sb.AppendLine();
                    //    sb.Append(sb2.ToString()); 
                    //}

                    //else
                    //    writeConf(sb, conf);


                    writeConf(sb, conf);
                    if (min.Use)
                    {
                        sb.AppendLine();
                        writeConf(sb, min);
                    }


                    return sb.ToString();

                }
                catch
                {
                    return "";
                }
            }
        }
        public string NbAlbumMovedDesc
        {
            get
            {
                if (nbAlbumMoved < 0)
                    return "";
                if (nbAlbumMoved == 0)
                    return "pas d'album en quarantaine";
                return string.Format("{0} albums en quarantaine", nbAlbumMoved);
            }
        }

        public void setNbAlbum(int nbanavailable, int empeches, int moved)
        {
            if (nbanavailable != this.nbAlbumMovedUnavailable)
            {
                this.nbAlbumMovedUnavailable = nbanavailable;
                OnPropertyChanged("NbAlbumMovedUnavailable");
            }

            if (empeches != nbEmpeached)
            {
                nbEmpeached = empeches;
                OnPropertyChanged("NbEmpeached");
            }

            if (moved != nbAlbumMoved)
            {
                nbAlbumMoved = moved;
                OnPropertyChanged("NbAlbumMoved");
            }
        }

        //public void setNbAlbumMoved(int nb)
        //{
        //    if (nb != nbAlbumMoved)
        //    {
        //        nbAlbumMoved = nb;
        //        OnPropertyChanged("NbAlbumMoved");
        //        OnPropertyChanged("NbAlbumMovedDesc");
        //    }

        //}

        private int nbAlbumMovedUnavailable;
        public int NbAlbumMovedUnavailable
        {
            get
            {
                return nbAlbumMovedUnavailable;
            }

            //set
            //{
            //    if (value != nbAlbumMovedUnavailable)
            //    {
            //        nbAlbumMovedUnavailable = value;
            //        OnPropertyChanged("NbAlbumMovedUnavailable");
            //    }
            //}
        }

    }


}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\DetailAlbumViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Input;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.gen.albums;
using System.Text.RegularExpressions;
using pdb.player.ViewModel.Commande.Link;
using pdb.player.ViewModel.Commande;
using pdb.db;
using System.Windows.Media.Imaging;
using System.IO;
using pdb.util;
using System.Windows.Media;
using pdb.player.model;
using System.Collections.ObjectModel;
using pdb.obj;


namespace pdb.player.ViewModel
{

    public enum albumMode
    {
        identique,
        origine,
        origineSiVirtuel,
        plusLong,
        plusCourt
    }
    class DetailAlbumViewModel : ViewModelBase
    {
        private static ArtWorkManager artworkManager = new ArtWorkManager();
        private TrackListViewModel humanSelected;
        private Album currentAlbum;
        // private List<TrackListViewModel> tracks;
        private albumMode mode;
        private bool albumVirtual;
        private static Logger log = Logger.getLogger("Img");
        private PlayList pl;
        private PlayListViewModel plv;
        public PlayListViewModel PlayListViewModel { get { return plv; } }


        public albumMode Mode
        {
            get
            {
                return mode;
            }
            set
            {
                if (value != mode)
                {
                    mode = value;
                    init(null);
                    OnPropertyChanged("");
                }
            }
        }

        public DetailAlbumViewModel()
        {
            TrackListViewModel.CurrentHumanSelectedChanged += new EventHandler(TrackListViewModel_CurrentSelectedChanged);
        }


        //  private ObservableCollection<ImageSource> images; 

        private void init(TrackListViewModel h)
        {
            // tracks = null;
            img = null;
            //images = new ObservableCollection<ImageSource>() ;
            //  long sizeImgMax = 0;
            // if (humanSelected == null)
            if (h == null)
                humanSelected = TrackListViewModel.HumanSelected;
            if (humanSelected != null)
            {
                var p = humanSelected.PieceGen;
                var idOrg = p.PieceId;

                switch (mode)
                {
                    case albumMode.identique:
                        break;
                    case albumMode.origine: p = p.Master;
                        break;
                    case albumMode.origineSiVirtuel:
                        if (p.Virtual)
                            p = p.Master;
                        break;
                    case albumMode.plusLong:
                        if (p.Virtual)
                        {
                            var virt = p.PieceAlbum.Count;
                            var master = p.Master.PieceAlbum.Count;
                            if (master > virt)
                                p = p.Master;
                        }

                        break;

                    case albumMode.plusCourt:
                        if (p.Virtual)
                        {
                            var virt = p.PieceAlbum.Count;
                            var master = p.Master.PieceAlbum.Count;
                            if (master < virt)
                                p = p.Master;
                        }

                        break;


                    default:
                        break;
                }

                albumVirtual = idOrg != p.PieceId;

                img = artworkManager.get(humanSelected.PieceGen);

                currentAlbum = p.PieceAlbum;
                initAlbums();

            }
            else
            {
                // currentAlbum = null;
                //tracks = new List<TrackListViewModel>();
            }
        }

        //public ObservableCollection<ImageSource> Images
        //{
        //    get
        //    {
        //        return images; 
        //    }
        //}

        void TrackListViewModel_CurrentSelectedChanged(object sender, System.EventArgs e)
        {
            if (humanSelected != TrackListViewModel.HumanSelected)
            {
                init(null);

            }
        }
        private class PieceTrackNumberComparer : IComparer<TrackListViewModel>
        {
            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
                if (cmp != 0)
                    return cmp;
                return x.getLocation().CompareTo(y.getLocation());
                //  return x.TrackNumber.CompareTo(y.TrackNumber);
            }
        }
        private class PieceVirtualClassementComparer : IComparer<TrackListViewModel>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                int cmp = x.PieceGen.VirtualClassement.CompareTo(y.PieceGen.VirtualClassement);


                if (cmp != 0) return -cmp;
                //cmp = x.RapportClassement.CompareTo(y.RapportClassement);
                //if (cmp != 0) return -cmp;
                return tn.Compare(x, y);
                //  return -x.RapportClassement.CompareTo(y.RapportClassement);
            }
        }

        public List<TrackListViewModel> Album
        {
            get
            {
                if (currentAlbum == null || plv == null)
                    return new List<TrackListViewModel>();
                var tracks = plv.Tracks;
                tracks.Sort(new PieceVirtualClassementComparer());
                //int index = 0;
                //foreach (TrackListViewModel t in tracks)
                //{
                //    index++;
                //    t.Index = index;
                //    if (humanSelected != null && t.MasterId == humanSelected.MasterId)
                //        t.IsSelected = true;
                //    else
                //        t.IsSelected = false; 
                //}
                return tracks;

                //var tracks = new List<TrackListViewModel>(); 
                //foreach (var t in currentAlbum.Tracks)
                //{
                //    TrackListViewModel trackList = TrackListViewModel.get(t.PieceId); 
                //    //index++;
                //    //TrackListViewModel trackList = PlayListViewModel.findTrack(App.bib.Musique, t.PieceId);
                //    //if (trackList == null)
                //    //    continue;
                //    //trackList.Index = index;
                //    //if (t.MasterId == humanSelected.MasterId)
                //    //    trackList.IsSelected = true;
                //    //else
                //    //    trackList.IsSelected = false;
                //    tracks.Add(trackList);
                //}
                // //if (tracks != null)
                // //    return tracks;
                //// tracks = new List<TrackListViewModel>();
                // if (currentAlbum == null)
                // {
                //     //tracks = new List<TrackListViewModel>();
                // }
                // else
                // {
                //     // var ll = new List<TrackListViewModel>();

                //   //  int index = 0;
                //     foreach (var t in currentAlbum.Tracks)
                //     {
                //       //  index++;
                //         TrackListViewModel trackList = TrackListViewModel.getOrCreate(t); // PlayListViewModel.findTrack(App.bib.Musique, t.PieceId);
                //         if (trackList == null)
                //             continue;
                //        // trackList.Index = index;
                //         if (t.PieceId == humanSelected.PieceId)
                //             trackList.IsSelected = true;
                //         else
                //             trackList.IsSelected = false;
                //         tracks.Add(trackList);
                //     }
                // }
                //return tracks;

            }
        }

        public TrackListViewModel SelectedTrackInAlbumView
        {
            get
            {


                //var t = humanSelected;


                //if (!albumVirtual)
                //    return t;
                //if (plv != null && !plv.contains(t.PieceId))
                //{
                //    t = plv.Tracks.Find(tt => tt.MasterId == humanSelected.MasterId);
                //    if (t != null)
                //        return t;
                //}
                return humanSelected;

                //if (humanSelected == null)
                //    return null;
                //var tracks = Album;
                //if (tracks == null || tracks.Count == 0)
                //    return null;
                //var tt = tracks.Find(t => t.MasterId == humanSelected.MasterId);
                //return tt;
            }
            set
            {
                if (value == null)
                    return; 
                if (humanSelected != null)
                    humanSelected.IsSelected = false;
                humanSelected = value;
                if (humanSelected != null)
                    humanSelected.IsSelected = true;
               // TrackListViewModel.setHumanSelected(App.bib.Musique, value);
                //  initAlbums(); 
                // TrackListViewModel.HumanSelected = humanSelected; 
                init(humanSelected);
                OnPropertyChanged("");
            }
        }


        #region cmd

        private ICommand _contextCmdCheck;
        public ICommand ContextCmdCheck { get { if (_contextCmdCheck == null) _contextCmdCheck = new CheckCmd(); return _contextCmdCheck; } }

        private ICommand _contextCmdUnCheck;
        public ICommand ContextCmdUnCheck { get { if (_contextCmdUnCheck == null) _contextCmdUnCheck = new UnCheckCmd(); return _contextCmdUnCheck; } }


        private ICommand _contextLinkFather;
        public ICommand LinkFather { get { if (_contextLinkFather == null) _contextLinkFather = new LinkFather(); return _contextLinkFather; } }

        private ICommand _contextLinkChild;
        public ICommand LinkChild { get { if (_contextLinkChild == null) _contextLinkChild = new LinkChild(); return _contextLinkChild; } }

        private ICommand _contextLinkFusion;
        public ICommand LinkFusion { get { if (_contextLinkFusion == null) _contextLinkFusion = new LinkFusion(); return _contextLinkFusion; } }

        private ICommand _contextUnLink;
        public ICommand LinkReset { get { if (_contextUnLink == null) _contextUnLink = new LinkReset(); return _contextUnLink; } }

        private ICommand _contextDelete;
        public ICommand DeleteTrack { get { if (_contextDelete == null) _contextDelete = new DeleteCmd(); return _contextDelete; } }

        private ICommand _contexExplorer;
        public ICommand Explorer { get { if (_contexExplorer == null) _contexExplorer = new Explorer(); return _contexExplorer; } }

        private ICommand _contextInfo;
        public ICommand Info { get { if (_contextInfo == null) _contextInfo = new InfoCmd(); return _contextInfo; } }



        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(App.Instance); return _ContextCmdAddToList; } }

        private ICommand _ContextCmdDbDeleteClassement;
        public ICommand ContextCmdDbDeleteClassement { get { if (_ContextCmdDbDeleteClassement == null) _ContextCmdDbDeleteClassement = new DbDeleteLastClassement(); return _ContextCmdDbDeleteClassement; } }

        private ICommand _ContextCmdDbDeleteRead;
        public ICommand ContextCmdDbDeleteRead { get { if (_ContextCmdDbDeleteRead == null) _ContextCmdDbDeleteRead = new DbDeleteLastRead(); return _ContextCmdDbDeleteRead; } }


        #endregion

        //  static Regex reg = new Regex(@"\[(.*)\]");
        /// <summary>
        /// moche mais pour l'instant on s'en contente
        /// </summary>
        public string Grouping
        {
            get
            {
                return getGrouping(false);
            }
        }

        private string getGrouping(bool albumVirt)
        {
            if (humanSelected == null)
                return "";
            var t = humanSelected.PieceGen;
            if (albumVirt)
                t = humanSelected.PieceGen.Master;

            var a = t.PieceAlbum;
            if (a == null)
                return "";
            string delta = "-";
            var updateClassement = a.UpdateClassement;
            if (updateClassement != null)
                delta = ((int)(DateTime.Now.Date - updateClassement.Value.Date).TotalDays).ToString();

            return string.Format("{0} {1} [{2}] {3}", t.StackIndex, delta, t.RankAlbumReverse, a.EquivLight);

            //var str = t.Grouping;

            //if (!reg.IsMatch(str))
            //    return str;

            //return reg.Match(str).Groups[1].Value;
        }

        public string GroupingAlt
        {
            get
            {
                return getGrouping(true);
            }
        }

        public bool WithVirtualAlbum
        {
            get
            {
                if (humanSelected == null)
                    return false;
                return humanSelected.PieceGen.PieceAlbum.Virtual;
            }
        }

        public string Name
        {
            get
            {
                if (humanSelected == null)
                    return "";
                return humanSelected.Album;
            }
        }

        public string NameAlt
        {
            get
            {
                if (humanSelected == null)
                    return "";
                return humanSelected.Piece.Master.Album;
            }
        }

        #region image
        private ImageSource img;
        public bool HasArtWork
        {
            get
            {
                return img != null;
            }
        }

        public ImageSource ArtWork { get { return img; } }

        #region albums
        public List<TrackListViewModel> Albums { get { return albums; } }
        private List<TrackListViewModel> albums = new List<TrackListViewModel>();
        private void initAlbums()
        {
            if (currentAlbum == null)
                return;

            var _albumName = currentAlbum.Name;
            //if (pl == null || _albumName != pl.Name)
            //{
            pl = new PlayList(_albumName);
            plv = new PlayListViewModel(pl);
            //  plv.setSecondary(); 
            foreach (var t in currentAlbum.Tracks)
            {
                pl.add(t);
            }
            plv.init();
            foreach (TrackListViewModel t in plv.Tracks)
            {
                if (t.PieceId == humanSelected.PieceId)
                    t.IsSelected = true;
                else
                    t.IsSelected = false;
            }
            if (humanSelected == null)
                return;

            albums = new List<TrackListViewModel>();


            foreach (var p in humanSelected.PieceGen.Master)
            {
                var pp = TrackListViewModel.getOrCreate(p); // pl.FindTrack(p.PieceId);
                if (pp != null)
                    albums.Add(pp);
            }
            albums.Sort(new AlbumComparer());

            //foreach (TrackListViewModel t in albums)
            //{
            //    t.IsSelected = t.PieceId == humanSelected.PieceId;
            //}
            //  return albums;
            //TrackListViewModel trackList = TrackListViewModel.getOrCreate(t); // PlayListViewModel.findTrack(App.bib.Musique, t.PieceId);
            //if (trackList == null)
            //    continue;
            //// trackList.Index = index;
            //if (t.PieceId == humanSelected.PieceId)
            //    trackList.IsSelected = true;
            //else
            //    trackList.IsSelected = false;
            //tracks.Add(trackList);
            // }


            //var albums = new List<TrackListViewModel>();
            //if (humanSelected == null)
            //    return albums;
            //var pl_ = PlayListViewModel.SelectedPlayList;
            //if (pl_ == null)
            //    return albums;
            //foreach (var p in humanSelected.PieceGen.Master)
            //{
            //    var pp = TrackListViewModel.getOrCreate(p); // pl.FindTrack(p.PieceId);
            //    if (pp != null)
            //        albums.Add(pp);
            //}
            //albums.Sort(new AlbumComparer());

            //foreach (TrackListViewModel t in albums)
            //{
            //    t.IsSelected = t.PieceId == humanSelected.PieceId;
            //}
            //return albums;


        }



        public TrackListViewModel SelectedTrackInAlbumsView
        {
            get
            {
                return humanSelected;

            }
            set
            {
                if (value == null)
                    return; 
                if (humanSelected != null)
                    humanSelected.IsSelected = false;
                humanSelected = value;
                if (humanSelected != null)
                    humanSelected.IsSelected = true;
                //if (humanSelected != null)
                //    humanSelected.IsSelected = true;
               // TrackListViewModel.setHumanSelected(App.bib.Musique, value); // HumanSelected = value;
                init(humanSelected);
                OnPropertyChanged("");

            }
        }


        private class AlbumComparer : IComparer<TrackListViewModel>
        {
            //private int theOne; 
            //public AlbumComparer(TrackListViewModel humanselected)
            //{
            //    theOne = humanselected.PieceId; 
            //}

            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {

                //if (x.PieceId == theOne)
                //    return -1;
                //if (y.PieceId == theOne)
                //    return 1;
                return x.RankAlbumReverse.CompareTo(y.RankAlbumReverse);
            }
        }
        #endregion
        #endregion

    }
}

]]></content>
  </file>
  <file path="\pdb.player\ViewModel\InfoViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.gen;
using System.Windows.Input;
using pdb.player.ViewModel.Commande;

namespace pdb.player.ViewModel
{

    class InfoViewModel : ViewModelBase
    {
        private List<TrackListViewModel> list = new List<TrackListViewModel>();
        private HashSet<int> hs = new HashSet<int>();


        private bool withAlbum;
        private bool real;
        private bool withParent;


        private string album;
        private string artist;
        private string name;
        private int? trackNumber;
        private int? year;

        private bool applyAlbum;
        private bool applyArtist;
        private bool applyName;
        private bool applyTrackNumber;
        private bool applyYear;

        private bool loading;

        private TrackListViewModel current;

        public InfoViewModel(TrackListViewModel current)
        {
            this.current = current;
            buidList();
            TrackListViewModel.CurrentHumanSelectedChanged += new EventHandler(TrackListViewModel_CurrentHumanSelectedChanged);
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            if (TrackListViewModel.HumanSelected != current)
            {
                this.current = TrackListViewModel.HumanSelected;
                buidList(); 
            }
        }

        public void init()
        {
            string album = null;
            string artist = null;
            string name = null;
            int? tn = null; 
            int? y = null;

            for (int i = 0; i < list.Count; i++)
            {
                var t = list[i];
                if (i == 0)
                {
                    album = t.Album;
                    artist = t.Artist;
                    name = t.Name;
                    if (t.Year > 0)
                        y = t.Year;

                    if (t.TrackNumber > 0)
                        tn = t.TrackNumber;
                }

                else
                {
                    if (t.Album != album)
                        album = null;
                    if (t.Artist != artist)
                        artist = null;
                    if (t.Name != name)
                        name = null;
                    if (y != null && t.Year != y.Value)
                        y = null;
                    if (tn != null && t.TrackNumber != tn.Value)
                        tn = null;
                }
                if (album == null && artist == null && name == null && tn == null && year == null)
                    break;
            }

            Album = album;
            Artist = artist;
            Name = name;
            if (tn.HasValue)
                TrackNumber = tn;
            if (y.HasValue)
                Year = y; 



            applyAlbum = false;
            applyArtist = false;
            applyName = false;
            applyTrackNumber = false;
            applyYear = false;
            OnPropertyChanged(""); 
        }

        private void buildAlbum(Piece t)
        {
            foreach (Piece p in t.PieceAlbum)
            {
                TrackListViewModel tt = TrackListViewModel.getOrCreate(p);
                list.Add(tt);
            }
        }



        private void add(Piece p)
        {
            Piece toInsert = p;
            if (real && p.Virtual)
                p = p.Parent;
            if (hs.Add(p.PieceId))
            {
                TrackListViewModel tt = TrackListViewModel.getOrCreate(p);
                list.Add(tt);
            }
            if (withParent && p.Parent != null)
            {
                p = p = p.Parent;
                if (hs.Add(p.PieceId))
                {
                    TrackListViewModel tt = TrackListViewModel.getOrCreate(p);
                    list.Add(tt);
                }
            }

        }

        private void buidList()
        {
            list.Clear();
            hs.Clear();
            loading = true;
            var source = current.PieceGen;
            if (source.Virtual && real)
                source = source.Parent;


            if (withAlbum)
            {
                foreach (Piece p in source.PieceAlbum)
                {
                    add(p);
                }
            }
            else
                add(source);

            init();
            loading = false;
            OnPropertyChanged("List");
        }

        public void Apply()
        {
            App.setChanging(); 
            foreach (TrackListViewModel t in list)
            {
                if (applyAlbum)
                    t.Album = album;
                if (applyArtist)
                    t.Artist = artist;
                if (applyName)
                    t.Name = name;
                if (applyTrackNumber)
                {
                    if (trackNumber == null)
                        t.TrackNumber = -1;
                    else
                        t.TrackNumber = trackNumber.Value;
                }

                if (applyYear)
                {
                    if (year == null)
                        t.Year = -1;
                    else
                        t.Year = year.Value;
                }

            }

            App.releaseChanging();
            App.invalidateAlbums(); 
            App.go();
        }

        private bool isUnique { get { return list.Count < 2; } }

        public List<TrackListViewModel> List { get { return list; } }

        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value != album)
                {
                    album = value;
                   ApplyAlbum = true;
                   if (!loading) OnPropertyChanged("Album");
                }
            }
        }

        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value != artist)
                {
                    artist = value;
                    ApplyArtist = true;
                    if (!loading)  OnPropertyChanged("Artist");
                }
            }
        }


        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    ApplyName = true;
                    if (!loading) OnPropertyChanged("Name");
                }
            }
        }

        public int? TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (value != trackNumber)
                {
                    trackNumber = value;
                    ApplyTrackNumber = true;
                    if (!loading) OnPropertyChanged("TrackNumber");
                }
            }
        }

        public int? Year
        {
            get
            {
                return year;
            }
            set
            {
                if (value != year)
                {
                    year = value;
                    ApplyYear = true;
                    if (!loading) OnPropertyChanged("Year");
                }
            }
        }

        public bool ApplyAlbum
        {
            get
            {
                return applyAlbum;
            }
            set
            {

                if (value != applyAlbum)
                {
                    applyAlbum = value;
                    if (!loading) OnPropertyChanged("ApplyAlbum");
                }
            }
        }

        public bool ApplyArtist
        {
            get
            {
                return applyArtist;
            }
            set
            {
                if (value != applyArtist)
                {
                    applyArtist = value;
                    if (!loading) OnPropertyChanged("ApplyArtist");
                }
            }
        }

        public bool ApplyName
        {
            get
            {
                return applyName;
            }
            set
            {
                if (value != applyName)
                {
                    applyName = value;
                    if (!loading) OnPropertyChanged("ApplyName");
                }
            }
        }


        public bool ApplyTrackNumber
        {
            get
            {
                return applyTrackNumber;
            }
            set
            {
                if (value != applyTrackNumber)
                {
                    applyTrackNumber = value;
                    if (!loading) OnPropertyChanged("ApplyTrackNumber");
                }
            }
        }

        public bool ApplyYear
        {
            get
            {
                return applyYear;
            }
            set
            {
                if (value != applyYear)
                {
                    applyYear = value;
                    if (!loading) OnPropertyChanged("ApplyYear");
                }
            }
        }


        public bool WithAlbum
        {
            get
            {
                return withAlbum;
            }
            set
            {
                if (value != withAlbum)
                {
                    withAlbum = value;
                    buidList();
                    OnPropertyChanged("WithAlbum");
                }
            }
        }

        public bool WithParent
        {
            get
            {
                return withParent;
            }
            set
            {
                if (value != withParent)
                {
                    withParent = value;
                    buidList();
                    OnPropertyChanged("WithParent");
                }
            }
        }

        public bool Real
        {
            get
            {
                return real;
            }
            set
            {
                if (value != real)
                {
                    real = value;
                    buidList();
                    OnPropertyChanged("Real");
                }
            }
        }


        private ICommand _contextInfo;
        public ICommand Info { get { if (_contextInfo == null) _contextInfo = new InfoCmd(); return _contextInfo; } }






    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\InfoCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.player.ViewModel.Commande
{
    class InfoCmd : CommandeBase
    {
        public override bool CanExecute(object parameter)
        {
            var track = TrackListViewModel.HumanSelected;
            if (track == null)
                return false;            
            return true;
        }

        public override void Execute(object parameter)
        {
            var winfo = new pdb.player.Vue.Info();
            winfo.Show();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="3" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="album"
                       x:Name="dg" x:Uid="album"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="false" 
                                        
                       SelectedItem="{Binding SelectedTrackInAlbumView}">



            <!--<DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>-->

            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox Style="{StaticResource cb}" IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridCheckBoxColumn  ElementStyle="{StaticResource cb}" Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <!--<DataGridCheckBoxColumn Header=""  Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                <DataGridTextColumn Header="" Binding="{Binding Index,Mode=OneWay}" />
                <DataGridTextColumn Header="p" Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="" Binding="{Binding MedianneStatus,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Virtuel" Binding="{Binding ClassementVirtuel,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Virtuel2" Binding="{Binding ClassementVirtuel2,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2,Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>
                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>


                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />

                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}" />
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="Rendement" Binding="{Binding Rendement, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>


                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Keep" Binding="{Binding Keep,Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="NoCompact" Binding="{Binding NoCompact,Mode=OneWay}" />

                <DataGridTextColumn Header="PisteMaster"  Binding="{Binding MainTrackNumber,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="KeepCoeff" Binding="{Binding KeepCoeff, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

            </DataGrid.Columns>


            <DataGrid.ItemContainerStyle>

                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="BorderThickness" Value="0" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exis
                    ts}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},ConverterParameter=album,   UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />




                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected"  Value="True">-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Foreground"  Value="White" />-->
                    <!--<Setter Property="BorderThickness" Value="1" />-->
                    <!--</Trigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <!--<Setter Property="Height"  Value="20" />-->

                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Padding" Value="10,10,10,10" />
                </Style>
            </DataGrid.RowStyle>

            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Info"  Command="{Binding Info}" />
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
        </l:EnhancedDataGrid>
        <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True"  />
        <Grid Grid.Row="2"  Visibility="{Binding HasArtWork, Converter={StaticResource boolVis}}">
            <Image Source="{Binding ArtWork}" ></Image>
            <!--<ListView ItemsSource="{Binding Images}">
                <ListView.ItemTemplate>
                    <DataTemplate>
                        <StackPanel>
                            <Image Source="{Binding}"  />
                        </StackPanel>
                    </DataTemplate>
                </ListView.ItemTemplate>
                <ListView.ItemsPanel>
                    <ItemsPanelTemplate>
                        <StackPanel Orientation="Horizontal" HorizontalAlignment="Stretch" VerticalAlignment="Stretch"></StackPanel>
                    </ItemsPanelTemplate>
                </ListView.ItemsPanel>

            </ListView>-->

            <Image Source="{Binding ArtWork}" ></Image>

        </Grid>
        <Grid Grid.Row="3">

            <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="albums"
                       x:Name="dgalbums" x:Uid="albums"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="False" 
                                SelectedItem="{Binding SelectedTrackInAlbumsView}">
                HeadersVisibility="All" 
                                
                                 >
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album,Mode=OneWay}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="RankRev" Binding="{Binding RankAlbumReverse,Mode=OneWay}" />
                    <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                    <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                    <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                    <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                    <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                    <DataGridTextColumn Header="Recents"  Binding="{Binding NbRecentsInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>



                </DataGrid.Columns>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <!--<Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />-->
                        <Setter Property="FontWeight" Value="Normal" />
                    </Style>
                </DataGrid.ItemContainerStyle>

                <DataGrid.CellStyle>
                    <Style TargetType="DataGridCell">
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=albums, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="BorderBrush" Value="Transparent" />
                    </Style>
                </DataGrid.CellStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                    </Style>
                </DataGrid.RowStyle>


            </l:EnhancedDataGrid>
            <ComboBox Name="cbx_mode" HorizontalAlignment="Right"  Width="20" Height="25" VerticalAlignment="Top" SelectionChanged="cbx_mode_SelectionChanged" >
                <ComboBoxItem  ToolTip="album du morceau sélectionné" >identique</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre" >origine</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre si virtuel" >origine si virtuel</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus long entre le maitre et le virtuel" >le plus long</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus court entre le maitre et le virtuel" >le plus court</ComboBoxItem>
            </ComboBox>



        </Grid>


    </Grid>
</UserControl>  
]]></content>
  </file>
  <file path="\pdb.player\Vue\ClassementCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.ClassementCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid Background="{Binding IhmInDispo, Converter={StaticResource dispo},  UpdateSourceTrigger=PropertyChanged}" >
        <!--<Grid.ColumnDefinitions>
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="3" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>-->
        <!--<DataGrid  Grid.Column="0" DockPanel.Dock="Bottom" 
                       Name="dgAlbum" 
                       AutoGenerateColumns="False" 
                       ScrollViewer.CanContentScroll="True" 
                       SelectedItem="{Binding SelectedTrackInAlbumView}">

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding isSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>

            <DataGrid.Columns>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" />
                <DataGridTextColumn Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement}"/>
            </DataGrid.Columns>

        </DataGrid>
        <GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" />-->

        <Grid Grid.Column="0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="*" />
                <RowDefinition Height="3" />
                <RowDefinition Height="*" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>

            <Grid Grid.Row="0" Margin="5"  >
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto" />
                    <ColumnDefinition Width="Auto" />
                    <ColumnDefinition Width="Auto" />
                    <ColumnDefinition Width="90" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="Auto" />
                </Grid.ColumnDefinitions>
                <CheckBox Grid.Column="0" Style="{StaticResource cb}"  Name="cbEnabled" ToolTip="Afficher seulement les désactivés" IsChecked="{Binding OnlyDisabled, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"  />
                <CheckBox Grid.Column="1" Style="{StaticResource cb}"  Name="cbUncheck" ToolTip="Décocher après classement" IsChecked="{Binding UncheckAfter, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"  />
                <CheckBox Grid.Column="2"  Style="{StaticResource cb}" Name="cbAuto" ToolTip="Passage au morceau suivant automatiquement" IsChecked="{Binding Auto, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"  />
                <TextBox Grid.Column="3"  Name="TbClass"   Text="{Binding Classement, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource cl} }"  />
                <TextBox Grid.Column="4"  Name="TbName" Text="{Binding Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                <Button Grid.Column="5" Name="btRecord" DockPanel.Dock="Right" Content="Enregistrer"  Command="{Binding Record,UpdateSourceTrigger=PropertyChanged}" 
                        />

            </Grid>


            <!--<ListView  DockPanel.Dock="Top" Grid.Row="0" Name="dg"  ScrollViewer.CanContentScroll="True" >
                <ListView.ItemContainerStyle>
                    <Style TargetType="{x:Type ListViewItem}">
                        <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                        <Setter Property="FontWeight" Value="Normal" />
                        <Style.Triggers>
                            <Trigger Property="IsSelected" Value="True">
                                <Setter Property="FontWeight" Value="Bold" />
                            </Trigger>
                        </Style.Triggers>
                    </Style>
                </ListView.ItemContainerStyle>
                <ListView.View>
                    <GridView>
                        <GridViewColumn DisplayMemberBinding="{Binding Enabled}"/>
                        <GridViewColumn DisplayMemberBinding="{Binding Name}"/>
                        <GridViewColumn DisplayMemberBinding="{Binding Classement}"/>
                    </GridView>
                </ListView.View>
            </ListView>-->

            <l:EnhancedDataGrid Grid.Row="1" AutoGenerateColumns="False"  DockPanel.Dock="Top" x:Name="dg" x:Uid="classement"  ScrollViewer.CanContentScroll="True" ConfCouleur="classement" >
                <!--SelectedItem="{Binding SelectedTrackInClassView}" >-->
                <DataGrid.ContextMenu>
                    <ContextMenu>
                        <MenuItem Header="infos" Command="{Binding}"/>
                    </ContextMenu>
                </DataGrid.ContextMenu>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="FontWeight" Value="Normal" />
                        <Style.Triggers>
                            <!--<Trigger Property="IsSelected" Value="True">
                                <Setter Property="Foreground" Value="Brown" />
                            </Trigger>
                            <DataTrigger Binding="{Binding Exists}" Value="False">
                                <Setter Property="Foreground" Value="LightGray" />
                            </DataTrigger>-->

                        </Style.Triggers>
                    </Style>
                </DataGrid.ItemContainerStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">
                        <EventSetter Event="MouseDoubleClick" Handler="dgMouseDoubleClick" />
                        <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />

                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=classement,  UpdateSourceTrigger=PropertyChanged}" />
                       
                        <!--<Style.Triggers>
                            <Trigger Property="DataGridRow.IsSelected" Value="True">
                                <Setter Property="DataGridRow.Background" Value="Brown" />
                            </Trigger>
                          

                        </Style.Triggers>-->
                    </Style>
                </DataGrid.RowStyle>
                <DataGrid.Columns>
                    <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" />-->
                    <DataGridTemplateColumn Header="" >
                        <DataGridTemplateColumn.CellTemplate>
                            <DataTemplate>
                                <CheckBox Style="{StaticResource cb}"  IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                            </DataTemplate>
                        </DataGridTemplateColumn.CellTemplate>
                    </DataGridTemplateColumn>
                    <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                    <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl} }"/>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                    <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                    <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay}"/>
                    <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                    <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                    <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                    <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                    <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>


                </DataGrid.Columns>

            </l:EnhancedDataGrid>


            <GridSplitter Grid.Row="2" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True" />

            <!--<Grid Grid.Row="3" HorizontalAlignment="Stretch">
                <DataGrid ItemsSource="{Binding}" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" 
                       Name="dgStat"  IsReadOnly="True"
          Width="{Binding RelativeSource={RelativeSource AncestorType={x:Type DockPanel}}, Path=ActualWidth}"
                       AutoGenerateColumns="False" >
                    <DataGrid.Columns>
                        <DataGridTextColumn Header="-5" Binding="{Binding -5}"/>
                        <DataGridTextColumn Header="-4" Binding="{Binding -4}"/>
                        <DataGridTextColumn Header="-3" Binding="{Binding -3}"/>
                        <DataGridTextColumn Header="-2" Binding="{Binding -2}"/>
                        <DataGridTextColumn Header="-1" Binding="{Binding -1}"/>
                        <DataGridTextColumn Header="0" Binding="{Binding  0}" >
                            
                        </DataGridTextColumn>
                        <DataGridTextColumn Header="1" Binding="{Binding  1}"/>
                        <DataGridTextColumn Header="2" Binding="{Binding  2}"/>
                        <DataGridTextColumn Header="3" Binding="{Binding  3}"/>
                        <DataGridTextColumn Header="4" Binding="{Binding  4}"/>
                        <DataGridTextColumn Header="5" Binding="{Binding  5}"/>
                    </DataGrid.Columns>
                    <DataGrid.ItemTemplate>
                        <DataTemplate>
                            <TextBlock Text ="{Binding}" Width="Auto"  HorizontalAlignment="Stretch"/>
                        </DataTemplate>
                    </DataGrid.ItemTemplate>
                </DataGrid>
            </Grid>-->
            <Grid Name="tab" Grid.Row="3" >

            </Grid>
            <Grid Grid.Row="4">
                <Grid.RowDefinitions>
                    <RowDefinition  Height="Auto"/>
                    <RowDefinition />
                    <RowDefinition />

                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>
                <!--<TextBlock Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="3" Name="d02" Text="{Binding D02}" />
            <TextBlock Grid.Row="0" Grid.Column="3" Grid.ColumnSpan="3" Name="d35" Text="{Binding D35}" />
            <TextBlock Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="2" Name="d01" Text="{Binding D01}" />
            <TextBlock Grid.Row="1" Grid.Column="2" Grid.ColumnSpan="2" Name="d23" Text="{Binding D23}" />
            <TextBlock Grid.Row="1" Grid.Column="4" Grid.ColumnSpan="2" Name="d45" Text="{Binding D45}" />-->


                <TextBlock Grid.Row="1" Text="{Binding Path=Tracks.Count}" />
                <TextBlock Grid.Row="1" Grid.Column="1" Name="d02" Text="{Binding D02}" />
                <TextBlock Grid.Row="1" Grid.Column="2" Name="d35" Text="{Binding D35}" />
                <TextBlock Grid.Row="1" Grid.Column="3" Name="d01" Text="{Binding D01}" />
                <TextBlock Grid.Row="1" Grid.Column="4" Name="d23" Text="{Binding D23}" />
                <TextBlock Grid.Row="1" Grid.Column="5" Name="d45" Text="{Binding D45}" />
                <TextBlock Grid.Row="2" Grid.Column="0" Name="d0" Text="{Binding D0}" />
                <TextBlock Grid.Row="2" Grid.Column="1" Name="d1" Text="{Binding D1}" />
                <TextBlock Grid.Row="2" Grid.Column="2" Name="d2" Text="{Binding D2}" />
                <TextBlock Grid.Row="2" Grid.Column="3" Name="d3" Text="{Binding D3}" />
                <TextBlock Grid.Row="2" Grid.Column="4" Name="d4" Text="{Binding D4}" />
                <TextBlock Grid.Row="2" Grid.Column="5" Name="d5" Text="{Binding D5}" />
            </Grid>

        </Grid>
    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="main" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Info"  Command="{Binding Info}" />
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox Style="{StaticResource cb}" IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="Exists" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum,Mode=OneWay}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt" Binding="{Binding RankAlbumSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt0" Binding="{Binding RankAlbumZeroSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="DeltaRank" Binding="{Binding DeltaRank, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>

                
                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Mode=OneWay,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLight0"  Binding="{Binding EquivLight0, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLightSt"  Binding="{Binding EquivLightSt, Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Empêché" Binding="{Binding Empeached, UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ClassementValueLightSt"  Binding="{Binding ClassementValueLightSt, Mode=OneWay}" />

                <DataGridTextColumn Header="is" Binding="{Binding Index2,Mode=OneWay}"/>
                <DataGridTextColumn Header="EmpêchéHisto"  Binding="{Binding EmpeachedNb, Mode=OneWay}" />

                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rendement" Binding="{Binding Rendement, Mode=OneWay, Converter={StaticResource decimalEl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="File" Binding="{Binding File, Mode=OneWay}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>



               
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Keep" Binding="{Binding Keep,Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="NoCompact" Binding="{Binding NoCompact,Mode=OneWay}" />

                <DataGridTextColumn Header="PisteMaster"  Binding="{Binding MainTrackNumber,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Recents"  Binding="{Binding NbRecentsInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="KeepCoeff" Binding="{Binding KeepCoeff, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <ContentControl Name="Cctl" Grid.Row="1" >
            <DockPanel Grid.Row="1" Name="dp_status" >
                <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMovedUnavailable,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbEmpeached,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" HorizontalAlignment="Left" Text="{Binding AutoResume,UpdateSourceTrigger=PropertyChanged}" FontWeight="DemiBold" FontSize="11" Margin="0,0,10,0"/>



                <TextBlock DockPanel.Dock="Bottom" FontSize="11" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
            </DockPanel>
        </ContentControl>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Info.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.Info"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
         xmlns:l="clr-namespace:pdb.player.Vue"
        Title="Info" Height="600" Width="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
      
        <Grid Name="infos" Grid.Row="0" Margin="3" >
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>


            <CheckBox Grid.Column="0"  Name="cbName" IsChecked="{Binding ApplyName, UpdateSourceTrigger=PropertyChanged}" />
            <TextBlock Grid.Column="1">Nom</TextBlock>
            <TextBox Grid.Column="2" Name="tbName" Text="{Binding Name, Mode=TwoWay, UpdateSourceTrigger=LostFocus}" />

            <CheckBox Grid.Row="1"  IsChecked="{Binding ApplyAlbum, UpdateSourceTrigger=PropertyChanged}" />
            <TextBlock Grid.Row="1" Grid.Column="1">Album</TextBlock>
            <TextBox Grid.Row="1" Grid.Column="2" Name="tbAlbum" Text="{Binding Album, Mode=TwoWay, UpdateSourceTrigger=LostFocus}" />

            <CheckBox Grid.Row="2" IsChecked="{Binding ApplyArtist, UpdateSourceTrigger=PropertyChanged}" />
            <TextBlock Grid.Row="2" Grid.Column="1">Artiste</TextBlock>
            <TextBox Grid.Row="2" Grid.Column="2" Name="tbArtist" Text="{Binding Artist, Mode=TwoWay, UpdateSourceTrigger=LostFocus}" />

            <CheckBox Grid.Row="3" IsChecked="{Binding ApplyYear, UpdateSourceTrigger=PropertyChanged}" />
            <TextBlock Grid.Row="3" Grid.Column="1">Année</TextBlock>
            <TextBox Grid.Row="3" Grid.Column="2"  Text="{Binding Year, Mode=TwoWay, Converter={StaticResource Int}, UpdateSourceTrigger=LostFocus}" />






        </Grid>
        <l:EnhancedDataGrid Grid.Row="1" x:Name="dgInfo" x:Uid="info" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Info"  Command="{Binding Info}" />
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox Style="{StaticResource cb}" IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="Exists" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum,Mode=OneWay}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt" Binding="{Binding RankAlbumSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt0" Binding="{Binding RankAlbumZeroSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="DeltaRank" Binding="{Binding DeltaRank, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>


                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Mode=OneWay,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}, Mode=OneWay}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLight0"  Binding="{Binding EquivLight0, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLightSt"  Binding="{Binding EquivLightSt, Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Empêché" Binding="{Binding Empeached, UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ClassementValueLightSt"  Binding="{Binding ClassementValueLightSt, Mode=OneWay}" />

                <DataGridTextColumn Header="is" Binding="{Binding Index2,Mode=OneWay}"/>
                <DataGridTextColumn Header="EmpêchéHisto"  Binding="{Binding EmpeachedNb, Mode=OneWay}" />

                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rendement" Binding="{Binding Rendement, Mode=OneWay, Converter={StaticResource decimalEl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="File" Binding="{Binding File, Mode=OneWay}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>




                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Keep" Binding="{Binding Keep,Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="NoCompact" Binding="{Binding NoCompact,Mode=OneWay}" />

                <DataGridTextColumn Header="PisteMaster"  Binding="{Binding MainTrackNumber,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Recents"  Binding="{Binding NbRecentsInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="KeepCoeff" Binding="{Binding KeepCoeff, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <StackPanel Grid.Row="2" Orientation="Horizontal" VerticalAlignment="Bottom" HorizontalAlignment="Left">
            <CheckBox Content="Reel" IsChecked="{Binding Real, UpdateSourceTrigger=PropertyChanged}" />
            <CheckBox Content="Album" IsChecked="{Binding WithAlbum, UpdateSourceTrigger=PropertyChanged}" />
            <CheckBox Content="Avec Parent" IsChecked="{Binding WithParent, UpdateSourceTrigger=PropertyChanged}" />


        </StackPanel>

        <StackPanel Grid.Row="2" Orientation="Horizontal" VerticalAlignment="Bottom" HorizontalAlignment="Right">
          
            <Button Name="btOk" Content="Ok" Click="btOk_Click"/>
            <Button Name="btCancel" Content="Cancel" Click="btCancel_Click" />
        </StackPanel>

    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Info.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using pdb.player.ViewModel;

namespace pdb.player.Vue
{
    /// <summary>
    /// Logique d'interaction pour Info.xaml
    /// </summary>
    public partial class Info : Window
    {
        private InfoViewModel vm; 
        public Info()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(Info_Loaded);
        }

        void Info_Loaded(object sender, RoutedEventArgs e)
        {
            vm = new InfoViewModel(TrackListViewModel.HumanSelected);
            DataContext = vm;
            dgInfo.ItemsSource = vm.List;
            vm.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(vm_PropertyChanged);
        }

        void vm_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "List")
            {
                dgInfo.ItemsSource = null;
                dgInfo.ItemsSource = vm.List; 
            }
        }

       



        private void btOk_Click(object sender, RoutedEventArgs e)
        {
            vm.Apply(); 
        }

        private void btCancel_Click(object sender, RoutedEventArgs e)
        {
            vm.init(); 
        }

       


        private void dg_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            try
            {
                //var r = sender as DataGridRow;
                //var t = r.Item as TrackListViewModel;
                //PlayerViewModel.reset(this, t);
            }
            catch
            {
            }
        }

        private void dg_MouseClick(object sender, MouseButtonEventArgs e)
        {
            ////  e.Handled = true; 
            ////var r = sender as DataGridRow;
            ////var t = r.Item as TrackListViewModel;
            ////TrackListViewModel.setHumanSelected(PlayList, t); //   .HumanSelected = t;
            ////startPoint = e.GetPosition(null);

            //checkItems(false);

            //PlayerViewModel.Instance.makeResume();
        }

       

        private void dg_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            //var mousePos = e.GetPosition(null);
            //var diff = startPoint - mousePos;

            //if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance
            //    || Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
            //{
            //    var treeView = sender as DataGrid;
            //    var treeViewItem = //(e.OriginalSource as DependencyObject).
            //        Util.Util<DataGridRow>.FindAnchestor((DependencyObject)e.OriginalSource);
            //    //   FindAnchestor<TreeViewItem>((DependencyObject)e.OriginalSource);

            //    if (treeView == null || treeViewItem == null)
            //        return;

            //    var folderViewModel = treeView.SelectedItem as TrackListViewModel;
            //    if (folderViewModel == null)
            //        return;

            //    var dragData = new DataObject(folderViewModel);
            //    DragDrop.DoDragDrop(treeViewItem, dragData, DragDropEffects.Copy);
            //}
        }

       
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\PlayerControler.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.PlayerControler"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
              xmlns:local="clr-namespace:pdb.player"
              xmlns:util="clr-namespace:pdb.player.Vue.Util"
             mc:Ignorable="d" 
             d:DesignHeight="167" d:DesignWidth="777">
    <UserControl.Resources>
        <util:StringFormatConverter x:Key="StringFormater" />
        <util:TimeFormatConverter x:Key="TimeSpan" />
        <util:IntFormatConverter x:Key="Int" />
        <Style x:Key="EmptyButtonStyle" TargetType="{x:Type Button}">
            <Setter Property="Background" Value="#00000000"/>
            <Setter Property="BorderBrush" Value="#00000000"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/>
            <Setter Property="HorizontalContentAlignment" Value="Center"/>
            <Setter Property="VerticalContentAlignment" Value="Center"/>
            <Setter Property="Padding" Value="0"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <ContentPresenter 
                        HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
                        Margin="{TemplateBinding Margin}" 
                        RecognizesAccessKey="True" 
                        SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" 
                        VerticalAlignment="{TemplateBinding VerticalContentAlignment}"
                           
                            />
                        
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </UserControl.Resources>
    <Grid Margin="0"  x:Name="gmain" >
        <Grid.Background>
            <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                <GradientStop Color="#fff" Offset="0" />
                <GradientStop Color="#dfdfdf" Offset="1" />
               
            </LinearGradientBrush>

        </Grid.Background>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Name="defNav" Width="Auto" />
            <ColumnDefinition Name="defInfo" Width="*" />
            <ColumnDefinition Name="defFilter" Width="Auto" />
        </Grid.ColumnDefinitions>
        <Grid Margin="10" Grid.Column="0" >
            <StackPanel Orientation="Horizontal" VerticalAlignment="Bottom">

                <Button Name="b_rewind" Height="40" Width="40" Command="{Binding BackWard}" Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Rewind-icon.png"  Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_play" Height="40" Width="40"  Command="{Binding Play,UpdateSourceTrigger=PropertyChanged}"  Style="{DynamicResource EmptyButtonStyle}">
                    <!--<Image Name="I_Play" Source="images\Toolbar-MP3-Play-icon.png"   Height="30" Width="30"></Image>-->
                    <Image Name="I_Play" Source="{Binding SrcPlayPause, UpdateSourceTrigger=PropertyChanged}"   Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_forward" Height="40" Width="40" Command="{Binding Forward}"  Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Forward-icon.png"    Height="30" Width="30" ></Image>
                </Button>
                <Grid Margin="10">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition />
                        <ColumnDefinition />
                        <ColumnDefinition />
                    </Grid.ColumnDefinitions>
                    <TextBlock Text="&lt;)" Grid.Column="0"  VerticalAlignment="Center" Margin="0,0,5,0"/>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="SliderVolume" Width="150" VerticalAlignment="Center" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Volume, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <TextBlock Text="&lt;)))" Grid.Column="2"  VerticalAlignment="Center"  Margin="5,0,00,0"/>
                </Grid>
            </StackPanel>
        </Grid>
       
        <Grid Grid.Column="1">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Name="defName" MaxHeight="50" Height="Auto" />
                    <RowDefinition Name="defPosition" Height="Auto" />
                </Grid.RowDefinitions>

                <StackPanel Grid.Row="0" Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,15,0,0">
                    <Label Name="l_TrackName"  HorizontalAlignment="Center" Content="{Binding Path=CurrentName,  UpdateSourceTrigger=PropertyChanged}"  FontWeight="Bold" Padding="0" Margin="0"></Label>
                    <Label Grid.Row="1" Name="l_trackAuthorAlbum" HorizontalAlignment="Center" Content="{Binding Path=CurrentAuthorAlbum,  UpdateSourceTrigger=PropertyChanged}"  Padding="0" Margin="0"/>
                </StackPanel>
                <Grid Grid.Row="2"  HorizontalAlignment="Stretch" Margin="5">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                        <ColumnDefinition Width="Auto" />
                    </Grid.ColumnDefinitions>
                    <StackPanel Grid.Column="0" Orientation="Horizontal">
                        <CheckBox Style="{StaticResource cb}" Name="cbRot" VerticalAlignment="Center" DockPanel.Dock="Left" ToolTip="calcul des listes" IsChecked="{Binding CreateRot,UpdateSourceTrigger=PropertyChanged}" />
                        <CheckBox Style="{StaticResource cb}" Name="cbEnabled" VerticalAlignment="Center" DockPanel.Dock="Left" ToolTip="Jouer seulement les morceaux cochés" IsChecked="{Binding OnlyEnabled,UpdateSourceTrigger=PropertyChanged}" />
                        <CheckBox Style="{StaticResource cb}" Name="cbAuto" VerticalAlignment="Center" DockPanel.Dock="Left" ToolTip="Position automatique pour classement" IsChecked="{Binding NavAuto,UpdateSourceTrigger=PropertyChanged}" />
                        <Button Name="btSort" Content="  "  Height="15" ToolTip="Configuration du tri par album" Click="btSort_Click" />
                        <!--<ComboBox Name="cbxSort" Height="20" SelectedIndex="{Binding SortAlbumMode, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource sortAlbum} }"  >
                                  <ComboBox.ToolTip>
                                    <TextBlock  xml:space="preserve">
strict          = tri sur moyenne quand aucun des albums n'a défini sa médianne
mix             = tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne
mixLight        = tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light
mixLight2       = tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne
medQuasi        = calcul médianne quasi strict, qq miettes pour éviter le zero
medLight        = calcul Médianne moins strict
medLightSafe   = calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse
medLightSafe2   = calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse                                        
medLightSafe3   = calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse   ...                                     
light           = tri uniquement sur la moyenne
                                    </TextBlock>
                                  </ComboBox.ToolTip>
                            <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur moyenne" Name="mix" >mix</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne quand les deux albums ont défini leur médianne, sinon tri sur medianne light" Name="mixLight" >mixLight</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri sur medianne light quand les deux albums ont défini leur médianne, sinon tri sur moyenne" Name="mixLight2" >mixLight2</ComboBoxItem>
                            <ComboBoxItem ToolTip="Calcul médianne quasi strict, qq miettes pour éviter le zero" Name="medQuasi" >medQuasi</ComboBoxItem>                            
                            <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="medLight" >medLight</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise un morceau au plus pour avoir une estimation basse" Name="medLightSafe" >medLightSafe</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à deux morceaux pour avoir une estimation basse" Name="medLightSafe2" >medLightSafe2</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à trois morceaux pour avoir une estimation basse" Name="medLightSafe3" >medLightSafe3</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 4 morceaux pour avoir une estimation basse" Name="medLightSafe4" >medLightSafe4</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 5 morceaux pour avoir une estimation basse" Name="medLightSafe5" >medLightSafe5</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 6 morceaux pour avoir une estimation basse" Name="medLightSafe6" >medLightSafe6</ComboBoxItem>
                            <ComboBoxItem ToolTip="calcul medLight, on virtualise jusqu'à 10 morceaux pour avoir une estimation basse" Name="medLightSafe10" >medLightSafe10</ComboBoxItem>
                            <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="light" >light</ComboBoxItem>
                        </ComboBox>-->
                        <CheckBox Style="{StaticResource cb}" Name="cbAlbumVirtual" VerticalAlignment="Center" DockPanel.Dock="Left" ToolTip="albums virtuels" IsChecked="{Binding WithVirtualAlbum,UpdateSourceTrigger=PropertyChanged}" Visibility="{Binding WithVirtualAlbum, Converter={StaticResource boolVis}, Mode=OneTime}"/>
                        <CheckBox Style="{StaticResource cb}" Name="cbArtistVirtual" VerticalAlignment="Center" DockPanel.Dock="Left" ToolTip="albums virtuels par artiste" IsChecked="{Binding WithVirtualArtist,UpdateSourceTrigger=PropertyChanged}" Visibility="{Binding WithVirtualAlbum, Converter={StaticResource boolVis}, Mode=OneTime}"/>
                        <Label Name="Duration" DockPanel.Dock="Left" VerticalAlignment="Bottom" Content="{Binding Path=ElapsedTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />

                    </StackPanel>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="PBar"  VerticalAlignment="Bottom" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Position, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <StackPanel Grid.Column="2" Orientation="Horizontal">
                        <Label Name="RemainingTime"   VerticalAlignment="Bottom" Content="{Binding Path=RemainingTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />
                        <Label Content="/" />
                        <Label Name="Length"  VerticalAlignment="Bottom" Content="{Binding Path=Length, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"/>
                    </StackPanel>
                </Grid>
            </Grid>

        </Grid>
        <DockPanel Grid.Column="2" HorizontalAlignment="Stretch" VerticalAlignment="Top" Margin="0,15,0,0">
            <GroupBox Header="Filtre" HorizontalAlignment="Right" DockPanel.Dock="Right">
                <StackPanel Orientation="Horizontal" >
                    <CheckBox x:Name="cbNext" VerticalAlignment="Center" IsChecked="{Binding FilterNext}" ToolTip="Afficher un morceau par album" />
                    <TextBox x:Name="txtFilter" MinWidth="150"  KeyUp="txtFilter_KeyUp" />
                </StackPanel>
            </GroupBox>
        </DockPanel>


    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Util\StringFormatConverter.cs">
    <content><![CDATA[using System;
using System.Windows;
using System.Windows.Data;
using System.Windows.Media;
using pdb.gen;
using pdb.gen.medianne;
using pdb.obj;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Colors;
using pdb.util;
using pdb.gen.conf;

namespace pdb.player.Vue.Util
{
    [ValueConversion(typeof(object), typeof(string))]
    public class StringFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            string format = parameter as string;
            if (!string.IsNullOrEmpty(format))
            {
                return string.Format(culture, format, value);
            }
            else
            {
                return value.ToString();
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TimeSpan), typeof(string))]
    public class TimeFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is TimeSpan)
            {
                TimeSpan ts = (TimeSpan)value;
                return String.Format("{0}:{1}{2}", ts.Minutes, ts.Seconds >= 10 ? "" : "0", ts.Seconds);
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(decimal), typeof(string))]
    public class DecimalFormatEConverter : BaseConverter, IValueConverter
    {
        object IValueConverter.Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            decimal v = (decimal)value;
            if (v <= 0m)
                return ""; 
            return (v).FormatE(4);
        }

        object IValueConverter.ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    [ValueConversion(typeof(decimal), typeof(string))]
    public class DecimalFormatElConverter : BaseConverter, IValueConverter
    {
        object IValueConverter.Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
             decimal v = (decimal)value;
            if (v <= 0m)
                return ""; 
            return (v).FormatE(3);
        }

        object IValueConverter.ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    [ValueConversion(typeof(string), typeof(string))]
    public class ClFormatConverter : BaseConverter, IValueConverter
    {
        static int NB_DEC = 4;
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            var str = value.ToString();
            int count = str.Length;
            return Piece.getReadableCl(str);
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            bool second = false;
            //if (str.StartsWith("0"))
            second = true;
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {

                        if (i > NB_DEC || (i >= NB_DEC && second))
                        {
                            if (!second)
                            {
                                second = true;
                                i = 1;
                            }
                            else
                                i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();


        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (value == null) return "";
            return value.ToString().Replace(" ", "");
        }
    }


    [ValueConversion(typeof(int), typeof(string))]
    public class IntFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return ""; 
            if (value is int)
            {
                int ivalue = (int)value;
                if (ivalue <= 0) return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            int result;
            if (int.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }


    [ValueConversion(typeof(decimal), typeof(string))]
    public class DecimalFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is decimal)
            {
                decimal dvalue = (decimal)value;
                if (dvalue <= 0) return "";
                return dvalue.ToString("0.###");

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            decimal result;
            if (decimal.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }

    [ValueConversion(typeof(DateTime), typeof(string))]
    public class DateToDelaiConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            if (value is DateTime)
            {
                DateTime dvalue = (DateTime)value;
                int delta = (int)((DateTime.Now.Date - dvalue.Date).TotalDays);
                return delta.ToString();

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            decimal result;
            if (decimal.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter0 : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = BgColorFormatConverter.getConf(parameter);

                return BgColorFormatConverter.getColor0(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter00 : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = BgColorFormatConverter.getConf(parameter);

                return BgColorFormatConverter.getcolor00(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }



    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter : BaseConverter, IValueConverter
    {
        public static int ColorMotifSeuil = CConf.ColorMotifSeuil; 
        public static SolidColorBrush getcolor00(TrackListViewModel tv, TrackColor couleurs)
        {
            if (tv.PieceGen.IsNext)
            {
                if (false !=tv.Exists)
                {
                    if (tv.PieceGen.AlmostFree) return couleurs.AlmostFree.Brush;
                    if (tv.PieceGen.AlmostFree1) return couleurs.AlmostFree1.Brush;

                    if (tv.PieceGen.Empeached1) return couleurs.Empeached1.Brush;

                    if (tv.PieceGen.Empeached) return couleurs.Empeached.Brush;
                    if (tv.PieceGen.EmpeachedM) return couleurs.EmpeachedM.Brush;

                    if (tv.PieceGen.Moved) return couleurs.Moved.Brush;
                    if (tv.PieceGen.MovedM) return couleurs.MovedM.Brush;

                    if (tv.PieceGen.AlbumRecentlyUpdated) return couleurs.Recent.Brush;
                    if (tv.PieceGen.AlbumRecentlyUpdatedMain) return couleurs.RecentM.Brush;

                   
                    if (tv.SelectedMotif > selectedCoeff.noCoeff)
                    {
                        if (tv.DeltaRank >= ColorMotifSeuil)
                        {
                            switch (tv.SelectedMotif)
                            {
                                case selectedCoeff.main: return couleurs.nextByCoeffMain.Brush;
                                case selectedCoeff.min: return couleurs.nextByCoeffMin.Brush;
                            }
                        }
                        else
                        {
                            switch (tv.SelectedMotif)
                            {
                                case selectedCoeff.main: return couleurs.nextByCoeffMainSoft.Brush;
                                case selectedCoeff.min: return couleurs.nextByCoeffMinSoft.Brush;
                            }
                        }
                    }

                    return couleurs.Next.Brush;

                }
                return couleurs.NextAbsent.Brush;
            }
            return Brushes.Transparent;
        }

        public static SolidColorBrush getColor0(TrackListViewModel tv, TrackColor couleurs)
        {

            var c = getcolor00(tv, couleurs);
            if (c != Brushes.Transparent)
                return c;

            if (tv.IsSelected) return couleurs.Selected.Brush;


            if (tv.PieceGen.AlmostFree) return couleurs.AlmostFree.Brush;
            if (tv.PieceGen.AlmostFree1) return couleurs.AlmostFree1.Brush;

            if (tv.PieceGen.Empeached1) return couleurs.Empeached1.Brush;

            if (tv.PieceGen.Empeached) return couleurs.Empeached.Brush;
            if (tv.PieceGen.EmpeachedM) return couleurs.EmpeachedM.Brush;

            if (tv.PieceGen.Moved) return couleurs.Moved.Brush;
            if (tv.PieceGen.MovedM) return couleurs.MovedM.Brush;

            if (tv.PieceGen.AlbumRecentlyUpdated) return couleurs.Recent.Brush;
            if (tv.PieceGen.AlbumRecentlyUpdatedMain) return couleurs.RecentM.Brush;

            exportState es = tv.ExportStatus;
            if (false ==tv.Exists)
                es = exportState.miss;
            var exp = couleurs.export;
            switch (es)
            {
                case exportState.none: return exp.none.Brush; // Brushes.White;
                case exportState.miss: return exp.miss.Brush;                //return Brushes.LightGray;
                case exportState.present: return exp.present.Brush; // return Brushes.White;
                case exportState.copy: return exp.copy.Brush; //return Brushes.LightGreen;
                case exportState.delete: return exp.delete.Brush; //return Brushes.DarkGray;
                default:
                    break;
            }

            return Brushes.Transparent;
        }

        public static SolidColorBrush getColor(TrackListViewModel tv, TrackColor couleurs)
        {
            if (tv.IsSelected) return couleurs.Selected.Brush;

            return getColor0(tv, couleurs);
        }

        public static TrackColor getConf(object parameter)
        {
            var conf = Couleurs.Instance.general.track;
            if (parameter != null)
            {
                string path = parameter.ToString();
                var _c = Couleurs.get(path);

                TrackColor _conf = null;

                if (_c is TrackColor)
                    _conf = _c as TrackColor;
                else
                {
                    if (_c is General)
                    {
                        _conf = (_c as General).track;
                    }
                }


                if (_conf != null)
                    conf = _conf;
            }

            return conf;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = getConf(parameter);

                return getColor(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class ForeColorFormatConverter : BaseConverter, IValueConverter
    {
        public SolidColorBrush getColor(TrackListViewModel tv, object parameter)
        {
            //if (tv.PieceGen.IsNext && tv.IsSelected)
            //{
            //    var conf = BgColorFormatConverter.getConf(parameter);
            //    return BgColorFormatConverter.getColor0(tv, conf);
            //}
            if (tv.IsSelected) return Brushes.White;
            return Brushes.Black;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                return getColor(tv, parameter);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(FontWeights))]
    public class FontConverter : BaseConverter, IValueConverter
    {

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                if (tv.IsSelected && tv.PieceGen.IsNext)
                    return FontWeights.Bold;
                return FontWeights.Normal;

            }
            catch
            {

            }
            return FontWeights.Normal;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(ihmInDispo), typeof(Brush))]
    public class ColorDispoConverter : BaseConverter, IValueConverter
    {
        private SolidColorBrush getColor(ihmInDispo info)
        {

            switch (info)
            {
                case ihmInDispo.none: return Brushes.Transparent;
                case ihmInDispo.rot: return Brushes.Gainsboro;
                case ihmInDispo.stat: return Brushes.LightSlateGray;
                default:
                    break;
            }
            return Brushes.White;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                ihmInDispo info = (ihmInDispo)value;
                return getColor(info);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(bool), typeof(System.Windows.Visibility))]
    public class BoolToVis : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is bool)
            {
                return (bool)value ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
            }
            return null;

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (System.Windows.Visibility.Visible.Equals(value)) return true;
            if (System.Windows.Visibility.Collapsed.Equals(value)) return false;
            return null;

        }
    }
    [ValueConversion(typeof(medianneMode), typeof(int))]
    public class SortModeConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is medianneMode)
            {
                return (int)value;
            }
            return null;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                return (medianneMode)(int)(value);
            }
            return null;
        }
    }

    [ValueConversion(typeof(DateTime?), typeof(string))]
    public class DateConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return null;

            if (value is DateTime)
            {
                if (DateTime.MinValue.Equals(value) || DateTime.MaxValue.Equals(value))
                    return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {

            return null;
        }
    }


    [ValueConversion(typeof(selectedCoeff), typeof(string))]
    public class SelectedMotifConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return null;

            if (value is selectedCoeff)
            {
                var motif = (selectedCoeff)value;
                switch (motif)
                {
                    case selectedCoeff.none: return "";
                    case selectedCoeff.noCoeff: return "no";
                    default:
                        return motif.ToString();

                }

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {

            return null;
        }
    }







}
]]></content>
  </file>
  <file path="\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.iit;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Albums;
using pdb.podcast.Auto;
using pdb.podcast.Delta;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Sort;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;
using PlayList = pdb.it.PlayList;
using pdb.podcast.Date0;
using pdb.podcast.Notes;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static ILoader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto;
        static int step = -1;
        static Program _instance = new Program();
        // static bool calculRoots = false;
        static List<HashSet<int>> lists = null;
        static AlbumMgr albumMgr = AlbumMgr.Instance;

        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        public static Chrono chrono = new Chrono();
        private static Logger logChrono;
        private static DB.Db db;

        //public static DB.Db Db { get { return db; } }


        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {

            Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono", true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true;

            FileRegister.init(new Dictionary<string, FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true;

                loader.saveIds();
                //if (db != null)
                //    db.write();

                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                Console.WriteLine("\nFin de l'opération d'enregistrement.");
                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Memory.End();
                Exporter.Abort();

                if (db != null)
                {
                    while (db.Writing)
                    {
                        log.log("waiting db writing");
                        Thread.Sleep(1000);
                    }
                }

                //if (_writeDb != null)
                //{
                //    misc.log("attente writeDb");
                //    _writeDb.Wait();
                //}
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                if (db != null)
                    db.write();
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}

        #region Task


        private List<ITrackInfoItunes> loadTracks(bool firstStep, bool forceLoad)
        {
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
            loader.loadTracks(firstStep, forceLoad, listTrack);

            return listTrack;

        }
        #endregion


        private static void SyncDb(List<TrackInfoItunes> list, bool checkInOut)
        {
            if (db == null)
                return;
            log.log("SyncDb checkInOut= " + checkInOut);
            foreach (TrackInfoItunes t in list)
            {
                if (checkInOut)
                    t.checkInOut();
                var tdb = db.get(t);
                if (tdb == null)
                {
                    log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                    continue;
                }
                tdb.synch(t);

            }
            log.log("Fin SyncDb checkInOut= " + checkInOut);

        }

        public void go(string[] args)
        {
            TrackInfoItunes.AlbumMgr = albumMgr;
            int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            if (countArgs > 0)
                confFile = args[0];
            bool _fin = false;

            Album.logDebug = Logger.getLogger("pubDebug", false);
            Album.log = Logger.getLogger("pub2", Album.logDebug, true);
            Album.logDebug.NoReset = true;
            Album.log.NoReset = true;
            Hibernator hibernator = new Hibernator();
            DateRefBuilder dateRefBuilder = new DateRefBuilder();
            try
            {

                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start(60);

                // bool firstLoad = true;


                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                TrackInfoItunes.setDate0(Conf.Date0);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                TrackInfoItunes.PlayedLevel = Conf.DateLevel;
                var itConf = new pdb.it.Conf(xelt);

                // loader = new Loader(itConf, true);
                bool import = Conf.Import.enabled || Conf.Import.merge;
                db = new DB.Db();


                if (Conf.UseMock)
                    loader = new MockLoader(itConf.DefaultFolder);
                else
                    loader = new Loader(itConf, import, db,
                        () =>
                        {
                            misc.Pre = "[Load " + step + "] ";

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.AbortSpecial();
                            //   Thread.Sleep(1000); 
                            //  BackGroundTaskMgr.Start(); 
                        }, Conf.OnlyEnabled, Conf.OnlyUnRead)

                   ;
                // loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder;

                db.load();
                //  db.write(); return; 

                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();

                List<TrackInfoItunes> listIt = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);




                bool firstlaunched = false;
                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}"));
                        chrono.reset("Program");

                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.setConf(xelt);
                        //loader.Conf = new it.Conf(xelt);
                        // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut", true);
                        List<TrackInfoItunes> list = null;
                        DirConf root = null;
                        if (step == 0 || !Conf.Simulation)
                        {
                            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();


                            listTrack = loadTracks(step == 0, AutoBuilder.MustUpdate);
                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();

                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            // listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {

                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                // loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            //    loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            listIt = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            // GroupStat trackStat = new GroupStat();

                            loader.saveIds();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location)) // || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }
                                    FileRegister.Push(location);
                                    dictLoc[t.Location] = t;
                                    listIt.Add(t);
                                    // if (!t.Played)
                                    //    trackStat.recordTrack(t, typeState.all);
                                    //trackStat.recordTrack(t, typeState.all);
                                }
                            }

                            db.recordIt(listIt);
                            chrono.bip("loadTracks", true);


                            // ici on peut faire la verification des doublons - track hibernés et re-téléchargés par ce con d'itunes
                            var albumConsolid = new AlbumConsolid();
                            foreach (TrackAlbum album in albumMgr.List)
                            {
                                albumConsolid.consolid(album);
                            }

                            log.log("nb123={0} nb12={1} nb13={2} nb23={3} nb1={4} nb2={5} nb3={6} nb0={7}, nb3n={8}",
                                AlbumConsolid.nb123, AlbumConsolid.nb12, AlbumConsolid.nb13, AlbumConsolid.nb23,
                                AlbumConsolid.nb1, AlbumConsolid.nb2, AlbumConsolid.nb3, AlbumConsolid.nb0, AlbumConsolid.nb3n);

                            if (Conf.Import.enabled)
                            {
                                var listImport = new List<TrackInfoItunes>();
                                hibernator.select(Conf.Import, listImport, db.Tracks, true);

                                foreach (TrackInfoItunes tdb in listImport)
                                {
                                    loader.import(tdb);
                                }
                            }
                            else if (Conf.Import.merge)
                            {
                                foreach (TrackInfoItunes t in listIt)
                                    loader.merge(t);
                            }

                            root = Conf.DirConf;
                            var feeds = root.Feeds;

                            list = db.Tracks;
                            foreach (TrackInfoItunes track in list)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds", true);

                            var loaded = feeds.Loaded;
                            loaded.Sort(new PodCastComparer());


                            xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            loader.setConf(xelt);

                            if (Conf.Freewheel)
                            {
                                PlayList.StartOpe();
                                Freewheel(root);
                                log.log("Freewheel : fin sans enregistrement DB");
                                return;
                            }


                            if (Conf.Sort.selectionBefore)
                            {



                                //***************** Lancement "pour de vrai" ***************************************

                                LimitItemLoader.ModeSelection = true;

                                loadCandidat(root);
                                chrono.bip("loadCandidat(root)");
                                //  AutoBuilder.test(); 
                                // standAlone(root); 
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root)");
                                //**********************************************************************************


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, true);
                                //****************************************


                            }



                            if (Conf.Sort.checkBefore)
                            {
                                Album.Init();
                                var sorter = new Sorter(Conf.Sort, list);
                                sorter.build();
                                chrono.bip("sorter.build();", true);


                                if (Album.NbRepeches > 0)
                                {
                                    log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                    _fin = true;
                                }
                            }

                            if (Conf.Import.enabled || Conf.Import.merge)
                            {
                                _fin = true;

                            }



                            if (_fin)
                            {
                                log.log("fin sans enregistrement DB");
                                //  db.write();


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, false);
                                //****************************************
                                return;
                            }


                            if (Album.NbModif > 0)
                            {
                                resetLoad(root);
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                            }
                            bool changeDate = false;
                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            {
                                changeDate = dateRefBuilder.auto(loaded);
                                TrackInfoItunes.setDate0(Conf.Date0);
                                double offsetIni = dateRefBuilder.getOffset();
                                AutoBuilder.Offset = offsetIni;
                            }
                            AutoBuilder.init(true);
                            if (Conf.Sort.stopOnOffset && changeDate)
                            {
                                log.log("fin cause stopOnOffset");
                                return;
                            }

                            if (Conf.Sort.stopOnPub2 && Album.NbModifPertinent > 0)
                            {
                                log.log("fin cause stopOnPub2");
                                return;
                            }

                            AutoBuilder.Offset = 0;
                            chrono.bip("AutoBuilder.init(true)");
                            xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            loader.setConf(xelt);
                          
                            ContexteBuilder.Instance.init(loaded);
                            
                            Conf.DateRef.contexte = ContexteBuilder.Instance.Debut; 
                            dateRefBuilder.saveCurrent();



                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            //trackStat.report(descTrack);
                            //log.log(descTrack.ToString());

                            //var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            //var trackFile = DescBuilder.create("Tracks", sbT);
                            //trackStat.report(trackFile);
                            //sbT.Flush();

                            //asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            //chrono.bip("desc tracks", true);
                            //Logger.LogConsole = false;
                            //        loader.loadLists();
                            Logger.LogConsole = true;
                            chrono.bip("load list", true);

                        }
                        list = db.Tracks;


                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program");
                            root = Conf.DirConf;
                            var feeds = root.Feeds;
                            foreach (TrackInfoItunes track in feeds.getSelectedTracks())
                            {
                                track.clearLists();
                            }

                            feeds.clearSelectedTracks();

                            chrono.bip("track.clearLists", true);

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;




                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true;
                            AutoBuilder.init(true);
                            chrono.bip("AutoBuilder.init(true)");
                            loadCandidat(root);
                            chrono.bip("loadCandidat(root)");
                            //  AutoBuilder.test(); 
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            chrono.bip("Selection(root)");
                            //**********************************************************************************

                            Album.Init();

                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.reset ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.once ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.white ||
                                (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all && !firstlaunched))
                            {
                                if (Sorter.NbLaunch == 0 || (Conf.Sort.enabled != Tuning.Sort.sortMode.white && Conf.Sort.enabled != Tuning.Sort.sortMode.once))
                                {
                                    var sorter = new Sorter(Conf.Sort, list);
                                    sorter.build();
                                }
                                _fin = Conf.Sort.enabled == Tuning.Sort.sortMode.white || Conf.Sort.enabled == Tuning.Sort.sortMode.reset;
                                if (!_fin && Album.NbModif > 0)
                                    resetLoad(root);
                            }

                            firstlaunched = true;

                            if (Album.NbRepeches > 0)
                            {
                                log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                _fin = true;
                            }



                            if (!_fin) // && Album.NbModif == 0)
                            {

                                //***************** Lancement "pour de faux" ***************************************
                                AutoBuilder.Init3();
                                chrono.bip("AutoBuilder.Init3()");
                                LimitItemLoader.ModeSelection = false;
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root) 2");
                                LimitItemLoader.ModeSelection = true;
                                //**********************************************************************************
                            }
                            Exporter.TopCopy();
                            chrono.bip("selection");




                            // Conf.date00Consume();
                            TrackInfoItunes.setDate0(Conf.Date0);

                            int iii = 0;
                            while (!BackGroundTaskMgr.ConfirmEnd(10))
                            {
                                iii++;
                                if (iii == 60)
                                    iii = 0;
                                if (iii == 0)
                                {
                                    log.log("Attente Classement");
                                }
                                Thread.Sleep(100);
                            }






                            if (_fin || Album.NbModif > 0)
                            {
                                log.log("{0} éléments ont la Pub2 modifiée", Album.NbModif);
                                SyncDb(list, true);
                                //foreach (TrackInfoItunes t in list)
                                //{
                                //    var tdb = db.get(t);
                                //    if (tdb == null)
                                //    {
                                //        log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                //        continue;
                                //    }
                                //    tdb.synch(t);

                                //}

                                db.writeAsync();

                                if (_fin)
                                {
                                    log.log("fin");
                                    return;
                                }
                                // continue;
                            }




                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    //if (count == 1)
                                    //    s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu");

                            if (Conf.GenFeed)
                            {
                                foreach (RootItItem rootItem in Conf.RootIt)
                                {
                                    var fAuto = loader.TreePlayList.getComposite(rootItem.name);
                                    var fFeeds = fAuto.getComposite("Feed");

                                    if (fFeeds != null)
                                    {
                                        scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                    }

                                }
                            }


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root, false);
                            //****************************************



                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                            //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            chrono.bip("AutoBuilder.init(false)");
                            bool cangoAuto = AutoBuilder.Check(feeds);

                            chrono.bip("AutoBuilder");
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");

                                postReport(root, true);

                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false;
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true;
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                //  tw = new StringBuilder();
                                //feeds.rapportPreSelected(tw);
                                //asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false;
                                log.log(sb2.ToString());
                                Logger.LogConsole = true;


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false;
                                log.log(sb3.ToString());
                                Logger.LogConsole = true;
                                chrono.bip("rapport", true);
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 

                        SyncDb(list, true);
                        db.writeAsync();


                        Logger.CreateNullLoggers = false;


                        lists = null;
                        WritePlayList(root);




                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;

                            Dictionary<string, Dictionary<int, TrackInfoItunes>> depots = new Dictionary<string, Dictionary<int, TrackInfoItunes>>();
                            foreach (SelectParam p in listP)
                            {

                                listS = new List<TrackInfoItunes>();
                                if (!string.IsNullOrEmpty(p.name))
                                {
                                    // Compatibilité anciennes listes
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                    buildList("_" + p.level, listS, prior, folder);
                                }
                                else
                                {

                                    var pp = p.Clone() as SelectParam;
                                    feeds.buildFirstSelectedTrackLevel(listS, p);

                                    var l = new List<TrackInfoItunes>();

                                    pp.nb = int.MaxValue;
                                    var selector = new TrackSelector(pp);
                                    foreach (TrackInfoItunes t in listS)
                                    {
                                        if (selector.select(t))
                                            l.Add(t);
                                    }

                                    string path = p.path;
                                    if (!string.IsNullOrWhiteSpace(path))
                                        buildList(path, l, prior);

                                    string[] _depots = p.depot;
                                    if (_depots != null)
                                    {
                                        foreach (string depot in _depots)
                                        {
                                            if (!depots.ContainsKey(depot))
                                                depots.Add(depot, new Dictionary<int, TrackInfoItunes>());

                                            var dep = depots[depot];
                                            foreach (TrackInfoItunes t in l)
                                            {
                                                if (!dep.ContainsKey(t.DbId))
                                                    dep.Add(t.DbId, t);
                                            }
                                        }
                                    }
                                }
                            }

                            foreach (KeyValuePair<string, Dictionary<int, TrackInfoItunes>> kvp in depots)
                            {
                                string path = kvp.Key;

                                var l = new List<TrackInfoItunes>(kvp.Value.Values);
                                l.Sort(new PodcastComparerPubPub2());
                                buildList(path, l, prior);
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);

                        var listSelected = root.Feeds.getSelectedTracks();

                        var sorterafter = new Sorter(Conf.Sort, list);
                        //    sorter.build();

                        foreach (TrackInfoItunes s in listSelected)
                        {
                            s.updateNative();
                        }






                        //if (Conf.Hibernate.enabled)
                        //{
                        //    Hibernator hibernator = new Hibernator();
                        //    var nb = hibernator.go(loader); 
                        //    if (nb >0)
                        //    {
                        //        misc.log("{0} elements hibernés", nb);
                        //        misc.log("fin ");
                        //        return; 
                        //    }

                        //}


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                log.log("Attente Classement");
                            }
                            Thread.Sleep(100);
                        }



                        //if (Conf.Sort.enabled >= Tuning.Sort.sortMode.once_all)
                        //{
                        //    var sorter = new Sorter(Conf.Sort, list);
                        //    sorter.build();
                        //}

                        int nbH = 0;
                        _fin = false;
                        if (Conf.Hibernate.enabled)
                        {
                            nbH = hibernator.go(loader, list);
                            if (nbH > 0)
                            {
                                log.log("{0} elements hibernés", nbH);
                                _fin = true;
                            }
                        }

                        if (loader.NbTrackCreated > 0)
                        {
                            log.log("{0} éléments ont été recréés", loader.NbTrackCreated);
                            _fin = true;
                        }

                        if (Album.NbRepeches > 0)
                        {
                            log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                            _fin = true;
                        }



                        if (Conf.UseMock)
                            _fin = true;



                        if (_fin)
                        {


                            log.log("fin");

                            return;
                        }





                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");



                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in db.Tracks)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogAll(ex.ToString());
                        misc.log(ex.ToString());
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        //private DirConf _attenteWriteHtml;
        // private volatile object _lockReportHtml = new object();
        private bool _end;
        // ThreadUtil thReport;
        DateTime lastReport;

        private void postReport(DirConf dir, bool force)
        {
            if (force || lastReport.AddSeconds(10) < DateTime.Now)
            {
                try
                {
                    reportHtml(dir);
                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                lastReport = DateTime.Now;
            }
            //if (thReport == null)
            //{
            //    lock (_lockReportHtml)
            //    {
            //        if (thReport == null)
            //        {
            //            thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
            //            thReport.Start();
            //        }
            //    }
            //}

            //lock (_lockReportHtml)
            //    _attenteWriteHtml = dir;
        }

        //private void loopReportHtml()
        //{
        //    DirConf traite = null;
        //    while (!_end)
        //    {
        //        Thread.Sleep(1000);
        //        if (_attenteWriteHtml == null)
        //            continue;
        //        lock (_lockReportHtml)
        //        {
        //            if (_attenteWriteHtml == null)
        //                continue;
        //            traite = _attenteWriteHtml;
        //            _attenteWriteHtml = null;
        //        }
        //        reportHtml(traite);
        //    }
        //}


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
                //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
                //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders, false);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders, false);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders, false);
        }

        public static void buildList(string path, List<TrackInfoItunes> list_, int prior)
        {
            bool absolutePath = path.StartsWith(@"\");
            var tab = path.Split('\\');
            int count = tab.GetLength(0);
            var folder = new List<string>();

            foreach (string s in tab)
            {
                if (!string.IsNullOrWhiteSpace(s))
                    folder.Add(s);
            }

            buildList(list_, prior, folder, absolutePath);
        }



        public static void buildList(List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            var newf = new List<string>(folders);
            int count = newf.Count;

            string name = newf[count - 1];
            newf.RemoveAt(count - 1);
            buildList(name, list_, prior, newf, absolutePath);
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            try
            {
                if (Conf.Simulation)
                    return;
                if (Conf.UseMock)
                {
                    var sb = new StringBuilder();
                    foreach (string f in folders)
                    {
                        sb.Append(f); sb.Append(@"\");
                    }
                    sb.Append(name);
                    log.logNoDate("---------------------------");
                    log.log("liste {0}", sb.ToString());
                    if (list_ != null)
                    {
                        foreach (TrackInfoItunes t in list_)
                        {
                            log.logNoDate(t.ToString());
                        }
                    }
                    return;
                }

                if (list_ != null)
                {
                    foreach (TrackInfoItunes track in list_)
                    {
                        loader.reviveIfNecessary(track);
                    }
                }



                var rootIt = Conf.RootIt;
                RootItItem currentRoot = rootIt.roots[0];
                int count = rootIt.roots.Count;

                if (list_ != null)
                {
                    //   log.log("build list {0}",name);
                    //  var list = new List<IFile>(list_);
                    if (lists == null)
                    {
                        lists = new List<HashSet<int>>();
                        foreach (var item in rootIt.roots)
                        {
                            lists.Add(new HashSet<int>());
                        }
                        var list__ = new List<TrackInfoItunes>(list_);
                        list__.Sort(new PodcastComparerPubPub2());



                        int countTrack = list_.Count;

                        long size = 0;
                        int j = 0;
                        int indexRoot = 0;

                        //    HashSet<int> current = lists[0]; 

                        while (true)
                        {
                            if (j >= countTrack)
                                break;
                            TrackInfoItunes track = list__[j];
                            size += track.Size;
                            if (size <= currentRoot.size)
                            {
                                lists[indexRoot].Add(track.DbId);
                                // track.IndexRoot = indexRoot;
                            }
                            else
                            {

                                size = 0;
                                //  size += track.Size;
                                indexRoot++;
                                if (indexRoot >= count)
                                    break;
                                currentRoot = rootIt.roots[indexRoot];
                                continue;
                            }
                            j++;
                        }

                    }
                }


                for (int r = 0; r < count; r++)
                {
                    currentRoot = rootIt.roots[r];
                    folders = new List<string>(folders);
                    PlayListComposite folder = null;

                    if (absolutePath)
                    {
                        if (r > 0)
                            throw new Exception("un chemin absolu ne peut pas être géré dans une partition");
                        // folders[0] = folders[0].Substring(1);
                        folder = loader.TreePlayList;

                    }
                    else
                        folder = loader.TreePlayList.getComposite(currentRoot.name);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(currentRoot.name);


                    var nname = name;
                    if (name.Contains(Path.DirectorySeparatorChar.ToString()))
                    {
                        var tab = name.Split(Path.DirectorySeparatorChar);
                        string str = null;
                        for (int i = 0; i < tab.GetLength(0); i++)
                        {
                            if (str != null)
                                folders.Add(str);
                            if (!string.IsNullOrEmpty(tab[i]))
                                str = tab[i];
                        }
                        if (!string.IsNullOrEmpty(str))
                            nname = str;
                    }
                    List<IFile> l = null;

                    if (list_ != null)
                    {
                        l = new List<IFile>();
                        foreach (TrackInfoItunes t in list_)
                        {
                            if (lists[r].Contains(t.DbId))
                                l.Add(t);
                        }
                    }


                    for (int i = 0; i < folders.Count; i++)
                    {
                        var aux = folder;
                        folder = folder.getComposite(folders[i]);
                        if (folder == null)
                            folder = loader.getOrCreateFolder(aux, folders[i], l == null ? true : l.Count > 0);
                        if (folder == null)
                            return;
                    }

                    //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
                    var playlist = loader.getPlayList(folder, nname, l == null ? true : l.Count > 0);
                    if (playlist != null)
                    {
                        if (prior < int.MaxValue && prior >= 0)
                            playlist.setPrior(prior);
                        //if (list.Count > 0)


                        playlist.mergeList(l, _instance, Conf.OnlyEnabled, Conf.OnlyUnRead);
                        //  loader.mergeList(playlist, l, false, _instance, null);
                        //else
                        //    loader.removeList(folder, name);
                    }



                    //log.log("clear list {0}", name); 
                    //loader.ClearList(playlist);
                    //log.log("add items {0}", name); 
                    //foreach (TrackInfoItunes track in list)
                    //    loader.addItemToList(playlist, track); 

                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }


        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildGlobalList(string path, List<TrackInfoItunes> list_, int prior)
        {
            PlayListComposite folder = null;
            List<string> folders = new List<string>();
            string nname = "";
            if (Conf.UseMock)
                return;
            try
            {

                var tab = path.Split(Path.DirectorySeparatorChar);
                string str = null;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    if (str != null)
                        folders.Add(str);
                    if (!string.IsNullOrEmpty(tab[i]))
                        str = tab[i];
                }
                if (!string.IsNullOrEmpty(str))
                    nname = str;

                folder = loader.TreePlayList;





                var l = new List<IFile>();
                foreach (TrackInfoItunes t in list_)
                {
                    if (t.Present)
                        l.Add(t);
                }

                for (int i = 0; i < folders.Count; i++)
                {
                    var aux = folder;
                    folder = folder.getComposite(folders[i]);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(aux, folders[i], l.Count > 0);
                    if (folder == null)
                        return;
                }


                var playlist = loader.getPlayList(folder, nname, l.Count > 0);
                if (playlist != null)
                {
                    if (prior < int.MaxValue && prior >= 0)
                        playlist.setPrior(prior);


                    playlist.mergeList(l, _instance, false, false);

                }



            }

            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }




        }

        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            DateTime now = DateTime.Now;

            fLoader.Action(pre);
            var ts = (DateTime.Now - now).TotalMilliseconds;
            if (ts > 1 && Conf.LogDir && pre > action.none && pre < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", pre, dir.getPath(), ts.ToString("0"));
            }

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());

            now = DateTime.Now; ts = (DateTime.Now - now).TotalMilliseconds;
            fLoader.Action(post);

            if (ts > 1 && Conf.LogDir && post > action.none && post < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", post, dir.getPath(), (DateTime.Now - now).TotalMilliseconds.ToString("0"));
            }


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }

        private void resetLoad(DirConf dir)
        {
            recursif(dir, action.resort, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void Freewheel(DirConf dir)
        {
            dir.Loader.LimitsLoader.Freewheel();
        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
            List<TrackInfoItunes> list = null;
            //  var list = db.Tracks.FindAll(t => t.Present);
            //var list = db.Tracks.FindAll(t => t.isConcernedBySelection); 
            if (Conf.UseMock)
                list = db.Tracks.FindAll(t => t.isConcernedBySelection && t.isPodcast);
            else
                list = db.Tracks.FindAll(t => t.Present && t.isConcernedBySelection && t.isPodcast);
            foreach (SelectParamBase listeGlobal in Conf.GlobalListes)
            {
                var selector = new TrackSelector(listeGlobal);
                var l = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (selector.select(t))
                        l.Add(t);
                }

                buildGlobalList(listeGlobal.path, l, 2);

            }

            foreach (Note note in Conf.Notes)
            {
                var builder = new NoteBuilder(note);
                builder.build(list);
                foreach (ListNote listNote in builder.Depot)
                {
                    var path = string.Format(note.path, listNote.Note);
                    var _l = listNote.List;
                    if (note.histo)
                    _l.Sort(new PodCastComparer());
                    else
                        _l.Sort(new PodCastComparerInv());
                    buildGlobalList(path, _l, 2);

                    if (!string.IsNullOrEmpty(note.single))
                    {
                        var pathSingle = string.Format(note.single, listNote.Note);
                        var hs = new HashSet<string>();
                        var ls = new List<TrackInfoItunes>();
                        foreach (TrackInfoItunes t in _l)
                        {
                            if (!t.Selected)
                                continue;
                            if (!hs.Add(t.AlbumKey))
                                continue;
                            ls.Add(t);
                        }
                        buildGlobalList(pathSingle, ls, 2);
                    }
                }
                // Sélection d'un unique item (preise encompte des niveaux précédents)
                if (!string.IsNullOrEmpty(note.unique))
                {
                    //Dictionnaire global
                    var hsGlobal = new HashSet<string>();
                    var depot = new List<ListNote>(builder.Depot);
                    int count = depot.Count;
                    var dateref = ContexteBuilder.Instance.Zero.AddDays(1); 
                    for (int i = count - 1; i >= 0; i--)
                    {
                        ListNote listNote = depot[i];
                        var _l = listNote.List.FindAll(t => t.Selected) ;
                        _l.Sort(new PodCastComparer());

                        var linv = _l.FindAll(t => t.Recent && t.Pub.Date < dateref);
                        linv.Sort(new PodCastComparerInv());

                        foreach (TrackInfoItunes t in _l)
                        {
                            if (linv.Contains(t))
                                continue; 
                            linv.Add(t); 
                        }

                        //if (note.histo)
                        //    _l.Sort(new PodCastComparer());
                        //else
                        //    _l.Sort(new PodCastComparerInv());
                        var ls = new List<TrackInfoItunes>();
                        var hs = new HashSet<string>();
                        var pathUnique = string.Format(note.unique, listNote.Note);
                        foreach (TrackInfoItunes t in linv)
                        {
                            //if (!t.Selected)
                            //    continue;
                            if (hsGlobal.Contains(t.AlbumKey))
                                continue;
                            if (!hs.Add(t.AlbumKey))
                                continue;
                            if (t.Pub < dateref)
                            {
                                hsGlobal.Add(t.AlbumKey); 
                            }

                            ls.Add(t);
                        }

                        buildGlobalList(pathUnique, ls, 2);
                    }
                }

            }

            var contextB = ContexteBuilder.Instance;

            if (contextB.Enabled)
            {

                var selected = dir.getListe();
                selected.Sort(new PodCastComparer());

                //   contextB.init(selected); 
                var listContext = new List<TrackInfoItunes>();
                contextB.buildList(selected, listContext);

                buildList("_contexte", listContext, 2);
            }



        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                                break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Grouping = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;

//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    public class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        //  private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        //private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        //public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();

        static ContexteBuilder context = ContexteBuilder.Instance;


        private List<TrackInfoItunes> candidats = new List<TrackInfoItunes>();

        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        // private Logger log;
        timeSpan currentDuration = new timeSpan();
        // timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;


        private static bool _checkExists;
        public static bool CheckExists { set { _checkExists = value; } }


        // List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        //BgDictString0<TrackInfoItunes> selectedByFd = new BgDictString0<TrackInfoItunes>();
        //BgDictString0<TrackInfoItunes> manageByFd = new BgDictString0<TrackInfoItunes>();
        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            init(parent, limit);
        }

        public void init(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            //log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }


        //public timeSpan _durationv;
        //public timeSpan _datev;
        //private timeSpan _fd;
        //public timeSpan Fd { get { return _fd; } }

        public int _nb;

        //public void checkV(AutoBuilder auto, int nb, timeSpan fd, timeSpan d, timeSpan date)
        //{
        //    BgDictString0<TrackInfoItunes> dict = new BgDictString0<TrackInfoItunes>();

        //    int nbMin = int.MaxValue;
        //    timeSpan fdMin = timeSpan.MaxValue;
        //    timeSpan dMin = timeSpan.MaxValue;
        //    timeSpan dateMin = timeSpan.MaxValue;
        //    foreach (FeedLimitItemLoader loader in loaders.Values)
        //    {
        //        loader.checkV(nb, fd);
        //        var _nb = loader.NbV;
        //        var _fd = loader.FdV;
        //        if (_nb > nb && _nb < nbMin)
        //            nbMin = _nb;
        //        if (_fd > fd && fd < fdMin)
        //            fdMin = _fd;
        //        for (int i = 0; i <= loader.IndexV; i++)
        //        {
        //            var track = loader.Candidats[i];
        //            if (dict.ContainsKey(track.Location))
        //                continue;
        //            var _d = currentDuration + track.Duree;
        //            if (_d > d && d < dMin)
        //                dMin = _d;
        //            var _date = track.Ts;
        //            if (_date > date && _date < dateMin)
        //                dateMin = _date;
        //            break;
        //        }



        //    }

        //    this._durationv = dMin;
        //    this._datev = dateMin;
        //    this._nb = nbMin;
        //    this._fd = fdMin;
        //}

       

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 && limit.Nbp==0)
                return;

            if (!limit.OverwriteConf && limit.Nb2 == 0)
                return;
            candidats.Clear(); 

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            //if (limit.Dir.Cascading)
            //{
            var dd = limit.LoadDuration;
            if (dd > duration)
            {
                loadEqSel = false;
                duration = dd;
            }
            //}

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                //var location = candidat.Location;
                //if (string.IsNullOrEmpty(location))
                //    continue;

                //if (standAlone.ContainsKey(location))
                //    continue;

                var d = candidat.Pub2;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                candidats.Add(candidat);
                //  standAlone.Add(location, candidat);
                Exporter.Record(candidat);

                //var loader = getLoader(candidat);
                //loader.AddCandidat(candidat);
                continue;



            }

        }




        private FeedLimitItemLoader getLoader(TrackInfoItunes candidat)
        {
            return limit.Dir.Loader.Albums.Get(candidat);
        }

        /// <summary>
        /// On supprime tout sauf les standalone
        /// </summary>
        public void reset()
        {
            //loaders = new BgDictString0<FeedLimitItemLoader>();
            //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
            // public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
            //legacy = new SequentialDictString<TrackInfoItunes>();
            //legacyRelax = new SequentialDictString<TrackInfoItunes>();
            //selected = new SequentialDictString<TrackInfoItunes>();
            //exclu = new SequentialDictString<TrackInfoItunes>();

            //selectedByFd = new BgDictString0<TrackInfoItunes>();
            //manageByFd = new BgDictString0<TrackInfoItunes>();
            use.Clear();


            currentDuration = new timeSpan();
            // timeSpan currentDurationVirtual = new timeSpan();
            durationStop = new timeSpan();
            currentContrib = new timeSpan();
            //trackDurationMax = new timeSpan();
            //trackDurationMin = new timeSpan();

            //var aux = new List<TrackInfoItunes>(candidats.Count);
            //foreach (TrackInfoItunes track in candidats)
            //{
            //    var copy = TrackInfoItunes.createCopy(track);
            //    aux.Add(copy);
            //}

            //candidats = aux; 
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            //  currentDurationVirtual = new timeSpan();
            //selectedByFd = new BgDictString0<TrackInfoItunes>();
            //manageByFd = new BgDictString0<TrackInfoItunes>();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in limit.Dir.Loader.Albums)
                loader.phase2();
        }

        //public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        //{
        //    if (itemSource == limit)
        //        return;
        //    var location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    //if (standAlone.ContainsKey(location))
        //    //    return;
        //    bool transmitTotal = limit.Dir.TransmitTotalGuest;
        //    //if (transmitTotal && legacy.ContainsKey(location))
        //    //    return;
        //    //if (!transmitTotal && legacyRelax.ContainsKey(location))
        //    //    return;


        //    if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
        //    {

        //        if (transmitTotal)
        //            legacy.Add(location, track);
        //        else
        //            legacyRelax.Add(location, track);
        //    }
        //}

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //    var location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;
        //    //if (standAlone.ContainsKey(location))
        //    //    return;
        //    if (transmitTotal && legacy.ContainsKey(location))
        //        return;
        //    if (!transmitTotal && legacyRelax.ContainsKey(location))
        //        return;
        //    if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
        //    {
        //        if (transmitTotal)
        //            legacy.Add(location, track);
        //        else
        //            legacyRelax.Add(location, track);

        //    }
        //}



        //private timeSpan getDuration(int nb, timeSpan minfd)
        //{
        //    timeSpan tot = new timeSpan();
        //    foreach (FeedLimitItemLoader feed in loaders.Values)
        //    {
        //        tot += feed.getTotalDurationFor(nb, minfd);
        //    }
        //    return tot;
        //}

        public void Selection()
        {

            if (limit.Nb == 0 && limit.Nbp == 0)
                return;

            //  var histo = limit.Dir.Histo;

            //var relax = legacyRelax.List;
            //if (relax.Count > 0)
            //{
            //    if (histo)
            //        relax.Sort(new PodCastComparerPub2());
            //    else
            //        relax.Sort(new PodCastComparerInv());
            //    selection(relax, false, false);
            //}

            //var list = legacy.List;
            //if (list.Count > 0)
            //{
            //    if (histo)
            //        list.Sort(new PodCastComparerPub2());
            //    else
            //        list.Sort(new PodCastComparerInv());
            //    selection(list, false, true);
            //}

            if (candidats.Count > 0)
            {
                selection(candidats);
            }



            //var list2 = standAlone.List;
            //if (list2.Count > 0)
            //{
            //    //if (histo)
            //    //    list2.Sort(new PodCastComparerPub2());
            //    //else
            //    //    list2.Sort(new PodCastComparerInv());

            //    selection(list2); //, true, true);
            //}

        }


        private class FdResponse
        {
            public int nb;
           // public int nbp;
            public timeSpan duree;
            public bool okFd;
            public bool okNb;
           // public bool okNbp;
            public bool Result { get { return okFd && okNb;  } }
            //  public bool OnlyFd { get { return okFd && !okNb; } }


        }

        FdResponse check(FeedLimitItemLoader loader, TrackInfoItunes candidat, bool isConcernedBySelection, LimitItem limit)
        {
            var response = new FdResponse();

            var _nb = isConcernedBySelection ? loader.Nbp: loader.Nb; 
         

            if (!loader.isSelected(candidat))
            {
                _nb++; 
            }
                
            response.nb = _nb;
            response.duree = loader.fd;

            var conf = loader.album.ConfAlbum;

            int _nbMax = isConcernedBySelection ? limit.getNbp(conf) : limit.getNb(conf); //    load ? limit.LoadNb : (int)(System.Math.Min(limit.Nb, limit.Nb2));
           


            var __durationMax = limit.getFd(conf); //  load ? limit.LoadDuration : System.Math.Min(limit.FeedDuration, limit.Fd2);
            var _durationMax = timeSpan.FromMinutes(__durationMax);

            response.okNb = _nb <= _nbMax;
            response.okFd = response.duree <= _durationMax;

            if (isConcernedBySelection && context.Enabled)
            {
                if (!response.Result)
                {
                    if (response.okFd)
                    {
                        if (conf.Nb2 == int.MaxValue)
                        {
                            if (context.accept(candidat, _nb))
                            {
                                response.okNb = true;
                                // response.okFd = true;
                            }
                        }
                    }
                    else
                    {
                    }
                    //if (_nb <= context.Nb)
                    //{
                    //    if (context.accept(candidat))
                    //        response.okNb = true;
                    //}
                    //else
                    //    context.checkFin(candidat);
                }
            }




            return response;

        }

        private void selection(List<TrackInfoItunes> list)
        {
            bool checkExist = _checkExists && !limit.Dir.Histo && (limit.Dir.selectParams == null && limit.Dir.selectParams.Count == 0);
            var dtAutoMAwx = Conf.Date0.AddDays(limit.Dir.getMaxDateAuto());
            var duration = limit.getDuration();

            var durationMax = timeSpan.FromMinutes(duration);

            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {

                TrackInfoItunes candidat = list[index];

                //if (candidat.Album == "LA GRANDE TABLE 1ère partie")
                //{
                //}
                //if (candidat.Album == "SI TU NE VAS PAS A RIO")
                //{
                //}
                //foreach (TrackInfoItunes candidat in list)
                //{

                //if (candidat.Album == "Géopolitique")
                //{
                //}

                //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
                //{
                //}
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (checkExist && !FileRegister.ExistNow(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                DateTime d = candidat.getDate(); // candidat.TrackAlbum.ConfAlbum.checkPub ? candidat.Pub : candidat.Pub2;

                bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
                if (okDate)
                {
                }
                var loader = getLoader(candidat);



                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                // okTotalDuration = currentDuration <= durationMax;

                //  bool okprovi = okDate && okTotalDuration;
                // bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                FdResponse response = null;
                //if (!increment) // données venant de sous-dossier (histo, voisins....)
                //{
                //    response = check(loader, candidat, limit);
                //    _control = response == null || response.Result;
                //    //  _control = loader.control(false, limit, candidat); // loader.control(parent, limit, candidat, select, false, okDate && okTotalDuration, true);
                //    //if (_control && !selectedByFd.ContainsKey(location))
                //    //    selectedByFd.Add(location, candidat);
                //    //if (!manageByFd.ContainsKey(location))
                //    //    manageByFd.Add(location, candidat);
                //}



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;


                var newDuration = currentDuration + candidat.Duree;
                var oldDuration = currentDuration;
                bool okTotalDuration = newDuration <= durationMax;
                //if (manageByFd.ContainsKey(location))
                //{
                //    _control = false;
                //    if (selectedByFd.ContainsKey(location))
                //        _control = true;
                //}
                //else
                //{
                bool isConcernedBySelection = candidat.isConcernedBySelection; 
                response = check(loader, candidat, isConcernedBySelection, limit);
                bool _control = response == null || response.Result;
                //_control = loader.control(false, limit, candidat); // loader.control(parent, limit, candidat, select, false, okDate && okTotalDuration, true);

                //}

                if (_control)
                {
                    //currentDurationVirtual += candidat.Duree;
                    if (okDate)
                        currentDuration = newDuration;
                }


                // newDuration = currentDuration;
                //if (_control && !selectedByFd.ContainsKey(location))
                //    selectedByFd.Add(location, candidat);
                //if (!manageByFd.ContainsKey(location))
                //    manageByFd.Add(location, candidat);
                //  okTotalDuration = newDuration <= durationMax;






                bool go = okDate && _control && okTotalDuration;
                if (go)
                {

                  
                    if (_selection)
                    {
                        if (checkExist)
                        {
                            if (!FileRegister.ExistNow(location))
                            {
                                currentDuration = oldDuration;
                                continue; 
                            }
                        }
                        candidat.select(selectMode.simple, limit);
                        limit.Dir.Feeds.recordTrack(candidat, limit);
                    }
                    loader.record(candidat);


                    //report aux niveaux inférieurs
                    // if (real)
                    // parent.recordLimitItemCandidat(candidat, limit);
                    // return true;

                }

                if (!_selection)
                {

                    if (limit.canSignal() && response != null)
                    {



                        var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                            //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                            //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                            //, okTotalDuration, newDuration, candidat, limit);
                                response.okFd, response.duree
                        , response.okNb, response.nb
                        , okTotalDuration, newDuration, candidat, isConcernedBySelection, limit);

                      
                        limit.signal(dataAuto);
                    }

                }

                if (_selection)
                {


                    //newDuration = currentDuration;
                    //okTotalDuration = newDuration <= durationMax;
                    if (!okTotalDuration)
                    {
                        //if (!Logger.CreateNullLoggers)
                        //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                        {
                            // currentDuration = newDuration;
                            durationStop = currentDuration;
                        }

                        if (true || Conf.AutoSelect)
                            continue;
                        else
                            break;

                    }

                    if (!okDate && limit.Dir.Histo)
                        break;

                    if (!_control || !okDate)
                        continue;





                    if (!newContribut)
                    {
                        // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            // log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }



                    // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                    limit.Dir.recordTrack(candidat, limit);



                }
                else
                {
                    if (!okDate && d > dtAutoMAwx)
                        break;
                }

            }
        }


        //private void selection0(List<TrackInfoItunes> list, bool select, bool increment)
        //{
        //    var duration = limit.Duration;
        //    var durationMax = timeSpan.FromMinutes(duration);
        //    var contributionMax = timeSpan.FromMinutes(limit.Contribution);

        //    int count = list.Count;
        //    for (int index = 0; index < count; index++)
        //    {
        //        TrackInfoItunes candidat = list[index];
        //        //foreach (TrackInfoItunes candidat in list)
        //        //{

        //        //if (candidat.Album == "Géopolitique")
        //        //{
        //        //}

        //        //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
        //        //{
        //        //}
        //        var location = candidat.Location;
        //        if (string.IsNullOrEmpty(location))
        //            continue;

        //        //if (_selection && selected.ContainsKey(location))
        //        //    continue;
        //        // vérification à postériori par rapports aux différents niveaux
        //        bool newContribut = candidat.Selected;

        //        DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
        //        bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
        //        var loader = getLoader(candidat.Album);
        //        bool okTotalDuration = false;
        //        bool _control = false;

        //        //tester uniquement fd et nb
        //        // _control = loader.control(candidat, select, false, false);

        //        // var _newDuration = currentDuration;
        //        //if (increment)
        //        //    _newDuration = currentDuration + candidat.Duree;

        //        // savoir si ça passe uniquement avec le critère d
        //        okTotalDuration = currentDuration <= durationMax;

        //        bool okprovi = okDate && okTotalDuration;
        //        bool ok = okDate && okTotalDuration && _control;

        //        // rejouer le controle pour incrémenter nb et fd      
        //        if (!increment) // données venant de sous-dossier (histo, voisins....)
        //        {
        //            _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //        }



        //        //if (!loader.LoadEqSel)
        //        //{

        //        //    if (_control)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
        //        //    else if (loader.EndByFd)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

        //        //}

        //        //if (!increment && !_selection) //!loader.LoadEqSel &&
        //        //{
        //        //    //  if (!loader.OkNb)
        //        //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
        //        //    // if (!loader.OkFd)
        //        //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

        //        //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //        //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //        //}

        //        //if (!control(candidat, select, okDuration))
        //        //    continue;

        //        if (increment)
        //        {
        //            var newDuration = currentDuration + candidat.Duree;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (manageByFd.ContainsKey(location))
        //            {
        //                _control = false;
        //                if (selectedByFd.ContainsKey(location))
        //                    _control = true;
        //            }
        //            else
        //            {
        //                _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

        //            }

        //            if (_control)
        //            {
        //                //currentDurationVirtual += candidat.Duree;
        //                if (okDate)
        //                    currentDuration += candidat.Duree;
        //            }


        //            // newDuration = currentDuration;
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //            //  okTotalDuration = newDuration <= durationMax;



        //            //okTotalDuration = newDuration <= durationMax;
        //            //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

        //            //if (okDate && _control)
        //            //    currentDuration += candidat.Duree;
        //            //currentDurationVirtual = currentDuration; // += candidat.Duree;

        //            //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

        //            //  bool okTotalDuration = newDuration <= durationMax;

        //            if (!_selection)
        //            {


        //                var _fd = loader.getCurrentDuration(false);

        //                if (_fd > newDuration)
        //                {
        //                    newDuration = _fd;
        //                    okTotalDuration = newDuration <= durationMax;
        //                }
        //                if (_control)
        //                {
        //                }
        //                else
        //                {
        //                    //var fd = loader.getCurrentDuration(true);
        //                    //var nb = loader.getNb(true);

        //                    //newDuration = new timeSpan();
        //                    //foreach (FeedLimitItemLoader l in loaders.Values)
        //                    //    l.phaseTest();
        //                    //for (int j = 0; j <= index; j++)
        //                    //{
        //                    //    TrackInfoItunes t = list[j];
        //                    //    var subloader = getLoader(t.Album);
        //                    //    var subok = subloader.test(nb, fd, t);
        //                    //    if (j >= subloader.IndexBase)
        //                    //    {
        //                    //        if (subok || selectedByFd.ContainsKey(location))
        //                    //            newDuration += t.Duree;
        //                    //    }

        //                    //}
        //                    //// newDuration += getDuration(nb, fd);

        //                    //if (newDuration < currentDuration)
        //                    //{
        //                    //}
        //                    //else if (newDuration > currentDurationVirtual)
        //                    //{
        //                    //}
        //                    //okTotalDuration = newDuration <= durationMax;
        //                }


        //                //question fd
        //                //if (!loader.LoadEqSel)
        //                //{
        //                var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //              loader.OkFd, loader.getDurationStop(okDate)
        //              , loader.OkNb, loader.getNbStop(okDate)
        //              , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

        //                limit.Dir.CauseRegister.signal(dataRoot);

        //                var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //                    //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
        //                    //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
        //                    //, okTotalDuration, newDuration, candidat, limit);
        //                        loader.OkFd, _fd// loader.getCurrentDuration (false)
        //                , loader.OkNb, loader.getNb(false)
        //                , okTotalDuration, newDuration, candidat, limit);

        //                limit.signal(dataAuto);
        //            }




        //            //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
        //            //loader.OkFd, loader.getDurationStop(okDate)
        //            //, loader.OkNb, loader.getNbStop(okDate)
        //            //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

        //            //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //            //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //            //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

        //            if (Conf.BorderTb)
        //            {
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
        //                else if (okDate && okTotalDuration)
        //                {
        //                    if (loader.EndByFd)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
        //                }
        //                //else if (Conf.BorderVirtual)
        //                //{
        //                //    if (_control)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
        //                //    else if (loader.EndByFd)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
        //                //}


        //                //}

        //                //if (!loadEqSel)
        //                //{
        //                // question d
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
        //                else if (okDate && _control)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okTotalDuration)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
        //                }


        //                // question date
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
        //                else if (_control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okDate)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
        //                }

        //                //}

        //            }


        //            ////question duree
        //            //if (okDate && _control) // || Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
        //            //}

        //            ////question fd

        //            //if (_control)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

        //            //    }
        //            //}
        //            //else //if (!loader.limit.NbFeedLimit)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
        //            //        limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
        //            //        limit.signal(tb);
        //            //    }
        //            //}
        //            ////question date
        //            //if (_control && okDuration)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
        //            //    limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
        //            //    limit.signal(tb);
        //            //}



        //            //if (!_control && !Conf.BorderVirtual)
        //            //    continue;
        //            if (!okDate)
        //                continue;

        //            if (!_control)
        //                continue;
        //            newDuration = currentDuration;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (!okTotalDuration)
        //            {
        //                //if (!Logger.CreateNullLoggers)
        //                //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

        //                if (_selection)
        //                    limit.DurationLimitAtteinte = true;
        //                if (durationStop.Value == 0)
        //                {
        //                    // currentDuration = newDuration;
        //                    durationStop = currentDuration;
        //                }

        //            }

        //            if (!okTotalDuration)
        //                continue;


        //            if (_selection && !newContribut)
        //            {
        //                // pour l'instant ? on ne gère pas la contribtion en mode rejeu

        //                currentContrib += candidat.Duree;
        //                if (currentContrib > contributionMax)
        //                {
        //                    //  log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
        //                    limit.ContributionLimitAtteinte = true;
        //                    break;
        //                }

        //                use.Add(candidat);
        //            }

        //            //   currentDuration = newDuration;




        //            if (_selection)
        //            {
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                limit.Dir.recordTrack(candidat, limit);
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                //  limit.Dir.recordTrack(candidat, limit);

        //                selected.Add(location, candidat);

        //                if (select)
        //                    exclu.Add(location, candidat);
        //            }





        //        }

        //    }
        //}

        public LimitItem Item { get { return limit; } }
        public override string ToString()
        {
            return limit.ToString();
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.ordo.conf;
using pdb.podcast.Auto;
using pdb.util;

namespace pdb.podcast.Tuning
{
    public enum menage
    {
        none,
        read,
        name
    }
    public class Conf
    {
        string SOV = "..\\sov\\";
        //private static string CONF_FILE = @"..\conf.xml";
        #region membres
        private DirConf root;
        private XmlElement xDir;
        private bool buildLimitMulti;
        private bool single;
        private Move move;
        private bool deleteDoublon;
        private bool getDescription;
        private int volumeMin = int.MinValue;
        private bool simulation;
        private string copyAll;
        private int maxScan = 10;
        private ConfOrdo ordo = new ConfOrdo();
        private menage menage = menage.none;
        private string poubelle = "";
        // private string zique;
        private bool writePlayLists;
        private bool writePreSel;
        private bool writeItems;
        private bool writeUse;
        private bool writeExclu;
        private bool genFeed;
        private int genFeedPrior = 11;
        private int genUsePrior = 11;
        private int genExcluPrior = 11;
        //private bool transmit = true;
        //private bool transmitTotal = true;
        //private bool transmitTotalGuest = true;
        private bool? cascading = null;
        private bool autoBlock;

        private ConfDate dates = new ConfDate();

        private List<SelectParam> selectParams = new List<SelectParam>();
        private List<Note> notes = new List<Note>();
        private Journal journal;
        private RootIt rootIt = new RootIt();
        private bool onlyEnabled = true;
        private bool onlyUnRead = true;
        private bool checkExist = true;

        // private Auto auto = null;
        private bool logGen = true;
        //private DateTime date0;
        //private DateTime date00;
        private double deltaOpen = 70;
        private Html html = new Html();

        private bool autoSequence = true;
        private bool borderVirtual;
        private bool borderIdem;
        private bool borderGranSlam;
        private bool borderTb;
        private bool autoSelect;
        private bool logDir;

        private Export export = new Export();
        private Hibernate import = new Hibernate();
        private Sort.Sort sort = new Sort.Sort();
        private Hibernate hibernate = new Hibernate();
        private Db db = new Db();
        private ConfAlbums albums = new ConfAlbums();
        private Listes listes = new Listes();
        private Listes globalListes = new Listes();

        private bool checkPub = true;

        private bool useMock;
        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        private bool freewheel = false; 


        private Contexte contexte = new Contexte();
        private DateRef dateRef = new DateRef(); 
        #endregion
        public static readonly Conf Instance = new Conf();
        private static bool started;
        private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
        public void setConfFile(string conf)
        {
            this.confFile = new FileInfo(@"..\" + conf);

            if (!Directory.Exists(SOV))
                Directory.CreateDirectory(SOV);

            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            File.Copy(confFile.FullName, string.Format("{0}{1}_{2}", SOV, timeStamp, confFile.Name), true);
        }

        #region getters
        public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
        public static bool Single { get { return Instance.single; } }
        public static DirConf DirConf { get { return Instance.root; } }
        public static Move Move { get { return Instance.move; } }
        public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
        public static bool GetDescription { get { return Instance.getDescription; } }
        public static int VolumeMin { get { return Instance.volumeMin; } }
        public static bool Simulation { get { return Instance.simulation; } }
        public static string CopyAll { get { return Instance.copyAll; } }
        public static ConfOrdo Ordo { get { return Instance.ordo; } }
        public static int MaxScan { get { return Instance.maxScan; } }
        public static menage Menage { get { return Instance.menage; } }
        public static string Poubelle { get { return Instance.poubelle; } }
        public static bool WritePlayLists { get { return Instance.writePlayLists; } }
        public static bool WritePreSel { get { return Instance.writePreSel; } }
        public static bool WriteItems { get { return Instance.writeItems; } }
        public static bool WriteUse { get { return Instance.writeUse; } }
        public static bool WriteExclu { get { return Instance.writeExclu; } }
        public static bool GenFeed { get { return Instance.genFeed; } }
        public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
        public static int GenUsePrior { get { return Instance.genUsePrior; } }
        public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

        //public static bool Transmit { get { return Instance.transmit; } }
        //public static bool TransmitTotal { get { return Instance.transmitTotal; } }
        //public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
        public static bool? Cascading { get { return Instance.cascading; } }
        public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
        public static DateTime DateLevel { get { return Instance.dates.Level; } }
      
        internal static Journal Journal { get { return Instance.journal; } }
        internal static RootIt RootIt { get { return Instance.rootIt; } }

        public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
        public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }
        public static bool CheckExist { get { return Instance.checkExist; } }

        public static bool AutoBlock { get { return Instance.autoBlock; } }
        public static bool LogGen { get { return Instance.logGen; } }

        internal static Html Html { get { return Instance.html; } }

        public static bool AutoSequence { get { return Instance.autoSequence; } }
        public static bool BorderVirtual { get { return Instance.borderVirtual; } }
        public static bool BorderIdem { get { return Instance.borderIdem; } }
        public static bool BorderGranSlam { get { return Instance.borderGranSlam; } }
        public static bool BorderTb { get { return Instance.borderTb; } }
        public static bool AutoSelect { get { return Instance.autoSelect; } }
        public static Export Export { get { return Instance.export; } }
        internal static Hibernate Import { get { return Instance.import; } }
        public static Sort.Sort Sort { get { return Instance.sort; } }
        public static ConfAlbums Albums { get { return Instance.albums; } }
        internal static Hibernate Hibernate { get { return Instance.hibernate; } }
        internal static Db Db { get { return Instance.db; } }
        /// <summary>
        /// muy important. on calcule les dates max avec pub plutôt que Pub2
        /// </summary>
        //  public static bool CheckPub { get { return Instance.checkPub; } }
        public static bool UseMock { get { return Instance.useMock; } }
        public static bool LogDir { get { return Instance.logDir; } }
        public static double DeltaOPen { get { return Instance.deltaOpen; } }
        internal static Listes Listes { get { return Instance.listes; } }
        internal static Listes GlobalListes { get { return Instance.globalListes; } }
        internal static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
        internal static List<Note> Notes { get { return Instance.notes; } }

        internal static Contexte Contexte { get { return Instance.contexte; } }
        internal static DateRef DateRef { get { return Instance.dateRef; } }

        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        public static bool Freewheel { get { return Instance.freewheel; } }
        //  public static string Zique { get { return Instance.zique; } }
        #endregion

        private DateTime lastModif = DateTime.MinValue;
        private FileInfo confFile;
        public FileInfo ConfFile { get { return confFile; } }
        #region load

        public XmlElement load(bool waitForModification)
        {

            while (true)
            {
                confFile.Refresh();
                if (!confFile.Exists)
                    throw new ApplicationException(confFile + " n'existe pas !!");
                DateTime dt = confFile.LastWriteTime;
                if (dt > lastModif || !waitForModification)
                    break;
                Thread.Sleep(1000);
            }

            lastModif = confFile.LastWriteTime;

            XmlDocument l_doc = new XmlDocument();
            l_doc.Load(confFile.FullName);

            XmlElement xroot = l_doc.DocumentElement;
            XMLTool l_xmlConf = new XMLTool(xroot);

            string str = l_xmlConf.getNodeValue("volumeMin");
            if (!string.IsNullOrEmpty(str))
                volumeMin = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("maxScan");
            if (!string.IsNullOrEmpty(str))
                maxScan = Convert.ToInt32(str);

            buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
            simulation = l_xmlConf.getBoolValue("simulation");
            //   zique = l_xmlConf.getNodeValue("zique");

            deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
            getDescription = l_xmlConf.getBoolValue("getDescription");
            copyAll = l_xmlConf.getNodeValue("copyAll");

            poubelle = l_xmlConf.getNodeValue("poubelle");

            str = l_xmlConf.getNodeValue("menage");
            if (!string.IsNullOrEmpty(str))
                menage = (menage)(Enum.Parse(typeof(menage), str, true));

            writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
            writePreSel = l_xmlConf.getBoolValue("writePreSel");
            writeItems = l_xmlConf.getBoolValue("writeItems");
            writeUse = l_xmlConf.getBoolValue("writeUse");
            writeExclu = l_xmlConf.getBoolValue("writeExclu");
            genFeed = l_xmlConf.getBoolValue("genFeed");
            str = l_xmlConf.getNodeValue("genFeedPrior");
            if (!string.IsNullOrEmpty(str))
                genFeedPrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genUsePrior");
            if (!string.IsNullOrEmpty(str))
                genUsePrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genExcluPrior");
            if (!string.IsNullOrEmpty(str))
                genExcluPrior = Convert.ToInt32(str);

            //transmit = l_xmlConf.getBoolValue("transmit");
            //transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
            //transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
            onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
            onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
            checkExist = l_xmlConf.getBoolValue("checkExist", true);
            str = l_xmlConf.getNodeValue("cascading");
            if (!string.IsNullOrEmpty(str))
                cascading = "true".Equals(str);
            //  cascading = l_xmlConf.getBoolValue("cascading");

            //str = l_xmlConf.getNodeValue("date0");
            //if (!string.IsNullOrEmpty(str))
            //    date0 = Convert.ToDateTime(str);

            //str = l_xmlConf.getNodeValue("date00");
            //if (!string.IsNullOrEmpty(str))
            //    date00 = Convert.ToDateTime(str);

            var xDateRef = l_xmlConf.NodeLookUp("dateRef");
            dateRef = new DateRef(xDateRef);

            var xDates = l_xmlConf.NodeLookUp("playedDates");
            dates = new ConfDate(xDates);

            logGen = l_xmlConf.getBoolValue("logGen");
            var createNullLoggerOrg = Logger.CreateNullLoggers;

            Logger.CreateNullLoggers = !logGen;
            xDir = l_xmlConf.NodeLookUp("dir");

            var rootLimit = new Limits();
            buildLimit(xDir, rootLimit, null);

            AutoBuilder.clear();
            root = DirConf.getDir(rootLimit, xDir.Attributes["name"].InnerText, null); //new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
            root.build(null, xDir);
            buildDirChilds(xDir, root);
            root.Init();

            // AutoBuilder.getLoaders(); 

            XmlElement xMove = l_xmlConf.NodeLookUp("move");
            move = new Move(xMove);

            ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

            selectParams.Clear();

            var xSelect = l_xmlConf.NodeLookUp("select");
            if (xSelect != null)
            {
                foreach (XmlNode xsub in xSelect)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        selectParams.Add(new SelectParam(xSelect, x));
                }
            }

            notes.Clear();
            var xNotes = l_xmlConf.NodeLookUp("notes");
            if (xNotes != null)
            {
                foreach (XmlNode xsub in xNotes)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        notes.Add(new Note(x));
                }
            }

            journal = null;
            var xJournal = XMLTool.NodeLookUp(xroot, "journal");
            if (xJournal != null)
            {
                journal = new Tuning.Journal();
                buildLimitItem(xJournal, xJournal, journal);
                var xxJournal = new XMLTool(xJournal);
                journal.NbJour = xxJournal.getIntAttValue("nbJour");
            }

            rootIt = new Tuning.RootIt(l_xmlConf.NodeLookUp("rootIt")); //  l_xmlConf.getNodeValue("rootIt");

            autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
            //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
            //if (xAuto == null)
            //    auto = null;
            //else
            //    auto = new Auto(xAuto);

            XmlElement xHtml = l_xmlConf.NodeLookUp("html");
            html = new Html(xHtml);

            autoSequence = l_xmlConf.getBoolValue("autoSequence", true);
            borderVirtual = l_xmlConf.getBoolValue("borderVirtual", false);
            borderIdem = l_xmlConf.getBoolValue("borderIdem", false);
            borderGranSlam = l_xmlConf.getBoolValue("borderGranSlam", false);
            borderTb = l_xmlConf.getBoolValue("borderTb", false);
            autoSelect = l_xmlConf.getBoolValue("autoSelect", false);
            checkPub = l_xmlConf.getBoolValue("checkPub", false);
            useMock = l_xmlConf.getBoolValue("useMock ", false);
            logDir = l_xmlConf.getBoolValue("logDir ", false);

            freewheel = l_xmlConf.getBoolValue("freewheel", false); 

            var xExport = l_xmlConf.NodeLookUp("export"); // export = l_xmlConf.getNodeValue("export");
            export = new Tuning.Export(xExport);

            var xImport = l_xmlConf.NodeLookUp("import"); // export = l_xmlConf.getNodeValue("export");
            import = new Tuning.Hibernate(xImport);

            var xSort = l_xmlConf.NodeLookUp("sort");
            sort = new Tuning.Sort.Sort(xSort);


            var xAlbums = l_xmlConf.NodeLookUp("albums");
            albums = new ConfAlbums(xAlbums);

            var xHibernate = l_xmlConf.NodeLookUp("hibernate");
            hibernate = new Hibernate(xHibernate);


            var xDb = l_xmlConf.NodeLookUp("db");
            db = new Db(xDb);


            Logger.CreateNullLoggers = createNullLoggerOrg;
            var xlistes = l_xmlConf.NodeLookUp("listes");
            listes = new Listes(xlistes);

            var xglobal = l_xmlConf.NodeLookUp("global");
            globalListes = new Listes(xglobal);


            var xContext = l_xmlConf.NodeLookUp("context");
            contexte = new Contexte(xContext); 
            started = true;
            return xroot;

        }

        #region limites

        private void buildDirChilds(XmlNode node, DirConf parent)
        {
            AutoBuilder.setClient(parent, node);
            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "auto")
                {
                    AutoBuilder.build(child, parent);
                }
                else
                {
                    if (child.Name == "dir")
                    {
                        string name = (child.Attributes["name"].InnerText);
                        Limits childLimite = parent.Limites.Clone() as Limits;
                        DirConf sub = DirConf.getDir(childLimite, name, parent); // new DirConf(childLimite, name, parent);
                        sub.buildR(xDir, child);

                        //if (child.Attributes["d"] != null)
                        //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);



                        if (child.Attributes["all"] != null)
                        {
                            sub.HistoAll = child.Attributes["all"].Value == "true";
                        }
                        if (child.Attributes["histo"] != null)
                        {
                            sub.Histo = child.Attributes["histo"].Value == "true";
                        }
                        if (child.Attributes["resetBefore"] != null)
                        {
                            sub.ResetBefore = child.Attributes["resetBefore"].Value == "true";
                        }
                        if (child.Attributes["resetAfter"] != null)
                        {
                            sub.ResetAfter = child.Attributes["resetAfter"].Value == "true";
                        }
                        if (child.Attributes["serial"] != null)
                        {
                            sub.Serial = child.Attributes["serial"].Value == "true";
                        }

                        if (child.Attributes["cascading"] != null)
                            sub.Cascading = child.Attributes["cascading"].Value == "true";
                        if (child.Attributes["selectionPre"] != null)
                            sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                        sub.selectParams.Clear();
                        foreach (XmlNode xsub in child.ChildNodes)
                        {
                            if (xsub is XmlElement)
                            {
                                if (xsub.Name == "select")
                                {
                                    foreach (XmlNode xp in xsub.ChildNodes)
                                    {
                                        if (xsub is XmlElement)
                                        {
                                            var _param = new SelectParamBase(xsub as XmlElement, xp as XmlElement);
                                            sub.selectParams.Add(_param);
                                        }
                                    }
                                }
                            }
                        }

                        //if (child.Attributes["transmit"] != null)
                        //    sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                        //if (child.Attributes["transmitTotal"] != null)
                        //    sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                        //if (child.Attributes["transmitTotalGuest"] != null)
                        //    sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                        buildLimit(child, childLimite, sub);
                        parent.addChild(sub);
                        if (!started)
                            misc.log(sub.display());
                        buildDirChilds(child, sub);
                        sub.Init();

                    }
                }
            }

        }

        private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
        {
            string strTd = child.InnerText;
            if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
                item.Td = Convert.ToInt32(strTd);

            AutoBuilder.setClient(item, child);

            //foreach (XmlNode sub in child.ChildNodes)
            //{
            //    if (sub.Name == "auto")
            //        AutoBuilder.build(sub, item);
            //}

            item.build(parent, child);

            //var dAtt0 = parent.Attributes["d"];
            //if (dAtt0 != null)
            //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

            //var dAtt = child.Attributes["d"];
            //if (dAtt != null)
            //    item.Duration = Convert.ToSingle(dAtt.InnerText);

            //var cAtt0 = parent.Attributes["c"];
            //if (cAtt0 != null)
            //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

            //var cAtt = child.Attributes["c"];
            //if (cAtt != null)
            //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

            //var fdAtt0 = parent.Attributes["fd"];
            //if (fdAtt0 != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

            //var fdAtt = child.Attributes["fd"];
            //if (fdAtt != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

            //var nbAtt0 = parent.Attributes["nb"];
            //if (nbAtt0 != null)
            //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
            //var nbAtt = child.Attributes["nb"];
            //if (nbAtt != null)
            //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

            //var dateAtt0 = parent.Attributes["date"];
            //if (dateAtt0 != null)
            //    item.DateMin = getDate(dateAtt0.InnerText);
            //var dateAtt = child.Attributes["date"];
            //if (dateAtt != null)
            //    item.DateMin = getDate(dateAtt.InnerText);

            //var dateAtt0Max = parent.Attributes["maxdate"];
            //if (dateAtt0Max != null)
            //    item.DateMax = getDate(dateAtt0Max.InnerText);
            //var dateAttMax = child.Attributes["maxdate"];
            //if (dateAttMax != null)
            //    item.DateMax = getDate(dateAttMax.InnerText);
        }

        //private static bool date00Consumed;
        //public static void date00Consume() { date00Consumed = true; }

        public static DateTime Date0
        {
            get
            {
                return Instance.dateRef.date0; 
            }
        }

        public static DateTime DateContexte
        {
            get
            {
                return Instance.dateRef.contexte; 
            }
        }
      

        public static DateTime getDate(string str)
        {
            if (string.IsNullOrWhiteSpace(str))
                return DateTime.MaxValue;
            double d = -1;
            if (Date0 > DateTime.MinValue)
            {
                if (double.TryParse(str, out d))
                {
                    return Date0.AddDays(d);
                }
            }

            if (str.EndsWith("c"))
            {

                var _str = str.Remove(str.Length - 1);
                if (double.TryParse(_str, out d))
                {
                    return DateContexte.AddDays(d);
                }
            }
            return Convert.ToDateTime(str);
        }

        private void buildLimit(XmlNode node, Limits limits, DirConf dir)
        {

            Limit[] tab = new Limit[Limits.NB];

            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "list")
                {

                    int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                    Limit limit = new Limit(level);
                    var items = new List<LimitItem>();

                    double tdMin = 0;
                    foreach (XmlNode xItem in child.ChildNodes)
                    {
                        //if (xItem.Name == "auto")
                        //{
                        //    AutoBuilder.build(xItem, limit);
                        //}
                        //else 
                        if (xItem.Name == "td")
                        {
                            var item = new LimitItem(limit);
                            item.TdMin = tdMin;
                            buildLimitItem(child, xItem, item);


                            var itemTd = item.Td;
                            if (itemTd < int.MaxValue)
                                tdMin = item.Td;
                            items.Add(item);
                        }
                    }

                    if (items.Count == 0)
                    {
                        var defaultItem = new LimitItem(limit);
                        buildLimitItem(child, child, defaultItem);
                        items.Add(defaultItem);
                    }

                    limit.Items = items;

                    //var dAtt = child.Attributes["d"];
                    //if (dAtt != null)
                    //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                    //var fdAtt = child.Attributes["fd"];
                    //if (fdAtt != null)
                    //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                    //var nbAtt = child.Attributes["nb"];
                    //if (nbAtt != null)
                    //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                    tab[level] = limit;
                }

            }

            Limit current = null;
            bool oneTabAtLeast = false;
            //  LimitItem currentItem = null;

            double currentDuration = int.MaxValue;
            double lcurrentDuration = int.MaxValue;
            double currentContrib = int.MaxValue;
            double currentFeedDuration = int.MaxValue;
            // double lcurrentFeedDuration = int.MaxValue;
            int currentNb = int.MaxValue;
            int currentNbp = int.MaxValue;
            int lcurrentNb = int.MaxValue;

            double currentTd = int.MaxValue;

            double currentTdMin = int.MaxValue;
            DateTime currentDateMin = DateTime.MinValue;
            DateTime currentDateMax = DateTime.MaxValue;
            bool currentOverwrite = false;

            for (int i = 0; i < Limits.NB; i++)
            {

                //if (tab[i] != null)
                //{

                if (tab[i] != null)
                {
                    current = tab[i];
                    oneTabAtLeast = true;

                }

                if (!oneTabAtLeast)
                    current = limits[i];

                var _limit = limits[i];
                _limit.Level = i;
                limits[i].Parent = limits;

                //foreach (LimitItem currentItem in current.Items)
                //{

                if (_limit.Items.Count != current.Items.Count)
                {
                    _limit.Items.Clear();
                }

                for (int j = 0; current != null && j < current.Items.Count; j++)
                {

                    var currentItem = current.Items[j];
                    // if (currentItem.Duration < int.MaxValue)
                    currentDuration = currentItem.Duration;
                    currentOverwrite = currentItem.OverwriteConf;
                    lcurrentDuration = currentItem.LoadDuration;
                    //if (currentItem.Contribution < int.MaxValue)
                    currentContrib = currentItem.Contribution;
                    // if (currentItem.FeedDuration < int.MaxValue)
                    currentFeedDuration = currentItem.FeedDuration;
                    //  lcurrentFeedDuration = currentItem.LoadFeedDuration;

                    //   if (currentItem.Nb < int.MaxValue)
                    currentNb = currentItem.Nb;
                    currentNbp = currentItem.Nbp;
                    lcurrentNb = currentItem.LoadNb;
                    //  if (currentItem.Td < int.MaxValue)
                    currentTd = currentItem.Td;
                    currentTdMin = currentItem.TdMin;

                    currentDateMin = currentItem.DateMin;
                    currentDateMax = currentItem.DateMax;
                    //}
                    //}

                    //if (current != null)
                    //{
                    LimitItem _limitItem = null;
                    if (j >= _limit.Items.Count)
                    {
                        _limitItem = currentItem.Clone() as LimitItem;
                        _limit.Items.Add(_limitItem);
                        _limitItem.Limit = _limit;

                    }
                    else
                    {
                        _limitItem = _limit.Items[j];

                    }
                    //if (currentDuration < int.MaxValue)
                    _limitItem.setDuration(currentDuration, false); // Duration = currentDuration;
                    _limitItem.LoadDuration = lcurrentDuration;
                    //if (currentContrib < int.MaxValue)
                    //    _limitItem.Contribution = currentContrib;
                    // if (currentFeedDuration < int.MaxValue)
                    _limitItem.setFeedDuration(currentFeedDuration, false); // FeedDuration = currentFeedDuration;
                    // _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                    // if (currentNb < int.MaxValue)
                    _limitItem.setNbMax(currentNb, false);
                    _limitItem.setNbMaxp(currentNbp, false);
                    _limitItem.LoadNb = lcurrentNb;
                    //   if (currentTd < int.MaxValue)
                    _limitItem.Td = currentTd;
                    _limitItem.TdMin = currentTdMin;
                    _limitItem.DateMin = currentDateMin;
                    _limitItem.setDateMax(currentDateMax, false);
                    _limitItem.Contribution = currentContrib;
                    _limitItem.OverwriteConf = currentOverwrite;



                    if (dir != null)
                    {
                        if (_limitItem.Duration == int.MaxValue)
                            _limitItem.setDuration(dir.Duration, true); // Duration = dir.Duration;
                        if (_limitItem.LoadDuration == int.MaxValue)
                            _limitItem.LoadDuration = dir.LoadDuration;
                        if (_limitItem.Contribution == int.MaxValue)
                            _limitItem.Contribution = dir.Contribution;
                        if (_limitItem.Td == int.MaxValue)
                            _limitItem.Td = dir.Td;
                        if (_limitItem.Nb == int.MaxValue)
                            _limitItem.setNbMax(dir.Nb, true);
                        if (_limitItem.Nbp == int.MaxValue)
                            _limitItem.setNbMaxp(dir.Nbp, true);
                        if (_limitItem.LoadNb == int.MaxValue)
                            _limitItem.LoadNb = dir.LoadNb;
                        if (_limitItem.FeedDuration == int.MaxValue)
                            _limitItem.setFeedDuration(dir.FeedDuration, true);
                        //if (_limitItem.LoadFeedDuration == int.MaxValue)
                        //    _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                        if (_limitItem.DateMin == DateTime.MinValue)
                            _limitItem.DateMin = dir.DateMin;
                        if (_limitItem.DateMax == DateTime.MaxValue)
                            _limitItem.setDateMax(dir.DateMax, true);
                    }

                    _limitItem.setParent(dir);

                }

                //}
                // }

            }

        }
        #endregion
        #endregion

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\DirConf.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.podcast.Report;
using pdb.util;
using pdb.podcast.Load;
using pdb.podcast.Auto;
using pdb.podcast.Selection;
using System;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Répertoire de pistes
    /// </summary>
    public class DirConf : LimitItemBase, IEnumerable<DirConf>//, IBuilderSource, IBorder
    {
        /// <summary>
        /// logger
        /// </summary>
        // private Logger log;
        /// <summary>
        /// Limites associées au noeud
        /// </summary>
        private Limits limites;
        /// <summary>
        /// Nom du répertoire
        /// </summary>
        private string name = "";

        /// <summary>
        /// Sous-répertoires
        /// </summary>
        private List<DirConf> childs = new List<DirConf>();

        /// <summary>
        /// Répertoire parent
        /// </summary>
        new private DirConf parent;

        /// <summary>
        /// Stats
        /// </summary>
        private DirStat stat;
        internal DirStat Stat { set { stat = value; } get { return stat; } }
        internal TrackConteneur Conteneur { get { return conteneur; } }

        private CauseRegister _causeRegister;
        internal CauseRegister CauseRegister
        {
            get
            {
                if (_causeRegister != null)
                    return _causeRegister;
                if (parent == null)
                    return null;
                return parent.CauseRegister;
            }
        }

        private Feeds feeds;
        internal Feeds Feeds
        {
            get
            {
                if (feeds != null)
                    return feeds;
                if (parent == null)
                    return null;
                return parent.Feeds;
            }
        }


        /// <summary>
        /// Ajout d'un sous-répertoire
        /// </summary>
        /// <param name="dir"></param>
        public void addChild(DirConf dir)
        {
            if (childs.Contains(dir))
                return;
            childs.Add(dir);

        }
        public DirConf Parent
        {
            get { return parent; }
        }

        public bool isChildOf(DirConf dir)
        {
            if (dir == this)
                return true;
            if (parent == null)
                return false;
            return parent.isChildOf(dir);
        }

        /// <summary>
        /// Conteneur des pistes
        /// </summary>
        private TrackConteneur conteneur;

        private FeedsLoader loader;
        internal FeedsLoader Loader
        {
            get
            {
                if (loader == null)
                    loader = new FeedsLoader(this);
                return loader;
            }

        }



        //public void buildLoaders(List<LimitItemLoader> list, AutoBuilder auto)
        //{
        //    if (auto != Auto)
        //        return;
        //    var loader = Loader;
        //    var fl = loader.LimitsLoader;
        //    fl.getLoaders(list);
        //    foreach (DirConf sub in childs)
        //    {
        //        sub.buildLoaders(list, auto);
        //    }
        //}

        /// <summary>
        /// Enregistrement d'une piste
        /// </summary>
        /// <param name="track">piste</param>
        /// <param name="provider">item de limite</param>
        public void recordTrack(TrackInfoItunes track, LimitItem limit)
        {
            if (offset > DateTime.MinValue)
            {
                track.Offset = offset;
                offset = offset.AddDays(1);
            }
            conteneur.recordTrack(track, limit);
            //if (parent != null)
            //    parent.recordTrackFromChild(track, limit, this);
        }

        //public void recordTrackStandAlone(TrackInfoItunes track, LimitItem limit)
        //{
        //    conteneur.recordTrackStandAlone(track, limit);
        //}

        /// <summary>
        /// Récupération de la liste des pistes
        /// </summary>
        /// <returns></returns>
        public List<TrackInfoItunes> getListe()
        {
            var list = conteneur.getListe();
            if (Histo)
                list.Sort(new PodcastComparerPubPub2());
            else
                list.Sort(new PodCastComparerInv());
            //log.log("");
            //log.log(getPath() + " getListe " + list.Count + " elt.");
            //foreach (TrackInfoItunes track in list)
            //{
            //    log.log(track.ToString());
            //}
            return list;
        }

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, DirConf dirSource)
        //{
        //    if (dirSource.transmitToParent)
        //        Loader.recordTrackFromChild(track, itemSource, dirSource.transmitTotal);
        //    if (parent != null)
        //        parent.recordTrackFromChild(track, itemSource, this);
        //}

        /// <summary>
        /// Abandonné
        /// </summary>
        public void TransmissionListToParent(TrackInfoItunes track)
        {
        }


        //public void recordTrackForStats(TrackInfoItunes track, LimitItem provider)
        //{
        //    conteneur.recordTrackForStats(track, provider);
        //}






        public List<SelectParamBase> selectParams = new List<SelectParamBase>(); 

        public Limits Limites { get { return limites; } set { limites = value; } }


        private static Dict<string, DirConf> dict = new Dict<string, DirConf>();
        public static DirConf getDir(Limits limites, string name, DirConf parent)
        {
            // return new DirConf(limites, name, parent); 
            string path = getPath(parent, name);


            var d = dict[path];
            if (d == null)
            {
                d = new DirConf(limites, name, parent);
                dict[path] = d;
                return d;
            }
            else
            {
                //  var nd = new DirConf(limites, name, parent);
                dict[path] = d;
                d.recup = true;
                d.init(limites, name, parent);
                // nd.loader = d.loader; 
            }

            return d;

        }


        private DirConf(Limits limites, string name, DirConf parent)
            : base()
        {
            init(limites, name, parent);
        }
        private bool recup = false;

        public void Init()
        {
            if (recup && loader != null)
            {
                loader.init(this);
            }
        }
        private void init(Limits limites, string name, DirConf parent)
        {
            this.name = name;
            this.limites = limites;
            limites.Parent = this;
            this.parent = parent;
            this.setParent(parent);
            //  this.log = Logger.getLogger(getPath() + "\\dir", false);
            if (parent == null)
            {
                conteneur = new TrackConteneur(this, null);
                if (feeds == null)
                    feeds = new Feeds();
                if (Conf.Html.writeCause <= 0)
                {
                    _causeRegister = new NullRegister();
                }
                else
                    _causeRegister = new CauseRegister();
            }
            else
                conteneur = new TrackConteneur(this, parent.conteneur);
            //transmitToParent = Conf.Transmit;
            //transmitTotal = Conf.TransmitTotal;
            //transmitTotalGuest = Conf.TransmitTotalGuest;
            cascading = Conf.Cascading;
            if (loader != null)
            {
                if (parent != null)
                    loader.Albums.Clear();


            }

            this.borderObs.Clear();

        }

        ///// <summary>
        ///// durée max de chaque item
        ///// </summary>
        //public float Duration
        //{
        //    set { duration = value; }
        //    get
        //    {
        //        if (parent == null || duration < int.MaxValue)
        //        {
        //            return duration;
        //        }
        //        return parent.Duration;

        //    }
        //}

        /// <summary>
        /// Répertoire de type Info
        /// </summary>
        public bool? Info
        {
            get
            {
                if (name == "info")
                    return true;
                if (name == "PAS Info")
                    return false;
                if (parent == null)
                    return null;
                return parent.Info;
            }
        }

        /// <summary>
        /// Répertoire de type rare
        /// </summary>
        public bool? Rare
        {
            get
            {
                if (name == "RARE")
                    return true;
                if (name == "PAS RARE")
                    return false;
                if (parent == null)
                    return null;
                return parent.Rare;
            }
        }
        private bool? histo;
        /// <summary>
        /// Répertoire de type historique
        /// </summary>
        public bool Histo
        {
            get
            {
                if (histo.HasValue)
                    return histo.Value;
                if (name == "Histo")
                    return true;
                if (parent == null)
                    return false;
                return parent.Histo;
            }
            set
            {
                histo = value; 
            }
        }

        public bool ResetBefore;
        public bool ResetAfter; 

        

        private bool serial;
        public bool Serial { get { return serial; } set { serial = value; } }

        /// <summary>
        /// Généralisation de l'historique à tous les noeuds enfant ou simple sélection nominative(par album)
        /// </summary>
        private bool? histoAll;
        public bool? HistoAll
        {
            get
            {
                if (histoAll.HasValue)
                    return histoAll;
                if (parent == null)
                    return null;
                return parent.HistoAll;
            }
            set
            {
                histoAll = value;
            }
        }

        private bool? cascading;
        public bool Cascading
        {
            get
            {
                if (cascading.HasValue)
                    return cascading != false;
                if (false == histoAll)
                    return false;
                if (parent == null)
                    return true;
                return parent.Cascading;
            }
            set
            {
                cascading = value;
            }
        }

        private bool? selectionPre;
        public bool SelectionPre
        {
            get
            {
                if (selectionPre.HasValue)
                    return selectionPre != false;
                if (false == selectionPre)
                    return false;
                if (parent == null)
                    return false;
                return parent.SelectionPre;
            }
            set
            {
                selectionPre = value;
            }
        }

        //private bool transmitToParent = true;
        //public bool TransmitToParent { get { return transmitToParent; } set { transmitToParent = value; } }

        //private bool transmitTotal = true;
        //public bool TransmitTotal { get { return transmitTotal; } set { transmitTotal = value; } }

        //private bool transmitTotalGuest = true;
        //public bool TransmitTotalGuest { get { return transmitTotalGuest; } set { transmitTotalGuest = value; } }



        /// <summary>
        /// Arbre généalogique du répertoire permettant de situer les listes à modifier
        /// </summary>
        public List<string> Folders
        {
            get
            {

                if (parent == null)
                    return new List<string> { name };
                var list = parent.Folders;
                list.Add(name);
                return list;

            }

        }
        public string Name { get { return name; } }

        /// <summary>
        /// Représentation du chemin depuis le root
        /// </summary>
        /// <returns></returns>
        public string getPath()
        {
            return getPath(parent, name);
        }

        public static string getPath(DirConf parent, string name)
        {
            if (parent == null)
                return name;
            string path = parent.getPath();
            if (string.IsNullOrEmpty(path))
                return name;
            return path + "\\" + name;
        }



        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            //sb.Append(" ");
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            //sb.Append(limites.ToString());
            return sb.ToString();
            // return getPath() + " " + Environment.NewLine + limites.ToString();
        }

        public string display()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            sb.AppendLine();
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            sb.Append(limites.ToString());
            return sb.ToString();
        }



        public IEnumerator<DirConf> GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        public List<LimitItem> getAllListItems()
        {
            var list = new List<LimitItem>();
            buildListLimitItems(list);
            return list;
        }

        protected void buildListLimitItems(ICollection<LimitItem> depot)
        {
            foreach (DirConf sub in this)
                sub.buildListLimitItems(depot);
            foreach (Limit limit in limites)
            {
                foreach (LimitItem item in limit.Items)
                    depot.Add(item);
            }
        }

        #region ITrackReport Members

        /// <summary>
        /// Rapport
        /// </summary>
        /// <param name="sb"></param>
        public void rapport(DescBuilder sb)
        {
            sb.beginLine();

            conteneur.rapport(sb);
            sb.AppendLine();


            if (!LimitItem.includeDetail)
                return;
            foreach (DirConf sub in childs)
            {
                var descBuilder = sb.createChild(sub.getPath());
                sub.rapport(descBuilder);
            }

        }
        public double getTotalSize()
        {
            return conteneur.getTotalSize();
        }





        #endregion

        #region IBuilderSource
        public List<TrackInfoItunes> getSelectedTracks()
        {
            var items = new List<TrackInfoItunes>(conteneur.Tracks.Total.Use.List);
            if (Histo)
                items.Sort(new PodcastComparerPubPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;
        }

        public IDictionary<string, TrackInfoItunes> getAllTracks()
        {
            return Feeds.LoadedTracks;
        }


        public string getEmpreinte()
        {
            return conteneur.Tracks.Total.Use.getEmpreinte();
        }


        private AutoBuilder auto;
        public AutoBuilder Auto
        {
            get
            {
                if (auto != null)
                    return auto;
                if (parent != null)
                    return parent.Auto;
                return null;
            }
            set
            {
                auto = value;
            }
        }
        #region IBorder
        private List<AutoBuilder> borderObs = new List<AutoBuilder>();
        public void addBorderObs(AutoBuilder auto)
        {
            borderObs.Add(auto);
        }
        #endregion
        #endregion

        public void signal(TrackBorderItem tb)
        {
            if (false == HistoAll)
                return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(tb);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(tb);
        }


        public bool canSignal()
        {
            return true;
            //if (false == HistoAll || serial) //OUAILLE?
            //    return false;
            //return true; 
        }

        public void signal(CauseDatas cd)
        {
            //if (false == HistoAll || serial) //OUAILLE?
            //    return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(cd);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(cd);
        }

        public double getMaxDateAuto()
        {
            foreach (AutoBuilder border in borderObs)
            {
                return border.getMaxDateAuto(); 
            }
            if (parent != null)
                return parent.getMaxDateAuto();
            return 0; 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Sort.cs">
    <content><![CDATA[using System.Xml;
using pdb.util;
using System;
using System.Collections.Generic;
using pdb.podcast.Albums;

namespace pdb.podcast.Tuning.Sort
{
    public enum sortMode
    {
        no,
        reset,
        white,
        once,
        once_all,
        all,
        //  histo
    }

    public enum histoMode
    {
        /// <summary>
        /// Démarrage de l'histo sur Date0
        /// </summary>
        fix,
        /// <summary>
        /// Démarrage de l'histo sur le premier sélectionné
        /// </summary>
        selected,
        /// <summary>
        /// Démarrage de l'histo sur le dernier lu
        /// </summary>
        read

    }
    public class SortItem : SelectParamBase
    {
        /// <summary>
        /// nom de l'album ou suite d'albums
        /// </summary>
        new public List<string> name = new List<string>();

        public sortMode enabled;
        public bool checkBefore;
        public bool selectionBefore;
       
        ///// <summary>
        ///// prise en compte des longs podcasts
        ///// </summary>
        //public double dureeMin;
        /// <summary>
        /// intervalle max entre deux écoutes (une semaine)
        /// </summary>
        private double intervalle = 7;
        /// <summary>
        /// intervalle min entre deux écoutes (un jour)
        /// </summary>
        private double intervalleMin = 1;
        /// <summary>
        /// intervalle standard entre deux écoutes (un jour)
        /// </summary>
        private double intervalleMin0 = 1;
        /// <summary>
        /// intervalle max entre deux écoutes pour un rare
        /// </summary>
        private double intervalleR;
        /// <summary>
        /// intervalle min entre deux écoutes pour un rare
        /// </summary>
        private double intervalleMinR = 7;
        /// <summary>
        /// intervalle standard entre deux écoutes pour un rare
        /// </summary>
        private double intervalleMinR0 = 7;
        /// <summary>
        /// coeff intervalle par heure du dernier lu
        /// </summary>
        public double rapportDuree = 0;
        /// <summary>
        /// coeff intervalle par heure du dernier lu rare
        /// </summary>
        public double rapportDureeR = 0;
        /// <summary>
        /// On prend en compte la durée pour augmenter le coeff
        /// </summary>
        public bool dureeCoeff;
        /// <summary>
        /// On prend en compte la durée pour augmenter les bornes
        /// </summary>
        public double dureeBorne;
        /// <summary>
        /// On prend en compte la durée pour augmenter les bornes mais on n'augmente que le delta
        /// </summary>
        public double dureeBorneDelta;
        /// <summary>
        /// Densité en-dessous de laquelle l'album est considéré comme rare
        /// </summary>
        public double densiteMin = 0.1;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMin; 
        /// </summary>
        public bool minUseDuree = true;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMin pour les rares
        /// </summary>
        public bool minUseDureeR = true;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMax 
        /// </summary>
        public bool maxUseDuree = true;
        ///  <summary>
        /// On utilise la durée dans le calcul d'intervalleMax pour les rares
        /// </summary>
        public bool maxUseDureeR = true;
        ///// <summary>
        ///// nb d'écoutes maximum dans l'intervalle (typiquement 5)
        ///// </summary>
        //private double ecouteMax;
        ///// <summary>
        ///// nb d'écoutes maximum dans l'intervalle pour un rare
        ///// </summary>
        //private double ecouteMaxR;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute
        /// </summary>
        private double histo;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute pour un rare
        /// </summary>
        private double histoR;
        /// <summary>
        /// nombre d'items pris en comptepour l'historique
        /// </summary>
        private int nbHisto;
        /// <summary>
        /// nombre d'items pris en comptepour l'historique pour un rare
        /// </summary>
        private int nbHistoR;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : nombre minimum d'éléments à prendre en compte
        /// </summary>
        public int deltaNbMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'éléments à prendre en compte
        /// </summary>
        public int deltaNbRab;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : intervalle minimum à prendre en compte en jours
        /// </summary>
        public double deltaMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'intervalle à prendre en compte
        /// </summary>
        public double deltaRab;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'intervalle à prendre en compte, en proportion de l'écart initial
        /// </summary>
        public double coeffRab;
        /// <summary>
        /// Ecart min entre deux podcasts non rares à l'atterrissage
        /// </summary>
        public double atterrissageMin = 0.5;

        /// <summary>
        /// Ecart min absolu
        /// </summary>
        private double atterrissageMin0 = 0.5;
        /// <summary>
        /// Ecart min entre deux podcasts rares à l'atterrissage
        /// </summary>
        public double atterrissageMinR = 1;

        /// <summary>
        /// Détermination de la densité à venir sur N jours
        /// </summary>
        public double futur = -1;
        /// <summary>
        /// Détermination de la densité à venir sur N jours pour les rares
        /// </summary>
        public double futurR = -1;
        /// <summary>
        /// Pour calcul horizon, période globale à prenre en compte
        /// </summary>
        public double futurh = 365; 
        /// <summary>
        /// Pour calcul horizon, périodes à prenre en compte
        /// </summary>
        private List<double> futurhl= new List<double>();

        /// <summary>
        /// Pour calcul horizon, périodes à prenre en compte pour les rares
        /// </summary>
        private List<double> futurhlR = new List<double>();

        /// <summary>
        /// Partie futur antérieure. Permet de limiter les grosses moyennes; à la dernire occurance, on prend en compte une durée avant
        /// </summary>
        public double futura = 0; 

        /// <summary>
        /// Dans la correction du delta par rapport à la proportion de lus, une tolérance pour pouvoir par exemple laisser courir pendant une semaine
        /// </summary>
        public double tolerance = 35;

        /// <summary>
        /// Dans la correction du delta par rapport à la proportion de lus, une tolérance pour pouvoir par exemple laisser courir pendant un mois 
        /// </summary>
        public double toleranceR = 35;

        /// <summary>
        /// Dans le calcul de la tolérance, nb de morceaux à prendre en compte; 
        /// </summary>
        public int nbTolerance;

        /// <summary>
        /// Dans le calcul de la tolérance, nb de morceaux à prendre en compte pour les rares; 
        /// </summary>
        public int nbToleranceR;

        /// <summary>
        /// si dépassement on rappelle
        /// </summary>
        public bool toleranceNegative;

        /// <summary>
        /// pas d'empilage des tracks repoussés
        /// </summary>
        public bool noCollision;
        /// <summary>
        /// recalcul peut entrainer une date plus récente
        /// </summary>
        public bool canGoBack;
        /// <summary>
        /// recalcul peut entrainer une date plus récente, mais si ça le rend non séléctionné, on bricole pour qu'il soit quand même selectionné
        /// </summary>
        public bool canGoBackButForceSelected;
        /// <summary>
        /// écart constant entre les poscasts repoussés
        /// </summary>
        public bool deltaConst;

        /// <summary>
        /// Date0 lors de l'écoute du dernier podcast externe
        /// </summary>
        public DateTime extLast0;
        /// <summary>
        /// Décalage entre date du podcast supplémentaire et la date0
        /// </summary>
        public double extDelta;
        /// <summary>
        /// coefficient permettant le calcul de la prochaine date en fonction du retard entre la date0 et maintenant
        /// </summary>
        public double extPente;
        /// <summary>
        /// check de la date de dernière lecture
        /// </summary>
        public bool limitRead;
        ///// <summary>
        ///// Dans le calcul de delta ne pas inclure les non-selectionnés
        ///// </summary>
        //public bool deltaCheckSelected;
        /// <summary>
        /// handicap pour les nouveaux podcasts
        /// </summary>
        public int totalMin;
        /// <summary>
        /// Coefficient de rappel vers la valeur initiale pour les lus
        /// </summary>
        public double elastique = 1;

        /// <summary>
        /// Coefficient de rappel vers la valeur initiale pour les non lus
        /// </summary>
        public double elastique2 = 1;

        /// <summary>
        /// Cumul max de retard pour les non-rares
        /// </summary>
        public double cumulMax = -1;

        /// <summary>
        /// Cumul max de retard pour les rares
        /// </summary>
        public double cumulMaxR = -1;

        /// <summary>
        /// Cumul min de retard pour les non-rares
        /// </summary>
        public double cumulMin = -1;

        /// <summary>
        /// Cumul min de retard pour les rares
        /// </summary>
        public double cumulMinR = -1;

        /// <summary>
        /// Pas d'amortissement pour les vieux podcasts, vieux en jours par rapport à la date0
        /// </summary>
        public int deltaConstLate = -1;

        /// <summary>
        /// Utilisation de track virtuels pour éviter accidents (tracks manquants)
        /// </summary>
        public bool useVirtuel;

        /// <summary>
        /// Utilisation de track virtuels pour affectation pub2
        /// </summary>
        public bool useVirtuel2;

        /// <summary>
        /// Dès la pub2 remise à zero, les suivants aussi
        /// </summary>
        public bool erasedDone;
        /// <summary>
        /// On recalcule tout
        /// </summary>
        public bool recheck;
        /// <summary>
        /// En mode vacance on tasse moins les tracks. implique !recheck
        /// </summary>
        public bool vacances;
        /// <summary>
        /// on fait comme avant
        /// </summary>
        public bool oldMode;

        /// <summary>
        /// Dans le coeff, on prend en compte la densité
        /// </summary>
        public bool coeffDensite;


        /// <summary>
        /// On utilise des intervalles en fonction de la répartition effective ( et non pas déclarative ) des tracks. En clair les intervalles de 7j ou de 1j sont plus finement évalués
        /// </summary>
        public bool intervalleVar;
        /// <summary>
        /// Proportion entre 0 et 1 de l'atterrissage par rapport à intervalleMin
        /// </summary>
        public double atterrissageMinVar = 1;

        /// <summary>
        /// Détermination plutôt que déclaration de intervalleMin0
        /// </summary>
        private bool useintervalleFactMin;

        /// <summary>
        /// on limite aux valeurs "rare" (14j * duree) 
        /// </summary>
        private bool intervalleBorne;
        /// <summary>
        /// Un petit coup de rallonge pour les bientôt finis
        /// </summary>
        public bool honneurAuxVieux;
        /// <summary>
        /// On n'applique l'horizon qu'à la fin
        /// </summary>
        public bool horizonFinal;
        /// <summary>
        /// l'interpolation n'est pas linéaire mais au carré entre 0 et un et asymptotique vers 2 après
        /// </summary>
        public bool mixCarre;
        /// <summary>
        /// Aggrégation de la densite et de la duree positionnement du variable
        /// </summary>
        private bool mixVarDuree;

        /// <summary>
        /// Arret quand la date0 change
        /// </summary>
        public bool stopOnOffset;

        /// <summary>
        /// Arret quand une pub2 change
        /// </summary>
        public bool stopOnPub2;

        /// <summary>
        /// Coeff > 1 appliqué au rapport en vue de déterminer l'horizon. Permet de diminuer l'horiszon et nous donner un peu d'air - marre des séries à +10j
        /// </summary>
        public double rapportHorizonCoeff = 1.0;
        /// <summary>
        /// Coeff > 1 appliqué au rapport en vue de déterminer l'horizon pour les rares. Permet de diminuer l'horiszon et nous donner un peu d'air - marre des séries à +10j
        /// </summary>
        public double rapportHorizonCoeffR = 1.0;

        /// <summary>
        /// en cas de plusieurs podcasts dans la même journée, durée min pour en compter plusieurs en min
        /// </summary>
        public double collisionDuree = -1;

        /// <summary>
        /// Moyenne limite
        /// </summary>
        public double limitMoy = -1;

        /// <summary>
        /// Delta limite
        /// </summary>
        public double limitDelta = -1; 

        

        public histoMode histoMode;

        private ITrackSelector selector;

        public SortItem()
        {
        }

        public SortItem(XmlElement parent, XmlElement node)
            : base(parent, node)
        {

            if (node == null)
                return;
            var str = "";
            builds("name", v => str = v);

            if (!string.IsNullOrEmpty(str))
            {
                foreach (string album in str.Split('|'))
                {
                    if (!string.IsNullOrWhiteSpace(album))
                        name.Add(album.ToLowerWithoutDiacritics());
                }
            }

            builds("enabled", v => str = v);

            if (!string.IsNullOrEmpty(str))
                enabled = (sortMode)Enum.Parse(typeof(sortMode), str);

            buildd("dureeMin", v => dureeMin = v);
            buildd("intervalle", v => intervalle = v);
            buildd("intervalleMin", v => intervalleMin = v);
            buildd("intervalleMin0", v => intervalleMin0 = v);
            buildd("intervalleR", v => intervalleR = v);
            buildd("intervalleMinR", v => intervalleMinR = v);
            buildd("intervalleMinR0", v => intervalleMinR0 = v);

            buildd("atterrissageMin", v => atterrissageMin = v);
            buildd("atterrissageMinR", v => atterrissageMinR = v);
            buildd("histo", v => histo = v);
            buildd("histoR", v => histoR = v);
            buildi("nbHisto", v => nbHisto = v);
            buildi("nbHistoR", v => nbHistoR = v);

            buildd("futur", v => futur = v);
            buildList("futurhl", futurhl);
            buildList("futurhlR", futurhlR); 
            buildd("futura", v => futura = v);
            buildd("futurR", v => futurR = v);
            //buildd("ecouteMax", v => ecouteMax = v);
            //buildd("ecouteMaxR", v => ecouteMaxR = v);

            buildDate("extLast0", v => extLast0 = v);
            buildd("extDelta", v => extDelta = v);
            buildd("extPente", v => extPente = v);




            buildb("deltaConst", v => deltaConst = v);
            buildb("toleranceNegative", v => toleranceNegative = v);
            buildi("deltaConstLate", v => deltaConstLate = v);
            buildb("useVirtuel", v => useVirtuel = v);
            buildb("useVirtuel2", v => useVirtuel2 = v);

            buildb("noCollision", v => noCollision = v);
            buildb("checkBefore", v => checkBefore = v);
            buildb("selectionBefore", v => selectionBefore = v);
            buildb("limitRead", v => limitRead = v);
            buildb("canGoBack", v => canGoBack = v);
            // buildb("deltaCheckSelected", v => deltaCheckSelected = v);

            #region lissage
            buildi("deltaNbMin", v => deltaNbMin = v);
            buildi("deltaNbRab", v => deltaNbRab = v);

            buildd("deltaMin", v => deltaMin = v);
            buildd("deltaRab", v => deltaRab = v);

            #endregion

            builds("histoMode", v => str = v);
            histoMode = (histoMode)Enum.Parse(typeof(histoMode), str);

            buildi("totalMin", v => totalMin = v);

            buildd("elastique", v => elastique = v);
            buildd("elastique2", v => elastique2 = v);



            buildd("cumulMin", v => cumulMin = v);
            buildd("cumulMinR", v => cumulMinR = v);
            buildd("cumulMax", v => cumulMax = v);
            buildd("cumulMaxR", v => cumulMaxR = v);
            buildd("rapportDuree", v => rapportDuree = v);
            buildd("rapportDureeR", v => rapportDureeR = v);
            buildd("coeffRab", v => coeffRab = v);


            buildb("dureeCoeff", v => dureeCoeff = v);
            buildd("dureeBorne", v => dureeBorne = v);
            buildd("dureeBorneDelta", v => dureeBorneDelta = v);
            buildd("densiteMin", v => densiteMin = v);


            buildb("minUseDuree", v => minUseDuree = v);
            buildb("maxUseDuree", v => maxUseDuree = v);

            buildb("minUseDureeR", v => minUseDureeR = v);
            buildb("maxUseDureeR", v => maxUseDureeR = v);

            buildb("erasedDone", v => erasedDone = v);
            buildb("recheck", v => recheck = v);
            buildb("vacances", v => vacances = v);
            buildb("oldMode", v => oldMode = v);

            buildd("tolerance", v => tolerance = v);
            buildd("toleranceR", v => toleranceR = v);

            buildi("nbTolerance", v => nbTolerance = v);
            buildi("nbToleranceR", v => nbToleranceR = v);

            buildb("coeffDensite", v => coeffDensite = v);
            buildb("intervalleVar", v => intervalleVar = v);
            buildd("atterrissageMinVar", v => atterrissageMinVar = v);
            buildb("useintervalleFactMin", v => useintervalleFactMin = v);
            buildb("intervalleBorne", v => intervalleBorne = v);
            buildb("honneurAuxVieux", v => honneurAuxVieux = v);
            buildb("horizonFinal", v => horizonFinal = v);
            buildd("atterrissageMin0", v => atterrissageMin0 = v);
            buildb("mixCarre", v => mixCarre = v);
            buildb("mixVarDuree", v => mixVarDuree = v);
            buildb("stopOnOffset", v => stopOnOffset = v);
            buildb("stopOnPub2", v => stopOnPub2 = v);

            buildd("rapportHorizonCoeff", v => rapportHorizonCoeff = v);
            buildd("rapportHorizonCoeffR", v => rapportHorizonCoeffR = v);

            buildd("collisionDuree", v => collisionDuree = v);
            buildd("limitMoy", v => limitMoy = v);
            buildd("limitDelta", v => limitDelta = v); 

            this.selector = new TrackSelector(this);
        }
        /// <summary>
        /// donne l'intervalle plafond
        /// </summary>
        /// <param name="rare">album rare</param>
        /// <param name="duree">duree du dernier track en heures</param>
        /// <returns></returns>
        public double getIntervalle(bool rare, double duree, double intervalleMin0)
        {
            var _intervalle = rare && intervalleR > 0 ? intervalleR : intervalle;
            var _rapportDuree = rare ? rapportDureeR : rapportDuree;
            return getIntervalle(_intervalle, _rapportDuree, duree, intervalleMin0);
        }

        

        private double getIntervalle(double intervalle, double rapportDuree, double duree, double intervalleMin0)
        {
            var ret0 = intervalle;
            var ret1 = ret0;
            var ret2 = ret0;
            var coeff = duree * rapportDuree;
            if (coeff > 1)
            {
                if (dureeBorne > 0)
                {

                    // ex coeff =2
                    // avec dureeBornee = 0 => ret0
                    // avec dureeBornee = 0.1 =>0.9 +0.2    =>1.1 *ret0
                    // avec dureeBorne = 0.5 => 0.5 +1      =>1.5 *ret0
                    // avec dureeBorne = 0.9 => 0.1+1.8     =>1.9 *ret0
                    ret1 = ret0 * ((1 - dureeBorne) + coeff * dureeBorne);

                }
                if (dureeBorneDelta > 0)
                {
                    var delta = ret0 - intervalleMin0;
                    delta *= ((1 - dureeBorneDelta) + coeff * dureeBorneDelta);
                    ret2 = intervalleMin0 + delta;
                }
            }

            if (ret1 > ret2)
                return ret1;
            else
                return ret2;


        }

        private double getMix(double i, double ir, double X, double rapportDuree, double duree)
        {
            var coeff = rapportDuree * duree;
            if (coeff > 1)
                X *= coeff;
            return getMix(i, ir, X); 
        }
        /// <summary>
        /// Corrige le rapport pour determination de l'horizon 
        /// </summary>
        /// <param name="rapport"></param>
        /// <param name="X"></param>
        /// <returns></returns>
        public double getHorizonCorrec(double rapport, double X)
        {
            double r = rapportHorizonCoeffR;
            if (X < 0)
                r = rapportHorizonCoeff;
            //else if (X > 1)
            //{
            //}
            else
                r = rapportHorizonCoeff + X * (rapportHorizonCoeffR - rapportHorizonCoeff); 
            // r = getMix(rapportHorizonCoeff, rapportHorizonCoeffR, X);
            if (r < 1)
                r = 1; 
            var rapportModif = r * rapport;
            if (rapportModif > 1)
                rapportModif = 1;

            return rapportModif; 

        }

        private double getMix(double i, double ir, double X)
        {
            if (X <= 0)
                return i;
            else if (X >= 1 && intervalleBorne)
                return ir;
            if (mixCarre)
            {
                if (X <= 1)
                    return i + X * X * (ir - i); 
                // 1=> ir v = 2 *(ir-i)
                // y= ax2
                return (2 * ir) - ir / X; 
            }
            return i + X * (ir - i);
            // avec i=2 et ir =1 
            //X=0.1 => 2+ 0.01*-1=> 1.99 correct
            //X=0.9 => 2 -0.81 = 1.19
            //X=1.1=> 2- 1/1.1

        }
        public double getIntervalleVar(bool rare, double X, double duree, double intervalleMin0)
        {
            var _rapportDuree = rare ? rapportDureeR : rapportDuree;
            if (mixVarDuree)
                return getMix(intervalle, intervalleR, X, _rapportDuree, duree); 
           
            double _intervalle = getMix(intervalle, intervalleR,X);
            return getIntervalle(_intervalle, _rapportDuree, duree, intervalleMin0);
        }

        private double getCoeffDuree(double rapportDuree, double duree)
        {
            var coeff = duree * rapportDuree;
            if (coeff > 1)
                return coeff;
            return 1; 
        }

        public double getRapport(bool rare, double duree)
        {
            var rapport0 = rare ? intervalleR / intervalleMinR0 : intervalle / intervalleMin0;
            var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
            if (coeff > 1)
                return rapport0 * coeff;
            return rapport0;
        }

        public bool applyDuree(bool min, bool rare)
        {
            if (dureeCoeff)
                return false;
            bool use = rare ? (min ? minUseDureeR : maxUseDureeR) : (min ? minUseDuree : maxUseDuree);
            return use;
        }
        public double getIntervalleMin(bool rare, double duree)
        {
            var ret0 = rare && intervalleMinR > 0 ? intervalleMinR : intervalleMin;
            if (applyDuree(true, rare))
            {
                var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
                if (coeff > 1)
                    return ret0 * coeff;
            }
            return ret0;
        }

        public double getIntervalleMinVar(bool rare, double X, double duree)
        {
            if (mixVarDuree )
            {                
                if (applyDuree(true, rare))
                {
                    var _rapportDuree = rare ? rapportDureeR : rapportDuree;
                    return getMix(intervalleMin, intervalleMinR, X, rapportDuree, duree); 
                }
                else
                    return getMix(intervalleMin, intervalleMinR, X); 
                   
            }
            var ret0 = getMix(intervalleMin, intervalleMinR, X); 
            if (applyDuree(true, rare))
            {
                var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
                if (coeff > 1)
                    return ret0 * coeff;
            }
            return ret0;
        }

        public double getCoeff(bool rare, double coeff0, double duree)
        {

            var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
            if (coeff > 1)
                return coeff0 * coeff;

            return coeff0;

        }

        public double getFutur(bool rare)
        {
            return rare ? futurR : futur;
        }

        public List<double> getFuturHList(bool rare)
        {
            return rare ? futurhlR : futurhl;
        }

        public double getTolerance(bool rare)
        {
            return rare ? toleranceR : tolerance;
        }

        public int getNbTolerance(bool rare)
        {
            return rare ? nbToleranceR : nbTolerance;
        }


        public double getIntervalleMin0(bool rare)
        {
            var ret0 = rare && intervalleMinR0 > 0 ? intervalleMinR0 : intervalleMin0;
            return ret0;
        }

        public double getIntervalleMin0Var(double X, double intervalleFactMin)
        {
            if (useintervalleFactMin)
                return intervalleFactMin;
            return getMix(intervalleMin0, intervalleMinR0, X);            
        }


        public double getatterrissageMinVar(double X, double intervalleFactMin)
        {
            if (useintervalleFactMin)
                return intervalleFactMin * atterrissageMinVar;
            var ret =  getMix(atterrissageMin, atterrissageMinR, X);
            if (ret < atterrissageMin0)
                ret = atterrissageMin0;
            return ret; 

        }
        public double getHisto(bool rare)
        {
            return rare && histoR > 0 ? histoR : histo;
        }
        public int getNbHisto(bool rare)
        {
            return rare && nbHisto > 0 ? nbHistoR : nbHisto;
        }
        //public double getEcouteMax(bool rare)
        //{
        //    return rare && ecouteMaxR > 0 ? ecouteMaxR : ecouteMax;
        //}
        ///// <summary>
        ///// Donne le recalage max par morceau pour atterissage: typiquement pour un non-rare :0.5, pour un rare, disons 1
        ///// </summary>
        ///// <param name="rare"></param>
        ///// <returns></returns>
        //public double getRecupMax(bool rare)
        //{
        //    double ini = getIntervalleMin0(rare);
        //    if (rare)
        //        return ini - atterrissageMinR;
        //    else
        //        return ini - atterrissageMin; 
        //}

        public double getAtterrissageMin(bool rare)
        {
            return rare ? atterrissageMinR : atterrissageMin;
        }

        internal bool select(ISelectable album)
        {
            return selector.select(album);
        }

        public double getCumulMax(bool rare)
        {
            return rare && cumulMaxR > 0 ? cumulMaxR : cumulMax;
        }
        public double getCumulMin(bool rare)
        {
            return rare && cumulMinR > 0 ? cumulMinR : cumulMin;
        }


    }
    public class Sort : SortItem
    {
        private List<SortItem> items = new List<SortItem>();
        private List<SortItem> rules = new List<SortItem>();

        public SortItem getItem(string key)
        {
            foreach (SortItem g in items)
            {
                if (g.name.Contains(key))
                    return g;

            }
            return null;
        }

        public SortItem getRule(TrackAlbum album)
        {
            foreach (SortItem r in rules)
            {
                if (r.select(album))
                    return r;
            }

            return null;
        }
        public Sort()
        {

        }

        public Sort(XmlElement node)
            : base(null, node)
        {
            if (node == null)
                return;
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    if (sub.Name == "album")
                    {
                        items.Add(new SortItem(node, sub as XmlElement));
                    }
                    else if (sub.Name == "rule")
                    {
                        rules.Add(new SortItem(node, sub as XmlElement));
                    }
                }
            }


        }




    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des données morceux dupliqués 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;
        private bool goCompact = true;
        private bool classementChange; 
        private bool _firstConsolid = true;
        private bool _albumBuild = false;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private PlayList root = new PlayList("root", null);
        public PlayList Root { get { return root; } }
        private PlayList musique;
        private PlayList classement;
        private PlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new PlayList("musique", root);
            classement = new PlayList("classement", root);
            listes = new PlayList("listes", root);
            albums = new Albums(this);
        }
        /// <summary>
        /// Lance le compactage à la prochaine génération
        /// </summary>
        public void GoCompact() { goCompact = true; }
        public void ClassementChange() { classementChange = true; }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating(false);
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        //public void buildClassTree()
        //{
        //    buildClassTree(classement);
        //}


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public Albums Albums { get { return albums; } }
        public void invalidateAlbums() { }// pour l'instant ne fonctionne pas  _albumBuild = false; albums.invalidateAll(true); }
        public void ConsolidInit(IEnumerable<ITrackNativeDates> dbList)
        {
            if (_albumBuild)
                return;
            allClassed.Clear();
            allClassedInAlbumEnabled.Clear();
            m_listTrackClassed.Clear();

            listPiece.Clear();
            listPieceInAlbum.Clear();
            all.Clear();

            // albums = new Albums(this);
            VirtualPiece.init();

            htIds.Clear(); 

            //  htIds = new BgDict<int, Piece>();
            foreach (ITrackNativeDates track in dbList)
            {

                if (!track.isPodcast)
                {
                    Piece piece = null;
                    int pieceId = track.PieceId;
                    if (htIds.ContainsKey(pieceId))
                    {
                        piece = htIds[pieceId];
                        piece.initRank();
                    }
                    else
                    {
                        piece = new Piece(track);
                        htIds.Add(pieceId, piece);
                    }

                    all.Add(piece);

                }
            }
            // link
            foreach (Piece piece in all)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.Parent = htIds[parentId];
                }
            }

            // liste FORT + albums

            albums.checkBuild();
            logger.log("build albums");
            foreach (Piece piece in all)
            {
                
                if (piece.Parent == null)
                {
                   // piece.removeVirtualChilds(); 
                    listPiece.Add(piece);
                    foreach (Piece p in piece)
                    {
                        if (albums.check(p))
                            listPieceInAlbum.Add(p);
                    }
                }
            }

            var confGen = CConf.ConfGen;
            var min = confGen.AlbumMin;

            if (_albumVirtual)
            {
                logger.log("build albums virtuels");
                var listCandidat = new List<Piece>();
                var dictTmp = new BgDictString<Album>();
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        piece.buildVirtualAlbums(listCandidat);
                    }
                }
                foreach (Piece p in listCandidat)
                    albums.checkVirtual(p, dictTmp);




                min = confGen.PathVirtualMin;
                if (min > 1)
                {
                    // Suppression des albums virtuel par répertoire avec trop peu de morceaux
                    foreach (var key in new List<string>(dictTmp.Keys))
                    {
                        var a = dictTmp[key];
                        if (a.Virtual && !a.VirtualByArtist)
                        {
                            if (a.Count < min)
                                dictTmp.Remove(key);
                        }
                    }
                }

                if (confGen.ArtistVirtual)
                {
                    min = confGen.AristVirtualMin;
                    if (min > 1)
                    {
                        // Suppression des albums artiste avec trop peu de morceaux
                        foreach (var key in new List<string>(dictTmp.Keys))
                        {
                            var a = dictTmp[key];
                            if (a.VirtualByArtist)
                            {
                                if (a.Count < min)
                                    dictTmp.Remove(key);

                            }
                        }
                    }
                }





                var listAlbums = new List<Album>(dictTmp.Values);

                listAlbums.Sort(new VirtualAlbumComparer());
                albums.checkVirtuals(listAlbums, listPieceInAlbum);

            }

            albums.buildDone();

            // Suppression des albums avec trop peu de morceaux
            min = confGen.AlbumMin;
            if (min > 1)
            {
                // Suppression des albums standards avec trop peu de morceaux
                var dict = albums.Dict;
                foreach (var key in new List<string>(dict.Keys))
                {
                    var a = dict[key];
                    if (!a.Virtual)
                    {
                        if (a.Count < min)
                            dict.Remove(key);
                    }
                }
            }
            albums.sortVirtual(); 
            _albumBuild = true;

        }


        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList, bool makeSort)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                DateTime now = DateTime.Now;
                DateTime debut = now;

                allClassed.Clear();
                allClassedInAlbumEnabled.Clear();
                m_listTrackClassed.Clear();

                ConsolidInit(dbList);
                now = DateTime.Now;

                StackAlbum.Instance.init(all);

                misc.log("StackAlbum.Instance.init(all); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                misc.log("allClassed; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;



                misc.log("makeConsolid:init; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now;
                Ranking(makeSort);
                misc.log("makeConsolid:fin; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            }
            finally
            {
                lock (_lock)
                {
                    _firstConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece); // addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbum)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif

        }

        public void buildLists(PlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                // mine.add(sub);
                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }


            //foreach (PlComponent c in ext)
            //{
            //    if (c is CPlayList)
            //    {
            //        var subExt = c as CPlayList;
            //        var sub = new CPlayList(subExt.Name, mine);
            //        sub.ID = subExt.ID;
            //        // mine.add(sub);
            //        buildList(sub, subExt);
            //    }
            //    else
            //    {
            //        var t = c as IFile;
            //        var piece = htIds[t.PieceId];
            //        mine.add(new TrackList(piece));
            //    }
            //}
        }



        internal Album getAlbum(Piece track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort)
        {
            albums.buildStack(makeSort);
            QRanking();
            LRanking();
            QLRanking();

            if (Piece.Compact)
            {
                if (goCompact || (classementChange && CConf.ConfGen.AlbumSort.compactAny))
                {
                    lock (Albums.LockSort)
                    {
                        goCompact = false;
                        classementChange = false;
                        var l = new List<Piece>(this.listPiece);
                        l.Sort(new CPieceComparerByQualityAndLength2());
                        new Condenseur(listPieceInAlbum ).gener2();
                    }
                }
            }


            var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");


            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);
            // if (makeSort)
            albums.makeSort(_firstConsolid);
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal(false));
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating(false));
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");
            DateTime now = DateTime.Now;
            DateTime debut = now;



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }

            misc.log("piece.Rank.init(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


            //on ordonne les morceaux top-down => sont privilégiés les plus en vue
            listPiece.Sort(l_pieceComparer);

            misc.log("listPiece.Sort(l_pieceComparer); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

            //compactage de la liste en tenant compte des mieux notés
            m_list = new CListPiece(listPiece);


            misc.log(" m_list = new CListPiece(listPiece); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now;
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }
            logger.log("fin : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now;
            // Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

            logger.log("total QRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now;

            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }

            logger.log("total LRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));
        }

        //public void compact()
        //{
        //    if (Piece.Compact)
        //    {
        //        if (goCompact || CConf.ConfGen.AlbumSort.compactAny)
        //        {
        //            goCompact = false;
        //            var l = new List<Piece>(this.listPiece);
        //            l.Sort(new CPieceComparerByQualityAndLength2());
        //            new Condenseur(m_listQL).gener2();
        //        }
        //    }
        //}
        /// <summary>
        /// Tri des morceaux en fonction de leur qualité +longueur en cas d'égalité
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now;

            m_listQL = new List<Piece>(m_listTrackClassed);
            foreach (Piece p in m_listQL)
                p.invalidateCache(false);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }
           

            //if (CConf.Condensation)
            //{
            //    var l = new List<Piece>(this.listPiece);
            //    l.Sort(new CPieceComparerByQualityAndLength2());
            //    new Condenseur(m_listQL).gener2();

            //}


            logger.log("total QLRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }


        private static volatile object _lockStat = new object();
        //   private static volatile object _lockStat2 = new object();
        private static bool buildingStat;
        const string BUILDING_STATE = @"..\building.txt";
        const string LOADING_EXCEL = @"..\busyExcel.txt";

        private void _buildStat(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 1");
                    return;
                }


                try
                {
                    if (File.Exists(LOADING_EXCEL))
                    {
                        string content = File.ReadAllText(LOADING_EXCEL);
                        misc.log(content);
                        if (content.Contains("BUSY"))
                        {
                            return;
                        }
                    }
                }
                catch (Exception ex)
                {
                    misc.logError("Impossible de lire le fichier lock excel", ex);
                    return;
                }

                buildingStat = true;
            }



            try
            {
                //bool ok = Monitor.TryEnter(_lockStat2, 60 * 1000);
                //if (!ok)
                //{
                //    misc.log("Pas pu entrer pour générer les stats !!!!!!");
                //    return;
                //}


                File.WriteAllText(BUILDING_STATE, "BUILDING");
                bool generDistrib = step % 10 == 0;
                var list = new List<Piece>(m_listQL);
                list.Sort(new ClassementValueDecimal0Comparer());

                if (_albumSortMode.createCourant)
                {
                    var unselected = list.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = list.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(list).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(list) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(list) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                lock (_lockStat)
                {
                    buildingStat = false;
                    File.WriteAllText(BUILDING_STATE, "FREE");
                }
                if (rappel != null)
                    rappel();
            }
        }

        public void builStats(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 0");
                    return;
                }

            }
            //  _buildStat(rappel); 
            new Thread(() => _buildStat(rappel)).Start();

        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table m�tier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates, IEnumerable<Piece>, IItem
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual virtualMode VirtualMode { get { return virtualMode.none; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } get { return gen; } }
        /// <summary>
        /// Permet d'utiliser le classement Compact. 
        /// </summary>
        private bool useCompact = Compact;
        // private bool useCompact0 = Compact;
        public static bool Compact;
        public static string compact(string strClassement)
        {
            if (!Compact)
                return null;

            if (string.IsNullOrEmpty(strClassement))
                return null;
            if (ClassementHash.ZERO_KEY == strClassement)
                return null;
            var cl = classementHash.getCache(strClassement);
            var res = tradCompact[cl.ClassementValueDecimal];
            if (string.IsNullOrEmpty(res))
            {
            }
            return res;
        }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        public bool UseCompact { get { return useCompact; } set { useCompact = value; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void resetMedianneCompact() { _infoMedianne = infoMedianne.none; useCompact = Compact; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
            // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }
        public int RankAlbumZero { get { if (album == null) return 0; return gen.Albums.RankZero - album.RankZero; } }
        public int RankAlbumSt { get { if (album == null) return 0; return album.RankSt; } }
        public int RankAlbumZeroSt { get { if (album == null) return 0; return album.RankZeroSt; } }




        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        // public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public decimal ClassementValueLight { get { if (album == null) return 0; return album.ClassementValueLight; } }
        public decimal ClassementValueLight0 { get { if (album == null) return 0; return album.ClassementValueLightZero; } }
        public decimal ClassementValueLightSt { get { if (album == null) return 0; return album.ClassementValueLightSt; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Moved = value; } }
        public bool MovedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Moved;
                    default:
                        return false;
                }
            }
        }

        public bool isEmpeached()
        {
            if (album == null) return false;
            return album.Empeached;
        }

        public int EmpeachedNb { get { if (album == null) return 0; return album.EmpeachedNb; } }

        public bool Empeached { get { if (album == null) return false; return album.Empeached && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Empeached = value; } }
        public bool EmpeachedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Empeached;
                    default:
                        return false;
                }
            }
        }
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get { if (album == null) return false; return album.Empeached1 && this == album.Next; } set { if (album != null) album.Empeached1 = value; } }
        public bool AlmostFree { get { if (album == null) return false; return album.AlmostFree && this == album.Next; } }
        public bool AlmostFree1 { get { if (album == null) return false; return album.AlmostFree1 && this == album.Next; } }

        public bool AlbumRecentlyUpdated { get { return StackValue > 0 && SelectedMotif == selectedCoeff.noCoeff; } }
        public bool AlbumRecentlyUpdatedMain
        {
            get
            {
                if (StackValue == 0) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return true;
                    default:
                        return false;
                }
            }
        }


        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch();
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache(true);

        }

        public string ClassementCompact
        {
            get
            {

                return getClassementCache(true).strClassement;
                //if (parent != null)
                //    return parent.ClassementCompact;
                //if (Compact)
                //{
                //    if (string.IsNullOrEmpty(_classementCompact))
                //        return ClassementCache.strClassement;
                //    return _classementCompact;
                //}
                //else
                //    return ClassementCache.strClassement;

            }
        }
        public static ClassementHash classementHash = new ClassementHash();
        //private ClassementCache _classementCache;
        //private ClassementCache ClassementCache
        //{
        //    get
        //    {


        //        if (_classementCache == null)
        //        {
        //            if (parent != null)
        //                _classementCache = parent.ClassementCache;
        //            if (_classementCache == null)
        //            {
        //                if (Compact)
        //                {
        //                    if (string.IsNullOrEmpty(_classementCompact))
        //                        _classementCache = classementHash.getCache(track.ClassName, track.Rating);
        //                    else
        //                        _classementCache = classementHash.getCache(_classementCompact);
        //                }
        //                else
        //                    _classementCache = classementHash.getCache(track.ClassName, track.Rating);

        //            }
        //        }
        //        return _classementCache;
        //    }
        //}

        // private bool keep;
        private static Dictionary<int, decimal> hsKeep = new Dictionary<int, decimal>();
        public bool Keep
        {
            get { return hsKeep.ContainsKey(PieceId); } //  .Contains(PieceId); }
            //set
            //{
            //    if (value)
            //        hsKeep.Add(PieceId);
            //    else
            //        hsKeep.Remove(PieceId);
            //}
        }

        public decimal KeepCoeff
        {
            get
            {
                if (!Keep)
                    return 0;
                return hsKeep[PieceId];
            }
        }

        public void setKeep(decimal coeff)
        {
            if (hsKeep.ContainsKey(PieceId))
            {
                if (coeff == 0m)
                    hsKeep.Remove(PieceId);
                else
                    hsKeep[PieceId] = coeff;
            }
            else
            {
                if (coeff > 0m)
                    hsKeep.Add(PieceId, coeff);
            }
        }

        private static HashSet<int> ksCompact = new HashSet<int>();
        private static Dict<decimal, string> tradCompact = new Dict<decimal, string>();
        // private static Dict<int, string> dictCompact = new Dict<int, string>();

        public static void resetCompact() { tradCompact.Clear(); }
        //private bool UseCompact0
        //{
        //    get
        //    {
        //        if (parent == null)
        //            return useCompact0;
        //        return parent.useCompact0;
        //    }
        //}
        private ClassementCache getClassementCache(bool _compact)
        {
            //if (parent != null)
            //    return parent.getClassementCache(_compact);
            //  ClassementCache compactc = null;

            var str = StrClassementCoeff;
            if (_compact && useCompact && ClassementACompacter)
            {
                var strCompact = compact(str);
                if (str != ClassementHash.ZERO_KEY && string.IsNullOrEmpty(strCompact))
                {
                }
                else
                    return classementHash.getCache(strCompact);

            }
            return classementHash.getCache(str);
            // return classementHash.getCache(strClassement);


        }



        // private string _classementCompact;



        /// <summary>
        /// Compacte le classement - returne OK si fait
        /// </summary>
        /// <param name="classement"></param>
        /// <returns></returns>
        public bool setClassementCompact(string classement)
        {
            invalidateCache(true);

            // _classementCompact = classement;
            var _compact = classementHash.getCache(classement);
            var org = classementHash.getCache(StrClassementCoeff);

            if (org.ClassementValueDecimal <= _compact.ClassementValueDecimal)
            {
                //  useCompact0 = false;
                //tradCompact.Remove(org.strClassement); 
                // dictCompact.Remove(MasterId);
                // _classementCache = org;
                return false;
            }
            else
            {
                // useCompact0 = true;
                tradCompact[org.ClassementValueDecimal] = classement;
                // dictCompact[MasterId] = classement;
                // _classementCache = _compact;
                return true;
            }
        }

        public decimal ClassementValueDecimal(bool compact)
        {
            return getClassementCache(compact).ClassementValueDecimal;
        }



        public virtual void invalidateCache(bool razCompact)
        {
            //if (razCompact)
            //{
            //  //  useCompact0 = false;
            //  //  useCompact = false;

            //    //if (parent != null)
            //    //    parent.invalidateCache(razCompact);
            //}
            //  tradCompact.Remove(StrClassement); 
            //dictCompact.Remove(MasterId);

            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
            //_classementProvisoireRecent = null;

            //if (parent != null)
            //    parent.invalidateCache(razCompact);
            //else
            //{
            //    // _classementCache = null;
            //    if (Compact)
            //    {
            //        if (razCompact)
            //            _classementCompact = null;
            //    }
            //    foreach (Piece p in childs)
            //    {
            //        if (Compact)
            //        {
            //            if (razCompact)
            //                p._classementCompact = null;
            //        }
            //        // p._classementCache = null;
            //    }
            //  }


        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        // private string _classNameAndRating;
        //public String ClassNameAndRating
        //{
        //    get
        //    {
        //        return ClassementCache.ClassNameAndRating;
        //    }
        //}

        public String ClassNameAndRating(bool compact)
        {
            return getClassementCache(compact).ClassNameAndRating;

        }

        // private decimal _classementValueDecimal = -1;
        //public decimal ClassementValueDecimal
        //{
        //    get
        //    {
        //        return ClassementCache.ClassementValueDecimal;
        //    }
        //}
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        /// <summary>
        /// Convertit chaine de format 12345 en 0.17
        /// </summary>
        /// <param name="classNameAndRating"></param>
        /// <returns></returns>
        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }
        public decimal RapportClassement(bool compact)
        {
            return getClassementCache(compact).RapportClassement;
        }

        public string HrC { get { return getClassementEquiv(RapportClassement(true)); } }




        // private decimal _rapportClassement = -1;
        //public decimal RapportClassement
        //{
        //    get
        //    {
        //        return ClassementCache.RapportClassement;
        //        //if (parent != null)
        //        //    return parent.RapportClassement;
        //        //if (_rapportClassement != -1)
        //        //    return _rapportClassement;

        //        //decimal resultat = 0;
        //        //try
        //        //{
        //        //    return getRapport(ClassNameAndRating);
        //        //}
        //        //catch
        //        //{
        //        //}
        //        //_rapportClassement = resultat;
        //        //// _classementVirtuel = resultat; 
        //        //return _rapportClassement;
        //    }
        // }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        private const int END_EQUIV = 13;
        private const int NB_DEC_EQUIV = 8;
        public static string getStrClassement(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            int lastNotNull = 0;
            int firstNotNull = -1;
            int i = 0;
            for (; i < END_EQUIV; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);

                if (a > 0)
                {
                    lastNotNull = i;
                    if (firstNotNull < 0)
                        firstNotNull = i;
                }
                if (i >= _ok + NB_DEC_EQUIV + 2)
                    break;
            }
            var str = sb.ToString();
            sb = new StringBuilder();
            int indexPt = lastNotNull - 1;
            if ((lastNotNull - firstNotNull) > NB_DEC_EQUIV)
                indexPt--;
            //if (str.Length == 5)
            //    indexPt--; 

            for (int j = 0; j <= lastNotNull; j++)
            {

                sb.Append(str[j]);
                if (j == indexPt)
                    sb.Append('.');

            }
            str = sb.ToString(); // str.Insert(str.Length - 1, ".");
            return str;
        }
        public static string getClassementEquiv(decimal valRapport)
        {
            var str = getStrClassement(valRapport);
            return getReadableCl(str);
        }




        //public decimal RapportClassementDecimal
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return parent.RapportClassementDecimal;
        //        decimal resultat = 0;
        //        try
        //        {
        //            string str = ClassNameAndRating;
        //            char[] tab = str.ToCharArray();

        //            decimal K = 1m;
        //            int count = tab.GetLength(0);


        //            for (int i = 0; i < count; i++)
        //            {
        //                K = K * 6;
        //                int c = Convert.ToInt32(tab[i].ToString());
        //                resultat += (decimal)c / K;
        //            }
        //        }
        //        catch
        //        {
        //        }
        //        return resultat;
        //    }
        //}

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating(false);
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        //public string Comment
        //{
        //    get
        //    {
        //        //if (string.IsNullOrEmpty(track.Comment))
        //        //    gen.writeComment(this);
        //        return track.Comment;
        //    }
        //    set
        //    {
        //        //if (track.Comment != value)
        //        //{
        //        try
        //        {
        //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //            track.Comment = value;
        //        }
        //        catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
        //        //}
        //    }
        //}

        //public virtual string Grouping
        //{
        //    get
        //    {
        //        if (string.IsNullOrEmpty(track.Grouping))
        //        {
        //            gen.writeGrouping(this);
        //        }
        //        return track.Grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (track.Grouping != value)
        //    //    //{
        //    //        try
        //    //        {
        //    //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //    //            track.Grouping = value;
        //    //        }
        //    //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //    //    //}
        //    //}

        //}





        //public virtual void setGrouping(string value, bool prior)
        //{
        //    try
        //    {
        //        //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //        track.setGrouping(value, prior);
        //    }
        //    catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //}

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation();
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        //public string ArtWork
        //{
        //    get { return track.ArtWork; }
        //    set { track.ArtWork = value; }
        //}

        public DateTime FirstAcces
        {
            get
            {
                var min = DateTime.MaxValue;
                foreach (DateTime dt in Dates)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }
                foreach (DateTime dt in DatesClassementBrut)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }

                return min;
            }
        }

        public DateTime Added
        {
            get
            {
                return track.Added;
            }
        }

        public virtual DateTime AlbumAdded
        {
            get
            {
                return album.AlbumAdded;
            }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {
                var list = DatesClassement;
                if (list.Count == 0)
                    return null;
                var dc = list[0];

                if (dc == DateTime.MinValue)
                    return null;
                if (dc == DateTime.MaxValue)
                    return null;

                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {

                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > Piece.SeuilProvisoire)
                        return true;
                }
                return false;

            }
        }

        public bool ClassementRecentCompact
        {
            get
            {
                return !string.IsNullOrEmpty(compact(StrClassement)) && LastClassementRecent;
            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public int NbRecentsInAlbum { get { if (album == null) return 0; return album.Recents; } }

        public int MasterTrackNumber
        {
            get
            {
                if (parent == null)
                    return TrackNumber;
                return parent.TrackNumber;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }




        //public void writeCommentGrouping()
        //{
        //    var mode = CConf.ConfGen.WriteComment;
        //    writeComment(mode);
        //    var modeg = CConf.ConfGen.WriteGrouping;
        //    writeGrouping(modeg);

        //}

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        //public void writeComment(writeGrouping mode)
        //{
        //    if (parent != null)
        //        return;
        //    if (mode == Tuning.writeGrouping.none)
        //        return;


        //    if (mode == Tuning.writeGrouping.mix)
        //    {
        //        StringBuilder sbEnd = new StringBuilder();

        //        sbEnd.Append(ClassName);
        //        sbEnd.Append(".");
        //        sbEnd.Append((RatingCmp / 20).ToString());
        //        sbEnd.Append(ClassEvol);
        //        string strEnd = sbEnd.ToString();
        //        string found = "";

        //        string[] tab = Comment.Split(' ');
        //        int count = tab.GetLength(0);
        //        if (count > 0)
        //        {
        //            found = tab[count - 1];
        //            if (found.Equals(strEnd))
        //                return;
        //        }
        //        writeComment(Tuning.writeGrouping.all);
        //    }

        //    StringBuilder sb = new StringBuilder();
        //    //string l_pref = "";
        //    //string l_str = "";

        //    string l_strList = ClassName;
        //    //if (ClassPlayList != null)
        //    //    l_strList = ClassName;

        //    ////if (m_classement.Imported)
        //    ////{
        //    //if (l_strList != ClassName)
        //    //{
        //    //    sb.Append("m (");
        //    //    sb.Append(ClassName);
        //    //    sb.Append(") "); 
        //    //  //  l_pref = "m (" + ClassName + ") ";
        //    //}
        //    ////}
        //    int l_rank = Rank.Twice;

        //    if (l_rank > 0)
        //    {
        //        CTuning.format(sb, l_rank);
        //        sb.Append(" ");
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }


        //        var r = CTuning.Rapport(Rank.Quality);






        //        var quality = CConf.Select.Quality;
        //        //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
        //        //{
        //        double tx0 = Convert.ToInt32(1000 * r);
        //        sb.Append(tx0.ToString());
        //        sb.Append(" ");
        //        //}

        //        //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
        //        var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
        //        //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //getTx(m_rank.Lenght)
        //        //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


        //        sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
        //        //if (l_tx < 100 || l_tx >= 1000)
        //        //    sb.Append(l_tx.ToString("G2", en));
        //        //else
        //        //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



        //        sb.Append(" ");
        //        var rest = r;

        //        for (int i = 0; i < 4; i++)
        //        {
        //            var ee = rest * 6.0m;
        //            int e = (int)System.Math.Floor(ee);
        //            rest = ee - e;
        //            sb.Append(e);
        //        }



        //        sb.Append(" ");


        //        //sb.Append(l_tx2.ToString());
        //        //sb.Append(" ");
        //        //sb.Append((100 * m_rank.SortValue).ToString("0"));
        //        //sb.Append(" ");

        //        //sb.Append(Dates.Count.ToString()); sb.Append(" ");

        //        //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

        //        //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

        //        //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



        //        sb.Append(l_strList);
        //        sb.Append(".");
        //        sb.Append((RatingCmp / 20).ToString());

        //    }

        //    sb.Append(ClassEvol);



        //    Comment = sb.ToString();
        //    //Comment = l_pref + l_str + ClassEvol;
        //}

        public override string ToString()
        {
            object o = PieceAlbum;
            if (o == null)
                o = VirtualMode;
            return string.Format("{0} {1}", o, track);
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 1;
                return RapportClassement(true) / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 1;
                return RapportClassement(true) / _classementVirtuel2;
            }
        }




        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        //private bool haveToUpdateGrouping = false;
        //public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        //public void writeGrouping(writeGrouping writeGrouping)
        //{
        //    var cat = CConf.ConfGen.DisplayCategories;
        //    //if (!CConf.ConfGen.WithOrder)
        //    //    cat = minCategories; 
        //    if (writeGrouping == Tuning.writeGrouping.none)
        //        return;

        //    //if (m_rank.Twice <= 0)
        //    //    return;
        //    if (haveToUpdateGrouping)
        //    {
        //        setGrouping(getGroup(cat), true);
        //    }

        //    else if (writeGrouping == Tuning.writeGrouping.mix)
        //    {
        //        bool haveToUpdate = false;
        //        string org = Grouping;
        //        if (org != null)
        //        {
        //            string[] data = org.Split(' ');

        //            try
        //            {
        //                foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
        //                {
        //                    DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
        //                    //displayCategory found = cat.Find(c => (int)c == (int)mode);
        //                    if (found != null)
        //                    {
        //                        int indexOfTime = cat.IndexOf(found);

        //                        string timeValue = data[indexOfTime];
        //                        string newValue = getTimeValue(mode, found.mode);
        //                        if (!newValue.Equals(timeValue))
        //                        {
        //                            haveToUpdate = true;
        //                            break;
        //                        }
        //                    }
        //                }
        //            }
        //            catch
        //            {
        //                haveToUpdate = true;
        //            }
        //        }
        //        else
        //        {
        //            haveToUpdate = true;
        //        }
        //        if (haveToUpdate)
        //            setGrouping(getGroup(cat), true);
        //    }
        //    else
        //        setGrouping(getGroup(cat), false);
        //}



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    int rank = album.Rank.Sort;
                    rank = gen.Albums.RankZero - rank; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
                    return rank;
                }
                return 0;
            }
        }

        public int DeltaRankAbs { get { return System.Math.Abs(RankAlbumReverse - RankAlbumZero); } }
        public int DeltaRank { get { return RankAlbumZero - RankAlbumReverse; } }

        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            sb.Append(RankAlbumReverse);
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
            //gen.Albums.invalidate(Master); 
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == parent)
                    return;
                var old = parent;
                if (old != null)
                    old.albumMustRefresh();
                parent = value;
                if (parent == null)
                {
                    if (old != null)
                    {
                        old.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = parent.Master;
                    this.PieceParentId = value.MasterId;
                    parent.addChild(this);
                }
                if (album != null)
                    this.album.mustRefresh();
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            childs.Add(child);
        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public void removeVirtualChilds()
        {
            List<Piece> list = null;
            foreach (var c in childs)
            {
                if (c.Virtual)
                {
                   // c.parent = null;
                    if (list == null)
                        list = new List<Piece>();
                    list.Add(c);
                }
            }
            if (list != null)
            {
                foreach (var c in list)
                {
                    childs.Remove(c);
                }
            }
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return track.ExportStatus; // exportState;
            }
            set
            {
                track.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        //public List<string> getIntermediaryPath()
        //{
        //    var list = new List<string>();
        //    foreach (var path in track.RelativesPath)
        //    {

        //        var tab = path.Split('\\');
        //        var sb = new StringBuilder();

        //        sb.Append(@"\");
        //        var count = tab.GetLength(0);
        //        for (int i = 0; i < count; i++)
        //        {
        //            var _s = tab[i];
        //            if (string.IsNullOrEmpty(_s))
        //                continue;

        //            var s = sb.ToString();
        //            if (!string.IsNullOrEmpty(s))
        //            {
        //                if (s.Length >= 2)
        //                {
        //                    list.Add(s);
        //                }
        //            }



        //            if (i > 0)
        //                sb.Append(@"\");
        //            sb.Append(_s);
        //        }
        //    }


        //    return list;


        //}


        public void buildVirtualAlbums(List<Piece> list)
        {
            if (CConf.ConfGen.PathVirtual)
            {
                foreach (var path in track.RelativesPath)
                {

                    var tab = path.Split('\\');
                    var sb = new StringBuilder();

                    sb.Append(@"\");
                    var count = tab.GetLength(0);
                    for (int i = 0; i < count; i++)
                    {
                        var _s = tab[i];
                        if (string.IsNullOrEmpty(_s))
                            continue;

                        var virt = createVirtualAlbum(sb.ToString(), virtualMode.path);

                        if (virt != null)
                            list.Add(virt);



                        if (i > 0)
                        {
                            sb.Append(@"\");
                            if (i < count - 1)
                            {
                                var extended = createVirtualAlbum(_s, virtualMode.extended);
                                if (extended != null)
                                    list.Add(extended);
                            }
                        }
                        sb.Append(_s);
                    }
                }
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in this)
                {
                    if (!string.IsNullOrEmpty(p.Artist))
                    {
                        var virt = createVirtualAlbum(p.Artist, virtualMode.artist);
                        if (virt == null)
                            continue;
                        list.Add(virt);
                    }
                }

            }
            if (CConf.ConfGen.YearVirtual)
            {
                foreach (Piece p in this)
                {
                    if (p.Year > 0)
                    {
                        var strYear = p.Year.ToString();
                        if (strYear.Length == 4)
                        {
                            var decennie = strYear.Remove(3);
                            var virtDecennie = createVirtualAlbum(decennie, virtualMode.year);
                            if (virtDecennie != null)
                                list.Add(virtDecennie);
                        }
                        var virt = createVirtualAlbum(strYear, virtualMode.year);
                        if (virt == null)
                            continue;
                        list.Add(virt);
                    }
                }

            }

        }

        private Piece createVirtualAlbum(string path, virtualMode mode)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2)
            {
                if (!CConf.ConfGen.VirtualRoot)
                    return null;
            }
            var virt = new VirtualAlbumPiece(track, Master, path, mode);
            return virt;
        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        //  const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        private static DateTime seuilCompact;
        public static DateTime SeuilCompact
        {
            get { return seuilCompact; }
            set
            {
                seuilCompact = value;
                if (seuilCompact > DateTime.Now)
                    seuilCompact = DateTime.MaxValue;
            }
        }
        // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true;
                }
                return false;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        public bool ClassementACompacter
        {
            get
            {
                if (!Enabled)
                    return false;
                if (seuilCompact == DateTime.MaxValue)
                    return true;
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > seuilCompact)
                        return false;
                }
                return true;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        //public bool ClassementProvisoire
        //{
        //    get
        //    {
        //        if (RapportClassement(false) == 0)
        //            return false;
        //        var str = ClassName;
        //        int count = str.Length;
        //        if (count < 4)
        //            return true;
        //        if (count >= 8)
        //            return false;

        //        var tab = str.ToCharArray();
        //        int nb = 0;
        //        for (int i = 0; i < count; i++)
        //        {
        //            if (nb > 0)
        //                nb++;
        //            else
        //            {
        //                if (tab[i] != '0')
        //                {
        //                    nb++;
        //                }
        //            }
        //        }
        //        if (nb >= NB_CHAR_COMPLETE)
        //            return false;

        //        return true;

        //    }
        //}

        public bool Played { get { return track.Played; } }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }


        public void setClassement(string classement)
        {
            track.setClassement(classement);
        }

        public string StrClassement
        {
            get
            {
                return Keep ? DeepClassement : strClassement;
            }
        }

        public string StrClassementCoeff
        {
            get
            {
                if (!Keep)
                    return strClassement;
                var coeff = hsKeep[PieceId];
                if (coeff == 1m)
                    return DeepClassement;
                var cl = classementHash.getCache(DeepClassement);

                var rapport = cl.RapportClassement;
                rapport *= coeff;
                var clReduit = getStrClassement(rapport);
                return clReduit;
                // return Keep ? DeepClassement : strClassement;
            }
        }

        public string strClassement
        {
            get { return track.strClassement; }
        }


        public string DeepClassement
        {
            get { return track.DeepClassement; }
        }
    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        public BgDictString<Album> Dict { get { return dict; } }
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object();
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }


        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                foreach (Album album in dict.Values)
                {
                    album.checkBuild();
                }
                dict.Clear(); 
            }
        }

        private string getKey(string _album, virtualMode mode)
        {
            return Album.getKey(_album, mode);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                var confGen = CConf.ConfGen;
                var min1 = confGen.AlbumMin;
                var min2 = confGen.PathVirtualMin;
                var min3 = confGen.AristVirtualMin;
                foreach (Album album in new List<Album>(dict.Values))
                {
                    int count = album.Count;
                    bool toKeep = album.buildDone();
                    if (toKeep)
                    {

                        if (album.Virtual)
                        {
                            if (album.VirtualByArtist)
                            {
                                if (min3 > 1 && count < min3)
                                    toKeep = false;
                            }
                            else if (min2 > 1 && count < min2)
                                toKeep = false;
                        }
                        else if (min1 > 1 && count < min1)
                            toKeep = false;



                        if (!toKeep)
                        {
                            // misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
                            dict.Remove(getKey(album.Name, album.VirtualMode));
                        }

                    }

                }


            }
        }



        private bool check_(Piece piece, string albumOrg, virtualMode mode, IDictionary<string, Album> dict)
        {
            string __album = getKey(albumOrg, mode);


            var album = dict[__album];
            if (album == null)
            {
                //  misc.log("creation album {0}", __album);
                album = new Album(albumOrg, __album);
                album.setVirtual(mode); 
                dict.Add(__album, album);
            }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualMode, dict);
        }

        public int Count { get { return dict.Count; } }
        public int RankZero { get;  set; }





        public void sortVirtual()
        {
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {

            if (piece.Virtual)
                check_(piece, dict);

        }

        public Album getAlbum(Piece piece)
        {
            return piece.PieceAlbum;
            //string __album = "-";
            //var _album = piece.Album;
            //if (!string.IsNullOrEmpty(_album))
            //{
            //    __album = _album.Trim();
            //    return dict[__album];
            //}
            //return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            var now = DateTime.Now;
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
            misc.log("buildStack; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
        }


        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public void makeSort(Piece piece)
        {
            if (piece == null)
                return;
            //var album = piece.PieceAlbum;
            //if (album == null)
            //    return;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;

                album.mustRefresh();
                album.makeSort(confMedianne, conf0); //listRef, reference); 
                album.mustRefresh();
            }

        }
        // private int nbSort=1;
        private bool urgence;
        public void setUrgence() { urgence = true; }
        public void makeSort(bool sortAll)
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var main = confMedianne.Main;
                var min = confMedianne.Min;
                var mainCoeffVirt = main.coeffVirt;
                var mainCoeffOld = main.CoeffOld;

                var minCoeffVirt = min.coeffVirt;
                var minCoeffOld = min.CoeffOld;




                if (confSort.reset)
                {
                    main.coeffVirt = 1;
                    main.CoeffOld = 1;
                    min.coeffVirt = 1;
                    min.CoeffOld = 1;
                }

                List<Album> list = new List<Album>(dict.Values);
                List<Album> listw = list;
                HashSet<Album> hs = null;
                DateTime now = DateTime.Now;
                DateTime debut = now;
                bool partial = !sortAll && confSort.optimSize > 0 && urgence;
                if (partial)
                    urgence = false;
                int step = 0;
                Album last = null;
                // int coeffSort = 1;
                while (true)
                {
                    step++;

                    if (partial)
                    {
                        //nbSort++;
                        //coeffSort = 1; 

                        //int _nbSort = nbSort;
                        //while (_nbSort >=2 && _nbSort % 2 == 0)
                        //{
                        //    coeffSort *= 2;
                        //    _nbSort /= 2; 
                        //}
                        hs = new HashSet<Album>();
                        list.Sort(new AlbumClassComparer2());
                        list.Reverse();
                        listw = new List<Album>();
                        decimal equivLightMax = 0;
                        decimal equivLightZeroMax = 0;
                        int nb = 0;
                        int max = step * confSort.optimSize; // *coeffSort;

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                nb++;
                                listw.Add(a);
                                hs.Add(a);

                                var _classementValueLight = a.ClassementValueLight;
                                if (_classementValueLight > equivLightMax)
                                {
                                    equivLightMax = _classementValueLight;
                                    last = a;
                                }

                                var _classementValueLightZero = a.ClassementValueLightZero;

                                if (_classementValueLightZero > equivLightZeroMax)
                                {
                                    equivLightZeroMax = _classementValueLightZero;
                                    last = a;
                                }

                                if (nb >= max)
                                    break;
                            }
                        }


                        var equivZeroVerif = equivLightZeroMax * pdb.util.Math.Pow(main.coeffVirt, main.safe) * pdb.util.Math.Pow(min.coeffVirt, min.safe) * main.CoeffOld * min.CoeffOld;
                        var dxMin = min.dcoeff;
                        var dxMain = pdb.util.Math.Pow(main.dcoeff, main.safe);
                        var equivVerif = equivLightMax * (dxMain * dxMin);

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                var _classementValueLight = a.ClassementValueLight;


                                if (_classementValueLight < equivVerif && _classementValueLight < equivZeroVerif)
                                {
                                    if (hs.Add(a))
                                    {
                                        listw.Add(a);
                                        if (_classementValueLight > equivLightMax)
                                        {
                                            equivLightMax = _classementValueLight;
                                            last = a;
                                        }

                                    }
                                }

                            }
                        }

                    }

                    int nbSorted = 0;
                    foreach (Album album in listw)
                    {
                        if (album.makeSort(confMedianne, conf0)) //listRef, reference); 
                            nbSorted++;
                    }

                    string infoAlbum = "";
                    if (last != null)
                    {
                        infoAlbum = string.Format("last={0} {1} {2} {3}", last.Tracks[0].RankAlbumReverse, last.EquivLight0, last.EquivLight, last);
                    }
                    //   misc.log(string.Format("makeSort : nbSort={0} coeffSort={1} step={2}  {3} albums {4} ms {5}", nbSort, coeffSort, step, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                    misc.log(string.Format("makeSort : step={0}  {1}/{2} albums {3} ms {4}", step, nbSorted, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                    now = DateTime.Now;
                    //if (confSort.reset)
                    //{
                    main.coeffVirt = mainCoeffVirt;
                    main.CoeffOld = mainCoeffOld;
                    min.coeffVirt = minCoeffVirt;
                    min.CoeffOld = minCoeffOld;

                    // }


                    list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                    list.Reverse();
                   
                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (album.AtLeastOneEnabled)
                            RankZero = i;
                        album.Rank.Sort = i + 1;
                    }

                    if (!partial)
                        break;


                    list.Reverse();

                    int nbCheck = 0;
                    bool? check = null;
                    foreach (Album a in list)
                    {
                        if (!a.AtLeastOneEnabled)
                            continue;
                        if (hs.Contains(a))
                        {
                            nbCheck++;
                            if (nbCheck >= confSort.optimCheck) // * coeffSort)
                            {
                                check = true;
                                break;
                            }
                        }
                        else
                        {
                            check = false;
                            break;
                        }


                    }

                    if (check == null || check.Value)
                        break;

                }


                misc.log(string.Format("makeSort albums total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));

                List<Album> listSt = null;
                List<Album> list0 = null;
                List<Album> listSt0 = null;


                if (confSort.sortSt || confSort.correcMainRank || confSort.correcMainCoeff || confSort.correcMainZero)
                {
                    listSt = new List<Album>(list);

                    listSt.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                    listSt.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        listSt[i].RankSt = i + 1;
                    }
                    misc.log(string.Format("sort St : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sort0)
                {
                    now = DateTime.Now;
                    list0 = new List<Album>(list);

                    list0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                    list0.Reverse();
                    for (int i = 0; i < list0.Count; i++)
                    {
                        list0[i].RankZero = i + 1;
                    }
                    misc.log(string.Format("sort 0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sortSt0 || confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    listSt0 = new List<Album>(list);

                    listSt0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, conf0));
                    listSt0.Reverse();
                    for (int i = 0; i < listSt0.Count; i++)
                    {
                        listSt0[i].RankZeroSt = i + 1;
                    }
                    misc.log(string.Format("sort St0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.Name == "\\")
                        {
                        }
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                if (o.Name == "Ill Communication")
                                {
                                }
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;

                                if (o.RankZero > un.RankZero)
                                {
                                    correc = false;
                                    break;
                                }
                                

                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }
                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }

                

                    //now = DateTime.Now;
                    //for (int i = listSt.Count - 1; i >= 0; i--)
                    //{
                    //    Album un = listSt[i];
                    //    Album zero = listSt0[i];
                    //    if (un.DontTouchSelectedCoeff)
                    //        continue;
                    //    if (un == zero)
                    //        un.InvalidateMain();
                    //}
                    misc.log(string.Format("correcMainRank : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainCoeff)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLightSt * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLightSt;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }
                    misc.log(string.Format("correcMainCoeff : {0} ms", (DateTime.Now - now).TotalMilliseconds));

                }
                if (confSort.correcMainZero)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.Name == "Ill Communication")
                        {
                        }
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {




                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                if (o.Name == "Ill Communication")
                                {
                                }
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;


                                if (o.ClassementValueLightZeroSt < un.ClassementValueLightZeroSt)
                                {
                                    if (o.RankZero > un.RankZero)
                                    {
                                        correc = false;
                                        break;
                                    }
                                }

                                if (!unClassementRecent)
                                {
                                    if (o.ClassementValueLightZeroSt == un.ClassementValueLightZeroSt)
                                    {
                                        if (confSort.correcMainZeroCheckEquality)
                                        {
                                            if (onext.LastClassementRecent)
                                            {
                                                if (o.RankZero > un.RankZero)
                                                {
                                                    correc = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }


                                //if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //    break;
                                // }



                                //if (o.RankSt <= un.RankSt)
                                //{
                                //    if (o.RankZeroSt > un.RankZeroSt)
                                //    {
                                //        correc = false;
                                //        break;
                                //    }

                                //    if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //        break;
                                //}

                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }

                    misc.log(string.Format("correcMainZero : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }


              

                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}

                misc.log(string.Format("makeSort total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var now = DateTime.Now;
            var list = new List<Album>(dict.Values);

            //var confGen = CConf.ConfGen;
            //var min1 = confGen.AlbumMin;
            //var min2 = confGen.PathVirtualMin;
            //var min3 = confGen.AristVirtualMin;
            //foreach (Album album in dict.Values)
            //{
            //    int count = album.Count;
            //    bool toKeep = true;


            //    if (album.Virtual)
            //    {
            //        if (album.VirtualByArtist)
            //        {
            //            if (min3 > 1 && count < min3)
            //                toKeep = false;
            //        }
            //        else if (min2 > 1 && count < min2)
            //            toKeep = false;
            //    }
            //    else if (min1 > 1 && count < min1)
            //        toKeep = false;



            //    if (!toKeep)
            //    {
            //        misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
            //    }
            //    else
            //        list.Add(album);

            //}

            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            misc.log(string.Format("make selection : {0} ms", (DateTime.Now - now).TotalMilliseconds));
            return list;
        }

        //public void changeAlbum(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Album, false)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();
        //    check_(p, newA, false, this.dict);
        //    var newAlb = dict[getKey(newA, false)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();

        //    //  invalidate(p); 
        //}

        //public void changeArtist(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Artist, true)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();

        //    check_(p, newA, true, this.dict);
        //    var newAlb = dict[getKey(newA, true)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();
        //}

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                bool found = false;
                foreach (Album album in dict.Values)
                {
                    if (album.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.Clear();
                }
                else
                {
                    // on le prend.
                    dict.Add(getKey(candidat.Name, candidat.VirtualMode), candidat);
                    foreach (Piece p in candidat)
                    {
                        p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }




        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(Piece track)
        {
            track.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track);

        }

        #region invalider


        public void invalidateAll(bool total)
        {
            foreach (var a in dict.Values)
            {
                if (total)
                    a.mustRefresh();
                else
                    a.refreshLight();
            }
        }
        //public void invalidate(Piece piece)
        //{
        //    foreach (var p in piece.Master)
        //    {
        //        var key = getKey(p.Album, p.VirtualByArtist);
        //        var a = dict[key];
        //        if (a == null)
        //        {
        //        }
        //        else
        //            a.invalidate();
        //        //if (p.Virtual)
        //        //    continue; 
        //        ////1. check standard
        //        //var key = getKey(p.Album, false);
        //        //var a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 
        //        ////2. check artiste
        //        //key = getKey(p.Artist, true);
        //        //a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 

        //        ////3. check paths
        //        //foreach (string path in p.getIntermediaryPath())
        //        //{
        //        //    key = getKey(path, false);
        //        //    a = dict[key];
        //        //    if (a == null)
        //        //    {
        //        //    }
        //        //    else
        //        //        a.invalidate(); 
        //        //}
        //    }
        //}
        #endregion



    }
}
]]></content>
  </file>
</db>
