<db path="C:\bernard\db1\db4">
   <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;
using System.Linq;
using System.Linq.Expressions;
using System.Text.RegularExpressions;
namespace pdb.podcast.Sort
{
    class Album
    {
        const string DATE_FORMAT = "dd/MM/yy HH:mm";
        const string DAY_FORMAT = "dd/MM HH:mm";
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        // private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbModifPertinent = 0;
        private static int nbRepecheForce = 0;
        private static DateTime dateRepeche = DateTime.MaxValue; public static DateTime DateRepeche { get { return dateRepeche; } }
        private static List<TrackSort> repeches = new List<TrackSort>();
        public static int NbRepeches { get { return repeches.Count; } }
        public static int NbModif { get { return nbModif; } }
        public static int NbModifPertinent { get { return nbModifPertinent; } }

        private bool done;

        //  bool checkSelected, apply;
        DateTime date0; //, newDate0;
        DateTime date1;
        public static void Init()
        {
            //lastReads.Clear(); 
            //nbrepeches = 0;
            repeches.Clear();
            nbModif = 0; nbModifPertinent = 0;
            nbRepecheForce = 0;
            dateRepeche = DateTime.MaxValue;
        }

        public static void Bilan()
        {
            if (dateRepeche < DateTime.MaxValue)
                log.log("*************Date minimum:" + dateRepeche);
            repeches.Sort((x, y) => x.Pub2.CompareTo(y.Pub2));
            foreach (TrackSort t in repeches)
                log.log(string.Format("date={0} {1}", t.Pub2, t));
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;
        public static Logger logDebug;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }



        public void init()
        {
            //done = false;
        }

        //public void buildAll()
        //{
        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;

        //    checkSelected = false;
        //    apply = false;

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        var dt = track.Pub2.AddSeconds(1);
        //        date0 = dt;
        //        newDate0 = dt;
        //        build();
        //        if (dt >= Conf.Date0)
        //            break;
        //    }

        //    apply = true;
        //    date0 = Conf.Date0;
        //    newDate0 = Conf.NewDate0;
        //    // writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        writeComment(track, track.Pub2);
        //    }
        //}

        private void build0()
        {
            int count = list.Count;
            if (count == 0)
                return;



            TrackSort.Date0 = date0;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    if (track.Pub2 < track.Pub)
                        track.Pub2 = track.Pub;
                    if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                    {
                        var aux = currentPub2.AddMinutes(1);
                        log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                        track.Pub2 = aux;
                    }
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                            indexNextSelected = i;
                        }
                    }
                    else
                        break;
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var rare = album.Rare;
            var intervalleMin0 = conf.getIntervalleMin0(rare);
            var intervalle = conf.getIntervalle(rare, lastRead.DureeEnHeure, intervalleMin0);
            var intervalleMin = conf.getIntervalleMin(rare, lastRead.DureeEnHeure);

            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(rare);
            double cumulMax = conf.getCumulMax(rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = intervalle; // conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    // var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    double rapport = (double)_nbRead / (double)_nbTotal;

                    var coeff = 1 / rapport;

                    if (conf.dureeCoeff)
                    {
                        coeff = conf.getCoeff(rare, coeff, lastRead.DureeEnHeure);
                    }

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);



                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                {
                    double _coeff = deltaLimiteEcoule / delta;
                    delta = borne(_coeff, intervalle, intervalleMin);
                }

                if (delta < 1)
                    delta = 1;




                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }





            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();

            DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * delta).truncateToMinute();
            //var cumul = (limitFuture - next.Pub).TotalDays;
            //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
            //if (dtaux > limitFutureRab)
            //    limitFutureRab = dtaux; 
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = delta;
            if (conf.extPente > 0)
                deltaAtterrissage = delta0;


            if (conf.deltaConst || conf.extPente > 0)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                for (int i = indexLastRead + 2; i < count; i++)
                {
                    var t = list[i];
                    if (conf.useVirtuel)
                    {
                        // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                        dt = dt.AddDays(intervalleMin0);
                    }
                    else
                        dt = t.Pub;


                    nb++;
                    if (dt > limitFuture)
                    {
                        nextDate = dt;
                        nblissage++;
                        if (dt <= _deltaMin)
                            continue;
                        if (dt <= _deltaRab)
                            continue;
                        if (nb <= conf.deltaNbMin)
                            continue;
                        if (nblissage <= conf.deltaNbRab)
                            continue;
                        if (dt <= limitFutureRab)
                            continue;

                        break;


                        //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                        //    break;
                    }

                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            //  nb = 0;
            // bool enRetard = limitFuture < date0;
            TrackSort last = next;
            DateTime lastPub2 = limitFuture;
            int indexDepart = indexLastRead + 1;



            bool erased = false;

            if (conf.vacances)
                deltaAtterrissage = delta;

            for (int i = indexDepart; i < count; i++)
            {
                var t = list[i];
                if (erased && conf.erasedDone)
                {
                    eraseSort(t, "", t.Pub);
                    continue;
                }

                DateTime dt = lastPub2;

                if (i == indexDepart && !conf.useVirtuel2)
                {
                    dt = limitFuture;
                }
                else
                {

                    //if (conf.deltaCheckSelected)
                    //{
                    //    if (!t.Selected)
                    //        continue;
                    //    if (!t.Enabled)
                    //        continue;
                    //}
                    var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                    if (conf.useVirtuel2)
                        dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                    else
                        dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
                    if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1)
                    {
                        var dt2 = dt;
                        if (conf.useVirtuel2)
                            dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                        else
                            dt2 = lastPub2.AddDays(delta).truncateToMinute();
                        //if (dt2 <= date0)
                        dt = dt2;
                        //else
                        //    dt = date0.AddMinutes(1);
                    }


                }



                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset || erased && conf.erasedDone)
                {
                    erased = true;
                    eraseSort(t, "", t.Pub);
                }
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }


                    //if (dt > DateTime.Now)
                    //{
                    //}

                    //if ((dt - t.Pub).TotalDays > 100)
                    //{
                    //}

                    writeComment(t, dt, "", t.Pub);
                    //nb++;
                }


                last = t;
                lastPub2 = dt;


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }

        private static double getweek(double days)
        {
            return 7 * System.Math.Floor(days / 7.0);
        }

        private void build()
        {

            int count = list.Count;
            if (count == 0)
                return;


            if (this.album.Album == "LA GRANDE TABLE 1ère partie")
            {
            }

            if (this.album.Album == "La tête au carré")
            {
            }

            // bool rare = album.Rare;

            TrackSort.Date0 = date0;

            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;

            // 1. ordre
            for (int i = 0; i < count; i++)
            {
                var track = list[i];


                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    if (track.Pub2 < track.Pub)
                        track.Pub2 = track.Pub;

                    if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                    {
                        var aux = currentPub2.AddMinutes(1);
                        log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                        track.Pub2 = aux;
                    }
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }



            int index0 = 0;
            int indexCourant = 0;

            TrackSort next = null;
            int indexLastRead = -1;
            // int indexPrelastRead = -1;
            TrackSort lastRead = null;
            // TrackSort prelastRead = null;

            if (this.album.Album == "PARLER CONTRE LA TERREUR")
            {
            }

            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played)
                {
                    if (next == null)
                    {
                        //indexPrelastRead = indexLastRead;
                        //prelastRead = lastRead; 
                        indexLastRead = i;
                        lastRead = track;
                        indexCourant = i;

                    }
                    else
                        break;

                }

                else if (lastRead != null)
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                        }
                    }
                    else
                        break;
                }
            }

            if (indexLastRead < 0)
                return;



            if (indexCourant < 0)
                return;

            if (conf.vacances || !conf.recheck)
                index0 = indexCourant;
            else
            {
                index0 = 0;
                indexLastRead = -1;
                lastRead = null;
                //indexPrelastRead = -1;
                //prelastRead = null; 

            }
            bool firstSel = false;


            // DateTime lastPlayed = DateTime.MinValue;

            if (lastRead == null)
            {
                for (int i = index0; i < count; i++)
                {
                    var track = list[i];

                    if (track.Played) // && track.PlayedDate > lastPlayed)
                    {
                        indexLastRead = i;
                        //prelastRead = track;
                        //indexPrelastRead = i;
                        // lastPlayed = track.PlayedDate;

                        lastRead = track;

                        index0 = i;
                        break;
                    }


                }
            }

            if (lastRead == null)
                return;
            if (lastRead.Pub == DateTime.MinValue)
                return;

            TrackSort last = lastRead;
            DateTime lastPub2 = lastRead.Pub2;
            //DateTime lastPubTh = lastRead.Pub2;
            DateTime pubMoy = lastRead.Pub2;
            DateTime pubMoyForCalcul = pubMoy;

            while (true)
            {
                if (index0 >= count - 1)
                    break;



                var current = list[index0];
                bool played = current.Played;


                if (played)
                {
                    lastRead = current;
                    indexLastRead = index0;
                }

                //  int indexNextSelected = -1;

                //  TrackSort next = null;

                // 2. Détermination lastRead et next



                bool rare = album.Rare;

                var futur = conf.getFutur(rare);
                futur = getweek(futur);
                var futurh = getweek(conf.futurh);
                var futura = getweek(conf.futura);
                int nbFutur = 0;
                int nbFuturh = 0;
                int nbRestant = 0;
                double intervalleFactMin = 1;
                double intervalleFactMoy = 1;
                double intervalleX = 0;

                // DateTime lastExists = lastRead.Pub;

                var now = DateTime.Now;
                DateTime finFutur = now;
                DateTime finFuturH = now;
                DateTime debutFutur = current.Pub; //.AddDays(-futura);
                int indexDebut = index0;
                var deltaTotal = futur;
                var deltaTotalH = futurh;
                if (futur > 0)
                {
                    finFutur = current.Pub.AddDays(futur);
                    finFuturH = current.Pub.AddDays(futurh);
                    if (finFutur > now)
                    {
                        var d = getweek((now - debutFutur).TotalDays);
                        finFutur = debutFutur.AddDays(d);

                        //indexDebut = 0;
                        //debutFutur = finFutur.AddDays(-futur);
                    }

                    if (finFuturH > now)
                    {
                        var d = getweek((now - debutFutur).TotalDays);
                        finFuturH = debutFutur.AddDays(d);

                    }

                    //if (futura > 0)
                    //{
                    //    if (debutFutur < list[0].Pub)
                    //    {
                    //        debutFutur = list[0].Pub;
                    //        indexDebut = 0;
                    //    }
                    //    else
                    //    {
                    //        for (int i = index0; i >= 0; i--)
                    //        {
                    //            var t = list[i].Pub;
                    //            if (t >= debutFutur)
                    //                indexDebut = i;
                    //            else
                    //                break;
                    //        }
                    //    }
                    //}
                    // chopper l'intervalle majoritaire pour éviter le poids des erreurs. 
                    Dict<int, int> spectreDelta = new Dict<int, int>();
                    DateTime lastExists = lastRead.Pub;
                    DateTime l = DateTime.MinValue;
                    for (int i = indexDebut; i < count; i++)
                    {
                        var t = list[i].Pub;
                        if (t < debutFutur)
                            continue;
                        if (t.Date == l.Date && list[i].track.Duree.TotalMinute < conf.collisionDuree)
                            continue;
                        l = t;
                        nbRestant++;

                        if (t < finFuturH)
                            nbFuturh++;


                        if (t < finFutur)
                        {
                            nbFutur++;


                            var dp = (int)(System.Math.Round((t - lastExists).TotalDays, 0, MidpointRounding.AwayFromZero));
                            lastExists = t;
                            if (dp > 0)
                                spectreDelta[dp]++;
                        }
                        else if (nbRestant >= TrackAlbum.NB_MIN_POUR_FREQUENT)
                        {
                            break;
                        }
                    }

                    if (nbFutur == 0)
                        nbFutur = 1;
                    if (nbFuturh == 0)
                        nbFuturh = 1;
                    deltaTotal = (finFutur - debutFutur).TotalDays;
                    deltaTotalH = (finFuturH - debutFutur).TotalDays;
                    if (deltaTotal > 0)
                    {
                        intervalleFactMoy = deltaTotal / (double)nbFutur;
                        //var median = deltaTotalH / (double)nbFuturh;
                        //if (median > intervalleFactMoy)
                        //    intervalleFactMoy = median;

                    }

                    if (futura > 0)
                    {
                        var min = current.Pub.AddDays(-futura);
                        var nb2 = nbFutur;
                        DateTime pubDebut = current.Pub;
                        for (int i = indexDebut - 1; i >= 0; i--)
                        {
                            var t = list[i].Pub;
                            if (t < min)
                                break;
                            nb2++;
                            pubDebut = t;
                        }
                        var deltaTotal2 = (finFutur - pubDebut).TotalDays;
                        var intervalleFactMoy2 = deltaTotal2 / (double)nb2;

                        if (intervalleFactMoy2 < intervalleFactMoy)
                        {
                            intervalleFactMoy = intervalleFactMoy2;
                            deltaTotal = deltaTotal2;
                            debutFutur = pubDebut;
                            nbFutur = nb2;
                        }
                        else
                        {
                        }
                    }
                    var limitMoy = conf.limitMoy;
                    if (limitMoy > 0 && intervalleFactMoy > limitMoy)
                        intervalleFactMoy = limitMoy;

                    intervalleX = (intervalleFactMoy - 1) / 6;

                    var choices = spectreDelta.Keys.ToList();
                    choices.Sort((x, y) => x.CompareTo(y));

                    int max = 0;
                    int dpMaj = 1;
                    for (int i = 0; i < choices.Count; i++)
                    {
                        int k = choices[i];
                        var r = spectreDelta[k];
                        if (r > max)
                        {
                            max = r;
                            dpMaj = k;
                        }
                    }

                    intervalleFactMin = dpMaj;

                    if (nbRestant < TrackAlbum.NB_MIN_POUR_FREQUENT && !rare)
                    {
                        // this.album.RareEffect = true;
                        rare = true;
                    }
                }

                double duree = current.DureeEnHeure;
                var intervalleMin0 = conf.getIntervalleMin0(rare);
                var intervalleMin0Var = conf.getIntervalleMin0Var(intervalleX, intervalleFactMin);

                var intervalle = conf.getIntervalle(rare, duree, intervalleMin0);
                var intervalleVar = conf.getIntervalleVar(rare, intervalleX, duree, intervalleMin0Var);

                var intervalleCorrec = intervalle;
                var intervalleCorrecVar = intervalleVar;
                var intervalleMin = conf.getIntervalleMin(rare, duree);
                var intervalleMinVar = conf.getIntervalleMinVar(rare, intervalleX, duree);


                var atterissageMin = conf.getAtterrissageMin(rare);
                var atterissageMinVar = conf.getatterrissageMinVar(intervalleX, intervalleFactMin);

                double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                DateTime pub2 = lastRead.Pub2;

                double delta0Corr = deltaLastRead0;

                double cumulMin = conf.getCumulMin(rare);
                double cumulMax = conf.getCumulMax(rare);

                if (pub2 > lastRead.Pub && conf.extPente == 0)
                {
                    if (conf.elastique < 1)
                    {
                        delta0Corr = deltaLastRead0 * conf.elastique;
                        pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                    }


                    //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                    //{
                    //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                    //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                    //}
                }


                // var _played = played ? current : lastRead;
                var deltaLecture = (DateTime.Now - lastRead.PlayedDate).TotalDays;


                //int nbReads = 0;
                //int nbTotals = 0;

                int nbRead = 0;
                int nbTotal = 0;

                //int _nbRead = 0;
                int _nbTotal = 0;

                var histo = conf.getHisto(rare);
                var nbHisto = conf.getNbHisto(rare);
                double densite = 1;
                double rapport = 1;
                double rapportBorne = 1;
                bool borneParHorizon = false;
                double coeff = 1;
                double coeffVar = 1;

                double delta = intervalle; // conf.getIntervalle(album.Rare);
                double deltaVar = intervalleVar;
                double delta0 = delta;
                double deltaHorizon0 = delta;
                double deltaHorizon0Var = deltaVar;
                double deltaHorizon = delta;
                double deltaHorizonVar = deltaVar;

                bool useTolerance = false;

                if (histo > 0 || nbHisto > 0)
                {

                    DateTime limit = lastRead.Pub; //
                    try { limit = limit.AddDays(-histo); }
                    catch (Exception ex)
                    {
                        misc.log("Impossible de caler l'historique {0} {1}", this, lastRead, ex);
                        throw;
                    }
                    DateTime l = DateTime.MinValue;
                    for (int i = indexLastRead; i >= 0; i--)
                    {
                        var t = list[i];
                        var dt = t.Pub;
                        if (dt.Date == l && t.track.Duree.TotalMinute < conf.collisionDuree)
                            continue;
                        l = dt.Date;
                        if ((dt < limit || nbTotal >= nbHisto) && nbTotal >= conf.totalMin)
                            break;

                        if (t.Played)
                            nbRead++;


                        nbTotal++;

                    }

                    _nbTotal = nbTotal;

                    if (nbRead > 0 && _nbTotal > 0)
                    {
                        if (_nbTotal < conf.totalMin)
                            _nbTotal = conf.totalMin;


                        // var futur = conf.getFutur(rare);

                        if (futur > 0)
                        {


                            double theoric = (finFutur - current.Pub).TotalDays / intervalleMin0;
                            densite = nbFutur / theoric;
                            //if (densite >= 1)
                            //    densite = 1;

                            if (densite < conf.densiteMin && !rare)
                            {
                                rare = true;


                                intervalleMin0 = conf.getIntervalleMin0(rare);
                                intervalleMin0Var = conf.getIntervalleMin0Var(intervalleX, intervalleFactMin);

                                intervalle = conf.getIntervalle(rare, duree, intervalleMin0);
                                intervalleVar = conf.getIntervalleVar(rare, intervalleX, duree, intervalleMin0Var);

                                intervalleCorrec = intervalle;
                                intervalleCorrecVar = intervalleVar;
                                intervalleMin = conf.getIntervalleMin(rare, duree);
                                intervalleMinVar = conf.getIntervalleMinVar(rare, intervalleX, duree);


                                atterissageMin = conf.getAtterrissageMin(rare);
                                atterissageMinVar = conf.getatterrissageMinVar(intervalleX, intervalleFactMin);




                                theoric = (finFutur - current.Pub).TotalDays / intervalleMin0;
                                densite = nbFutur / theoric;
                                //if (densite >= 1)
                                //    densite = 1;
                            }
                            //if (densite < 1)
                            //    rapport = rapport * densite;
                        }


                        //  album.Rare ? conf.intervalleR : conf.intervalle;
                        rapport = (double)nbRead / (double)_nbTotal;
                        coeff = 1 / rapport;

                        if (conf.dureeCoeff)
                            coeff = conf.getCoeff(rare, coeff, duree);

                        coeffVar = coeff;

                        if (conf.coeffDensite)
                        {
                            coeff /= densite;

                            coeffVar *= intervalleFactMoy;
                        }

                        if (conf.honneurAuxVieux && nbRestant < TrackAlbum.NB_MIN_POUR_FREQUENT)
                        {
                            if (nbRestant > 0)
                            {
                                var t = TrackAlbum.NB_MIN_POUR_FREQUENT / nbRestant;
                                coeff *= t;
                                coeffVar *= t;
                            }
                        }

                        if (this.album.Album == "PARLER CONTRE LA TERREUR")
                        {
                        }

                        var recup = intervalleMin0 - atterissageMin;
                        //   var recupVar = intervalleMin0Var - atterissageMinVar;


                        delta = intervalle; // conf.getIntervalle(album.Rare);
                        delta0 = delta;
                        deltaHorizon0 = delta;
                        deltaHorizon = delta;


                        deltaHorizon0Var = intervalleVar;
                        deltaHorizonVar = intervalleVar;

                        rapportBorne = conf.getHorizonCorrec(rapport, intervalleX);

                        if ((this.album.Album == "Rendez-vous avec X" || this.album.Album == "Sur les épaules de Darwin") && (index0 > indexCourant - 10 && index0 < indexCourant + 10))
                        {
                        }

                        deltaHorizon0 = intervalleMin0 + recup * (1 - rapport) / rapport + (1 - densite) / (densite * rapport);
                        //deltaHorizon0Var = intervalleMin0Var + recupVar * (1 - rapport) / rapport + (1 - 1 / intervalleFactMoy) / (rapport / intervalleFactMoy); 
                        //deltaHorizon0Var = intervalleFactMoy + ((1 - rapport) / rapport) * (intervalleFactMoy - atterissageMinVar); // ça pue
                        var d0 = (lastPub2 - pubMoyForCalcul).TotalDays;
                        var d1 = (lastPub2 - last.Pub).TotalDays;
                        var d00 = (pubMoyForCalcul - last.Pub).TotalDays;


                        var deltaMoy = d1; // System.Math.Min(d0, d1);
                        if (deltaMoy < 0)
                            deltaMoy = 0;

                        var deltaTotalh = (finFuturH - debutFutur).TotalDays;
                        var correcMoy0 = (deltaTotalh - deltaMoy * rapportBorne) / nbFuturh;
                        var correcMoy1 = (deltaTotal - deltaMoy * rapportBorne) / nbFutur;
                        var correcMoy = System.Math.Min(correcMoy0, correcMoy1);
                        var correcMoy2 = intervalleFactMoy * (1 - deltaMoy / deltaTotalh);
                        deltaHorizon0Var = (correcMoy2 - atterissageMinVar * (1 - rapportBorne)) / rapportBorne;
                        // im=7, rapport=0.9



                        deltaHorizon = deltaHorizon0;
                        deltaHorizonVar = deltaHorizon0Var;



                        var tolerance = conf.getTolerance(rare);
                        double tolerancePart = 0;
                        if (tolerance > 0)
                        {
                            var ecart0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                            tolerancePart = (tolerance - ecart0) / conf.getNbTolerance(rare);
                            if (deltaHorizon < tolerancePart)
                                deltaHorizon = tolerancePart;
                            else if (conf.toleranceNegative && tolerancePart < 0)
                                deltaHorizon += tolerancePart;


                            if (deltaHorizonVar < tolerancePart)
                            {
                                deltaHorizonVar = tolerancePart;
                                useTolerance = true;
                            }
                            else if (conf.toleranceNegative && tolerancePart < 0)
                                deltaHorizonVar += tolerancePart;
                        }




                        if (deltaHorizon < intervalle)
                            intervalleCorrec = deltaHorizon;

                        if (deltaHorizonVar < intervalleVar)
                        {
                            intervalleCorrecVar = deltaHorizonVar;
                            borneParHorizon = true;
                        }

                        //if (intervalleCorrec < intervalleMin)
                        //    intervalleCorrec = intervalleMin;

                        //if (intervalleCorrecVar < intervalleMinVar)
                        //    intervalleCorrecVar = intervalleMinVar;
                        //0.1 => 10
                        //0.9 => 1.11
                        //coeff -= 1; // 9  0.11
                        //var dminmax = intervalle - intervalleMin;

                        var _delta0 = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
                        var _deltaVar0 = borne(coeffVar, intervalleVar, intervalleMinVar);




                        var _delta = borne(coeff, intervalleCorrec, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
                        var _deltaVar = borne(coeffVar, intervalleCorrecVar, intervalleMinVar);


                        if (conf.horizonFinal)
                        {
                            if (_delta0 < delta)
                                delta = _delta0;
                            else if (_delta0 == delta)
                            { }
                            else
                            { }



                            if (_deltaVar0 < deltaVar)
                                deltaVar = _deltaVar0;
                            else if (_deltaVar0 == deltaVar)
                            { }
                            else
                            { }

                            if (delta > deltaHorizon)
                                delta = deltaHorizon;

                            //if (delta < tolerancePart)
                            //    delta = tolerancePart; 

                            if (deltaVar > deltaHorizonVar)
                                deltaVar = deltaHorizonVar;

                            //if (deltaVar < tolerancePart)
                            //    deltaVar = tolerancePart; 

                        }
                        else
                        {


                            if (_delta < delta)
                                delta = _delta;
                            else if (_delta == delta)
                            { }
                            else
                            { }


                            if (_deltaVar < deltaVar)
                                deltaVar = _deltaVar;
                            else if (_deltaVar == deltaVar)
                            { }
                            else
                            { }
                        }




                    }

                    //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


                    if (conf.intervalleVar)
                    {
                        delta = deltaVar;
                        atterissageMin = atterissageMinVar;
                        intervalleMin = intervalleMinVar;
                        intervalleMin0 = intervalleMin0Var;
                        intervalle = intervalleVar;

                    }


                    //if (this.album.Album == "Sur les épaules de Darwin" && index0 >= indexCourant - 10)
                    //{
                    //}

                    if (intervalleMin > delta)
                        intervalleMin = delta;
                    if (intervalleMin0 > intervalleMin)
                        intervalleMin0 = intervalleMin;
                    if (atterissageMin > intervalleMin)
                        atterissageMin = intervalleMin;





                }



                if (conf.extPente > 0)
                {
                    var d0 = (DateTime.Now - pub2).TotalDays;
                    var dl = conf.extDelta;
                    if (dl == 0)
                    {
                        dl = d0;
                    }

                    delta0 = d0 / conf.extPente;
                    delta = delta0;
                    //01/01/2014 ->01/01/2017
                    //04/01/2017 -> 04/01/2014
                    var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                    var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                    log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                    if (deltaLimiteEcoule > delta)
                    {
                        double _coeff = deltaLimiteEcoule / delta;
                        delta = borne(_coeff, intervalle, intervalleMin);
                    }

                    if (delta < 1)
                        delta = 1;




                    //if (delta > intervalle)
                    //    delta = intervalle;
                }

                if (conf.limitRead && deltaLecture > intervalle)
                {
                    //13 /10 ->7
                    var _old = delta;

                    delta += intervalle - deltaLecture;
                    log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
                }





                if (delta < intervalleMin)
                    delta = intervalleMin;

                if (delta > intervalle)
                    delta = intervalle;



                DateTime limitFuture = lastPub2.AddDays(delta).truncateToMinute();
                DateTime ll = pub2.AddDays(atterissageMin).truncateToMinute();
                if (limitFuture < ll)
                    limitFuture = ll;
                //  limitFuture = pub2.AddDays(delta).truncateToMinute();
                double ecart = 0;
                if (indexLastRead + 1 < count)
                {
                    TrackSort _next = list[indexLastRead + 1];
                    ecart = (limitFuture - _next.Pub).TotalDays;
                }

                DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * ecart).truncateToMinute();
                //var cumul = (limitFuture - next.Pub).TotalDays;
                //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
                //if (dtaux > limitFutureRab)
                //    limitFutureRab = dtaux; 
                DateTime nextDate = limitFuture;

                int nb = 0;
                int nblissage = 0;
                double deltaAtterrissage = intervalleMin;
                double atterrissageVacance = deltaAtterrissage;

                if (this.album.Album == "La tête au carré" && index0 > indexCourant - 6)
                {
                }

                if (conf.noCollision)
                    deltaAtterrissage = delta;
                if (conf.extPente > 0)
                    deltaAtterrissage = delta0;
                string causes = "";

                if (conf.deltaConst || conf.extPente > 0)
                {
                }

                else
                {
                    var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                    var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                    DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                    var sbCause = new StringBuilder();

                    for (int i = indexLastRead + 1; i < count; i++)
                    {
                        var t = list[i];
                        if (conf.useVirtuel)
                        {
                            // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                            dt = dt.AddDays(intervalleMin0);
                        }
                        else
                            dt = t.Pub;


                        nb++;
                        if (dt > limitFuture)
                        {
                            sbCause = new StringBuilder();
                            nextDate = dt;
                            nblissage++;

                            int nbCause = 0;
                            if (dt <= _deltaMin)
                            {
                                sbCause.Append(" deltaMin");
                                nbCause++;
                            }
                            if (dt <= _deltaRab)
                            {
                                sbCause.Append(" deltaRab");
                                nbCause++;
                            }
                            if (nb <= conf.deltaNbMin)
                            {
                                sbCause.Append(" deltaNbMin");
                                nbCause++;
                            }
                            if (nblissage <= conf.deltaNbRab)
                            {
                                sbCause.Append(" deltaNbRab");
                                nbCause++;
                            }
                            if (dt <= limitFutureRab)
                            {
                                sbCause.Append(" coeffRab");
                                nbCause++;
                            }

                            if (nbCause > 0)
                            {
                                causes = sbCause.ToString();
                                continue;
                            }


                            break;


                            //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                            //    break;
                        }

                    }

                    if (nb > 0 && conf.noCollision) //    (nextDate > limitFuture && nb > 0 && conf.noCollision)
                    {
                        deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (deltaAtterrissage > intervalleMin)
                            deltaAtterrissage = intervalleMin;
                    }
                }

                if (deltaAtterrissage < atterissageMin)
                {
                    causes += " corrigé atterrissageMin";
                    deltaAtterrissage = atterissageMin;

                }


                atterrissageVacance = delta * rapport + deltaAtterrissage * (1 - rapport);


                //string atter = string.Format("{0}->{1}", delta.ToString("0.##"), deltaAtterrissage.ToString("0.##"));
                //if (conf.vacances && deltaAtterrissage != atterrissageVacance)
                string atter = string.Format("{0}:{1}->{2}({3})", intervalleFactMoy.ToString("0.##"), delta.ToString("0.##"), deltaAtterrissage.ToString("0.##"), atterrissageVacance.ToString("0.##"));

                string deltas = string.Format("{0} ic={1}({2}) h={3} i={4} r={5}% ({6}%)", atter,
                   conf.intervalleVar ? intervalleCorrecVar.ToString("0.##") : intervalleCorrec.ToString("0.##"),
                   conf.intervalleVar ? intervalleCorrec.ToString("0.##") : intervalleCorrecVar.ToString("0.##"), deltaHorizon.ToString("0.##"), intervalle.ToString("0.##"),
                   (100 * rapport).ToString("0"), (100 * rapportBorne).ToString("0"));
                //    deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"));
                string stats = string.Format("{0}/{1}={2}% c={3} d={4}% dr={5} r={6}({7})", nbRead, nbTotal, (100 * rapport).ToString("0"), coeff.ToString("0.##"), (densite * 100).ToString("0"), (100 * densite * rapport).ToString("0"),
                    deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"));
                var sbAlbum = new StringBuilder();

                sbAlbum.Append(string.Format("[{0}]", album.Album));
                if (album.Rare) sbAlbum.Append(" rare ");
                else if (rare) sbAlbum.Append(" rare+ ");
                sbAlbum.Append(current.track.Duree.TotalMinute.ToString("0 m"));

                string _usetolerance = useTolerance ? "+" : " ";
                string h = borneParHorizon ? "h" : " ";
                string _rapportBorne = (rapportBorne == 1 & rapport < 1) ? "~" : " ";
                var str = string.Format("{0} {1}{2}{3}{4} lect={5} causes={6}", stats, sbAlbum.ToString(), _usetolerance, h, _rapportBorne, deltaLecture.ToString("#,#"), causes);

                if (played)
                {
                    if (index0 >= indexCourant)
                        log.logNoDate(str);
                    else
                        logDebug.logNoDate(str);
                }


                //  nb = 0;
                // bool enRetard = limitFuture < date0;

                //int indexDepart = indexLastRead + 1;
                // int indexNext = index0 + 1;

                //if (current != lastRead)
                int suivant = index0 + 1;
                if (suivant < count)
                {

                    var t = list[index0 + 1]; // current; // list[indexNext];

                    var _deltaAtterrissage = deltaAtterrissage;
                    var _atterrissageMin = atterissageMin;
                    if (conf.vacances && firstSel)
                    {
                        _deltaAtterrissage = atterrissageVacance;
                        _atterrissageMin = delta * rapport + atterissageMin * (1 - rapport);
                    }

                    DateTime dt = lastPub2;

                    if (suivant == indexLastRead + 1 && !conf.useVirtuel2)
                    {
                        dt = limitFuture;
                        // lastPubTh = limitFuture;
                    }
                    else
                    {


                        var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                        if (conf.useVirtuel2)
                        {
                            dt = lastPub2.AddDays(d * _deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                            // lastPubTh = lastPub2.AddDays(d * _atterrissageMin).truncateToMinute();
                        }
                        else
                        {
                            dt = lastPub2.AddDays(_deltaAtterrissage).truncateToMinute();
                            // lastPubTh = lastPubTh.AddDays(_atterrissageMin).truncateToMinute();
                        }
                        if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1 && t.Pub2 < date1)
                        {
                            var dt2 = dt;
                            if (conf.useVirtuel2)
                                dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                            else
                                dt2 = lastPub2.AddDays(delta).truncateToMinute();
                            //if (dt2 <= date0)
                            dt = dt2;
                            //else
                            //    dt = date0.AddMinutes(1);
                        }


                    }

                    if (!firstSel)
                    {
                        if (dt > date0)
                            firstSel = true;
                    }



                    var dtMin = lastPub2.AddDays(atterissageMin);

                    if (dt < dtMin)
                        dt = dtMin;

                    if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    {
                        eraseSort(t, deltas, pubMoy);
                    }
                    else
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                        {
                            if (__delta > cumulMin)
                            {
                                __delta = borneCumul(__delta, cumulMin, cumulMax);
                                dt = t.Pub.AddDays(__delta).truncateToMinute();
                            }
                        }

                        if (conf.elastique2 < 1)
                        {
                            var deltacorr2 = __delta * conf.elastique2;
                            dt = t.Pub.AddDays(deltacorr2).truncateToMinute();
                        }



                        if (dt < dtMin)
                            dt = dtMin;

                        var limitDelta = conf.limitDelta;
                        if (limitDelta > 0)
                        {
                            var dtMax = lastPub2.AddDays(limitDelta);
                            if (dt > dtMax)
                                dt = dtMax; 
                        }

                        if (dt > DateTime.Now)
                        {
                        }

                        if ((dt - t.Pub).TotalDays > 100)
                        {
                        }

                        if (t.Pub >= dt)
                            eraseSort(t, deltas, pubMoy);
                        else
                            writeComment(t, dt, deltas, pubMoy);
                        //nb++;
                    }


                    last = t;
                    lastPub2 = t.Pub2; // dt;
                    //if (t.Pub2 < lastPub2)
                    //{
                    //    if (t.Pub != t.Pub2)
                    //    {
                    //    }
                    //    lastPub2 = t.Pub2;
                    //}

                    //  lastPub2 = System.Math.Min(dt, t.Pub2); // dt;  //t.Pub2; FIX BUG ??
                    //if (lastPubTh > lastPub2)
                    //    lastPubTh = lastPub2;

                    pubMoy = pubMoy.AddDays(intervalleFactMoy);
                    pubMoyForCalcul = pubMoyForCalcul.AddDays(intervalleFactMoy);

                    if (pubMoyForCalcul > lastPub2)
                        pubMoyForCalcul = lastPub2;


                    if (played)
                    {
                        //prelastRead = current;
                        ////lastPlayed = lastRead.PlayedDate;
                        //indexPrelastRead = index0;
                    }

                }


                index0++;
            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }


        public void Build()
        {
            if (album.Album == "SCIENCE PUBLIQUE")
            {
            }
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            //if (conf.enabled == sortMode.histo)
            //{
            //    buildAll();
            //    return;
            //}
            //else
            //{
            //checkSelected = true;
            //apply = true;
            date0 = Conf.Date0;
            if (conf.deltaConstLate >= 0)
                date1 = date0.AddDays(conf.deltaConstLate);
            // newDate0 = Conf.NewDate0;
            if (conf.extPente > 0 || conf.oldMode)
                build0();
            else
                build();
            return;
            //  }

            #region old
            /* if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true, true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, true);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, true, true, Conf.Date0, Conf.NewDate0);
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            */
            #endregion


        }



        private void eraseSort(TrackSort track, string desc, DateTime dateMoy)
        {
            writeComment(track, track.Pub, desc, dateMoy);
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (!checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = track.Pub;
            //    return;
            //}

            ////if (!force && !track.Selected)
            ////    return;
            //if (conf.canGoBack || conf.enabled == sortMode.reset)
            //{
            //    if (!track.Played && track.Enabled)
            //    {
            //        DateTime pub = track.Pub;
            //        if (track.Pub2 >= date0 && pub <date0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //        else if (track.Pub2 >=newDate0 && pub < newDate0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //    }

            //    //}
            //    //else
            //    //{
            //    if (track.Pub2 != track.Pub)
            //        nbModif++;
            //    track.Pub2 = track.Pub;
            //    //}
            //    track.track.BuildComment();
            //    // writeComment(track);
            //}
        }

        //private void applyPub(TrackSort track)
        //{
        //    writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);
        //}

        private void writeComment(TrackSort track, DateTime dt, string desc, DateTime pubMoy)
        {
            dt = dt.truncateToMinute();
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = dt;
            //    return;
            //}



            //if (checkSelected && !track.Selected)
            //    return;


            if (conf.canGoBack)
            {
                if (!track.Played && track.Enabled)
                {
                    if (track.pub20 >= date0 && dt < date0)
                    {
                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            repeches.Add(track);
                        }
                        if (dt < dateRepeche)
                            dateRepeche = dt;
                    }

                    //else if (track.pub20 >= newDate0 && dt < newDate0)
                    //{

                    //    if (conf.canGoBackButForceSelected)
                    //    {
                    //        log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                    //        nbRepecheForce++;
                    //        dt = date0.AddMinutes(nbRepecheForce);
                    //    }
                    //    else
                    //    {
                    //        log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.pub20, dt, newDate0);
                    //        repeches.Add(track);
                    //    }

                    //    if (dt < dateRepeche)
                    //        dateRepeche = dt;

                    //}
                }
            }
            else
            {
                if (dt == track.pub20)
                {
                    logDebug.logNoDate("\t{0} {1} {2}\t{3}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), desc, track.Name);
                    return;
                }
                else if (dt < track.pub20)
                {
                    logDebug.logNoDate("\t{0} {1}<= {2} {3}\t{4}", track.Pub.ToString(DATE_FORMAT), track.pub20.ToString(DAY_FORMAT), dt.ToString(DAY_FORMAT), desc, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var delta0 = (track.pub20 - track.Pub).TotalDays;

            var deltaMoy0 = (track.pub20 - pubMoy).TotalDays;
            var deltaMoy1 = (dt - pubMoy).TotalDays;


            var sbDelta = new StringBuilder();
            sbDelta.Append("(");
            var strD0 = delta0.ToString("#.#");
            var strD1 = delta.ToString("#.#");

            var strDM0 = deltaMoy0.ToString("#.#");
            var strDM1 = deltaMoy1.ToString("#.#");
            if (delta0 > 0)
            {
                if (delta0 > 0)
                    sbDelta.Append(strD0);
                //sbDelta.Append("|");
                ////  if (deltaMoy0 > 0)
                //sbDelta.Append(strDM0);
            }
            if (strD0 != strD1)
            {
                sbDelta.Append("->");
                if (delta > 0)
                    sbDelta.Append(strD1);
                //sbDelta.Append("|");
                //if (deltaMoy1 > 0)
                //    sbDelta.Append(strDM1);
            }
            //sbDelta.Append("|");
            //if (deltaMoy0 != 0)
            //{
            //    sbDelta.Append(strDM0);

            //    if (strDM1 != strDM0)
            //    {
            //        sbDelta.Append("->");
            //        if (deltaMoy1 > 0)
            //            sbDelta.Append(strDM1);
            //    }
            //}
            sbDelta.Append(")");

            while (sbDelta.Length < 22)
                sbDelta.Append(" ");

            var strDelta = sbDelta.ToString();

            if (track.pub20 != dt)
            {

                if (track.pub20.truncateToMinute() != dt)
                {
                    //if (track.track.Selected)
                    //{
                    nbModif++;
                    var d = System.Math.Abs((track.pub20 - dt).TotalHours);
                    if (d > 1)
                        nbModifPertinent++;

                    var dd = System.Math.Abs((track.pub20 - dt).TotalMinutes);
                    if (dd <= 5)
                    {
                        log.log("poil de cul {0}", track);
                    }

                    // var str = string.Format("\t{0}\t{1}=>\t{2}({3})\t{4} {5}", track.Pub, track.pub20, dt, strDelta, desc, track.Name);
                    var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), strDelta, desc, track.Name); // ", track.pub20, dt, strDelta, desc, track.Name);
                    if (track.track.Selected)
                        log.logNoDate(str);
                    else
                        logDebug.logNoDate(str);
                    //}
                }
                track.Pub2 = dt;
            }
            else if (track.pub20 > track.Pub)
            {
                // if (track.track.Selected)
                var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), dt.ToString(DAY_FORMAT), strDelta, desc, track.Name);
                // var str = string.Format("\t{0}\t{1}({2})\t{3} {4}", track.Pub, track.pub20, strDelta, desc, track.Name);
                if (track.track.Selected)
                    log.logNoDate(str);
                else
                    logDebug.logNoDate(str);
            }
            else
            {
                var sbBlanc = new StringBuilder();

                var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), Regex.Replace(dt.ToString(DAY_FORMAT), ".", " "), strDelta, desc, track.Name);
                // var str = string.Format("\t{0} ({1})\t{2} {3}", track.Pub, strDelta, desc,track.Name);
                logDebug.logNoDate(str);
            }


            track.track.BuildComment();
            //  track.track.BuildComposer(); 
        }

        private static double borne(double coeff, double intervalle, double intervalleMin)
        {

            if (intervalle < intervalleMin)
                intervalleMin = intervalle;
            if (coeff <= 1)
                return coeff * intervalleMin;
            coeff -= 1; // 9  0.11
            var dminmax = intervalle - intervalleMin;

            var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

            return _delta;
        }

        private static double borneCumul(double delta, double cumulMin, double cumulMax)
        {
            if (cumulMin < 0 || cumulMax < 0)
                return delta;
            if (delta < cumulMin)
                return delta;
            var coeff = delta / cumulMin;
            return borne(coeff, cumulMax, cumulMin);
        }

        private double _coeffLecture = -1;
        public double getCoeffLecture(TrackInfoItunes track)
        {
            if (_coeffLecture > 0)
                return _coeffLecture;
            int count = list.Count;
            int index = -1;
            for (int i = 0; i < count; i++)
            {
                if (list[i].track == track)
                {
                    index = i;
                    break;
                }
            }
            if (index < 0)
                return 0;

            var _histo = conf.getHisto(track.Rare);

            if (_histo > 0)
            {
                int nbTotal = 0;
                int nbRead = 0;
                double histo = _histo;




                DateTime limit = track.Pub.AddDays(-histo);
                for (int i = index - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }

                if (nbTotal > 0)
                    _coeffLecture = nbRead / nbTotal;
                else
                    return 0;
            }
            else
                return 0;

            return _coeffLecture;



        }
    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Sort.cs">
    <content><![CDATA[using System.Xml;
using pdb.util;
using System;
using System.Collections.Generic;
using pdb.podcast.Albums;

namespace pdb.podcast.Tuning.Sort
{
    public enum sortMode
    {
        no,
        reset,
        white,
        once,
        once_all,
        all,
        //  histo
    }

    public enum histoMode
    {
        /// <summary>
        /// Démarrage de l'histo sur Date0
        /// </summary>
        fix,
        /// <summary>
        /// Démarrage de l'histo sur le premier sélectionné
        /// </summary>
        selected,
        /// <summary>
        /// Démarrage de l'histo sur le dernier lu
        /// </summary>
        read

    }
    public class SortItem : SelectParamBase
    {
        /// <summary>
        /// nom de l'album ou suite d'albums
        /// </summary>
        new public List<string> name = new List<string>();

        public sortMode enabled;
        public bool checkBefore;
        public bool selectionBefore;
       
        ///// <summary>
        ///// prise en compte des longs podcasts
        ///// </summary>
        //public double dureeMin;
        /// <summary>
        /// intervalle max entre deux écoutes (une semaine)
        /// </summary>
        private double intervalle = 7;
        /// <summary>
        /// intervalle min entre deux écoutes (un jour)
        /// </summary>
        private double intervalleMin = 1;
        /// <summary>
        /// intervalle standard entre deux écoutes (un jour)
        /// </summary>
        private double intervalleMin0 = 1;
        /// <summary>
        /// intervalle max entre deux écoutes pour un rare
        /// </summary>
        private double intervalleR;
        /// <summary>
        /// intervalle min entre deux écoutes pour un rare
        /// </summary>
        private double intervalleMinR = 7;
        /// <summary>
        /// intervalle standard entre deux écoutes pour un rare
        /// </summary>
        private double intervalleMinR0 = 7;
        /// <summary>
        /// coeff intervalle par heure du dernier lu
        /// </summary>
        public double rapportDuree = 0;
        /// <summary>
        /// coeff intervalle par heure du dernier lu rare
        /// </summary>
        public double rapportDureeR = 0;
        /// <summary>
        /// On prend en compte la durée pour augmenter le coeff
        /// </summary>
        public bool dureeCoeff;
        /// <summary>
        /// On prend en compte la durée pour augmenter les bornes
        /// </summary>
        public double dureeBorne;
        /// <summary>
        /// On prend en compte la durée pour augmenter les bornes mais on n'augmente que le delta
        /// </summary>
        public double dureeBorneDelta;
        /// <summary>
        /// Densité en-dessous de laquelle l'album est considéré comme rare
        /// </summary>
        public double densiteMin = 0.1;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMin; 
        /// </summary>
        public bool minUseDuree = true;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMin pour les rares
        /// </summary>
        public bool minUseDureeR = true;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMax 
        /// </summary>
        public bool maxUseDuree = true;
        ///  <summary>
        /// On utilise la durée dans le calcul d'intervalleMax pour les rares
        /// </summary>
        public bool maxUseDureeR = true;
        ///// <summary>
        ///// nb d'écoutes maximum dans l'intervalle (typiquement 5)
        ///// </summary>
        //private double ecouteMax;
        ///// <summary>
        ///// nb d'écoutes maximum dans l'intervalle pour un rare
        ///// </summary>
        //private double ecouteMaxR;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute
        /// </summary>
        private double histo;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute pour un rare
        /// </summary>
        private double histoR;
        /// <summary>
        /// nombre d'items pris en comptepour l'historique
        /// </summary>
        private int nbHisto;
        /// <summary>
        /// nombre d'items pris en comptepour l'historique pour un rare
        /// </summary>
        private int nbHistoR;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : nombre minimum d'éléments à prendre en compte
        /// </summary>
        public int deltaNbMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'éléments à prendre en compte
        /// </summary>
        public int deltaNbRab;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : intervalle minimum à prendre en compte en jours
        /// </summary>
        public double deltaMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'intervalle à prendre en compte
        /// </summary>
        public double deltaRab;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'intervalle à prendre en compte, en proportion de l'écart initial
        /// </summary>
        public double coeffRab;
        /// <summary>
        /// Ecart min entre deux podcasts non rares à l'atterrissage
        /// </summary>
        public double atterrissageMin = 0.5;

        /// <summary>
        /// Ecart min absolu
        /// </summary>
        private double atterrissageMin0 = 0.5;
        /// <summary>
        /// Ecart min entre deux podcasts rares à l'atterrissage
        /// </summary>
        public double atterrissageMinR = 1;

        /// <summary>
        /// Détermination de la densité à venir sur N jours
        /// </summary>
        public double futur = -1;
        /// <summary>
        /// Détermination de la densité à venir sur N jours pour les rares
        /// </summary>
        public double futurR = -1;
        /// <summary>
        /// Pour calcul horizon, période à prenre en compte
        /// </summary>
        public double futurh = 365;

        /// <summary>
        /// Partie futur antérieure. Permet de limiter les grosses moyennes; à la dernire occurance, on prend en compte une durée avant
        /// </summary>
        public double futura = 0; 

        /// <summary>
        /// Dans la correction du delta par rapport à la proportion de lus, une tolérance pour pouvoir par exemple laisser courir pendant une semaine
        /// </summary>
        public double tolerance = 35;

        /// <summary>
        /// Dans la correction du delta par rapport à la proportion de lus, une tolérance pour pouvoir par exemple laisser courir pendant un mois 
        /// </summary>
        public double toleranceR = 35;

        /// <summary>
        /// Dans le calcul de la tolérance, nb de morceaux à prendre en compte; 
        /// </summary>
        public int nbTolerance;

        /// <summary>
        /// Dans le calcul de la tolérance, nb de morceaux à prendre en compte pour les rares; 
        /// </summary>
        public int nbToleranceR;

        /// <summary>
        /// si dépassement on rappelle
        /// </summary>
        public bool toleranceNegative;

        /// <summary>
        /// pas d'empilage des tracks repoussés
        /// </summary>
        public bool noCollision;
        /// <summary>
        /// recalcul peut entrainer une date plus récente
        /// </summary>
        public bool canGoBack;
        /// <summary>
        /// recalcul peut entrainer une date plus récente, mais si ça le rend non séléctionné, on bricole pour qu'il soit quand même selectionné
        /// </summary>
        public bool canGoBackButForceSelected;
        /// <summary>
        /// écart constant entre les poscasts repoussés
        /// </summary>
        public bool deltaConst;

        /// <summary>
        /// Date0 lors de l'écoute du dernier podcast externe
        /// </summary>
        public DateTime extLast0;
        /// <summary>
        /// Décalage entre date du podcast supplémentaire et la date0
        /// </summary>
        public double extDelta;
        /// <summary>
        /// coefficient permettant le calcul de la prochaine date en fonction du retard entre la date0 et maintenant
        /// </summary>
        public double extPente;
        /// <summary>
        /// check de la date de dernière lecture
        /// </summary>
        public bool limitRead;
        ///// <summary>
        ///// Dans le calcul de delta ne pas inclure les non-selectionnés
        ///// </summary>
        //public bool deltaCheckSelected;
        /// <summary>
        /// handicap pour les nouveaux podcasts
        /// </summary>
        public int totalMin;
        /// <summary>
        /// Coefficient de rappel vers la valeur initiale pour les lus
        /// </summary>
        public double elastique = 1;

        /// <summary>
        /// Coefficient de rappel vers la valeur initiale pour les non lus
        /// </summary>
        public double elastique2 = 1;

        /// <summary>
        /// Cumul max de retard pour les non-rares
        /// </summary>
        public double cumulMax = -1;

        /// <summary>
        /// Cumul max de retard pour les rares
        /// </summary>
        public double cumulMaxR = -1;

        /// <summary>
        /// Cumul min de retard pour les non-rares
        /// </summary>
        public double cumulMin = -1;

        /// <summary>
        /// Cumul min de retard pour les rares
        /// </summary>
        public double cumulMinR = -1;

        /// <summary>
        /// Pas d'amortissement pour les vieux podcasts, vieux en jours par rapport à la date0
        /// </summary>
        public int deltaConstLate = -1;

        /// <summary>
        /// Utilisation de track virtuels pour éviter accidents (tracks manquants)
        /// </summary>
        public bool useVirtuel;

        /// <summary>
        /// Utilisation de track virtuels pour affectation pub2
        /// </summary>
        public bool useVirtuel2;

        /// <summary>
        /// Dès la pub2 remise à zero, les suivants aussi
        /// </summary>
        public bool erasedDone;
        /// <summary>
        /// On recalcule tout
        /// </summary>
        public bool recheck;
        /// <summary>
        /// En mode vacance on tasse moins les tracks. implique !recheck
        /// </summary>
        public bool vacances;
        /// <summary>
        /// on fait comme avant
        /// </summary>
        public bool oldMode;

        /// <summary>
        /// Dans le coeff, on prend en compte la densité
        /// </summary>
        public bool coeffDensite;


        /// <summary>
        /// On utilise des intervalles en fonction de la répartition effective ( et non pas déclarative ) des tracks. En clair les intervalles de 7j ou de 1j sont plus finement évalués
        /// </summary>
        public bool intervalleVar;
        /// <summary>
        /// Proportion entre 0 et 1 de l'atterrissage par rapport à intervalleMin
        /// </summary>
        public double atterrissageMinVar = 1;

        /// <summary>
        /// Détermination plutôt que déclaration de intervalleMin0
        /// </summary>
        private bool useintervalleFactMin;

        /// <summary>
        /// on limite aux valeurs "rare" (14j * duree) 
        /// </summary>
        private bool intervalleBorne;
        /// <summary>
        /// Un petit coup de rallonge pour les bientôt finis
        /// </summary>
        public bool honneurAuxVieux;
        /// <summary>
        /// On n'applique l'horizon qu'à la fin
        /// </summary>
        public bool horizonFinal;
        /// <summary>
        /// l'interpolation n'est pas linéaire mais au carré entre 0 et un et asymptotique vers 2 après
        /// </summary>
        public bool mixCarre;
        /// <summary>
        /// Aggrégation de la densite et de la duree positionnement du variable
        /// </summary>
        private bool mixVarDuree;

        /// <summary>
        /// Arret quand la date0 change
        /// </summary>
        public bool stopOnOffset;

        /// <summary>
        /// Arret quand une pub2 change
        /// </summary>
        public bool stopOnPub2;

        /// <summary>
        /// Coeff > 1 appliqué au rapport en vue de déterminer l'horizon. Permet de diminuer l'horiszon et nous donner un peu d'air - marre des séries à +10j
        /// </summary>
        public double rapportHorizonCoeff = 1.0;
        /// <summary>
        /// Coeff > 1 appliqué au rapport en vue de déterminer l'horizon pour les rares. Permet de diminuer l'horiszon et nous donner un peu d'air - marre des séries à +10j
        /// </summary>
        public double rapportHorizonCoeffR = 1.0;

        /// <summary>
        /// en cas de plusieurs podcasts dans la même journée, durée min pour en compter plusieurs en min
        /// </summary>
        public double collisionDuree = -1;

        /// <summary>
        /// Moyenne limite
        /// </summary>
        public double limitMoy = -1;

        /// <summary>
        /// Delta limite
        /// </summary>
        public double limitDelta = -1; 

        

        public histoMode histoMode;

        private ITrackSelector selector;

        public SortItem()
        {
        }

        public SortItem(XmlElement parent, XmlElement node)
            : base(parent, node)
        {

            if (node == null)
                return;
            var str = "";
            builds("name", v => str = v);

            if (!string.IsNullOrEmpty(str))
            {
                foreach (string album in str.Split('|'))
                {
                    if (!string.IsNullOrWhiteSpace(album))
                        name.Add(album.ToLowerWithoutDiacritics());
                }
            }

            builds("enabled", v => str = v);

            if (!string.IsNullOrEmpty(str))
                enabled = (sortMode)Enum.Parse(typeof(sortMode), str);

            buildd("dureeMin", v => dureeMin = v);
            buildd("intervalle", v => intervalle = v);
            buildd("intervalleMin", v => intervalleMin = v);
            buildd("intervalleMin0", v => intervalleMin0 = v);
            buildd("intervalleR", v => intervalleR = v);
            buildd("intervalleMinR", v => intervalleMinR = v);
            buildd("intervalleMinR0", v => intervalleMinR0 = v);

            buildd("atterrissageMin", v => atterrissageMin = v);
            buildd("atterrissageMinR", v => atterrissageMinR = v);
            buildd("histo", v => histo = v);
            buildd("histoR", v => histoR = v);
            buildi("nbHisto", v => nbHisto = v);
            buildi("nbHistoR", v => nbHistoR = v);

            buildd("futur", v => futur = v);
            buildd("futura", v => futura = v);
            buildd("futurR", v => futurR = v);
            //buildd("ecouteMax", v => ecouteMax = v);
            //buildd("ecouteMaxR", v => ecouteMaxR = v);

            buildDate("extLast0", v => extLast0 = v);
            buildd("extDelta", v => extDelta = v);
            buildd("extPente", v => extPente = v);




            buildb("deltaConst", v => deltaConst = v);
            buildb("toleranceNegative", v => toleranceNegative = v);
            buildi("deltaConstLate", v => deltaConstLate = v);
            buildb("useVirtuel", v => useVirtuel = v);
            buildb("useVirtuel2", v => useVirtuel2 = v);

            buildb("noCollision", v => noCollision = v);
            buildb("checkBefore", v => checkBefore = v);
            buildb("selectionBefore", v => selectionBefore = v);
            buildb("limitRead", v => limitRead = v);
            buildb("canGoBack", v => canGoBack = v);
            // buildb("deltaCheckSelected", v => deltaCheckSelected = v);

            #region lissage
            buildi("deltaNbMin", v => deltaNbMin = v);
            buildi("deltaNbRab", v => deltaNbRab = v);

            buildd("deltaMin", v => deltaMin = v);
            buildd("deltaRab", v => deltaRab = v);

            #endregion

            builds("histoMode", v => str = v);
            histoMode = (histoMode)Enum.Parse(typeof(histoMode), str);

            buildi("totalMin", v => totalMin = v);

            buildd("elastique", v => elastique = v);
            buildd("elastique2", v => elastique2 = v);



            buildd("cumulMin", v => cumulMin = v);
            buildd("cumulMinR", v => cumulMinR = v);
            buildd("cumulMax", v => cumulMax = v);
            buildd("cumulMaxR", v => cumulMaxR = v);
            buildd("rapportDuree", v => rapportDuree = v);
            buildd("rapportDureeR", v => rapportDureeR = v);
            buildd("coeffRab", v => coeffRab = v);


            buildb("dureeCoeff", v => dureeCoeff = v);
            buildd("dureeBorne", v => dureeBorne = v);
            buildd("dureeBorneDelta", v => dureeBorneDelta = v);
            buildd("densiteMin", v => densiteMin = v);


            buildb("minUseDuree", v => minUseDuree = v);
            buildb("maxUseDuree", v => maxUseDuree = v);

            buildb("minUseDureeR", v => minUseDureeR = v);
            buildb("maxUseDureeR", v => maxUseDureeR = v);

            buildb("erasedDone", v => erasedDone = v);
            buildb("recheck", v => recheck = v);
            buildb("vacances", v => vacances = v);
            buildb("oldMode", v => oldMode = v);

            buildd("tolerance", v => tolerance = v);
            buildd("toleranceR", v => toleranceR = v);

            buildi("nbTolerance", v => nbTolerance = v);
            buildi("nbToleranceR", v => nbToleranceR = v);

            buildb("coeffDensite", v => coeffDensite = v);
            buildb("intervalleVar", v => intervalleVar = v);
            buildd("atterrissageMinVar", v => atterrissageMinVar = v);
            buildb("useintervalleFactMin", v => useintervalleFactMin = v);
            buildb("intervalleBorne", v => intervalleBorne = v);
            buildb("honneurAuxVieux", v => honneurAuxVieux = v);
            buildb("horizonFinal", v => horizonFinal = v);
            buildd("atterrissageMin0", v => atterrissageMin0 = v);
            buildb("mixCarre", v => mixCarre = v);
            buildb("mixVarDuree", v => mixVarDuree = v);
            buildb("stopOnOffset", v => stopOnOffset = v);
            buildb("stopOnPub2", v => stopOnPub2 = v);

            buildd("rapportHorizonCoeff", v => rapportHorizonCoeff = v);
            buildd("rapportHorizonCoeffR", v => rapportHorizonCoeffR = v);

            buildd("collisionDuree", v => collisionDuree = v);
            buildd("limitMoy", v => limitMoy = v);
            buildd("limitDelta", v => limitDelta = v); 

            this.selector = new TrackSelector(this);
        }
        /// <summary>
        /// donne l'intervalle plafond
        /// </summary>
        /// <param name="rare">album rare</param>
        /// <param name="duree">duree du dernier track en heures</param>
        /// <returns></returns>
        public double getIntervalle(bool rare, double duree, double intervalleMin0)
        {
            var _intervalle = rare && intervalleR > 0 ? intervalleR : intervalle;
            var _rapportDuree = rare ? rapportDureeR : rapportDuree;
            return getIntervalle(_intervalle, _rapportDuree, duree, intervalleMin0);
        }

        

        private double getIntervalle(double intervalle, double rapportDuree, double duree, double intervalleMin0)
        {
            var ret0 = intervalle;
            var ret1 = ret0;
            var ret2 = ret0;
            var coeff = duree * rapportDuree;
            if (coeff > 1)
            {
                if (dureeBorne > 0)
                {

                    // ex coeff =2
                    // avec dureeBornee = 0 => ret0
                    // avec dureeBornee = 0.1 =>0.9 +0.2    =>1.1 *ret0
                    // avec dureeBorne = 0.5 => 0.5 +1      =>1.5 *ret0
                    // avec dureeBorne = 0.9 => 0.1+1.8     =>1.9 *ret0
                    ret1 = ret0 * ((1 - dureeBorne) + coeff * dureeBorne);

                }
                if (dureeBorneDelta > 0)
                {
                    var delta = ret0 - intervalleMin0;
                    delta *= ((1 - dureeBorneDelta) + coeff * dureeBorneDelta);
                    ret2 = intervalleMin0 + delta;
                }
            }

            if (ret1 > ret2)
                return ret1;
            else
                return ret2;


        }

        private double getMix(double i, double ir, double X, double rapportDuree, double duree)
        {
            var coeff = rapportDuree * duree;
            if (coeff > 1)
                X *= coeff;
            return getMix(i, ir, X); 
        }
        /// <summary>
        /// Corrige le rapport pour determination de l'horizon 
        /// </summary>
        /// <param name="rapport"></param>
        /// <param name="X"></param>
        /// <returns></returns>
        public double getHorizonCorrec(double rapport, double X)
        {
            double r = rapportHorizonCoeffR;
            if (X < 0)
                r = rapportHorizonCoeff;
            //else if (X > 1)
            //{
            //}
            else
                r = rapportHorizonCoeff + X * (rapportHorizonCoeffR - rapportHorizonCoeff); 
            // r = getMix(rapportHorizonCoeff, rapportHorizonCoeffR, X);
            if (r < 1)
                r = 1; 
            var rapportModif = r * rapport;
            if (rapportModif > 1)
                rapportModif = 1;

            return rapportModif; 

        }

        private double getMix(double i, double ir, double X)
        {
            if (X <= 0)
                return i;
            else if (X >= 1 && intervalleBorne)
                return ir;
            if (mixCarre)
            {
                if (X <= 1)
                    return i + X * X * (ir - i); 
                // 1=> ir v = 2 *(ir-i)
                // y= ax2
                return (2 * ir) - ir / X; 
            }
            return i + X * (ir - i);
            // avec i=2 et ir =1 
            //X=0.1 => 2+ 0.01*-1=> 1.99 correct
            //X=0.9 => 2 -0.81 = 1.19
            //X=1.1=> 2- 1/1.1

        }
        public double getIntervalleVar(bool rare, double X, double duree, double intervalleMin0)
        {
            var _rapportDuree = rare ? rapportDureeR : rapportDuree;
            if (mixVarDuree)
                return getMix(intervalle, intervalleR, X, _rapportDuree, duree); 
           
            double _intervalle = getMix(intervalle, intervalleR,X);
            return getIntervalle(_intervalle, _rapportDuree, duree, intervalleMin0);
        }

        private double getCoeffDuree(double rapportDuree, double duree)
        {
            var coeff = duree * rapportDuree;
            if (coeff > 1)
                return coeff;
            return 1; 
        }

        public double getRapport(bool rare, double duree)
        {
            var rapport0 = rare ? intervalleR / intervalleMinR0 : intervalle / intervalleMin0;
            var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
            if (coeff > 1)
                return rapport0 * coeff;
            return rapport0;
        }

        public bool applyDuree(bool min, bool rare)
        {
            if (dureeCoeff)
                return false;
            bool use = rare ? (min ? minUseDureeR : maxUseDureeR) : (min ? minUseDuree : maxUseDuree);
            return use;
        }
        public double getIntervalleMin(bool rare, double duree)
        {
            var ret0 = rare && intervalleMinR > 0 ? intervalleMinR : intervalleMin;
            if (applyDuree(true, rare))
            {
                var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
                if (coeff > 1)
                    return ret0 * coeff;
            }
            return ret0;
        }

        public double getIntervalleMinVar(bool rare, double X, double duree)
        {
            if (mixVarDuree )
            {                
                if (applyDuree(true, rare))
                {
                    var _rapportDuree = rare ? rapportDureeR : rapportDuree;
                    return getMix(intervalleMin, intervalleMinR, X, rapportDuree, duree); 
                }
                else
                    return getMix(intervalleMin, intervalleMinR, X); 
                   
            }
            var ret0 = getMix(intervalleMin, intervalleMinR, X); 
            if (applyDuree(true, rare))
            {
                var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
                if (coeff > 1)
                    return ret0 * coeff;
            }
            return ret0;
        }

        public double getCoeff(bool rare, double coeff0, double duree)
        {

            var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
            if (coeff > 1)
                return coeff0 * coeff;

            return coeff0;

        }

        public double getFutur(bool rare)
        {
            return rare ? futurR : futur;
        }

        public double getTolerance(bool rare)
        {
            return rare ? toleranceR : tolerance;
        }

        public int getNbTolerance(bool rare)
        {
            return rare ? nbToleranceR : nbTolerance;
        }


        public double getIntervalleMin0(bool rare)
        {
            var ret0 = rare && intervalleMinR0 > 0 ? intervalleMinR0 : intervalleMin0;
            return ret0;
        }

        public double getIntervalleMin0Var(double X, double intervalleFactMin)
        {
            if (useintervalleFactMin)
                return intervalleFactMin;
            return getMix(intervalleMin0, intervalleMinR0, X);            
        }


        public double getatterrissageMinVar(double X, double intervalleFactMin)
        {
            if (useintervalleFactMin)
                return intervalleFactMin * atterrissageMinVar;
            var ret =  getMix(atterrissageMin, atterrissageMinR, X);
            if (ret < atterrissageMin0)
                ret = atterrissageMin0;
            return ret; 

        }
        public double getHisto(bool rare)
        {
            return rare && histoR > 0 ? histoR : histo;
        }
        public int getNbHisto(bool rare)
        {
            return rare && nbHisto > 0 ? nbHistoR : nbHisto;
        }
        //public double getEcouteMax(bool rare)
        //{
        //    return rare && ecouteMaxR > 0 ? ecouteMaxR : ecouteMax;
        //}
        ///// <summary>
        ///// Donne le recalage max par morceau pour atterissage: typiquement pour un non-rare :0.5, pour un rare, disons 1
        ///// </summary>
        ///// <param name="rare"></param>
        ///// <returns></returns>
        //public double getRecupMax(bool rare)
        //{
        //    double ini = getIntervalleMin0(rare);
        //    if (rare)
        //        return ini - atterrissageMinR;
        //    else
        //        return ini - atterrissageMin; 
        //}

        public double getAtterrissageMin(bool rare)
        {
            return rare ? atterrissageMinR : atterrissageMin;
        }

        internal bool select(ISelectable album)
        {
            return selector.select(album);
        }

        public double getCumulMax(bool rare)
        {
            return rare && cumulMaxR > 0 ? cumulMaxR : cumulMax;
        }
        public double getCumulMin(bool rare)
        {
            return rare && cumulMinR > 0 ? cumulMinR : cumulMin;
        }


    }
    public class Sort : SortItem
    {
        private List<SortItem> items = new List<SortItem>();
        private List<SortItem> rules = new List<SortItem>();

        public SortItem getItem(string key)
        {
            foreach (SortItem g in items)
            {
                if (g.name.Contains(key))
                    return g;

            }
            return null;
        }

        public SortItem getRule(TrackAlbum album)
        {
            foreach (SortItem r in rules)
            {
                if (r.select(album))
                    return r;
            }

            return null;
        }
        public Sort()
        {

        }

        public Sort(XmlElement node)
            : base(null, node)
        {
            if (node == null)
                return;
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    if (sub.Name == "album")
                    {
                        items.Add(new SortItem(node, sub as XmlElement));
                    }
                    else if (sub.Name == "rule")
                    {
                        rules.Add(new SortItem(node, sub as XmlElement));
                    }
                }
            }


        }




    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\auto\CalcAuto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.auto
{
    public partial class ConfMedianneVirt : TuningBase
    {
        public bool linkconv { get { return _linkconv; } set { _linkconv = value; calcProduct(); } }

        private void calcProduct()
        {
            this.linkProduct = calcProduct(this.v, this.a);
        }

        public decimal calcProduct(decimal dcoeffp, decimal dconvergence)
        {
            var linkProduct = this.linkProduct;
            try
            {
                linkProduct = dcoeffp / dconvergence;
                // 1 0,9 -> 10
                // 0.1 0,99 
            }
            catch
            {
            }

            return linkProduct;
        }

        private void calcConv()
        {
            this.a = calcConv(this.v, this.linkProduct);
        }

        public decimal LinkProduct
        {
            get
            {
                if (linkProduct == 0m)
                    calcProduct();
                return linkProduct;
            }
            set
            {
                linkProduct = value;
                calcConv();

            }
        }

        public decimal calcConv(decimal dcoeffp, decimal linkProduct)
        {
            var dconvergence = this.a;
            try
            {
                // 1- conv = coeff / prod
                dconvergence = dcoeffp / linkProduct; //1/10
            }
            catch
            {

            }
            return dconvergence;
        }

        public void checkCoeffOld()
        {
            if (coeffOldAuto)
            {
                coeffOld = (decimal)pdb.util.Math.Pow(coeffVirt, coeffOldAutoLevel);
            }
        }

        private void verifMaxV()
        {

            var _dxmax = (coeffVirt - 1) * d0;
            var _dx = v * pas;
            if (_dx > _dxmax)
            {
                var vv = _dxmax / pas;
                misc.log("verifMaxV {0}->{1}", v.FormatE(4), vv.FormatE(4));
                v = vv;
            }
        }

        private void verifMaxA()
        {
            var _dxmax = (coeffVirt - 1) * d0;
            var _dx = 2 * a * pas * pas;

            if (_dx > _dxmax)
            {
                var aa = _dxmax / (2 * pas * pas);
                misc.log("verifMaxA {0}->{1}", a.FormatE(4), aa.FormatE(4));
                a = aa;
            }
        }

        private void verifBas()
        {
            var dx = v * pas;
            if (dx < epsilon)
            {
                //dx = epsilon;
                v = epsilon / pas;
            }

            //dx = vv * pas;
            //if (dx < epsilon)
            //{
            //    dx = epsilon;
            //    vv = epsilon / pas;
            //}

            var dv = a * pas;
            if (dv < vepsilon)
            {
                // dv = vepsilon;
                a = vepsilon / pas;

            }

            if (a < aepsilon)
                a = aepsilon;

            if (coeffVirt < 1)
                coeffVirt = 1;
        }
        private decimal _v0;
        private decimal getLimitedDelta(decimal v0, decimal oldSameDirection)
        {
            var v1 = v0;

            if (v0 > 1)
            {
                if (oldSameDirection > v0)
                {
                    v1 = 2 * v0 - oldSameDirection;
                    if (v1 < 1)
                        v1 = 1;
                }
            }
            return v1;
        }
        public bool calcAuto(bool selectedByCoeff, int deltaRank)
        {

            if (selectedByCoeff)
            {
                var d = deltaRank == 0 ? 1 : deltaRank;
                coeffLot = (decimal)d / (decimal)lot;
                if (coeffLot > 1)
                    coeffLot = 1;
            }
            var coeffVirt0 = coeffVirt;
            if (coeffOldSwap)
            {
                coeffVirt = coeffOld;
            }
            var _c0 = coeffVirt;
            _v0 = v;
            var oldSameDirection = Math.Abs(_nbSameDirection);

            // vv = v;
            var dv0 = dv;
            var _a0 = a;

            if (-_nbSameDirectionBox > serialm)
                _nbSameDirectionBox = -serialm;
            if (_nbSameDirectionBox > serialp)
                _nbSameDirectionBox = serialp;

            if (-_nbElastique > serialElastique)
                _nbElastique = -serialElastique;
            if (_nbElastique > serialElastique)
                _nbElastique = serialElastique;


            if (-_nbElastique2 > serialElastique)
                _nbElastique2 = -serialElastique;
            if (_nbElastique2 > serialElastique)
                _nbElastique2 = serialElastique;


            if (_nbAlt < 0)
                _nbAlt = 0;
            if (_nbAlt > serialAlt)
                _nbAlt = serialAlt;

            decimal ecart0 = System.Math.Max(_nbElastique, -_nbElastique2);

            var last = lastAutoDirection;
            var lastDelta_ = this.lastDelta;
            lastAutoDirection = selectedByCoeff;

            if (last.HasValue)
            {
                if (last != selectedByCoeff || (checkFall && selectedByCoeff))
                {
                    if (last != selectedByCoeff)
                    {
                        _nbAltHisto++;
                        _nbSameDirection = 0;
                        _nbAlt++;
                    }
                    else
                    {
                        _nbAltHisto = 0;
                    }

                    //if (_nbAltHisto > 1)
                    //{
                    if (selectedByCoeff)
                    {
                        _nbElastique -= coeffLot * getLimitedDelta(coeffElastique1dm, oldSameDirection); // rapportmp* coeffElastique1r;
                        _nbElastique2 -= coeffLot * getLimitedDelta(coeffElastique2dm, oldSameDirection); // rapportmp* coeffElastique2;
                    }
                    else
                    {
                        var c = -1M;
                        if (last != selectedByCoeff)
                        {
                            // si coeff ~ 0 je dois avoir +1
                            // si coeff ~ 1 je dois avoir -1
                            c = 1 - 2 * coeffLot; 
                        }
                        _nbElastique += c * coeffElastique1dp;
                        _nbElastique2 += c * coeffElastique2dp;
                    }

                    if (last != selectedByCoeff)
                    {
                        if (_nbAltHisto > 1)
                        {
                            if (currentStaticp > 1 && coeffStaticpRetour > 1)
                            {
                                currentStaticp /= coeffStaticpRetour;
                                if (currentStaticp < 1)
                                    currentStaticp = 1;
                            }
                            if (currentStaticm > 1 && coeffStaticmRetour > 1)
                            {
                                currentStaticm /= coeffStaticmRetour;
                                if (currentStaticm < 1)
                                    currentStaticm = 1;
                            }
                        }
                    }

                    else
                    {
                        if (coeffStaticpRetour > 1 && currentStaticp > coeffStaticpRetour)
                        {
                            currentStaticp /= coeffStaticpRetour;
                            if (currentStaticp < 1)
                                currentStaticp = 1;
                        }
                        currentStaticm *= coeffStaticm;
                    }



                    // }
                    if (_nbSameDirectionBox > 0 && selectedByCoeff)
                        _nbSameDirectionBox--;
                    if (_nbSameDirectionBox < 0 && !selectedByCoeff)
                        _nbSameDirectionBox++;

                }
                else
                {
                    _nbAlt--;
                    _nbAltHisto = 0;


                    if (selectedByCoeff)
                    {
                        _nbSameDirectionBox--;
                        // _nbSameDirection--;
                        _nbElastique += coeffLot * coeffElastique1sm; // coeffElastique1* rapportmp;
                        _nbElastique2 += coeffLot * coeffElastique2sm; // coeffElastique2r* rapportmp;
                    }
                    else
                    {
                        _nbElastique += coeffElastique1sp;
                        _nbElastique2 += coeffElastique2sp;
                        _nbSameDirectionBox++;
                        // _nbSameDirection++;
                    }
                }

                //if (selectedByCoeff)
                //{
                //    _nbSameDirection -= getLimitedDelta(coeffElastique1dm, oldSameDirection); 
                //}
                //else
                //{
                //    _nbSameDirection++;
                //}
            }

            if (!auto)
                return false;

            var lastProduct = linkProduct;


            var c0 = v;
            //verifHaut();
            //verifBas();


            if (last.HasValue)
            {
                var aux = a;




                lastDelta = null;
                if (last != selectedByCoeff) // if (_nbAltHisto > 1)
                {
                    if (_nbAlt > serialAlt || _nbElastique2 < -serialElastique)
                    {
                        lastDelta = false;
                    }
                }
                else if (checkFall && selectedByCoeff)
                {
                }
                else
                {
                    bool applyanti = false;
                    // bof. pour l'instant seul currentStaticm est géré
                    if (selectedByCoeff)
                    {
                        if (coeffStaticpRetour > 1 && currentStaticp > coeffStaticpRetour)
                        {
                            currentStaticp /= coeffStaticpRetour;
                            if (currentStaticp < 1)
                                currentStaticp = 1;
                        }
                        currentStaticm *= coeffStaticm;

                    }
                    else if (coeffStaticRetourLarge)
                    {

                        if (currentStaticm > 1)
                        {
                            currentStaticm /= coeffStaticmRetour;
                            if (currentStaticm < 1)
                                currentStaticm = 1;
                        }

                        //if (coeffStaticmRetour > 1 && currentStaticm > coeffStaticmRetour)
                        //    currentStaticm /= coeffStaticmRetour;
                        currentStaticp *= coeffStaticp;
                    }

                    if (selectedByCoeff && -_nbSameDirectionBox > serialm)
                        applyanti = true;
                    else if (!selectedByCoeff && _nbSameDirectionBox > serialp)
                        applyanti = true;
                    else if (_nbElastique > serialElastique)
                        applyanti = true;
                    //else if (_nbElastique2 > serialElastique)
                    //    applyanti = true;

                    if (applyanti)
                        lastDelta = true;
                    else
                        lastDelta = null;
                    if (_linkconv)
                        calcConv();


                }



                bool onAugmente = lastDelta.HasValue && (lastDelta_ == null || lastDelta_ == lastDelta);
                if (onAugmente)
                {
                    a *= (1 + aa);
                    //verifHaut();
                    //verifBas();
                }
                else
                {
                    decimal ecart1 = System.Math.Max(_nbElastique, -_nbElastique2);


                    if (ecart1 > 0 && ecart1 < ecart0)
                    {
                        if (a > aepsilon)
                        {
                            a /= (1 + aa * coeffLot);
                            if (a < aepsilon)
                                a = aepsilon;
                        }

                        //verifHaut();
                        //verifBas();

                    }
                }

                //if (c0 == v || !onAugmente)
                //{

                //    var ecart1 = System.Math.Max(System.Math.Abs(_nbElastique), System.Math.Abs(_nbElastique2));
                //    if (ecart1 < ecart0)
                //    {
                //        a /= (1 + aa);
                //        if (a < aepsilon)
                //            a = aepsilon;

                //    }
                //}
                //else
                //{
                //    a *= (1 + aa);
                //    verifHaut();
                //    verifBas();

                //}


                // vv += pas * a;



                verifMaxA();

                if (lastDelta.HasValue)
                {
                    //verifMaxA();
                    if (false == lastDelta)
                    {
                        var _v = _v0 - pas * a;
                        var limit = _v0 / vv;
                        if (_v < limit)
                        {
                            _v = limit;
                            a = (_v0 - _v) / pas;
                        }
                        v = _v;

                        if (_linkconv)
                            calcConv();

                    }
                    else if (true == lastDelta)
                    {

                        var _v = _v0 + pas * a;
                        var limit = _v0 * vv;

                        if (_v > limit)
                        {
                            _v = limit;
                            a = (_v - _v0) / pas;
                        }

                        v = _v;
                    }

                    //  verifMaxV();
                    //verifHaut();
                    //verifBas();
                }


                verifMaxV();


                misc.log("convergence {0:0.##}->{1:0.######}", c0, v);
                misc.log("evol convergence {0:0.######}->{1:0.######}", aux, a);
            }

            string montee = selectedByCoeff ? "down" : "up";

            verifBas();
            var _rapportTmp = rapportmp;
            if (selectedByCoeff)
            {
                _rapportTmp = coeffLot * getLimitedDelta(_rapportTmp, oldSameDirection);
                //if (rapportmp > 1)
                //{
                //    if (oldSameDirection > rapportmp)
                //    {
                //        _rapportTmp = 2 * rapportmp - oldSameDirection;
                //        if (_rapportTmp < 1)
                //            _rapportTmp = 1;
                //    }
                //}

                coeffVirt -= pas * v * _rapportTmp / currentStaticp;
                _nbSameDirection -= _rapportTmp;
            }
            else
            {
                coeffVirt += pas * v / currentStaticm;
                _nbSameDirection++;
            }


            if (selectedByCoeff)
            {
                verifMaxA();
                verifMaxV();

                verifBas();
                coeffVirt = _c0 - pas * v * _rapportTmp / currentStaticp;
                verifBas();
            }




            //verifHaut();
            //verifBas();
            dx = Math.Abs(coeffVirt - _c0);
            if (_c0 > 0)
                dcoeff = 1 + dx / _c0;

            if (selectedByCoeff)
                dx /= _rapportTmp;


            dv = Math.Abs(v - _v0);
            if (dv == 0)
                dv = dv0 * (a / _a0);



            // da = Math.Abs(a - _a0);
            misc.log("{0} {1:0.### ###} {2:0.### ###}->{3:0.### ###}", montee, dx, c0, coeffVirt);


            histo.Add(new HistoValue(coeffVirt, dx, a, v / currentStaticm, dv, v));

            checkCoeffOld();

            if (coeffOldSwap)
            {
                coeffOld = coeffVirt;
                coeffVirt = coeffVirt0;
            }

            return dx != 0;
        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\auto\ConfMedianneVirt.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using Math = pdb.util.Math;
using StringBuilder = pdb.util.StringBuilder;

namespace pdb.gen.auto
{
    public partial class ConfMedianneVirt : TuningBase
    {
        [NonSerialized]
        const string PATH_DYN = "..\\dynamic";
        private string Path { get { return string.Format("{0}{1}", DIR_CONF, fdata); } }
        private string PathC { get { return string.Format("{0}{1}", DIR_CONF, fdatac); } }
        private string PathDiff { get { return string.Format("{0}{1}", DIR_CONF, fdiff); } }
        private string PathDiffTmp { get { return string.Format("{0}{1}", DIR_CONF, fdiffTmp); } }
        // private string PathLastFull { get { return string.Format("{0}{1}", DIR_CONF, flast); } }
        const string PATH_DYN_DIFF = "..\\dynamic_diff";


        const int NB_HISTO = 1000000;
        public int safe;
        public decimal coeffVirt = 1m;
        public double virtDelay = 1.0;



        public string name;


        /// <summary>
        /// lié au mode db
        /// </summary>
        public dbMode mode;
        /// <summary>
        /// fichier ou est consigné l'historique courant
        /// </summary>
        public string fdata;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique
        /// </summary>
        public string fdiff;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique en mode full en vue de la sauvegarfe
        /// </summary>
        public string fdiffTmp;
        ///// <summary>
        ///// fichier ou est consigné la dernière sauvegarde full de l'historique
        ///// </summary>
        //public string flast;
        /// <summary>
        /// Fichier historique compressé
        /// </summary>
        public string fdatac;

        public int indexDiff = 0;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        /// <summary>
        /// calcul du coeff en fonction du nombre de pistes
        /// </summary>
        public bool coeffVirtAuto;
        /// <summary>
        ///  calcul du coeff en fonction du nombre de pistes dans tous les cas
        /// </summary>
        public bool coeffVirtAutoAll;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;

        public int serialp = 1;
        public int serialm = 1;
        public int serialAlt = 1;
        public decimal serialElastique = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique1dm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique1dp = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique2dm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique2dp = 1m;






        /// <summary>
        /// Coeff appliqué à _nbElastique quand  pas chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique1sm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand pas chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique1sp = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand pas chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique2sm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand pas chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique2sp = 1m;


        //public decimal coeffElastique1 = 1m;
        //public decimal coeffElastique2 = 1m;

        //public decimal coeffElastique1r = 1m;
        //public decimal coeffElastique2r = 1m;

        /// <summary>
        /// pas de calcul
        /// </summary>
        public decimal pas = 0.1m;
        /// <summary>
        /// vitesse : augmentation ou diminution du coeff virtuel
        /// </summary>
        public decimal v;

        /// <summary>
        /// variation de la vitesse en proportion
        /// </summary>
        public decimal vv = 1.1m;

        ///// <summary>
        ///// Vitesse virtuelle : pour calculer l'accélaration en tenant compte des contraintes en simulant un augmentation. Mauvaise idée. toujours egal à v en cas de contrainte
        ///// </summary>
        //private decimal vv;
        /// <summary>
        /// borne visant à limiter le delta entre deux pas
        /// </summary>
        public decimal d0 = 0.01m;
        //  public decimal dcoeffm;


        /// <summary>
        /// accélération : augmentation ou diminution de la vitesse
        /// </summary>
        public decimal a;
        //public decimal a0 =0.01m;
        //public decimal dconvergence01;
        /// <summary>
        /// variation de l'accélération en proportion
        /// </summary>
        public decimal aa = 0.01m;
        /// <summary>
        ///accélaration plancher
        /// </summary>
        public decimal aepsilon = 0.001m;

        /// <summary>
        /// ecart min entre deux positions
        /// </summary>
        private decimal epsilon = 0.001m * 0.001m;
        /// <summary>
        /// ecart de vitesse entre deux positions
        /// </summary>
        private decimal vepsilon = 0.001m * 0.001m;

        private bool? lastDelta;
        private bool? lastAutoDirection;
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        private decimal _nbSameDirection;
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        private int _nbSameDirectionBox;
        /// <summary>
        /// nb allez/retour pour calcul
        /// </summary>
        private int _nbAlt;
        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique;

        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique2;
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        private int _nbAltHisto;

        /// <summary>
        /// Quand plusieurs montées consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticp = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticm = 1;

        /// <summary>
        /// Après plusieurs montées consécutives : retour au coeff nominal 
        /// </summary>
        private decimal coeffStaticpRetour = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : retour au coeff nominal 
        /// </summary>
        private decimal coeffStaticmRetour = 1;
        public decimal CoeffStaticmRetour { get { return coeffStaticmRetour; } }

        /// <summary>
        /// Retour mode large
        /// </summary>
        private bool coeffStaticRetourLarge;

        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des montées consécutives
        /// </summary>
        private decimal currentStaticp = 1;
        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des descentes consécutives
        /// </summary>
        private decimal currentStaticm = 1;
        public decimal CurrentStaticm { get { return currentStaticm; } }

        /// <summary>
        /// On gere spécifiquement le cas des descentes consécutives
        /// </summary>
        public bool checkFall;

        /// <summary>
        /// Rapport de vitesse négative / vitesse positive
        /// </summary>
        private decimal rapportmp = 1m;
        /// <summary>
        /// anti atténuation
        /// </summary>
        //public decimal danticonvergence = 1m;
        //public decimal danticonvergence0;
        //public decimal danticonvergence01;

        //public decimal danticonvdeltap = 1m;
        //public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        private List<HistoValue> histo = new List<HistoValue>();
        //  private List<decimal> histoDiff = new List<decimal>();

        private decimal coeffOld = 1m;

        public bool oldAsZero;
        private bool coeffOldAuto;
        public bool coeffOldSwap;
        public int coeffOldAutoLevel;
        private bool use;
        /// <summary>
        /// On mesure l'écart gagné. lot est le nombre min de rang pour prise en compte totale de la baisse
        /// </summary>
        private double lot=1.0;
        private decimal coeffLot = 1M;


        public bool Use { get { return use; } }

        public ConfMedianneVirt()
        { }

        public ConfMedianneVirt(ConfMedianneVirt o, bool raz)
            : this(o)
        {
            if (raz)
            {
                // safe = 0;
                coeffOld = 1;
                coeffVirt = 1;
            }
        }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            name = o.name;
            mode = o.mode;
            fdata = o.fdata;
            fdatac = o.fdatac;
            fdiff = o.fdiff;
            fdiffTmp = o.fdiffTmp;
            //  flast = o.flast;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAutoAll = o.coeffVirtAutoAll;

            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            //dcoeffp = o.dcoeffp;
            //dcoeffm = o.dcoeffm;
            //dconvergence = o.dconvergence;
            //dconvdeltap = o.dconvdeltap;
            //dconvdeltam = o.dconvdeltam;
            //danticonvergence = o.danticonvergence;
            //danticonvdeltap = o.danticonvdeltap;
            //danticonvdeltam = o.danticonvdeltam;

            pas = o.pas;
            v = o.v;
            d0 = o.d0;
            a = o.a;
            aa = o.aa;
            aepsilon = o.aepsilon;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            serialAlt = o.serialAlt;

            serialElastique = o.serialElastique;
            coeffElastique1dm = o.coeffElastique1dm;
            coeffElastique1dp = o.coeffElastique1dp;
            coeffElastique1sm = o.coeffElastique1sm;
            coeffElastique1sp = o.coeffElastique1sp;
            coeffElastique2dm = o.coeffElastique2dm;
            coeffElastique2dp = o.coeffElastique2dp;
            coeffElastique2sm = o.coeffElastique2sm;
            coeffElastique2sp = o.coeffElastique2sp;


            _nbSameDirection = o._nbSameDirection;
            _nbSameDirectionBox = o._nbSameDirectionBox;
            _nbAlt = o._nbAlt;
            _nbAltHisto = o._nbAltHisto;
            _nbElastique = o._nbElastique;
            _nbElastique2 = o._nbElastique2;

            coeffOld = o.coeffOld;
            coeffOldAuto = o.coeffOldAuto;
            coeffOldSwap = o.coeffOldSwap;
            oldAsZero = o.oldAsZero;
            coeffOldAutoLevel = o.coeffOldAutoLevel;
            epsilon = o.epsilon;

            //dconvergence0 = o.dconvergence0;
            //dconvergence01 = o.dconvergence01;
            //danticonvergence0 = o.danticonvergence0;
            //danticonvergence01 = o.danticonvergence01;

            lastDelta = o.lastDelta;
            use = o.use;
            coeffStaticRetourLarge = o.coeffStaticRetourLarge;
            this.checkFall = o.checkFall;
            this.virtDelay = o.virtDelay;
            this.lot = o.lot;
            this.coeffLot = o.coeffLot; 
            histo = new List<HistoValue>(o.histo);

        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var str = "";
            builds("mode", v => str = v);
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);
            builds("name", v => name = v);
            builds("fdata", v => fdata = v);
            builds("fdatac", v => fdatac = v);
            builds("fdiff", v => fdiff = v);
            builds("fdiffTmp", v => fdiffTmp = v);
            // builds("flast", v => flast = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAutoAll", v => coeffVirtAutoAll = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);

            builddec("pas", v => pas = v);
            builddec("v", vv => v = vv);
            builddec("dv", v => dv = v);
            builddec("d0", v => d0 = v);
            builddec("a", v => a = v);
            builddec("aa", v => aa = v);
            builddec("vepsilon", v => vepsilon = v);
            builddec("aepsilon", v => aepsilon = v);


            //builddec("dcoeffp", v => dcoeffp = v);
            //builddec("dcoeffm", v => dcoeffm = v);
            //builddec("dconvergence", v => dconvergence = v);
            //builddec("dconvergence0", v => dconvergence0 = v);
            //builddec("dconvergence01", v => dconvergence01 = v);
            //builddec("dconvdeltap", v => dconvdeltap = v);
            //builddec("dconvdeltam", v => dconvdeltam = v);

            //builddec("danticonvergence", v => danticonvergence = v);
            //builddec("danticonvergence0", v => danticonvergence0 = v);
            //builddec("danticonvergence01", v => danticonvergence01 = v);
            //builddec("danticonvdeltap", v => danticonvdeltap = v);
            //builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serialAlt", v => serialAlt = v);
            buildi("elastique", v => serialElastique = v);


            builddec("coeffElastique1dm", v => coeffElastique1dm = v);
            builddec("coeffElastique1dp", v => coeffElastique1dp = v);
            builddec("coeffElastique1sm", v => coeffElastique1sm = v);
            builddec("coeffElastique1sp", v => coeffElastique1sp = v);
            builddec("coeffElastique2dm", v => coeffElastique2dm = v);
            builddec("coeffElastique2dp", v => coeffElastique2dp = v);

            builddec("coeffElastique2sm", v => coeffElastique2sm = v);
            builddec("coeffElastique2sp", v => coeffElastique2sp = v);


            buildi("serial", v => _nbSameDirection = v);
            buildi("serialBox", v => _nbSameDirectionBox = v);
            buildi("serialAltC", v => _nbAlt = v);
            buildi("serialAltH", v => _nbAltHisto = v);
            builddec("elastiqueC", v => _nbElastique = v);
            builddec("elastiqueC2", v => _nbElastique2 = v);


            builddec("coeffOld", v => coeffOld = v);
            buildb("oldAsZero", v => oldAsZero = v);
            buildb("coeffOldAuto", v => coeffOldAuto = v);
            buildb("coeffOldSwap", v => coeffOldSwap = v);
            buildi("coeffOldAutoLevel", v => coeffOldAutoLevel = v);
            builddec("epsilon", v => epsilon = v);

            buildbn("lastDelta", v => lastDelta = v);

            builddec("coeffStaticp", v => coeffStaticp = v);
            builddec("coeffStaticm", v => coeffStaticm = v);

            builddec("coeffStaticpRetour", v => coeffStaticpRetour = v);
            builddec("coeffStaticmRetour", v => coeffStaticmRetour = v);
            buildb("coeffStaticRetourLarge", v => coeffStaticRetourLarge = v);


            builddec("currentStaticp", v => currentStaticp = v);
            builddec("currentStaticm", v => currentStaticm = v);
            builddec("rapportmp", v => rapportmp = v);

            buildb("use", v => use = v);
            buildb("checkFall", v => checkFall = v);
            buildd("virtDelay", v => virtDelay = v);

            buildd("lot", v => lot = v);
            builddec("coeffLot", v => coeffLot = v);


            HistoValue last = null;
            var xhisto = XMLTool.NodeLookUp(child, "histo");
            if (xhisto != null)
            {
                foreach (XmlElement sub in xhisto.ChildNodes)
                {
                    var _nevw = new HistoValue(sub.InnerText, last);
                    histo.Add(_nevw);
                    last = _nevw;
                }
            }
            else
            {

                if (File.Exists(Path))
                {
                    var lines = File.ReadAllLines(Path);
                    for (int i = 0; i < lines.GetLength(0); i++)
                    {
                        try
                        {
                            var line = lines[i];

                            if (string.IsNullOrEmpty(line))
                                continue;
                            var _nevw = new HistoValue(line, last);
                            histo.Add(_nevw);
                            last = _nevw;
                        }
                        catch (Exception ex)
                        {
                            misc.log(string.Format("impossible de lire la ligne n° {0}:{1}", i + 1, lines[i]), ex);
                            throw;
                        }
                    }
                    indexDiff = histo.Count;

                    //if (histo.Count >0 )
                    //    coeffVirt = getCoeff(histo[histo.Count -1]);


                }

                if (File.Exists(PathDiff))
                {
                    var histoDiff = new List<HistoValue>();
                    var lines = File.ReadAllLines(PathDiff);
                    for (int i = 0; i < lines.GetLength(0); i++)
                    {
                        try
                        {
                            var line = lines[i];
                            if (string.IsNullOrEmpty(line))
                                continue;

                            var _nevw = new HistoValue(line, last);
                            histoDiff.Add(_nevw);
                            last = _nevw;
                        }
                        catch (Exception ex)
                        {
                            misc.log(string.Format("impossible de lire la ligne n° {0}:{1}", i + 1, lines[i]), ex);
                            throw;
                        }

                    }

                    if (mode == dbMode.full)
                    {
                        histo.AddRange(histoDiff);
                        indexDiff = histo.Count;
                    }
                    else
                    {
                        indexDiff = histo.Count - histoDiff.Count;
                    }

                }



                if (mode == dbMode.full)
                {
                    PathDiff.Sov("0");                    
                }
                   

                if (histo.Count > 0)
                {
                    int index = histo.Count - 1;
                    decimal current = histo[index].coeff;
                    //coeffVirt = getCoeff(current);
                    bool? sens = null;

                    int nbSerie = 0;
                    // decimal delta = 0m;

                    var rr = 1;
                    //if (dcoeffp > 0)
                    //    rr = dcoeffm / dcoeffp;
                    if (rr > 0)
                    {
                        while (true)
                        {
                            index--;
                            if (index < 0)
                                break;
                            var aux = histo[index].coeff;
                            var _sens = current > aux;
                            if (sens == null)
                            {
                                sens = _sens;
                                lastAutoDirection = !_sens;

                                // delta = current - aux;
                            }


                            if (sens != _sens)
                                break;
                            current = aux;
                            nbSerie++;

                        }

                        //_nbSameDirection = nbSerie;
                        //dcoeffp = Math.Abs(delta); dcoeffm = dcoeffp * rr;

                    }
                }
            }

            checkCoeffOld();
            //if (histoDiff.Count > 0)
            //    coeffVirt = getCoeff(histo[histo.Count - 1]); 

        }



        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("name", name);
            write("mode", mode);
            write("use", use);
            write("serial", _nbSameDirection);
            write("elastiqueC", _nbElastique);
            write("elastiqueC2", _nbElastique2);

            write("coeffVirt", coeffVirt);
            write("coeffOld", coeffOld);
            write("serialBox", _nbSameDirectionBox);
            write("serialAltC", _nbAlt);
            write("serialAltH", _nbAltHisto);

            write("coeffStaticp", coeffStaticp);
            write("coeffStaticm", coeffStaticm);
            write("coeffStaticpRetour", coeffStaticpRetour);
            write("coeffStaticmRetour", coeffStaticmRetour);
            write("coeffStaticRetourLarge", coeffStaticRetourLarge);
            write("currentStaticp", currentStaticp);
            write("currentStaticm", currentStaticm);

            write("lastDelta", lastDelta);

            write("serialAlt", serialAlt);
            write("elastique", serialElastique);

            write("fdata", fdata);
            write("fdatac", fdatac);
            write("fdiff", fdiff);
            write("fdiffTmp", fdiffTmp);


            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAutoAll", coeffVirtAutoAll);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);

            write("pas", pas);
            write("v", v);
            write("dv", dv);
            write("d0", d0);
            write("a", a);
            write("aa", aa);
            write("aepsilon", aepsilon);
            write("vepsilon", vepsilon);
            write("rapportmp", rapportmp);

            //write("dcoeffp", dcoeffp);
            //write("dcoeffm", dcoeffm);
            //write("dconvergence", dconvergence);
            //write("dconvergence0", dconvergence0);
            //write("dconvergence01", dconvergence01);
            //write("dconvdeltap", dconvdeltap);
            //write("dconvdeltam", dconvdeltam);

            //write("danticonvergence", danticonvergence);
            //write("danticonvergence0", danticonvergence0);
            //write("danticonvergence01", danticonvergence01);
            //write("danticonvdeltap", danticonvdeltap);
            //write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);

            write("checkFall", checkFall);





            write("oldAsZero", oldAsZero);
            write("coeffOldAuto", coeffOldAuto);
            write("coeffOldSwap", coeffOldSwap);

            write("coeffOldAutoLevel", coeffOldAutoLevel);
            write("epsilon", epsilon);

            write("coeffElastique1dm", coeffElastique1dm);
            write("coeffElastique1dp", coeffElastique1dp);
            write("coeffElastique1sm", coeffElastique1sm);
            write("coeffElastique1sp", coeffElastique1sp);


            write("coeffElastique2dm", coeffElastique2dm);
            write("coeffElastique2dp", coeffElastique2dp);
            write("coeffElastique2sm", coeffElastique2sm);
            write("coeffElastique2sp", coeffElastique2sp);

            write("virtDelay", virtDelay);
            write("lot", lot);
            write("coeffLot", coeffLot);


            var sb = new StringBuilder();
            var sbDiff = new StringBuilder();
            var sbc = new StringBuilder();




            //if (modeDiff)
            //{
            //    histoDiff = null;
            //}
            //else
            //{
            //    if (histoDiff != null)
            //    {
            //        histo.AddRange(histoDiff);
            //        histoDiff = null;
            //    }

            //    if (File.Exists(PathDiff))
            //        File.Delete(PathDiff);
            //}

            int count = histo.Count;
            HistoValue last = null;
            for (int i = 0; i < count; i++)
            {
                histo[i].write(sb);
                histo[i].writeDiff(sbc, last);

                if (i >= indexDiff)
                    histo[i].writeDiff(sbDiff, last);

                last = histo[i];
            }


            if (!string.IsNullOrEmpty(fdata))
            {
                AsyncFileWriter.Instance.post(Path, sb.ToString());
                if (mode == dbMode.diff)
                    AsyncFileWriter.Instance.post(PathDiff, sbDiff.ToString());
                else
                    AsyncFileWriter.Instance.post(PathDiffTmp, sbDiff.ToString());


                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);
            }

            if (!string.IsNullOrEmpty(fdatac))
            {
                AsyncFileWriter.Instance.post(PathC, sbc.ToString());
            }


            writeEnd();
        }
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        public decimal Serial { get { return _nbSameDirection; } set { _nbSameDirection = value; } }
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        public int SerialBox { get { return _nbSameDirectionBox; } }
        /// <summary>
        /// nb allez-retours pour calcul
        /// </summary>
        public int Alt { get { return _nbAlt; } }
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        public int AltHisto { get { return _nbAltHisto; } }
        /// <summary>
        /// Position de l'élastique. Positif : tend à agrandir le delta. du à plusieurs séries dans le même sens. Négatif : tend à diminuer le delta. du à plusieurs allez-retours consécutifs
        /// </summary>
        public decimal Elastique { get { return _nbElastique; } }
        public decimal Elastique2 { get { return _nbElastique2; } }
        public decimal dv = 0;
        public decimal dx = 0m;
        public decimal dcoeff = 1;
        //  public decimal da;
        public decimal AccelerationRapport { get { return dv / epsilon; } }
        public decimal VitesseRapport { get { return dx / epsilon; } }
        public decimal danticonvergenceMin
        {
            get
            {
                return epsilon;
            }
        }




        public decimal CoeffOld
        {
            get { return coeffOld; }
            set { coeffOld = value; checkCoeffOld(); }
        }

        public bool CoeffOldAuto
        {
            get { return coeffOldAuto; }
            set { coeffOldAuto = value; checkCoeffOld(); }
        }

        //private decimal getCoeff(decimal coeffT) { return Math.Pow(coeffT, (1.0m / safe)); }


    }
}
]]></content>
  </file>
</db>
