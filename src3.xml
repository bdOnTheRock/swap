<db path="C:\bernard\db2\">
  <file path="buro\buroSimple\Walpaper.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using buroSimpleLib;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using System.Threading;
using System.Diagnostics;
using System.Windows.Forms;
using Microsoft.Win32;
using System.Drawing.Drawing2D;

namespace buroSimple
{
    class Walpaper
    {
        int HAUTEUR;
        int LARGEUR;
        const string TMP_FILE = @"C:\Temp\wp.bmp";
        const string TMP_FILE1 = @"C:\Temp\wp1.bmp";
        const string TMP_FILE2 = @"C:\Temp\wp2.bmp";
        const string INDEX_FILE = @"C:\Temp\wp.index.txt";
        const string TMP_LOADED = @"C:\Temp\Loaded";
        const string HISTO = @"C:\Temp\WP_HISTO\";

        /// <summary>
        /// delai en secondes entre deux refreh
        /// </summary>
        public double delay = 30;
        /// <summary>
        /// On ne prend qu'un exemplaire pour une taille donnée
        /// </summary>
        public bool unique = false;
        /// <summary>
        /// Try par taille
        /// </summary>
        public bool sortBySize = false;
        /// <summary>
        /// On considère suex fichiers de même taille et de même nom comme identiques
        /// </summary>
        public bool uniqueName = false;
        /// <summary>
        /// tri inversé
        /// </summary>
        public bool reverse = false;
        /// <summary>
        /// On tente de recreer une image à la taille de l'écran
        /// </summary>
        public bool fullscreen = false;
        /// <summary>
        /// On tente d'utiliser les valeurs &
        /// </summary>
        public bool highResolution = false;
        /// <summary>
        /// tri par pixel et taille
        /// </summary>
        public bool combine = false;
        /// <summary>
        /// Un seul grand écran 
        /// </summary>
        public bool oneScreen = false;

        private bool GO;
        public void go()
        {
            if (!Directory.Exists(HISTO))
                Directory.CreateDirectory(HISTO);
            GO = true;
            DirectoryInfo loaded = new DirectoryInfo(TMP_LOADED);
            if (!loaded.Exists)
                loaded.Create();


            SystemEvents.PowerModeChanged += new PowerModeChangedEventHandler(SystemEvents_PowerModeChanged);
            SystemEvents.SessionSwitch += SystemEvents_SessionSwitch;




            HAUTEUR = 1080;
            LARGEUR = 1920;
            var list = new List<FileDto>();
            using (StreamReader sr = new StreamReader(@"C:\Temp\buro1.txt"))
            {
                string line = "";
                while ((line = sr.ReadLine()) != null)
                {
                    if (string.IsNullOrEmpty(line))
                        continue;

                    try
                    {
                        FileDto fd = FileDto.FromLine(line); //  new FileDto() { Path = tab[0], Size = Convert.ToInt64(tab[1]) };
                        if (fd != null)
                            list.Add(fd);
                    }
                    catch
                    {
                    }

                }
            }

            list.Sort((x, y) =>
            {
                int cmp = 0;
                if (sortBySize)
                {
                    cmp = x.Size.CompareTo(y.Size);
                    if (cmp != 0)
                        return cmp;
                    if (combine)
                        cmp = x.Pixels().CompareTo(y.Pixels());
                    if (cmp != 0)
                        return cmp;
                    cmp = x.Width.CompareTo(y.Width);
                }
                else
                {
                    cmp = x.Pixels().CompareTo(y.Pixels());
                    if (cmp != 0)
                        return cmp;
                    cmp = x.Width.CompareTo(y.Width);
                    if (cmp != 0)
                        return cmp;
                    if (combine)
                        cmp = x.Size.CompareTo(y.Size);
                }

                if (cmp != 0)
                    return cmp;
                return x.Path.CompareTo(y.Path);
            });

            if (reverse)
                list.Reverse();

            int count = list.Count;

            string path0 = "";
            int index0 = 0;
            if (File.Exists(INDEX_FILE))
            {
                path0 = File.ReadAllText(INDEX_FILE).Trim();
            }

            if (!string.IsNullOrEmpty(path0))
            {
                for (int i = 0; i < count; i++)
                {
                    if (list[i].Path == path0)
                    {
                        index0 = i;
                        break;
                    }
                }
            }

            HashSet<string> hs = new HashSet<string>();
            int pixels = -1;
            int width = -1;
            long size = -1;
            int nbLoaded = 0;
            for (int i = index0 + 1; i < count; i++)
            {
                while (!GO)
                {
                    Thread.Sleep(1000);
                }

                while (currentSwitchSessionStatus != SessionSwitchReason.SessionLogon
                    && currentSwitchSessionStatus != SessionSwitchReason.SessionUnlock)
                {
                    Console.WriteLine("Pause reason " + currentSwitchSessionStatus);
                    Thread.Sleep(1000);
                }



                FileDto f = list[i];
                Console.WriteLine("candidat " + f);
                var fpixels = f.Pixels();
                var fwidth = f.Width;
                bool change = false;
                bool sizeChanged = f.Size > size;
                bool pixelChanged = fpixels > pixels || fwidth != width;

                if (combine)
                    change = sizeChanged || pixelChanged;
                else if (sortBySize)
                    change = sizeChanged;
                else
                    change = pixelChanged;
                if (change)
                {
                    hs.Clear();
                    size = f.Size;
                    width = f.Width;
                    if (fpixels > pixels)
                    {
                        if (pixels > 0)
                            File.Copy(INDEX_FILE, HISTO + pixels + "_wp.index.txt", true);
                        pixels = fpixels;
                    }
                    if (fwidth != width)
                        width = fwidth;
                    foreach (FileInfo fl in loaded.GetFiles())
                    {
                        fl.Delete();
                    }
                    nbLoaded = 0;
                }
                else
                {
                    if (unique)
                        continue;
                }
                string fileName = Path.GetFileName(f.Path);
                if (hs.Contains(fileName))
                    continue;
                bool errorFs = false;
                try
                {
                    Image img = null;
                    if (fullscreen)
                    {
                        try
                        {
                            img = createFileFs(f);
                        }
                        catch (Exception ex)
                        {
                            errorFs = true;
                            Console.WriteLine(ex.Message);
                        }
                    }
                    if (errorFs)
                        img = createFile(f);
                    if (img != null)
                    {
                        bool ok = true;
                        foreach (FileInfo fl in loaded.GetFiles())
                        {
                            if (ImageUtil.AreIdentical(img, fl.FullName))
                            {
                                ok = false;
                                break;
                            }
                        }
                        img.Dispose();

                        if (ok)
                        {
                            WinAPI.BmpLoad(TMP_FILE);
                            nbLoaded++;
                            File.Copy(TMP_FILE, loaded.FullName + "\\" + nbLoaded + ".bmp", true);
                            File.WriteAllText(INDEX_FILE, f.Path);
                            if (!errorFs)
                                Thread.Sleep((int)(delay * 1000.0));
                            else
                                Thread.Sleep((int)(Math.Min(1, delay) * 1000.0));
                            if (uniqueName)
                                hs.Add(fileName);

                            if (!errorFs)
                            {
                                while (ScreenUtil.isRecovered(TMP_FILE, oneScreen))
                                {
                                    Console.WriteLine("Pause reason Recovered");
                                    Thread.Sleep((int)(1000 * Math.Max(1, delay)));
                                }
                            }



                        }
                        else
                        {
                            Console.WriteLine("Identique " + f);
                            continue;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Blank " + f);
                        continue;
                    }

                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            }
        }
        private SessionSwitchReason currentSwitchSessionStatus = SessionSwitchReason.SessionLogon;
        private void SystemEvents_SessionSwitch(object sender, SessionSwitchEventArgs e)
        {
            Console.WriteLine("SystemEvents_SessionSwitch:" + e.Reason);
            currentSwitchSessionStatus = e.Reason;

        }

        void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)
        {
            Console.WriteLine("SystemEvents_PowerModeChanged:" + e.Mode.ToString());
            if (e.Mode == PowerModes.Resume)
                GO = true;
            else GO = false;
        }

        private void paramGr(Graphics graphics)
        {
            graphics.CompositingMode = CompositingMode.SourceCopy;
            graphics.CompositingQuality = CompositingQuality.AssumeLinear;
            graphics.InterpolationMode = InterpolationMode.NearestNeighbor;
            graphics.SmoothingMode = SmoothingMode.None;
            graphics.PixelOffsetMode = PixelOffsetMode.None;
        }

        private Image createFileFs(FileDto f)
        {
            Image img = Image.FromFile(f.Path);
            Bitmap bmp = new Bitmap(img.Width, img.Height);
            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.DrawImage(img, 0, 0);
            }

            img.Dispose();
            img = bmp;

            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}={1}x{2} {3} {4}", largeur0 * hauteur0, largeur0, hauteur0, f.HumanReadableSize, img.PixelFormat);

            double r0 = (double)HAUTEUR / (double)LARGEUR;
            double r = (double)hauteur0 / (double)largeur0;

            //facteur d'augmentation
            int scale = 1;

            //1. on teste blank
            int largeurTrame;
            int hauteurTrame;

            Bitmap trame;
            img.Save(TMP_FILE1, ImageFormat.Bmp);
            var imgVerif = ImageUtil.Scan(TMP_FILE1);
            if (imgVerif == null)
            {
                img.Dispose();
                return null;
            }

            imgVerif.Dispose();

            int l = largeur0;
            int h = hauteur0;
            //int l0 = l;
            //int h0 = h;
            ////Image currentImage = img;
            //while (true)
            //{
            //    l *= 2;
            //    if (l > LARGEUR)
            //        break;
            //    h *= 2;
            //    if (h > HAUTEUR)
            //        break;
            //    l0 = l;
            //    h0 = h;
            //}

            if (r > r0)
                scale = HAUTEUR / hauteur0;
            else
                scale = LARGEUR / largeur0;

            l *= scale;
            h *= scale;

            //l=l0; 
            //h=h0; 

            //var trameInter = new Bitmap(l, h, img.PixelFormat);
            //using (Graphics g = Graphics.FromImage(trameInter))
            //{
            //    paramGr(g);
            //    //int _xrec = (int)((LARGEUR - l) / 2.0);
            //    //int _yrec = (int)((HAUTEUR - h) / 2.0);
            //    //Rectangle _centré = new Rectangle(_xrec, _yrec, l, h);
            //    Rectangle rect = new Rectangle(0, 0, l, h);
            //    // g.DrawImageUnscaledAndClipped(img, _centré);
            //   // g.DrawImageUnscaledAndClipped(img, rect);
            // g.DrawImage(img, rect, 0,0, l,h, GraphicsUnit.Pixel); 
            // //    g.DrawImage(img, rect); 

            //  //  trameInter.Dispose();
            //    // img.Dispose();


            //   // return Image.FromFile(TMP_FILE);
            //}
            var trameInter = img;
            if (scale > 1)
            {
                trameInter = ImageUtil.Scale(img, scale);
            }

            trameInter.Save(TMP_FILE2, ImageFormat.Bmp);

            imgVerif = ImageUtil.Scan(TMP_FILE2);
            if (imgVerif == null)
            {
                img.Dispose();
                return null;
            }


            if (r > r0)
            {
                // image pas assez large --> ajout largeur



                hauteurTrame = HAUTEUR;
                largeurTrame = Convert.ToInt32(LARGEUR * r0 / r); //   Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = LARGEUR;
                hauteurTrame = Convert.ToInt32(HAUTEUR * r / r0);
            }

            trame = new Bitmap(LARGEUR, HAUTEUR);
            Graphics graphics = Graphics.FromImage(trame);
            paramGr(graphics);
            int xrec = (int)((LARGEUR - largeurTrame) / 2.0);
            int yrec = (int)((HAUTEUR - hauteurTrame) / 2.0);



            // var abort = new Image.GetThumbnailImageAbort(ThumbnailCallback);
            //var thumbnail = img.GetThumbnailImage(largeurTrame , hauteurTrame, abort, IntPtr.Zero);

            Rectangle centré = new Rectangle(xrec, yrec, largeurTrame, hauteurTrame);
            // graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);
            // Rectangle all = new Rectangle(0,0,LARGEUR, HAUTEUR); 
            //graphics.DrawImage(img, centré);
            graphics.DrawImageUnscaledAndClipped(trameInter, centré);
            trameInter.Dispose();
            //thumbnail.Save(TMP_FILE, ImageFormat.Bmp);

            //thumbnail.Dispose();
            // image.Dispose();

            trame.Save(TMP_FILE, ImageFormat.Bmp);


            trame.Dispose();
            // img.Dispose();
            graphics.Dispose();

            return Image.FromFile(TMP_FILE);

        }

        public bool ThumbnailCallback()
        {
            return false;
        }

        private Image createFile(FileDto f)
        {
            Image img = Image.FromFile(f.Path);

            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}={1}x{2} {3}", largeur0 * hauteur0, largeur0, hauteur0, f.HumanReadableSize);

            double r0 = (double)HAUTEUR / (double)LARGEUR;

            int largeurTrame;
            int hauteurTrame;

            double r = (double)hauteur0 / (double)largeur0;





            if (r > r0)
            {
                // image pas assez large --> ajout largeur

                hauteurTrame = hauteur0;
                largeurTrame = Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = largeur0;
                hauteurTrame = Convert.ToInt32((double)largeur0 * (double)r0);
            }
            Graphics graphics = null;
            Bitmap trame = null;
            if (highResolution)
                try
                {
                    trame = new Bitmap(largeurTrame, hauteurTrame, img.PixelFormat);
                    graphics = Graphics.FromImage(trame);
                }
                catch
                {
                    if (trame != null)
                        trame.Dispose();
                }
            if (graphics == null)
            {
                trame = new Bitmap(largeurTrame, hauteurTrame);
                graphics = Graphics.FromImage(trame);
            }

            paramGr(graphics);


            int xrec = (largeurTrame - largeur0) / 2;
            int yrec = (hauteurTrame - hauteur0) / 2;
            Rectangle centré = new Rectangle(xrec, yrec, largeur0, hauteur0);
            graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);


            trame.Save(TMP_FILE, ImageFormat.Bmp);
            trame.Dispose();
            img.Dispose();
            graphics.Dispose();

            // verif
            var imgVerif = ImageUtil.Scan(TMP_FILE);
            return imgVerif;

            //using (Bitmap fs = new Bitmap(LARGEUR, HAUTEUR))
            //{
            //    Image i0 = null;
            //    Image i1 = null;
            //    using (var g = Graphics.FromImage(fs))
            //    {

            //        if (File.Exists(TMP_FILE))
            //        {
            //            i0 = Image.FromFile(TMP_FILE);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }

            //        if (File.Exists(TMP_FILE1))
            //        {
            //            i1 = Image.FromFile(TMP_FILE1);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }
            //    }
            //    fs.Save(TMP_FILE, ImageFormat.Bmp);
            //    if (i0 != null)
            //        i0.Dispose();
            //    if (i1 != null)
            //        i1.Dispose();
            //}
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimpleSearch\Program.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util.ordo;
using buroSimpleLib;
using System.IO;
using System.Drawing;
using System.Threading;
using pdb.util;
using System.Configuration;
using System.Drawing.Imaging;

namespace buroSimpleSearch
{
    class Program
    {
        static List<FileDto> list = new List<FileDto>();
        static HashSet<string> imageType = new HashSet<string> { "bmp", "gif", "ico", "jpeg", "jpg", "jpe", "png", "svg", "tif", "tiff" };
        static HashSet<string> noImageType = new HashSet<string>();

        static listCandidat imageCandidat = new listCandidat();
        static listCandidat NoImageCandidat = new listCandidat();
        static volatile object _lock = new object();
        static int LEVEL_MIN = 0;

        static void Main(string[] args)
        {
            Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);
            new Program().go();
        }

        static Ordonnanceur ordo;
        static StreamWriter sw = new StreamWriter(FileDto.PATH);
        void go()
        {
            // Scan(@"H:\spacer.gif");
            //  Scan(@"C:\temp\wp.bmp");
            //Scan(@"H:\noir.png");
            //Scan(@"H:\blanc.png");
            //Scan(@"H:\bleu.png");
            //Scan(@"H:\rouge.png");
            //Scan(@"H:\vert.png");


            //Scan(@"C:\apps\oracle\11.2.0.3\client-32\uix\cabo\images\bltdscn.gif");
            //Scan(@"C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\VCWizards\AppWiz\Generic\CustomWizard\Templates\1033\spacer.gif");

            var _nbProc = ConfigurationManager.AppSettings["nbProc"];
            int nbProc = 3;
            if (!string.IsNullOrEmpty(_nbProc))
                nbProc = Convert.ToInt32(_nbProc);
            ordo = new Ordonnanceur(nbProc);

            var paths = ConfigurationManager.AppSettings["paths"];
            if (string.IsNullOrEmpty(paths))
                paths = @"C:\";
            var tab = paths.Split(';');
            foreach (string path in tab)
            {
                if (string.IsNullOrEmpty(path))
                    continue;
                ordo.addTask(new TaskDir(ordo, new DirectoryInfo(path)));
            }
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"C:\")));
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"E:\")));
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"I:\")));
            while (ordo.Busy)
                Thread.Sleep(30);
            sw.Flush();
            sw.Dispose();

            Console.WriteLine("fin"); 
            Console.Read(); 
        }

        private class TaskDir : Task
        {
            private DirectoryInfo dir;
            public TaskDir(Ordonnanceur ordo, DirectoryInfo dir)
                : base(ordo)
            {
                this.dir = dir;
            }

            protected override void action()
            {
                //   ConsoleLogger.log(dir.FullName);
                List<FileDto> aux = null;
                foreach (FileInfo f in dir.GetFiles())
                {
                    // ConsoleLogger.log("check " + f.FullName);
                    FileDto fd = check(f);
                    if (fd != null)
                    {
                        ConsoleLogger.log(fd.ToStringSearch());
                        if (aux == null)
                            aux = new List<FileDto>();
                        aux.Add(fd);
                    }
                }
                if (aux != null)
                {
                    lock (_lock)
                    {
                        foreach (FileDto fd in aux)
                        {
                            fd.appendToDb(sw);
                        }
                        sw.Flush(); 
                    }
                }
                //ConsoleLogger.log("fin " +dir.FullName);
                done = true;

                foreach (DirectoryInfo sub in dir.GetDirectories())
                {
                    ordo.addsubTask(new TaskDir(ordo, sub));
                }
            }



            public override string ToString()
            {
                return dir.FullName;
            }
        }

        private class candidat
        {
            public candidat(String ext) { this.ext = ext; }
            private String ext;
            private int note = 0;
            public void increment()
            {
                note++;
            }
            public bool Accepted { get { return note >= 10; } }
        }
        private class listCandidat
        {
            private IDictionary<String, candidat> list = new Dictionary<String, candidat>();

            public bool record(String ext)
            {
                candidat cand;
                if (!list.ContainsKey(ext))
                {
                    cand = new candidat(ext);
                    list.Add(ext, cand);
                }
                cand = list[ext];
                cand.increment();
                return cand.Accepted;
            }
        }

        //static public Image Scan(string file)
        //{
        //   return ImageUtil.Scan(file); 
        //}

        static FileDto check(FileInfo f)
        {
            var file = f.FullName;
            //  Console.WriteLine(file.FullName);
            var ext = Path.GetExtension(file).ToLower().Replace(".", "");
            if (noImageType.Contains(ext)) return null;



            Image img;
            FileDto fdto = null;
            try
            {
                img = Image.FromFile(file);
                if (img != null)
                    fdto = new FileDto() { Path = file, Size = f.Length, Height = img.Height, Width = img.Width };

                img.Dispose();
            }
            catch (Exception)
            {
                fdto = null;
            }

            if (ext != null && ext.Length > 1)
            {
                if (!imageType.Contains(ext))
                {
                    ConsoleLogger.log("TYPE:" + ext + " " + file + " " + fdto);
                    if (fdto != null)
                    {
                        lock (imageCandidat)
                        {
                            if (imageCandidat.record(ext))
                            {
                                imageType.Add(ext);
                                ConsoleLogger.log("TYPE OK!!:" + ext + " " + file);
                            }
                        }

                    }
                    else
                    {
                        lock (NoImageCandidat)
                        {
                            if (NoImageCandidat.record(ext))
                            {
                                noImageType.Add(ext);
                                ConsoleLogger.log("TYPE NOK!!:" + ext + " " + file);
                            }
                        }
                        return null;
                    }
                }

            }
            return fdto;




        }

        static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {

            sw.Dispose();
        }

        static void write()
        {
            using (StreamWriter sw = new StreamWriter(FileDto.PATH))
            {
                foreach (FileDto f in list)
                {
                    sw.Write(f.Path);
                    sw.Write(";");
                    sw.WriteLine(f.Size);
                }
            }
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Dedoubler.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.IO;

namespace pdb.podcast
{
    class Dedoubler
    {
        static Logger logger = Logger.getLogger("Doublons");
        int nb = 0;
        long size = 0;
        Dictionary<string, List<TrackInfoItunes>> albums = new Dictionary<string, List<TrackInfoItunes>>();

        public int NbDoublons { get { return nb; } }
        public long Size { get { return size; } }
        public void checkDoublons(IEnumerable<TrackInfoItunes> list)
        {
            var l = new List<TrackInfoItunes>(list);
            l.Sort(new PodCastComparer());

            DateTime dt = DateTime.MinValue;
            TrackInfoItunes current = null;
            List<TrackInfoItunes> currentColl = new List<TrackInfoItunes>();


            foreach (TrackInfoItunes t in l)
            {
                if (t.HasParent)
                    continue;
                var _t = t.Pub.truncateToMinute();
                if (current == null || _t > dt)
                {
                    current = t;
                    dt = _t;
                    checkColl(currentColl);
                    currentColl.Clear();
                }
                if (_t.Hour > 0 || _t.Minute > 0)
                    currentColl.Add(t);
            }
            checkColl(currentColl);
            logger.log("{0} doublons, size:{1}", nb, FileUtil.HumanReadableSize(size, 1));

            logger.log("*************************************");
            logger.log("******* Par albums ******************");
            logger.log("*************************************");

            foreach (string album in albums.Keys)
            {
                logger.log("------- " + album + " -------");
                var a = albums[album];
                string parentAlbum = "";
                string dirParent = "";
                foreach (TrackInfoItunes t in a)
                {
                    var parent = t.Parent;
                    var _pAlbum = parent.Album;
                    var _dirParent = Path.GetDirectoryName(parent.Location);

                    if (_pAlbum != parentAlbum || _dirParent != dirParent)
                    {
                        logger.log("parent:{0}|{1}|{2}", parent.Album, parent.LogicalName, parent.Location);
                        parentAlbum = _pAlbum;
                        dirParent = _dirParent;
                    }
                    logger.log("doublon:{0}|{1}|{2}", t.Album, t.LogicalName, t.Location);

                }
            }


        }

        private class TrackCmp : IComparer<TrackInfoItunes>
        {
            public int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                var cmp = x.TrackAlbum.Count.CompareTo(y.TrackAlbum.Count);
                if (cmp != 0)
                    return cmp;
                var dir1 = Path.GetDirectoryName(x.Location);
                var dir2 = Path.GetDirectoryName(y.Location);
                cmp = dir1.Length.CompareTo(dir2.Length);
                if (cmp != 0)
                    return cmp;
                cmp = dir1.CompareTo(dir2);
                if (cmp != 0)
                    return cmp;
                cmp = x.Location.Length.CompareTo(y.Location.Length);
                if (cmp != 0)
                    return cmp;
                return x.Location.CompareTo(y.Location);
            }
        }

        private void checkColl(List<TrackInfoItunes> coll)
        {
            int count = coll.Count;
            if (count <= 1)
                return;

            coll.Sort(new TrackCmp());
            TrackInfoItunes parent = coll[0];
            var dureeP = parent.Duree.TotalMinute;
            string parentName = parent.LogicalName;
            bool parentLog = false;

            for (int i = 1; i < count; i++)
            {
                TrackInfoItunes t = coll[i];
                //if (t.TrackAlbum == parent.TrackAlbum)
                //    continue;
                var duree = t.Duree.TotalMinute;
                var coeff = duree / dureeP;
                if (t.LogicalName.Equals(parentName, StringComparison.InvariantCultureIgnoreCase))
                {
                    if (System.Math.Abs(duree - dureeP) < 0.5 && (coeff > 0.98 && coeff < 1.02))
                    {
                        if (t.HasParent)
                            throw new ArgumentException("t est déjà apparenté");
                        if (!parentLog)
                        {
                            parentLog = true;
                            logger.log("parent:{0}|{1}|{2}", parent.Album, parent.LogicalName, parent.Location);
                        }
                        logger.log("doublon:{0}|{1}|{2}", t.Album, t.LogicalName, t.Location);

                        if (!albums.ContainsKey(t.Album))
                            albums.Add(t.Album, new List<TrackInfoItunes>());
                        albums[t.Album].Add(t);

                        t.Parent = parent;
                        size += t.Size;
                        nb++;
                    }
                }
            }
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.iit;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Albums;
using pdb.podcast.Auto;
using pdb.podcast.Delta;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Sort;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;
using PlayList = pdb.it.PlayList;
using pdb.podcast.Date0;
using pdb.podcast.Notes;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static ILoader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto;
        static int step = -1;
        static Program _instance = new Program();
        // static bool calculRoots = false;
        static List<HashSet<int>> lists = null;
        static AlbumMgr albumMgr = AlbumMgr.Instance;

        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        public static Chrono chrono = new Chrono();
        private static Logger logChrono;
        private static DB.Db db;
        static Hibernator hibernator = new Hibernator();

        //public static DB.Db Db { get { return db; } }


        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {
            Logger.init(Environment.CurrentDirectory.Replace("\\", "_") + string.Join("_", args));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono", true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true;

            FileRegister.init(new Dictionary<string, FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true;

                loader.saveIds();
                //if (db != null)
                //    db.write();

                if (db != null)
                {
                    while (db.Writing)
                    {
                        misc.log("waiting db writing");
                        Thread.Sleep(1000);
                    }
                }
                Console.WriteLine("\nFin de l'opération d'enregistrement.");

                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();

                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Memory.End();
                Exporter.Abort();



                //if (_writeDb != null)
                //{
                //    misc.log("attente writeDb");
                //    _writeDb.Wait();
                //}
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                if (db != null)
                    db.write();
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}

        #region Task


        private List<ITrackInfoItunes> loadTracks(bool firstStep, bool forceLoad)
        {
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
            loader.loadTracks(firstStep, forceLoad, listTrack);

            return listTrack;

        }
        #endregion


        private static void SyncDb(List<TrackInfoItunes> list, bool checkInOut)
        {
            if (db == null)
                return;
            log.log("SyncDb checkInOut= " + checkInOut);
            foreach (TrackInfoItunes t in list)
            {
                if (checkInOut)
                    t.checkInOut();
                var tdb = db.get(t);
                if (tdb == null)
                {
                    log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                    continue;
                }
                tdb.synch(t);

            }
            log.log("Fin SyncDb checkInOut= " + checkInOut);

        }

        public void go(string[] args)
        {
            //  TrackInfoItunes.AlbumMgr = albumMgr;
            //int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            //if (countArgs > 0)
            //    confFile = args[0];
            bool _fin = false;

            bool modeDownLoad = false;
            foreach (string v in args)
            {
                if ("-download".Equals(v))
                {
                    modeDownLoad = true;
                    log.log("mode download");
                }
            }

            Album.logDebug = Logger.getLogger("pubDebug", false);
            Album.log = Logger.getLogger("pub2", Album.logDebug, true);
            Album.logDebug.NoReset = true;
            Album.log.NoReset = true;

            DateRefBuilder dateRefBuilder = new DateRefBuilder();
            try
            {

                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start(60);

                // bool firstLoad = true;


                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                // TrackInfoItunes.setDate0(Conf.Date0);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                //TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                TrackInfoItunes.PlayedLevel = Conf.DateLevel;
                var itConf = new pdb.it.Conf(xelt);

                // loader = new Loader(itConf, true);
                bool import = Conf.Import.enabled || Conf.Import.merge;
                db = new DB.Db();


                if (Conf.UseMock)
                    loader = new MockLoader(itConf.DefaultFolder);
                else
                    loader = new Loader(itConf, import, db,
                        () =>
                        {
                            misc.Pre = "[Load " + step + "] ";

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.AbortSpecial();
                            //   Thread.Sleep(1000); 
                            //  BackGroundTaskMgr.Start(); 
                        }, Conf.OnlyEnabled, Conf.OnlyUnRead)

                   ;
                // loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder;

                db.load();
                //  db.write(); return; 


                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();

                List<TrackInfoItunes> listIt = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);




                bool firstlaunched = false;
                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}"));
                        chrono.reset("Program");

                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.setConf(xelt);
                        //loader.Conf = new it.Conf(xelt);
                        // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut", true);
                        List<TrackInfoItunes> list = null;
                        DirConf root = null;
                        if (step == 0 || !Conf.Simulation)
                        {
                            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();



                            listTrack = loadTracks(step == 0, AutoBuilder.MustUpdate);


                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();

                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            // listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {

                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                // loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            //    loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            listIt = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            // GroupStat trackStat = new GroupStat();

                            loader.saveIds();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location)) // || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }
                                    FileRegister.Push(location);
                                    dictLoc[t.Location] = t;
                                    listIt.Add(t);
                                    // if (!t.Played)
                                    //    trackStat.recordTrack(t, typeState.all);
                                    //trackStat.recordTrack(t, typeState.all);
                                }
                            }



                            db.recordIt(listIt);
                            chrono.bip("loadTracks", true);
                            var dedoubler = new Dedoubler();
                            dedoubler.checkDoublons(db.Tracks);                            
                            chrono.bip("Dedoubler", true);

                            if (dedoubler.NbDoublons>0)
                            {
                                db.write(); 
                            }

                            Download.Downloader downloader = null;
                            if (modeDownLoad)
                            {
                                //new Thread(() => loader.updatePocasts()).Start();
                                downloader = new Download.Downloader(db);
                                downloader.go();

                                loader.loadTrackToDownload(downloader.ToDownload);
                                return;
                            }



                            // ici on peut faire la verification des doublons - track hibernés et re-téléchargés par ce con d'itunes
                            using (var albumConsolid = new AlbumConsolid())
                            {
                                foreach (TrackAlbum album in albumMgr.List)
                                {
                                    albumConsolid.consolid(album);
                                }
                            }

                            log.log("nb123={0} nb12={1} nb13={2} nb23={3} nb1={4} nb2={5} nb3={6} nb0={7}, nb3n={8}",
                                AlbumConsolid.nb123, AlbumConsolid.nb12, AlbumConsolid.nb13, AlbumConsolid.nb23,
                                AlbumConsolid.nb1, AlbumConsolid.nb2, AlbumConsolid.nb3, AlbumConsolid.nb0, AlbumConsolid.nb3n);

                            var scan = Conf.Scan;
                            if (!string.IsNullOrEmpty(scan))
                            {
                                var s = new Scanneur(scan, loader as Loader, db);
                                s.Scan();
                                db.write();
                                return;
                            }
                            root = Conf.DirConf;
                            var feeds = root.Feeds;

                            if (Conf.Freewheel)
                            {
                                PlayList.StartOpe();
                                Freewheel(root);
                                log.log("Freewheel : fin sans enregistrement DB");
                                return;
                            }



                            if (Conf.Import.enabled)
                            {
                                var listImport = new List<TrackInfoItunes>();
                                hibernator.select(Conf.Import, listImport, db.Tracks, true);

                                foreach (TrackInfoItunes tdb in listImport)
                                {
                                    loader.import(tdb);
                                }
                            }
                            else if (Conf.Import.merge)
                            {
                                foreach (TrackInfoItunes t in listIt)
                                    loader.merge(t);
                            }



                            list = db.Tracks;
                            foreach (TrackInfoItunes track in list)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds", true);


                            var loaded = feeds.Loaded;
                            loaded.Sort(new PodCastComparer());

                            bool changeDate = false;
                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            {
                                dateRefBuilder.prepare(loaded);

                            }

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);



                            if (Conf.Sort.selectionBefore)
                            {



                                //***************** Lancement "pour de vrai" ***************************************

                                LimitItemLoader.ModeSelection = true;

                                loadCandidat(root);
                                chrono.bip("loadCandidat(root)");
                                //  AutoBuilder.test(); 
                                // standAlone(root); 
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root)");
                                //**********************************************************************************


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, true);
                                //****************************************


                            }



                            if (Conf.Sort.checkBefore)
                            {
                                Album.Init();
                                var sorter = new Sorter(Conf.Sort, list);
                                sorter.build();
                                chrono.bip("sorter.build();", true);


                                changeDate = dateRefBuilder.autoSafe(loaded);
                                //TrackInfoItunes.setDate0(Conf.Date0);
                                double offsetIni = dateRefBuilder.getOffset();
                                AutoBuilder.Offset = offsetIni;

                                if (Album.NbRepeches > 0 && !Conf.DateRef.auto)
                                {
                                    log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                    _fin = true;
                                }
                            }

                            dateRefBuilder.saveCurrent();
                            ContexteBuilder.Instance.init(loaded);
                            Conf.DateRef.contexte = ContexteBuilder.Instance.Debut;

                            if (Conf.Import.enabled || Conf.Import.merge)
                            {
                                _fin = true;

                            }



                            if (_fin)
                            {
                                log.log("fin sans enregistrement DB");
                                //  db.write();


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, false);
                                //****************************************
                                return;
                            }


                            if (Album.NbModif > 0)
                            {
                                resetLoad(root);

                            }
                            //bool changeDate = false;
                            //if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            //{
                            //    changeDate = dateRefBuilder.auto(loaded);
                            //    TrackInfoItunes.setDate0(Conf.Date0);
                            //    double offsetIni = dateRefBuilder.getOffset();
                            //    AutoBuilder.Offset = offsetIni;
                            //}
                            AutoBuilder.init(true);
                            if (Conf.Sort.stopOnOffset && changeDate)
                            {
                                log.log("fin cause stopOnOffset");
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                                return;
                            }

                            if (Conf.Sort.stopOnPub2 && Album.NbModifPertinent > 0)
                            {
                                log.log("fin cause stopOnPub2");
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                                return;
                            }

                            AutoBuilder.Offset = 0;
                            chrono.bip("AutoBuilder.init(true)");
                            xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            loader.setConf(xelt);

                            //ContexteBuilder.Instance.init(loaded);

                            //Conf.DateRef.contexte = ContexteBuilder.Instance.Debut;
                            //   dateRefBuilder.saveCurrent();



                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            //trackStat.report(descTrack);
                            //log.log(descTrack.ToString());

                            //var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            //var trackFile = DescBuilder.create("Tracks", sbT);
                            //trackStat.report(trackFile);
                            //sbT.Flush();

                            //asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            //chrono.bip("desc tracks", true);
                            //Logger.LogConsole = false;
                            //        loader.loadLists();
                            Logger.LogConsole = true;
                            chrono.bip("load list", true);

                        }
                        list = db.Tracks;


                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program");
                            root = Conf.DirConf;
                            var feeds = root.Feeds;
                            foreach (TrackInfoItunes track in feeds.getSelectedTracks())
                            {
                                track.clearLists();
                            }

                            feeds.clearSelectedTracks();

                            chrono.bip("track.clearLists", true);

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;




                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true;
                            AutoBuilder.init(true);
                            chrono.bip("AutoBuilder.init(true)");
                            loadCandidat(root);
                            chrono.bip("loadCandidat(root)");
                            //  AutoBuilder.test(); 
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            chrono.bip("Selection(root)");
                            //**********************************************************************************

                            Album.Init();

                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.reset ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.once ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.white ||
                                (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all && !firstlaunched))
                            {
                                if (Sorter.NbLaunch == 0 || (Conf.Sort.enabled != Tuning.Sort.sortMode.white && Conf.Sort.enabled != Tuning.Sort.sortMode.once))
                                {
                                    var sorter = new Sorter(Conf.Sort, list);
                                    sorter.build();
                                }
                                _fin = Conf.Sort.enabled == Tuning.Sort.sortMode.white || Conf.Sort.enabled == Tuning.Sort.sortMode.reset;
                                if (!_fin && Album.NbModif > 0)
                                    resetLoad(root);
                            }

                            firstlaunched = true;

                            if (Album.NbRepeches > 0)
                            {
                                log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                _fin = true;
                            }



                            if (!_fin) // && Album.NbModif == 0)
                            {

                                //***************** Lancement "pour de faux" ***************************************
                                AutoBuilder.Init3();
                                chrono.bip("AutoBuilder.Init3()");
                                LimitItemLoader.ModeSelection = false;
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root) 2");
                                LimitItemLoader.ModeSelection = true;
                                //**********************************************************************************
                            }
                            Exporter.TopCopy();
                            chrono.bip("selection");




                            // Conf.date00Consume();
                            // TrackInfoItunes.setDate0(Conf.Date0);

                            int iii = 0;
                            while (!BackGroundTaskMgr.ConfirmEnd(10))
                            {
                                iii++;
                                if (iii == 60)
                                    iii = 0;
                                if (iii == 0)
                                {
                                    log.log("Attente Classement");
                                }
                                Thread.Sleep(100);
                            }






                            if (_fin || Album.NbModif > 0)
                            {
                                log.log("{0} éléments ont la Pub2 modifiée", Album.NbModif);

                                //foreach (TrackInfoItunes t in list)
                                //{
                                //    var tdb = db.get(t);
                                //    if (tdb == null)
                                //    {
                                //        log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                //        continue;
                                //    }
                                //    tdb.synch(t);

                                //}



                                if (_fin)
                                {
                                    SyncDb(list, true);
                                    db.writeAsync();
                                    log.log("fin");
                                    return;
                                }
                                // continue;
                            }




                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    //if (count == 1)
                                    //    s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu");

                            if (Conf.GenFeed)
                            {
                                foreach (RootItItem rootItem in Conf.RootIt)
                                {
                                    var fAuto = loader.TreePlayList.getComposite(rootItem.name);
                                    var fFeeds = fAuto.getComposite("Feed");

                                    if (fFeeds != null)
                                    {
                                        scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                    }

                                }
                            }


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root, false);
                            //****************************************



                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                            //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            chrono.bip("AutoBuilder.init(false)");
                            bool cangoAuto = AutoBuilder.Check(feeds);

                            chrono.bip("AutoBuilder");
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");

                                postReport(root, true);

                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false;
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true;
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                //  tw = new StringBuilder();
                                //feeds.rapportPreSelected(tw);
                                //asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false;
                                log.log(sb2.ToString());
                                Logger.LogConsole = true;


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false;
                                log.log(sb3.ToString());
                                Logger.LogConsole = true;
                                chrono.bip("rapport", true);
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 



                        SyncDb(list, true);
                        db.writeAsync();


                        Logger.CreateNullLoggers = false;

                        int nbH = 0;
                        _fin = false;
                        if (Conf.Hibernate.enabled)
                        {
                            nbH = hibernator.go(loader, list);
                            if (nbH > 0)
                            {
                                log.log("{0} elements hibernés", nbH);
                                _fin = true;
                            }
                        }

                        lists = null;
                        WritePlayList(root);




                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;

                            Dictionary<string, Dictionary<int, TrackInfoItunes>> depots = new Dictionary<string, Dictionary<int, TrackInfoItunes>>();
                            foreach (SelectParam p in listP)
                            {

                                listS = new List<TrackInfoItunes>();
                                if (!string.IsNullOrEmpty(p.name))
                                {
                                    // Compatibilité anciennes listes
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                    buildList("_" + p.level, listS, prior, folder);
                                }
                                else
                                {

                                    var pp = p.Clone() as SelectParam;
                                    feeds.buildFirstSelectedTrackLevel(listS, p);

                                    var l = new List<TrackInfoItunes>();

                                    pp.nb = int.MaxValue;
                                    var selector = new TrackSelector(pp);
                                    foreach (TrackInfoItunes t in listS)
                                    {
                                        if (selector.select(t))
                                            l.Add(t);
                                    }

                                    string path = p.path;
                                    if (!string.IsNullOrWhiteSpace(path))
                                        buildList(path, l, prior);

                                    string[] _depots = p.depot;
                                    if (_depots != null)
                                    {
                                        foreach (string depot in _depots)
                                        {
                                            if (!depots.ContainsKey(depot))
                                                depots.Add(depot, new Dictionary<int, TrackInfoItunes>());

                                            var dep = depots[depot];
                                            foreach (TrackInfoItunes t in l)
                                            {
                                                if (!dep.ContainsKey(t.DbId))
                                                    dep.Add(t.DbId, t);
                                            }
                                        }
                                    }
                                }
                            }

                            foreach (KeyValuePair<string, Dictionary<int, TrackInfoItunes>> kvp in depots)
                            {
                                string path = kvp.Key;

                                var l = new List<TrackInfoItunes>(kvp.Value.Values);
                                l.Sort(new PodcastComparerPubPub2());
                                buildList(path, l, prior);
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);

                        var listSelected = root.Feeds.getSelectedTracks();

                        var sorterafter = new Sorter(Conf.Sort, list);
                        //    sorter.build();

                        foreach (TrackInfoItunes s in listSelected)
                        {
                            s.updateNative();
                        }






                        //if (Conf.Hibernate.enabled)
                        //{
                        //    Hibernator hibernator = new Hibernator();
                        //    var nb = hibernator.go(loader); 
                        //    if (nb >0)
                        //    {
                        //        misc.log("{0} elements hibernés", nb);
                        //        misc.log("fin ");
                        //        return; 
                        //    }

                        //}


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                log.log("Attente Classement");
                            }
                            Thread.Sleep(100);
                        }



                        //if (Conf.Sort.enabled >= Tuning.Sort.sortMode.once_all)
                        //{
                        //    var sorter = new Sorter(Conf.Sort, list);
                        //    sorter.build();
                        //}

                        if (Conf.Hibernate.enabled)
                        {
                            hibernator.doH();
                        }

                        if (loader.NbTrackCreated > 0)
                        {
                            log.log("{0} éléments ont été recréés", loader.NbTrackCreated);
                            _fin = true;
                        }

                        if (Album.NbRepeches > 0)
                        {
                            log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                            _fin = true;
                        }



                        if (Conf.UseMock)
                            _fin = true;



                        if (_fin)
                        {


                            log.log("fin");

                            return;
                        }





                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");



                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in db.Tracks)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogAll(ex.ToString());
                        misc.log(ex.ToString());
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        //private DirConf _attenteWriteHtml;
        // private volatile object _lockReportHtml = new object();
        private bool _end;
        // ThreadUtil thReport;
        DateTime lastReport;

        private void postReport(DirConf dir, bool force)
        {
            if (force || lastReport.AddSeconds(10) < DateTime.Now)
            {
                try
                {
                    reportHtml(dir);
                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                lastReport = DateTime.Now;
            }
            //if (thReport == null)
            //{
            //    lock (_lockReportHtml)
            //    {
            //        if (thReport == null)
            //        {
            //            thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
            //            thReport.Start();
            //        }
            //    }
            //}

            //lock (_lockReportHtml)
            //    _attenteWriteHtml = dir;
        }

        //private void loopReportHtml()
        //{
        //    DirConf traite = null;
        //    while (!_end)
        //    {
        //        Thread.Sleep(1000);
        //        if (_attenteWriteHtml == null)
        //            continue;
        //        lock (_lockReportHtml)
        //        {
        //            if (_attenteWriteHtml == null)
        //                continue;
        //            traite = _attenteWriteHtml;
        //            _attenteWriteHtml = null;
        //        }
        //        reportHtml(traite);
        //    }
        //}


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
                //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
                //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders, false);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders, false);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders, false);
        }

        public static void buildList(string path, List<TrackInfoItunes> list_, int prior)
        {
            bool absolutePath = path.StartsWith(@"\");
            var tab = path.Split('\\');
            int count = tab.GetLength(0);
            var folder = new List<string>();

            foreach (string s in tab)
            {
                if (!string.IsNullOrWhiteSpace(s))
                    folder.Add(s);
            }

            buildList(list_, prior, folder, absolutePath);
        }



        public static void buildList(List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            var newf = new List<string>(folders);
            int count = newf.Count;

            string name = newf[count - 1];
            newf.RemoveAt(count - 1);
            buildList(name, list_, prior, newf, absolutePath);
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            try
            {
                if (Conf.Simulation)
                    return;
                if (Conf.UseMock)
                {
                    var sb = new StringBuilder();
                    foreach (string f in folders)
                    {
                        sb.Append(f); sb.Append(@"\");
                    }
                    sb.Append(name);
                    log.logNoDate("---------------------------");
                    log.log("liste {0}", sb.ToString());
                    if (list_ != null)
                    {
                        foreach (TrackInfoItunes t in list_)
                        {
                            log.logNoDate(t.ToString());
                        }
                    }
                    return;
                }

                if (list_ != null)
                {
                    foreach (TrackInfoItunes track in list_)
                    {
                        loader.reviveIfNecessary(track);
                    }
                }



                var rootIt = Conf.RootIt;
                RootItItem currentRoot = rootIt.roots[0];
                int count = rootIt.roots.Count;

                if (list_ != null)
                {
                    //   log.log("build list {0}",name);
                    //  var list = new List<IFile>(list_);
                    if (lists == null)
                    {
                        lists = new List<HashSet<int>>();
                        foreach (var item in rootIt.roots)
                        {
                            lists.Add(new HashSet<int>());
                        }
                        var list__ = new List<TrackInfoItunes>(list_);
                        list__.Sort(new PodcastComparerPubPub2());



                        int countTrack = list_.Count;

                        long size = 0;
                        int j = 0;
                        int indexRoot = 0;

                        //    HashSet<int> current = lists[0]; 

                        while (true)
                        {
                            if (j >= countTrack)
                                break;
                            TrackInfoItunes track = list__[j];
                            size += track.Size;
                            if (size <= currentRoot.size)
                            {
                                lists[indexRoot].Add(track.DbId);
                                // track.IndexRoot = indexRoot;
                            }
                            else
                            {

                                size = 0;
                                //  size += track.Size;
                                indexRoot++;
                                if (indexRoot >= count)
                                    break;
                                currentRoot = rootIt.roots[indexRoot];
                                continue;
                            }
                            j++;
                        }

                    }
                }


                for (int r = 0; r < count; r++)
                {
                    currentRoot = rootIt.roots[r];
                    folders = new List<string>(folders);
                    PlayListComposite folder = null;

                    if (absolutePath)
                    {
                        if (r > 0)
                            throw new Exception("un chemin absolu ne peut pas être géré dans une partition");
                        // folders[0] = folders[0].Substring(1);
                        folder = loader.TreePlayList;

                    }
                    else
                        folder = loader.TreePlayList.getComposite(currentRoot.name);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(currentRoot.name);


                    var nname = name;
                    if (name.Contains(Path.DirectorySeparatorChar.ToString()))
                    {
                        var tab = name.Split(Path.DirectorySeparatorChar);
                        string str = null;
                        for (int i = 0; i < tab.GetLength(0); i++)
                        {
                            if (str != null)
                                folders.Add(str);
                            if (!string.IsNullOrEmpty(tab[i]))
                                str = tab[i];
                        }
                        if (!string.IsNullOrEmpty(str))
                            nname = str;
                    }
                    List<IFile> l = null;

                    if (list_ != null)
                    {
                        l = new List<IFile>();
                        foreach (TrackInfoItunes t in list_)
                        {
                            if (lists[r].Contains(t.DbId))
                                l.Add(t);
                        }
                    }


                    for (int i = 0; i < folders.Count; i++)
                    {
                        var aux = folder;
                        folder = folder.getComposite(folders[i]);
                        if (folder == null)
                            folder = loader.getOrCreateFolder(aux, folders[i], l == null ? true : l.Count > 0);
                        if (folder == null)
                            return;
                    }

                    //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
                    var playlist = loader.getPlayList(folder, nname, l == null ? true : l.Count > 0);
                    if (playlist != null)
                    {
                        if (prior < int.MaxValue && prior >= 0)
                            playlist.setPrior(prior);
                        //if (list.Count > 0)


                        playlist.mergeList(l, hibernator.Ignore, _instance, Conf.OnlyEnabled, Conf.OnlyUnRead);
                        //  loader.mergeList(playlist, l, false, _instance, null);
                        //else
                        //    loader.removeList(folder, name);
                    }



                    //log.log("clear list {0}", name); 
                    //loader.ClearList(playlist);
                    //log.log("add items {0}", name); 
                    //foreach (TrackInfoItunes track in list)
                    //    loader.addItemToList(playlist, track); 

                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }


        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildGlobalList(string path, List<TrackInfoItunes> list_, int prior)
        {
            PlayListComposite folder = null;
            List<string> folders = new List<string>();
            string nname = "";
            if (Conf.UseMock)
                return;
            try
            {

                var tab = path.Split(Path.DirectorySeparatorChar);
                string str = null;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    if (str != null)
                        folders.Add(str);
                    if (!string.IsNullOrEmpty(tab[i]))
                        str = tab[i];
                }
                if (!string.IsNullOrEmpty(str))
                    nname = str;

                folder = loader.TreePlayList;





                var l = new List<IFile>();
                foreach (TrackInfoItunes t in list_)
                {
                    if (t.Present)
                        l.Add(t);
                }

                for (int i = 0; i < folders.Count; i++)
                {
                    var aux = folder;
                    folder = folder.getComposite(folders[i]);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(aux, folders[i], l.Count > 0);
                    if (folder == null)
                        return;
                }


                var playlist = loader.getPlayList(folder, nname, l.Count > 0);
                if (playlist != null)
                {
                    if (prior < int.MaxValue && prior >= 0)
                        playlist.setPrior(prior);


                    playlist.mergeList(l, hibernator.Ignore, _instance, false, false);

                }



            }

            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }




        }

        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            DateTime now = DateTime.Now;

            fLoader.Action(pre);
            var ts = (DateTime.Now - now).TotalMilliseconds;
            if (ts > 1 && Conf.LogDir && pre > action.none && pre < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", pre, dir.getPath(), ts.ToString("0"));
            }

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());

            now = DateTime.Now; ts = (DateTime.Now - now).TotalMilliseconds;
            fLoader.Action(post);

            if (ts > 1 && Conf.LogDir && post > action.none && post < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", post, dir.getPath(), (DateTime.Now - now).TotalMilliseconds.ToString("0"));
            }


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }

        private void resetLoad(DirConf dir)
        {
            recursif(dir, action.resort, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void Freewheel(DirConf dir)
        {
            dir.Loader.LimitsLoader.Freewheel();
        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
            List<TrackInfoItunes> list = null;
            //  var list = db.Tracks.FindAll(t => t.Present);
            //var list = db.Tracks.FindAll(t => t.isConcernedBySelection); 
            var Fin1ereJournee = ContexteBuilder.Instance.Fin1ereJournee;
            var limitContexte = ContexteBuilder.Instance.LimitWriteList;
            if (Conf.UseMock)
                list = db.Tracks.FindAll(t => t.isConcernedBySelection && t.isPodcast);
            else
                list = db.Tracks.FindAll(t => t.Present && t.isConcernedBySelection && t.isPodcast && t.Pub2 <= limitContexte);
            foreach (SelectParamBase listeGlobal in Conf.GlobalListes)
            {
                var selector = new TrackSelector(listeGlobal);
                var l = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (selector.select(t))
                        l.Add(t);
                }

                buildGlobalList(listeGlobal.path, l, 2);

            }

            //foreach (Note note in Conf.Notes)
            //{
            var builder = dir.NoteBuilder;
            if (builder == null)
                return;
            var note = builder.Note; // note.NoteBuilder; // new NoteBuilder(note);
            builder.build(list);
            builder.display();
            foreach (ListNote listNote in builder.Depot)
            {
                var path = string.Format(note.path, listNote.Note);
                var _l = listNote.List;
                if (note.histo)
                    _l.Sort(new PodCastComparer());
                else
                    _l.Sort(new PodCastComparerInv());
                buildGlobalList(path, _l, 2);

                if (!string.IsNullOrEmpty(note.single))
                {
                    var pathSingle = string.Format(note.single, listNote.Note);
                    var hs = new HashSet<string>();
                    var ls = new List<TrackInfoItunes>();
                    foreach (TrackInfoItunes t in _l)
                    {
                        if (!t.Selected)
                            continue;
                        if (!hs.Add(t.AlbumKey))
                            continue;
                        ls.Add(t);
                    }
                    buildGlobalList(pathSingle, ls, 2);
                }
            }
            // Sélection d'un unique item (preise encompte des niveaux précédents)
            if (!string.IsNullOrEmpty(note.unique))
            {
                Logger logger = Logger.getLogger("NotesU", false);
                //Dictionnaire global
                var hsGlobal = new HashSet<string>();
                var depot = new List<ListNote>(builder.Depot);
                int count = depot.Count;

                for (int i = count - 1; i >= 0; i--)
                {
                    ListNote listNote = depot[i];
                    var _l = listNote.List.FindAll(t => t.Selected && t.Pub <= Fin1ereJournee);
                    _l.Sort(new PodCastComparer());

                    var linv = _l.FindAll(t => t.Recent && ContexteBuilder.Instance.getRetard(t, note.date0Min) <= note.retardHisto);
                    linv.Sort(new PodCastComparerInv());

                    foreach (TrackInfoItunes t in _l)
                    {
                        if (linv.Contains(t))
                            continue;
                        linv.Add(t);
                    }

                    //if (note.histo)
                    //    _l.Sort(new PodCastComparer());
                    //else
                    //    _l.Sort(new PodCastComparerInv());
                    var ls = new List<TrackInfoItunes>();
                    var hs = new HashSet<string>();
                    var pathUnique = string.Format(note.unique, listNote.Note);
                    foreach (TrackInfoItunes t in linv)
                    {
                        //if (!t.Selected)
                        //    continue;
                        if (hsGlobal.Contains(t.AlbumKey))
                            continue;
                        if (hs.Contains(t.AlbumKey))
                            continue;
                        if (t.Pub <= ContexteBuilder.Instance.Zero)
                        {
                            hsGlobal.Add(t.AlbumKey);
                            hs.Add(t.AlbumKey);
                        }
                        else
                        {
                        }

                        ls.Add(t);

                        var tn = listNote.getTrackNote(t.DbId);
                        tn.log(logger);
                    }

                    buildGlobalList(pathUnique, ls, 2);
                }
            }

            //  }

            var contextB = ContexteBuilder.Instance;

            if (contextB.Enabled)
            {

                var selected = dir.getListe();
                selected.Sort(new PodCastComparer());
                var listContext = new List<TrackInfoItunes>();
                contextB.buildList(selected, listContext);

                buildList("_contexte", listContext, 2);
            }



        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                            break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Grouping = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.obj;
using pdb.it;
using pdb.podcast.Albums;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        // standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub, ISelectable
    {
        public const string PUB_DATE_FORMAT_COMMENT = "yyyy/MM/dd HH:mm";
        public const string PUB_DATE_FORMAT_DB = "dd/MM/yyyy HH:mm";
        private static Loader loader;
        private static AlbumMgr albumMgr = AlbumMgr.Instance;
        private DateTime dtDisabled = DateTime.MaxValue;
        public DateTime Disabled { get { return dtDisabled; } }


        public override bool Equals(object obj)
        {
            var o = obj as TrackInfoItunes;
            if (o == null)
                return false;
            return DbId.Equals(o.DbId);
        }

        public new static Loader Loader { set { loader = value; } }
        private TrackAlbum _album;
        public TrackAlbum TrackAlbum
        {
            get
            {
                return _album;
            }
            set
            {
                _album = value;
            }
        }

        public ConfAlbum ConfAlbum
        {
            get
            {
                if (_album != null)
                    return _album.ConfAlbum;
                return ConfAlbums.Main;
            }
        }

        public override string AlbumKey { get { var alb = TrackAlbum; if (alb == null) return base.AlbumKey; return alb.AlbumKey; } }
        public override string Album
        {
            get
            {
                if (string.IsNullOrEmpty(album) && _album != null)
                    return _album.Album;
                return album;
            }
            set
            {
                base.Album = value;
            }
        }

        public int AlbumRating { get { return TrackAlbum.AlbumRating; } }
        //  private bool ratingComputed; public bool RatingComputed { get { return ratingComputed; } }

        //public override void setAlbum(string album)
        //{
        //    TrackInfoItunes.AlbumMgr.setAlbum(this, album);
        //}

        public DateTime getDate()
        {
            return TrackAlbum.ConfAlbum.checkPub ? Pub : Pub2;
        }

        private void import(IITFileOrCDTrack native)
        {
            misc.log("import {0}", this);
            native.Name = name;

            native.AlbumRating = AlbumRating;
            if (rating != AlbumRating)
                native.Rating = rating;
            native.PlayedDate = this.PlayedDate.ToUniversalTime();
            native.Enabled = this.Enabled;
            native.PlayedCount = this.playCount;
            var _comment = buildComment();
            if (!string.IsNullOrEmpty(_comment))
                native.Grouping = _comment;
            var _composer = buildComposer();
            if (!string.IsNullOrEmpty(_composer))
                native.Composer = _composer;

        }

        public string buildComment()
        {
            string comment = pub.ToString(PUB_DATE_FORMAT_COMMENT);
            if (pub2 > pub)
                comment = string.Format("{0}|{1}| {2}",
                    pub2.ToString(PUB_DATE_FORMAT_COMMENT),
                    pub.ToString(PUB_DATE_FORMAT_COMMENT),
                    (pub2 - pub).TotalDays.ToString("#00.#"));
            return comment;
        }

        public string buildComposer()
        {
            string comment = pub.ToString(PUB_DATE_FORMAT_COMMENT);
            //if (pub2 > pub)
            //    comment = string.Format("{0}|{1}", Pub2.ToString(PUB_DATE_FORMAT_COMMENT), Pub.ToString(PUB_DATE_FORMAT_COMMENT));
            return comment;
        }

        public void BuildComment()
        {
            var comment = buildComment();
            if (!string.IsNullOrEmpty(comment) && comment != Grouping)
            {
                //if (!string.IsNullOrEmpty(Grouping))
                //    File.AppendAllText("..\\groupingIni.txt", string.Format("{0};{1};{2}\r\n",DbId,Location,Grouping));
                Grouping = comment;
            }

        }

        public void BuildComposer()
        {
            var composer = buildComposer();
            //  Composer = composer;
            if (!string.IsNullOrEmpty(composer) && composer != Composer)
                Composer = composer;
        }

        public void import()
        {
            if (!isPresent())
                return;

            try
            {
                var native = TrackTrack;
                if (native == null)
                    native = Track;
                if (native == null)
                {
                    bgImport.add(new BgTaskImport(this));
                }
                else
                    import(native);

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public void merge()
        {
            if (!isPresent())
                return;
            bgImport.add(new BgTaskImport(this));
        }

        //public void import(TrackInfoItunes db)
        //{
        //    this._album = db._album;
        //    // this.albumRating = db.albumRating;
        //    this.rating = db.rating;
        //    //this.rare = db.rare;
        //    //this.info = db.info;
        //    this.playCount = db.playCount;
        //    this.PlayedDate = db.PlayedDate;
        //    this.enabled = db.enabled;
        //    present = true;
        //    db.present = true;

        //    import();
        //}

        private DateTime offset;
        public DateTime Offset
        {
            set
            {
                if (offset == DateTime.MinValue)
                    offset = value;
            }
            get { return offset; }
        }

        //public override bool Enabled
        //{
        //    get
        //    {
        //        if (_dbId == 1181)
        //        {
        //        }

        //        if (dtDisabled == DateTime.MaxValue)
        //            return true;

        //        if (_album != null
        //            && _album.ConfAlbum != null
        //            && _album.ConfAlbum.disabledForgot < DateTime.MaxValue)
        //        {
        //            if (dtDisabled < _album.ConfAlbum.disabledForgot)
        //                return true;
        //            else
        //                return false;
        //        }
        //        return base.Enabled;
        //    }
        //    //set
        //    //{
        //    //    if (enabled != value)
        //    //    {
        //    //        base.Enabled = value;
        //    //        if (!enabled)
        //    //        {
        //    //            dtDisabled = DateTime.Now;
        //    //        }
        //    //    }
        //    //}
        //}

        public bool BaseEnabled { get { return base.Enabled; } }


        public override IITFileOrCDTrack Track
        {
            get
            {
                if (track != null)
                    return track;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    // loader.resurrection(this);
                }
                return base.Track;
            }
        }

        public override IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (tracktrack != null)
                    return tracktrack;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    //   loader.resurrection(this);
                }
                return base.TrackTrack;
            }
        }

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        //private static bool _updateNative;
        //public static bool UpdateNative { get { return _updateNative; } set { _updateNative = value; } }
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                    defaultFolder += "Podcasts\\";
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;
        public int DbId { get { return _dbId; } set { if (_dbId <= 0) _dbId = value; } }

        /// <summary>
        /// Si Track doublon (genre podcast de voyage) id du podcast à l'origine
        /// </summary>
        private int parentId;

       public int ParentId { get { return parentId; } }

        private TrackInfoItunes parent;

        public bool HasParent { get { return parent != null ; } }

        public TrackInfoItunes Parent { get { return parent; } set { parent = value; parentId = parent.DbId; } }

        public TrackInfoItunes Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        //public override string Location
        //{
        //    get
        //    {
        //        if (parent == null)
        //            return location;
        //        if (true == FileRegister.Exist(location))
        //            return location;
        //        return parent.location;
        //    }

        //    set
        //    {
        //        base.Location = value;
        //    }
        //}

        //private static int NB = 0;
        //private int iddebug;

        public TrackInfoItunes()
        {
            _isPodCast = true;
            //NB++;
            //iddebug = NB;
        }
        public override int GetHashCode()
        {
            return DbId.GetHashCode();
        }
        //  public bool Deleted { get; set; }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        //  private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        // private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        //private LimitItem exclu;
        //public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            //var key = item.ID;
            //if (!listLoad0.ContainsKey(key))
            //    listLoad0.Add(key, item);
        }
        //public bool containsload(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listLoad0.ContainsKey(key);
        //}

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        //public bool containsSelect(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listSelected.ContainsKey(key);
        //}
        //public bool isPreselected { get { return listLoad0.Count > 0; } }
        //public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {

                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        public void synch(TrackInfoItunes o)
        {
            _in = o._in;
            _out = o._out;
            pub = o.pub;
            Pub2 = o.pub2;
            if (!string.IsNullOrEmpty(Description))
                Description = o.Description;
            if (!string.IsNullOrEmpty(LongDescription))
                LongDescription = o.LongDescription;

        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            if (!track.Enabled)
            {
                if (dtDisabled == DateTime.MaxValue || dtDisabled == DateTime.MinValue)
                    dtDisabled = DateTime.Now;
            }

            TrackAlbum.AlbumRating = track.AlbumRating;
            // this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!track.Podcast)
                return;
            //if (!isPodcast)
            //    return;

            duree = new util.timeSpan(Duration);

            CheckPlay(this);

            //if (track.PlayedCount > 0)
            //{
            //    played = markAsPlayed(Rating, PlayedDate);
            //}

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                Pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Grouping != commentByReleaseDate)
                    {
                        misc.log("chgt Comment à partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Grouping = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Grouping;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Grouping)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment à partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Grouping = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de gérer " + this, ex);
                }
            }
            finally
            {

                //if (target)
                //{

                //    FileInfo file = new FileInfo(loc);
                //    DirectoryInfo dirTrack = file.Directory;
                //    DirectoryInfo dirPodcast = dirTrack.Parent;
                //    if (!dirPodcast.Name.Equals(REFONTE))
                //    {
                //        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                //        if (!dirV1.Exists)
                //            dirV1.Create();

                //        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                //        string dirDest = Path.GetDirectoryName(dest);
                //        string fileName = Path.GetFileName(dest);
                //        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                //        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                //        try
                //        {
                //            misc.log("deplacer " + loc);
                //            string newDest = file.copyTree(dest, null);
                //            misc.log("-------> " + newDest);
                //            track.Location = newDest;
                //            try
                //            {
                //                File.Delete(loc);
                //            }

                //            catch (Exception del)
                //            {

                //                misc.log(del.ToString());
                //            }

                //        }
                //        catch (Exception ex)
                //        {
                //            misc.log(ex.ToString());
                //        }
                //    }
                //}

            }
#endif

        }


        //private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        //public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }

        private static DateTime playedLevel = DateTime.MinValue;
        public static DateTime PlayedLevel { set { playedLevel = value; } }
        //public static bool markAsPlayed(int rating, DateTime date)
        //{
        //    if (maxPlayed.ContainsKey(rating))
        //        return date > maxPlayed[rating];
        //    return true;
        //}

        public bool calcEnabled()
        {
            if (dtDisabled == DateTime.MaxValue)
                return true;
            var conf = ConfAlbum;
            if (dtDisabled > conf.forgotMax)
                return false;

            return dtDisabled < conf.forgotDisabled;
        }

        public static void CheckPlay(TrackInfoItunes track)
        {
            var played = isPlayed(track);

            track.played = played;
            track.enabled = track.calcEnabled();
        }


        private static bool isPlayed(TrackInfoItunes track)
        {
            var playDate = track.PlayedDate;
            if (track.playCount <= 0)
            {
                if (playDate == DateTime.MinValue)
                    return false;
                if (playedLevel == DateTime.MinValue || playDate >= playedLevel)
                    return false;
                // pour les vieux on prend quand même en compte la date de dernière lecture
                return true;
            }


            var conf = track.ConfAlbum;
            var playedDate = track.PlayedDate;
            if (playedDate > conf.forgotMax)
                return true;

            if (track.isConcernedBySelection)
            {
                if (playedDate < conf.forgotShort)
                    return false;
            }
            else
            {
                if (playedDate < conf.forgot)
                    return false;
            }
            return true;

        }


        public string ShortName { get { return getShortName(location); } }
        public static string getShortName(string location) { return misc.getShortPath(location, Exporter.PODCASTS, Exporter.ZIQUE, "Y:"); }

        private string hibernateLocation;
        public string HibernateLocation { get { return hibernateLocation; } set { hibernateLocation = value; } }


        public bool isPresent()
        {
            if (!string.IsNullOrEmpty(hibernateLocation))
                return FileRegister.ExistNow(hibernateLocation);
            return FileRegister.ExistNow(location);

            //var path = location;
            //if (_extern)
            //{
            //    var shortName = ShortName;
            //    path = TrackInfoItunes.DefaultFolder + shortName;
            //}
            //if (FileRegister.Exist(location))
            //{
            //    location = path;
            //    return true;
            //}
            //return false;
        }

        private double note = int.MaxValue;
        public double Note { get { return note; } set { note = value; } }

        public void build(XmlReader reader)
        {

            location = reader.GetAttribute("f");
            if (!string.IsNullOrEmpty(location))
            {
                if (Path.IsPathRooted(location))
                {
                }
                else
                    location = TrackInfoItunes.DefaultFolder + location;

                FileRegister.Push(location);
            }
            url = reader.GetAttribute("url");
            hibernateLocation = reader.GetAttribute("hl");

            string album = reader.GetAttribute("alb");

            if (!string.IsNullOrEmpty(album))
                this.album = album;

            name = reader.GetAttribute("name");

            var str = reader.GetAttribute("pub");
            if (!string.IsNullOrEmpty(str))
                Pub = Convert.ToDateTime(str);

            str = reader.GetAttribute("pub2");
            if (!string.IsNullOrEmpty(str))
                Pub2 = Convert.ToDateTime(str);
            else
                Pub2 = Pub;

            str = reader.GetAttribute("date");
            if (!string.IsNullOrEmpty(str))
            {
                // playCount = 1;
                PlayedDate = Convert.ToDateTime(str);
            }

            str = reader.GetAttribute("nbr");
            if (!string.IsNullOrEmpty(str))
            {
                playCount = Convert.ToInt16(str);
            }

            str = reader.GetAttribute("albumRating");
            if (!string.IsNullOrEmpty(str))
                TrackAlbum.AlbumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                rating = Convert.ToInt32(str);

            if (TrackAlbum.AlbumRating > 0 && rating == 0)
                rating = TrackAlbum.AlbumRating;

            str = reader.GetAttribute("id");
            _dbId = Convert.ToInt32(str);

            str = reader.GetAttribute("pid");
            if (!string.IsNullOrEmpty(str))
                parentId = Convert.ToInt32(str);

            //if ("y" == reader.GetAttribute("rare"))
            //    TrackAlbum.Rare = true;
            //if ("y" == reader.GetAttribute("info"))
            //    TrackAlbum.Info = true;
            if ("y" == reader.GetAttribute("disabled"))
            {
                dtDisabled = DateTime.MinValue;
            }
            else
            {
                str = reader.GetAttribute("dd");
                if (string.IsNullOrEmpty(str))
                {
                    dtDisabled = DateTime.MaxValue;
                }
                else
                {
                    if ("y" == str)
                        dtDisabled = DateTime.MinValue;
                    else
                        dtDisabled = Convert.ToDateTime(str);
                }
            }
            str = reader.GetAttribute("s");
            if (!string.IsNullOrEmpty(str))
                _size = Convert.ToInt64(str);
            else
                _size = -1;

            str = reader.GetAttribute("d");
            if (!string.IsNullOrEmpty(str))
                Duree = timeSpan.FromSecondes(Convert.ToInt32(str));



            str = reader.GetAttribute("add");
            if (!string.IsNullOrEmpty(str))
                added = Convert.ToDateTime(str);
            str = reader.GetAttribute("add1");
            if (!string.IsNullOrEmpty(str))
                AddedFirst = Convert.ToDateTime(str);

            if (addedFirst == DateTime.MinValue)
                addedFirst = added;

            Description = reader.GetAttribute("desc");
            LongDescription = reader.GetAttribute("ldesc");
            Comment = reader.GetAttribute("comment");


            str = reader.GetAttribute("note");
            if (!string.IsNullOrEmpty(str))
                note = Convert.ToDouble(str);

            CheckPlay(this);

        }

        /// <summary>
        /// Merge du track db (this) avec celui récupéré par itunes
        /// </summary>
        /// <param name="native"></param>
        public void merge(TrackInfoItunes native)
        {
            if (native == this)
                return;
            if (string.IsNullOrEmpty(location))
                location = native.Location;

            string album = native.Album;

            name = native.Name;

            PlayedDate = native.PlayedDate;

            playCount = native.PlayCount;

            rating = native.Rating;


            // enabled = native.enabled;

            Duration = native.Duration;

            if (native.Added > DateTime.MinValue)
                added = native.Added;

            if (addedFirst == DateTime.MinValue)
                addedFirst = added;

            if (!string.IsNullOrEmpty(native.Description))
                Description = native.Description;
            if (!string.IsNullOrEmpty(native.LongDescription))
                LongDescription = native.LongDescription;
            if (string.IsNullOrEmpty(Comment))
                Comment = native.Comment;
            // détection des déselections manuelles
            if (Enabled && !native.Enabled)
            //if (enabled && !native.enabled)
            {
                //  enabled = native.enabled;
                var o = native.dtDisabled;
                if ((dtDisabled == DateTime.MaxValue) || (o > dtDisabled && o < DateTime.MaxValue))
                    dtDisabled = o;
            }


            CheckPlay(this);

        }

        public void readStat(XmlReader reader)
        {
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                _in = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                _out = Convert.ToDateTime(str);
        }

        public bool SelectedByDb { get { return Selected; } }// || _in > _out; } }

        public void readStatGlobal(XmlReader reader)
        {
            DateTime oin = DateTime.MinValue;
            DateTime oout = DateTime.MinValue;
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                oin = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                oout = Convert.ToDateTime(str);

            if (oin > oout)
            {
                //sélectionné
                _gout = DateTime.MaxValue;
                return;
            }

            if (oout > _gout)
                _gout = oout;
        }

        //public void consolidStat()
        //{
        //    if (_in > DateTime.MinValue)
        //    {
        //        if (_in < _gin || _gin == DateTime.MinValue)
        //            _gin = _in; 
        //    }

        //    if (_out > _gout)
        //        _gout = _out; 
        //}



        public override void build(XmlNode xTrack)
        {
            TrackInfoItunes copy = null;
            if (loader.Import || loader.Slave)
            {
                copy = createCopy(this);
            }

            base.build(xTrack);

            if (!isPodcast)
                return;
            if (Strange)
                return;
            if (this._dbId == 1181)
            {
            }

            if (!base.Enabled)
            {
                if (dtDisabled == DateTime.MaxValue || dtDisabled == DateTime.MinValue)
                    dtDisabled = DateTime.Now;
            }

            var album = TrackAlbum;
            if (album == null)
            {
                album = albumMgr.Get(this.Album);
            }


            //  bool ratingComputed = false;
            bool albumRatingComputed = false;
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            //if (!isPodcast)
            //    return;
            //if (Strange)
            //    return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    //if (key == "Rating Computed")
                    //    ratingComputed = true;
                    if (key == "Album Rating Computed")
                        albumRatingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); AddedFirst = added; break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Release Date": pub = Convert.ToDateTime(value).truncateToMinute(); break; //DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Album Rating": if (album != null) album.AlbumRating = Convert.ToInt32(value); break;
                }

            }
            // gestion des rating
            if (albumRatingComputed & album != null)
                album.AlbumRating = 0;

            duree = new util.timeSpan(Duration);


            bool change = false;
            if (copy != null)
            {
                if (copy._album != null)
                    _album = copy._album;
                if (!string.IsNullOrEmpty(copy.name) && copy.name != name)
                {
                    log.log("import cause name '{0}' '{1}' {2}", name, copy.name, this);
                    name = copy.name;
                    change = true;
                }

                if (PlayedDate != copy.PlayedDate)
                {
                    log.log("import cause playDate '{0}' '{1}' {2}", PlayedDate, copy.PlayedDate, this);
                    PlayedDate = copy.PlayedDate;
                    change = true;
                }
                if (playCount != copy.playCount)
                {
                    log.log("import cause playCount '{0}' '{1}' {2}", playCount, copy.playCount, this);
                    change = true;
                    playCount = copy.playCount;
                }
                // albumRating = copy.albumRating;
                //if (base.Enabled != copy.BaseEnabled)
                //{
                //    log.log("import cause enabled '{0}' '{1}' {2}", enabled, copy.enabled, this);
                //    enabled = copy.enabled;
                //    change = true;
                //}

                if (rating != copy.rating)
                {
                    log.log("import cause rating '{0}' '{1}' {2}", rating, copy.rating, this);
                    rating = copy.rating;
                    change = true;
                }
                if (pub2 != copy.pub2)
                {
                    log.log("import cause pub2 '{0}' '{1}' {2}", pub2, copy.pub2, this);
                    pub2 = copy.pub2;
                    change = true;
                }


                var comment = buildComment();
                if (!string.IsNullOrEmpty(comment) && comment != Grouping)
                {
                    log.log("import cause comment '{0}' '{1}' {2}", Grouping, comment, this);
                    change = true;
                }


                //var composer = buildComposer();
                //if (!string.IsNullOrEmpty(composer) && composer != Composer)
                //{
                //    log.log("import cause composer '{0}' '{1}' {2}", Composer, composer, this);
                //    change = true;
                //}

                //var _comment = buildComment();
                //if (_comment != Comment)
                //    change = true;

                Duration = copy.Duration;
                duree = copy.duree;


            }
            setPub();

            CheckPlay(this);

            if (change)
            {
                import();
            }
        }



        //private PubLoader pubLoader;
        //internal PubLoader PubLoader { get { if (pubLoader == null) pubLoader = new PubLoader(this); return pubLoader; } }
        internal PubLoader PubLoader { get { return new PubLoader(this); } }

        public void setPub()
        {
            PubLoader.setPub();
        }

        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        private DateTime pub2;
        public DateTime Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
                if (pub2 < pub)
                    pub2 = pub;
            }
        }

        public DateTime Pub2
        {
            get { return pub2; }
            set
            {
                if (value > pub)
                    pub2 = value;
                else
                    pub2 = pub;

            }
        }


        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        new public DateTime Added { get { return added; } }

        /// <summary>
        /// Date de premier ajout; 
        /// </summary>
        private DateTime addedFirst;
        public DateTime AddedFirst
        {
            get { return addedFirst; }

            set
            {
                if (addedFirst == DateTime.MinValue)
                    addedFirst = value;
            }
        }

        private DateTime _in;
        public DateTime In { get { return _in; } }

        private DateTime _out;
        public DateTime Out { get { return _out; } }

        //private DateTime _gin;
        //public DateTime Gin { get { return _gin; } }

        /// <summary>
        /// Dernier out global (MaxValue si encore sélectionné)
        /// </summary>
        private DateTime _gout;
        public DateTime Gout { get { return _gout; } set { _gout = value; } }

        public void checkInOut()
        {
            DateTime now = DateTime.Now;
            if (Selected)
            {
                if (_in == DateTime.MinValue || _out > _in)
                    _in = now;
            }
            else
            {
                if (_in > DateTime.MinValue)
                {
                    if (_out == DateTime.MinValue || _in > _out)
                        _out = now;
                }
            }
        }


        public albumSpec Specif { get { return TrackAlbum.Specif; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        // private bool info;

        public bool Info
        {
            get { return TrackAlbum.Info; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        //  private bool rare;
        public bool Rare
        {
            get { return TrackAlbum.Rare; }
        }
        public bool RareEffect
        {
            get { return TrackAlbum.RareEffect; }
        }

        public bool Actu
        {
            get { return TrackAlbum.Actu; }
        }

        public bool Courant
        {
            get { return TrackAlbum.Courant; }
        }

        public bool Open { get { return TrackAlbum.Open; } }
        public bool Recent { get { return TrackAlbum.Recent; } }
        public bool UnAn { get { return TrackAlbum.UnAn; } }

        private bool played;
        public override bool Played { get { return played; } }
        public bool BasePlayed { get { return base.Played; } }

        //private bool globalSelected;
        //public bool GlobalSelected { get { return globalSelected; } set { globalSelected = value; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        // private bool inJournal = false;

        //public bool FreeInJournal { get { return Selected && !inJournal; } }
        //public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        public void clearLists()
        {
            selected = selectMode.none;
            //  exclu = null;
            //  inJournal = false;
            listSelected.Clear();// = new SequentialDictString<LimitItem>();
            //listLoad0 = new SequentialDictString<LimitItem>();
            //listStandAlone = new SequentialDictString<LimitItem>();
            //indexRoot = -1;
            offset = default(DateTime);
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }
        private string pubInfoShort() { return pub.ToString("dd.MM.yy"); }
        public static string pubInfoShort(DateTime pub) { return pub.ToString("dd.MM.yy"); }
        private string getDayOfWeek()
        {
            var strDayOfWeek = "";
            switch (pub.DayOfWeek)
            {
                case DayOfWeek.Friday:
                strDayOfWeek = "v";
                break;
                case DayOfWeek.Monday:
                strDayOfWeek = "l";
                break;
                case DayOfWeek.Saturday:
                strDayOfWeek = "s";
                break;
                case DayOfWeek.Sunday:
                strDayOfWeek = "d";
                break;
                case DayOfWeek.Thursday:
                strDayOfWeek = "j";
                break;
                case DayOfWeek.Tuesday:
                strDayOfWeek = "ma";
                break;
                case DayOfWeek.Wednesday:
                strDayOfWeek = "me";
                break;
                default:
                break;
            }

            return strDayOfWeek;
        }

        // private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void updateNative()
        {
            PubLoader.setPub();


            int volume = Volume;
            if (Album.Contains("RFI"))
            {
                if (volume != -20)
                    Volume = -20;
            }
            else
            {
                if (volume < volumeMin)
                    Volume = volumeMin;
            }


            if (pub > MIN)
            {

                var target = NameWithDate;
                if (!target.Equals(Name))
                    Name = target;
                BuildComment();
                BuildComposer();
                return;

                //string infoShort = pubInfoShort();
                //string infoPubName = pub.ToString("dd.MM.yyyy");
                //string infoPubName2 = pub.ToString("dd/MM/yyyy");
                //string infoPubName3 = pub.ToString("dd/MM/yy");
                //string infoYear = Year.ToString();
                //if (pub.DayOfYear == 1)
                //{
                //    infoPubName = pub.Year.ToString();
                //    infoPubName2 = infoPubName;
                //    infoPubName3 = infoPubName;
                //    infoShort = infoPubName;
                //}

                //string name = Name;
                //string str = name;

                //while (str.Contains("  "))
                //    str = str.Replace("  ", " ");

                //while (str.Contains(infoShort))
                //    str = str.Replace(infoShort, "");
                //while (str.Contains(infoPubName))
                //    str = str.Replace(infoPubName, "");
                //while (str.Contains(infoPubName2))
                //    str = str.Replace(infoPubName2, "");
                //while (str.Contains(infoPubName3))
                //    str = str.Replace(infoPubName3, "");

                //str = str.Trim();

                ////if (regInfoShort.IsMatch(str))
                ////{
                ////    var strdate = regInfoShort.Match(str).Groups[1].Value;
                ////    str = str.Replace(strdate, "");
                ////}



                ////Michel Rocard (1/5) l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 17.06.13 l
                //var strDayOfWeek = getDayOfWeek();
                //var s1 = strDayOfWeek + " ";
                //strDayOfWeek = " " + strDayOfWeek;

                //while (str.EndsWith(strDayOfWeek))
                //    str = str.Remove(str.Length - strDayOfWeek.Length - 1);
                ////while (str.EndsWith(s1))
                ////    str = str.Remove(str.Length - s1.Length);

                ////if (str.Contains(infoPubName))
                ////    str = str.Replace(infoPubName, infoShort);
                ////else if (name.Contains(infoPubName2))
                ////    str = str.Replace(infoPubName2, infoShort);

                ////else
                ////{
                ////    if (!str.Contains(infoShort))
                ////    {
                ////        str = str + " " + infoShort;
                ////    }
                ////    else
                ////    {
                ////        if (Year > 1980 && str.Contains(infoYear))
                ////            str = str.Replace(infoYear, "").Trim();
                ////    }
                ////}
                //var strBUG = "30.12.99";
                //if (str.Contains(strBUG))
                //    str = str.Replace(strBUG, "");

                //while (str.Contains("  "))
                //    str = str.Replace("  ", " ");

                //str = str.Trim();

                //str += " ";
                //str += infoShort;


                //str += strDayOfWeek;

                //if (!str.Equals(name))
                //    Name = str;

                //BuildComment();
                //BuildComposer();
            }
        }
        // private LimitItem provider; 
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (!listSelected.ContainsKey(key))
                listSelected.Add(key, limit);



            if (selected == value)
                return;

            selected = value;
            //if (isPresent() && !present)
            //{
            //    // loader.resurrection(this);
            //}




        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            // string strYear = Year > 0 ? Year.ToString() : "";
            var strAlbum = "";
            if (_album != null)
                strAlbum = Album;
            var strNote = "";
            if (note < int.MaxValue)
                strNote = note.ToString("0.##");
            return string.Format("{0} {1} {2} {3} {4} {5}", level, strNote, strAlbum, name, strPub, duree);
            // return level.ToString() + " " + strAlbum + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" à suprimer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                this.Pub = value;
            }
        }
        //DateTime IPub.Pub2
        //{
        //    get
        //    {
        //        return pub2;
        //    }
        //    set
        //    {
        //        pub2 = value;
        //    }
        //}

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            //set
            //{
            //    if (string.IsNullOrEmpty(this.Grouping))
            //        setGrouping(this.Comment, true);
            //    Comment = value;
            //}
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        DateTime IPub.Offset { get { return offset; } }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree
        {
            get
            {

                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
                return duree;
            }
            private set
            {
                duree = value;
                if (base.Duration.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
            }
        }

        static Regex regDeltaPub = new Regex(@"¤[\d,]+$");
        static Regex regDeltaPub2 = new Regex(@"[\d,]+°$");

        public static string getLogicalExternName(string t, DateTime pub)
        {
            if (string.IsNullOrEmpty(t))
                return "";
            t = t.Trim();
            var strBUG = "30.12.99";
            if (t.Contains(strBUG))
                t = t.Replace(strBUG, "").Trim();
            //var tab = t.Split((char)1); 
            //t = tab[0]; 
            while (true)
            {
                var t0 = t;
                if (regDeltaPub.IsMatch(t))
                {
                    t = regDeltaPub.Replace(t, "").Trim();
                }
                else if (regDeltaPub2.IsMatch(t))
                {
                    t = regDeltaPub2.Replace(t, "").Trim();
                }

                var strPub = pub.ToString("dd.MM.yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pub.ToString("dd/MM/yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pub.ToString("dd/MM/yy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pubInfoShort(pub);
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                if (t.EndsWith("-"))
                    t = t.Remove(t.Length - 1).Trim();

                strPub = pub.ToString("yy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();

                strPub = pub.ToString("yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();

                if (t.EndsWith("20"))
                    t = t.Remove(t.Length - "20".Length).Trim();

                if (t == t0)
                    break;
            }

            while (t.Contains("  "))
                t = t.Replace("  ", " ");



            return t;
        }

        public string getLogicalName(string t)
        {
            t = t.Trim();
            var strBUG = "30.12.99";
            if (t.Contains(strBUG))
                t = t.Replace(strBUG, "").Trim();
            //var tab = t.Split((char)1); 
            //t = tab[0]; 
            while (true)
            {
                var t0 = t;
                if (regDeltaPub.IsMatch(t))
                {
                    t = regDeltaPub.Replace(t, "").Trim();
                }
                else if (regDeltaPub2.IsMatch(t))
                {
                    t = regDeltaPub2.Replace(t, "").Trim();
                }
                if (pub2 > pub)
                {
                    var strD = (pub2 - pub).TotalDays.ToString("0.#");
                    if (t.EndsWith(strD))
                        t = t.Remove(t.Length - strD.Length).Trim();

                }

                var sw = getDayOfWeek();
                if (t.EndsWith(sw))
                    t = t.Remove(t.Length - sw.Length).Trim();
                var strPub = pub.ToString("dd.MM.yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pub.ToString("dd/MM/yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pub.ToString("dd/MM/yy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pubInfoShort();
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                if (t.EndsWith("-"))
                    t = t.Remove(t.Length - 1).Trim();

                strPub = pub.ToString("yy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();

                strPub = pub.ToString("yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();

                if (t.EndsWith("20"))
                    t = t.Remove(t.Length - "20".Length).Trim();

                if (t == t0)
                    break;
            }

            while (t.Contains("  "))
                t = t.Replace("  ", " ");



            return t;
        }

        /// <summary>
        /// Renvoie le décalage (avec espace avant) le cas échéant ou rien
        /// </summary>
        /// <returns></returns>
        private string getDateOffset()
        {
            if (pub2 > pub)
                return string.Format(" {0}°", (pub2 - pub).TotalDays.ToString("0.#"));
            return "";
        }

        public string NameWithDate
        {
            get { return string.Format("{0} {1} {2}{3}", LogicalName, pubInfoShort(), getDayOfWeek(), getDateOffset()); }
        }

        public string LogicalName
        {
            get
            {
                return getLogicalName(name);
            }
        }

        //public override string Name
        //{
        //    get
        //    {
        //        return name;
        //    }
        //    set
        //    {
        //        if (value == null)
        //        {
        //            log.log("set Name null !!! {0}", this);
        //            return;
        //        }

        //        var thisLog = LogicalName;
        //        var newLog = getLogicalName(value);

        //        if (!thisLog.Equals(newLog, StringComparison.InvariantCultureIgnoreCase))
        //        {
        //            log.log("Modification du nom logique !!! {0}->{1} {2}", thisLog, newLog, this);
        //            return;
        //        }
        //        base.Name = value;
        //    }
        //}



        public override TimeSpan Duration
        {
            get
            {
                var dur = base.Duration;
                if (dur.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
                return base.Duration;
            }

            set
            {
                base.Duration = value;
                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
            }
        }

        private long _size = -1;
        public long Size
        {
            get
            {
                if (_size < 0)
                {
                    var f = FileRegister.Get(Location);
                    var exist = f.Exists;
                    if (exist == null)
                        return -1;
                    else if (true == exist)
                        _size = f.Length;
                    else
                        _size = 0;
                }
                return _size;
            }
        }

        //private int indexRoot = -1;
        //public int IndexRoot { get { return indexRoot; } set { indexRoot = value; } }



        //public static void setDate0(DateTime date) { Date0 = date; }
        //private static DateTime Date0;
        //private timeSpan ts;
        //public timeSpan Ts
        //{
        //    get
        //    {
        //        if (ts == default(timeSpan))
        //        {
        //            if (Date0 == DateTime.MinValue)
        //                throw new ApplicationException("Date0 pas initialisée");
        //            ts = new timeSpan(Pub2 - Date0);
        //        }
        //        return ts;
        //    }
        //}

        public void hibernate(FileValue fv, string dirH)
        {
            bgHibernate.add(new BgTaskHibernate(this, fv, dirH));
        }

        /// <summary>
        /// pour minimiser les listes de selection on checke la durée. en effet à l'utilisation on mélange de toute façon avec les longs
        /// </summary>
        public bool isConcernedBySelection
        {
            get
            {
                //if (!enabled)
                //    return false;
                //if (played)
                //    return false;
                var globalDuree = TrackAlbum.ConfAlbum.maxGlobal;
                if (globalDuree > 0)
                {
                    if (Duree.TotalMinute > globalDuree)
                        return false;
                }
                return true;
            }
        }

        public bool isLong
        {
            get
            {
                var globalDuree = TrackAlbum.ConfAlbum.maxGlobal;
                if (globalDuree > 0)
                {
                    if (Duree.TotalMinute > globalDuree)
                        return true;
                }
                return false;
            }
        }

        protected class BgTaskHibernate : BgTaskDeleteTrackTrack
        {
            private TrackInfoItunes track;
            private FileValue fv;
            string dirH;
            public BgTaskHibernate(TrackInfoItunes track, FileValue fv, string dirH)
                : base(track, string.Format("Hibernate {0}", track))
            {
                this.track = track;
                this.fv = fv;
                this.dirH = dirH;
            }

            public override void exec()
            {
                base.exec();
                if (!success)
                    return;

                if (!string.IsNullOrEmpty(dirH))
                {
                    var dest = misc.copyTree(fv, dirH + track.ShortName, false);
                    track.HibernateLocation = dest;

                    try
                    {
                        File.Delete(track.Location);
                        fv.delete();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }
                }
            }
        }


        private class BgTaskImport : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskImport(TrackInfoItunes info)
                : base(string.Format("import {0}", info.Location))
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    info.import(_track);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



    }
}



]]></content>
  </file>
  <file path="db4\pdb.podcast\Albums\TrackAlbum.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;

namespace pdb.podcast.Albums
{
    [Flags]
    public enum albumSpec : byte
    {
        rare = 1,
        recent = 2,
        unAn = 4,
        open = 8,
        courant = 16,
        actu = 32,
        info = 64
    }

    public enum downloadMode : byte
    {
        none = 0,
        no = 1,
        last = 2,
        onePerDay = 3,
        onePerMin = 4,
        multiple = 5
    }


    public class TrackAlbum : ISelectable //pdb.it.Albums.TrackAlbumBase, 
    {
        private static DateTime dateOPen;
        private static DateTime dateUnAn;
        private albumSpec specif;
        private downloadMode _downloadMode;
        private string key;
        private string album;
        private HashSet<TrackInfoItunes> list = new HashSet<TrackInfoItunes>();
        private bool? _rareEffect;

        public string AlbumKey { get { return key; } }
        public downloadMode DownLoadMode { get { return _downloadMode; } set { _downloadMode = value; } }

        private static TrackAlbum _NULL = new TrackAlbum("Pas d'album", "Pas d'album");
        public static TrackAlbum NULL { get { return _NULL; } }

        static TrackAlbum()
        {
            dateOPen = DateTime.Now.AddDays(-Conf.DeltaOPen);
            dateUnAn = Conf.Date0.AddYears(1);
        }
        public TrackAlbum(string album, string key)
        {
            this.key = key;
            this.album = album;
            //conf = Conf.Albums;

            //foreach (ConfAlbum _album in Conf.Albums.Items)
            //{
            //    foreach (string alb in _album.name)
            //    {
            //        if (alb == this.Album)
            //        {
            //            conf = _album;
            //            return;
            //        }
            //    }
            //}

        }
        public string Album { get { return album; } }
        public int AlbumRating { get; set; }
        public double Note { get; set; }

        public albumSpec Specif { get { return specif; } }
        public bool Info
        {
            get { return specif.HasFlag(albumSpec.info); }
        }
        public void setInfo() { specif |= albumSpec.info; }

        public bool Rare
        {
            get { return specif.HasFlag(albumSpec.rare); }
        }
        public void setRare() { specif |= albumSpec.rare; }


        public bool Actu
        {
            get { return specif.HasFlag(albumSpec.actu); }
        }
        public void setActu() { specif |= albumSpec.actu; }

        public bool Courant { get { return specif.HasFlag(albumSpec.courant); } }
        public void setCourant() { specif |= albumSpec.courant; }

        public bool Open { get { return specif.HasFlag(albumSpec.open); } }
        private void setOpen()
        {
            if (!specif.HasFlag(albumSpec.open))
                specif |= albumSpec.open;
        }

        public bool Recent { get { return specif.HasFlag(albumSpec.recent); } }
        private void setRecent()
        {
            if (!specif.HasFlag(albumSpec.recent))
                specif |= albumSpec.recent;
        }

        public bool UnAn { get { return specif.HasFlag(albumSpec.unAn); } }
        private void setUnAn()
        {
            if (!specif.HasFlag(albumSpec.unAn))
                specif |= albumSpec.unAn;
        }

        private List<string> urls = new List<string>();
        public List<string> Urls { get { return urls; } }


        private pdb.podcast.Tuning.ConfAlbum conf;

        public ConfAlbum ConfAlbum
        {
            get
            {
                if (conf != null)
                    return conf;
                return ConfAlbums.Main; 
            }
            set { conf = value; }
        }

        public ConfAlbum getConf()
        {
            return conf; 
        }
        //private bool checkPub;
        //public bool CheckPub { get { return checkPub; } }

        //private bool checkDoublon;
        //public bool CheckDoublon { get { return checkDoublon; } }
        /// <summary>
        /// Nombre de tracks dans l'étape fraicheur (recent unAn, open)
        /// </summary>
        private int nbInStep;
        const int NB_STEP = 3;

        public void AddOrReplace(TrackInfoItunes track)
        {
            if (!list.Contains(track))
                Add(track, true);
            else
            {
                list.Remove(track);
                list.Add(track);
            }
        }

        public void Add(TrackInfoItunes track, bool calcSpec)
        {

            if (list.Contains(track))
            {
                list.Remove(track);
            }
            //if (!list.Contains(track))
            //  {
            list.Add(track);
            if (!calcSpec)
                return;
            if (track.Pub >= Conf.Date0)
            {
                if (!Recent)
                {
                    nbInStep++;
                    if (nbInStep >= NB_STEP)
                    {
                        nbInStep = 0;
                        setRecent();
                    }
                    return;
                }
                if (track.Pub >= dateUnAn)
                {
                    if (!UnAn)
                    {
                        nbInStep++;
                        if (nbInStep >= NB_STEP)
                        {
                            nbInStep = 0;
                            setUnAn();
                        }
                        return;
                    }
                }

                if (track.Pub >= dateOPen)
                {

                    if (!Open)
                    {
                        nbInStep++;
                        if (nbInStep >= NB_STEP)
                        {
                            setOpen();
                        }
                    }
                }

            }
            //  }

        }
        public void Remove(TrackInfoItunes track)
        {
            list.Remove(track);
        }
        //private bool sorted;
        public List<TrackInfoItunes> List
        {
            get
            {
                //if (!sorted)
                //{
                //    sorted = true;
                //    list.Sort(new PodCastComparer());
                //}
                return new List<TrackInfoItunes>(list);
            }
        }

        public int Count { get { return list.Count; } }

        public override string ToString()
        {
            return string.Format("{0} ({1})", Album, AlbumKey);
        }


        public int Rating
        {
            get { return AlbumRating; }
        }






        public util.timeSpan Duree
        {
            get { return util.timeSpan.MaxValue; }
        }

        public LimitItem Exclu
        {
            get
            {
                throw new NotImplementedException();
            }
            set
            {
                throw new NotImplementedException();
            }
        }

        public bool Histo
        {
            get { throw new NotImplementedException(); }
        }

        public DateTime Pub
        {
            get { throw new NotImplementedException(); }
        }

        public DateTime Pub2
        {
            get
            {
                throw new NotImplementedException();
            }
            set
            {
                throw new NotImplementedException();
            }
        }

        public bool Serial
        {
            get { throw new NotImplementedException(); }
        }

        public long Size
        {
            get { throw new NotImplementedException(); }
        }

        public const int NB_MIN_POUR_FREQUENT = 52;
        public bool RareEffect
        {
            get
            {
                if (Rare)
                    return true;
                if (_rareEffect == null)
                {
                    //combien il m'en reste à lire ? 
                    int nb = 0;
                    var maxGlobal = ConfAlbum.maxGlobal;
                    foreach (TrackInfoItunes t in list)
                    {
                        if (t.Played)
                            continue;
                        if (!t.Enabled)
                            continue;
                        if (t.Pub > Conf.Date0 || (maxGlobal > 0 && t.Duree.TotalMinute <= maxGlobal))
                        {
                            nb++;
                            if (nb >= NB_MIN_POUR_FREQUENT)
                            {
                                _rareEffect = false;
                                return false;
                            }
                        }
                    }
                    _rareEffect = true;
                }
                return _rareEffect.Value;
            }

        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Date0\DateRefBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using System.Xml;
using pdb.util;
using pdb.podcast.Albums;

namespace pdb.podcast.Date0
{
    class DateRefBuilder
    {
        /// <summary>
        /// Registre des éléments sélectionnables avant modif
        /// </summary>
        private HashSet<int> hs = new HashSet<int>();
        public void prepare(IEnumerable<TrackInfoItunes> list)
        {
            var conf = Conf.DateRef;
            if (!conf.auto)
                return;
            // DateTime next = DateTime.MaxValue;
            // TrackInfoItunes nextT = null;
            DateTime date0 = conf.date0;

            var serials = getSerials(); 
            foreach (TrackInfoItunes t in list)
            {
                var dt = t.Pub2;
                if (dt < date0)
                    continue;


                var globalDuree = t.TrackAlbum.ConfAlbum.maxGlobal;
                if (globalDuree < 0)
                    continue; //cas de rfi une semaine...
                if (t.Duree.TotalMinute < globalDuree)
                    continue;
                string album = t.Album; 
                if (serials.Contains(album))
                    continue;                
                hs.Add(t.DbId);
            }
        }

        private List<string> getSerials()
        {
            var list = new List<string>();
            var root = Conf.DirConf;
            buildListSerial(root, list);
            return list;
        }

        private void buildListSerial(DirConf dir, List<string> depot)
        {
            if (dir.UniqueAlbum)
                depot.Add(dir.Name);
            foreach (DirConf sub in dir)
                buildListSerial(sub, depot);

        }

        public bool autoSafe(List<TrackInfoItunes> list)
        {
            var conf = Conf.DateRef;
            if (!conf.auto)
                return false;
            DateTime next = DateTime.MaxValue;
            TrackInfoItunes nextT = null;
            DateTime date0 = conf.date0;
            foreach (TrackInfoItunes t in list)
            {
                if (!hs.Contains(t.DbId))
                    continue;
                var dt = t.Pub2;

                if (dt < next)
                {
                    var globalDuree = t.TrackAlbum.ConfAlbum.maxGlobal;
                    if (globalDuree < 0)
                        continue; //cas de rfi une semaine...
                    if (t.Duree.TotalMinute < globalDuree)
                        continue;
                    next = dt;
                    nextT = t;
                }
            }
            if (next != date0 && next < DateTime.MaxValue)
            {
                misc.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
                misc.log("date0 modifiée {0}=>{1} par {2}", date0, next, nextT);
                misc.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
                conf.date0 = next;
                conf.Write(Conf.Instance.ConfFile.FullName);
                return true;
            }
            return false;
        }


        public bool auto(List<TrackInfoItunes> list)
        {
            var conf = Conf.DateRef;
            if (!conf.auto)
                return false;
            DateTime next = DateTime.MaxValue;
            TrackInfoItunes nextT = null;
            DateTime date0 = conf.date0;
            foreach (TrackInfoItunes t in list)
            {
                var dt = t.Pub2;
                if (dt < date0)
                    continue;
                if (dt < next)
                {
                    var globalDuree = t.TrackAlbum.ConfAlbum.maxGlobal;
                    if (globalDuree < 0)
                        continue; //cas de rfi une semaine...
                    if (t.Duree.TotalMinute < globalDuree)
                        continue;
                    next = dt;
                    nextT = t;
                }
            }
            if (next > date0 && next < DateTime.MaxValue)
            {
                misc.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
                misc.log("date0 modifiée {0}=>{1} par {2}", date0, next, nextT);
                misc.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
                conf.date0 = next;
                conf.Write(Conf.Instance.ConfFile.FullName);
                return true;
            }
            return false;
        }

        public double getOffset()
        {
            var conf = Conf.DateRef;
            if (!conf.offset)
                return 0;
            DateTime date0 = conf.date0;
            DateTime old = conf.old;
            if (date0 == DateTime.MinValue || date0 == DateTime.MaxValue)
                return 0;
            if (old == DateTime.MinValue || old == DateTime.MaxValue)
                return 0;
            if (old >= date0)
                return 0;
            var ret = (date0 - old).TotalDays;
            misc.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
            misc.log("offset maxdate : " + ret.ToString("0.##"));
            misc.log("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
            return ret;

        }

        public void saveCurrent()
        {
            var conf = Conf.DateRef;
            conf.old = conf.date0;
            conf.Write(Conf.Instance.ConfFile.FullName);
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using pdb.podcast.Tuning;
using pdb.podcast.Albums;


namespace pdb.podcast.DB
{
    public class Db
    {
        public const string CURRENT_VERSION = "2.0";
        const string SEQ_PIECE = "seq";
        const string TOKEN_VERSION = "version";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        private BgDictString<TrackInfoItunes> dictUrl = new BgDictString<TrackInfoItunes>();
        private BgDict<int, TrackInfoItunes> dictId = new BgDict<int, TrackInfoItunes>();
        //  private Dictionary<string, TrackAlbum> dictAlbum;
        private volatile object _lock = new object();
        private AlbumMgr albumMgr = AlbumMgr.Instance;






        string FILE = "..\\db.xml";
        string FILE_STAT = "..\\db_stats.xml";
        //string HUMAN_FILE = "..\\dbh.xml";
        private List<string> sources = new List<string>();
        string SOV = "..\\sov\\";
        string zipSov;
        //   private XmlSerializer xmlSerializer;

        // private bool import;
        private bool loaded;
        private bool writing;
        public bool Writing { get { return writing; } }

        public Db()
        {
            var conf = Conf.Db;
            FILE = conf.file;
            FILE_STAT = conf.fileStat;
            SOV = conf.sov;
            zipSov = conf.sovZip.Replace("[date]", DateTime.Now.Date.ToString("yy-MM-dd"));
            foreach (DbSource source in conf.sources)
            {
                sources.Add(source.file);
            }

            // AlbumMgr albums = AlbumMgr.Instance;
            // dictAlbum = albums.Dict;

            // this.import = import;
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};


        }

        public List<TrackInfoItunes> Tracks
        {
            get
            {
                if (!loaded)
                {
                    lock (_lock)
                    {

                    }
                }

                var l = new List<TrackInfoItunes>(dictId.Values);
                return l;
            }
        }

        public TrackInfoItunes get(string location)
        {
            if (!loaded)
            {
                lock (_lock)
                {

                }
            }
            var shortName = TrackInfoItunes.getShortName(location);
            return dict[shortName];
        }

        //public TrackAlbum getAlbum(string album)
        //{
        //    return albumMgr.getOrNull(album); 
        //    //var key = album.toKey();
        //    //if (dictAlbum.ContainsKey(key))
        //    //    return dictAlbum[key];
        //    //return null;
        //}
        //public TrackAlbum create(string album)
        //{
        //    var key = album.toKey();
        //    var TrackAlbum = new TrackAlbum(album, key);
        //    dictAlbum.Add(key, TrackAlbum);
        //    return TrackAlbum;
        //}

        public TrackInfoItunes get(TrackInfoItunes w)
        {
            return dictId[w.DbId];
        }

        public TrackInfoItunes getByUrl(string url)
        {
            return dictUrl[url];
        }

        public void CheckToDownload(TrackInfoItunes track)
        {
            var url = track.Url;
            if (string.IsNullOrEmpty(url))
                throw new ArgumentException(string.Format("track={0} url NULL", track));
            if (dictUrl.ContainsKey(url))
                throw new ArgumentException(string.Format("track={0} url existe:{1}", track, url));
            dictUrl.Add(url, track);
            int id = ++pieceSequenceId;
            track.DbId = id;
            dictId[track.DbId] = track;
        }

        public void Check(TrackInfoItunes track)
        {
            var location = track.ShortName;
            var url = track.Url;
            if (string.IsNullOrEmpty(location) & string.IsNullOrEmpty(url))
                return;
            TrackInfoItunes dbTrack = null;
            if (!string.IsNullOrEmpty(location))
                dbTrack = dict[location];
            if (dbTrack == null && !string.IsNullOrEmpty(url))
                dbTrack = dictUrl[url];
            //if (dbTrack == null)
            //{
            //    var album = track.TrackAlbum; 
            //    if (album != null && album != TrackAlbum.NULL)
            //    {
            //        var mode = album.DownLoadMode;
            //        TrackInfoItunes org = null;
            //        var list = album.List.FindAll(t => !string.IsNullOrEmpty(t.Location));


            //        switch (mode)
            //        {
            //            case downloadMode.none:
            //                break;
            //            case downloadMode.no:
            //                break;
            //            case downloadMode.last: org = list.Find(t => t.Pub == track.Pub);
            //                break;
            //            case downloadMode.onePerDay: org = list.Find(t => t.Pub.Date == track.Pub.Date);
            //                break;
            //            case downloadMode.onePerMin: org = list.Find(t => t.Pub == track.Pub);
            //                break;
            //            case downloadMode.multiple: org = list.Find(t => t.Pub == track.Pub && t.LogicalName == track.LogicalName);
            //                break;
            //            default:
            //                break;
            //        }

            //        if (org != null && !string.IsNullOrEmpty(org.Location))
            //            dbTrack = dict[org.Location]; 

            //    }
            //}
            if (dbTrack == null)
            {
                int id = ++pieceSequenceId;
                track.DbId = id;
                albumMgr.setAlbum(track, track.Album);
            }
            else
            {
                if (dbTrack != track)
                {
                    track.DbId = dbTrack.DbId;
                    dbTrack.Album = track.Album;
                    if (string.IsNullOrEmpty(dbTrack.Location))
                    {
                        dbTrack.Location = track.Location;
                    }

                    if (string.IsNullOrEmpty(track.Location))
                    {
                        track.Location = dbTrack.Location;
                    }

                    if (string.IsNullOrEmpty(dbTrack.Url))
                    {
                        dbTrack.Url = track.Url;
                    }

                    if (string.IsNullOrEmpty(track.Url))
                    {
                        track.Url = dbTrack.Url;
                    }

                    dbTrack.merge(track);
                }

                //if (import)
                //{
                //    track.import(dbTrack);
                //}
            }
            if (track.Pub2 < track.Pub)
            {
                var pub2 = track.Pub2.truncateToMinute();
                var pub = track.Pub.truncateToMinute();
                if (pub2 < pub)
                    track.Pub2 = pub;
            }

            location = track.ShortName;
            if (!string.IsNullOrEmpty(location))
            {
                track.Present = true;
                dict[location] = track;
            }
            if (!string.IsNullOrEmpty(url))
                dictUrl[url] = track;
            dictId[track.DbId] = track;



        }

        //public void Import(IEnumerable<TrackInfoItunes> listIt)
        //{
        //    foreach (TrackInfoItunes it in listIt)
        //    {
        //        var location = it.ShortName;
        //        var tdb = dict[location];
        //        if (tdb == null)
        //            continue;

        //        it.import(tdb);
        //    }
        //}

        //public void createIfExist(pdb.it.ITrackBuilder loader, List<TrackInfoItunes> listIt)
        //{
        //    foreach (TrackInfoItunes tdb in dict.Values)
        //    {
        //        if (tdb.isPresent())
        //        {
        //            loader.createTrack(tdb, true);
        //            tdb.import();
        //        }
        //    }
        //}



        public void load()
        {
            lock (_lock)
            {
                try
                {
                    var strVersion = "1";
                    TrackAlbum currentAlbum = null;
                    // string currentAlbumName = null;
                    using (XmlReader reader = XmlReader.Create(FILE))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {
                                    var seq = reader.GetAttribute(SEQ_PIECE);
                                    pieceSequenceId = Convert.ToInt32(seq);
                                    strVersion = reader.GetAttribute(TOKEN_VERSION);
                                }
                                else if (reader.Name == "a")
                                {
                                    currentAlbum = readAlbum(reader);
                                    // currentAlbumName = currentAlbum.Album.toKey();
                                    //if (dictAlbum.ContainsKey(currentAlbumName))
                                    //{
                                    //    currentAlbum = dictAlbum[currentAlbumName];
                                    //}
                                    //else
                                    //    dictAlbum.Add(currentAlbumName, currentAlbum);
                                }
                                else if (reader.Name == "t")
                                {
                                    var t = read(reader, currentAlbum);
                                    dict[t.ShortName] = t;
                                    if (!string.IsNullOrEmpty(t.Url))
                                        dictUrl[t.Url] = t;
                                    dictId[t.DbId] = t;
                                }

                                else if (reader.Name == "u")
                                {
                                    currentAlbum.Urls.Add(reader.GetAttribute("url"));
                                }
                            }
                        }

                    }

                    using (XmlReader reader = XmlReader.Create(FILE_STAT))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {

                                }
                                else
                                {
                                    int id = Convert.ToInt32(reader.GetAttribute("id"));


                                    var t = dictId[id];
                                    if (t == null)
                                    {
                                        string loc = reader.GetAttribute("f");
                                        Program.log.log("track {0} dans les stats non vu dans db {1}", id, loc);
                                    }
                                    else
                                    {
                                        t.readStat(reader);
                                        t.readStatGlobal(reader);
                                    }
                                }
                            }
                        }

                    }


                    foreach (string source in sources)
                    {
                        try
                        {
                            using (XmlReader reader = XmlReader.Create(source))
                            {
                                while (reader.Read())
                                {
                                    if (reader.NodeType == XmlNodeType.Element)
                                    {
                                        if (reader.Name == "db")
                                        {

                                        }
                                        else
                                        {
                                            int id = Convert.ToInt32(reader.GetAttribute("id"));


                                            var t = dictId[id];
                                            if (t == null)
                                            {

                                            }
                                            else
                                            {
                                                t.readStatGlobal(reader);
                                            }
                                        }
                                    }
                                }

                            }
                        }

                        catch (Exception ex)
                        {
                            misc.log(ex);
                        }
                    }


                    //using (XmlReader reader = XmlReader.Create(GLOBAL_STAT))
                    //{
                    //    while (reader.Read())
                    //    {
                    //        if (reader.NodeType == XmlNodeType.Element)
                    //        {
                    //            if (reader.Name == "db")
                    //            {

                    //            }
                    //            else
                    //            {
                    //                int id = Convert.ToInt32(reader.GetAttribute("id"));


                    //                var t = dictId[id];
                    //                if (t == null)
                    //                {
                    //                    string loc = reader.GetAttribute("f");
                    //                    Program.log.log("track {0} dans les global stats non vu dans db {1}", id, loc);
                    //                }
                    //                else
                    //                {
                    //                    t.readStatGlobal(reader);
                    //                    t.consolidStat();
                    //                }
                    //            }
                    //        }
                    //    }

                    //}

                    foreach (TrackInfoItunes t in dictId.Values)
                    {
                        if (t.ParentId > 0)
                            t.Parent = dictId[t.ParentId];
                    }

                }

                finally
                {
                    loaded = true;
                }
            }
        }


        private void readUrl(XmlReader reader, TrackAlbum currentAlbum)
        {
        }

        private TrackInfoItunes read(XmlReader reader, TrackAlbum currentAlbum)
        {
            var t = new TrackInfoItunes();

            //if (album != null)
            //{
            t.TrackAlbum = currentAlbum;

            // }
            t.build(reader);


            currentAlbum.Add(t, true);
            return t;
        }

        private TrackAlbum readAlbum(XmlReader reader)
        {
            string name = reader.GetAttribute("name");
            var album = albumMgr.Get(name);
            if ("y" == reader.GetAttribute("rare"))
                album.setRare();
            if ("y" == reader.GetAttribute("info"))
                album.setInfo();
            if ("y" == reader.GetAttribute("actu"))
                album.setActu();
            if ("y" == reader.GetAttribute("courant"))
                album.setCourant();


            var str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                album.AlbumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("note");
            if (!string.IsNullOrEmpty(str))
                album.Note = Convert.ToDouble(str);

            str = reader.GetAttribute("download");
            if (!string.IsNullOrEmpty(str))
                album.DownLoadMode = (downloadMode)Enum.Parse(typeof(downloadMode), str, true);
            else
                album.DownLoadMode = downloadMode.none;

            return album;
        }

        private void write(XmlWriter writer, TrackAlbum album)
        {
            writer.WriteStartElement("a");
            try
            {
                var list = album.List;

                writer.WriteAttributeString("name", album.Album);
                writer.WriteAttributeString("nb", list.Count.ToString());
                if (album.AlbumRating > 0)
                    writer.WriteAttributeString("rating", album.AlbumRating.ToString());
                if (album.Note != 0)
                    writer.WriteAttributeString("note", album.Note.ToString("0.##"));
                if (album.Rare)
                    writer.WriteAttributeString("rare", "y");
                else if (album.RareEffect)
                    writer.WriteAttributeString("rareEffect", "y");
                if (album.Info)
                    writer.WriteAttributeString("info", "y");
                if (album.Actu)
                    writer.WriteAttributeString("actu", "y");
                if (album.Courant)
                    writer.WriteAttributeString("courant", "y");

                writer.WriteAttributeString("spec", album.Specif.ToString());
                if (album.DownLoadMode > downloadMode.none)
                    writer.WriteAttributeString("download", album.DownLoadMode.ToString());


                list.Sort(new TrackComparer());
                // list.Sort(new PodCastComparer());

                TrackInfoItunes last = null;
                var l2 = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (t.TrackAlbum == null || t.TrackAlbum == TrackAlbum.NULL)
                        t.TrackAlbum = album;  // = album; 
                    //if (t.Deleted)
                    //    listDeleted.Add(t);
                    // else
                    if (!Conf.Db.purgemissing || (string.IsNullOrEmpty(t.Location) && !string.IsNullOrEmpty(t.Url)) || t.isPresent())
                    {
                        l2.Add(t); // write(writer, t, false);
                        last = t;
                    }
                    else
                        listMissing.Add(t);
                }
                if (last != null)
                {
                    writer.WriteAttributeString("lastPub", last.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                    writer.WriteAttributeString("last", last.Name);
                }

                foreach (string url in album.Urls)
                {
                    writer.WriteStartElement("u");
                    writer.WriteAttributeString("url", url);
                    writer.WriteEndElement();
                }

                foreach (TrackInfoItunes t in l2)
                {
                    write(writer, t, false);
                }
            }
            catch (Exception ex)
            {
                misc.log("impossible d'enregistrer {0} {1}", album.Album, ex);
            }
            writer.WriteEndElement();

        }

        private static void write(XmlWriter writer, TrackInfoItunes track, bool writeAlbum)
        {
            try
            {
                writer.WriteStartElement("t");
                writer.WriteAttributeString("id", track.DbId.ToString());
                if (track.HasParent)
                    writer.WriteAttributeString("pid", track.Parent.DbId.ToString());
                if (track.Pub > DateTime.MinValue)
                    writer.WriteAttributeString("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                var location = track.Location;
                if (!string.IsNullOrEmpty(location))
                {
                    if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                    {
                        location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                    }


                }
                writer.WriteAttributeString("f", location);
                if (writeAlbum)
                    writer.WriteAttributeString("alb", track.Album);
                else if (track.TrackAlbum.Album.toKey() != track.Album.toKey())
                    writer.WriteAttributeString("alb", track.Album);
                if (track.Note < int.MaxValue && track.isConcernedBySelection)
                    writer.WriteAttributeString("note", track.Note.ToString("0.##"));
                writer.WriteAttributeString("name", track.Name);

                if (track.Pub2 > DateTime.MinValue && track.Pub2 > track.Pub)
                    writer.WriteAttributeString("pub2", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                if (track.PlayedDate > DateTime.MinValue)
                    writer.WriteAttributeString("date", track.PlayedDate.ToString());
                if (track.PlayCount > 0)
                    writer.WriteAttributeString("nbr", track.PlayCount.ToString());
                //if (track.AlbumRating > 0)
                //    writer.WriteAttributeString("albumRating", track.AlbumRating.ToString());
                if (track.Rating != track.AlbumRating)
                    writer.WriteAttributeString("rating", track.Rating.ToString());


                //if (track.RatingComputed)
                //    writer.WriteAttributeString("computed", "y");
                //if (track.Rare)
                //    writer.WriteAttributeString("rare", "y");
                //if (track.Info)
                //    writer.WriteAttributeString("info", "y");
                var duree = track.Duree;
                if (duree.Value > 0)
                {
                    writer.WriteAttributeString("d", duree.Value.ToString("0"));
                    var size = track.Size;
                    if (size > 0)
                        writer.WriteAttributeString("s", size.ToString());
                }

                //if (!track.Enabled)
                //    writer.WriteAttributeString("disabled", "y");
                var dtDisabled = track.Disabled;
                if (dtDisabled == DateTime.MinValue)
                    writer.WriteAttributeString("dd", "y");
                else if (dtDisabled < DateTime.MaxValue)
                    writer.WriteAttributeString("dd", dtDisabled.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));


                if (track.Added > DateTime.MinValue)
                    writer.WriteAttributeString("add", track.Added.ToString());
                if (track.AddedFirst > DateTime.MinValue && track.AddedFirst < track.Added)
                    writer.WriteAttributeString("add1", track.AddedFirst.ToString());

                if (!string.IsNullOrEmpty(track.Description))
                {
                    try
                    {
                        writer.WriteAttributeString("desc", track.Description.Replace("!!", ""));
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible décrire la description de {0} id={1} {2} {3}", track, track.DbId, track.Description, ex);
                    }
                }


                if (!string.IsNullOrEmpty(track.LongDescription))
                {
                    try
                    {
                        writer.WriteAttributeString("ldesc", track.LongDescription.Replace("!!", ""));
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible décrire la description longue de {0} id={1} {2} {3}", track, track.DbId, track.LongDescription, ex);
                    }
                }

                try
                {
                    var comment = track.Comment;
                    if (!string.IsNullOrEmpty(comment))
                    {
                        var build = track.buildComment();
                        if (comment != build)
                            writer.WriteAttributeString("comment", comment);
                    }
                }
                catch (Exception ex)
                {
                    misc.log("impossible de vérifier comment de {0} id={1} {2}", track, track.DbId, ex);
                }


                if (!string.IsNullOrEmpty(track.HibernateLocation))
                    writer.WriteAttributeString("hl", track.HibernateLocation);

                if (!string.IsNullOrEmpty(track.Url))
                    writer.WriteAttributeString("url", track.Url);

            }
            catch (Exception ex)
            {
                misc.log("impossible d'enregistrer {0} {1} {2}", track.DbId, track, ex);
            }

            writer.WriteEndElement();

        }

        private static void writeStat(XmlWriter writer, TrackInfoItunes track)
        {
            if (track.In > DateTime.MinValue)
            {
                writer.WriteStartElement("t");
                writer.WriteAttributeString("id", track.DbId.ToString());
                var location = track.Location;
                if (!string.IsNullOrEmpty(location))
                {
                    if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                    {
                        location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                    }


                }
                writer.WriteAttributeString("f", location);



                if (track.Out == DateTime.MinValue || track.In < track.Out)
                {
                    writer.WriteAttributeString("in", track.In.ToString());
                    if (track.Out > DateTime.MinValue)
                        writer.WriteAttributeString("out", track.Out.ToString());
                }
                else
                {
                    writer.WriteAttributeString("out", track.Out.ToString());
                    writer.WriteAttributeString("in", track.In.ToString());
                }


                writer.WriteEndElement();
            }

        }

        public void recordIt(IEnumerable<TrackInfoItunes> listIt)
        {
            using (System.IO.StreamWriter sw = new StreamWriter(@"..\load.txt"))
            {
                if (listIt != null)
                {
                    foreach (TrackInfoItunes t in listIt)
                    {
                        Check(t);
                        sw.Write(t.ID);
                        sw.Write("\t");
                        sw.Write(t.Location);
                        sw.Write("\t");
                        sw.WriteLine(t.Url);
                    }
                }
            }
        }

        private List<TrackInfoItunes> listMissing;
        private List<TrackInfoItunes> listDeleted;
        private class TrackComparer : IComparer<TrackInfoItunes>
        {
            public virtual int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                int cmp = x.Pub.CompareTo(y.Pub);
                if (cmp != 0)
                    return cmp;
                return x.DbId.CompareTo(y.DbId);
            }
        }

        private class TrackComparerInv : TrackComparer
        {
            public override int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                return -base.Compare(x, y);
            }
        }

        public void writeAsync()
        {
            new ThreadUtil(write, "db.write").Start();
        }
        public void write()
        {
            misc.log("db::write");
            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            var listZip = new List<string>();
            lock (_lock)
            {
                writing = true;
                try
                {
                    if (!Directory.Exists(SOV))
                        Directory.CreateDirectory(SOV);
                    ZipUtil.Exe = @"C:\Program Files\7-Zip\7z.exe";
                    // ZipUtil.Enter();
                    //ZipUtil.CompressAsync(zipSov, FILE, true); 
                    var destCopy = string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE));
                    File.Copy(FILE, destCopy, true);
                    listZip.Add(destCopy);
                    //  ZipUtil.CompressAsync(zipSov, timeStamp, new List<string> { destCopy }, false); 

                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                finally
                {
                    // ZipUtil.Release();
                }


                listMissing = new List<TrackInfoItunes>();
                listDeleted = new List<TrackInfoItunes>();

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(FILE + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());

                    //AlbumMgr mgr = TrackInfoItunes.AlbumMgr as AlbumMgr;
                    var albums = albumMgr.List;

                    //albums.Sort(new TrackComparer()); 
                    albums.Sort((x, y) => x.Album.CompareTo(y.Album));

                    foreach (TrackAlbum album in albums)
                    {
                        write(writer, album);
                    }

                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE + ".tmp", FILE, true);



                if (listMissing.Count > 0)
                {
                    string missing = string.Format("{0}{1}__missing.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(missing, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            write(writerMissing, track, true);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }

                    listZip.Add(missing);

                }

                if (listDeleted.Count > 0)
                {
                    var deleted = string.Format("{0}{1}__deleted.xml", SOV, timeStamp);
                    using (XmlWriter writerDeleted = XmlWriter.Create(deleted, settings))
                    {
                        writerDeleted.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            write(writerDeleted, track, true);
                        }
                        writerDeleted.WriteEndDocument();
                        writerDeleted.Flush();
                    }
                    listZip.Add(deleted);
                }
                var destCopyStat = string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE_STAT));
                if (File.Exists(FILE_STAT))
                {
                    File.Copy(FILE_STAT, destCopyStat, true);
                    listZip.Add(destCopyStat);
                }

                using (XmlWriter writer = XmlWriter.Create(FILE_STAT + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    var tracks = Tracks;
                    tracks.Sort(new PodCastComparer());
                    foreach (TrackInfoItunes track in tracks)
                    {
                        if (!Conf.Db.purgemissing || (string.IsNullOrEmpty(track.Location) && !string.IsNullOrEmpty(track.Url)) || track.isPresent())
                            writeStat(writer, track);
                    }
                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE_STAT + ".tmp", FILE_STAT, true);

                // listZip.Add(FILE_STAT); 

                if (listMissing.Count > 0)
                {
                    var missing = string.Format("{0}{1}__missing_stat.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(missing, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }
                    listZip.Add(missing);

                }

                if (listDeleted.Count > 0)
                {
                    var deletedStat = string.Format("{0}{1}__deleted_stat.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(deletedStat, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }
                    listZip.Add(deletedStat);

                }
                misc.log("db::fin write");
                ZipUtil.Compress(zipSov, null, listZip, false, false);
                misc.log("db::fin write et zip");
                //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                writing = false;
            }
        }


        // géopolitique 4 par défaut rating ->80 albumrating ->80 computed =true
        //RFI 0 de temps en temps surcharge pour un par défaut : rating null albumrating->20 computed = true
        //                                  pour un syrchargé  : rating non null ""   
        // adele 1                          pour les défaut   rating:20 album 20 computed
        //                                  pour un surchargé 4 rating 80 album 20 non computed

        //C'est quand même gavant. il fait pas la différence entre les étoiles pleines et creuses
        //prenons adele defaut : 20 /20 computed
        //          autre        80 /20 non computed


        // ayo album zero surcharge 1 deux étoiles creuses => 20/40/computed

        //Ah ok . cas computed 1. album=rating => c'est bien level album
        //                        album != rating => c'est bidon  "étoile creuse"                                
        //        sinon on lit directement level album

        // Quel con j'ai pas vu qu'il y avait RatingComputed et Album Rating computed
        // je me le refele
        //géopolitique ratinet alubm => 80 ratingComputed
        // RFi  defaut rating null album 20 albumcomputed
        //      surchargé   rating 20 idem     
        // adele defaut rating 20 rating computed albumrating 20




    }
}]]></content>
  </file>
  <file path="db4\pdb.util\FileUtil.cs">
    <content><![CDATA[using System;
using System.IO;

using Microsoft.Win32;

namespace pdb.util
{
    /// <summary>
    /// Utilitaires de manipulation de fichiers
    /// </summary>
    public static class FileUtil
    {
        public const long KILO = 1024;
        public const long MEGA = KILO * KILO;
        public const long GIGA = MEGA * KILO;
        public const long TERA = GIGA * KILO;
        public const long PETA = GIGA * KILO;

        /// <summary>
        /// Enregistrement d'un fichier sans limite max
        /// </summary>
        /// <param name="input"></param>
        /// <param name="path"></param>
        public static void RecordFile(Stream input, String path)
        {
            RecordFile(input, path, long.MaxValue);
        }

        /// <summary>
        /// Enregistrement d'un fichier avec une limite de taille
        /// </summary>
        /// <param name="input">Flux d'entrée</param>
        /// <param name="path">Chemin destination</param>
        /// <param name="sizeMax">taille maximum gérée (en octets)</param>
        /// <remarks>Lance toutes les IO.Exceptions</remarks>
        public static void RecordFile(Stream input, String path, long sizeMax)
        {
            if (input.Length > sizeMax)
            {
                throw new ApplicationException("Exception manipulation du fichier : taile flux > SizeMax ");
            }

            using (input)
            {
                using (Stream sFile = new FileStream(path, FileMode.Create))
                {
                    const int BUF_LENGHT = 4096;

                    byte[] buf = new byte[BUF_LENGHT];
                    int nb = input.Read(buf, 0, BUF_LENGHT);
                    while (nb > 0)
                    {
                        sFile.Write(buf, 0, nb);
                        nb = input.Read(buf, 0, BUF_LENGHT);
                    }

                }
            }

        }

        public static byte[] ReadFile(String path)
        {
            byte[] tab;
            using (Stream fs = new FileStream(path, FileMode.Open))
            {
                tab = new byte[fs.Length];
                fs.Read(tab, 0, tab.GetLength(0));
            }
            return tab;
        }

        public static MemoryStream getStream(String path)
        {
            using (Stream fs = new FileStream(path, FileMode.Open))
            {
                MemoryStream memStr = new MemoryStream();
                const int BUF = 4096;
                byte[] buffer = new byte[BUF];
                int nb = 0;
                while ((nb = fs.Read(buffer, 0, BUF)) > 0)
                {
                    memStr.Write(buffer, 0, nb);
                }
                memStr.Flush();
                memStr.Position = 0;
                return memStr;
            }
        }

        /// <summary>
        /// Fournit la taille d'un fichier user friendly
        /// </summary>
        /// <param name="size"></param>
        /// <returns></returns>
        public static String HumanReadableSize(this long size, int level)
        {
            //level <=0 ==>3.6 Mo
            // level ==0 ==> 3 Mo
            // level == 1 ==> 3 Mo 614 Ko

            if (size > PETA)
            {
                return getHumanParty(size, TERA, "Po", level);
            }

            if (size > TERA)
            {
                return getHumanParty(size, TERA, "To", level);
            }

            if (size > GIGA)
            {
                return getHumanParty(size, GIGA, "Go", level);
            }

            if (size > MEGA)
            {
                return getHumanParty(size, MEGA, "Mo", level);
            }
            if (size > KILO)
            {
                return getHumanParty(size, KILO, "Ko", level);
            }

            return getHumanParty(size, 1, "o", level);
        }

        private static String getHumanParty(long size, long kilo, String unite, int level)
        {
            double ratio = (double)size / kilo;
            int partie = (int)Math.Floor(ratio);
            long reste = size - partie * kilo;

            if (reste == 0 || level == 0 || kilo == 1)
                return string.Format("{0} {1}", partie, unite);

            if (level < 0)
            {
                return string.Format("{0:0.###} {1}", ratio, unite);
            }

            return string.Format("{0} {1} {2}", partie, unite, HumanReadableSize(reste, level - 1));


            //if (level>0)
            //    return String.Format("{0} {1}{2}", partie, unite, reste == 0 ? "" : " " + HumanReadableSize(reste, complete));
            //else
            //{
            //    if (reste == 0)
            //        return (string.Format("{0} {1}", partie, unite)); 
            //    else 
            //    {

            //    }

            //}

            //    return string.Format("{0} {1}{2}", partie, reste == 0 ? "" : "." + HumanReadableSize(reste, complete));
        }

        public static String getMimeType(this String file)
        {
            var contentType = "application/octet-stream";
            String ext = Path.GetExtension(file);
            try
            {

                var fileClass = Registry.ClassesRoot.OpenSubKey(ext);
                contentType = fileClass.GetValue("Content Type").ToString();
            }
            catch
            {
                switch (ext)
                {
                    case ".doc":
                    return "application/msword";
                    case ".docx":
                    return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                    case ".ppt":
                    return "application/vnd.ms-powerpoint";
                    case ".pptx":
                    return "application/vnd.openxmlformats-officedocument.presentationml.presentation";
                    case ".xls":
                    return "application/vnd.ms-excel";
                    case ".xlsx":
                    return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
                    case ".pdf":
                    return "application/pdf";
                    case ".xml":
                    return "text/xml";
                    case ".csv":
                    return "application/vnd.ms-excel";
                    case ".zip":
                    return "application/zip";
                    case ".txt":
                    return "text/plain";
                    default:
                    break;
                }
            }
            return contentType;
        }

        //public static FileInfo findFile(String directory, String seq_id)
        //{
        //    DirectoryInfo dir = new DirectoryInfo(directory);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        if (file.Name.StartsWith(seq_id))
        //            return file;
        //    }
        //    return null;
        //}
    }
}
]]></content>
  </file>
  <file path="db4\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;
//using pdb.it.Albums;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        protected static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        //protected static IAlbumMgr albumMgr;
        //public static IAlbumMgr AlbumMgr { set { albumMgr = value; } get { return albumMgr; } }
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        // private TrackPlayListManager listManager = new TrackPlayListManager();
      //  private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        //private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        //private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        // private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        //private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        protected static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);
        protected static BackGroundTaskMgr bgImport = BackGroundTaskMgr.getMgr("Import", 0);
        protected static BackGroundTaskMgr bgHibernate = BackGroundTaskMgr.getMgr("Hibernate", 0);
        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }

        //public virtual void setAlbum(string album)
        //{
        //    albumMgr.setAlbum(this, album);
        //}

        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            this.album = track.Album; 
            
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;

            fillDesc(track);




        }

        private void FIll(IITURLTrack track)
        {
            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            this.album = track.Album; 
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            // this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            //  this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;
            this.location = track.URL;
            if (string.IsNullOrEmpty(description))
                description = track.Description;
            if (string.IsNullOrEmpty(longDescription))
                longDescription = track.LongDescription;
        }

        public virtual bool Played { get { return this.playCount > 0; } }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present;
        public bool Present
        {
            get { return present; }
            set { present = value; }
        }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location": Uri uri = new Uri(value);
                        return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.PlayedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded;


            Fill();
        }

        public void build(IITURLTrack track)
        {
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded;
            FIll(track);
        }



        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0;
            string key = "";
            bool nextIgnore = false;
            _isPodCast = false;


            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;
               
                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value;
                        break;
                    case "Artist": artist = value; break;
                    case "Album": album = value; break; // albumMgr.setAlbum(this, value); break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": PlayedDate = Convert.ToDateTime(value); break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;// Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet") || value.Equals("Flux audio MPEG"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                fillDesc(tracktrack);
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        private string description;
        private string longDescription;

        public string Description { get { return description; } protected set { description = value; } }
        public string LongDescription { get { return longDescription; } protected set { longDescription = value; } }


        public void fillDesc(IITFileOrCDTrack track)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(description))
                description = track.Description;
            if (string.IsNullOrEmpty(longDescription))
                longDescription = track.LongDescription;
        }
        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return TrackTrack;

                fillDesc(track);
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        private static BackGroundTaskMgr bgArtist = BackGroundTaskMgr.getMgr("Artist", 0);
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;
                if (string.IsNullOrEmpty(location))
                    artist = value;
                else
                {
                    bgArtist.add(new Bgtask(() =>
                    {
                        Track.Artist = value;
                        artist = value;
                    }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                    ));
                }


            }
        }
        //protected IAlbum _album;
        //public IAlbum TrackAlbum { get { return _album; } set { _album = value; } }
        private static BackGroundTaskMgr bgAlbum = BackGroundTaskMgr.getMgr("Album", 0);
        public virtual string AlbumKey { get { return Album.toKey(); } }
        protected string album; 
        public virtual string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value == null || value.Equals(album)) return;
                if (string.IsNullOrEmpty(location))
                    album = value;
                else
                {
                    bgAlbum.add(new Bgtask(() =>
                    {
                        // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                        Track.Album = value;
                       // albumMgr.setAlbum(this, value);
                    }, this,
                    "change album from '{0}' to'{1}' {2}", Album, value, this
                    ));
                }

            }
        }
        protected string name = "";
        private static BackGroundTaskMgr bgName = BackGroundTaskMgr.getMgr("Name", 0);
        public virtual string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;
                if (string.IsNullOrEmpty(location))
                    name = value;
                else
                {

                    int lengh = 0;
                    if (name != null)
                        lengh = name.Length;

                    if (value.Length < lengh)
                    {
                        log.log("Attention On raccourcit le nom !!! {0}->{1} {2}", name, value, this);
                        // return; 
                    }




                    var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                    bgName.add(bgtaskName);
                }

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }

        protected string composer = "";
        private static BackGroundTaskMgr bgComposer = BackGroundTaskMgr.getMgr("Composer", 0);
        public virtual string Composer
        {
            get
            {
                if (present && string.IsNullOrEmpty(composer))
                {
                    var t = Track;
                    if (t != null)
                        composer = t.Composer;
                }
                return composer;
            }
            set
            {
                if (!present)
                {
                    composer = value;
                    return;
                }

                if (value == null || value.Equals(composer)) return;

                var t = Track;
                if (t != null)
                    composer = t.Composer;
                if (value.Equals(composer))
                    return;


                var bgtaskComposer = new BgTaskComposer(this, string.Format("change composer from '{0}' to '{1}' {2}", composer, value, this), value);
                bgComposer.add(bgtaskComposer);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }


        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        //private bool firstClass;
        //public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        protected static BackGroundTaskMgr bgComment = BackGroundTaskMgr.getMgr("Comment", 0);
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                // firstClass = false;
                if (comment != value)
                {
                    //try
                    //{
                    //    var tab0 = comment.Split(' ');
                    //    var tab1 = value.Split(' ');

                    //    var count0 = tab0.GetLength(0);
                    //    var count1 = tab1.GetLength(0);

                    //    if (count0 != count1)
                    //        firstClass = true;

                    //    else if (comment.Length > 3)
                    //    {
                    //        string org = tab0[count0 - 1];
                    //        string fin = tab1[count1 - 1];

                    //        firstClass = !org.Equals(fin);
                    //    }
                    //}

                    //catch
                    //{
                    //    firstClass = true;
                    //}

                    //var sb = new StringBuilder();
                    //sb.Append(ClassName);
                    //sb.Append(".");
                    //sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format(" change comment from '{0}' to '{1}' {2}", comment, value, this), value);

                    //if (firstClass)
                    //    bgFirstClass.add(task);
                    //else
                    bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled = true;
        public virtual bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        protected bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        private DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                return playedDate;
            }

            set
            {
                if (playedDate > DateTime.MinValue)
                {
                    var dt = (value - playedDate).TotalHours;
                    if (dt > 2 || dt < -2)
                        playedDate = value;
                    else
                        return;

                }
                playedDate = value;
            }
        }
        protected string location;
        public virtual string Location
        {
            get { return location; }
            set { location = value; }
        }

        protected string url;
        public string Url
        {
            get { return url; }
            set
            {
                if (string.IsNullOrEmpty(url))
                    url = value;
            }

        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }

            set
            {
                if (!present)
                {
                    grouping = value;
                    return;
                }
                if (grouping != value)
                {
                    var task = new BgTaskGrouping(this, string.Format("change grouping from '{0}' to'{1}' {2}", grouping, value, this), value);
                    bgg.add(task);
                }
            }


        }

        //public void setGrouping(string value, bool prior)
        //{
        //    if (!present)
        //    {
        //        grouping = value;
        //        return;
        //    }
        //    if (grouping != value)
        //    {
        //        bool _delta = false;
        //        // bool _deltaRank = false; 
        //        string rankAlbum = "";
        //        string equivAlbum = "";
        //        if (value != null)
        //        {
        //            string[] org = grouping.Split(' ');
        //            string[] _new = value.Split(' ');

        //            int count = org.GetLength(0);
        //            if (_new.GetLength(0) != count || count < 3)
        //                _delta = true;
        //            else
        //            {
        //                rankAlbum = _new[1];
        //                equivAlbum = _new[2];
        //                if (!org[1].Equals(_new[1]))
        //                {
        //                    _delta = true;
        //                }
        //            }
        //        }

        //        var sb = new StringBuilder();
        //        sb.Append(rankAlbum);
        //        sb.Append(" ");
        //        sb.Append(equivAlbum);
        //        sb.Append(" ");
        //        sb.Append(Album);
        //        //sb.Append(ClassName);
        //        //sb.Append(".");
        //        //sb.Append((Rating / 20).ToString());

        //        var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

        //        if (firstClass)
        //        {
        //            bgSeconClass.add(task);
        //            return;
        //        }

        //        //if (prior)
        //        //{
        //        //    bgGroupPrior.add(task);
        //        //    return;
        //        //}



        //        if (_delta)
        //        {
        //            if (prior)
        //                bgGroupPrior.add(task);
        //            else
        //                bgGroup2nd.add(task);
        //            return;
        //        }

        //        bgg.add(task);

        //        //if (_delta)
        //        //    bgGroupDelta.add(task);
        //        //else
        //        //{
        //        //    bgg.add(task);
        //        //}
        //        //  grouping = value;
        //    }
        //}



        private int volume;
        private static BackGroundTaskMgr bgVolume = BackGroundTaskMgr.getMgr("Volume", 0);
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgVolume.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        //public List<CPlayList> PLayLists
        //{
        //    get { return listManager.PLayLists; }
        //}

        //public List<CPlayList> ClassPlayLists
        //{
        //    get { return listManager.ClassPlayLists; }
        //}

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    listManager.AddPlayList(a_playList);
        //    // className = listManager.ClassName;
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    listManager.removePlayList(list);
        //    // className = listManager.ClassName;
        //}


        //public string ClassName
        //{
        //    get
        //    {
        //        className = listManager.ClassName;
        //        return className;
        //    }
        //    set
        //    {
        //        className = listManager.ClassName;
        //        if (className != value)
        //        {
        //            bgClass.add(new Bgtask(() =>
        //            {
        //                loader.setClassPlayList(this, className, value);
        //                className = value;
        //            }, this,
        //           "change className from '{0}' to'{1}' {2}", className, value, this));


        //            //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
        //            //className = value;
        //            //OnClassNameChange(value);
        //        }
        //    }
        //}
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }
        private static BackGroundTaskMgr bgDelete = BackGroundTaskMgr.getMgr("Delete", 10);
        public void Delete()
        {
            if (tracktrack != null)
            {
                log.log("!delete! {0}", this);
                tracktrack.Delete();
            }
            else
                bgDelete.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        protected class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComposer : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComposer(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Composer = value;
                    info.composer = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getLocation()
        {
            return location;
        }

        private DateTime added;
        public virtual DateTime Added
        {
            get { return added; }
            set { added = value; }
        }



        public string strClassement
        {
            get { throw new NotImplementedException(); }
        }

        public Classement DeepClassement
        {
            get { throw new NotImplementedException(); }
        }


        public Classement MaxClassement
        {
            get { throw new NotImplementedException(); }
        }

        public Classement Classement
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        public IMasterPiece MasterPiece
        {
            get
            {
                throw new NotImplementedException();
            }
        }
    }
}



]]></content>
  </file>
</db>
