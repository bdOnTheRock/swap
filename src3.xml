<db path="C:\bernard\db1\db4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.obj;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static Logger logPerf = Logger.getLogger("Perf");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            var xmlConf = CConf.loadConf();
            pdb.player.ViewModel.Colors.MementoColor.recover();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        private static bool changing;
        public static void setChanging() { changing = true; }
        public static void releaseChanging() { changing = false; }
        public static void invalidateAlbums()
        {
            if (gen == null)
                return;

            gen.invalidateAlbums();
            if (changing)
                return;
            go();
        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                var xmlConf = CConf.loadConf();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");



                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0);
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }

        private static void resetOneCl()
        {
            lock (_lock)
            {
                try
                {
                    if (CConf.ResetOneCl)
                    {

                        // CPieceClassement.DateMin = DateTime.MinValue;
                        //   Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                        var oldKepp = new List<Piece>();

                        var _albums = gen.Albums;
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            foreach (Piece t in l)
                            {
                                if (t.Keep)
                                {
                                    t.setKeep(0); //t.Keep = false;
                                    oldKepp.Add(t);
                                    //t.resetMedianneCompact();
                                    //t.invalidateCache(true); 
                                }
                            }
                        }
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            Classement pluspetitNonNull = null;
                            Piece min = null;
                            int nbnotes = 0;
                            foreach (Piece t in l)
                            {
                                //si on a au moins un not√© on quitte

                                //var p = t.Track as CPiece;


                                var cl = t.DeepClassement; // p.Classement.DbValue;
                                                           // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                                if (cl.isPositive())// > zer0d)
                                {
                                    nbnotes++;
                                    if (t.LastClassementRecent || !t.Enabled)
                                    {
                                        min = null;
                                        break;
                                    }
                                    if (pluspetitNonNull == null || cl < pluspetitNonNull)
                                    {
                                        pluspetitNonNull = cl;
                                        min = t;
                                    }
                                }

                            }

                            if (min != null)
                            {
                                var coeff = (decimal)nbnotes / l.Count;
                                coeff *= coeff;
                                min.setKeep(coeff);
                            }
                        }

                        foreach (Piece t in oldKepp)
                        {

                            if (!t.Keep)
                            {
                                t.resetMedianneCompact();
                                t.invalidateCache(true);
                            }
                        }


                    }
                }
                finally
                {
                    //  CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                }
            }
        }


        private static void goInit()
        {
            var client = new SimpleClient("goInit\t", logPerf);
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;




            if (CConf.ResetOneCl)
            {
                gen.ConsolidInit(Db.List.getList());
                client.log(" gen.ConsolidInit(Db.List.getList());");
                resetOneCl();
                client.log("resetOneCl");
                //CPieceClassement.DateMin = DateTime.MinValue;
                ////Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                //Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                ////foreach (Piece p in gen.sortByClass())
                ////{
                ////    decimal clValue = p.ClassementValueDecimal(false) ;
                ////    if (clValue > zer0d)
                ////    {
                ////        if (clValue >= zer0d)
                ////        {
                ////            var dPiece = Db.getPiece(p.PieceId);
                ////            var strNewCl = "0000" + dPiece.getClassement().ToString();
                ////            var newCl = Classement.create(strNewCl);
                ////            p.Enabled = true;

                ////            p.setClassement(newCl.ClassList, newCl.Rating);
                ////            dPiece.Classement.eraseClassement2(newCl);
                ////        }
                ////        else
                ////            p.Enabled = false;
                ////    }
                ////}

                //var _albums = gen.Albums;
                //foreach (var album in _albums.List)
                //{
                //    var l = album.Tracks;
                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in l)
                //    {
                //        decimal clValue = t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        (min.Track as CPiece).Classement.keepValue();
                //    }
                //}
                ////    foreach (Piece t in l)
                ////    {
                ////        if (t.Parent == null)
                ////        {
                ////            decimal clValue = t.ClassementValueDecimal(false);
                ////            if (t.isClassListNumeric && clValue > zer0d)
                ////            {
                ////                if (clValue > pluspetitNonNull)
                ////                {
                ////                    var dPiece = Db.getPiece(t.PieceId);
                ////                    t.Enabled = true;
                ////                    t.setClassement("0", 0);
                ////                    dPiece.Classement.eraseClassement2();
                ////                }
                ////            }
                ////        }
                ////    }
                ////}

                ////gen.MakeConsolid(Db.List.getList(), true);
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
            }

            gen.MakeConsolid(null, true, client);
            if (CConf.ConfGen.LimitList <= 0)
                gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            client.log("creation bib");
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, client, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
            client.log("Fin goInit");
        }

        static int nbGo = 0;
        static bool classementChange;
        private static void _go()
        {
            nbGo++;
            bool urgence = false;
            var client = new SimpleClient("<--- chrono " + nbGo + "\t", logPerf);

            try
            {
                Memento.Instance.save();
                bool reInit = !gen.AlbumBuild;
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                //   gen.compact(); 
                detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                client.log("debut");
                if (PlayerViewModel.Instance.CreateRot)
                {

                    if (gen.ClassementChanged)
                    {
                        classementChange = true;
                    }

                    if (_currentTrack == null && classementChange)
                    {
                        resetOneCl();
                        client.log("resetOneCl");
                        classementChange = false;
                    }

                    if (_currentTrack != null)
                    {
                        gen.Albums.makeSort(_currentTrack.PieceGen);
                        client.log("makeSort partial");
                        _currentTrack.refresh();
                        if (refreshAlbum != null)
                            refreshAlbum("", EventArgs.Empty);
                        client.log("refreshAlbum");
                    }

                    _currentTrack = null;


                    // if (__end || __go) return;


                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                    urgence = gen.Urgence;

                    gen.MakeConsolid(null, _updateStats, client); //   bib.Musique.Tracks);
                    if (reInit)
                        gen.buildMusiqueAgain();
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, client, App.bib);
                    if (reInit)
                        bib.syncMusique();
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();


                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);
                    client.log("refresh apr√®s createRot");


                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats)
                        {
                            detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => detailClassementViewModel.IhmInDispo = ihmInDispo.none);

                        }
                        else
                            detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats)
                    {
                        _updateStats = false;
                    }
                }

                if (urgence && !DetailClassementViewModel.Instance.Auto)
                    go(false);
                client.log("FIN!");

            }


        }

        public static event EventHandler refresh;
        public static event EventHandler refreshAlbum;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                return null;
                case MessageBoxResult.No:
                return false;
                case MessageBoxResult.None:
                return null;
                case MessageBoxResult.OK:
                return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Threading;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.player.ViewModel.Commande;
using pdb.util;
using pdb.gen.auto;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg;
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg;
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(TrackListViewModel t)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }



    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object();
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort { get { return confAlbumSort; } set { confAlbumSort = value; } }
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel();
                    }
                }
                return _instance;
            }
        }

        public ConfFilter ConfFilter { get { return FilterTask.conf; } }
        private IPlayerEngine _player;

        public IPlayerEngine Player
        {
            get
            {
                if (_player == null)
                {
                    lock (_lock)
                    {
                        if (_player == null)
                        {
                            _player = PlayerBuilder.create("vlcplugin");
                            _player.mediaEndReached += player_mediaEndReached;
                            _player.Volume = volume;

                            new Thread(refreshLoop).Start();
                        }
                    }
                }
                return _player;
            }
        }

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        public static event EventHandler autoChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        // private bool sortByAlbum = true;
        private bool withVirtualAlbum = CConf.ConfGen.AlbumVirtual;
        private bool withArtistVirtual = CConf.ConfGen.ArtistVirtual;
        private bool navAuto = CConf.ConfGen.NavAuto;
        public bool NavAuto
        {
            get { return navAuto; }
            set
            {
                if (value != navAuto)
                {
                    navAuto = value;
                    OnPropertyChanged("NavAuto");
                }
            }
        }

        private bool filterOnlyNext = true; 
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                    OnPropertyChanged("FilterNext");
                    App.gen.FilterNext = value; 
                }
            }
        }
        ItrackProvider _real;
        private Logger log;
        // public static IPlayerEngine Player { get { return Instance.player; } }


        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }
        private bool createRot = true;
        public bool CreateRot
        {
            get
            {
                return createRot;
            }
            set
            {
                if (value != createRot)
                {
                    createRot = value;
                    OnPropertyChanged("CreateRot");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return confAlbumSort.Enabled;
            }
        }
        //private albumSortMode sortAlbumMode;
        //public albumSortMode SortAlbumMode
        //{
        //    get { return sortAlbumMode; }
        //    set
        //    {
        //        if (value != sortAlbumMode)
        //        {
        //            sortAlbumMode = value;
        //            OnPropertyChanged("SortAlbumMode");
        //            App.go();
        //        }
        //    }
        //}

        public bool WithVirtualAlbum
        {
            get { return withVirtualAlbum; }
            set
            {
                if (value != withVirtualAlbum)
                {
                    withVirtualAlbum = value;
                    OnPropertyChanged("WithVirtualAlbum");
                    App.go();
                }
            }
        }

        public bool WithVirtualArtist
        {
            get { return withArtistVirtual; }
            set
            {
                if (value != withArtistVirtual)
                {
                    withArtistVirtual = value;
                    OnPropertyChanged("WithVirtualArtist");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            //player.mediaEndReached += player_mediaEndReached;
            //player.Volume = volume;

            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            //new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume();
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }

        public void checkNavIni()
        {
            if (!navAuto)
                return;

            var tracks = PresentationTracks;
            bool foundFirst = false;
            TrackListViewModel f = null;

            foreach (TrackListViewModel t in tracks)
            {
                if (t.Index == 1)
                {
                    foundFirst = true;
                }
                if (foundFirst && t.PieceGen.IsNext)
                {
                    f = t;
                    break;
                }
            }

            if (f == null)
                return;

            tracks.MoveCurrentTo(f);
            focus(f);

        }

        public void forward()
        {
            if (!navAuto)
                movetoNext(true);
            else
            {
                try
                {
                    var t = TrackListViewModel.HumanSelected;
                    if (t != null)
                    {
                        t.refresh();
                        //  var g = t.Grouping; 
                    }

                    var pl = PlayListViewModel.SelectedPlayList;
                    if (pl == null)
                    {
                        movetoNext(true);
                        return;
                    }

                    string _album = "";
                    if (currentTrack != null)
                        _album = currentTrack.Album;
                    movetoNext(true); // des fois le morceaux affich√© n'est pas celui jou√©. Dommage...
                    if (currentTrack != null && currentTrack.Album == _album)
                    {
                        if (state == playerstate.play)
                            play(false, true);
                        return;
                    }

                    if (currentTrack == null)
                        return;
                    var album = App.gen.Albums.getAlbum(CurrentTrack.PieceGen);
                    var tracks = album.Tracks;
                    //    tracks.Sort(new PieceClassementComparer());
                    //  decimal val = int.MaxValue;
                    int i = 0;
                    TrackListViewModel choose = null;
                    if (confAlbumSort.ComposantsUtiles[0].cmpMin > modeMin.non)
                    {
                        var next = album.Next;
                        if (next != null)
                            choose = TrackListViewModel.getOrCreate(next); // pl.FindTrack(next.PieceId);
                    }
                    else
                    {
                        for (i = 0; i < tracks.Count; i++)
                        {
                            var item = tracks[i];
                            if (item != null && (!onlyEnabled || item.Enabled))
                            {
                                var tl = TrackListViewModel.getOrCreate(item); // pl.FindTrack(item.PieceId);
                                if (!tl.ExistsNow)
                                    continue;
                                choose = tl;

                                //val = v;
                                // choose = tl;
                                if (!item.Classement.isPositive())
                                {
                                    break;
                                    //if (confAlbumSort.ComposantsUtiles[0].cmpMin != modeMin.toujours)
                                    //    choose = tl;
                                    //break;
                                }
                                // choose = tl;
                            }
                        }
                    }

                    if (choose != null)
                    {
                        //var p = choose.PieceGen;
                        //if (p != null)
                        //   confAlbumSort.auto(p.AutoCoeff1, p.AutoCoeff2); 
                        if (choose != currentTrack)
                        {
                            reset(provider, choose, state == playerstate.play);
                            var coll = PresentationTracks;
                            coll.MoveCurrentTo(choose);
                        }

                        focus(choose);

                    }
                }
                finally
                {
                    refresh();
                    doFilter(_lastFilter);
                }

            }
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            Player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext(bool autoPlay)
        {
            move(true, autoPlay);
            doFilter(_lastFilter);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext, bool autoPlay)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {

                int masterId = 0;
                if (currentTrack != null)
                {
                    tracks.MoveCurrentTo(currentTrack);
                    masterId = currentTrack.MasterId;
                }
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.ExistsNow && (!onlyEnabled || item.Enabled) && item.MasterId != masterId)
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    // focus(item);
                    if (playing && autoPlay)
                    {
                        Player.play(item.Location, true);
                    }
                    // focus(item);
                }

                refresh(); 

            }
        }


        private void movetoPrevious()
        {
            move(false, true);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.ExistsNow && (!onlyEnabled || item.Enabled))
                                break;
                            else if (currentTrack != null)
                            {
                                item = currentTrack;
                                break; 
                            }
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;                   
                    item = null;
                }

                CurrentTrack = item;

                //  focus(item);

                State = playerstate.play;
                //item.Playing = true;
                Player.play(currentTrack.Location, reload);
                // Volume = Volume;
                focus(item);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
                refresh(); 
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            Player.stop();
            refresh(); 

        }

        private void next()
        {
            if (navAuto)
                forward();
            else
                movetoNext(true);
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }

        public void focusHelp()
        {
            var t = TrackListViewModel.CurrentPlaying;
            if (t == null)
                t = TrackListViewModel.HumanSelected;
            if (t == null) return;
            focus(t);
        }
        private void focus(TrackListViewModel t)
        {
            if (provider == null)
                return;
            provider.Focus(t);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = _player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = _player.Elapsed;
                this.Length = _player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    var sb = new System.Text.StringBuilder();
                    sb.Append(currentTrack.Artist);
                    sb.Append(" - ");
                    sb.Append(currentTrack.Album);
                    if (currentTrack.PieceGen != null)
                    {
                        if (currentTrack.PieceGen.Virtual)
                        {
                            sb.Append(" (");
                            sb.Append(currentTrack.PieceGen.Master.Album);
                            sb.Append(")");
                        }
                    }
                    CurrentAuthorAlbum = sb.ToString();
                    if (currentTrack.ExistsNow)
                        currentTrack.Duration = length;

                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            reset(provider, track, true);
        }

        public static void makeauto(TrackListViewModel current)
        {
            if (current != null)
            {
                var p = current.PieceGen;
                if (p != null)
                {
                    if (MedianneDriver.auto(confAlbumSort, p))
                        App.gen.Albums.invalidateAll(false);
                    if (autoChange != null)
                        autoChange(current, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track, bool autoPlay)
        {
            if (provider != null)
            {
                Instance.provider = provider;
                if (provider.PlayList != null)
                    Instance.currentPl = provider.PlayList;
                Instance.provider = provider;
                Instance.tracks = provider.PresentationTracks;

            }
            Instance._positionstate = positionstate.free;






            Instance.CurrentTrack = track;
            if (autoPlay)
                Instance.play(true, true);
            Instance.makeResume();
            App.go();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au r√©el");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            var currentPlaying = TrackListViewModel.CurrentPlaying;
                            tracks.MoveCurrentTo(currentPlaying);
                            provider.Focus(currentPlaying);
                        }
                        else
                        {
                            log.log("d√©tection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
        //  private class filterTask
        //  {
        //      public filterTask()
        //      {
        //      }
        //      public string filter;
        //      //public string waitingFilter; 
        //      //private bool cancel; 
        //      //private Thread th;
        //      public Predicate<object> Filter;
        //      //public ICollectionView coll;
        //      //private bool busy;

        //      public void go()
        //      {

        //          if (!string.IsNullOrEmpty(filter))
        //              filter = filter.Trim().ToLower().removeAccent();

        //          var tab = filter.Split(' ');
        //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
        //          lock (this)
        //              busy = true;
        //          coll.Filter = item =>
        //          {
        //              TrackListViewModel vitem = item as TrackListViewModel;
        //              if (vitem == null) return false;

        //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //              //    return vitem.Classement.StartsWith(filter);
        //              bool ok = true;
        //              var name = vitem.Name.Trim().ToLower().removeAccent();
        //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //              var album = vitem.Album.Trim().ToLower().removeAccent();
        //              var classement = vitem.Classement;
        //              foreach (string str in tab)
        //              {
        //                  if (!ok)
        //                      return false;
        //                  if (string.IsNullOrEmpty(str))
        //                      continue;
        //                  var str_ = str.Trim();
        //                  if (str_ == string.Empty)
        //                      continue;

        //                  ok = name.Contains(str_)
        //                      || artist.Contains(str_)
        //                      || album.Contains(str_)
        //                      || classement.StartsWith(str_);

        //              }

        //              return ok;

        //          };

        //          lock (this)
        //              busy = true;

        //      }
        //      private void getItems()
        //      {
        //          try
        //          {
        //              if (!string.IsNullOrEmpty(filter))
        //                  filter = filter.Trim().ToLower().removeAccent();
        //              if (cancel)
        //                  return;
        //              var tab = filter.Split(' ');
        //              if (cancel)
        //                  return;
        //              Filter = item =>
        //              {
        //                  TrackListViewModel vitem = item as TrackListViewModel;
        //                  if (vitem == null) return false;

        //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //                  //    return vitem.Classement.StartsWith(filter);
        //                  bool ok = true;
        //                  var name = vitem.Name.Trim().ToLower().removeAccent();
        //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //                  var album = vitem.Album.Trim().ToLower().removeAccent();
        //                  var classement = vitem.Classement;
        //                  foreach (string str in tab)
        //                  {
        //                      if (!ok)
        //                          return false;
        //                      if (string.IsNullOrEmpty(str))
        //                          continue;
        //                      var str_ = str.Trim();
        //                      if (str_ == string.Empty)
        //                          continue;

        //                      ok = name.Contains(str_)
        //                          || artist.Contains(str_)
        //                          || album.Contains(str_)
        //                          || classement.StartsWith(str_);

        //                  }

        //                  return ok;

        //              };
        //          }
        //          catch (Exception ex)
        //          {
        //              App.log.log(ex.ToString()); 
        //          }
        //      }
        //  }
        ////  private static filterTask filtertask = new filterTask(); 
        private static IDisposable work;
        private static FilterTask filterTask = null;

        private static bool cancel;
        public static void doFilter0(ICollectionView coll, string filter)
        {

            ILogger log = App.log;
            log.log("filter=>{0}", filter);
            lock (_lock)
            {
                if (work == null)
                {
                    log.log("filter=>{0} verrou libre", filter);
                    work = coll.DeferRefresh();
                }
                else
                {
                    log.log("filter=>{0} verrou pris, abandon t√¢che en cours", filter);
                    cancel = true;
                }
            }

            var _cancel = cancel;
            if (_cancel)
                log.log("filter=>{0} verrou pris, attente fin t√¢che en cours", filter);
            while (cancel)
                Thread.Sleep(30);

            if (_cancel)
                log.log("filter=>{0} verrou pris, fin d'attente fin t√¢che en cours", filter);

            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 


            _cancel = cancel;
            if (!_cancel)
            {
                lock (_lock)
                    _cancel = cancel;
            }

            if (!_cancel)
            {
                log.log("filter=>{0} lancement filtre", filter);
                coll.Filter = item =>
                {
                    if (cancel)
                        return false;
                    TrackListViewModel vitem = item as TrackListViewModel;
                    if (vitem == null) return false;



                    //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                    //    return vitem.Classement.StartsWith(filter);
                    bool ok = true;
                    var name = vitem.Name.Trim().ToLower().removeAccent();
                    var artist = vitem.Artist.Trim().ToLower().removeAccent();
                    var album = vitem.Album.Trim().ToLower().removeAccent();
                    List<string> paths = null;

                    var classement = vitem.Classement;
                    foreach (string str in tab)
                    {
                        if (!ok)
                            return false;
                        if (string.IsNullOrEmpty(str))
                            continue;
                        var str_ = str.Trim();
                        if (str_ == string.Empty)
                            continue;

                        ok = name.Contains(str_)
                            || artist.Contains(str_)
                            || album.Contains(str_)
                            || classement.StartsWith(str_);

                        if (!ok)
                        {
                            if (paths == null)
                            {
                                paths = new List<string>();
                                foreach (var f in vitem.Piece.Files)
                                {
                                    paths.Add(f.File.ToLower().removeAccent());
                                }
                            }

                            foreach (string path in paths)
                            {
                                if (path.Contains(str))
                                    return true;
                            }
                        }
                    }

                    return ok;

                };

                if (cancel)
                    log.log("filter=>{0} la t√¢che a √©t√© interrompue", filter);
            }
            else
            {
                log.log("filter=>{0} finalement pas de lancement", filter);
            }
            lock (_lock)
            {
                if (!cancel)
                {
                    if (work != null)
                    {
                        log.log("filter=>{0} application du filtre", filter);
                        work.Dispose();
                    }
                    else
                    {
                        log.log("filter=>{0} ben pourquoa le work √©tait null ????", filter);
                    }
                    work = null;

                }
            }

            lock (_lock)
                cancel = false;

            log.log("filter=>{0} fin", filter);
        }




        private class FilterTask
        {
            public static ConfFilter conf = new ConfFilter();
            private ICollectionView coll;
            public readonly string filter0;
            public readonly bool filterNext;

            private string filter;
            private bool _cancel;
            private bool end;
            private Thread th;
            SimpleChrono log;
            public string step;
            private HashSet<int> l = new HashSet<int>();
            public FilterTask(string filter, bool filterNext, ICollectionView coll, SimpleChrono log)
            {
                this.filter0 = filter;
                this.filter = filter;
                this.filterNext = filterNext;

                this.coll = coll;
                this.log = log;
                step = "ini";
                th = new Thread(calc);
                th.Start();
            }

            public void cancel()
            {
                lock (_lock)
                    _cancel = true;
            }

            public bool End { get { return end; } }
            public bool Cancel { get { return _cancel; } }
            private bool toClear;

            private void calc()
            {
                step = "calc";
                try
                {
                    if (string.IsNullOrEmpty(filter) && !filterNext)
                    {
                        toClear = true;
                        apply();
                        return;
                    }
                    toClear = false;

                    filter = filter.Trim().ToLower().removeAccent();
                    //if (string.IsNullOrWhiteSpace(filter) && !filterNext && conf.includeVirtual && conf.includeVirtualArtist)
                    //{
                    //    clear(); 
                    //    return;
                    //}

                    var tab = filter.Split(' ');

                    int nb = 0;
                    int nbOk = 0;

                    foreach (TrackListViewModel vitem in coll.SourceCollection)
                    {
                        if (_cancel)
                            return;

                        if (filterNext && !vitem.PieceGen.IsNext)
                            continue;
                        if (conf.onlyMaster && vitem.Piece.Parent != null)
                            continue;
                        if (!filterNext)
                        {
                            if (vitem.PieceGen.Virtual && !conf.includeVirtual)
                                continue;
                            if (vitem.PieceGen.VirtualMode == pdb.gen.albums.virtualMode.artist && !conf.includeVirtualArtist)
                                continue;
                        }



                        bool ok = true;

                        if (conf.onlyId)
                        {
                            ok = filter == vitem.PieceId.ToString();
                        }
                        else
                        {

                            var name = vitem.Name.Trim().ToLower().removeAccent();
                            var artist = vitem.Artist.Trim().ToLower().removeAccent();
                            var album = vitem.Album.Trim().ToLower().removeAccent();
                            var masterAlbum = vitem.MasterAlbum.Trim().ToLower().removeAccent();
                            var classement = vitem.Classement;
                            List<string> paths = null;
                            foreach (string str in tab)
                            {
                                if (ok)
                                {
                                    if (string.IsNullOrEmpty(str))
                                        continue;
                                    var str_ = str.Trim();
                                    if (str_ == string.Empty)
                                        continue;

                                    ok = name.Contains(str_)
                                        || artist.Contains(str_)
                                        || album.Contains(str_)
                                        || masterAlbum.Contains(str_)
                                        || classement.StartsWith(str_)
                                        || (conf.includeId && str == vitem.PieceId.ToString())
                                        ;

                                    if (!ok)
                                    {
                                        if (paths == null)
                                        {
                                            paths = new List<string>();
                                            foreach (var f in vitem.Piece.Files)
                                            {
                                                paths.Add(f.File.ToLower().removeAccent());
                                            }
                                        }

                                        foreach (string path in paths)
                                        {
                                            if (path.Contains(str))
                                            {
                                                ok = true;
                                                break;
                                            }
                                        }
                                    }

                                }
                                else
                                    break;

                            }
                        }


                        nb++;
                        if (ok)
                        {
                            if (conf.family)
                            {
                                foreach (Piece p in vitem.PieceGen.Master)
                                {
                                    if (!filterNext)
                                    {
                                        if (p.Virtual && !conf.includeVirtual)
                                            continue;
                                        if (p.VirtualMode == pdb.gen.albums.virtualMode.artist && !conf.includeVirtualArtist)
                                            continue;
                                    }
                                    l.Add(p.PieceId);
                                }
                            }
                            else
                                l.Add(vitem.PieceId);

                            nbOk++;
                        }
                    }

                    log.log(string.Format("{0}/{1}", nbOk, nb));
                    // log.log(string.Format("calc:{0} item{1} {2} s√©lectionn√©{3}", nb, (nb > 1 ? "s" : ""), nbOk, (nbOk > 1 ? "s" : "")));   

                    lock (_lock)
                    {
                        if (_cancel)
                            return;
                    }


                    apply();


                }
                finally
                {
                    if (_cancel)
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache termin√©e par cancel");
                    }
                }





            }




            public void apply()
            {
                step = "apply";

                bool __cancel = _cancel;

                if (!__cancel)
                {
                    lock (_lock)
                        __cancel = _cancel;
                }


                if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
                {

                    if (__cancel)
                        return;
                    step = "applyAppDispatcher";
                    try
                    {
                        if (toClear)
                        {
                            log.log("clear filter");
                            coll.Filter = null;
                            log.log("fin clear filter");
                            return;
                        }

                        if (work == null)
                        {
                            log.log("creation du tempo");
                            work = coll.DeferRefresh();
                        }
                        else
                        {
                            log.log("tempo d√©j√† cr√©√© ");

                        }


                        coll.Filter = item =>
                        {
                            if (_cancel)
                                return false;

                            var t = item as TrackListViewModel;
                            if (t == null)
                                return false;
                            if (!l.Contains(t.PieceId))
                                return false;
                            return true;
                        };




                        if (!__cancel)
                        {
                            log.log("application");
                            work.Dispose();
                            work = null;
                            log.log("fin application");
                        }
                        else
                        {
                            log.log("abandon application");
                        }
                    }
                    finally
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache termin√©e par application");
                        PlayerViewModel.Instance.makeResume();
                        PlayerViewModel.Instance.focusHelp();
                    }
                }
                else
                {
                    App.Current.Dispatcher.BeginInvoke(new Action(apply), App.DISPATCHER_PRIORITY);
                }
            }

            public override string ToString()
            {
                return string.Format("en cours:{0} step:{1} end:{2} cancel:{3}", filter0, step, End, Cancel);
            }

        }


        public static void doFilter(ICollectionView coll, string filter)
        {
            SimpleChrono log = new SimpleChrono(string.Format("\tfilter=>{0}\t", filter), App.log);

            log.log("");
            lock (_lock)
            {
                bool _cancelCurrent = false;
                bool _same = false;

                if (filterTask != null)
                {
                    log.log(filterTask.ToString());
                }

                _cancelCurrent = filterTask != null && !filterTask.End;
                _same = _cancelCurrent && filterTask.filter0.Equals(filter) && filterTask.filterNext == Instance.FilterNext;
                if (_same)
                {
                    log.log("identique");
                    return;
                }
                else if (_cancelCurrent)
                {
                    log.log("abandon t√¢che en cours");
                    filterTask.cancel();
                }

                else
                {
                    log.log("verrou libre");
                }

                filterTask = new FilterTask(filter, Instance.filterOnlyNext, coll, log);

            }





        }



        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}
        string _lastFilter = "";
        //public void doFilter()
        //{
        //    if (this.navAuto)
        //        doFilter(_lastFilter);
        //}

        public void doFilter(String filter)
        {
            this._lastFilter = filter;
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);

        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
            {
                string newResume = resume;
                try
                {

                    IEnumerable items = null;
                    var provider = DisplayProvider;
                    if (provider == null)
                        return;
                    var tracks = provider.PresentationTracks;
                    int nbOrg = -1;
                    items = tracks;
                    if (items == null)
                        return;

                    var selected = provider.SelectedTracks;
                    if (selected.Count > 1)
                    {
                        items = selected;
                        nbOrg = 0;
                        foreach (TrackListViewModel t in tracks)
                            nbOrg++;
                    }
                    int nb = 0, nbSelected = 0, nbPresent = 0;
                    TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationPresent = new TimeSpan();
                    HashSet<int> h = new HashSet<int>();

                    foreach (TrackListViewModel track in items)
                    {
                        if (!h.Add(track.PieceGen.MasterId))
                            continue;
                        nb++;
                        duration += track.Duration;
                        if (track.Enabled)
                        {
                            nbSelected++;
                            durationSelected += track.Duration;
                        }
                        if (true == track.Exists)
                        {
                            nbPresent++;
                            durationPresent += track.Duration;
                        }
                    }

                    ITextWriter sb = new pdb.util.StringBuilder();
                    sb.Append(nb);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    if (nbOrg >= 0)
                    {
                        sb.Append(" sur ");
                        sb.Append(nbOrg);
                        sb.Append(",");
                    }
                    sb.Append(" ");
                    humanDuration(sb, duration);
                    sb.Append(" ( ");
                    sb.Append(nbSelected);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nbSelected > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationSelected);

                    sb.Append(" )");

                    if (nbPresent > 0)
                    {
                        sb.Append(" presents: ");
                        sb.Append(nbPresent);
                        sb.Append(" ");
                        sb.Append("elt");
                        if (nb > 1)
                            sb.Append("s");
                        sb.Append(" ");
                        humanDuration(sb, durationPresent);
                    }
                    sb.Append("\t");

                    var currentTrack = TrackListViewModel.HumanSelected;
                    if (currentTrack != null)
                    {
                        humanSize(sb, currentTrack.Size);
                        sb.Append(" ");
                        sb.Append(currentTrack.Piece.Files.PathReduc);
                    }

                    newResume = sb.ToString();

                }
                catch (Exception e0)
                {
                    App.log.log(e0.ToString());
                }
                finally
                {
                    if (newResume != resume)
                    {
                        resume = newResume;
                        if (resumeChange != null)
                        {
                            try
                            {
                                resumeChange(this, EventArgs.Empty);
                            }
                            catch (Exception ex)
                            {
                                App.log.log(ex.ToString());
                            }
                        }
                    }
                }
            }
            else
            {
                App.Current.Dispatcher.BeginInvoke(new Action(makeResume), App.DISPATCHER_PRIORITY);
            }

        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append(size.HumanReadableSize(-1));
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append("j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append("m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append("m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append("s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    Player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    Player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;
using pdb.gen.medianne;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackInfoItunes
    {




        #region r√©percut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion

        private CPiece piece;
        private Piece track;

        // private TrackList track;
        //  private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        //  public TrackList Track { get { return track; } }
        //   public CPiece Piece { get { return piece.Piece; } }
        // public Piece PieceGen { get { return track.Piece; } }

        public CPiece Piece { get { return piece; } }
        public Piece PieceGen { get { return track; } }
        public Piece Master { get { return track.Master; } }
        public bool Played { get { return piece.Played; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            // piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            //OnPropertyChanged("Comment");
            //OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        private int index2;
        public int Index2
        {
            get { return index2; }
            set
            {
                if (value != index2)
                {
                    index2 = value;
                    OnPropertyChanged("Index2");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public bool Empeached { get { return PieceGen.isEmpeached(); } set { PieceGen.Empeached = value; } }
        public int EmpeachedNb { get { return PieceGen.EmpeachedNb; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        private static bool setHumanSelectedUsed;
        private static volatile object _lock = new object();
        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            lock (_lock)
            {
                if (setHumanSelectedUsed)
                    return;
            }

            try
            {
                lock (_lock)
                    setHumanSelectedUsed = true;
                //if (humanSelected != null)
                //{
                //    humanSelected.refresh();
                //   // var b = humanSelected.Grouping; 
                //}
                if (track != humanSelected)
                {
                    humanSelected = track;


                    //  humanSelected.refresh();
                    // var b = humanSelected.Grouping; 
                    int id = 0;
                    if (track != null) id = track.PieceId;
                    if (id != humanSelectedId)
                    {
                        humanSelectedId = id;
                        if (CurrentHumanSelectedChanged != null)
                            CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                    }
                }
            }
            finally
            {
                lock (_lock)
                    setHumanSelectedUsed = false;
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return MasterPiece.ExportStatus; // exportState;
            }
            set
            {
                if (MasterPiece.ExportStatus != value)
                {
                    MasterPiece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }



        private TrackListViewModel(Piece piece)
            : base(piece)
        {
            this.track = piece;
            this.piece = track.Track as CPiece;
        }
        # region registre
        #region main
        /// <summary>
        /// Registre des tracks pr√©sent√©s dans la grille principale
        /// </summary>
        private static BgDict<int, TrackListViewModel> dict = new BgDict<int, TrackListViewModel>();
        /// <summary>
        /// R√©cup√®re ou cr√©e un track dans la grille principale
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public static TrackListViewModel getOrCreate(Piece p)
        {
            var t = dict[p.PieceId];
            if (t == null)
            {
                t = new TrackListViewModel(p);
                dict.Add(p.PieceId, t);
            }
            return t;
        }

        public static TrackListViewModel get(int id)
        {
            return dict[id];
        }
        public static IDictionary<int, TrackListViewModel> Dict { get { return dict; } }
        #endregion
        #region album
        /// <summary>
        /// Registre des tracks pr√©sent√©s dans la grille album
        /// </summary>
        private static BgDict<int, TrackListViewModel> dictA = new BgDict<int, TrackListViewModel>();
        /// <summary>
        /// R√©cup√®re ou cr√©e un track dans la grille album
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public static TrackListViewModel getOrCreateA(Piece p)
        {
            var t = dictA[p.PieceId];
            if (t == null)
            {
                t = new TrackListViewModel(p);
                dictA.Add(p.PieceId, t);
            }
            return t;
        }

        public static TrackListViewModel getA(int id)
        {
            return dictA[id];
        }
        public static IDictionary<int, TrackListViewModel> DictA { get { return dictA; } }
        #endregion
        # endregion
        //public TrackListViewModel(TrackList track, PlayListViewModel playlist)
        //    : base(track, playlist)
        //{
        //    //this.track = track;
        //    //this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
        //    //piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
        //    //int id = track.PieceId;
        //    //if (!dictT.ContainsKey(id))
        //    //{
        //    //    var list = new List<TrackListViewModel>();
        //    //    dictT.Add(id, list);
        //    //}

        //    //dictT[id].Add(this);

        //}

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }

        public string ClassementCompact
        {
            get { return PieceGen.ClassementCompact; }
        }

        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        //  Classement ITrackNative.Classement { get { return PieceGen.Classement; } }
        public String Classement
        {
            get
            {
                return PieceGen.Classement.ToString();
            }
            set
            {

                // piece.StrClassement = value;
                //if (value != piece.Piece.StrClassement)
                //{

                lock (Albums.LockSort)
                {
                    piece.StrClassement = value;
                    track.invalidateCache(true);
                    App.gen.ClassementChange();

                    //piece.Classement = value;
                    // PieceGen.invalidateCache();
                    var albums = App.gen.Albums;
                    albums.signalClassChange(track);
                  //  albums.invalidateAll(false); 
                    if (DetailClassementViewModel.Instance.Auto)
                        App.gen.setUrgence();
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    OnPropertyChanged("Classement");

                    App.go(this);
                    // onPropertyChanged("Classement");


                    // }

                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                if (value != Year)
                {
                    piece.Year = value;
                    App.invalidateAlbums();
                }
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }

        public DateTime Added { get { return piece.Added; } }

        public DateTime FirstAcces
        {
            get
            {
                return track.FirstAcces;
            }
        }



        public DateTime AlbumAdded
        {
            get
            {
                return track.AlbumAdded;
            }
        }

        public int RankAlbum { get { return PieceGen.RankAlbum; } }
        public int RankAlbumZero { get { return PieceGen.RankAlbumZero; } }
        public int RankAlbumReverse { get { return PieceGen.RankAlbumReverse; } }
        public int RankAllAlbum { get { return PieceGen.RankAllAlbum; } }
        public int RankAlbumSt { get { return PieceGen.RankAlbumSt; } }
        public int RankAlbumZeroSt { get { return PieceGen.RankAlbumZeroSt; } }


        public int Rank { get { return PieceGen.Rank.Quality; } }
        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        //public string Comment
        //{
        //    get
        //    {
        //        if (PieceGen.Virtual)
        //            return "";
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        if (PieceGen.Virtual)
        //            return;
        //        //piece.Comment = value; 
        //        if (value != piece.Comment)
        //        {
        //            //  track.Comment = value;
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get { return track.Piece.Grouping; }
        //    set
        //    {
        //        //  piece.Grouping = value;
        //        if (value != track.Piece.Grouping)
        //        {
        //            track.Piece.setGrouping(value, true);
        //            // track.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string File
        {
            get { return piece.Files.PathReduc; }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                if (value != Artist)
                {
                    piece.Artist = value;
                    App.invalidateAlbums();
                }
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    switch (track.VirtualMode)
                    {
                        case virtualMode.none:
                        break;
                        case virtualMode.artist:
                        return string.Format("[{0}]", track.Album);
                        case virtualMode.path:
                        break;
                        case virtualMode.year:
                        if (track.Album.Length == 3)
                            return string.Format("[[{0}0']]", track.Album);
                        else
                            return string.Format("[[{0}]]", track.Album);
                        case virtualMode.extended:
                        return string.Format("¬§{0}", track.Album);
                        case virtualMode.added:
                        return string.Format("<{0}>", track.Album);
                        case virtualMode.word:
                        return string.Format("'{0}'", track.Album);
                        case virtualMode.list:
                        return string.Format("/{0}", track.Album);
                        default:
                        break;
                    }
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                {
                    if (value != Album)
                    {
                        piece.Album = value;
                        App.invalidateAlbums();
                    }
                }
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.setClassement(className, rating);
            PieceGen.invalidateCache(true);

        }



        public DateTime PlayedDate
        {
            get { return piece.PlayedDate; }
        }

        //public string ArtWork
        //{
        //    get
        //    {
        //        return piece.ArtWork;
        //    }
        //    set
        //    {
        //        piece.ArtWork = value;
        //    }
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    track.Piece.setGrouping(value, prior);
        //    piece.Grouping = value; // TODO je fait quoi de √ßa ???
        //    // onPropertyChanged("Grouping");
        //}

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel - 1; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2 - 1; } }

        public decimal Rendement
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Rendement - 1;
            }
        }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }



        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Dates); }
        }


        public string ClassEvol
        {
            get { return track.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool? Exists { get { return Piece.Exists; } }
        public bool ExistsNow { get { return Piece.ExistsNow; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.invalidateCache(false);
            parent.PieceGen.invalidateCache(false);

            track.albumMustRefresh();
            parent.track.albumMustRefresh();

            piece.Parent = parent.Piece.Master;
            track.setParent(parent.track);

            track.albumMustRefresh();
            parent.track.albumMustRefresh();

            track.invalidateCache(false);
            parent.PieceGen.invalidateCache(false);
        }

        public void fusion(TrackListViewModel toDelete)
        {

            PieceGen.invalidateCache(false);
            toDelete.PieceGen.invalidateCache(false);

            App.Db.List.fusion(piece, toDelete.Piece);
            PieceGen.invalidateCache(false);
            toDelete.PieceGen.invalidateCache(false);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }
        public DateTime? MasterAlbumUpdateClassement { get { return PieceGen.MasterAlbumUpdateClassement; } }



        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }

        public string EquivLight
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight;
            }
        }

        public string EquivLight0
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight0;
            }
        }

        public string EquivLightSt
        {
            get
            {

                if (album == null)
                    return "";
                return album.EquivLightSt;
            }
        }

        public decimal ClassementValueLightSt
        {
            get
            {
                if (album == null)
                    return 0;
                return album.ClassementValueLightSt;
            }
        }

        public decimal ClassementValueLight
        {
            get
            {
                if (album == null)
                    return 0;
                return album.ClassementValueLight;
            }
        }

        public int AlbumCount
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Count;
            }
        }

        public bool Virtual { get { return PieceGen.Virtual; } }

        public int DeltaRank { get { return PieceGen.DeltaRank; } }


        public void setClassement(string classement)
        {
            Classement = classement;
        }


        public string strClassement
        {
            get { return Classement; }
        }

        public string MaxClassement
        {
            get { return track.MaxClassement.ToString(); }
        }

        public string DeepClassement
        {
            get { return track.DeepClassement.ToString(); }
        }




        public bool Keep { get { return PieceGen.Keep; } }

        public bool NoCompact { get { return !PieceGen.UseCompact; } }

        public int MainTrackNumber { get { return PieceGen.MasterTrackNumber; } }

        public int NbRecentsInAlbum { get { return PieceGen.NbRecentsInAlbum; } }
        public int NbDoneInAlbum { get { return PieceGen.NbDoneInAlbum; } }
        public string PlusPetitEnabled { get { return PieceGen.PlusPetitEnabled; } }

        public decimal KeepCoeff { get { return PieceGen.KeepCoeff; } }

        public IMasterPiece MasterPiece
        {
            get
            {
                return piece.MasterPiece;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Chrono.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;

namespace pdb.util
{
    public class Chrono
    {
        private DateTime begin;
        private DateTime _end;
        private List<ChronoPhase> list = new List<ChronoPhase>();
        private Thread th;
        private DateTime current;
        private string clientName;
        public void reset(string clientName)
        {
            th = Thread.CurrentThread;
            list.Clear();
            this.clientName = clientName;
            begin = DateTime.Now;
            current = begin;
            _end = begin;
        }

        public void reset()
        {
            th = Thread.CurrentThread;
            list.Clear();
            //this.clientName = clientName;
            begin = DateTime.Now;
            current = begin;
            _end = begin;
        }

        public void bip(string clientName, string phase)
        {
            if (!clientName.isNullorEmpty() && clientName != this.clientName)
                return;

            bip(phase);
        }

        public void bip(string phase, bool displayNow)
        {
            if (!displayNow && Thread.CurrentThread != th)
                return;

            var now = DateTime.Now;
            var dt = now - current;
            current = now;
            var cp = new ChronoPhase(phase, dt);
            if (displayNow)
                misc.log(cp);
            list.Add(cp);
        }

        public void bip(string phase)
        {
            bip(phase, false);
        }

        public void end()
        {
            _end = DateTime.Now;
        }

        public TimeSpan Total { get { return _end - begin; } }

        public string display(double seuil, string strFormat)
        {
            var sb = new StringBuilder();
            foreach (ChronoPhase ph in list)
            {
                if (ph.duration.TotalMilliseconds < seuil)
                    continue;
                ph.display(sb, strFormat);
                sb.Append(" ");

            }
            return sb.ToString();
        }

        public override string ToString()
        {
            return display(-1, "{0,2};{0,-3:#}");
        }



    }

    class ChronoPhase
    {
        public readonly string phase;
        public readonly TimeSpan duration;
        public ChronoPhase(string phase, TimeSpan duration)
        {
            this.phase = phase;
            this.duration = duration;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            display(sb);
            return sb.ToString();
        }

        public void display(ITextWriter sb, string strFormat)
        {
            sb.Append(string.Format(strFormat, phase, duration.TotalMilliseconds));
        }

        public void display(ITextWriter sb)
        {
            sb.Append(string.Format("{0,2}", phase));
            sb.Append(":");
            sb.Append(string.Format("{0,-3:#}", duration.TotalMilliseconds));
        }
    }



    public class SimpleChrono
    {
        private DateTime begin;
        private DateTime courant;
        private string prefix;
        private ILogger _log;

        public SimpleChrono(DateTime begin, string prefix, ILogger log)
        {
            this.begin = begin;
            this.courant = begin;
            this.prefix = prefix;
            this._log = log;
        }

        public SimpleChrono(string prefix, ILogger log)
            : this(DateTime.Now, prefix, log)
        {
        }

        public void log(string content)
        {
            var now = DateTime.Now;
            var tsPhase = now - courant;
            courant = now;
            var tsTot = now - begin;

            var partial = tsPhase.TotalSeconds.ToString("#.#");
            if (string.IsNullOrEmpty(partial.Trim()))
                partial = "    ";


            var total = tsTot.TotalSeconds.ToString("#.#");
            if (string.IsNullOrEmpty(total.Trim()))
                total = "    ";


            _log.log("{0}{1}\t{2}\t{3}", prefix, partial, total, content);

        }

    }
}
]]></content>
  </file>
  <file path="\pdb.util\IClient.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util
{
    /// <summary>
    /// Client pour les t√¢ches longues qui peuvent √™tre interrompues
    /// </summary>
    public interface IClient
    {
        /// <summary>
        /// Log du temps pass√© √† une t√¢che
        /// </summary>
        /// <param name="phase"></param>
        void log(string phase);
        /// <summary>
        /// Arret de la t√¢che
        /// </summary>
        bool Cancel { get; }
    }

    public class SimpleClient : IClient
    {
        private bool _cancel;
        private SimpleChrono chrono;
        public void cancel() { _cancel = true; }
        public SimpleClient(ILogger log) : this("", log)
        {

        }
        public SimpleClient(string prefix, ILogger log)
        {
            this.chrono = new SimpleChrono(prefix, log);
        }
        public bool Cancel
        {
            get
            {
                return _cancel;
            }
        }

        public void log(string phase)
        {
            chrono.log(phase);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\pdb.util.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.util</RootNamespace>
    <AssemblyName>pdb.util</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Debug\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AsyncFileWriter.cs" />
    <Compile Include="BgDict.cs" />
    <Compile Include="CalcMedianne.cs" />
    <Compile Include="Chrono.cs" />
    <Compile Include="CustomFormat.cs" />
    <Compile Include="CUtil.cs" />
    <Compile Include="DateUtil.cs" />
    <Compile Include="DecimalIndex.cs" />
    <Compile Include="DescBuilder.cs" />
    <Compile Include="Dict.cs" />
    <Compile Include="FileRegister.cs" />
    <Compile Include="FileRotator.cs" />
    <Compile Include="FileType.cs" />
    <Compile Include="Generic\Attributs\AttributeHelper.cs" />
    <Compile Include="Generic\Attributs\CustomAttribute.cs" />
    <Compile Include="Generic\Attributs\Db\DbAttributes.cs" />
    <Compile Include="Generic\Attributs\Db\SbAttributes.cs" />
    <Compile Include="Generic\Attributs\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Json\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\NameAttributeBase.cs" />
    <Compile Include="Generic\Attributs\Sp\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Xml\XmlAttributes.cs" />
    <Compile Include="Generic\Encode\Getters.cs" />
    <Compile Include="Generic\Encode\JSON.cs" />
    <Compile Include="Generic\Encode\JsonEncoder.cs" />
    <Compile Include="Generic\Encode\JsonParser.cs" />
    <Compile Include="Generic\Encode\JsonSerializer.cs" />
    <Compile Include="Generic\Encode\JsonXmlEncoder.cs" />
    <Compile Include="Generic\Encode\SafeDictionary.cs" />
    <Compile Include="Generic\INode.cs" />
    <Compile Include="Generic\MappingException.cs" />
    <Compile Include="Generic\Parse\DbParser.cs" />
    <Compile Include="Generic\Parse\DbWrapper.cs" />
    <Compile Include="Generic\Parse\JsonParser.cs" />
    <Compile Include="Generic\Parse\Json\JsonBuilder.cs" />
    <Compile Include="Generic\Parse\Json\JsonParseException.cs" />
    <Compile Include="Generic\Parse\Json\JsonState.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateDeuxPoints.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateFinal.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateName.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValue.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValueIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonWrapper.cs" />
    <Compile Include="Generic\Parse\Node.cs" />
    <Compile Include="Generic\Parse\Parser.cs" />
    <Compile Include="Generic\Parse\ParserBase.cs" />
    <Compile Include="Generic\Parse\XmlParser.cs" />
    <Compile Include="Generic\Parse\XmlSerializer.cs" />
    <Compile Include="Generic\Parse\XmlWrapper.cs" />
    <Compile Include="Generic\TypeInfo.cs" />
    <Compile Include="Generic\Utils.cs" />
    <Compile Include="Generic\XmlParser.cs" />
    <Compile Include="Generic\XmlSerializer.cs" />
    <Compile Include="IClient.cs" />
    <Compile Include="list\DictList.cs" />
    <Compile Include="DictLocation.cs" />
    <Compile Include="DisposableCounter.cs" />
    <Compile Include="FileUtil.cs" />
    <Compile Include="HashList.cs" />
    <Compile Include="ILogger.cs" />
    <Compile Include="list\LinkedList.cs" />
    <Compile Include="list\SequentialDict.cs" />
    <Compile Include="list\SequentialDictString.cs" />
    <Compile Include="list\Stack.cs" />
    <Compile Include="Locker.cs" />
    <Compile Include="Logger.cs" />
    <Compile Include="LoggerConsole.cs" />
    <Compile Include="Math.cs" />
    <Compile Include="MemUtil.cs" />
    <Compile Include="misc.cs" />
    <Compile Include="OutputRecorder.cs" />
    <Compile Include="PathUtil.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Queue.cs" />
    <Compile Include="serialize\Serializer.cs" />
    <Compile Include="serialize\TextSerializer.cs" />
    <Compile Include="StringUtil.cs" />
    <Compile Include="TextWriter.cs" />
    <Compile Include="ThreadUtil.cs" />
    <Compile Include="TimeSpan.cs" />
    <Compile Include="TuningBase.cs" />
    <Compile Include="XMLTool.cs" />
    <Compile Include="ZipUtil.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\CLegacyListWriter.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.Tuning;
using pdb.gen.albums;
namespace pdb.gen
{

    public class CLegacyListWriter
    {
        private List<Piece> m_list = new List<Piece>();
        private List<Piece> m_listIni = null;
        private IEnumerable<Piece> m_enum;
        private int m_rotPeriod = -1;
        private static CPieceInListComparer c_comparer = new CPieceInListComparer();
        private bool m_bIni = false;
        private static DateTime now = DateTime.Now;
        private static Logger logger = Logger.getLogger("gen", true);
        private Consolid gen;
        public CLegacyListWriter(Consolid gen, IList<Piece> a_pieceEnumerator)
        {
            this.gen = gen;
            if (a_pieceEnumerator != null)
            {
                m_enum = a_pieceEnumerator;
                //    this.sortByAlbum = sortByAlbum; 

                foreach (Piece l_piece in m_enum)
                {
                    m_list.Add(l_piece);
                }
                m_listIni = new List<Piece>(m_list);
            }

        }


        private ICollection<ListWriterMgr> writers = new List<ListWriterMgr>();
        public void addWriter(IListWriter writer) { writers.Add(new ListWriterMgr(writer)); }


        //public void reset()
        //{

        //    const int MIN_DURATION = 10 * 3600;
        //    m_list.Clear();
        //    m_listIni.Clear();
        //    foreach (Piece l_piece in m_enum)
        //    {
        //        m_list.Add(l_piece);
        //    }
        //    if (!m_bIni)
        //    {
        //        m_bIni = true;
        //        m_listIni = new List<Piece>(m_list);

        //    }
        //    double l_totalDuration = getDuration(1, null);
        //    while (l_totalDuration < MIN_DURATION && ListSelection.Scale > 0.01)
        //    {
        //        ListSelection.Scale *= 0.9;
        //        l_totalDuration = getDuration(1, null);
        //    }

        //    // If CConf.Sort.Quality.Mode = listMode.substract Then CPiece.Scale *= 0.1


        //}
        public void writeRot(int a_base)
        {
            logger.log("write rot" + a_base);
            List<Piece> l_listPieceCLass = new List<Piece>();
            foreach (Piece l_piece in m_list)
            {
                if (l_piece.QRank > 0 && ListSelection.canPlay(l_piece, a_base))
                {
                    l_listPieceCLass.Add(l_piece);
                }
            }
            l_listPieceCLass.Sort(c_comparer);
            m_list = l_listPieceCLass;

            writePlayList("rot" + a_base, l_listPieceCLass, false, true);
        }

        //public bool SortByAlbum { set { sortByAlbum = value; } }
        //private bool sortByAlbum = true; 
        public void writeGen(ExtendToNative<datesMode> mode, ExtendToNative<double> nbHours, string baseName, bool onlyEvol, bool sortByAlbum)
        {
            try
            {
                var conf = CConf.ConfGen;
                logger.log("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol);
                bool withTimeOrder = mode.extendTimeOrder && nbHours.extendTimeOrder;

                var timeRestLimit = 0m;
                if (nbHours.level)
                {
                    CRank fictif = new CRank();
                    fictif.Quality = 1;
                    //fictif.Lenght = 1;
                    //fictif.Twice = 1;
                    DateTime dtFictif = DateTime.Now.AddDays(-nbHours.item);
                    List<DateTime> lfictif = new List<DateTime> { dtFictif };
                    timeRestLimit = CalcDate.getRest(lfictif, fictif);
                    logger.log("Limite {0} => {1} {2} ", nbHours.item, timeRestLimit, conf.Vie.TotalDays() * timeRestLimit);
                }

                List<Piece> l_listPieceCLass = new List<Piece>();
                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.QRank > 0)
                    {

                        if (!(string.IsNullOrEmpty(l_piece.ClassEvol) && onlyEvol))
                        {
                            if (l_piece.Enabled || !conf.OnlyEnabled)
                                l_listPieceCLass.Add(l_piece);
                        }

                    }
                }
                l_listPieceCLass.Sort(new PieceRestComparer());
                //  l_listPieceCLass.Sort(new PieceMaxClassementComparer());

                TimeSpan limit = TimeSpan.FromHours(nbHours.item);
                TimeSpan current = new TimeSpan();

                List<Piece> ret = new List<Piece>(l_listPieceCLass.Count);
                // string lastClassement = "";
                bool rejet = false;

                foreach (Piece piece in l_listPieceCLass)
                {
                    if (nbHours.level)
                    {
                        if (piece.Rank.TimeRest <= timeRestLimit)
                            ret.Add(piece);
                    }
                    else if (nbHours.item == 0)
                    {
                        if (piece.Rank.TimeRest == 0)
                            ret.Add(piece);
                    }
                    else
                    {
                        current += piece.Duration;
                        if (current > limit || rejet)
                        {
                            if (!rejet)
                                logger.log("writeGen rejet {0} {1} {2} {3} {4} {5} {6}", mode, nbHours, baseName, onlyEvol, piece.ClassNameAndRating(false), piece, piece.Rank.TimeRest);
                            rejet = true;
                            //if (piece.ClassNameAndRating.Equals(lastClassement))
                            //{
                            //    log.log("writeGen {0} {1} {2} {3} {4} r√©cup√©r√© par {5}", mode, nbHours, baseName, onlyEvol, piece, lastClassement);
                            //}
                            //else
                            break;
                        }
                        ret.Add(piece);
                        // log.log("writeGen {0} {1} {2} {3} {4} {5} {6}", mode, nbHours, baseName, onlyEvol, piece.ClassNameAndRating, piece, piece.Rank.TimeRest);
                        // rejet = false; 
                        // lastClassement = piece.ClassNameAndRating;
                    }
                }

                if (withTimeOrder)
                    ret.Sort(new PieceRestComparer());
                else
                {
                    if (sortByAlbum)
                        ret.Sort(new AllPieceComparer2());
                    else
                    {
                        //  ret.Sort(new PieceMaxClassementComparer());
                        ret.Sort(new CPieceComparerByQualityAndLength());
                        ret.Reverse();
                    }
                    // extension des listes normales
                    if (CConf.ConfGen.Anticipation && !nbHours.level && nbHours.item != 0 && ret.Count > 0)
                    {
                        Piece first = ret[0];
                        var listlecture = new List<Piece>(l_listPieceCLass);
                        //  listlecture.Sort(new PieceSortComparerList()); ==> Suprim√© : TODO a REFAIRE 
                        listlecture.Reverse();
                        while (true)
                        {
                            // que se passe-t-il quand le premier √©l√©ment de la liste est consomm√© (g1)
                            // si on refait le calcul

                            int indexLecture = listlecture.IndexOf(first);
                            if (indexLecture < 0)
                                break;
                            int indexPrecedentLecture = indexLecture - 1;
                            if (indexPrecedentLecture < 0)
                                break;
                            Piece precedentLecture = listlecture[indexPrecedentLecture];
                            if (ret.Contains(precedentLecture))
                                break;
                            // si le pr√©cedent dans l'ordre de la lecture est aussi le pr√©c√©dent dans l'ordre reste, on le conserve 

                            int indexRest = l_listPieceCLass.IndexOf(first);
                            if (indexRest < 0)
                                break;
                            int indexRestSuivant = indexRest + 1;
                            if (indexRestSuivant >= l_listPieceCLass.Count)
                                break;

                            Piece suivantRest = l_listPieceCLass[indexRestSuivant];
                            if (ret.Contains(suivantRest))
                                break;
                            if (suivantRest != precedentLecture)
                            {
                                int indexLecture2 = listlecture.IndexOf(suivantRest);
                                if (indexLecture2 > indexLecture)
                                    break;
                            }

                            ret.Add(precedentLecture);
                            first = precedentLecture;


                        }

                        if (withTimeOrder)
                            ret.Sort(new PieceRestComparer());
                        else
                        {
                            if (sortByAlbum)
                                ret.Sort(new AllPieceComparer2());
                            else
                            {
                                ret.Sort(new CPieceComparerByQualityAndLength());
                                ret.Reverse();
                            }
                        }

                        //ret.Sort(new PieceSortComparerList());
                        //ret.Reverse();
                    }

                }
                // 

                var large = ret;

                if (conf.GenLarge)
                    large = getLarge(ret);
                //ret.Reverse();
                //large.Reverse();

                // var hash = new HashList<Piece>(ret); 

                bool extendToNative = mode.extend && nbHours.extend;
                bool withOrder = conf.WithOrder && (nbHours.item > 0 || conf.OrderZero);
                withOrder = withOrder || withTimeOrder;
                string strLevel = "";
                if (nbHours.level)
                    strLevel = "_";
                writePlayList(mode.ToString(), baseName + strLevel + nbHours, ret, withOrder, extendToNative);

                withOrder = withOrder && conf.OrderLarge;
                if (conf.GenLarge)
                    writePlayList(mode.ToString(), baseName + strLevel + nbHours + "+", large, withOrder, extendToNative);

                //var writeGrouping = CConf.ConfGen.WriteGrouping;
                //if (writeGrouping > writeGrouping.none && (nbHours.item > 0 || conf.WriteGroupingZero))
                //{
                //    foreach (var piece in ret)
                //    {
                //        piece.MarkAsUpdateGrouping();
                //    }

                //    if (conf.GenLarge)
                //    {
                //        foreach (var piece in large)
                //        {
                //            piece.MarkAsUpdateGrouping();
                //        }
                //    }
                //}
            }
            catch (Exception ex)
            {
                misc.logError(string.Format("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol), ex);
            }
        }


        internal void writeGen(Albums albums, ExtendToNative<datesMode> mode, ExtendToNative<double> nbHours, string baseName, bool onlyEvol)
        {
            int limitSize = CConf.ConfGen.LimitList;
            bool filterNext = limitSize > 0 && gen.FilterNext;
            bool noLimit = filterNext && nbHours == null;

            try
            {
                logger.log("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol);
                bool withTimeOrder = mode != null && nbHours != null && mode.extendTimeOrder && nbHours.extendTimeOrder;

                var timeRestLimit = 0m;
                if (nbHours != null && nbHours.level)
                {
                    CRank fictif = new CRank();
                    fictif.Quality = 1;
                    //fictif.Lenght = 1;
                    //fictif.Twice = 1;
                    DateTime dtFictif = DateTime.Now.AddDays(-nbHours.item);
                    List<DateTime> lfictif = new List<DateTime> { dtFictif };
                    timeRestLimit = CalcDate.getRest(lfictif, fictif);
                    logger.log("Limite {0} => {1} {2} ", nbHours.item, timeRestLimit, CConf.ConfGen.Vie.TotalDays() * timeRestLimit);
                }

                var list = albums.makeSelection();



                TimeSpan limit = new TimeSpan();
                if (nbHours != null)
                    limit = TimeSpan.FromHours(nbHours.item);
                TimeSpan current = new TimeSpan();

                List<Album> retAlbum = new List<Album>();


                foreach (Album album in list)
                {
                    //if (album.Name.Contains(@"Ipod\noir\F07"))
                    //{

                    //}
                    if (!album.Classed)
                        continue;
                    if (!album.AtLeastOneEnabled)
                        continue;
                    if (nbHours == null)
                        retAlbum.Add(album);
                    else if (nbHours.level)
                    {
                        if (album.TimeRest <= timeRestLimit)
                            retAlbum.Add(album);
                    }
                    else if (nbHours.item == 0)
                    {
                        if (album.TimeRest == 0)
                            retAlbum.Add(album);
                    }
                    else
                    {
                        retAlbum.Add(album);
                        current += album.Duration;
                        if (current > limit)
                        {
                            break;
                        }
                    }
                }

                //retAlbum.Sort(new AlbumSortComparer());
                //retAlbum.Reverse(); 
                if (filterNext)
                {
                    retAlbum.Sort(new AlbumClassComparer2());
                    retAlbum.Reverse();
                }
                var ret = new List<Piece>();

                int nbAdd = 0;
                int rankReverseMin = int.MaxValue;
                foreach (Album album in retAlbum)
                {
                    if (filterNext)
                    {
                        var next = album.Next;
                        if (next != null)
                        {
                            if (limitSize > 0)
                            {
                                nbAdd++;
                              //  var rankAlbumReverse = album.RankAlbumReverse;

                                if (nbAdd > limitSize)
                                {
                                    //if (noLimit && rankReverseMin > 1)
                                    //{
                                    //    if (rankAlbumReverse > rankReverseMin)
                                    //        continue;
                                    //}
                                    //else
                                        break;
                                }
                                //if (rankAlbumReverse < rankReverseMin)
                                //    rankReverseMin = rankAlbumReverse;

                            }
                            ret.Add(next);
                        }

                    }
                    else
                        ret.AddRange(album.Sort());
                }


                // if (!CConf.ConfGen.AlbumOrdo)

                //ret.Sort(new AllPieceComparer());
                //ret.Reverse();
                if (!filterNext)
                    ret.Sort(new AllPieceComparer2());

                // var hash = new HashList<Piece>(ret); 
                var conf = CConf.ConfGen;
                bool extendToNative = mode != null && mode.extend && nbHours != null && nbHours.extend;
                bool withOrder = conf.WithOrder && ((nbHours != null && nbHours.item > 0) || conf.OrderZero);
                withOrder = withOrder || withTimeOrder;
                string strLevel = "";
                if (nbHours == null)
                    strLevel = "";
                else if (nbHours.level)
                    strLevel = "_";

                //var jum = ret.FindAll(t => t.Name == "Jumpin' Jack Flash"); 
                writePlayList("album\\" + mode, baseName + strLevel + nbHours, ret, CConf.ConfGen.AlbumOrdo, extendToNative, noLimit);
                //IList<Piece> large = ret;

                //large = getLarge(ret);
                //withOrder = withOrder && conf.OrderLarge;
                //writePlayList(mode.ToString(), baseName + strLevel + nbHours + "+", large, withOrder, extendToNative);

                //var writeGrouping = CConf.ConfGen.WriteGrouping;
                //if (writeGrouping > writeGrouping.none && ((nbHours != null && nbHours.item > 0) || conf.WriteGroupingZero))
                //{
                //    foreach (var piece in ret)
                //    {
                //        piece.MarkAsUpdateGrouping();
                //    }

                //    //if (conf.GenLarge)
                //    //{
                //    //    foreach (var piece in large)
                //    //    {
                //    //        piece.MarkAsUpdateGrouping();
                //    //    }
                //    //}
                //}
            }
            catch (Exception ex)
            {
                misc.logError(string.Format("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol), ex);
            }
        }




        public void writePrecisionClassement(string baseName, int precision, bool onlyEvol, bool extendToNative)
        {
            logger.log("writePrecisionClassement" + precision);
            List<Piece> l_listPieceCLass = new List<Piece>();
            foreach (Piece l_piece in m_listIni)
            {
                if (l_piece.QRank > 0)
                {
                    if (!(string.IsNullOrEmpty(l_piece.ClassEvol) && onlyEvol))
                        l_listPieceCLass.Add(l_piece);
                }
            }

            List<Piece> ret = new List<Piece>(l_listPieceCLass.Count);

            foreach (Piece piece in l_listPieceCLass)
            {
                if (piece.classPrecision() <= precision)
                    ret.Add(piece);
            }



            writePlayList("precision", baseName + precision, ret, false, extendToNative);
            var large = getLarge(ret);
            writePlayList("precision", baseName + precision + "+", large, false, extendToNative);


        }


        public void writeCheckClassement(int a_base)
        {
            logger.log("write check Classement " + a_base);
            List<Piece> l_listPieceCLass = new List<Piece>();

            if (a_base == 0)
            {
                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.ClassEvol != "")
                    {
                        l_listPieceCLass.Add(l_piece);
                    }
                }
            }
            else
            {

                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.QRank > 0 && ListSelection.mustPlayToPreciseClassement(l_piece, now, a_base)) // l_piece.mustPlayToPreciseClassement(now, a_base))
                    {
                        l_listPieceCLass.Add(l_piece);
                    }
                }
            }
            l_listPieceCLass.Sort(c_comparer);

            writePlayList("check" + a_base, l_listPieceCLass, false, true);
            var l_large = getLarge(l_listPieceCLass);
            writePlayList("_check" + a_base, l_large, false, true);
        }


        //public void writeRotMin(int a_hDuration)
        //{
        //    log("rotMax " + a_hDuration);
        //    int l_duration = 3600 * a_hDuration;
        //    m_list = writeRotMin_(l_duration);
        //    string l_name = a_hDuration.ToString();
        //    if (a_hDuration < 0)
        //        l_name = "all";

        //    string l_name0 = "rotMax" + l_name;
        //    string l_nameLarge = "_" + l_name0;


        //    writePlayList(l_name0, m_list, CConf.ConfGen.WithOrder, true);
        //    var l_large = getLarge(m_list);
        //    writePlayList(l_nameLarge, l_large, CConf.ConfGen.WithOrder, true);

        //}
        /// <summary>
        /// √©cit une liste bas√©e sur une dur√©e max
        /// </summary>
        /// <param name="a_ms">dur√©e totale de la liste, en ms</param>
        /// <remarks></remarks>
        private List<Piece> writeRotMin_(int a_ms)
        {
            double l_totalDuration = 0;
            int l_durationTarget = a_ms;
            int l_iEnd = 100 * ListSelection.Period;

            List<Piece> l_list = null;
            List<Piece> l_Oldlist = null;
            int l_period = m_rotPeriod;

            do
            {
                l_totalDuration = 0;
                l_Oldlist = l_list;

                l_list = new List<Piece>();

                l_period += 1;


                l_totalDuration = getDuration(l_period, l_list);

                //For Each l_piece As CPiece In m_list
                //    If l_piece.Rank > 0 AndAlso l_piece.canPlay(l_period) Then
                //        l_list.Add(l_piece)
                //        l_totalDuration += l_piece.Duration
                //    End If
                //Next

                m_list = l_list;
                //   log("period " + l_period.ToString() + " " + m_list.Count + "/" + (l_totalDuration / 60000).ToString(".") + " min");
            } while (l_totalDuration > l_durationTarget && l_period < l_iEnd && l_durationTarget > 0);
            m_rotPeriod = l_period - 1;

            if (l_Oldlist == null)
                l_Oldlist = l_list;
            l_Oldlist.Sort(c_comparer);
            return l_Oldlist;




        }

        private double getDuration(int a_base, IList a_list)
        {
            double l_totalDuration = 0;
            foreach (Piece l_piece in m_list)
            {
                if (l_piece.QRank > 0 && ListSelection.canPlay(l_piece, a_base))
                {
                    if (a_list != null)
                        a_list.Add(l_piece);
                    l_totalDuration += l_piece.Duration.TotalSeconds;
                }
            }
            return l_totalDuration;
        }

        private List<Piece> getLarge(IList<Piece> a_list)
        {
            var conf = CConf.ConfGen;

            HashList<Piece> l_large = new HashList<Piece>();
            var listClassEnabled = Consolid.QLClassed.FindAll(p => !conf.OnlyEnabled || p.Enabled);
            HashList<Piece> l_ref = new HashList<Piece>(listClassEnabled);
            int l_deltaBefore = CConf.Before;
            int l_deleteAfter = CConf.After;
            foreach (Piece l_piece in a_list)
            {
                int l_current = l_ref.IndexOf(l_piece); //l_piece.QLRank - 1;
                if (l_current < 0)
                    continue;
                int l_iBefore = l_current + l_deltaBefore;
                int l_after = l_current - l_deleteAfter;

                for (int l_iIndex = l_iBefore; l_iIndex >= l_after; l_iIndex--)
                {
                    if (l_iIndex >= 0 && l_iIndex < l_ref.Count)
                    {
                        var piece = l_ref[l_iIndex];
                        if ((!conf.OnlyEnabled || piece.Enabled) && !l_large.Contains(piece))
                            l_large.Add(piece);
                    }
                }
            }
            return l_large.List;
        }
        private void log(String txt)
        {
            logger.log(txt);
        }

        private void writePlayList(string folder, string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative)
        {
            writePlayList(folder, a_fileName, a_list, withOrder, extendToNative, false);
        }

        private void writePlayList(string folder, string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative, bool noLimit)
        {
            int limit = CConf.ConfGen.LimitList; // (int)(CConf.ConfGen.LimitList * 1.1);
            if (noLimit)
                limit = 0;
            var listt = a_list;

            if (limit > 0 && limit < a_list.Count)
            {
                if (gen.FilterNext)
                {
                    listt = a_list.FindAll(t => t.IsNext);
                }
                if (limit < listt.Count)
                    listt = listt.GetRange(0, limit);

                if (listt.Find(t => t.IsNext) == null)
                {
                    for (int i = limit; i < a_list.Count; i++)
                    {
                        var t = a_list[i];
                        listt.Add(t);
                        if (t.IsNext)
                            break;
                    }

                }
            }
            //BgDictString<object> dict = new BgDictString<object>();

            //if (max < a_list.Count)
            //{
            //    a_list = new List<Piece>(a_list);
            //    a_list.Reverse();
            //}
            List<IFile> list = new List<IFile>();

            //int nb = 0;
            //int nbAfterRead = -1; 
            foreach (IFile file in listt)
            {
                //if (dict.ContainsKey(file.Location))
                //{
                //    logger.log("d√©j√† pr√©sent '{0}'\\{1}\\{2} ", folder, a_fileName, file.Location);
                //}

                //else
                //{
                //    dict.Add(file.Location, file);
                list.Add(file);
                //nb++;
                //nbAfterRead++; 
                //if (nb >= max && nbAfterRead >= maxAfterRead)
                //    break;
                //   }

            }
            string GEN = "gen";
            if (!string.IsNullOrEmpty(folder) && !folder.EndsWith("\\"))
                GEN += "\\" + folder;


            foreach (ListWriterMgr writer in writers)
            {

                writer.writePlayList(GEN, a_fileName, list, withOrder);
                if (!extendToNative)
                    return;
            }
        }


        private void writePlayList(string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative)
        {
            writePlayList(null, a_fileName, a_list, withOrder, extendToNative);

        }

        //private class FileImpl : IFile
        //{
        //    private string location;
        //    private int id;


        //    public FileImpl(IFile file)
        //    {
        //        this.location = file.Location;
        //        this.id = file.PieceId;

        //    }

        //    #region IFile Members

        //    public string Location
        //    {
        //        get { return location; }
        //    }

        //    public override bool Equals(object obj)
        //    {
        //        var o = obj as IFile;
        //        if (o == null)
        //            return false;
        //        return location.Equals(o.Location);

        //    }

        //    public override int GetHashCode()
        //    {
        //        return location.GetHashCode();
        //    }

        //    public override string ToString()
        //    {
        //        return location;
        //    }

        //    #endregion


        //    public int PieceId
        //    {
        //        get { return id; }
        //    }
        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// GÔøΩre l'application propriÔøΩtaire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des donn√©es consolid√©es morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des morceux avec les enfants 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        /// <summary>
        /// Liste des morceux avec les enfants - sans les virtuels 
        /// </summary>
        private List<Piece> listPieceInAlbumReal = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;
        private bool goCompact = true;
        private bool classementChange;
        private bool _firstConsolid = true;
        private bool _albumBuild = false;
        public bool AlbumsBuild { get { return _albumBuild; } }


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private PlayList root = new PlayList("root", null);
        public PlayList Root { get { return root; } }
        private PlayList musique;
        private PlayList classement;
        private PlayList listes;
        private PlayList genres;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new PlayList("musique", root);
            classement = new PlayList("classement", root);
            listes = new PlayList("listes", root);
            genres = new PlayList("genres", listes);
            albums = new Albums(this);
        }
        /// <summary>
        /// Lance le compactage √† la prochaine g√©n√©ration
        /// </summary>
        public void GoCompact() { goCompact = true; }
        public void ClassementChange() { classementChange = true; }
        public bool ClassementChanged { get { return classementChange; } }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating(false);
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        //public void buildClassTree()
        //{
        //    buildClassTree(classement);
        //}


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private bool filterOnlyNext = true;
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                }
            }
        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public Albums Albums { get { return albums; } }
        public void invalidateAlbums()
        {

            albums.invalidateAll(true);
            // pour l'instant ne fonctionne pas 
            return;
            _albumBuild = false;
        }

        public bool AlbumBuild { get { return _albumBuild; } }

        private void buildVirtualFromList(PlayList pl, List<Piece> list)
        {
            string path = pl.getPath(listes, genres);
            foreach (IItem item in pl.Items)
            {
                var piece = htIds[item.ID];
                var v = piece.createVirtualAlbum(path, virtualMode.list, null);
                if (v != null)
                {
                    list.Add(v);
                }
            }

            foreach (PlayList sub in pl.PlayLists)
            {
                buildVirtualFromList(sub, list);
            }
        }

        public void ConsolidInit(IEnumerable<ITrackInfoItunes> dbList)
        {
            if (_albumBuild)
                return;
            allClassed.Clear();
            allClassedInAlbumEnabled.Clear();
            m_listTrackClassed.Clear();

            listPiece.Clear();
            listPieceInAlbum.Clear();
            listPieceInAlbumReal.Clear();
            all.Clear();

            // albums = new Albums(this);
            // VirtualPiece.init();

            //htIds.Clear();

            //  htIds = new BgDict<int, Piece>();
            foreach (ITrackInfoItunes track in dbList)
            {

                if (!track.isPodcast)
                {
                    Piece piece = null;
                    int pieceId = track.PieceId;
                    if (htIds.ContainsKey(pieceId))
                    {
                        piece = htIds[pieceId];
                        piece.initRank();
                    }
                    else
                    {
                        piece = new Piece(track);
                        htIds.Add(pieceId, piece);
                    }

                    all.Add(piece);

                }
            }
            // link
            foreach (Piece piece in all)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.setParent(htIds[parentId]);
                }
            }

            // liste FORT + albums


            albums.checkBuild();
            logger.log("build albums");
            foreach (Piece piece in all)
            {

                if (piece.Parent == null)
                {
                    // piece.removeVirtualChilds(); 
                    listPiece.Add(piece);
                    foreach (Piece p in piece)
                    {
                        if (p.Virtual)
                            continue;
                        if (albums.check(p))
                        {
                            listPieceInAlbum.Add(p);
                            listPieceInAlbumReal.Add(p);
                        }
                    }
                }
            }

            var confGen = CConf.ConfGen;
            var min = confGen.AlbumMin;

            if (_albumVirtual)
            {
                logger.log("build albums virtuels");

                var listCandidat = new List<Piece>();
                var dictTmp = new BgDictString<Album>();
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        piece.buildVirtualAlbums(listCandidat);
                    }
                }

                if (CConf.ConfGen.ListVirtual)
                {
                    buildVirtualFromList(listes, listCandidat);
                }

                foreach (Piece p in listCandidat)
                    albums.checkVirtual(p, dictTmp);




                min = confGen.PathVirtualMin;
                if (min > 1)
                {
                    // Suppression des albums virtuel par r√©pertoire avec trop peu de morceaux
                    foreach (var key in new List<string>(dictTmp.Keys))
                    {
                        var a = dictTmp[key];
                        if (a.VirtualMode == virtualMode.path || a.VirtualMode == virtualMode.extended)
                        {
                            if (a.Count < min)
                            {
                                a.ClearAndMenage();
                                dictTmp.Remove(key);
                            }
                        }
                    }
                }

                if (confGen.ArtistVirtual)
                {
                    min = confGen.ArtistVirtualMin;
                    if (min > 1)
                    {
                        // Suppression des albums artiste avec trop peu de morceaux
                        foreach (var key in new List<string>(dictTmp.Keys))
                        {
                            var a = dictTmp[key];
                            if (a.VirtualByArtist)
                            {
                                if (a.Count < min)
                                {
                                    a.ClearAndMenage();
                                    dictTmp.Remove(key);
                                }

                            }
                        }
                    }
                }


                if (confGen.WordVirtual)
                {
                    min = confGen.WordVirtualMin;
                    if (min > 1)
                    {
                        // Suppression des albums artiste avec trop peu de morceaux
                        foreach (var key in new List<string>(dictTmp.Keys))
                        {
                            var a = dictTmp[key];
                            if (a.VirtualMode == virtualMode.word)
                            {
                                if (a.Count < min)
                                {
                                    a.ClearAndMenage();
                                    dictTmp.Remove(key);
                                }

                            }
                        }
                    }
                }




                var listAlbums = new List<Album>(dictTmp.Values);

                listAlbums.Sort(new VirtualAlbumComparer());
                albums.checkVirtuals(listAlbums, listPieceInAlbum);

                foreach (Piece piece in all)
                {
                    piece.menageChilds();
                }

            }

            albums.buildDone();

            // Suppression des albums avec trop peu de morceaux
            min = confGen.AlbumMin;
            if (min > 1)
            {
                // Suppression des albums standards avec trop peu de morceaux
                var dict = albums.Dict;
                foreach (var key in new List<string>(dict.Keys))
                {
                    var a = dict[key];
                    if (!a.Virtual)
                    {
                        if (a.Count < min)
                        {
                            a.ClearAndMenage();
                            dict.Remove(key);
                        }
                    }
                }
            }
            albums.sortVirtual();
            _albumBuild = true;

        }


        public void MakeConsolid(IEnumerable<ITrackInfoItunes> dbList, bool makeSort, IClient client)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                DateTime now = DateTime.Now;
                DateTime debut = now;
                calcRank = !urgence; // && (allClassed.Count == 0 || classementChange); 
                if (calcRank)
                {
                    allClassed.Clear();
                    allClassedInAlbumEnabled.Clear();
                    m_listTrackClassed.Clear();

                    ConsolidInit(dbList);
                    //if (CConf.ConfGen.LimitAlbums > 0)
                    //    _albumBuild = false;
                    now = DateTime.Now;

                    StackAlbum.Instance.init(all);

                    misc.log("StackAlbum.Instance.init(all); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    foreach (Piece piece in listPieceInAlbum)
                    {
                        if (piece.Classement.isClassed())
                        {
                            allClassed.Add(piece);
                            //if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            //    allClassedInAlbumEnabled.Add(piece);
                        }
                    }

                    foreach (Piece piece in listPieceInAlbumReal)
                    {
                        if (piece.Classement.isClassed())
                        {
                            if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                                allClassedInAlbumEnabled.Add(piece);
                        }
                    }

                    misc.log("m_listTrackClassed: {0} elt", m_listTrackClassed.Count);
                    misc.log("listPieceInAlbum: {0} elt", listPieceInAlbum.Count);
                    misc.log("allClassed: {0} elt", allClassed.Count);
                    misc.log("allClassedInAlbumEnabled: {0} elt", allClassedInAlbumEnabled.Count);
                    // (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
                    misc.log("listPieceInAlbumReal; {0} elt {1} ms", listPieceInAlbumReal.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;



                    misc.log("makeConsolid:init; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now;
                    client.log("ranking");
                }
                Ranking(makeSort, client);
                misc.log("makeConsolid:fin; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            }
            finally
            {
                lock (_lock)
                {
                    _firstConsolid = false;
                    _consolidEnCours = false;
                    urgence = false;
                }
            }

        }

        public void buildMusique()
        {
            misc.log("buildMusique");
            //if (CConf.ConfGen.LimitList > 0)
            //    return;
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece); // addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbumReal)
            {
                if (d.Add(piece.PieceId))
                    musique.add(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif
            misc.log("fin buildMusique");
        }

        //private void buildMusique(PlayList musique)
        //{
        //    var d = new HashSet<int>();
        //    foreach (Piece piece in all)
        //    {
        //        if (d.Add(piece.PieceId))
        //            musique.add(piece); // addObj(piece);
        //    }


        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        if (d.Add(piece.PieceId))
        //            musique.add(piece);
        //    }
        //}

        public void buildMusiqueAgain()
        {
            musique.DeleteBase();
            buildMusique();
        }


        public void buildLists(PlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                // mine.add(sub);
                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }


            //foreach (PlComponent c in ext)
            //{
            //    if (c is CPlayList)
            //    {
            //        var subExt = c as CPlayList;
            //        var sub = new CPlayList(subExt.Name, mine);
            //        sub.ID = subExt.ID;
            //        // mine.add(sub);
            //        buildList(sub, subExt);
            //    }
            //    else
            //    {
            //        var t = c as IFile;
            //        var piece = htIds[t.PieceId];
            //        mine.add(new TrackList(piece));
            //    }
            //}
        }


        private bool urgence;
        private bool calcRank;
        public void setUrgence()
        {
            urgence = true;
        }
        public bool Urgence { get { return urgence; } }
        internal Album getAlbum(Piece track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(Piece track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort, IClient client)
        {
            albums.buildStack(makeSort);
            if (calcRank)
            {
                QRanking();
                //  LRanking();
                QLRanking();
                client.log("QLRanking");
            }
            DateTime now = DateTime.Now;
            if (Piece.Compact)
            {
                if (goCompact || (classementChange && CConf.ConfGen.AlbumSort.compactAny))
                {
                    lock (Albums.LockSort)
                    {
                        client.log("Albums.LockSort");
                        goCompact = false;
                        classementChange = false;
                        //var l = new List<Piece>(this.listPiece);
                        //l.Sort(new CPieceComparerByQualityAndLength2());
                        new Condenseur(listPieceInAlbum).gener2();
                        client.log("new Condenseur(listPieceInAlbum).gener2();");
                    }
                }
                misc.log("Piece.Compact; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            }


            // var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");


            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            //   logger.log("PieceRestComparer->RankRest ");
            //list.Sort(new PieceRestComparer());

            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankRest = i + 1;
            //}

            //logger.log("list.Sort(new PieceDeltaComparer());");
            //list.Sort(new PieceDeltaComparer());
            //list.Reverse();

            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankDelta = i + 1;
            //}

            //logger.log("PieceSortComparer->Sort ");
            //list.Sort(new PieceSortComparer());
            //list.Reverse();

            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.Sort = i + 1;
            //}

            albums.makeSort(_firstConsolid, client);
            if (calcRank)
            {
                logger.log("AlbumsSort ");
                var all = new List<Piece>(listPieceInAlbum);
                // if (makeSort)


                logger.log("AllPieceComparer->RankAllAlbum ");
                all.Sort(new AllPieceComparer());
                for (int i = 0; i < all.Count; i++)
                {
                    all[i].RankAllAlbum = i + 1;
                }

                client.log("AllPieceComparer"); 
            }

            // CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackInfoItunes> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackInfoItunes track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux notÔøΩs
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.Classement.ToString());
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating(false));
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");
            DateTime now = DateTime.Now;
            DateTime debut = now;



            var l_pieceComparer = new PieceDeepClassementComparer();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }

            misc.log("piece.Rank.init(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


            //on ordonne les morceaux top-down => sont privil√©gi√©s les plus en vue
            listPiece.Sort(l_pieceComparer);

            misc.log("listPiece.Sort(l_pieceComparer); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

            //compactage de la liste en tenant compte des mieux not√©s
            m_list = new CListPiece(listPiece);


            misc.log(" m_list = new CListPiece(listPiece); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.Classement.isClassed())
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now;
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }
            logger.log("fin : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now;
            // Console.WriteLine("Qranking:total classÔøΩs : " + m_listTrackClassed.Count);

            logger.log("total QRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                break;
            }
            return Convert.ToInt32(qRank);
        }
        ///// <summary>
        ///// Tri des morceaux en fonction de leur longueur
        ///// </summary>
        ///// <remarks></remarks>
        //private void LRanking()
        //{
        //    logger.log("LRanking");
        //    DateTime now = DateTime.Now;
        //    DateTime debut = now;

        //    List<Piece> l_aux = new List<Piece>(listPiece);
        //    l_aux.Sort(new CPieceComparerByLenght());
        //    for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
        //    {
        //        Piece l_piece = l_aux[l_iIndex];
        //        l_piece.LRank = l_iIndex + 1;
        //    }

        //    logger.log("total LRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));
        //}

        //public void compact()
        //{
        //    if (Piece.Compact)
        //    {
        //        if (goCompact || CConf.ConfGen.AlbumSort.compactAny)
        //        {
        //            goCompact = false;
        //            var l = new List<Piece>(this.listPiece);
        //            l.Sort(new CPieceComparerByQualityAndLength2());
        //            new Condenseur(m_listQL).gener2();
        //        }
        //    }
        //}
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit√© +longueur en cas d'√©galit√©
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now;

            m_listQL = new List<Piece>(m_listTrackClassed);
            foreach (Piece p in m_listQL)
                p.invalidateCache(false);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            //List<Piece> l_aux = new List<Piece>(listPiece);
            //l_aux.Sort(new CPieceComparerByQualityAndLength());
            //int count = l_aux.Count;
            //for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            //{
            //    Piece l_piece = l_aux[l_iIndex];
            //    l_piece.QLRank = l_iIndex + 1;
            //}

            //l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            //for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            //{
            //    Piece l_piece = l_aux[l_iIndex];
            //    l_piece.Rank.TwiceInv = l_iIndex + 1;
            //}


            //if (CConf.Condensation)
            //{
            //    var l = new List<Piece>(this.listPiece);
            //    l.Sort(new CPieceComparerByQualityAndLength2());
            //    new Condenseur(m_listQL).gener2();

            //}


            logger.log("total QLRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }


        private static volatile object _lockStat = new object();
        //   private static volatile object _lockStat2 = new object();
        private static bool buildingStat;
        const string BUILDING_STATE = @"..\building.txt";
        const string LOADING_EXCEL = @"..\busyExcel.txt";

        private void _buildStat(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 1");
                    return;
                }


                try
                {
                    if (File.Exists(LOADING_EXCEL))
                    {
                        string content = File.ReadAllText(LOADING_EXCEL);
                        misc.log(content);
                        if (content.Contains("BUSY"))
                        {
                            return;
                        }
                    }
                }
                catch (Exception ex)
                {
                    misc.logError("Impossible de lire le fichier lock excel", ex);
                    return;
                }

                buildingStat = true;
            }



            try
            {
                //bool ok = Monitor.TryEnter(_lockStat2, 60 * 1000);
                //if (!ok)
                //{
                //    misc.log("Pas pu entrer pour g√©n√©rer les stats !!!!!!");
                //    return;
                //}


                File.WriteAllText(BUILDING_STATE, "BUILDING");
                bool generDistrib = step % 10 == 0;
                var list = new List<Piece>(m_listQL);
                list.Sort(new ClassementValueDecimal0Comparer());

                if (_albumSortMode.createCourant)
                {
                    var unselected = list.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = list.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(list).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(list) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(list) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                lock (_lockStat)
                {
                    buildingStat = false;
                    File.WriteAllText(BUILDING_STATE, "FREE");
                }
                if (rappel != null)
                    rappel();
            }
        }

        public void builStats(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 0");
                    return;
                }

            }
            //  _buildStat(rappel); 
            new Thread(() => _buildStat(rappel)).Start();

        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table mÔøΩtier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }

        private CLegacyListWriter ListWriter(List<Piece> l_list, params IListWriter[] writers)
        {

            if (m_listWriter == null)
            {
                m_listWriter = new CLegacyListWriter(this, l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
            }
            return m_listWriter;

        }

        private CLegacyListWriter ListWriterAlbums(List<Piece> l_listAlb, params IListWriter[] writers)
        {
            if (m_listWriterAlb == null)
            {
                m_listWriterAlb = new CLegacyListWriter(this, l_listAlb);
                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);
            }
            return m_listWriterAlb;
        }

        public void createRot(string a_baseName,IClient client, params IListWriter[] writers )
        {
            lock (_lock)
            {
                client.log("_lock"); 
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                m_listWriter = null;
                m_listWriterAlb = null;
                listWriterAll = null;
                // var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(this, null);






                //      m_listWriter.reset();
                //m_listWriter = new CLegacyListWriter(this, l_list);
                //foreach (IListWriter writer in writers)
                //    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    ListWriter(l_list, writers);
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in l_listAlb)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in l_listAlb)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    ListWriter(l_list, writers).writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    ListWriter(l_list, writers).writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                //m_listWriterAlb = new CLegacyListWriter(this, l_listAlb);

                //foreach (IListWriter writer in writers)
                //    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    ListWriterAlbums(l_listAlb, writers);
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in l_listAlb)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in l_listAlb)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                client.log("createRot"); 
                return;

                //writeRot(1);

                //m_listWriter.writeCheckClassement(1);

                //m_listWriter.reset();
                //writeRotMin(-1);
                //writeRotMin(10);
                //writeRotMin(1);
            }
        }
        //private void writeRotMin(int a_nbHour)
        //{
        //    logger.log("----------------------");
        //    m_listWriter.writeRotMin(a_nbHour);
        //}
        //private void writeRot(int a_base)
        //{
        //    m_listWriter.writeRot(a_base);

        //}
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.IO;

namespace pdb.gen.albums
{
    public enum virtualMode
    {
        none = 0,
        artist = 1,
        path = 2,
        year = 3,
        extended = 4,
        added = 5,
        list = 6,
        word = 7
    }

    public enum sortDone : byte
    {
        none,
        phaseUn,
        phaseDeux
    }

    public class Album : IEnumerable<Piece>
    {
        const int NB_DEC = 3;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        const int A_REFAIRE_CAUSE_COMPACT = -10;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
#if GEN2
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;
#endif
        private sortDone sortStatus;

        private int nbRecent;
        private int nbDone;
        public int Recents { get { return nbRecent; } }
        public int NbDone { get { return nbDone; } }
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }


            return ret; ;
        }
        /// <summary>
        /// classementValue redress√© par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
#if GEN2
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
#else
                return ClassementValueLightSt;
#endif
            }
        }
        //  private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero
        {
            get
            {
#if GEN2
                return classementValueLightZero;
#else
                return ClassementValueLight;
#endif
            }
        }
        public decimal Rendement
        {
            get
            {
#if GEN2
                if (classementValueLight == 0) return 1; return classementValueLightZero / classementValueLight;
#else
                return 1;
#endif
            }
        }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private virtualMode mode;
        public virtualMode VirtualMode { get { return mode; } }
        //  private bool _virtual;
        public bool Virtual { get { return mode > virtualMode.none; } }
        public void setVirtual(virtualMode mode) { this.mode = mode; }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return this.mode == virtualMode.artist; } }
        private Piece pluspetitEnabled;
        public Piece PlusPetitEnabled { get { return pluspetitEnabled; } }
        private int stackValue;

        public int StackValue
        {
            get
            {

                return stackValue;
            }
            set
            {
                if (value > 0 && this.Name == "\\")
                {
                }
                else
                    stackValue = value;
            }
        }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, mode);
                return key;
            }
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            quality = CRank.MAX;
        }
        private int quality;
        public int Quality
        {
            get { return quality; }
            set { quality = value; }
        }

        public int RankAlbumReverse
        {
            get
            {
                return Albums.RankZero - quality; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
            }
        }

        private decimal timeRest = decimal.MaxValue;
        public decimal TimeRest { get { return timeRest; } set { timeRest = System.Math.Round(value, NB_DEC); } }
        public string Name { get { return name; } }

        public override string ToString()
        {
            return string.Format("{0} {1} {2} elts", name, mode, Count);
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0
        {
            get
            {
#if GEN2
                return Piece.getClassementEquiv(classementValueLightZero);
#else
                return EquivLight;
#endif
            }
        }

        //// private string moyenne = "";
        //public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empech√© par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier emp√™ch√©
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return StackIndex == stackSize; } }
        public bool AlmostFree1 { get { return StackIndex == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (build)
                throw new ApplicationException("d√©j√† build√©");
            piece.PieceAlbum = this;


            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                quality = CRank.MAX;
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public void ClearAndMenage()
        {
            if (mode == virtualMode.word && name == "029")
            {
            }
            if (mode != virtualMode.none)
            {
                foreach (Piece p in list)
                    p.setParent(null);
            }
            Clear();
        }

        public void ConsolidChilds()
        {
            foreach (Piece p in list)
                p.consolidChild();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && !p.ClassmentPositive())
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici m√™me distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le pr√©c√©dent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est class√©
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est class√©
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionn√© est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                var exists = FileRegister.Exist(next.Location);
                return false == exists;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est s√©l√©ectionn√© le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la d√©gradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return false; } }// selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<PieceExtended> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {
                #region calcul virtuel



                DecimalPiece med = null;
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                // bool combineNow = mode.combine && mode.simple;
                if (real)
                    _albumMedianne.buildVirtual(mode.combine, mode.simple);
                else
                {
                    list.Sort(new PieceClassementComparer(false));
                }


                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.main);
                    med1 = med; med2 = med;
                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, PieceExtended.mode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.main);

                    //comparaison des m√©diannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }

                    if (mode.combine && !mode.simple)
                    {
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine);
                    }


                }



                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }













                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// r√©sultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, PieceExtended.mode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouv√© est √©ventuellement tres √©lev√© (pas prise en compte des √©l√©ments non encore not√©s
                    //            // j'applique le seuil que s'il est inf√©rieur √† la m√©diane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous not√©s => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var cnext = cause.Next;
                if (cnext != null)
                {
                    if (cnext.UseCompact && !cnext.Empty)
                    {
                        if (cnext.Piece.ClassementRecentCompact)
                        {
                            cnext.UseCompact = false;
                            return A_REFAIRE_CAUSE_COMPACT;
                        }
                    }
                }
                classementValueLight = med.d;
                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    //if (mode.combine && !mode.simple)
                    //{
                    //    _albumMedianne.buildVirtual(true);
                    //    med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                    //    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    //}
                    //else
                    //{
                    //    if (true == cause.selectedMotifMin)
                    //        med = med2;
                    //    else
                    //        med = med1;
                    //}




                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

                    foreach (var p in list)
                        p.finalyse();



                    if (cause.motifUp)
                    {
                        if (cause.selectedMotifMin.HasValue)
                        {
                            if (true == cause.selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else if (selectedMotifMin.HasValue)
                        {
                            if (true == selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else
                        {
                            if (true == resultGlobalMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }


                    }

                    try
                    {
                        if (med.index != null)
                            pluspetitEnabled = med.index.Piece;
                        if (med.index != null) med.index.Piece.MedianneLight = true;
                        if (med.indexBorder != null) med.indexBorder.Piece.Border = true;
                        if (med.indexBorderEffect != null) med.indexBorderEffect.Piece.BorderEffect = true;
                        if (med.indexBorderMin != null) med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // r√©sultat : min ou main
            public bool? selectedMotifMin = null;
            public PieceExtended Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de d√©gradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<PieceExtended> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;


            // PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            PieceExtended nextZero1 = null;
            PieceExtended nextZero2 = null;

            PieceExtended min1 = null;
            PieceExtended min2 = null;
            PieceExtended min = null;
            decimal _min1 = int.MaxValue;
            decimal _min2 = int.MaxValue;
            decimal _minzero1 = int.MaxValue;
            decimal _minzero2 = int.MaxValue;
            bool realZero = false;
            PieceExtended Next = null;
            foreach (PieceExtended p in list)
            {
                var v1 = p.VirtualClassement;
                var v2 = p.VirtualClassement2;

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            _minzero1 = v1;
                            nextZero1 = p;
                            if (v1 == 0)
                                realZero = true;
                        }
                    }

                    if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2 == 0)
                                realZero = true;
                        }

                    }



                    if (v1 > 0 && v1 < _min1)
                    {
                        _min1 = v1;
                        min1 = p;
                    }

                    if (v2 > 0 && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }

                    if (p.Empty)
                        break;
                }
            }
            decimal _min = 0;
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;

            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }

            PieceExtended nextZero = null;
            decimal _minzero = int.MaxValue;
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }

            if (nextZero != null)
            {

                if (realZero)
                {
                    // le min trouv√© est √©ventuellement tres √©lev√© (pas prise en compte des √©l√©ments non encore not√©s
                    // j'applique le seuil que s'il est inf√©rieur √† la m√©diane
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.ClassementValueLightZero > classementValueLight + EPSILON || (classementValueLight > 0 && this.ClassementValueLightZero / classementValueLight > 1 + EPSILON)) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minzero < classementValueLight)
                    {
                        classementValueLight = _minzero;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {
                        classementValueLight = _min;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous not√©s => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            if (real && min != null)
                this.pluspetitEnabled = min.Piece;
            return cause;



        }


        private bool makesort(List<Piece> list, List<PieceExtended> listE, ConfMedianne mode, ConfMedianne mode0, int nbrepeat)
        {
            int count = list.Count;

            if (sortStatus == sortDone.none)   //(!sort0Done)
            {
                // list.Sort(new CPieceComparerByQualityAndLength());
                var listSortedValues = new List<decimal>();
                //classed = false;
                //for (int i = 0; i < count; i++)
                //{
                //    listSortedValues.Add(list[i].Rank.SortValue);
                //    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                //        classed = true;
                //}
                ////misc.log("make sort Duration {0}", name); 
                //m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                //  listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                {
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                }
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                //   decimal moy = 0m;
                decimal offset = Album.conf.AlbumMoyOffset;
#if GEN2
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement(true);

                    p.setClassementVirtuel(rapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;
#endif

                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }
                if (sortStatus < sortDone.phaseUn)
                    sortStatus = sortDone.phaseUn;
                //   sort0Done = true;

            }


            if (sortStatus >= sortDone.phaseDeux)
                return false;

            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;
             selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;

#if GEN2
            classementValueLightZeroSt = -1;
           
            classementValueLightZero = makeSort(listE, mode0, false);
            if (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }
#endif
            classementValueLight = makeSort(listE, mode, true);
            if (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }

            //   classementValueLightZero = A_REFAIRE_CAUSE_COMPACT;


//   while (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
//   {
//       classementValueLightZero = makeSort(listE, mode0, false);
//   }

////   var _classementValueLight = makeSort(listE, mode, true);

//   while (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
//   {
//       classementValueLight = makeSort(listE, mode, true);
//   }
#if GEN2
            var coeff1 = mode.Main.coeffVirt;
            var coeff2 = mode.Min.CoeffOld;
            var rendementmax = 1m;

            if (mode.combine)
                rendementmax = coeff1 * coeff2;
            else
                rendementmax = pdb.util.Math.Max(coeff1, coeff2);
            if (Rendement > 6 * rendementmax + 1e-6m)
            {
                nbrepeat++;
                sortStatus = sortDone.none;
                if (nbrepeat >= 3)
                {
                    // classementValueLight = classementValueLightZero;
                    return true;
                }
                return makesort(list, listE, mode, mode0, nbrepeat);

            }
#endif
            return true;
        }

        public bool makeSort(ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
          
            if (sortStatus >= sortDone.phaseDeux)
                return false;

            try
            {

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return false;

                var listE = new List<PieceExtended>(count);

                //if (CConf.ResetOneCl)
                //{

                //    // CPieceClassement.DateMin = DateTime.MinValue;
                //    decimal zer0d = 0;
                //    Piece oldKeep = null;


                //    foreach (Piece t in list)
                //    {
                //        if (t.Keep)
                //        {
                //            t.Keep = false;
                //            oldKeep = t;
                //            break;
                //        }
                //    }


                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in list)
                //    {
                //        var cl = t.DeepClassement; // p.Classement.DbValue;
                //        decimal clValue = Piece.classementHash.getCache(cl).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {

                //            if (t.LastClassementRecent || !t.Enabled)
                //            {
                //                min = null;
                //                break;
                //            }
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        min.Keep = true;
                //        var r = min.RapportClassement(true);
                //        if (r <= 0)
                //        {
                //        }
                //    }



                //    if (oldKeep != null && !oldKeep.Keep)
                //    {
                //        oldKeep.resetMedianneCompact();
                //        oldKeep.invalidateCache(true);
                //    }
                //}


                atLeastOneEnabled = false;
                int _nbr = 0;
                int _nbdone = 0;


                for (int i = 0; i < count; i++)
                {
                    var p = list[i];


                    if (sortStatus < sortDone.phaseDeux) //  (!sortDone)
                        p.resetMedianneCompact();
                    if (p.Enabled)
                    {
                        atLeastOneEnabled = true;

                    }
                    if (!p.Enabled && p.ClassmentPositive())
                        _nbdone++;
                    if (p.LastClassementRecent)
                        _nbr++;
                    var pp = new PieceExtended(p);
                    listE.Add(pp);
                }

                nbRecent = _nbr;
                nbDone = _nbdone;


                bool ret = makesort(list, listE, mode, mode0, 0);

                sortStatus = sortDone.phaseDeux;
                return ret;
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }


            return false;
        }



        public void mustRefresh()
        {
            build = false;
            sortStatus = sortDone.none;

            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
            albumAdded = DateTime.MaxValue;
        }

        public void refreshLight()
        {
            if (sortStatus == sortDone.phaseDeux)
                sortStatus = sortDone.phaseUn;           
        }



        //public decimal getTrackSortValue(int index, List<Piece> list)
        //{
        //    if (index < 0 || index >= list.Count)
        //        return 0;
        //    return list[index].RapportClassement(true);
        //}

        //decimal firstTrackSortValue = -1;
        //public decimal getFirstTrackSortValue()
        //{
        //    if (firstTrackSortValue == -1)
        //    {
        //        int count = list.Count;
        //        if (count == 0)
        //            return -1;
        //        var _list = new List<Piece>(list);
        //        _list.Sort(new PieceSortComparer());
        //        firstTrackSortValue = _list[count - 1].Rank.SortValue;
        //    }
        //    return firstTrackSortValue;
        //}
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            timeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


#region Rank
        //private CRank m_rank = new CRank();

        //public CRank Rank { get { return m_rank; } }



        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            quality = CRank.MAX;
            // rankStack = -1;
        }

        //public int QRank
        //{
        //    get { return m_rank.Quality; }
        //    set { m_rank.Quality = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}


#endregion

#region tri



#endregion

        [Flags]
        private enum unsortMode : byte
        {
            album = 1,
            artist = 2

        }
        const char SEP = '\\';
        const int MAX_PATH_LEVEL = 10;

        public void addPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            paths.Add(p);
                        }
                        ilevel++;
                    }
                    // paths.Add(path);
                }
            }
        }

        public bool containsPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    if (paths.Contains(path))
                        return true; //paths.Add(path);
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            if (paths.Contains(p))
                                return true;
                        }
                        ilevel++;
                    }

                }
            }
            return false;
        }
        public void sortVirtual()
        {
            if (this.VirtualMode == virtualMode.none)
                return;
            var list = this.list.ToList<Piece>();
            int count = list.Count;
            if (count == 0)
                return;
            list.Sort((x, y) =>
            {
                var cmp = x.MasterTrackNumberForTri.CompareTo(y.MasterTrackNumberForTri);
                if (cmp != 0)
                    return cmp;
                return x.Location.CompareTo(y.Location);
            });
            var dictArtist = new Dictionary<string, List<Piece>>();
            var dictAlbum = new Dictionary<int, string>();
            var dictDir = new Dictionary<string, List<Piece>>();
            DirSort.reset();
            foreach (Piece p in list)
            {

                DirSort.record(p);
            }

            DirSort.go();


            foreach (Piece p in list)
            {
                if (p.TrackNumber == 0)
                {
                    p.TrackNumber = list.Count + p.MasterTrackNumber;
                }
            }

            list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;

            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}

            //var list2 = new List<Piece>(list);
            //list2.Sort(new VirtualPieceComparer());

            var hs = new HashSet<int>();
            var unsorted = new List<Piece>();
            Piece pp = list[0];
            hs.Add(pp.PieceId); unsorted.Add(pp);
            //string currentArtist = pp.Artist;
            //string currentAlbum = pp.Master.Album;


            int indexC = 0;
            //  bool singleAlbum = false;
            string currentArtist = Album.getKey(pp.Artist, virtualMode.artist);
            unsortMode mode = unsortMode.album | unsortMode.artist;
            if (VirtualByArtist)
                mode = unsortMode.album;

            HashSet<string> artists = new HashSet<string>();
            HashSet<string> albums = new HashSet<string>();
            artists.Add(currentArtist);
            albums.Add(pp.Master.PieceAlbum.Key);
            //  HashSet<string> paths = new HashSet<string>();
            //int pathlevel = 0;
            //  bool found = false;
            int nbc = 0;
            while (unsorted.Count < count)
            {
                nbc++;
                //int indexAlbum = -1;
                //int indexArtist = -1;


                // addPath(pp, paths, pathlevel);

                artists.Clear();
                albums.Clear();
                //    paths.Clear();
                artists.Add(currentArtist);
                albums.Add(pp.Master.PieceAlbum.Key);


                for (int i = 0; i < count; i++)
                {

                    var p = list[i];
                    if (hs.Contains(p.PieceId))
                        continue;

                    if (mode == 0)
                    {
                        hs.Add(p.PieceId);
                        unsorted.Add(p);
                        pp = p;
                        // indexAlbum = -1;
                        indexC = i;
                        continue;
                    }
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        var artist = p.Artist;
                        if (p.Artist != pp.Artist)
                        {
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            if (currentArtist != cartist)
                            {
                                if (!artists.Contains(cartist))
                                {
                                    if (mode.HasFlag(unsortMode.album))
                                    {
                                        if (albums.Contains(p.Master.PieceAlbum.Key))
                                        {
                                            //if (albums.Count <= 1)
                                            //    indexArtist = i;
                                            continue;
                                        }
                                    }

                                    //if (pathlevel <= MAX_PATH_LEVEL)
                                    //{
                                    //    if (containsPath(p, paths, pathlevel))
                                    //        continue;
                                    //}

                                    hs.Add(p.PieceId);
                                    unsorted.Add(p);
                                    pp = p;
                                    //indexAlbum = -1;
                                    //indexArtist = -1;

                                    albums.Add(pp.Master.PieceAlbum.Key);
                                    artists.Add(cartist);
                                    //  addPath(pp, paths, pathlevel); 
                                    indexC = i;
                                    currentArtist = cartist;
                                    //   found = true;
                                    continue;

                                }
                            }
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                    {
                        var album = p.Master.PieceAlbum.Key;
                        if (!albums.Contains(album))
                        {
                            //if (pathlevel <= MAX_PATH_LEVEL)
                            //{
                            //    if (containsPath(p, paths, pathlevel))
                            //        continue;
                            //}
                            hs.Add(p.PieceId);
                            unsorted.Add(p);
                            pp = p;
                            indexC = i;
                            //indexAlbum = -1;
                            albums.Add(album);
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            artists.Add(cartist);
                            currentArtist = cartist;
                            //   found = true;
                            //  addPath(pp, paths, pathlevel); 
                        }
                    }
                }


                //if (indexAlbum >= 0)
                //{
                //    // pas trouv√© d'autre artiste, on se rabat sur l'album
                //    var p = list2[indexAlbum];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexAlbum;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else if (indexArtist >= 0)
                //{
                //    // on a trouv√© un autre artiste sur le m√™me album. pas si mal
                //    var p = list2[indexArtist];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexArtist;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else
                //{
                //    // rien trouv√© de sp√©cial
                //    if (indexC == 0 && !singleAlbum)
                //    {
                //        singleAlbum = true;
                //    }
                //    indexC = 0;

                //}

                if (indexC == 0)
                {

                    //if (found)
                    //{
                    //    found = false;
                    //}
                    //else
                    //{
                    //{
                    //    if (paths.Count == 0)
                    //    {
                    //        pathlevel = MAX_PATH_LEVEL; 
                    //    }
                    //    if (pathlevel < MAX_PATH_LEVEL)
                    //    {
                    //        pathlevel++;
                    //    }
                    //    else
                    //    {
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        if (mode.HasFlag(unsortMode.album))
                            // on cherche les artistes diff√©rents ( √©ventuellement m√™me album ) 
                            mode &= ~unsortMode.album;
                        else
                        {
                            // on abandonne la recherche artiste et on r√©active la recherche album
                            mode &= ~unsortMode.artist;
                            mode |= unsortMode.album;
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                        // on est en mode single album; 
                        mode &= ~unsortMode.album;

                    //pathlevel = 0;
                    //  }
                }
                //}
                // }
                indexC = 0;

            }

            for (int i = 0; i < unsorted.Count; i++)
            {
                unsorted[i].TrackNumber = i + 1;
            }



            //foreach (Piece p in list)
            //{
            //    if (p == null)
            //        continue;
            //    var artist = p.Artist;
            //    FileInfo file = null;
            //    try
            //    {
            //        file = new System.IO.FileInfo(p.Location);
            //    }
            //    catch
            //    {
            //        continue;
            //    }
            //    var dirAlbum = file.Directory;
            //    var dirArtist = dirAlbum.Parent;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = dirArtist.FullName;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = "-";
            //    if (!dictArtist.ContainsKey(artist))
            //        dictArtist.Add(artist, new List<Piece>());
            //    dictArtist[artist].Add(p);

            //    var _album = p.Master.Album;
            //    if (string.IsNullOrEmpty(_album))
            //        _album = dirAlbum.FullName;
            //    dictAlbum.Add(p.PieceId, _album);

            //    //if (!dictAlbum.ContainsKey(_album))
            //    //    dictAlbum.Add(_album, new List<Piece>());
            //    //dictAlbum[_album].Add(p);


            //}

            //foreach (List<Piece> l in dictArtist.Values)
            //{
            //    //
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //var listUnSortArtist = new List<Piece>(list);
            //listUnSortArtist.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));

            //var listUnSortAlbum = new List<Piece>();

            //List<Piece> aux = new List<Piece>();
            //int current = 0;

            //foreach (Piece p in listUnSortArtist)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {
            //        //aux.Add(p);
            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            string xa = x.Master.Album;
            //            string ya = y.Master.Album;
            //            if (dictAlbum.ContainsKey(x.PieceId))
            //                xa = dictAlbum[x.PieceId];
            //            else
            //            { }
            //            if (dictAlbum.ContainsKey(y.PieceId))
            //                ya = dictAlbum[y.PieceId];
            //            else
            //            { }
            //            var cmp = xa.CompareTo(ya);
            //            return cmp;
            //        });

            //        listUnSortAlbum.AddRange(aux);
            //        aux.Clear();

            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    string xa = x.Master.Album;
            //    string ya = y.Master.Album;
            //    if (dictAlbum.ContainsKey(x.PieceId))
            //        xa = dictAlbum[x.PieceId];
            //    else
            //    { }
            //    if (dictAlbum.ContainsKey(y.PieceId))
            //        ya = dictAlbum[y.PieceId];
            //    else
            //    { }
            //    var cmp = xa.CompareTo(ya);
            //    return cmp;
            //});

            //listUnSortAlbum.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnSortAlbum.Count; i++)
            //{
            //    listUnSortAlbum[i].TrackNumber = i + 1;
            //}

            //aux.Clear();
            //current = 0;
            //var listUnsortTrack = new List<Piece>();

            //foreach (Piece p in listUnSortAlbum)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {

            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            var xt = x.MasterTrackNumber;
            //            var yt = y.MasterTrackNumber;
            //            int cmp = 0;
            //            if (xt <= 0 || yt <= 0)
            //            {
            //                try
            //                {
            //                    cmp = x.Location.CompareTo(y.Location);
            //                }
            //                catch
            //                {
            //                }
            //            }
            //            cmp = xt.CompareTo(yt);
            //            return cmp;
            //        });

            //        listUnsortTrack.AddRange(aux);
            //        aux.Clear();
            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    var xt = x.MasterTrackNumber;
            //    var yt = y.MasterTrackNumber;
            //    int cmp = 0;
            //    if (xt <= 0 || yt <= 0)
            //    {
            //        try
            //        {
            //            cmp = x.Location.CompareTo(y.Location);
            //        }
            //        catch
            //        {
            //        }
            //    }
            //    cmp = xt.CompareTo(yt);
            //    return cmp;
            //});

            //listUnsortTrack.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnsortTrack.Count; i++)
            //{
            //    listUnsortTrack[i].TrackNumber = i + 1;
            //}




            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;
            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}
        }

        public bool isSameOf(Album o)
        {
            if (o == this)
                return false;
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && mode == o.mode;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }
        private DateTime albumAdded = DateTime.MaxValue;
        public DateTime AlbumAdded
        {
            get
            {
                if (albumAdded < DateTime.MaxValue)
                    return albumAdded;
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                albumAdded = min;
                return albumAdded;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, virtualMode mode)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();

                if (mode == virtualMode.word)
                {
                    __album = string.Format("¬§¬§[{0}]", __album);
                    return __album;
                }
                if (mode == virtualMode.list)
                {
                    __album = string.Format("/{0}", __album);
                    return __album;
                }

                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (mode == virtualMode.artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }
                else if (mode == virtualMode.year)
                {
                    if (_album.Length == 3)
                        __album = string.Format("¬£[{0}0']", __album);
                    else
                        __album = string.Format("¬£[{0}]", __album);
                }
                else if (mode == virtualMode.extended)
                {
                    __album = string.Format("¬§[{0}]", __album);
                }
                else if (mode == virtualMode.added)
                {
                    __album = string.Format("<{0}>", __album);
                }

            }
            return __album;

        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }

        /// <summary>
        /// r√©f√©rence constante des albums
        /// </summary>
        private BgDictString<Album> dict0 = new BgDictString<Album>();
        /// <summary>
        /// Albums r√©els ou virtuels
        /// </summary>
        private BgDictString<Album> dict = new BgDictString<Album>();
        public BgDictString<Album> Dict { get { return dict; } }
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object();
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }


        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                foreach (Album album in dict0.Values)
                {
                    album.checkBuild();
                }
                dict.Clear();
            }
        }

        private string getKey(string _album, virtualMode mode)
        {
            return Album.getKey(_album, mode);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                var confGen = CConf.ConfGen;
                var min1 = confGen.AlbumMin;
                var min2 = confGen.PathVirtualMin;
                var min3 = confGen.ArtistVirtualMin;
                foreach (Album album in new List<Album>(dict.Values))
                {
                    int count = album.Count;
                    bool toKeep = album.buildDone();
                    if (toKeep)
                    {

                        if (album.Virtual)
                        {
                            if (album.VirtualByArtist)
                            {
                                if (min3 > 1 && count < min3)
                                    toKeep = false;
                            }
                            else if (min2 > 1 && count < min2)
                                toKeep = false;
                        }
                        else if (min1 > 1 && count < min1)
                            toKeep = false;



                        if (!toKeep)
                        {
                            //album.Clear(); 
                            // misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " √©l√©ments"));
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }

                    }

                }


            }
        }



        private bool check_(Piece piece, string albumOrg, virtualMode mode, IDictionary<string, Album> dict)
        {
            string key = getKey(albumOrg, mode);


            var album = dict[key];
            if (album == null)
            {
                album = dict0[key];
                if (album == null)
                {
                    //  misc.log("creation album {0}", __album);
                    album = new Album(albumOrg, key);
                    dict0.Add(key, album);

                }
                album.setVirtual(mode);
                dict.Add(key, album);
            }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualMode, dict);
        }

        public int Count { get { return dict.Count; } }
        public static int RankZero { get; set; }





        public void sortVirtual()
        {
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        //public void consolidChilds()
        //{
        //    misc.log("consolidChilds");
        //    foreach (Album album in dict.Values)
        //    {
        //        album.ConsolidChilds();
        //    }
        //}

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {

            if (piece.Virtual)
            {
                if (!check_(piece, dict))
                {
                }
                // piece.setParent(null);
            }

        }

        public Album getAlbum(Piece piece)
        {
            return piece.PieceAlbum;
            //string __album = "-";
            //var _album = piece.Album;
            //if (!string.IsNullOrEmpty(_album))
            //{
            //    __album = _album.Trim();
            //    return dict[__album];
            //}
            //return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            var now = DateTime.Now;
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
            misc.log("buildStack; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
        }


        /// <summary>
        /// On fait en premier le makesort de l'album qui a chang√©
        /// </summary>
        /// <param name="album"></param>
        public void makeSort(Piece piece)
        {
            if (piece == null)
                return;
            //var album = piece.PieceAlbum;
            //if (album == null)
            //    return;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;

                album.mustRefresh();
                album.makeSort(confMedianne, conf0); //listRef, reference); 
                                                     //  album.mustRefresh();
            }

        }
        // private int nbSort=1;
        //private bool urgence;
        //public void setUrgence() { urgence = true; }
        //public bool Urgence { get { return urgence; } } 
        public void makeSort(bool sortAll, IClient client)
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var main = confMedianne.Main;
                var min = confMedianne.Min;
                var mainCoeffVirt = main.coeffVirt;
                var mainCoeffOld = main.CoeffOld;

                var minCoeffVirt = min.coeffVirt;
                var minCoeffOld = min.CoeffOld;




                if (confSort.reset)
                {
                    main.coeffVirt = 1;
                    main.CoeffOld = 1;
                    min.coeffVirt = 1;
                    min.CoeffOld = 1;
                }

                List<Album> list = new List<Album>(dict.Values);
                List<Album> listw = list;
                HashSet<Album> hs = null;
                DateTime now = DateTime.Now;
                DateTime debut = now;

                bool partial = false;
#if GEN2
                partial = !sortAll && confSort.optimSize > 0 && consolid.Urgence;
#endif

                int step = 0;
                Album last = null;
                // int coeffSort = 1;

                while (true)
                {
                    step++;

                    if (partial)
                    {
                        //nbSort++;
                        //coeffSort = 1; 

                        //int _nbSort = nbSort;
                        //while (_nbSort >=2 && _nbSort % 2 == 0)
                        //{
                        //    coeffSort *= 2;
                        //    _nbSort /= 2; 
                        //}
                        hs = new HashSet<Album>();
                        list.Sort(new AlbumClassComparer2());
                        list.Reverse();
                        listw = new List<Album>();
                        decimal equivLightMax = 0;
                        decimal equivLightZeroMax = 0;
                        int nb = 0;
                        int max = step * confSort.optimSize; // *coeffSort;

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                nb++;
                                listw.Add(a);
                                hs.Add(a);

                                var _classementValueLight = a.ClassementValueLight;
                                if (_classementValueLight > equivLightMax)
                                {
                                    equivLightMax = _classementValueLight;
                                    last = a;
                                }

                                var _classementValueLightZero = a.ClassementValueLightZero;

                                if (_classementValueLightZero > equivLightZeroMax)
                                {
                                    equivLightZeroMax = _classementValueLightZero;
                                    last = a;
                                }

                                if (nb >= max)
                                    break;
                            }
                        }


                        var equivZeroVerif = equivLightZeroMax * pdb.util.Math.Pow(main.coeffVirt, main.safe) * pdb.util.Math.Pow(min.coeffVirt, min.safe) * main.CoeffOld * min.CoeffOld;
                        var dxMin = min.dcoeff;
                        var dxMain = pdb.util.Math.Pow(main.dcoeff, main.safe);
                        var equivVerif = equivLightMax * (dxMain * dxMin);

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                var _classementValueLight = a.ClassementValueLight;


                                if (_classementValueLight < equivVerif && _classementValueLight < equivZeroVerif)
                                {
                                    if (hs.Add(a))
                                    {
                                        listw.Add(a);
                                        if (_classementValueLight > equivLightMax)
                                        {
                                            equivLightMax = _classementValueLight;
                                            last = a;
                                        }

                                    }
                                }

                            }
                        }

                    }
                    if (!consolid.Urgence)
                    {
                        int nbSorted = 0;
                        foreach (Album album in listw)
                        {
                            if (client.Cancel)
                                return;
                            if (album.makeSort(confMedianne, conf0)) //listRef, reference); 
                                nbSorted++;
                        }

                        string infoAlbum = "";
                        if (last != null)
                        {
                            infoAlbum = string.Format("last={0} {1} {2} {3}", last.Tracks[0].RankAlbumReverse, last.EquivLight0, last.EquivLight, last);
                        }
                        //   misc.log(string.Format("makeSort : nbSort={0} coeffSort={1} step={2}  {3} albums {4} ms {5}", nbSort, coeffSort, step, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        misc.log(string.Format("makeSort : step={0}  {1}/{2} albums {3} ms {4}", step, nbSorted, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        client.log(string.Format("album.makeSort {0} elt", nbSorted));
                    }
                    now = DateTime.Now;
                    //if (confSort.reset)
                    //{
                    main.coeffVirt = mainCoeffVirt;
                    main.CoeffOld = mainCoeffOld;
                    min.coeffVirt = minCoeffVirt;
                    min.CoeffOld = minCoeffOld;

                    // }


                    list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                    misc.log("list.Sort(new AlbumClassComparer {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


                    list.Reverse();
                    misc.log("list.Reverse(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    client.log("AlbumClassComparer");

                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (album.AtLeastOneEnabled)
                            RankZero = i + 2;
                        album.Quality = i + 1;
                    }
                    client.log("album.Quality");
                    misc.log("album.Quality {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    if (!partial)
                        break;


                    list.Reverse();

                    int nbCheck = 0;
                    bool? check = null;
                    foreach (Album a in list)
                    {
                        if (!a.AtLeastOneEnabled)
                            continue;
                        if (hs.Contains(a))
                        {
                            nbCheck++;
                            if (nbCheck >= confSort.optimCheck) // * coeffSort)
                            {
                                check = true;
                                break;
                            }
                        }
                        else
                        {
                            check = false;
                            break;
                        }


                    }

                    if (check == null || check.Value)
                        break;

                }


                misc.log(string.Format("makeSort albums total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));

                List<Album> listSt = null;
                List<Album> list0 = null;
                List<Album> listSt0 = null;


                if (confSort.sortSt || confSort.correcMainRank || confSort.correcMainCoeff || confSort.correcMainZero)
                {
                    listSt = new List<Album>(list);

                    listSt.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                    listSt.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        listSt[i].RankSt = i + 1;
                    }
                    misc.log(string.Format("sort St : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sort0)
                {
                    now = DateTime.Now;
                    list0 = new List<Album>(list);

                    list0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                    list0.Reverse();
                    for (int i = 0; i < list0.Count; i++)
                    {
                        list0[i].RankZero = i + 1;
                    }
                    misc.log(string.Format("sort 0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sortSt0 || confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    listSt0 = new List<Album>(list);

                    listSt0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, conf0));
                    listSt0.Reverse();
                    for (int i = 0; i < listSt0.Count; i++)
                    {
                        listSt0[i].RankZeroSt = i + 1;
                    }
                    misc.log(string.Format("sort St0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                client.log("tri pour faire joli"); 
#if GEN2
                if (confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;

                                if (o.RankZero > un.RankZero)
                                {
                                    correc = false;
                                    break;
                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }
                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }



                    //now = DateTime.Now;
                    //for (int i = listSt.Count - 1; i >= 0; i--)
                    //{
                    //    Album un = listSt[i];
                    //    Album zero = listSt0[i];
                    //    if (un.DontTouchSelectedCoeff)
                    //        continue;
                    //    if (un == zero)
                    //        un.InvalidateMain();
                    //}
                    misc.log(string.Format("correcMainRank : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainCoeff)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLightSt * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLightSt;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }
                    misc.log(string.Format("correcMainCoeff : {0} ms", (DateTime.Now - now).TotalMilliseconds));

                }
                if (confSort.correcMainZero)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {




                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                if (o.Name == "Ill Communication")
                                {
                                }
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;


                                if (o.ClassementValueLightZeroSt < un.ClassementValueLightZeroSt)
                                {
                                    if (o.RankZero > un.RankZero)
                                    {
                                        correc = false;
                                        break;
                                    }
                                }

                                if (!unClassementRecent)
                                {
                                    if (o.ClassementValueLightZeroSt == un.ClassementValueLightZeroSt)
                                    {
                                        if (confSort.correcMainZeroCheckEquality)
                                        {
                                            if (onext.LastClassementRecent)
                                            {
                                                if (o.RankZero > un.RankZero)
                                                {
                                                    correc = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }


                                //if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //    break;
                                // }



                                //if (o.RankSt <= un.RankSt)
                                //{
                                //    if (o.RankZeroSt > un.RankZeroSt)
                                //    {
                                //        correc = false;
                                //        break;
                                //    }

                                //    if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //        break;
                                //}

                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }


                    misc.log(string.Format("correcMainZero : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

#endif


                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}
                var limit = CConf.ConfGen.LimitAlbums;
                if (limit > 0)
                {
                    var l = new List<Album>();
                    list.Sort(new AlbumClassComparer2());
                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (i < limit)
                        {
                            l.Add(album);
                            album.ConsolidChilds();
                            album.sortVirtual();
                        }
                        else
                        {
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }
                    }
                    list = l;

                }

                misc.log(string.Format("makeSort total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var now = DateTime.Now;
            var list = new List<Album>(dict.Values);

            //var confGen = CConf.ConfGen;
            //var min1 = confGen.AlbumMin;
            //var min2 = confGen.PathVirtualMin;
            //var min3 = confGen.AristVirtualMin;
            //foreach (Album album in dict.Values)
            //{
            //    int count = album.Count;
            //    bool toKeep = true;


            //    if (album.Virtual)
            //    {
            //        if (album.VirtualByArtist)
            //        {
            //            if (min3 > 1 && count < min3)
            //                toKeep = false;
            //        }
            //        else if (min2 > 1 && count < min2)
            //            toKeep = false;
            //    }
            //    else if (min1 > 1 && count < min1)
            //        toKeep = false;



            //    if (!toKeep)
            //    {
            //        misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " √©l√©ments"));
            //    }
            //    else
            //        list.Add(album);

            //}

            foreach (Album album in list)
            {
                album.makeSelection();
            }
            //list.Sort(new AlbumRestComparer());
            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankRest = i + 1;
            //}

            misc.log(string.Format("make selection : {0} ms", (DateTime.Now - now).TotalMilliseconds));
            return list;
        }

        //public void changeAlbum(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Album, false)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();
        //    check_(p, newA, false, this.dict);
        //    var newAlb = dict[getKey(newA, false)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();

        //    //  invalidate(p); 
        //}

        //public void changeArtist(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Artist, true)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();

        //    check_(p, newA, true, this.dict);
        //    var newAlb = dict[getKey(newA, true)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();
        //}

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                //if (candidat.VirtualMode == virtualMode.added)
                //{
                //    if (candidat.Name=="09/1012")
                //    {

                //    }
                //    if (candidat.Name =="22/09/2012")
                //    {

                //    }
                //}
                bool found = false;

                foreach (Piece p in candidat)
                {
                    var master = p.Master.PieceAlbum;
                    if (master.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    foreach (Album album in dict.Values)
                    {
                        if (album.isSameOf(candidat))
                        {
                            found = true;
                            break;
                        }
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique √† un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.ClearAndMenage();
                }
                else
                {
                    // on le prend.
                    string key = getKey(candidat.Name, candidat.VirtualMode);
                    if (!dict0.ContainsKey(key))
                        dict0.Add(key, candidat);
                    dict.Add(key, candidat);
                    foreach (Piece p in candidat)
                    {
                        //   p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }




        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(Piece track)
        {
            track.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track);

        }

        #region invalider


        public void invalidateAll(bool total)
        {
            foreach (var a in dict0.Values)
            {
                if (total)
                    a.mustRefresh();
                else
                    a.refreshLight();
            }
        }
        //public void invalidate(Piece piece)
        //{
        //    foreach (var p in piece.Master)
        //    {
        //        var key = getKey(p.Album, p.VirtualByArtist);
        //        var a = dict[key];
        //        if (a == null)
        //        {
        //        }
        //        else
        //            a.invalidate();
        //        //if (p.Virtual)
        //        //    continue; 
        //        ////1. check standard
        //        //var key = getKey(p.Album, false);
        //        //var a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 
        //        ////2. check artiste
        //        //key = getKey(p.Artist, true);
        //        //a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 

        //        ////3. check paths
        //        //foreach (string path in p.getIntermediaryPath())
        //        //{
        //        //    key = getKey(path, false);
        //        //    a = dict[key];
        //        //    if (a == null)
        //        //    {
        //        //    }
        //        //    else
        //        //        a.invalidate(); 
        //        //}
        //    }
        //}
        #endregion



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\MasterPiece.cs">
    <content><![CDATA[using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;

namespace pdb.db
{
    public class MasterPiece : IMasterPiece, IData
    {
        private const string TOKEN_DISABLED = "disabled";
        public const string TOKEN_DURATION = "duration";
        //dur√©e en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private CPieceClassement m_classement;
        private CListDate m_dates;
        private CListFile m_files;
        private CPieceChecked m_Enabled;
        private static MasterPiece _NULL = new MasterPiece();
        public static MasterPiece NULL { get { return _NULL; } }

        public MasterPiece()
        {
            m_dates = new CListDate();
            m_files = new CListFile();
            m_classement = new CPieceClassement(this);
            m_Enabled = new CPieceChecked();
        }
        public MasterPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);

            m_dates = new CListDate(a_xml);
            m_files = new CListFile(a_xml);
            m_classement = new CPieceClassement(this, a_xml);
            m_Enabled = new CPieceChecked();
            var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);

            if (xDisabled != null)
            {
                if (xDisabled.InnerText == "false")
                    Checked.Enable();
                else
                    Checked.Disable();
            }

            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xmlTool.getNodeValue(TOKEN_DURATION);




            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }

        }
        public CPieceClassement Classement { get { return m_classement; } }
        public CListFile Files { get { return m_files; } }
        public CListDate ListDates { get { return m_dates; } }
        internal CPieceChecked Checked { get { return m_Enabled; } }

        Classement IMasterPiece.Classement
        {
            get { return m_classement.Value; }
        }

        Classement IMasterPiece.DeepClassement
        {
            get { return m_classement.DbValue; }
        }

        Classement IMasterPiece.MaxClassement { get { return m_classement.MaxClassement(); } }


        public void setClassement(string className, int rating)
        {
            m_classement.setClassement(className, rating);
        }


        public void setClassement(string strClassement)
        {
            var cl = pdb.obj.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);

            m_classement.Value = cl;
        }



        public void write(XmlWriter w)
        {

            if (!Checked.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "");
            Classement.write(w);
            Files.write(w);
            ListDates.write(w);




        }

        public bool HasChange(MasterPiece lastFull)
        {
            if (m_classement.HasChange(lastFull.m_classement))
                return true;
            if (m_files.HasChange(lastFull.m_files))
                return true;
            if (m_dates.HasChange(lastFull.m_dates))
                return true;
            return false;
        }

        public void writeDiff(XmlWriter w, MasterPiece lastFull)
        {
            m_classement.writeDiff(w, lastFull.m_classement);
            var major = m_files.writeDiff(w, lastFull.m_files);
            m_dates.writeDiff(w, lastFull.m_dates, major);

            if (!Checked.Enabled && lastFull.Checked.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "");

            if (Checked.Enabled && !lastFull.Checked.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "false");


            if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
        }

        private exportState _exportState;
        public exportState ExportStatus
        {
            get
            {
                return _exportState;
            }
            set
            {
                _exportState = value;
            }
        }

        public string Location
        {
            get
            {
                return m_files.Path;
            }
        }


        public List<string> RelativesPath
        {
            get
            {

                var _RelativesPath = new List<string>();
                foreach (CFile f in m_files)
                {
                    _RelativesPath.Add(f.File);
                }
                return _RelativesPath;
            }
        }

        public DateTime PlayedDate
        {
            get { return m_dates.LastModif; }
        }

        public List<DateTime> Dates
        {
            get { return m_dates.Dates; }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return m_classement.getDates();
            }
        }

        public List<DateTime> DatesClassement
        {
            get
            {
                return m_classement.getDates();
            }
        }


        public bool Enabled
        {
            get
            {
                return m_Enabled.Enabled;
            }

            set
            {
                if (value)
                    m_Enabled.Enable();
                else
                    m_Enabled.Disable();
            }
        }

        public void consolid(MasterPiece remote, mergePriority a_priority)
        {

            m_classement.Consolid(remote.m_classement, a_priority);
            Checked.Consolid(remote.Checked, a_priority);

            if (m_duration.TotalMilliseconds < 2)
                this.m_duration = remote.m_duration;
            else if (remote.m_duration.TotalMilliseconds < 2)
                remote.m_duration = this.m_duration;
            else if (a_priority == mergePriority.right)
                m_duration = remote.m_duration;

            addData(remote);
        }

        public void addData(MasterPiece other)
        {
            m_dates.merge(other.m_dates);
            //  other.ListDates.merge(ListDates);

            m_files.merge(other.m_files);
            // other.Files.merge(Files);
        }


        public void addDataLink(MasterPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);


            Classement.mergeOnlyVersion(other.Classement);
            other.Classement.mergeOnlyVersion(Classement);
        }

        public TimeSpan Duration
        {
            get { return m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    m_duration = value;
                }

            }
        }
        public int DurationInSec
        {
            get { return Convert.ToInt32(Duration.TotalSeconds); }
        }

        public String ClassEvol
        {
            get { return getClassementEvol(); }
        }
        public String getClassementEvol()
        {
            DateTime playedCorr = ListDates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= Duration;
            }
            catch (Exception)
            {
                // logTrack.log("{0} impossible de corriger la date jou√©e {1} avec la dur√©e {2}", this, ListDates.LastModif, Duration);
            }
            if (Classement.LastModif > playedCorr)
            {
                return Classement.Evol;
            }
            return "";

        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListDate.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;

namespace pdb.db.obj
{

    /// <summary>
    /// liste des dates d'√©coute d'un morceau
    /// </summary>
    /// <remarks></remarks>
    /// 

    class ListenDate : IComparable, IEquatable<ListenDate>
    {
        public readonly DateTime date;
        public readonly bool deleted;
        public ListenDate(XmlElement node)
        {
            deleted = XMLTool.getDeleted(node);
            date = Convert.ToDateTime(node.InnerText);
        }
        public ListenDate(DateTime dt)
        {
            this.date = dt;
        }

        public int CompareTo(object obj)
        {
            var o = obj as ListenDate;
            if (o == null)
                return -1;
            return -this.date.CompareTo(o.date);
        }

        public bool Equals(ListenDate other)
        {
            if (other == null)
                return false;
            return date.Equals(other.date);
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as ListenDate);
        }

        public override int GetHashCode()
        {
            return date.GetHashCode();
        }
        public override string ToString()
        {
            return date.ToString();
        }
    }

    public class CListDate : IData
    {

        private const string DATES = "dates";

        private const string DATE = "date";
        private List<ListenDate> m_list = new List<ListenDate>();
        public static int Period = 30;

        private static CDateComparer c_comparer = new CDateComparer();
        private static DateTime min = new DateTime(1970, 3, 27);
        public CListDate(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, DATES);
            if (l_xml == null)
                return;
            foreach (XmlElement l_xmlDate in l_xml)
            {
                m_list.Add(new ListenDate(l_xmlDate));
            }
        }
        public CListDate()
        {
        }



        public CListDate(List<DateTime> dates)
        {
            foreach (DateTime dt in dates)
                m_list.Add(new ListenDate(dt));
        }

        public void recordJustReadTrack()
        {
            m_list.Add(new ListenDate(DateTime.Now));
        }

        //public void check(System.DateTime a_date)
        //{
        //    if (a_date > min)
        //    {
        //        if (!m_list.Contains(a_date))
        //        {
        //            if (!isDateInList(a_date))
        //            {
        //                m_list.Add(a_date);
        //            }
        //        }
        //    }
        //}

        //private bool isDateInList(System.DateTime a_date)
        //{
        //    foreach (System.DateTime l_date in m_list)
        //    {
        //        if (l_date == a_date)
        //            return true;
        //        //string refe = l_date.ToString();
        //        //if (refe == a_date.ToString())
        //        //    return true;
        //        //if (refe == a_date.AddHours(1).ToString())
        //        //    return true;
        //        //if (refe == a_date.AddHours(-1).ToString())
        //        //    return true;
        //    }
        //    return false;
        //}

        private void check(ListenDate other)
        {
            if (!other.deleted && !m_list.Contains(other))
                m_list.Add(other);
            else if (other.deleted && m_list.Contains(other))
                m_list.Remove(other);

        }

        public void merge(CListDate other)
        {
            foreach (ListenDate o in other.m_list)
                check(o);
        }

        private void sort()
        {
            m_list.Sort((x, y) => -x.date.CompareTo(y.date));
        }


        #region IData Members




        public void write(XmlWriter w)
        {
            sort();
            w.WriteStartElement(DATES);

            foreach (ListenDate dt in m_list)
            {
                w.WriteElementString(CListDate.DATE, dt.date.ToString());
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListDate lastFull)
        {
            return m_list.Count > lastFull.m_list.Count; 
            //if (m_list.Count > lastFull.m_list.Count)
            //    return true;
            //sort();
            //lastFull.sort();
            //int count = m_list.Count;
            //for (int i = 0; i < count; i++)
            //{
            //    if (!m_list[i].Equals(lastFull.m_list[i]))
            //        return true;
            //}
            //return false;
        }
        public void writeDiff(XmlWriter w, CListDate lastFull, bool major)
        {
            if (!HasChange(lastFull))
                return;
            sort();
            lastFull.sort();
            w.WriteStartElement(DATES);

            foreach (var l_date in m_list)
            {
                if (lastFull.m_list.Contains(l_date))
                    continue;
                w.WriteElementString(CListDate.DATE, l_date.ToString());
            }
            if (major)
            {
                foreach (var l_date in lastFull.m_list)
                {
                    if (m_list.Contains(l_date))
                        continue;
                    w.WriteStartElement(CListDate.DATE);
                    XMLTool.writeDeleted(w);
                    w.WriteString(l_date.ToString());
                    w.WriteEndElement();
                }
            }


            w.WriteEndElement();
        }


        #endregion
        public int Count
        {
            get { return m_list.Count; }
        }


        public DateTime LastModif
        {
            get
            {
                if (m_list.Count == 0)
                    return System.DateTime.MinValue;
                sort();
                return m_list[0].date;
            }
        }
        public List<DateTime> Dates
        {
            get
            {
                return (from dt in m_list select dt.date).ToList();
            }
        }

        public class CDateComparer : IComparer<System.DateTime>
        {

            public int Compare(System.DateTime x, System.DateTime y)
            {
                return -1 * System.DateTime.Compare(x, y);
            }
        }

        public void removeLast()
        {
            int count = m_list.Count;
            if (count == 0)
                return;
            m_list.RemoveAt(0);
        }


    }
}





]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListFile.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util;
using pdb.obj;

using pdb.db.piece;

namespace pdb.db.obj
{
    /// <summary>
    /// liste des fichiers acc√©dant au m√™me morceau
    /// </summary>
    /// <remarks></remarks>
    public class CListFile : IEnumerable<CFile>, IData
    {


        //  private static CFileComparer c_comparer = new CFileComparer();
        private const string TOKEN_FILES = "files";
        private List<CFile> m_list = new List<CFile>();
        private CFile pertinentFile;
        // private bool? _exists;
        public CListFile(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, TOKEN_FILES);
            if (l_xml == null)
                return;
            bool deleted = false;
            var att = l_xml.Attributes["f"];
            if (att != null)
            {
                deleted = XMLTool.getDeleted(l_xml);
                CFile f = new CFile(att.Value, deleted);
                @add(f);
                return;
            }
            foreach (XmlElement l_xmlFile in l_xml)
            {
                deleted = XMLTool.getDeleted(l_xmlFile);
                CFile l_file = new CFile(l_xmlFile.InnerText, deleted);
                @add(l_file);
            }
        }
        public CListFile()
        {
        }

        public CListFile(CListFile o)
        {
            foreach (CFile f in o)
                @add(f);
        }

        private void check(CFile other)
        {
            if (!other.deleted && !m_list.Contains(other))
                m_list.Add(other);
            else if (other.deleted && m_list.Contains(other))
                m_list.Remove(other);

        }

        public void @add(CFile a_file)
        {
            //if (!a_file.exists()) return; //TODO provisoire
            bool l_bFound = false;
            foreach (CFile l_file in m_list)
            {
                if (a_file.Equals(l_file))
                {
                    l_bFound = true;
                    break;
                }
            }
            if (l_bFound)
                return;
            if (a_file.FileType.typeMusic())
            {
                m_list.Add(a_file);
                pertinentFile = null;
            }
        }
        //   private CFile _pertinent; 
        public CFile getPertinentFile()
        {
            if (pertinentFile != null)
                return pertinentFile;
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            bool checkEnd = true;
            var list = new List<CFile>();
            foreach (CFile f in m_list)
            {
                var exist = f.exists();
                if (exist == null)
                    checkEnd = false;
                else if (true == exist)
                    list.Add(f);
            }

            CFile ret = null;
            if (list.Count == 1)
            {
                ret = list[0];
            }
            else
            {

                try
                {
                    list.Sort(new CFileComparer());
                }
                catch (Exception e)
                {
                    Console.WriteLine("impossible de comparer les fichiers");
                    foreach (CFile file in list)
                    {
                        Console.Write(file.File + ";");
                    }
                    Console.WriteLine(e.ToString());
                }

                ret = list.Count == 0 ? null : list[0];
            }

            if (checkEnd)
                pertinentFile = ret;


            return ret;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        private CFile getFirstFile()
        {
            var pertinent = getPertinentFile();
            if (pertinent != null)
                return pertinent;
            //if (_pertinent != null)
            //    return _pertinent; 
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list; // m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            var _pertinent = list.Count == 0 ? null : list[0];
            return _pertinent;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        //public void getSecondaryFiles(List<CFile> list)
        //{
        //    if (m_list.Count <= 1)
        //        return;
        //    var pertinent = getPertinentFile();

        //    foreach (CFile f in m_list)
        //    {
        //        if (f.exists() && f != pertinent)
        //            list.Add(f);
        //    }

        //}

        //public string File
        //{
        //    get
        //    {
        //        CFile l_file = getPertinentFile();
        //        if (l_file == null)
        //        {
        //            if (m_list.Count > 0) return m_list[0].File;
        //            return "";
        //        }
        //        return l_file.File;
        //    }
        //}

        public string PathReduc
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.File;
            }
        }

        public CFile File
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return null;
                return l_file;
            }
        }

        public string Path
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.Path;
            }
        }

        public string getLocation()
        {
            if (pertinentFile != null)
                return pertinentFile.Path;
            if (m_list.Count > 0)
                return m_list[0].getPath();
            return "";
        }
        //public String getUri()
        //{
        //    CFile l_file = getPertinentFile();
        //    if (l_file == null)
        //        return "";
        //    return l_file.getUri();
        //}

        public bool? Exists
        {
            get
            {
                //if (_exists.HasValue)
                //    return _exists.Value;
                if (pertinentFile != null && pertinentFile.exists().HasValue)
                {
                    //  _exists = true;
                    return pertinentFile.exists();
                }

                bool? ret = null;
                bool endCheck = true;
                foreach (CFile f in m_list)
                {
                    var exist = f.exists();
                    if (true == exist)
                    {
                        return true;
                    }
                    else if (false == exist)
                        ret = false;
                    else
                        endCheck = false;
                }

                if (endCheck)
                    return ret;
                else
                    return null;

            }
        }

        public bool ExistsNow()
        {
            if (pertinentFile != null && pertinentFile.exists().HasValue)
            {
                //  _exists = true;
                return pertinentFile.exists().Value;
            }

            foreach (CFile f in m_list)
            {
                var exist = f.exists();
                if (true == exist)
                {
                    return true;
                }
                else if (false == exist)
                {
                }
                else
                {
                    if (FileRegister.ExistNow(f.Path)) ;
                    return true;
                }

            }
            return false;
        }

        public void merge(CListFile a_list)
        {
            CFile aux = getPertinentFile();
            foreach (CFile l_file in a_list)
            {
                check(l_file);
            }


            CFile _new = getPertinentFile();

            if (aux == null)
            {
                if (_new != null)
                    onChange();

            }
            else
            {
                if (!aux.Equals(_new))
                    onChange();
            }

        }

        //private IDataObserver observer;
        //public IDataObserver Observer { set { observer = value; } }
        private void onChange() { }// if (observer != null) observer.RefChange(); }


        /// <summary>
        /// teste s'il existe un fichier en commun entre deux listes
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public bool HasOnePathInCommonWith(CListFile other)
        {
            foreach (CFile l_myFile in m_list)
            {
                foreach (CFile l_outFile in other.m_list)
                {
                    if (l_myFile.Equals(l_outFile))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public bool HasOnePathInCommonWith(String path)
        {

            foreach (CFile l_myFile in m_list)
            {

                if (l_myFile.Path.Equals(path))
                {
                    return true;
                }

            }
            return false;
        }


        public int Count
        {
            get { return m_list.Count; }
        }

        public System.Collections.Generic.IEnumerator<CFile> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public bool isPodcast
        {
            get
            {
                foreach (CFile l_file in new List<CFile>(m_list))
                {
                    if (l_file.isPodcast)
                        return true;
                }
                return false;
            }
        }


        #region IData Members


        public void write(ITextWriter a_sw)
        {
            //   m_list.Sort(c_comparer)
            XMLTool.openBalise(a_sw, TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                l_file.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, TOKEN_FILES);
        }


        public void write(XmlWriter w)
        {
            m_list.Sort(new CFileComparerName());
            w.WriteStartElement(TOKEN_FILES);
            if (m_list.Count == 1 && m_list[0] != null)
            {
                w.WriteAttributeString("f", m_list[0].File);
            }
            else
            {

                foreach (CFile l_file in this)
                {
                    l_file.write(w);
                }
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListFile lastFull)
        {
            if (m_list.Count != lastFull.m_list.Count)
                return true;
            m_list.Sort(new CFileComparerName());
            lastFull.m_list.Sort(new CFileComparerName());
            int count = m_list.Count;
            for (int i = 0; i < count; i++)
            {
                if (!m_list[i].Equals(lastFull.m_list[i]))
                    return true;
            }
            return false;
        }

        public bool contains(CFile file)
        {
            return m_list.Contains(file);
        }
        /// <summary>
        /// Ecrit les changments
        /// </summary>
        /// <param name="w"></param>
        /// <param name="lastFull"></param>
        /// <returns>changement majeur</returns>
        public bool writeDiff(XmlWriter w, CListFile lastFull)
        {
            if (!HasChange(lastFull))
                return false;
            bool ret = false; 
            m_list.Sort(new CFileComparerName());
            lastFull.m_list.Sort(new CFileComparerName());

            w.WriteStartElement(TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                if (!lastFull.contains(l_file))
                    l_file.write(w);
            }

            foreach (CFile l_file in lastFull)
            {
                if (!this.contains(l_file))
                {
                    ret = true;  
                    l_file.writeDeleted(w);
                }
            }

            w.WriteEndElement();
            return ret; 
        }

        #endregion

        public CFile this[int a_index]
        {
            get
            {
                if (a_index < 0 || a_index >= Count)
                {
                    throw new ApplicationException("bad index:" + a_index + " / " + Count);
                }
                else
                {
                    return m_list[a_index];
                }
            }
        }

        public void Sort()
        {
            try
            {
                m_list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
        //private class CFileComparer : IComparer<CFile>
        //{

        //    public int Compare(CFile x, CFile y)
        //    {
        //        return string.Compare(x.File.Trim().ToUpper(), y.File.Trim().ToUpper());
        //    }
        //}

        // private long size = -1;
        public long Size
        {
            get
            {
                var file = getPertinentFile();
                if (file == null)
                    return 0;
                return file.Size;

            }

        }

        //public string DirAndFileName
        //{
        //    get
        //    {
        //        var file = getFirstFile();
        //        if (file == null)
        //            return "";
        //        return file.DirAndFileName;
        //    }
        //}


    }
}


]]></content>
  </file>
</db>
