<db path="C:\bernard\db2\">
    <file path="buro\buroSimple\Program.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace buroSimple
{
    class Program
    {
        static void Main(string[] args)
        {
            int countArgs = args.GetLength(0);
            double delay = 30.0;
            bool unique = false; 
            for (int i = 0; i <countArgs; i++)
            {
                if (args[i] == "-t")
                {
                    if (i + 1 < countArgs)
                    {
                        delay = Convert.ToDouble(args[i + 1]);
                    }

                }
                else if (args[i] == "/u")
                    unique = true; 
            }
            var wp = new Walpaper() { delay = delay, unique = unique }; 
            wp.go(); 
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimple\Walpaper.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using buroSimpleLib;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using System.Threading;
using System.Diagnostics;
using System.Windows.Forms;
using Microsoft.Win32;
using System.Drawing.Drawing2D;

namespace buroSimple
{
    class Walpaper
    {
        int HAUTEUR;
        int LARGEUR;
        const string TMP_FILE = @"C:\Temp\wp.bmp";
        const string TMP_FILE1 = @"C:\Temp\wp1.bmp";
        const string INDEX_FILE = @"C:\Temp\wp.index.txt";


        public double delay = 30;
        public bool unique = false;
        private readonly IntPtr _ScreenStateNotify;
        private bool GO;
        public void go()
        {
            GO = true;


            SystemEvents.PowerModeChanged += new PowerModeChangedEventHandler(SystemEvents_PowerModeChanged);



            HAUTEUR = 1080;
            LARGEUR = 1920;
            var list = new List<FileDto>();
            using (StreamReader sr = new StreamReader(@"C:\Temp\buro1.txt"))
            {
                string line = "";
                while ((line = sr.ReadLine()) != null)
                {
                    if (string.IsNullOrEmpty(line))
                        continue;

                    try
                    {
                        FileDto fd = FileDto.FromLine(line); //  new FileDto() { Path = tab[0], Size = Convert.ToInt64(tab[1]) };
                        if (fd != null)
                            list.Add(fd);
                    }
                    catch
                    {
                    }

                }
            }

            list.Sort((x, y) =>
            {
                int cmp = x.Pixels().CompareTo(y.Pixels());
                if (cmp != 0)
                    return cmp;
                cmp = x.Size.CompareTo(y.Size);
                if (cmp != 0)
                    return cmp;
                return x.Path.CompareTo(y.Path);
            });

            int count = list.Count;

            string path0 = "";
            int index0 = 0;
            if (File.Exists(INDEX_FILE))
            {
                path0 = File.ReadAllText(INDEX_FILE).Trim();
            }

            if (!string.IsNullOrEmpty(path0))
            {
                for (int i = 0; i < count; i++)
                {
                    if (list[i].Path == path0)
                    {
                        index0 = i;
                        break;
                    }
                }
            }

            HashSet<string> hs = new HashSet<string>();
            int pixels = -1; 
            long size = -1;
            for (int i = index0 + 1; i < count; i++)
            {
                if (!GO)
                {
                    Thread.Sleep(1000);
                }
                FileDto f = list[i];
                Console.WriteLine("candidat " + f);
                if (f.Size > size || f.Pixels() > pixels)
                {
                    hs.Clear();
                    size = f.Size;
                    pixels = f.Pixels(); 
                }
                else
                {
                    if (unique)
                        continue;
                }

                if (!hs.Add(Path.GetFileName(f.Path)))
                    continue;
                try
                {
                    createFile(f);
                    WinAPI.BmpLoad(TMP_FILE);
                    File.WriteAllText(INDEX_FILE, f.Path);
                    Thread.Sleep((int)(delay * 1000.0));
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            }
        }

        void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)
        {
            Console.WriteLine("SystemEvents_PowerModeChanged:" + e.Mode.ToString());
            if (e.Mode == PowerModes.Resume)
                GO = true;
            else GO = false;
        }

        private void createFile(FileDto f)
        {
            Image img = Image.FromFile(f.Path);

            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}x{1} {2}", largeur0, hauteur0, f.HumanReadableSize);

            double r0 = (double)HAUTEUR / (double)LARGEUR;

            int largeurTrame;
            int hauteurTrame;

            double r = (double)hauteur0 / (double)largeur0;


            Bitmap trame;


            if (r > r0)
            {
                // image pas assez large --> ajout largeur

                hauteurTrame = hauteur0;
                largeurTrame = Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = largeur0;
                hauteurTrame = Convert.ToInt32((double)largeur0 * (double)r0);
            }

            trame = new Bitmap(largeurTrame, hauteurTrame);
            Graphics graphics = Graphics.FromImage(trame);

            //graphics.CompositingMode = CompositingMode.SourceCopy;
            //graphics.CompositingQuality = CompositingQuality.HighQuality;
            //graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
            //graphics.SmoothingMode = SmoothingMode.HighQuality;
            //graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

            int xrec = (largeurTrame - largeur0) / 2;
            int yrec = (hauteurTrame - hauteur0) / 2;
            Rectangle centré = new Rectangle(xrec, yrec, largeur0, hauteur0);
            graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);


            trame.Save(TMP_FILE, ImageFormat.Bmp);
            trame.Dispose();
            img.Dispose();
            graphics.Dispose();

            //using (Bitmap fs = new Bitmap(LARGEUR, HAUTEUR))
            //{
            //    Image i0 = null;
            //    Image i1 = null;
            //    using (var g = Graphics.FromImage(fs))
            //    {

            //        if (File.Exists(TMP_FILE))
            //        {
            //            i0 = Image.FromFile(TMP_FILE);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }

            //        if (File.Exists(TMP_FILE1))
            //        {
            //            i1 = Image.FromFile(TMP_FILE1);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }
            //    }
            //    fs.Save(TMP_FILE, ImageFormat.Bmp);
            //    if (i0 != null)
            //        i0.Dispose();
            //    if (i1 != null)
            //        i1.Dispose();
            //}
        }
    }
}
]]></content>
  </file>
   <file path="buro\buroSimpleLib\FileDto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.IO;

namespace buroSimpleLib
{
    public class FileDto
    {
        const string SEP = ";";
        public const string PATH = @"C:\Temp\buro.txt";
        public string Path;
        public long Size;
        public int Width;
        public int Height;

        public override string ToString()
        {
            return string.Format("{0}x{1} {2} {3} ", Width, Height, HumanReadableSize, Path);
        }

          public string ToStringSearch()
        {
            return string.Format("{0} {1} {2}x{3}  ",Path, HumanReadableSize, Width, Height);
        }

        public int Pixels() { return Width * Height; }

        public string HumanReadableSize
        {
            get
            {
                return FileUtil.HumanReadableSize(Size, 1);
            }
        }
        public void appendToDb(StreamWriter sw)
        {
            sw.Write(Path);
            sw.Write(SEP);
            sw.Write(Size);
            sw.Write(SEP);
            sw.Write(Width);
            sw.Write(SEP);
            sw.WriteLine(Height);
        }

        public static FileDto FromLine(string line)
        {
            if (string.IsNullOrEmpty(line))
                return null;
            var tab = line.Split(SEP.ToCharArray());
            try
            {
                FileDto fd = new FileDto() { Path = tab[0], Size = Convert.ToInt64(tab[1]), Width = Convert.ToInt32(tab[2]), Height = Convert.ToInt32(tab[3]) };
                return fd;
            }
            catch
            {
                return null;
            }
        }
    }
}
]]></content>
  </file>
   <file path="buro\buroSimpleSearch\Program.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util.ordo;
using buroSimpleLib;
using System.IO;
using System.Drawing;
using System.Threading;
using pdb.util;
using System.Configuration;

namespace buroSimpleSearch
{
    class Program
    {
        static List<FileDto> list = new List<FileDto>();
        static HashSet<string> imageType = new HashSet<string> { "bmp", "gif", "ico", "jpeg", "jpg", "jpe", "png", "svg", "tif", "tiff" };
        static HashSet<string> noImageType = new HashSet<string>();

        static listCandidat imageCandidat = new listCandidat();
        static listCandidat NoImageCandidat = new listCandidat();
        static volatile object _lock = new object();

        static void Main(string[] args)
        {
            Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);
            new Program().go();
        }

        static Ordonnanceur ordo;
        static StreamWriter sw = new StreamWriter(FileDto.PATH);
        void go()
        {
            var _nbProc = ConfigurationManager.AppSettings["nbProc"];
            int nbProc = 3;
            if (!string.IsNullOrEmpty(_nbProc))
                nbProc = Convert.ToInt32(_nbProc);
            ordo = new Ordonnanceur(nbProc);

            var paths = ConfigurationManager.AppSettings["paths"];
            if (string.IsNullOrEmpty(paths))
                paths = @"C:\";
            var tab = paths.Split(';');
            foreach (string path in tab)
            {
                if (string.IsNullOrEmpty(path))
                    continue;
                ordo.addTask(new TaskDir(ordo, new DirectoryInfo(path)));
            }
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"C:\")));
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"E:\")));
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"I:\")));
            while (ordo.Busy)
                Thread.Sleep(30);
            sw.Dispose();
        }

        private class TaskDir : Task
        {
            private DirectoryInfo dir;
            public TaskDir(Ordonnanceur ordo, DirectoryInfo dir)
                : base(ordo)
            {
                this.dir = dir;
            }

            protected override void action()
            {
                //   ConsoleLogger.log(dir.FullName);
                List<FileDto> aux = null;
                foreach (FileInfo f in dir.GetFiles())
                {
                    // ConsoleLogger.log("check " + f.FullName);
                    FileDto fd = check(f);
                    if (fd != null)
                    {
                        ConsoleLogger.log(fd.ToStringSearch());
                        if (aux == null)
                            aux = new List<FileDto>();
                        aux.Add(fd);
                    }
                }
                if (aux != null)
                {
                    lock (_lock)
                    {
                        foreach (FileDto fd in aux)
                        {
                           fd.appendToDb(sw);
                        }
                    }
                }
                //ConsoleLogger.log("fin " +dir.FullName);
                done = true;

                foreach (DirectoryInfo sub in dir.GetDirectories())
                {
                    ordo.addsubTask(new TaskDir(ordo, sub));
                }
            }



            public override string ToString()
            {
                return dir.FullName;
            }
        }

        private class candidat
        {
            public candidat(String ext) { this.ext = ext; }
            private String ext;
            private int note = 0;
            public void increment()
            {
                note++;
            }
            public bool Accepted { get { return note >= 10; } }
        }
        private class listCandidat
        {
            private IDictionary<String, candidat> list = new Dictionary<String, candidat>();

            public bool record(String ext)
            {
                candidat cand;
                if (!list.ContainsKey(ext))
                {
                    cand = new candidat(ext);
                    list.Add(ext, cand);
                }
                cand = list[ext];
                cand.increment();
                return cand.Accepted;
            }
        }

        static FileDto check(FileInfo f)
        {
            var file = f.FullName;
            //  Console.WriteLine(file.FullName);
            var ext = Path.GetExtension(file).ToLower().Replace(".", "");
            if (noImageType.Contains(ext)) return null;



            Image img;
            FileDto fdto = null;
            try
            {
                img = Image.FromFile(file);
                fdto = new FileDto() { Path = file, Size = f.Length, Height = img.Height, Width = img.Width };

                img.Dispose();
            }
            catch (Exception)
            {
                fdto = null;
            }

            if (ext != null && ext.Length > 1)
            {
                if (!imageType.Contains(ext))
                {
                    ConsoleLogger.log("TYPE:" + ext + " " + file + " " + fdto);
                    if (fdto != null)
                    {
                        lock (imageCandidat)
                        {
                            if (imageCandidat.record(ext))
                            {
                                imageType.Add(ext);
                                ConsoleLogger.log("TYPE OK!!:" + ext + " " + file);
                            }
                        }

                    }
                    else
                    {
                        lock (NoImageCandidat)
                        {
                            if (NoImageCandidat.record(ext))
                            {
                                noImageType.Add(ext);
                                ConsoleLogger.log("TYPE NOK!!:" + ext + " " + file);
                            }
                        }
                        return null;
                    }
                }

            }
            return fdto;




        }

        static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {

            sw.Dispose();
        }

        static void write()
        {
            using (StreamWriter sw = new StreamWriter(FileDto.PATH))
            {
                foreach (FileDto f in list)
                {
                    sw.Write(f.Path);
                    sw.Write(";");
                    sw.WriteLine(f.Size);
                }
            }
        }
    }
}
]]></content>
  </file>
     <file path="db4\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;
using System.Linq;
using System.Linq.Expressions;
using System.Text.RegularExpressions;
namespace pdb.podcast.Sort
{
    class Album
    {
        const string DATE_FORMAT = "dd/MM/yy HH:mm";
        const string DAY_FORMAT = "dd/MM HH:mm";
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        // private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbModifPertinent = 0;
        private static int nbRepecheForce = 0;
        private static DateTime dateRepeche = DateTime.MaxValue; public static DateTime DateRepeche { get { return dateRepeche; } }
        private static List<TrackSort> repeches = new List<TrackSort>();
        public static int NbRepeches { get { return repeches.Count; } }
        public static int NbModif { get { return nbModif; } }
        public static int NbModifPertinent { get { return nbModifPertinent; } }

        private bool done;

        //  bool checkSelected, apply;
        DateTime date0; //, newDate0;
        DateTime date1;

        int index0;
        int indexCourant;
        int indexNext;
        public static void Init()
        {
            //lastReads.Clear(); 
            //nbrepeches = 0;
            repeches.Clear();
            nbModif = 0; nbModifPertinent = 0;
            nbRepecheForce = 0;
            dateRepeche = DateTime.MaxValue;
        }

        public static void Bilan()
        {
            if (dateRepeche < DateTime.MaxValue)
                log.log("*************Date minimum:" + dateRepeche);
            repeches.Sort((x, y) => x.Pub2.CompareTo(y.Pub2));
            foreach (TrackSort t in repeches)
                log.log(string.Format("date={0} {1}", t.Pub2, t));
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;
        public static Logger logDebug;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }

        public bool getPlayed(TrackSort track, int index)
        {
            // si pas virtuel: on utilise de toutes façon le "vrai" played
            if (!conf.playVirtual)
                return track.track.BasePlayed;
            // à partir d'ici on utilise le vrai que dans le futur(pour avoir une bonne estimation de ce qui nous attend)
            // le futur est compté après le premier sélectionné
            if (index > indexNext)
            {
                return track.track.BasePlayed;
            }

            // on est dans le passé - courant (i<indexNext)

            if (!track.track.Enabled)
                return false;
            return track.track.Played;
            //if (track.pub20 <= date0)
            //    return track.track.Played;
            //return track.track.BasePlayed;
            //var _real = real && !conf.playVirtual;
            //return track.getPlayed(_real);
        }



        public void init()
        {
            //done = false;
        }

        //public void buildAll()
        //{
        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;

        //    checkSelected = false;
        //    apply = false;

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        var dt = track.Pub2.AddSeconds(1);
        //        date0 = dt;
        //        newDate0 = dt;
        //        build();
        //        if (dt >= Conf.Date0)
        //            break;
        //    }

        //    apply = true;
        //    date0 = Conf.Date0;
        //    newDate0 = Conf.NewDate0;
        //    // writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        writeComment(track, track.Pub2);
        //    }
        //}

        //private void build0()
        //{
        //    int count = list.Count;
        //    if (count == 0)
        //        return;



        //    TrackSort.Date0 = date0;
        //    int indexLastRead = -1;
        //    TrackSort lastRead = null;
        //    int indexNextSelected = -1;
        //    DateTime lastPlayed = DateTime.MinValue;
        //    TrackSort next = null;
        //    //  TrackSort reallyLastRead = null;
        //    DateTime currentPub = DateTime.MinValue;
        //    DateTime currentPub2 = DateTime.MinValue;
        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        //if (conf.extPente > 0)
        //        //{
        //        //    if (!track.Played && track.Pub == track.Pub2)
        //        //        track.Pub2 = Conf.Date0; 
        //        //}

        //        if (track.Pub > currentPub && track.Pub2 <= currentPub2)
        //        {
        //            if (track.Pub2 < track.Pub)
        //                track.Pub2 = track.Pub;
        //            if (track.Pub > currentPub && track.Pub2 <= currentPub2)
        //            {
        //                var aux = currentPub2.AddMinutes(1);
        //                log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
        //                track.Pub2 = aux;
        //            }
        //        }

        //        currentPub = track.Pub;
        //        currentPub2 = track.Pub2;
        //    }
        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        if (getPlayed(track, false)) // && track.PlayedDate > lastPlayed)
        //        {
        //            //// ok mais quid du cas au fil de l'histoire : date dans le futur
        //            //if (track.Pub2 <= date0 || conf.extPente > 0)
        //            //{
        //            if (next == null)
        //            {
        //                indexLastRead = i;
        //                lastPlayed = track.PlayedDate;
        //                lastRead = track;
        //            }
        //            else
        //                break;
        //            //}
        //        }

        //        else
        //        {
        //            if (next == null)
        //            {
        //                if (track.Selected || track.Pub2 >= date0)
        //                {
        //                    next = track;
        //                    indexNextSelected = i;
        //                }
        //            }
        //            else
        //                break;
        //        }
        //    }


        //    if (indexLastRead < 0)
        //        return;
        //    if (next == null)
        //        return;
        //    var rare = album.Rare;
        //    var intervalleMin0 = conf.getIntervalleMin0(rare);
        //    var intervalle = conf.getIntervalle(rare, lastRead.DureeEnHeure, intervalleMin0);
        //    var intervalleMin = conf.getIntervalleMin(rare, lastRead.DureeEnHeure);

        //    double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
        //    DateTime pub2 = lastRead.Pub2;

        //    double delta0Corr = deltaLastRead0;

        //    double cumulMin = conf.getCumulMin(rare);
        //    double cumulMax = conf.getCumulMax(rare);

        //    if (pub2 > lastRead.Pub && conf.extPente == 0)
        //    {
        //        if (conf.elastique < 1)
        //        {
        //            delta0Corr = deltaLastRead0 * conf.elastique;
        //            pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
        //        }


        //        //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
        //        //{
        //        //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
        //        //    pub2 = lastRead.Pub.AddDays(delta0Corr);
        //        //}
        //    }




        //    var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

        //    int nbReads = 0;
        //    int nbTotals = 0;

        //    int nbRead = 0;
        //    int nbTotal = 0;

        //    int _nbRead = 0;
        //    int _nbTotal = 0;
        //    double delta = intervalle; // conf.getIntervalle(album.Rare);
        //    double delta0 = delta;
        //    var _histo = conf.getHisto(rare);
        //    if (_histo > 0)
        //    {
        //        double histo = _histo;

        //        DateTime histo0 = next.Pub;
        //        if (conf.histoMode == histoMode.fix)
        //            histo0 = date0;
        //        DateTime limit = histo0.AddDays(-histo);

        //        for (int i = indexNextSelected - 1; i >= 0; i--)
        //        {
        //            var t = list[i];
        //            var dt = t.Pub;
        //            if (dt < limit && nbTotals >= conf.totalMin)
        //                break;

        //            if (getPlayed(t, true))
        //                nbReads++;


        //            nbTotals++;

        //        }



        //        limit = lastRead.Pub.AddDays(-histo);
        //        for (int i = indexLastRead; i >= 0; i--)
        //        {
        //            var t = list[i];
        //            var dt = t.Pub;
        //            if (dt < limit && nbTotal >= conf.totalMin)
        //                break;

        //            if (getPlayed(t, true))
        //                nbRead++;


        //            nbTotal++;

        //        }


        //        if (conf.histoMode == histoMode.read)
        //        {
        //            _nbRead = nbRead;
        //            _nbTotal = nbTotal;
        //        }
        //        else
        //        {
        //            _nbRead = nbReads;
        //            _nbTotal = nbTotals;
        //        }


        //        if (_nbRead > 0 && _nbTotal > 0)
        //        {
        //            if (_nbTotal < conf.totalMin)
        //                _nbTotal = conf.totalMin;
        //            //  album.Rare ? conf.intervalleR : conf.intervalle;
        //            // var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

        //            double rapport = (double)_nbRead / (double)_nbTotal;

        //            var coeff = 1 / rapport;

        //            if (conf.dureeCoeff)
        //            {
        //                coeff = conf.getCoeff(rare, coeff, lastRead.DureeEnHeure);
        //            }

        //            //0.1 => 10
        //            //0.9 => 1.11
        //            //coeff -= 1; // 9  0.11
        //            //var dminmax = intervalle - intervalleMin;

        //            delta = borne(coeff, intervalle, intervalleMin, intervalleMin0); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);



        //        }

        //        //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


        //    }



        //    if (conf.extPente > 0)
        //    {
        //        var d0 = (DateTime.Now - pub2).TotalDays;
        //        var dl = conf.extDelta;
        //        if (dl == 0)
        //        {
        //            dl = d0;
        //        }

        //        delta0 = d0 / conf.extPente;
        //        delta = delta0;
        //        //01/01/2014 ->01/01/2017
        //        //04/01/2017 -> 04/01/2014
        //        var dateLimitEcoule = DateTime.Now.AddDays(-dl);

        //        var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
        //        log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

        //        if (deltaLimiteEcoule > delta)
        //        {
        //            double _coeff = deltaLimiteEcoule / delta;
        //            delta = borne(_coeff, intervalle, intervalleMin, intervalleMin0);
        //        }

        //        if (delta < 1)
        //            delta = 1;




        //        //if (delta > intervalle)
        //        //    delta = intervalle;
        //    }

        //    if (conf.limitRead && deltaLecture > intervalle)
        //    {
        //        //13 /10 ->7
        //        var _old = delta;

        //        delta += intervalle - deltaLecture;
        //        log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
        //    }





        //    if (delta < intervalleMin)
        //        delta = intervalleMin;

        //    if (delta > intervalle)
        //        delta = intervalle;



        //    DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();

        //    DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * delta).truncateToMinute();
        //    //var cumul = (limitFuture - next.Pub).TotalDays;
        //    //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
        //    //if (dtaux > limitFutureRab)
        //    //    limitFutureRab = dtaux; 
        //    DateTime nextDate = limitFuture;

        //    int nb = 0;
        //    int nblissage = 0;
        //    double deltaAtterrissage = intervalleMin;

        //    if (conf.noCollision)
        //        deltaAtterrissage = delta;
        //    if (conf.extPente > 0)
        //        deltaAtterrissage = delta0;


        //    if (conf.deltaConst || conf.extPente > 0)
        //    {
        //    }

        //    else
        //    {
        //        var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
        //        var _deltaRab = limitFuture.AddDays(conf.deltaRab);

        //        DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

        //        for (int i = indexLastRead + 2; i < count; i++)
        //        {
        //            var t = list[i];
        //            if (conf.useVirtuel)
        //            {
        //                // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
        //                dt = dt.AddDays(intervalleMin0);
        //            }
        //            else
        //                dt = t.Pub;


        //            nb++;
        //            if (dt > limitFuture)
        //            {
        //                nextDate = dt;
        //                nblissage++;
        //                if (dt <= _deltaMin)
        //                    continue;
        //                if (dt <= _deltaRab)
        //                    continue;
        //                if (nb <= conf.deltaNbMin)
        //                    continue;
        //                if (nblissage <= conf.deltaNbRab)
        //                    continue;
        //                if (dt <= limitFutureRab)
        //                    continue;

        //                break;


        //                //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
        //                //    break;
        //            }

        //        }

        //        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
        //        {
        //            deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
        //            if (deltaAtterrissage > intervalleMin)
        //                deltaAtterrissage = intervalleMin;
        //        }
        //    }

        //    var tsatt = timeSpan.FromDays(deltaAtterrissage);
        //    if (tsatt.TotalMinute < 1)
        //        tsatt = timeSpan.FromMinutes(1);

        //    string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

        //    log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


        //    //  nb = 0;
        //    // bool enRetard = limitFuture < date0;
        //    TrackSort last = next;
        //    DateTime lastPub2 = limitFuture;
        //    int indexDepart = indexLastRead + 1;



        //    bool erased = false;

        //    if (conf.vacances)
        //        deltaAtterrissage = delta;

        //    for (int i = indexDepart; i < count; i++)
        //    {
        //        var t = list[i];
        //        if (erased && conf.erasedDone)
        //        {
        //            eraseSort(t, "", t.Pub);
        //            continue;
        //        }

        //        DateTime dt = lastPub2;

        //        if (i == indexDepart && !conf.useVirtuel2)
        //        {
        //            dt = limitFuture;
        //        }
        //        else
        //        {

        //            //if (conf.deltaCheckSelected)
        //            //{
        //            //    if (!t.Selected)
        //            //        continue;
        //            //    if (!t.Enabled)
        //            //        continue;
        //            //}
        //            var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


        //            if (conf.useVirtuel2)
        //                dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
        //            else
        //                dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
        //            if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1)
        //            {
        //                var dt2 = dt;
        //                if (conf.useVirtuel2)
        //                    dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
        //                else
        //                    dt2 = lastPub2.AddDays(delta).truncateToMinute();
        //                //if (dt2 <= date0)
        //                dt = dt2;
        //                //else
        //                //    dt = date0.AddMinutes(1);
        //            }


        //        }



        //        var _delta = (dt - lastRead.Pub2).TotalDays;
        //        if (t.Pub >= dt || conf.enabled == sortMode.reset || erased && conf.erasedDone)
        //        {
        //            erased = true;
        //            eraseSort(t, "", t.Pub);
        //        }
        //        else
        //        {
        //            if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
        //            {
        //                var __delta = (dt - t.Pub).TotalDays;
        //                if (__delta > cumulMin)
        //                {
        //                    __delta = borneCumul(__delta, cumulMin, cumulMax);
        //                    dt = t.Pub.AddDays(__delta).truncateToMinute();
        //                }
        //            }


        //            //if (dt > DateTime.Now)
        //            //{
        //            //}

        //            //if ((dt - t.Pub).TotalDays > 100)
        //            //{
        //            //}

        //            writeComment(t, dt, "", t.Pub);
        //            //nb++;
        //        }


        //        last = t;
        //        lastPub2 = dt;


        //    }


        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
        //        {
        //            var aux = currentPub2.AddMinutes(1);
        //            log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
        //            track.Pub2 = aux;
        //        }

        //        currentPub = track.Pub;
        //        currentPub2 = track.Pub2;
        //    }

        //}

        private static double getweek(double days)
        {
            return 7 * System.Math.Floor(days / 7.0);
        }
        private static void buildWeek(List<double> list)
        {
            for (int i = 0; i < list.Count; i++)
            {
                list[i] = getweek(list[i]);
            }
        }

        private double getIntervalleX(double intervalleFactMoy)
        {
            var intervalleX = (intervalleFactMoy - 1.4) / 5.6;
            if (intervalleX < 0)
                intervalleX = 0;
            else if (intervalleX > 1)
                intervalleX = intervalleFactMoy / 7.0;
            return intervalleX;
        }
        private void build()
        {
            index0 = 0;
            indexCourant = 0;
            indexNext = int.MaxValue;

            int count = list.Count;
            if (count == 0)
                return;


            if (this.album.Album == "LA GRANDE TABLE 1ère partie")
            {
            }

            else if (this.album.Album == "La tête au carré")
            {
            }
            else if (this.album.Album == "France Inter - Rue des entrepreneurs")
            {
            }
            else if (album.Album == "SCIENCE PUBLIQUE")
            {
            }


            // bool rare = album.Rare;

            TrackSort.Date0 = date0;

            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;

            // 1. ordre
            for (int i = 0; i < count; i++)
            {
                var track = list[i];


                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    if (track.Pub2 < track.Pub)
                        track.Pub2 = track.Pub;

                    if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                    {
                        var aux = currentPub2.AddMinutes(1);
                        log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                        track.Pub2 = aux;
                    }
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }





            TrackSort next = null;
            int indexLastRead = -1;
            // int indexPrelastRead = -1;
            TrackSort lastRead = null;
            // TrackSort prelastRead = null;

            int indexLastSelected = -1;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.track.Selected)
                    indexLastSelected = i;
                bool played = false;
                if (conf.playVirtual)
                    played = track.track.Enabled && track.track.Played;
                else
                    played = track.track.BasePlayed;

                if (played)
                {
                    if (next == null)
                    {
                        //indexPrelastRead = indexLastRead;
                        //prelastRead = lastRead; 
                        indexLastRead = i;
                        lastRead = track;
                        indexCourant = i;

                    }
                    //else
                    //    break;

                }

                else if (lastRead != null)
                {
                    if (next == null)
                    {
                        if (track.Selected || (track.Pub2 >= date0 && track.Enabled))
                        {
                            next = track;
                            indexNext = i;
                        }
                    }
                    //else
                    //    break;
                }
            }

            //if (indexLastRead < 0)
            //    return;



            if (indexCourant < 0)
                return;

            if (conf.vacances || !conf.recheck)
                index0 = indexCourant;
            else
            {
                index0 = 0;
                indexLastRead = -1;
                lastRead = null;
                //indexPrelastRead = -1;
                //prelastRead = null; 

            }
            //  bool firstSel = false;

            if (lastRead == null && !conf.recheck)
            {
                index0 = 0;
                indexLastRead = 0;
                lastRead = list[0];
                indexCourant = 0;
            }

            // DateTime lastPlayed = DateTime.MinValue;

            if (lastRead == null)
            {
                for (int i = index0; i < count; i++)
                {
                    var track = list[i];
                    if (getPlayed(track, i))
                    {
                        indexLastRead = i;
                        lastRead = track;
                        index0 = i;
                        break;
                    }
                    else
                    {
                        if (track.Pub2 != track.Pub)
                            eraseSort(track, "", track.Pub);
                    }
                }
            }

            if (lastRead == null)
            {
                for (int i = indexCourant; i < count; i++)
                {
                    var t = list[i];
                    if (t.Pub2 > t.Pub)
                        eraseSort(t, "", t.Pub);
                }
                return;
            }

            if (lastRead.Pub == DateTime.MinValue)
                return;

            TrackSort last = lastRead;
            DateTime lastPub2 = lastRead.Pub2;
            //DateTime lastPubTh = lastRead.Pub2;
            DateTime pubMoy = lastRead.Pub2;
            DateTime pubMoyForCalcul = pubMoy;

            while (true)
            {
                if (index0 >= count - 1)
                    break;



                var current = list[index0];


                bool played = getPlayed(current, index0); //  getPlayed(current, false);


                if (played)
                {
                    lastRead = current;
                    indexLastRead = index0;
                }

                bool rare = album.Rare;
                bool noHorizon = conf.noHorizon;

                var lfutur = conf.getFutur(rare);
                buildWeek(lfutur);
                var futurh = conf.futurh;
                futurh = getweek(futurh);
                var futurhl = conf.getFuturHList(rare);
                buildWeek(futurhl);
                var futura = getweek(conf.futura);

                double intervalleFactMin = 1;
                double _intervalleFactMoy = 1;
                double intervalleX = 0;

                // DateTime lastExists = lastRead.Pub;

                var now = DateTime.Now;
                DateTime finFutur = now;
                DateTime finFuturH = now;
                DateTime debutFutur = current.Pub; //.AddDays(-futura);
                int indexDebut = index0;

                DateTime pub2 = lastRead.Pub2;
                double duree = current.DureeEnHeure;
                var intervalleMin0Head = conf.getIntervalleMin0(rare);
                var intervalleHead = conf.getIntervalle(rare, duree, intervalleMin0Head);
                var intervalleMinHead = conf.getIntervalleMin(rare, duree);
                var _atterissageMin = conf.getAtterrissageMin(rare);

                //double deltaMax = intervalle; // conf.getIntervalle(album.Rare);
                double delta0 = intervalleHead;
                var deltaLecture = (DateTime.Now - lastRead.PlayedDate).TotalDays;
                double cumulMin = conf.getCumulMin(rare);
                double cumulMax = conf.getCumulMax(rare);
                double rapport = 1;
                double rapportBorneHead = 1;
                double _intervalleCorrec = intervalleHead;
                double _intervalleCorrecVar = intervalleHead;
                double _deltaHorizon = intervalleHead;
                double _deltaHorizon0 = intervalleHead;
                double deltaMax = -1;
                double _densite = 1;
                double nbReadHead = 0;
                double nbTotalHead = 0;
                double coeff = 1;
                bool useToleranceHead = false;
                bool _borneParHorizon = false;
                double futurChoisi = 0;
                double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                double _delta0Corr = deltaLastRead0;


                int nbRead = 0;
                int nbTotal = 0;
                var histo = conf.getHisto(rare);
                var nbHisto = conf.getNbHisto(rare);
                int _nbTotal = 0;

                DateTime limit = lastRead.Pub; //
                try { limit = limit.AddDays(-histo); }
                catch (Exception ex)
                {
                    misc.log("Impossible de caler l'historique {0} {1}", this, lastRead, ex);
                    throw;
                }
                {
                    DateTime l = DateTime.MinValue;
                    for (int i = index0; i >= 0; i--)
                    {
                        var t = list[i];
                        var dt = t.Pub;
                        if (dt.Date == l && t.track.Duree.TotalMinute < conf.collisionDuree)
                            continue;
                        l = dt.Date;
                        if ((dt < limit || nbTotal >= nbHisto) && nbTotal >= conf.totalMin)
                            break;

                        if (getPlayed(t, i))
                            nbRead++;


                        nbTotal++;

                    }
                }

                _nbTotal = nbTotal;

                while (_nbTotal < conf.totalMin0)
                {
                    _nbTotal++;
                    nbRead++;
                }

                if (_nbTotal < conf.totalMin)
                    _nbTotal = conf.totalMin;

                if (nbRead == 0)
                    nbRead = 1;

                rapport = (double)nbRead / (double)_nbTotal;
                coeff = 1 / rapport;

                if (this.album.Album == "La tête au carré" && index0 > indexCourant - 2)
                {
                }

                if ((this.album.Album == "Rendez-vous avec X") && (index0 > indexCourant - 2 && index0 < indexCourant + 10))
                {
                }

                foreach (double futur in lfutur)
                {
                    rare = album.Rare;
                    noHorizon = conf.noHorizon;
                    var intervalle = conf.getIntervalle(rare, duree, intervalleMin0Head);
                    double delta = intervalle;
                    int nbFutur = 0;
                    int nbFuturh = 0;
                    int nbRestant = 0;
                    var deltaTotal = futur;
                    var deltaTotalH = futurh;
                    var atterissageMin = conf.getAtterrissageMin(rare);

                    double intervalleFactMoy = 1;
                    if (futur > 0)
                    {
                        finFutur = current.Pub.AddDays(futur);
                        finFuturH = current.Pub.AddDays(futurh);
                        if (finFutur > now)
                        {
                            var d = getweek((now - debutFutur).TotalDays);
                            finFutur = debutFutur.AddDays(d);

                            //indexDebut = 0;
                            //debutFutur = finFutur.AddDays(-futur);
                        }

                        if (finFuturH > now)
                        {
                            var d = getweek((now - debutFutur).TotalDays);
                            finFuturH = debutFutur.AddDays(d);

                        }


                        // chopper l'intervalle majoritaire pour éviter le poids des erreurs. 
                        Dict<int, int> spectreDelta = new Dict<int, int>();
                        DateTime lastExists = lastRead.Pub;
                        DateTime l = DateTime.MinValue;
                        for (int i = indexDebut; i < count; i++)
                        {
                            var t = list[i].Pub;
                            if (t < debutFutur)
                                continue;
                            if (t.Date == l.Date && list[i].track.Duree.TotalMinute < conf.collisionDuree)
                                continue;
                            l = t;
                            nbRestant++;

                            if (t < finFuturH)
                                nbFuturh++;


                            if (t < finFutur)
                            {
                                nbFutur++;


                                var dp = (int)(System.Math.Round((t - lastExists).TotalDays, 0, MidpointRounding.AwayFromZero));
                                lastExists = t;
                                if (dp > 0)
                                    spectreDelta[dp]++;
                            }
                            else if (nbRestant >= TrackAlbum.NB_MIN_POUR_FREQUENT)
                            {
                                break;
                            }
                        }

                        if (nbFutur == 0)
                            nbFutur = 1;
                        if (nbFuturh == 0)
                            nbFuturh = 1;
                        deltaTotal = (finFutur - debutFutur).TotalDays;
                        deltaTotalH = (finFuturH - debutFutur).TotalDays;
                        if (deltaTotal > 0)
                        {
                            intervalleFactMoy = deltaTotal / (double)nbFutur;
                        }

                        if (futura > 0)
                        {
                            var min = current.Pub.AddDays(-futura);
                            var nb2 = nbFutur;
                            DateTime pubDebut = current.Pub;
                            for (int i = indexDebut - 1; i >= 0; i--)
                            {
                                var t = list[i].Pub;
                                if (t < min)
                                    break;
                                nb2++;
                                pubDebut = t;
                            }
                            var deltaTotal2 = (finFutur - pubDebut).TotalDays;
                            var intervalleFactMoy2 = deltaTotal2 / (double)nb2;

                            if (intervalleFactMoy2 < intervalleFactMoy)
                            {
                                intervalleFactMoy = intervalleFactMoy2;
                                deltaTotal = deltaTotal2;
                                debutFutur = pubDebut;
                                nbFutur = nb2;
                            }
                            else
                            {
                            }
                        }
                        var limitMoy = conf.getLimitMoy(album.Rare);
                        if (limitMoy > 0 && intervalleFactMoy > limitMoy)
                            intervalleFactMoy = limitMoy;

                        intervalleX = getIntervalleX(intervalleFactMoy);

                        var choices = spectreDelta.Keys.ToList();
                        choices.Sort((x, y) => x.CompareTo(y));

                        int max = 0;
                        int dpMaj = 1;
                        for (int i = 0; i < choices.Count; i++)
                        {
                            int k = choices[i];
                            var r = spectreDelta[k];
                            if (r > max)
                            {
                                max = r;
                                dpMaj = k;
                            }
                        }

                        intervalleFactMin = dpMaj;

                        if (nbRestant < TrackAlbum.NB_MIN_POUR_FREQUENT)
                        {
                            if (!album.Open)
                            {
                                // this.album.RareEffect = true;
                                if (!rare)
                                    rare = true;
                                if (!noHorizon)
                                    noHorizon = true;
                            }
                        }
                    }






                    var intervalleMin0 = conf.getIntervalleMin0(rare);
                    // var intervalleMin0Var = conf.getIntervalleMin0Var(intervalleX, intervalleFactMin);


                    var intervalleVar = conf.getIntervalleVar(rare, intervalleX, duree, intervalleMin0);

                    var intervalleCorrec = intervalle;
                    var intervalleCorrecVar = intervalleVar;
                    var intervalleMin = conf.getIntervalleMin(rare, duree);
                    var intervalleMinVar = conf.getIntervalleMinVar(rare, intervalleX, duree);



                    var atterissageMinVar = conf.getatterrissageMinVar(intervalleX, atterissageMin);





                    double delta0Corr = deltaLastRead0;



                    if (pub2 > lastRead.Pub && conf.extPente == 0)
                    {
                        if (conf.elastique < 1)
                        {
                            delta0Corr = deltaLastRead0 * conf.elastique;
                            pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                        }


                    }


                    double densite = 1;

                    double rapportBorne = 1;
                    bool borneParHorizon = false;

                    double coeffVar = 1;


                    double deltaVar = intervalleVar;

                    double deltaHorizon0 = delta;
                    double deltaHorizon0Var = deltaVar;
                    double deltaHorizon00Var = deltaVar;
                    double deltaHorizon = delta;
                    double deltaHorizonVar = deltaVar;

                    bool useTolerance = false;



                    if (nbRead > 0 && _nbTotal > 0)
                    {

                        if (futur > 0)
                        {

                            var __intervalleMin0 = intervalleMin0;
                            if (__intervalleMin0 == 1)
                                __intervalleMin0 = 7.0 / 5.0;
                            double theoric = (finFutur - current.Pub).TotalDays / __intervalleMin0;
                            densite = nbFutur / theoric;

                            if (densite > 1)
                                densite = 1;

                            //if (densite < conf.densiteMin && !noHorizon)
                            //    noHorizon = true;
                            if (densite < conf.densiteMin && !rare)
                            {
                                rare = true;



                                intervalleMin0 = conf.getIntervalleMin0(rare);
                                // intervalleMin0Var = conf.getIntervalleMin0Var(intervalleX, intervalleFactMin);

                                intervalle = conf.getIntervalle(rare, duree, intervalleMin0);
                                intervalleVar = conf.getIntervalleVar(rare, intervalleX, duree, intervalleMin0);

                                intervalleCorrec = intervalle;
                                intervalleCorrecVar = intervalleVar;
                                intervalleMin = conf.getIntervalleMin(rare, duree);
                                intervalleMinVar = conf.getIntervalleMinVar(rare, intervalleX, duree);


                                atterissageMin = conf.getAtterrissageMin(rare);
                                atterissageMinVar = conf.getatterrissageMinVar(intervalleX, atterissageMin);





                                theoric = (finFutur - current.Pub).TotalDays / intervalleMin0;
                                densite = nbFutur / theoric;
                                if (densite > 1)
                                    densite = 1;
                            }
                            //if (densite < 1)
                            //    rapport = rapport * densite;
                        }




                        //  album.Rare ? conf.intervalleR : conf.intervalle;
                        coeff = 1 / rapport;

                        if (conf.dureeCoeff)
                            coeff = conf.getCoeff(rare, coeff, duree);

                        coeffVar = coeff;

                        if (conf.coeffDensite)
                        {
                            coeff /= densite;

                            coeffVar *= intervalleFactMoy;
                        }

                        if (conf.honneurAuxVieux && nbRestant < TrackAlbum.NB_MIN_POUR_FREQUENT)
                        {
                            if (nbRestant > 0)
                            {
                                var t = TrackAlbum.NB_MIN_POUR_FREQUENT / nbRestant;
                                coeff *= t;
                                coeffVar *= t;
                            }
                        }

                        if (this.album.Album == "PARLER CONTRE LA TERREUR")
                        {
                        }

                        var recup = intervalleMin0 - atterissageMin;
                        //   var recupVar = intervalleMin0Var - atterissageMinVar;


                        delta = intervalle; // conf.getIntervalle(album.Rare);
                        delta0 = delta;
                        deltaHorizon0 = delta;
                        deltaHorizon = delta;


                        deltaHorizon0Var = intervalleVar;
                        deltaHorizonVar = intervalleVar;

                        rapportBorne = conf.getHorizonCorrec(rapport, intervalleX);

                        if ((this.album.Album == "Rendez-vous avec X" || this.album.Album == "Sur les épaules de Darwin") && (index0 > indexCourant - 10 && index0 < indexCourant + 10))
                        {
                        }



                        deltaHorizon0 = intervalleMin0 + recup * (1 - rapport) / rapport + (1 - densite) / (densite * rapport);
                        //deltaHorizon0Var = intervalleMin0Var + recupVar * (1 - rapport) / rapport + (1 - 1 / intervalleFactMoy) / (rapport / intervalleFactMoy); 
                        //deltaHorizon0Var = intervalleFactMoy + ((1 - rapport) / rapport) * (intervalleFactMoy - atterissageMinVar); // ça pue
                        var d0 = (lastPub2 - pubMoyForCalcul).TotalDays;
                        var d1 = (lastPub2 - last.Pub).TotalDays;
                        var d00 = (pubMoyForCalcul - last.Pub).TotalDays;


                        var deltaMoy = d1; // System.Math.Min(d0, d1);
                        if (deltaMoy < 0)
                            deltaMoy = 0;

                        // var deltaTotalh = (finFuturH - debutFutur).TotalDays;

                        var correcMoy0 = (deltaTotalH - deltaMoy * rapportBorne) / nbFuturh;
                        var correcMoy1 = (deltaTotal - deltaMoy * rapportBorne) / nbFutur;
                        var correcMoy = System.Math.Min(correcMoy0, correcMoy1);
                        //  var correcMoy2 = intervalleFactMoy * deltaTotal / (deltaTotal + deltaMoy * rapportBorne);
                        double correcMoy2 = intervalleFactMoy;
                        double deltaTotalForH = deltaTotal;
                        if (deltaTotalH < deltaTotal && deltaTotalH > 0)
                            deltaTotalForH = deltaTotalH;

                        double coeffMoy = rapportBorne * deltaMoy / deltaTotalForH;
                        //double minh = System.Math.Max(intervalleMinVar, intervalleMin0);
                        //double deltah = intervalleFactMoy - minh;

                        var correc = 1.0;
                        if (noHorizon)
                            correc = densite;

                        if (conf.horizonCut)
                            correcMoy2 = _intervalleFactMoy * (1 - coeffMoy * correc); //    intervalleFactMoy * (1 -coeffMoy);
                        else
                        {
                            //zero=> 
                            //var d = deltah / (1 + coeffMoy);
                            //correcMoy2 = minh + d;
                            correcMoy2 = intervalleFactMoy / (1 + coeffMoy * correc);
                            //intervalleFactMoy / (1 + rapportBorne * deltaMoy / deltaTotalForH);
                        }
                        //if (correcMoy2 < minh)
                        //    correcMoy2 = minh;
                        // 1 - 10/5 =>-1  5/(5+10) =0.33
                        // 1- 1/100 => 0.99   100/(100+1) =0.99
                        deltaHorizon00Var = (intervalleFactMoy - atterissageMinVar * (1 - rapportBorne)) / rapportBorne;


                        deltaHorizon0Var = (correcMoy2 - atterissageMinVar * (1 - rapportBorne)) / rapportBorne;
                        // im=7, rapport=0.9

                        double min = 0;
                        double hor = 0;



                        foreach (double h in futurhl)
                        {
                            if (this.album.Album == "Sur les épaules de Darwin")
                            {
                            }
                            var p = PeriodBuilder.getDensite(list, index0, conf, h);
                            double moy = p.Moy();
                            var limitMoy = conf.getLimitMoy(album.Rare);
                            if (limitMoy > 0 && moy > limitMoy)
                                moy = limitMoy;
                            double _intervalleX = getIntervalleX(moy); // (moy - 1) / 6;
                            var _intervalleMin0 = conf.getIntervalleMin0(rare);
                            var _atterissageMinVar = conf.getatterrissageMinVar(_intervalleX, atterissageMin);
                            var _rapportBorne = conf.getHorizonCorrec(rapport, _intervalleX);

                            hor = (moy - _atterissageMinVar * (1 - _rapportBorne)) / _rapportBorne;
                            //hor = (moy - atterissageMinVar * (1 - rapportBorne)) / rapportBorne;
                            double ecartMax = p.nb * _rapportBorne * (hor - _intervalleMin0);
                            if (ecartMax > 0 && deltaMoy > ecartMax)
                            {
                                var moy2 = p.Moy(deltaMoy - ecartMax);
                                if (limitMoy > 0 && moy2 > limitMoy)
                                    moy2 = limitMoy;
                                hor = (moy2 - _atterissageMinVar * (1 - _rapportBorne)) / _rapportBorne;
                                // hor = (moy2 - atterissageMinVar * (1 - rapportBorne)) / rapportBorne;
                            }
                            if (hor > min)
                                min = hor;
                        }

                        if (deltaHorizon0Var >= min)
                        {
                        }
                        else
                        {
                            if (this.album.Album == "Sur les épaules de Darwin")
                            {
                            }
                            deltaHorizon0Var = min;
                        }


                        deltaHorizon = deltaHorizon0;
                        deltaHorizonVar = deltaHorizon0Var;



                        var tolerance = conf.getTolerance(rare);
                        double tolerancePart = 0;
                        if (tolerance > 0)
                        {
                            var ecart0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                            tolerancePart = (tolerance - ecart0) / conf.getNbTolerance(rare);
                            if (deltaHorizon < tolerancePart)
                                deltaHorizon = tolerancePart;
                            else if (conf.toleranceNegative && tolerancePart < 0)
                                deltaHorizon += tolerancePart;


                            if (deltaHorizonVar < tolerancePart)
                            {
                                deltaHorizonVar = tolerancePart;
                                useTolerance = true;
                            }
                            else if (conf.toleranceNegative && tolerancePart < 0)
                                deltaHorizonVar += tolerancePart;
                        }




                        if (!noHorizon && deltaHorizon < intervalle)
                            intervalleCorrec = deltaHorizon;

                        if (!noHorizon && deltaHorizonVar < intervalleVar)
                        {
                            intervalleCorrecVar = deltaHorizonVar;
                            if (!conf.horizonFinal)
                                borneParHorizon = true;
                        }



                        var _delta0 = borne(coeff, intervalle, intervalleMin, intervalleMin0); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
                        var _deltaVar0 = borne(coeffVar, intervalleVar, intervalleMinVar, intervalleMin0);




                        var _delta = borne(coeff, intervalleCorrec, intervalleMin, intervalleMin0); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
                        var _deltaVar = borne(coeffVar, intervalleCorrecVar, intervalleMinVar, intervalleMin0);


                        if (conf.horizonFinal)
                        {
                            if (_delta0 < delta)
                                delta = _delta0;
                            else if (_delta0 == delta)
                            { }
                            else
                            { }



                            if (_deltaVar0 < deltaVar)
                                deltaVar = _deltaVar0;
                            else if (_deltaVar0 == deltaVar)
                            { }
                            else
                            { }

                            if (delta > deltaHorizon)
                            {
                                if (noHorizon)
                                {
                                }
                                else
                                    delta = deltaHorizon;
                            }



                            if (deltaVar > deltaHorizonVar)
                            {
                                if (noHorizon)
                                {
                                }
                                else
                                {
                                    deltaVar = deltaHorizonVar;
                                    borneParHorizon = true;
                                }
                            }



                        }
                        else
                        {


                            if (_delta < delta)
                                delta = _delta;
                            else if (_delta == delta)
                            { }
                            else
                            { }


                            if (_deltaVar < deltaVar)
                                deltaVar = _deltaVar;
                            else if (_deltaVar == deltaVar)
                            { }
                            else
                            { }
                        }





                    }

                    //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


                    if (conf.intervalleVar)
                    {
                        delta = deltaVar;
                        atterissageMin = atterissageMinVar;
                        intervalleMin = intervalleMinVar;
                        // intervalleMin0 = intervalleMin0Var;
                        intervalle = intervalleVar;
                        deltaHorizon = deltaHorizonVar;
                    }

                    if (delta > deltaMax)
                    {
                        futurChoisi = futur;
                        deltaMax = delta;
                        _densite = densite;

                        rapportBorneHead = rapportBorne;
                        _delta0Corr = delta0Corr;
                        _deltaHorizon = deltaHorizon;
                        _deltaHorizon0 = deltaHorizon00Var;
                        nbReadHead = nbRead;
                        nbTotalHead = nbTotal;

                        useToleranceHead = useTolerance;
                        _borneParHorizon = borneParHorizon;

                        _intervalleCorrec = intervalleCorrec;
                        _intervalleCorrecVar = intervalleCorrecVar;
                        _densite = densite;
                        _intervalleFactMoy = intervalleFactMoy;
                        _atterissageMin = atterissageMin;

                        intervalleMin0Head = intervalleMin0;
                        intervalleHead = intervalle;
                        intervalleMinHead = intervalleMin;

                    }
                }

                if ((this.album.Album == "Rendez-vous avec X"))
                {
                    if (current.Pub.Year == 2015)
                    {
                    }
                }

                if (conf.extPente > 0)
                {
                    var d0 = (DateTime.Now - pub2).TotalDays;
                    var dl = conf.extDelta;
                    if (dl == 0)
                    {
                        dl = d0;
                    }

                    var __delta0 = d0 / conf.extPente;
                    var __delta = delta0;
                    //01/01/2014 ->01/01/2017
                    //04/01/2017 -> 04/01/2014
                    var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                    var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                    log.log("{0} {1}", deltaMax.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                    if (deltaLimiteEcoule > deltaMax)
                    {
                        double _coeff = deltaLimiteEcoule / deltaMax;
                        __delta = borne(_coeff, intervalleHead, intervalleMinHead, intervalleMinHead);
                    }

                    if (__delta < 1)
                        __delta = 1;

                    if (__delta > deltaMax)
                        deltaMax = __delta;


                    //if (delta > intervalle)
                    //    delta = intervalle;
                }


                //if (this.album.Album == "Sur les épaules de Darwin" && index0 >= indexCourant - 10)
                //{
                //}

                if (intervalleMinHead > deltaMax)
                    intervalleMinHead = deltaMax;
                //if (intervalleMin0Head > intervalleMinHead)
                //    intervalleMin0Head = intervalleMinHead;
                if (_atterissageMin > intervalleMinHead)
                    _atterissageMin = intervalleMinHead;
                var _atterissageMin0 = conf.atterrissageMin0;
                if (_atterissageMin < _atterissageMin0)
                {
                    _atterissageMin = _atterissageMin0;
                }
                if (intervalleMinHead < _atterissageMin)
                    intervalleMinHead = _atterissageMin;
                if (deltaMax < _atterissageMin)
                    deltaMax = _atterissageMin;





                // }





                if (conf.limitRead && deltaLecture > intervalleHead)
                {
                    //13 /10 ->7
                    var _old = deltaMax;

                    deltaMax += intervalleHead - deltaLecture;
                    log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), deltaMax.ToString("0.##"));
                }





                if (deltaMax < intervalleMinHead)
                    deltaMax = intervalleMinHead;

                if (deltaMax > intervalleHead)
                    deltaMax = intervalleHead;



                DateTime limitFuture = lastPub2.AddDays(deltaMax).truncateToMinute();
                DateTime ll = pub2.AddDays(_atterissageMin).truncateToMinute();
                if (limitFuture < ll)
                    limitFuture = ll;
                //  limitFuture = pub2.AddDays(delta).truncateToMinute();
                double ecart = 0;
                if (indexLastRead + 1 < count)
                {
                    TrackSort _next = list[indexLastRead + 1];
                    ecart = (limitFuture - _next.Pub).TotalDays;
                }

                DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * ecart).truncateToMinute();

                DateTime nextDate = limitFuture;

                int nb = 0;
                int nblissage = 0;
                double deltaAtterrissage = intervalleMinHead;
                double atterrissageVacance = deltaAtterrissage;

                if (this.album.Album == "La tête au carré" && lastRead != null && lastRead.Pub > new DateTime(2015, 4, 8))
                {
                }

                if (conf.noCollision)
                    deltaAtterrissage = deltaMax;

                string causes = "";


                {
                    var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                    var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                    DateTime dt = lastRead.Pub.AddDays(intervalleMin0Head);

                    var sbCause = new StringBuilder();

                    for (int i = indexLastRead + 1; i < count; i++)
                    {
                        var t = list[i];
                        if (conf.useVirtuel)
                        {
                            // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                            dt = dt.AddDays(intervalleMin0Head);
                        }
                        else
                            dt = t.Pub;


                        nb++;
                        if (dt > limitFuture)
                        {
                            sbCause = new StringBuilder();
                            nextDate = dt;
                            nblissage++;

                            int nbCause = 0;
                            if (dt <= _deltaMin)
                            {
                                sbCause.Append(" deltaMin");
                                nbCause++;
                            }
                            if (dt <= _deltaRab)
                            {
                                sbCause.Append(" deltaRab");
                                nbCause++;
                            }
                            if (nb <= conf.deltaNbMin)
                            {
                                sbCause.Append(" deltaNbMin");
                                nbCause++;
                            }
                            if (nblissage <= conf.deltaNbRab)
                            {
                                sbCause.Append(" deltaNbRab");
                                nbCause++;
                            }
                            if (dt <= limitFutureRab)
                            {
                                sbCause.Append(" coeffRab");
                                nbCause++;
                            }

                            if (nbCause > 0)
                            {
                                causes = sbCause.ToString();
                                continue;
                            }


                            break;


                            //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                            //    break;
                        }

                    }

                    if (nb > 0 && conf.noCollision) //    (nextDate > limitFuture && nb > 0 && conf.noCollision)
                    {
                        deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (deltaAtterrissage > intervalleMinHead)
                            deltaAtterrissage = intervalleMinHead;
                    }
                }

                if (deltaAtterrissage < _atterissageMin)
                {
                    causes += " corrigé atterrissageMin";
                    deltaAtterrissage = _atterissageMin;
                }


                atterrissageVacance = deltaMax * rapport + deltaAtterrissage * (1 - rapport);



                string atter = string.Format("{0}/{1}:{2}->{3}({4})", _intervalleFactMoy.ToString("0.##"), futurChoisi, deltaMax.ToString("0.##"), deltaAtterrissage.ToString("0.##"), atterrissageVacance.ToString("0.##"));

                string deltas = string.Format("{0} ic={1}({2}) h={3} h0={4} i={5} r={6}% ({7}%)", atter,
                   conf.intervalleVar ? _intervalleCorrecVar.ToString("0.##") : _intervalleCorrec.ToString("0.##"),
                   conf.intervalleVar ? _intervalleCorrec.ToString("0.##") : _intervalleCorrecVar.ToString("0.##"),
                   _deltaHorizon.ToString("0.##"), _deltaHorizon0.ToString("0.##"), intervalleHead.ToString("0.##"),
                   (100 * rapport).ToString("0"), (100 * rapportBorneHead).ToString("0"));
                //    deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"));
                string stats = string.Format("{0}/{1}={2}% c={3} d={4}% dr={5} r={6}({7})", nbReadHead, nbTotalHead, (100 * rapport).ToString("0"), coeff.ToString("0.##"), (_densite * 100).ToString("0"), (100 * _densite * rapport).ToString("0"),
                    deltaLastRead0.ToString("0.##"), _delta0Corr.ToString("0.##"));
                var sbAlbum = new StringBuilder();

                sbAlbum.Append(string.Format("[{0}]", album.Album));
                if (album.Rare) sbAlbum.Append(" rare ");
                else if (rare) sbAlbum.Append(" rare+ ");
                sbAlbum.Append(current.track.Duree.TotalMinute.ToString("0 m"));

                string _usetolerance = useToleranceHead ? "+" : " ";
                {
                    string h = _borneParHorizon ? "h" : " ";
                    string _rapportBorne = (rapportBorneHead == 1 & rapport < 1) ? "~" : " ";
                    var str = string.Format("{0} {1}{2}{3}{4} lect={5} causes={6}", stats, sbAlbum.ToString(), _usetolerance, h, _rapportBorne, deltaLecture.ToString("#,#"), causes);


                    if (played)
                    {
                        if (index0 >= indexCourant && index0 <= indexLastSelected)
                            log.logNoDate(str);
                        else
                            logDebug.logNoDate(str);
                    }
                }



                int suivant = index0 + 1;
                if (suivant < count)
                {

                    var t = list[index0 + 1]; // current; // list[indexNext];

                    var _deltaAtterrissage = deltaAtterrissage;
                    var __atterrissageMin = _atterissageMin;
                    if (conf.vacances && index0 >= indexNext)
                    {
                        _deltaAtterrissage = atterrissageVacance;
                        __atterrissageMin = deltaMax * rapport + _atterissageMin * (1 - rapport);
                    }

                    DateTime dt = lastPub2;

                    if (suivant == indexLastRead + 1 && !conf.useVirtuel2)
                    {
                        dt = limitFuture;
                        // lastPubTh = limitFuture;
                    }
                    else
                    {


                        var d = (t.Pub - last.Pub).TotalDays / intervalleMin0Head;


                        if (conf.useVirtuel2)
                        {
                            dt = lastPub2.AddDays(d * _deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                            // lastPubTh = lastPub2.AddDays(d * _atterrissageMin).truncateToMinute();
                        }
                        else
                        {
                            dt = lastPub2.AddDays(_deltaAtterrissage).truncateToMinute();
                            // lastPubTh = lastPubTh.AddDays(_atterrissageMin).truncateToMinute();
                        }
                        if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1 && t.Pub2 < date1)
                        {
                            var dt2 = dt;
                            if (conf.useVirtuel2)
                                dt2 = lastPub2.AddDays(d * deltaMax).truncateToMinute();
                            else
                                dt2 = lastPub2.AddDays(deltaMax).truncateToMinute();
                            //if (dt2 <= date0)
                            dt = dt2;
                            //else
                            //    dt = date0.AddMinutes(1);
                        }


                    }



                    var deltaIncompressible = _atterissageMin;
                    if (_atterissageMin0 < deltaIncompressible)
                        deltaIncompressible = _atterissageMin0;


                    var dtMin = lastPub2.AddDays(deltaIncompressible);

                    if (dt < dtMin)
                        dt = dtMin;
                    bool erasedNext = false;
                    if (conf.erasedDone)
                    {
                        if (!played && current.Pub2 <= current.Pub)
                            erasedNext = true;
                    }
                    if (t.Pub >= dt || conf.enabled == sortMode.reset || erasedNext)
                    {
                        if (dt > t.Pub)
                        {
                        }
                        eraseSort(t, deltas, pubMoy);
                    }
                    else
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                        {
                            if (__delta > cumulMin)
                            {
                                __delta = borneCumul(__delta, cumulMin, cumulMax);
                                dt = t.Pub.AddDays(__delta).truncateToMinute();
                            }
                        }

                        if (conf.elastique2 < 1)
                        {
                            var deltacorr2 = __delta * conf.elastique2;
                            dt = t.Pub.AddDays(deltacorr2).truncateToMinute();
                        }



                        if (dt < dtMin)
                            dt = dtMin;

                        var limitDelta = conf.getLimitDelta(album.Rare);
                        if (limitDelta > 0)
                        {
                            var dtMax = lastPub2.AddDays(limitDelta);
                            if (dt > dtMax)
                                dt = dtMax;
                        }

                        if (dt > DateTime.Now)
                        {
                        }

                        if ((dt - t.Pub).TotalDays > 100)
                        {
                        }

                        if (t.Pub >= dt || erasedNext)
                            eraseSort(t, deltas, pubMoy);
                        else
                            writeComment(t, dt, deltas, pubMoy);
                        //nb++;
                    }


                    last = t;
                    lastPub2 = t.Pub2; // dt;


                    pubMoy = pubMoy.AddDays(_intervalleFactMoy);
                    pubMoyForCalcul = pubMoyForCalcul.AddDays(_intervalleFactMoy);

                    if (pubMoyForCalcul > lastPub2)
                        pubMoyForCalcul = lastPub2;


                    if (played)
                    {
                        //prelastRead = current;
                        ////lastPlayed = lastRead.PlayedDate;
                        //indexPrelastRead = index0;
                    }

                }


                index0++;
            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }


        public void Build()
        {

            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            //if (conf.enabled == sortMode.histo)
            //{
            //    buildAll();
            //    return;
            //}
            //else
            //{
            //checkSelected = true;
            //apply = true;
            date0 = Conf.Date0;
            if (conf.deltaConstLate >= 0)
                date1 = date0.AddDays(conf.deltaConstLate);
            // newDate0 = Conf.NewDate0;
            if (conf.oldMode)
                throw new NotImplementedException(); //     build0();
            else
                build();
            return;
            //  }

            #region old
            /* if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true, true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, true);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, true, true, Conf.Date0, Conf.NewDate0);
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            */
            #endregion


        }



        private void eraseSort(TrackSort track, string desc, DateTime dateMoy)
        {
            writeComment(track, track.Pub, desc, dateMoy);
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (!checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = track.Pub;
            //    return;
            //}

            ////if (!force && !track.Selected)
            ////    return;
            //if (conf.canGoBack || conf.enabled == sortMode.reset)
            //{
            //    if (!track.Played && track.Enabled)
            //    {
            //        DateTime pub = track.Pub;
            //        if (track.Pub2 >= date0 && pub <date0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //        else if (track.Pub2 >=newDate0 && pub < newDate0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //    }

            //    //}
            //    //else
            //    //{
            //    if (track.Pub2 != track.Pub)
            //        nbModif++;
            //    track.Pub2 = track.Pub;
            //    //}
            //    track.track.BuildComment();
            //    // writeComment(track);
            //}
        }

        //private void applyPub(TrackSort track)
        //{
        //    writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);
        //}

        private void writeComment(TrackSort track, DateTime dt, string desc, DateTime pubMoy)
        {
            dt = dt.truncateToMinute();

            var format = DAY_FORMAT;
            if (dt.Year != track.Pub.Year)
                format = DATE_FORMAT;
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = dt;
            //    return;
            //}



            //if (checkSelected && !track.Selected)
            //    return;


            if (conf.canGoBack)
            {
                if (getPlayed(track, index0) && track.Enabled)
                {
                    if (track.pub20 >= date0 && dt < date0)
                    {
                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            repeches.Add(track);
                        }
                        if (dt < dateRepeche)
                            dateRepeche = dt;
                    }

                    //else if (track.pub20 >= newDate0 && dt < newDate0)
                    //{

                    //    if (conf.canGoBackButForceSelected)
                    //    {
                    //        log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                    //        nbRepecheForce++;
                    //        dt = date0.AddMinutes(nbRepecheForce);
                    //    }
                    //    else
                    //    {
                    //        log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.pub20, dt, newDate0);
                    //        repeches.Add(track);
                    //    }

                    //    if (dt < dateRepeche)
                    //        dateRepeche = dt;

                    //}
                }
            }
            else
            {
                if (dt == track.pub20)
                {
                    logDebug.logNoDate("\t{0} {1} {2}\t{3}", track.Pub.ToString(DATE_FORMAT), dt.ToString(format), desc, track.Name);
                    return;
                }
                else if (dt < track.pub20)
                {
                    logDebug.logNoDate("\t{0} {1}<= {2} {3}\t{4}", track.Pub.ToString(DATE_FORMAT), track.pub20.ToString(format), dt.ToString(format), desc, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var delta0 = (track.pub20 - track.Pub).TotalDays;

            var deltaMoy0 = (track.pub20 - pubMoy).TotalDays;
            var deltaMoy1 = (dt - pubMoy).TotalDays;


            var sbDelta = new StringBuilder();
            sbDelta.Append("(");
            var strD0 = delta0.ToString("#.#");
            var strD1 = delta.ToString("#.#");

            var strDM0 = deltaMoy0.ToString("#.#");
            var strDM1 = deltaMoy1.ToString("#.#");
            if (delta0 > 0)
            {
                if (delta0 > 0)
                    sbDelta.Append(strD0);
                //sbDelta.Append("|");
                ////  if (deltaMoy0 > 0)
                //sbDelta.Append(strDM0);
            }
            if (strD0 != strD1)
            {
                sbDelta.Append("->");
                if (delta > 0)
                    sbDelta.Append(strD1);
                //sbDelta.Append("|");
                //if (deltaMoy1 > 0)
                //    sbDelta.Append(strDM1);
            }
            //sbDelta.Append("|");
            //if (deltaMoy0 != 0)
            //{
            //    sbDelta.Append(strDM0);

            //    if (strDM1 != strDM0)
            //    {
            //        sbDelta.Append("->");
            //        if (deltaMoy1 > 0)
            //            sbDelta.Append(strDM1);
            //    }
            //}
            sbDelta.Append(")");

            while (sbDelta.Length < 22)
                sbDelta.Append(" ");

            var strDelta = sbDelta.ToString();

            if (track.pub20 != dt)
            {

                if (track.pub20.truncateToMinute() != dt)
                {
                    //if (track.track.Selected)
                    //{
                    nbModif++;
                    var d = System.Math.Abs((track.pub20 - dt).TotalHours);
                    if (d > 1)
                        nbModifPertinent++;
                    else if (dt != track.Pub)
                        return;

                    var dd = System.Math.Abs((track.pub20 - dt).TotalMinutes);
                    if (dd <= 5)
                    {
                        log.log("poil de cul {0}", track);
                    }

                    // var str = string.Format("\t{0}\t{1}=>\t{2}({3})\t{4} {5}", track.Pub, track.pub20, dt, strDelta, desc, track.Name);

                    var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), dt.ToString(format), strDelta, desc, track.Name); // ", track.pub20, dt, strDelta, desc, track.Name);
                    if (track.track.Selected)
                        log.logNoDate(str);
                    else
                        logDebug.logNoDate(str);
                    //}
                }
                track.Pub2 = dt;
            }
            else if (track.pub20 > track.Pub)
            {
                // if (track.track.Selected)
                var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), dt.ToString(format), strDelta, desc, track.Name);
                // var str = string.Format("\t{0}\t{1}({2})\t{3} {4}", track.Pub, track.pub20, strDelta, desc, track.Name);
                if (track.track.Selected)
                    log.logNoDate(str);
                else
                    logDebug.logNoDate(str);
            }
            else
            {
                var sbBlanc = new StringBuilder();

                var str = string.Format("\t{0} {1}{2}\t{3}\t{4}", track.Pub.ToString(DATE_FORMAT), Regex.Replace(dt.ToString(format), ".", " "), strDelta, desc, track.Name);
                // var str = string.Format("\t{0} ({1})\t{2} {3}", track.Pub, strDelta, desc,track.Name);
                logDebug.logNoDate(str);
            }


            track.track.BuildComment();
            //  track.track.BuildComposer(); 
        }

        private static double borne(double coeff, double intervalle, double intervalleMin, double intervalleMin0)
        {
            double _delta = 0;
            if (intervalle < intervalleMin)
                intervalleMin = intervalle;
            if (coeff <= 1)
                _delta = coeff * intervalleMin;
            else
            {
                coeff -= 1; // 9  0.11
                var dminmax = intervalle - intervalleMin;
                _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);
            }

            if (_delta < intervalleMin0)
                _delta = intervalleMin0;
            return _delta;
        }

        private static double borneCumul(double delta, double cumulMin, double cumulMax)
        {
            if (cumulMin < 0 || cumulMax < 0)
                return delta;
            if (delta < cumulMin)
                return delta;
            var coeff = delta / cumulMin;
            return borne(coeff, cumulMax, cumulMin, cumulMin);
        }

        private double _coeffLecture = -1;
        //public double getCoeffLecture(TrackInfoItunes track)
        //{
        //    if (_coeffLecture > 0)
        //        return _coeffLecture;
        //    int count = list.Count;
        //    int index = -1;
        //    for (int i = 0; i < count; i++)
        //    {
        //        if (list[i].track == track)
        //        {
        //            index = i;
        //            break;
        //        }
        //    }
        //    if (index < 0)
        //        return 0;

        //    var _histo = conf.getHisto(track.Rare);

        //    if (_histo > 0)
        //    {
        //        int nbTotal = 0;
        //        int nbRead = 0;
        //        double histo = _histo;




        //        DateTime limit = track.Pub.AddDays(-histo);
        //        for (int i = index - 1; i >= 0; i--)
        //        {
        //            var t = list[i];
        //            var dt = t.Pub;
        //            if (dt < limit && nbTotal >= conf.totalMin)
        //                break;

        //            if (getPlayed(t, true))
        //                nbRead++;


        //            nbTotal++;

        //        }

        //        if (nbTotal > 0)
        //            _coeffLecture = nbRead / nbTotal;
        //        else
        //            return 0;
        //    }
        //    else
        //        return 0;

        //    return _coeffLecture;



        //}
    }
}]]></content>
  </file>
  <file path="db4\pdb.util\ConsoleLogger.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace pdb.util
{
    public class ConsoleLogger
    {
        public static void log(string txt)
        {
            if (txt == null)
                return;
            var name = Thread.CurrentThread.Name; 
            if (string.IsNullOrEmpty(name))
                name = Thread.CurrentThread.ManagedThreadId.ToString(); 
            var content = string.Format("[{0}] {1} {2}", name, DateTime.Now.ToLongTimeString(), txt);
            Console.WriteLine(content); 
        }

        public static void log(string format, params object[] args)
        {
            var txt = string.Format(format, args);
            log(txt); 
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.util\pdb.util.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.util</RootNamespace>
    <AssemblyName>pdb.util</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Debug\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
    <UseVSHostingProcess>true</UseVSHostingProcess>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AsyncFileWriter.cs" />
    <Compile Include="BgDict.cs" />
    <Compile Include="CalcMedianne.cs" />
    <Compile Include="Chrono.cs" />
    <Compile Include="ConsoleLogger.cs" />
    <Compile Include="CustomFormat.cs" />
    <Compile Include="CUtil.cs" />
    <Compile Include="DateUtil.cs" />
    <Compile Include="DecimalIndex.cs" />
    <Compile Include="DescBuilder.cs" />
    <Compile Include="Dict.cs" />
    <Compile Include="FileRegister.cs" />
    <Compile Include="FileRotator.cs" />
    <Compile Include="FileType.cs" />
    <Compile Include="Generic\Attributs\AttributeHelper.cs" />
    <Compile Include="Generic\Attributs\CustomAttribute.cs" />
    <Compile Include="Generic\Attributs\Db\DbAttributes.cs" />
    <Compile Include="Generic\Attributs\Db\SbAttributes.cs" />
    <Compile Include="Generic\Attributs\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Json\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\NameAttributeBase.cs" />
    <Compile Include="Generic\Attributs\Sp\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Xml\XmlAttributes.cs" />
    <Compile Include="Generic\Encode\Getters.cs" />
    <Compile Include="Generic\Encode\JSON.cs" />
    <Compile Include="Generic\Encode\JsonEncoder.cs" />
    <Compile Include="Generic\Encode\JsonParser.cs" />
    <Compile Include="Generic\Encode\JsonSerializer.cs" />
    <Compile Include="Generic\Encode\JsonXmlEncoder.cs" />
    <Compile Include="Generic\Encode\SafeDictionary.cs" />
    <Compile Include="Generic\INode.cs" />
    <Compile Include="Generic\MappingException.cs" />
    <Compile Include="Generic\Parse\DbParser.cs" />
    <Compile Include="Generic\Parse\DbWrapper.cs" />
    <Compile Include="Generic\Parse\JsonParser.cs" />
    <Compile Include="Generic\Parse\Json\JsonBuilder.cs" />
    <Compile Include="Generic\Parse\Json\JsonParseException.cs" />
    <Compile Include="Generic\Parse\Json\JsonState.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateDeuxPoints.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateFinal.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateName.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValue.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValueIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonWrapper.cs" />
    <Compile Include="Generic\Parse\Node.cs" />
    <Compile Include="Generic\Parse\Parser.cs" />
    <Compile Include="Generic\Parse\ParserBase.cs" />
    <Compile Include="Generic\Parse\XmlParser.cs" />
    <Compile Include="Generic\Parse\XmlSerializer.cs" />
    <Compile Include="Generic\Parse\XmlWrapper.cs" />
    <Compile Include="Generic\TypeInfo.cs" />
    <Compile Include="Generic\Utils.cs" />
    <Compile Include="Generic\XmlParser.cs" />
    <Compile Include="Generic\XmlSerializer.cs" />
    <Compile Include="IClient.cs" />
    <Compile Include="list\DictList.cs" />
    <Compile Include="DictLocation.cs" />
    <Compile Include="DisposableCounter.cs" />
    <Compile Include="FileUtil.cs" />
    <Compile Include="HashList.cs" />
    <Compile Include="ILogger.cs" />
    <Compile Include="list\LinkedList.cs" />
    <Compile Include="list\SequentialDict.cs" />
    <Compile Include="list\SequentialDictString.cs" />
    <Compile Include="list\Stack.cs" />
    <Compile Include="Locker.cs" />
    <Compile Include="Logger.cs" />
    <Compile Include="LoggerConsole.cs" />
    <Compile Include="Math.cs" />
    <Compile Include="MemUtil.cs" />
    <Compile Include="misc.cs" />
    <Compile Include="ordo\Ordonnanceur.cs" />
    <Compile Include="ordo\QueueOrdo.cs" />
    <Compile Include="ordo\Task.cs" />
    <Compile Include="OutputRecorder.cs" />
    <Compile Include="PathUtil.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Queue.cs" />
    <Compile Include="serialize\Serializer.cs" />
    <Compile Include="serialize\TextSerializer.cs" />
    <Compile Include="StringUtil.cs" />
    <Compile Include="TextWriter.cs" />
    <Compile Include="ThreadUtil.cs" />
    <Compile Include="TimeSpan.cs" />
    <Compile Include="TuningBase.cs" />
    <Compile Include="XMLTool.cs" />
    <Compile Include="ZipUtil.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="db4\pdb.util\ordo\Ordonnanceur.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util.ordo
{
    public class Ordonnanceur
    {
        private List<QueueOrdo> files = new List<QueueOrdo>();
        private Queue<Task> waiting = new Queue<Task>();
        //private ThreadUtil th;

        public Ordonnanceur(int nbTh)
        {
            for (int i = 0; i < nbTh; i++)
                files.Add(new QueueOrdo(this, "File " + i));
        }

        public bool Busy
        {
            get
            {
                if (!waiting.Empty)
                {
                    checkRest(); 
                    return true;
                }
                foreach (QueueOrdo file in files)
                {
                    if (file.Busy)
                        return true;
                }
                return false;
            }
        }

        //private void loop()
        //{
        //    while (true)
        //    {
        //        Action a = waiting.Dequeue();
        //        if (a == null)
        //        {
        //            ThreadUtil.Sleep(30);
        //            continue;
        //        }

        //        bool launched = false;
        //        while (!launched)
        //        {
        //            foreach (QueueOrdo file in files)
        //            {
        //                if (file.Busy)
        //                    continue;
        //                file.add(a);
        //                launched = true;
        //                break;
        //            }

        //            if (!launched)
        //            {
        //                ThreadUtil.Sleep(30);
        //            }
        //        }
        //    }
        //}
        public void addsubTask(Task action)
        {
            if (files.Count == 0)
            {
                action.exec(); 
                return; 
            }
            waiting.EnQueue(action);
        }

        public void checkRest()
        {
            
            if (waiting.Empty)
                return;
            while (true)
            {
                bool launched = false;
                foreach (QueueOrdo file in files)
                {
                    if (file.Busy)
                        continue;
                    lock (this)
                    {
                        if (file.Busy)
                            continue;
                        var old = waiting.Dequeue();
                        if (old == null)
                            break;
                        file.add(old);
                        launched = true;
                        break;
                    }
                }
                if (!launched)
                    break;
            }

        }
        public void addTask(Task action)
        {
            if (files.Count ==0)
            {
                action.exec(); 
                return; 
            }
            //ConsoleLogger.log("addTask " + action);
            bool launched = false;
            while (!launched)
            {
                foreach (QueueOrdo file in files)
                {
                   // ConsoleLogger.log("action={0} file={1}",  action, file); 
                    if (file.Busy)
                        continue;
                    lock (this)
                    {
                        if (file.Busy)
                            continue;
                        file.add(action);
                        launched = true;
                        break;
                    }


                }

                if (!launched)
                {
                    ThreadUtil.Sleep(1000);
                }
            }
        }

    }
}
]]></content>
  </file>
  </db>
