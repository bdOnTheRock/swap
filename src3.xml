<db path="C:\bernard\db4">
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using pdb.gen.auto;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        // private static PieceExtended index;
        //  public static int Index { get { return index; } }
        private static IPieceAlbum median;


        //public static DecimalIndex getMedianne(IList<Piece> list, bool main, decimal coeffMedianne)
        //{

        //    return new DecimalIndex() { d = getMedianne_(list, main, coeffMedianne), index = index };
        //}


        public static DecimalPiece getMedianne(IList<IPieceAlbum> list, bool main, decimal coeffMedianne)
        {
            PieceExtended.Mode = pieceExtendedMode.main;
            var ret = getMedianne_(list, coeffMedianne);
            return new DecimalPiece() { d = ret, index = median };
        }
        private List<IPieceAlbum> pieces;
        private ConfMedianne mode;
        private int _nbNoAdd;
        public AlbumMedianne(List<IPieceAlbum> pieces, ConfMedianne mode)
        {
            this.pieces = pieces;
            this.mode = mode;
            this._nbNoAdd = getNoAdd(mode.Main);
        }



        public void buildVirtual(bool combine, bool simple)
        {

            if (!mode.Min.Use)
            {
                buildVirtual0(mode.Main, true);
                align(mode.Main, pieceExtendedMode.main);
            }
            else
            {
                buildVirtual0(mode.Main, true);
                buildVirtual0(mode.Min, false);

                if (combine)
                {
                    foreach (IPieceAlbum p in pieces)
                        p.Combine();
                    align(mode.Main, pieceExtendedMode.combine);
                }

                if (!simple)
                {
                    align(mode.Main, pieceExtendedMode.main);
                    align(mode.Min, pieceExtendedMode.min);
                }
            }



            //if (!mode.Min.Use)
            //{
            //    buildVirtual0(mode.Main, true);
            //    align(mode.Main, PieceExtended.mode.main);
            //}
            //else if (combine && simple)
            //{
            //    buildVirtual0(mode.Main, true);
            //    buildVirtual0(mode.Min, false);
            //    foreach (PieceExtended p in pieces)
            //        p.Combine();
            //    align(mode.Main, PieceExtended.mode.combine);
            //}
            //else
            //{
            //    buildVirtual0(mode.Main, true);
            //    buildVirtual0(mode.Min, false);
            //    align(mode.Main, PieceExtended.mode.main);
            //    align(mode.Min, PieceExtended.mode.min);

            //    if (combine)
            //    {
            //        foreach (PieceExtended p in pieces)
            //            p.Combine();
            //        align(mode.Main, PieceExtended.mode.combine);
            //    }
            //}
        }

        private int getNoAdd(ConfMedianneVirt modeVirt)
        {

            var safe = modeVirt.safe;
            var _nbNoAdd = 0;

            int i0 = 0;
            int count = pieces.Count;
            if ((modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll) || modeVirt.noAddAll)
                return pieces.Count;
            else if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
            {
                _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
                if (modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll)
                    return _nbNoAdd;
                if (_nbNoAdd > 0)
                    _nbNoAdd--;
            }
            else
            {
                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.Empty)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }
            }

            //if (modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll)
            //    return _nbNoAdd;

            if (modeVirt.noAddEnd)
            {
                // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                // morceaux déjà notés
                var nb2 = pieces.Count<IPieceAlbum>(p => !p.Enabled && !p.Empty);
                _nbNoAdd = _nbNoAdd - nb2;
                if (_nbNoAdd < 0)
                    _nbNoAdd = 0;
            }
            _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

            return _nbNoAdd;
        }

        public void align(ConfMedianneVirt modeVirt, pieceExtendedMode main)
        {
            var count = pieces.Count;
            if (count < 2)
                return;
            PieceExtended.Mode = main;
          //  pieces.Sort(new PieceCmp0());

            decimal prec = pieces[count - 1].Value;

            var coeffEnabled = modeVirt.CoeffOld;


            for (int j = count - 2; j >= 0; j--)
            {
                var cand = pieces[j].Value;
                bool change = false;
                if (cand == 0)
                    continue;
                if (modeVirt.virtAlignPrec)
                {
                    if (cand < prec)
                    {
                        cand = prec + EPSILON;
                        change = true;
                    }
                }

                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                {

                    // quel serait le score s'il était coché
                    var vu = pieces[j].Value / coeffEnabled;
                    // en plus une petite marge
                    //  vu *= mode.coeffVirt; 
                    if (cand < vu)
                    {
                        cand = vu;
                        change = true;
                    }
                }
                if (change)
                    pieces[j].Value = cand;

                prec = cand;
            }

        }

        //public void align0(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        //{
        //    var count = pieces.Count; 
        //    if (count < 2)
        //        return;
        //    pieces.Sort(new PieceCmp0()); 
        //    //if (main== PieceExtended.mode.main)
        //    //    pieces.Sort(new PieceCmp());
        //    //else if (main == PieceExtended.mode.min)
        //    //    pieces.Sort(new PieceCmp2());
        //    //else
        //    //    pieces.Sort(new PieceCmp3());
        //    decimal prec = 0m;

        //    var coeffEnabled = modeVirt.CoeffOld;

        //    if (modeVirt.virtAlignPrec)
        //    {
        //        //if (_nbNoAdd < pieces.Count)
        //            prec = pieces[_nbNoAdd].Value;
        //    }

        //    for (int j = _nbNoAdd - 1; j >= 0; j--)
        //    {
        //        if (j < pieces.Count)
        //        {

        //            if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //            {
        //                var cand = pieces[j].Value;
        //                if (modeVirt.virtAlignPrec)
        //                {
        //                    if (cand < prec)
        //                        cand = prec + EPSILON;
        //                }

        //                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                {

        //                    // quel serait le score s'il était coché
        //                    var vu = pieces[j].Value / coeffEnabled;
        //                    // en plus une petite marge
        //                    //  vu *= mode.coeffVirt; 
        //                    if (cand < vu)
        //                        cand = vu;
        //                }
        //                pieces[j].Value = cand;

        //            }

        //            prec = pieces[j].Value;
        //        }
        //    }
        //}

        public void buildVirtual0(ConfMedianneVirt modeVirt, bool main)
        {
            DateTime limitDC = DateTime.Now.AddDays(-modeVirt.virtDelay);
            var coeffEnabled = modeVirt.CoeffOld;

            var _coeffVirt = modeVirt.coeffVirt;
            var safe = modeVirt.safe;
            int i0 = 0;

            int count = pieces.Count;
            PieceClassementComparer cmp = null;
            PieceExtended.Mode = main ? pieceExtendedMode.main : pieceExtendedMode.min;

            if (coeffEnabled > 1)
            {
                for (int i = 0; i < count; i++)
                {
                    var p = pieces[i];

                    if (p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
                        p.setCoeff(coeffEnabled, main);
                }
            }

            cmp = new PieceClassementComparer(false, main ? pieceExtendedMode.main : pieceExtendedMode.min);
            pieces.Sort(cmp);

            int indexV = 0;
            int nbAdd = 0;
            var _zero = mode.zero;
            i0 = count - 1;


            int _count = System.Math.Min(count, i0 + safe);
            decimal[] virt = null; // = new decimal[_count];
            //_nbNoAdd = System.Math.Min(safe, _nbNoAdd);
            var _coeffVirt0 = _coeffVirt;

            if (modeVirt.noAdd)
            {
                if (_coeffVirt > 1)
                {
                    if (modeVirt.coeffVirtAuto && (modeVirt.coeffVirtAutoAll || count < safe))
                    // if (count < safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;


                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < pieces.Count)
                        {
                            var p = pieces[j]; 
                            if (modeVirt.noVirtZero && p.Empty)
                                continue;

                            if (modeVirt.forceCoeffVirt)
                                _coeff *= _coeffVirt;
                            else if (!modeVirt.virtOnlyDisabled || !p.Enabled)
                                _coeff *= _coeffVirt;


                            if (p.Empty)
                                continue;

                            if (!p.Enabled)
                                continue; 
                            var dc = p.Piece.UpdateClassement;
                            if (dc == null || dc.Value < limitDC)
                            {
                                p.Coeff = _coeff; // Value = pieces[j].Value / _coeff;
                            }
                            //pieces[j].EffectMain = coeffEnabled < _coeff;

                        }
                    }
                }

            }
            else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = pieces[i].Value;
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= _coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
            }
            else
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    decimal courant = pieces[0].Value;
                    for (int i = 1; i < _count; i++)
                    {
                        if (pieces[i].Value <= _zero)
                        {
                            courant /= _coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = pieces[i].Value;
                    }
                }
            }

            decimal value = int.MaxValue;


            if (!modeVirt.noAdd)
            {
                int ii = 0;
                if (virt == null)
                    virt = new decimal[_count];
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = pieces[ii].Value;
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (modeVirt.lissage || value <= _zero)
                        {
                            if (value <= _zero)
                                nbAdd++;
                            value = calc;
                            pieces[ii].Value = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (modeVirt.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= safe)
                            continue;
                        pieces[i].Value = 0m;
                    }

                }
                if (mode.removeFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces[i].Value = 0m;
                    }
                }
            }



            if (mode.deleteFirst)
            {
                for (int i = 0; i < nbAdd; i++)
                {
                    pieces.RemoveAt(0);
                }
            }

        }

        //public static int buildVirtual(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, bool main, bool combine, ref int i0)
        //{
        //    var coeffEnabled = modeVirt.CoeffOld;

        //    var _coeffVirt = modeVirt.coeffVirt;
        //    var safe = modeVirt.safe;
        //    if (combine)
        //    {
        //        coeffEnabled = mode.Main.CoeffOld * mode.Min.CoeffOld;
        //        _coeffVirt = mode.Main.coeffVirt * mode.Min.coeffVirt;
        //        safe = (int)Math.Max(mode.Main.safe, mode.Min.safe);
        //    }


        //    //   var coeff = 1 / coeffEnabled; 
        //    int count = pieces.Count;
        //    PieceClassementComparer cmp = new PieceClassementComparer(false);
        //    pieces.Sort(cmp);
        //    //if (coeffEnabled != 1)
        //    //{
        //    if (coeffEnabled > 1)
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            var p = pieces[i];
        //            //  var rapportClassement = p.RapportClassement;
        //            if (coeffEnabled != 1m && p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
        //            {
        //                p.setCoeff(coeffEnabled, main);
        //                //rapportClassement /= coeffEnabled;
        //            }

        //            //p.setClassementVirtuel(rapportClassement);
        //            //if (!main)
        //            //    p.setClassementVirtuel2(rapportClassement);
        //        }
        //    }

        //    cmp = new PieceClassementComparer(false, main ? PieceExtended.mode.main : PieceExtended.mode.min);
        //    pieces.Sort(cmp);
        //    // }

        //    int indexV = 0;
        //    int nbAdd = 0;


        //    // List<Piece> _pieces = pieces;
        //    var _zero = mode.zero;


        //    //if (modeVirt.safe > 0)
        //    //{
        //    i0 = count - 1;
        //    int _nbNoAdd = 0;




        //    if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
        //    {
        //        _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
        //        if (_nbNoAdd > 0)
        //            _nbNoAdd--;
        //    }
        //    else if (modeVirt.noAddAll)
        //        _nbNoAdd = pieces.Count;
        //    else
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            var pp = pieces[i];
        //            if (pp.VirtualClassement == 0m)
        //            {
        //                i0 = i;
        //                _nbNoAdd = count - i0;
        //                break;
        //            }
        //        }
        //    }

        //    if (modeVirt.noAddEnd)
        //    {
        //        // var nb1 = pieces.Count<Piece>(p => p.Enabled);
        //        // morceaux déjà notés
        //        var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
        //        _nbNoAdd = _nbNoAdd - nb2;
        //        if (_nbNoAdd < 0)
        //            _nbNoAdd = 0;
        //    }
        //    //if (i0 == 0)
        //    //    return 0;
        //    //}

        //    //for (int i00 = 1; i00 <= i0; i00++)
        //    //{
        //    //    decimal coeff = (decimal)i00 / (decimal)i0;
        //    //List<decimal> _list = new List<decimal>();
        //    //for (int i = 0; i < pieces.Count; i++)
        //    //    _list.Add(pieces[i].getVirtual(main));
        //    //for (int i = i00; i < count; i++)
        //    //    _list[i] = 0m;
        //    //liste partielle originale
        //    //  List<decimal> _list0 = new List<decimal>(_list);
        //    int _count = System.Math.Min(count, i0 + safe);
        //    decimal[] virt = new decimal[_count];
        //    _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

        //    if (modeVirt.noAdd)
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            // var coeffEnabled = modeVirt.coeffOld; 

        //            if (count < safe && modeVirt.coeffVirtAuto)
        //            {
        //                if (modeVirt.coeffVirtAdjust)
        //                    _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
        //                else
        //                {
        //                    // ex 2^10 = 1024
        //                    // je veux obtenir 1024 avec 3
        //                    _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
        //                }
        //            }

        //            decimal _coeff = 1m;
        //            decimal prec = 0m;
        //            if (modeVirt.virtAlignPrec)
        //            {
        //                if (_nbNoAdd < pieces.Count)
        //                    prec = pieces[_nbNoAdd].Value;
        //            }

        //            for (int j = _nbNoAdd - 1; j >= 0; j--)
        //            {
        //                if (j < pieces.Count)
        //                {

        //                    if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //                    {
        //                        _coeff *= _coeffVirt;
        //                        var cand = pieces[j].Value / _coeff;
        //                        if (modeVirt.virtAlignPrec)
        //                        {
        //                            if (cand < prec)
        //                                cand = prec + EPSILON;
        //                        }

        //                        if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                        {
        //                            // quel serait le score s'il était coché
        //                            var vu = pieces[j].Value / coeffEnabled;
        //                            // en plus une petite marge
        //                            //  vu *= mode.coeffVirt; 
        //                            if (cand < vu)
        //                                cand = vu;
        //                        }
        //                        pieces[j].Value = cand;
        //                        // pieces[j].EffectMain = coeffEnabled < _coeff;
        //                    }
        //                    else if (modeVirt.forceCoeffVirt)
        //                        _coeff /= _coeffVirt;
        //                    prec = pieces[j].Value;
        //                }
        //            }
        //        }

        //    }
        //    else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            for (int i = 0; i < i0; i++)
        //            {
        //                decimal _coeff = 1m;
        //                decimal _base = pieces[i].Value;
        //                for (int j = i + 1; j < _count; j++)
        //                {
        //                    _coeff /= _coeffVirt;
        //                    virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
        //                }
        //            }
        //        }
        //    }
        //    else
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            decimal courant = pieces[0].Value;
        //            for (int i = 1; i < _count; i++)
        //            {
        //                if (pieces[i].Value <= _zero)
        //                {
        //                    courant /= _coeffVirt;
        //                    virt[i] = courant;
        //                }
        //                else
        //                    courant = pieces[i].Value;
        //            }
        //        }
        //    }

        //    decimal value = int.MaxValue;
        //    int ii = 0;
        //    if (modeVirt.noAdd)
        //    {
        //        //for (ii = 1; ii < count && ii < _count; ii++)
        //        //{
        //        //    var calc = virt[ii];
        //        //    if (calc > 0m)
        //        //        list[ii] = calc;
        //        //}
        //    }
        //    else
        //    {
        //        for (ii = 1; ii < count && ii < _count; ii++)
        //        {
        //            value = pieces[ii].Value;
        //            var calc = virt[ii];
        //            if (value < calc)
        //            {
        //                if (modeVirt.lissage || value <= _zero)
        //                {
        //                    if (value <= _zero)
        //                        nbAdd++;
        //                    value = calc;
        //                    pieces[ii].Value = value;
        //                }

        //            }
        //            else
        //                indexV = ii;
        //        }
        //        if (modeVirt.removeEpsilon)
        //        {
        //            // j'ai 5 virtuel alors que j'ai deux safe
        //            ///xx---
        //            int nb = 0;
        //            for (int i = indexV + 1; i < _count; i++)
        //            {
        //                nb++;
        //                if (nb <= safe)
        //                    continue;
        //                pieces[i].Value = 0m;
        //            }

        //        }
        //        if (mode.removeFirst)
        //        {
        //            for (int i = 0; i < nbAdd; i++)
        //            {
        //                pieces[i].Value = 0m;
        //            }
        //        }
        //    }

        //    //for (int i = 0; i < _list.Count && i < pieces.Count; i++)
        //    //{
        //    //    pieces[i].setValue(_list[i], main); 
        //    //    //if (main)
        //    //    //    pieces[i].setClassementVirtuel(_list[i]);
        //    //    //else
        //    //    //    pieces[i].setClassementVirtuel2(_list[i]);
        //    //}

        //    if (mode.deleteFirst)
        //    {
        //        for (int i = 0; i < nbAdd; i++)
        //        {
        //            pieces.RemoveAt(0);
        //        }
        //    }

        //    if (modeVirt.reSort || mode.removeFirst || modeVirt.noAdd)
        //    {
        //        //_list.Sort();
        //        //_list.Reverse();
        //        if (main)
        //            pieces.Sort(new PieceCmp());
        //        else
        //            pieces.Sort(new PieceCmp2());
        //    }



        //    if (modeVirt.noAdd)
        //        nbAdd = _nbNoAdd;
        //    //}
        //    return nbAdd;
        //}


        public DecimalPiece getMedianneLight(ConfMedianneVirt modeVirt, pieceExtendedMode main)
        {

            DecimalPiece ret0 = new DecimalPiece();
            DecimalPiece ret = ret0;
            try
            {
                var _zero = mode.zero;

                PieceExtended.Mode = main;
                //foreach (PieceExtended p in pieces)
                //    p.Mode = main;

                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = median;
                ret = ret0;


                int i0 = 0;
                int count = pieces.Count;


                ret = calcmedianneVirt(modeVirt);
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<IPieceAlbum>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }




            }
            finally
            {


            }

            return ret;
        }






        //public static DecimalIndex getMedianneLight(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, PieceExtended.mode main, bool combine)
        //{

        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {
        //        var _zero = mode.zero;


        //        foreach (PieceExtended p in pieces)
        //            p.Mode = main;

        //        var medianne = getMedianne_(pieces, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;
        //        ret = ret0;
        //        //if (pieces.Count == 1)
        //        //    return ret0;

        //        int i0 = 0;
        //        int count = pieces.Count;
        //        int nbAdd = buildVirtual(pieces, mode, modeVirt, main, combine, ref i0);
        //        //if (mode.combine && mode.simple)
        //        //{
        //        //    int i1 = 0;
        //        //    buildVirtual(pieces, mode, mode.Min, false, ref i1);
        //        //    foreach (var p in pieces)
        //        //    {
        //        //        p.setClassementVirtuelCombine();
        //        //    }
        //        //}
        //        ret = calcmedianneVirt(pieces, mode, modeVirt, main, nbAdd, System.Math.Min(i0, modeVirt.safe));
        //        if (mode.expEnabled != 0)
        //        {
        //            int _nb = pieces.Count<PieceExtended>(p => !p.Enabled);
        //            decimal _c = (decimal)_nb / (decimal)count;
        //            _c = Math.Pow(_c, mode.expEnabled);
        //            ret.d *= _c;
        //        }




        //    }
        //    finally
        //    {


        //    }

        //    return ret;
        //}

        private class PieceCmp0 : IComparer<IPieceAlbum>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(IPieceAlbum x, IPieceAlbum y)
            {
                int cmp = x.Classement.CompareTo(y.Classement); //   x.RapportClassement.CompareTo(y.RapportClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }


        //private class PieceCmp : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}

        //private class PieceCmp2 : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}

        //private class PieceCmp3 : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}




        //private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        //{
        //    var _list = new List<decimal>(list);
        //    int count = _list.Count;

        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        if (_list[count - i - 1] > conf.zero)
        //        {

        //            if (conf.removeLast == removeLast.non)
        //                break;
        //            _nbSupp++;
        //            if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                break;
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}


        private DecimalPiece calcmedianneVirt(ConfMedianneVirt confc)
        {
            int count = pieces.Count;
            var _list = new List<IPieceAlbum>();

            //1=> 1
            //2 =>3
            //3==>5
            int count1 = int.MaxValue;
            for (int i = 0; i < count && i < count1; i++)
            {
                var p = pieces[i];
                if (p.Classement.isZero() && count1 == int.MaxValue)
                {
                    var c = i;
                    count1 = 2 * i - 1;
                }

                _list.Add(p);
            }

            var classes = pieces.FindAll(p => !p.Empty);

            if (confc.oldAsZero)
                classes = pieces.FindAll(p => p.LastClassementRecent);



            int nbEnabled = classes.Count<IPieceAlbum>(p => p.Enabled);
            int nbDisabled = classes.Count<IPieceAlbum>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled);




            DecimalPiece ret = new DecimalPiece() { d = 0m, index = null }; // 0m; // decimal ret = int.MinValue;
            if (pieces.Count > 0)
                ret.index = pieces[0];
            int _nbSupp = 0;
            decimal coeffp = 1m;

            bool beginBorder = false;
            count1 = _list.Count;
            for (int i = 0; i < count1; i++)
            {
                int ilast = _list.Count - 1;
                var last = _list[ilast];
                if (i > 0)
                {
                    if (last.Empty)
                        _list.RemoveAt(ilast);
                    else
                        break;
                    ilast = _list.Count - 1;
                    if (ilast < 0)
                        break;
                    last = _list[ilast];
                    if (mode.puissance > 1m)
                    {
                        if (coeffp < 1e-15m)
                            coeffp = 1e-15m / (decimal)i;
                        else if (coeffp < 1e-12m)
                        {
                            coeffp = 1e-12m / ((decimal)i * i);
                            if (coeffp < 1e-15m)
                                coeffp = 1e-15m / (decimal)i;
                        }
                        else
                            coeffp /= mode.puissance;

                        if (coeffp < 1e-15m)
                            coeffp = 1e-15m / (decimal)i;
                        else if (coeffp < 1e-12m)
                        {
                            coeffp = 1e-12m / ((decimal)i * i);
                            if (coeffp < 1e-15m)
                                coeffp = 1e-15m / (decimal)i;
                        }

                        if (coeffp < 0)
                            coeffp = 0;
                    }
                }

                var aux = getMedianne_(_list, mode.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = last;
                }
                int offset = 0;
                if (count1 < count)
                    offset = count - count1;

                var coeff0 = 1 - ((decimal)i + offset) / (decimal)count; // (decimal)count - i / (decimal)count;
                if (mode.quasi > 1)
                    coeff0 = Math.Pow(coeff0, mode.quasi);

                decimal coeff = coeff0;
                if (coeff < coeffp)
                {
                }
                else
                {
                    coeff = coeffp;
                }





                if (coeff == 0m)
                    break;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = median;
                    ret.indexBorderEffect = last;
                }

                ret.indexBorderMin = last;
                var p = last;

                if (!p.Empty && (!confc.oldAsZero || p.LastClassementRecent))
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--;

                    if (!p.Enabled || !mode.removeEnabled || mode.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((mode.removeLast == removeLast.non || mode.removeLast == removeLast.unselected) && nbEnabled < 0)
                            break;

                        if (mode.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break;
                        }
                        _nbSupp++;
                    }
                }


            }


            return ret;
        }

        //private static DecimalIndex calcmedianneVirt(IList<PieceExtended> list, ConfMedianne conf, ConfMedianneVirt confc, bool main, int nbAdd, int nbDel)
        //{
        //    var _list = new List<PieceExtended>(list);
        //    var classes = _list.FindAll(p => p.VirtualClassement > conf.zero);

        //    if (confc.oldAsZero)
        //        classes = _list.FindAll(p => p.LastClassementRecent);

        //    int count = _list.Count;

        //    int nbEnabled = classes.Count<PieceExtended>(p => p.Enabled);
        //    int nbDisabled = classes.Count<PieceExtended>(p => !p.Enabled);
        //    int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    //int _nbSuppDisabled = 0;
        //    //int _nbSuppEnabled = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {
        //            //var d = _list[count - i];
        //            //if (d.Enabled)
        //            //    nbEnabled--;
        //            //else
        //            //    nbDisabled--;

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        ret.indexBorderMin = count - i - 1;
        //        var p = _list[count - i - 1];

        //        if (p.VirtualClassement > conf.zero && (!confc.oldAsZero || p.LastClassementRecent))
        //        {
        //            // je regarde si le morceau est désactivé
        //            // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
        //            if (p.Enabled)
        //                nbEnabled--;
        //            else
        //                nbDisabled--;
        //            nbdispo--;

        //            if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
        //            {
        //                //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
        //                //if (priseEncompte)
        //                //{
        //                if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected) && nbEnabled < 0)
        //                    break;

        //                if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
        //                {
        //                    if (nbdispo < 0)
        //                        break;
        //                }

        //                _nbSupp++;
        //                if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                    break;
        //                // }


        //            }
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}



        //private static decimal getMedianne_(IList<PieceExtended> list, bool main, decimal coeffMedianne)
        //{
        //    var l = new List<decimal>();
        //    foreach (PieceExtended p in list)
        //    {
        //        if (main)
        //            l.Add(p.VirtualClassement); 
        //        else
        //            l.Add(p.VirtualClassement2); 
        //    }

        //    return CalcMedianne.getMedianneDec(l, coeffMedianne); 
        //}

        //private static decimal getMedianne_(IList<Piece> list, bool main, decimal coeffMedianne)
        //{
        //    var l = new List<decimal>();
        //    foreach (Piece p in list)
        //    {
        //        if (main)
        //            l.Add(p.VirtualClassement);
        //        else
        //            l.Add(p.VirtualClassement2);
        //    }

        //    return CalcMedianne.getMedianneDec(l, coeffMedianne);
        //}


        private static decimal getMedianne_(IList<IPieceAlbum> list, decimal coeffMedianne)
        {

            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1 || coeffMedianne == 1)
            {
                median = list[0];
                return median.Value;
            }

            if (coeffMedianne == 1)
            {
                median = list[count - 1];
                return median.Value;
            }

            var medianne = coeffMedianne * (count - 1);

            var index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].Value;

            median = list[index];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
            {
                return val0;
            }
            median = list[i1];
            var val1 = list[i1].Value;
            return val1;

            //if (Math.Abs(medianne - i1) < PRECISION)
            //{
            //    median = list[i1];
            //    return val1;
            //}
            //if (val1 < PRECISION)
            //{
            //    median = list[i1];
            //    return val1;
            //}
            //var dx = medianne - index;


            //// var ret = val0 + pente * dx;


            //// moyenne avec calcul de log
            //var log0 = Math.Log(val0 + EPSILON_LOG);
            //var log1 = Math.Log(val1 + EPSILON_LOG);
            //// pente = log1 - log0;
            //var log = log0 + (log1 - log0) * dx;
            //return Math.Exp(log) - EPSILON_LOG;


        }

    }
}
]]></content>
  </file>
</db>
