<db path="C:\bernard\db2\">
  <file path="buro\buroSimple\Walpaper.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using buroSimpleLib;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using System.Threading;
using System.Diagnostics;
using System.Windows.Forms;
using Microsoft.Win32;
using System.Drawing.Drawing2D;

namespace buroSimple
{
    class Walpaper
    {
        int HAUTEUR;
        int LARGEUR;
        const string TMP_FILE = @"C:\Temp\wp.bmp";
        const string TMP_FILE1 = @"C:\Temp\wp1.bmp";
        const string TMP_FILE2 = @"C:\Temp\wp2.bmp";
        const string INDEX_FILE = @"C:\Temp\wp.index.txt";
        const string TMP_LOADED = @"C:\Temp\Loaded";


        public double delay = 30;
        public bool unique = false;
        public bool sortBySize = false;
        public bool uniqueName = false;
        public bool reverse = false;
        public bool fullscreen = false;

        private bool GO;
        public void go()
        {
            GO = true;
            DirectoryInfo loaded = new DirectoryInfo(TMP_LOADED);
            if (!loaded.Exists)
                loaded.Create();


            SystemEvents.PowerModeChanged += new PowerModeChangedEventHandler(SystemEvents_PowerModeChanged);



            HAUTEUR = 1080;
            LARGEUR = 1920;
            var list = new List<FileDto>();
            using (StreamReader sr = new StreamReader(@"C:\Temp\buro1.txt"))
            {
                string line = "";
                while ((line = sr.ReadLine()) != null)
                {
                    if (string.IsNullOrEmpty(line))
                        continue;

                    try
                    {
                        FileDto fd = FileDto.FromLine(line); //  new FileDto() { Path = tab[0], Size = Convert.ToInt64(tab[1]) };
                        if (fd != null)
                            list.Add(fd);
                    }
                    catch
                    {
                    }

                }
            }

            list.Sort((x, y) =>
            {
                int cmp = 0;
                if (sortBySize)
                {
                    cmp = x.Size.CompareTo(y.Size);
                    if (cmp != 0)
                        return cmp;
                    cmp = x.Pixels().CompareTo(y.Pixels());
                }
                else
                {
                    cmp = x.Pixels().CompareTo(y.Pixels());
                    if (cmp != 0)
                        return cmp;
                    cmp = x.Size.CompareTo(y.Size);
                }

                if (cmp != 0)
                    return cmp;
                return x.Path.CompareTo(y.Path);
            });

            if (reverse)
                list.Reverse();

            int count = list.Count;

            string path0 = "";
            int index0 = 0;
            if (File.Exists(INDEX_FILE))
            {
                path0 = File.ReadAllText(INDEX_FILE).Trim();
            }

            if (!string.IsNullOrEmpty(path0))
            {
                for (int i = 0; i < count; i++)
                {
                    if (list[i].Path == path0)
                    {
                        index0 = i;
                        break;
                    }
                }
            }

            HashSet<string> hs = new HashSet<string>();
            int pixels = -1;
            long size = -1;
            int nbLoaded = 0;
            for (int i = index0 + 1; i < count; i++)
            {
                if (!GO)
                {
                    Thread.Sleep(1000);
                }
                FileDto f = list[i];
                Console.WriteLine("candidat " + f);
                var fpixels = f.Pixels();
                if (f.Size > size || fpixels > pixels)
                {
                    hs.Clear();
                    size = f.Size;
                    if (fpixels > pixels)
                        pixels = fpixels;
                    foreach (FileInfo fl in loaded.GetFiles())
                    {
                        fl.Delete();
                    }
                    nbLoaded = 0;
                }
                else
                {
                    if (unique)
                        continue;
                }
                string fileName = Path.GetFileName(f.Path);
                if (hs.Contains(fileName))
                    continue;
                try
                {
                    Image img = null;
                    if (fullscreen)
                        img = createFileFs(f);
                    else
                        img = createFile(f);
                    if (img != null)
                    {
                        bool ok = true;
                        foreach (FileInfo fl in loaded.GetFiles())
                        {
                            if (ImageUtil.AreIdentical(img, fl.FullName))
                            {
                                ok = false;
                                break;
                            }
                        }
                        img.Dispose();

                        if (ok)
                        {
                            WinAPI.BmpLoad(TMP_FILE);
                            nbLoaded++;
                            File.Copy(TMP_FILE, loaded.FullName + "\\" + nbLoaded + ".bmp", true);
                            File.WriteAllText(INDEX_FILE, f.Path);
                            Thread.Sleep((int)(delay * 1000.0));
                            if (uniqueName)
                                hs.Add(fileName);
                        }
                        else
                        {
                            Console.WriteLine("Identique " + f);
                            continue;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Blank " + f);
                        continue;
                    }

                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            }
        }

        void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)
        {
            Console.WriteLine("SystemEvents_PowerModeChanged:" + e.Mode.ToString());
            if (e.Mode == PowerModes.Resume)
                GO = true;
            else GO = false;
        }

        private void paramGr(Graphics graphics)
        {
            graphics.CompositingMode = CompositingMode.SourceCopy;
            graphics.CompositingQuality = CompositingQuality.HighSpeed;
            graphics.InterpolationMode = InterpolationMode.Low;
            graphics.SmoothingMode = SmoothingMode.None;
            graphics.PixelOffsetMode = PixelOffsetMode.None;
        }

        private Image createFileFs(FileDto f)
        {
            Image img = Image.FromFile(f.Path); 


            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}={1}x{2} {3}", largeur0 * hauteur0, largeur0, hauteur0, f.HumanReadableSize);

            double r0 = (double)HAUTEUR / (double)LARGEUR;
            double r = (double)hauteur0 / (double)largeur0;

            //facteur d'augmentation
            int scale = 1;

            //1. on teste blank


            int largeurTrame;
            int hauteurTrame;

            Bitmap trame;
            img.Save(TMP_FILE1, ImageFormat.Bmp);
            var imgVerif = ImageUtil.Scan(TMP_FILE1);
            if (imgVerif == null)
            {
                img.Dispose();
                return null;
            }
           
            int l = largeur0;
            int h = hauteur0;
            //int l0 = l;
            //int h0 = h;
            //Image currentImage = img;
            //while (true)
            //{
            //    l *= 2;
            //    if (l > LARGEUR)
            //        break;
            //    h *= 2;
            //    if (h > HAUTEUR)
            //        break;
            //    l0 = l;
            //    h0 = h;
            //}

            if (r > r0)
                scale = HAUTEUR / hauteur0;
            else
                scale = LARGEUR / largeur0;

            l *= scale;
            h *= scale;

            //l = l0;
            //h = h0;

            var trameInter = new Bitmap(l, h);
            Graphics g = null;
            try
            {
                trameInter = new Bitmap(l, h, PixelFormat.Format64bppArgb);
                g = Graphics.FromImage(trameInter);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                trameInter = new Bitmap(l, h);
            }
           // g = Graphics.FromImage(img);
            paramGr(g);
            Rectangle rect = new Rectangle(0, 0, l, h);
            g.DrawImageUnscaledAndClipped(img, rect);
            ////int _xrec = (int)((LARGEUR - l) / 2.0);
            ////int _yrec = (int)((HAUTEUR - h) / 2.0);
            ////Rectangle _centré = new Rectangle(_xrec, _yrec, l, h);
            //Rectangle rect = new Rectangle(0, 0, l, h);
            //// g.DrawImageUnscaledAndClipped(img, _centré);
            //g.DrawImageUnscaledAndClipped(img, rect);
            ////g.DrawImage(img, rect, 0, 0, l, h, GraphicsUnit.Pixel);
            ////    g.DrawImage(img, rect); 

            ////  trameInter.Dispose();
            //// img.Dispose();


            //// return Image.FromFile(TMP_FILE);


            trameInter.Save(TMP_FILE2, ImageFormat.Bmp);
           // return trameInter;

            // g.Dispose();

            if (r > r0)
            {
                // image pas assez large --> ajout largeur



                hauteurTrame = HAUTEUR;
                largeurTrame = Convert.ToInt32(LARGEUR * r0 / r); //   Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = LARGEUR;
                hauteurTrame = Convert.ToInt32(HAUTEUR * r / r0);
            }

            trame = new Bitmap(LARGEUR, HAUTEUR, PixelFormat.Format64bppArgb);
            Graphics graphics = Graphics.FromImage(trame);


            paramGr(graphics);




            int xrec = (int)((LARGEUR - largeurTrame) / 2.0);
            int yrec = (int)((HAUTEUR - hauteurTrame) / 2.0);



            // var abort = new Image.GetThumbnailImageAbort(ThumbnailCallback);
            //var thumbnail = img.GetThumbnailImage(largeurTrame , hauteurTrame, abort, IntPtr.Zero);

            Rectangle centré = new Rectangle(xrec, yrec, largeurTrame, hauteurTrame);
            // graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);
            // Rectangle all = new Rectangle(0,0,LARGEUR, HAUTEUR); 
            //graphics.DrawImage(img, centré);
            graphics.DrawImageUnscaledAndClipped(trameInter, centré);
            trameInter.Dispose();
            //thumbnail.Save(TMP_FILE, ImageFormat.Bmp);

            //thumbnail.Dispose();
            // image.Dispose();

            trame.Save(TMP_FILE, ImageFormat.Bmp);
            trame.Dispose();
            // img.Dispose();
            graphics.Dispose();

            return Image.FromFile(TMP_FILE);

        }

        public bool ThumbnailCallback()
        {
            return false;
        }

        private Image createFile(FileDto f)
        {
            Image img = Image.FromFile(f.Path);

            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}={1}x{2} {3}", largeur0 * hauteur0, largeur0, hauteur0, f.HumanReadableSize);

            double r0 = (double)HAUTEUR / (double)LARGEUR;

            int largeurTrame;
            int hauteurTrame;

            double r = (double)hauteur0 / (double)largeur0;


            Bitmap trame;


            if (r > r0)
            {
                // image pas assez large --> ajout largeur

                hauteurTrame = hauteur0;
                largeurTrame = Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = largeur0;
                hauteurTrame = Convert.ToInt32((double)largeur0 * (double)r0);
            }

            trame = new Bitmap(largeurTrame, hauteurTrame);
            Graphics graphics = Graphics.FromImage(trame);

           paramGr(graphics); 


            int xrec = (largeurTrame - largeur0) / 2;
            int yrec = (hauteurTrame - hauteur0) / 2;
            Rectangle centré = new Rectangle(xrec, yrec, largeur0, hauteur0);
            graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);


            trame.Save(TMP_FILE, ImageFormat.Bmp);
            trame.Dispose();
            img.Dispose();
            graphics.Dispose();

            // verif
            var imgVerif = ImageUtil.Scan(TMP_FILE);
            return imgVerif;

            //using (Bitmap fs = new Bitmap(LARGEUR, HAUTEUR))
            //{
            //    Image i0 = null;
            //    Image i1 = null;
            //    using (var g = Graphics.FromImage(fs))
            //    {

            //        if (File.Exists(TMP_FILE))
            //        {
            //            i0 = Image.FromFile(TMP_FILE);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }

            //        if (File.Exists(TMP_FILE1))
            //        {
            //            i1 = Image.FromFile(TMP_FILE1);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }
            //    }
            //    fs.Save(TMP_FILE, ImageFormat.Bmp);
            //    if (i0 != null)
            //        i0.Dispose();
            //    if (i1 != null)
            //        i1.Dispose();
            //}
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimpleLib\ImageUtil.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;

namespace buroSimpleLib
{
    public static class ImageUtil
    {
        public static unsafe Image Scan(string file)
        {
            int LEVEL_MIN = 0;
            Bitmap b = null;
            DateTime debut = DateTime.Now;
            try
            {
                b = new Bitmap(file);//note this has several overloads, including a path to an image
            }

            catch
            {
                ConsoleLogger.log("Impossible de créer un Bitmap {0}", file);
                try
                {
                    Image i = Image.FromFile(file);
                    return i;
                }
                catch
                {
                    return null;
                }
            }
            DateTime debutScan = DateTime.Now;
            BitmapData bData = b.LockBits(new Rectangle(0, 0, b.Width, b.Height), ImageLockMode.ReadOnly, b.PixelFormat);

            var Depth = Bitmap.GetPixelFormatSize(b.PixelFormat);

            //  byte bitsPerPixel = Bitmap.GetBitsPerPixel(bData.PixelFormat);

            /*This time we convert the IntPtr to a ptr*/
            byte* scan0 = (byte*)bData.Scan0.ToPointer();
            bool ok = false;
            for (int i = 0; i < bData.Height; ++i)
            {
                if (ok)
                    break;
                for (int j = 0; j < bData.Width; ++j)
                {
                    byte* data = scan0 + i * bData.Stride + j * Depth / 8;

                    //data is a pointer to the first byte of the 3-byte color data
                    //data[0] = blueComponent;
                    //data[1] = greenComponent;
                    //data[2] = redComponent;
                    if (data[0] > LEVEL_MIN || data[1] > LEVEL_MIN || data[2] > LEVEL_MIN)
                    {
                        ok = true;
                        break;
                    }
                }
            }

            b.UnlockBits(bData);

            var ts = (DateTime.Now - debut).TotalMilliseconds.ToString("0");
            var tsLoad = (debutScan - debut).TotalMilliseconds.ToString("0");

            var tsScan = (DateTime.Now - debutScan).TotalMilliseconds.ToString("0");
            if (!ok)
            {
                ConsoleLogger.log("Blank {0} {1} ms", file, tsScan);
                b.Dispose();
                return null;
            }
            else if (ts.Length >= 3)
                ConsoleLogger.log("load:{0}ms scan:{1}ms total:{2} ms", tsLoad, tsScan, ts);
            return b;
        }

        public static bool AreIdentical(Image b1, string file2)
        {
            return !AreDifferent(b1, file2);
        }

        public static unsafe bool AreDifferent(Image img, string file2)
        {


            Bitmap b2 = null;
            Bitmap b1 = null;


            DateTime debut = DateTime.Now;
            DateTime debutScan = DateTime.Now;
            bool dif = false;
            try
            {
                try
                {
                    //b1 = new Bitmap(file1);//note this has several overloads, including a path to an image
                    b2 = new Bitmap(file2);
                    if (img is Bitmap)
                        b1 = img as Bitmap;
                    else
                        b1 = new Bitmap(img);
                    if (b1.Width != b2.Width)
                        dif = true;
                    else if (b1.Height != b2.Height)
                        dif = true;
                }

                catch
                {
                    dif = true;
                }
                if (!dif)
                {
                    debutScan = DateTime.Now;
                    BitmapData bData1 = b1.LockBits(new Rectangle(0, 0, b1.Width, b1.Height), ImageLockMode.ReadOnly, b1.PixelFormat);
                    BitmapData bData2 = b2.LockBits(new Rectangle(0, 0, b2.Width, b2.Height), ImageLockMode.ReadOnly, b2.PixelFormat);

                    var Depth = Bitmap.GetPixelFormatSize(b1.PixelFormat);

                    //  byte bitsPerPixel = Bitmap.GetBitsPerPixel(bData.PixelFormat);

                    /*This time we convert the IntPtr to a ptr*/
                    byte* scan01 = (byte*)bData1.Scan0.ToPointer();
                    byte* scan02 = (byte*)bData2.Scan0.ToPointer();

                    for (int i = 0; i < bData1.Height; ++i)
                    {
                        if (dif)
                            break;
                        for (int j = 0; j < bData1.Width; ++j)
                        {
                            if (dif)
                                break;
                            byte* data1 = scan01 + i * bData1.Stride + j * Depth / 8;
                            byte* data2 = scan02 + i * bData2.Stride + j * Depth / 8;

                            //data is a pointer to the first byte of the 3-byte color data
                            //data[0] = blueComponent;
                            //data[1] = greenComponent;
                            //data[2] = redComponent;

                            for (int c = 0; c < 3; c++)
                            {
                                if (data1[c] != data2[c])
                                {
                                    dif = true;
                                    break;
                                }
                            }

                        }
                    }

                    b1.UnlockBits(bData1);
                    b2.UnlockBits(bData2);
                }
            }
            finally
            {
                if (b2 != null)
                    b2.Dispose();
            }

            var ts = (DateTime.Now - debut).TotalMilliseconds.ToString("0");
            var tsLoad = (debutScan - debut).TotalMilliseconds.ToString("0");

            var tsScan = (DateTime.Now - debutScan).TotalMilliseconds.ToString("0");
            if (!dif)
            {
                ConsoleLogger.log("equal {0} {1} ms", file2, tsScan);
            }
            else if (ts.Length >= 3)
                ConsoleLogger.log("load:{0}ms scan:{1}ms total:{2} ms", tsLoad, tsScan, ts);


            return dif;
        }

        public static Image Scale(Image source, int scale)
        {
            Bitmap src = source as Bitmap;
            if (src == null)
                src = new Bitmap(source);


            int w = src.Width;
            int h = src.Height;

            int w2 = w * scale;
            int h2 = h * scale;
            Bitmap dest = new Bitmap(w2,h2, src.PixelFormat); 

            var bmSrc = new LockBitmap(src);
            var bmDest = new LockBitmap(dest);

            bmSrc.LockBits();
            bmDest.LockBits();

            for (int i = 0; i < w; i++)
            {
                for (int j = 0; j < h; j++)
                {
                    Color c = bmSrc.GetPixel(i, j);
                    int x0 = scale * i;
                    int x1 = x0 + scale;

                    int y0 = scale * j;
                    int y1 = y0 + scale;

                    for (int x = x0; x < x1; x++)
                    {
                        for (int y = y0; y < y1; y++)
                        {
                            bmDest.SetPixel(x, y, c);
                        }
                    }

                }
            }
            bmDest.UnlockBits();
            bmSrc.UnlockBits();

            return dest;
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimpleLib\LockBitmap.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace buroSimpleLib
{
   public class LockBitmap
{
    Bitmap source = null;
    IntPtr Iptr = IntPtr.Zero;
    BitmapData bitmapData = null;
 
    public byte[] Pixels { get; set; }
    public int Depth { get; private set; }
    public int Width { get; private set; }
    public int Height { get; private set; }
 
    public LockBitmap(Bitmap source)
    {
        this.source = source;
    }
 
    /// <summary>
    /// Lock bitmap data
    /// </summary>
    public void LockBits()
    {
        try
        {
            // Get width and height of bitmap
            Width = source.Width;
            Height = source.Height;
 
            // get total locked pixels count
            int PixelCount = Width * Height;
 
            // Create rectangle to lock
            Rectangle rect = new Rectangle(0, 0, Width, Height);
 
            // get source bitmap pixel format size
            Depth = System.Drawing.Bitmap.GetPixelFormatSize(source.PixelFormat);
 
            // Check if bpp (Bits Per Pixel) is 8, 24, or 32
            if (Depth != 8 && Depth != 24 && Depth != 32)
            {
                throw new ArgumentException("Only 8, 24 and 32 bpp images are supported.");
            }
 
            // Lock bitmap and return bitmap data
            bitmapData = source.LockBits(rect, ImageLockMode.ReadWrite, 
                                         source.PixelFormat);
 
            // create byte array to copy pixel values
            int step = Depth / 8;
            Pixels = new byte[PixelCount * step];
            Iptr = bitmapData.Scan0;
 
            // Copy data from pointer to array
            Marshal.Copy(Iptr, Pixels, 0, Pixels.Length);
        }
        catch (Exception ex)
        {
            throw;
        }
    }
 
    /// <summary>
    /// Unlock bitmap data
    /// </summary>
    public void UnlockBits()
    {
        try
        {
            // Copy data from byte array to pointer
            Marshal.Copy(Pixels, 0, Iptr, Pixels.Length);
 
            // Unlock bitmap data
            source.UnlockBits(bitmapData);
        }
        catch (Exception ex)
        {
            throw ex;
        }
    }
 
    /// <summary>
    /// Get the color of the specified pixel
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    public Color GetPixel(int x, int y)
    {
        Color clr = Color.Empty;
 
        // Get color components count
        int cCount = Depth / 8;
 
        // Get start index of the specified pixel
        int i = ((y * Width) + x) * cCount;
 
        if (i > Pixels.Length - cCount)
            throw new IndexOutOfRangeException();
 
        if (Depth == 32) // For 32 bpp get Red, Green, Blue and Alpha
        {
            byte b = Pixels[i];
            byte g = Pixels[i + 1];
            byte r = Pixels[i + 2];
            byte a = Pixels[i + 3]; // a
            clr = Color.FromArgb(a, r, g, b);
        }
        if (Depth == 24) // For 24 bpp get Red, Green and Blue
        {
            byte b = Pixels[i];
            byte g = Pixels[i + 1];
            byte r = Pixels[i + 2];
            clr = Color.FromArgb(r, g, b);
        }
        if (Depth == 8)
        // For 8 bpp get color value (Red, Green and Blue values are the same)
        {
            byte c = Pixels[i];
            clr = Color.FromArgb(c, c, c);
        }
        return clr;
    }
 
    /// <summary>
    /// Set the color of the specified pixel
    /// </summary>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <param name="color"></param>
    public void SetPixel(int x, int y, Color color)
    {
        // Get color components count
        int cCount = Depth / 8;
 
        // Get start index of the specified pixel
        int i = ((y * Width) + x) * cCount;
 
        if (Depth == 32) // For 32 bpp set Red, Green, Blue and Alpha
        {
            Pixels[i] = color.B;
            Pixels[i + 1] = color.G;
            Pixels[i + 2] = color.R;
            Pixels[i + 3] = color.A;
        }
        if (Depth == 24) // For 24 bpp set Red, Green and Blue
        {
            Pixels[i] = color.B;
            Pixels[i + 1] = color.G;
            Pixels[i + 2] = color.R;
        }
        if (Depth == 8)
        // For 8 bpp set color value (Red, Green and Blue values are the same)
        {
            Pixels[i] = color.B;
        }
    }
}
}
]]></content>
  </file>
  <file path="buro\testImages\Program.cs">
    <content><![CDATA[using buroSimpleLib;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace testImages
{
    class Program
    {
        static void Main(string[] args)
        {
            // Image png = Image.FromFile(@"C:\temp\2x20.png"); 
            Image png = Image.FromFile(@"C:\temp\png.png");
            Image png2 = ImageUtil.Scale(png, 2);
            png2.Save(@"C:\temp\png2.bmp", ImageFormat.Bmp);
        }
    }
}
]]></content>
  </file>
  <file path="buro\testImages\Properties\AssemblyInfo.cs">
    <content><![CDATA[using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("testImages")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("testImages")]
[assembly: AssemblyCopyright("Copyright ©  2019")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d1d8f637-998f-42e3-846c-38de2d0c06b3")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
]]></content>
  </file>
</db>
