<db path="C:\Bernard\db1\tmp\podcast\pdb.podcast">
  <file path="\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    class AutoBuilder : IComparable<AutoBuilder>, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private IBuilderSource source; public IBuilderSource Source { get { return source; } }

        private LimitItemBase client;
        public LimitItemBase Client { get { return client; } }
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;

        public Memory Mem { get { return mem0; } }

        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(sub, this);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(IBuilderSource source)
        {
            this.source = source;
            source.addBorderObs(this);
        }
        private static AutoBuilder main;
        public static void build(XmlNode xAuto, IBuilderSource source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return ;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client; 

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    {
                        //if (!exist)
                        //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                        tw.Write(DateTime.Now); tw.Write(SEP);
                        tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                        tw.Write(d.ToString("0.###")); tw.Write(SEP);
                        tw.Write(org.ToString("0.###")); tw.Write(SEP);
                        tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(atomicMode); tw.Write(SEP);
                        tw.Write(state); tw.Write(SEP);
                        for (int i = 0; i < imax; i++)
                        {
                            if (i > 0)
                            {
                                tw.WriteLine();
                                for (int j = 0; j < 11; j++)
                                    tw.Write(SEP);
                            }
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].track);
                            tw.Write(SEP);
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].item);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].track);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].item);
                            tw.Write(SEP);
                        }
                        tw.WriteLine();
                    }
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            state = builderstate.none;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init()
        {
            if (list.Count == 0)
                return;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;
            doc = new XmlDocument();
            doc.PreserveWhitespace = true;
            doc.Load(f.FullName);
            xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                builder.setValueOrg();
                if (builder.ToSave())
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check2();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                AutoBuilder builder = null;
                if (!started)
                {
                    started = true;
                    foreach (AutoBuilder b in list)
                        b.total = b.source.getTotalSize();
                }
                // application de la précédente modif
                builder = list[index];
                if (builder.state > builderstate.none)
                {
                    builder.makeEmpreinteNonSequence();
                    decrementIndex();
                }
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    builder = list[i];
                    bool cango = false;
                    bool _cont = false;
                    while (true)
                    {
                        if (i == index || _cont)
                        {
                            cango = builder.check();
                            index = i;
                            main = builder;
                            _cont = false;
                            break;
                        }
                        else
                            cango = builder.checkWithoutModify();
                        if (builder.state == builderstate.none)
                            _cont = true;
                        else
                            break;
                    }
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (i == index)
                    {
                        if (builder.newv != builder.org)
                        {
                            _modifFile = true;
                        }
                        else
                        {
                            //index--;
                            //if (index < 0)
                            //    index = list.Count - 1;
                        }
                    }
                    if (_modifFile)
                        break;
                }
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                    _cango = false;
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.log.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        private bool check()
        {
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.none)
                reset();
            else if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
                else
                {
                    mustUpdate = false;
                    canGo = true;
                    org = newv;
                    return true;
                }
            }
            if (Conf.AutoSequence || total < 0)
                total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
            if (state == builderstate.none)
                delta0 = delta;
            state = builderstate.enCours;
            lastd = d;
            d = 0;
            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return true;
            string attTarget = conf.type.ToString();
            var att = xml.Attributes[attTarget];
            if (att == null)
                return true;
            org = Convert.ToDouble(att.Value);
            newv = org;
            try
            {
                if (delta * delta0 < 0)
                {
                    if (atomicMode < 0)
                    {
                        atomicMode = 0;
                        //if (minMem == null)
                        //    minMem = new Memory(mem0);
                        //if (maxMem == null)
                        //    maxMem = new Memory(mem0);
                        //if (minMem.suppressions.Count == 0)
                        //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
                        //if (maxMem.ajouts.Count == 0)
                        //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
                    }
                }
                bool cancelSameConf = false;
                bool cancelNb = false;
                if (atomicMode >= 0)
                {
                    atomicMode++;
                    if (Math.Abs(dmin - delta) < EPSILON)
                        sameConfiguration++;
                    else if (Math.Abs(dmax - delta) < EPSILON)
                        sameConfiguration++;
                    else
                        sameConfiguration = 0;
                    if (sameConfiguration > conf.idem)
                        cancelSameConf = true;
                    if (atomicMode > conf.cloop)
                        cancelNb = true;
                }
                if (delta >= 0)
                {
                    if (mem0.suppressions.Count > 0)
                        minMem = new Memory(mem0);
                    if (delta < conf.write)
                        canGo = true;
                    //  lastGoodLevel = org;
                    //if (maxMem != null && minMem != null)
                    //{
                    if (atomicMode > 0)
                    {
                        if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
                        {
                            log("abandon recherche cartésienne cause idem");
                            state = builderstate.stable;
                            return true;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            state = builderstate.stable;
                            return true;
                        }
                        //if (Math.Abs(dmin - delta) < 0.01)
                        //    dminAlready = true;
                        //else
                        //    dminAlready = false;
                        if (maxMem != null && minMem != null)
                        {
                            if (minMem.suppressions.Count == maxMem.ajouts.Count)
                            {
                                bool identique = true;
                                for (int i = 0; i < minMem.suppressions.Count; i++)
                                {
                                    if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                    {
                                        identique = false;
                                        break;
                                    }
                                }
                                if (identique)
                                {
                                    if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
                                    {
                                        mustUpdate = false;
                                        log("abandon recherche cartésienne cause cycle");
                                        state = builderstate.stable;
                                        _empreinte = newEmpreinte;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    cmin = org;
                    dmin = delta;
                    // lastGoodDelta = (int)delta;
                    lastTotal = (int)total;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        //if (atomicMode > conf.cloop)
                        //{
                        //    mustUpdate = false;
                        //    log("abandon recherche cartésienne cause cloop");
                        //    state = builderstate.stable;
                        //    _empreinte = newEmpreinte;
                        //    return true;
                        //}
                        //if (dminAlready && dmaxAlready)
                        //{
                        //    mustUpdate = false;
                        //    Program.log.log("abandon recherche cartésienne cause cycle");
                        //    return true;
                        //}
                        d = 0.5 * (cmax - cmin);
                    }
                    else
                    {
                        double _d = int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmax - cmin;
                        double aux = int.MaxValue;
                        // double aux2 = int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - level.d) * level.inf;
                            if (aux > d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {

                            if (org > conf.max)
                                d = conf.max - org;
                            else
                            {
                                d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 < d)
                        //    d = aux2;

                        if (d > _d)
                            d = _d;
                    }
                }
                else if (delta < 0)
                {
                    if (mem0.ajouts.Count > 0)
                        maxMem = new Memory(mem0);
                    mustUpdate = true;
                    canGo = false;
                    //if (maxMem != null && minMem != null)
                    //{
                    //    if (atomicMode < 0)
                    //        atomicMode = 0;
                    //    atomicMode++;
                    //}
                    cmax = org;
                    dmax = delta;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        bool identique = false;
                        if (minMem != null && maxMem != null
                            && maxMem.ajouts.Count == minMem.suppressions.Count)
                        {
                            identique = true;
                            for (int i = 0; i < minMem.suppressions.Count; i++)
                            {
                                if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                {
                                    identique = false;
                                    break;
                                }
                            }
                        }
                        if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
                        {
                            log("retour derniere bonne valeur cause idem");
                            d = cmin - cmax;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            d = cmin - cmax;
                        }
                        else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
                        {
                            log("retour derniere bonne valeur cause cycle");
                            d = cmin - cmax;
                        }
                        //else if (atomicMode > conf.cloop)
                        //{                      
                        //    log("abandon recherche cartésienne cause cloop");
                        //    d = cmin - cmax;
                        //}
                        else
                            d = 0.5 * (cmin - cmax);
                    }
                    else
                    {

                        double _d = -int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmin - cmax;
                        double aux = -int.MaxValue;
                        // double aux2 = -int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - conf.delta + level.d) * level.sup;
                            if (aux < d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {
                            if (org < conf.min)
                                d = (conf.min - org);
                            else
                            {
                                d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 > d)
                        //    d = aux2;

                        if (d < _d)
                            d = _d;
                    }
                    //d = (delta - conf.delta) * conf.sup;
                    //if (org <= lastGoodLevel)
                    //{
                    //    lastGoodLevel = -1;
                    //    lastGoodDelta = -1;
                    //    lastTotal = -1;
                    //}
                }
                if (Math.Abs(d) < 0.00000001)
                {
                    mustUpdate = false;
                    // unCart();
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                //if (dejaVu)
                //    Program.log.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
                log("correction {0}", d);
                newv = org + d;
                if (newv <= 0)
                    newv = 0;
                if (conf.coeff > 0)
                {
                    if (newv > conf.max)
                        newv = conf.max;
                    else if (newv < conf.min)
                        newv = conf.min;
                }
                newv = Math.Round(newv, 8);
                log(" valeur {0} --> {1}", org, newv);
                att.Value = newv.ToString();
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
                string strDate = "";
                var attD = xml.Attributes["date"];
                if (attD != null)
                    strDate = attD.Value;
                bool exist = File.Exists(file);
                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private bool check2()
        {
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (choose != null)
                    choose.makePertinent();
            }
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            choose = null;
            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }

                total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                log("delta {0}", delta);
                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;
                if (up && delta < conf.delta)
                {
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                mustUpdate = true;
                double dt = double.MaxValue;
                choose = null;
                foreach (AutoBuilderItem item in items)
                {
                    item.setTension(up);
                }
                foreach (AutoBuilderItem item in items)
                {
                    double aux = double.MaxValue;

                    if (conf.selectFix)
                        aux = item.Tension;
                    else
                        aux = item.Dt;
                    if (conf.selectAbs)
                        aux = Math.Abs(aux); 

                    TrackBorderItem tb = up ? item.Rejected : item.Selected;
                    if (tb == null || tb.Virtual)
                    {
                        if (Conf.BorderGranSlam)
                        {
                            choose = null;
                            break;
                        }
                        if (!Conf.BorderIdem)
                            continue;
                    }

                    if (aux < dt)
                    {
                        dt = aux;
                        newv = item.NewV;
                        choose = item;

                    }
                }
                if (choose == null)
                {
                    dt = double.MaxValue;
                    foreach (AutoBuilderItem item in items)
                    {
                        double aux = double.MaxValue;
                        //if (conf.selectFix)
                        aux = item.Tension;
                        //else
                        //    aux = item.Dt;
                        if (aux < dt)
                        {
                            dt = aux;
                            newv = item.NewV;
                            choose = item;
                        }
                    }
                }
                else
                    log("REEL!!!!");

                org = choose.Org;



                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                    var nextTrack = choose.Rejected.candidat;
                    var size = Stat.getSizeinMo(nextTrack);
                    if (delta < size)
                    {
                        state = builderstate.stable;
                        return true;
                    }

                }
                else
                {
                }
                choose.save();
                Program.log.log("===> " + choose.ToString());
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    bool exist = File.Exists(file);
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            return string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9})", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax);
        }
        private void log()
        {
            Program.log.log("{0} {1}", name, sb.ToString());
            Program.log.log("{0} total:{1}", name, total.ToString("0.###"));
            Program.log.log("{0} delta {1}", name, delta.ToString("0.###"));
            Program.log.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            Program.log.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            Program.log.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            Program.log.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                log(" valeur {0} --> {1}", org, newv);
                //    }
                //}
            }
            else Program.log.log("valeur non modifiée {0}", org);
            Program.log.log("\r\n");
            Program.log.log("\r\n");
            foreach (AutoBuilder builder in list)
            {
                builder.log(builder.ToString());
            }
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return; 
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }
    }
}
]]></content>
  </file>
  <file path="\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;

namespace pdb.podcast.Auto
{
    class AutoBuilderItem : IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        public double NewV { get { return newv; } }
        internal TrackBorderItem Rejected { get { return _rejected; } }
        internal TrackBorderItem Selected { get { return _selected; } }
        internal void makePertinent() { pertinentOrg = org; }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlElement xml;
        double dd;
        double d;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        public AutoBuilderItem(pdb.podcast.Tuning.Auto conf, AutoBuilder parent)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente;
            dd = d * d;
        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _rejected;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }
               
            //    tb.status = borderStatus.rejectedXtraLight; 
            //}

        
            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }
        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val > torg)
                    return;
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;
                if (_selected == null)
                    setSelect(tb);
                else
                {
                    if (tb.status > _selected.status) // && !Conf.BorderIdem)
                        setSelect(tb);
                    else if (tb.status == _selected.status)
                    {
                        if (tb.val > _selected.val)
                            setSelect(tb);
                    }
                }

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;


                if (_rejected == null)
                    setRejec(tb);
                else
                {
                    if (tb.status > _rejected.status)// && !Conf.BorderIdem)
                        setRejec(tb);
                    else if (tb.status == _rejected.status)
                    {
                        if (tb.val < _rejected.val)
                            setRejec(tb);
                    }
                }

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
            misc.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            //  misc.log(ToString());
        }
        private double dt; public double Dt { get { return dt; } }
        private double tension; public double Tension { get { return tension; } }

        public void setTension(bool up)
        {
            dt = getDt(up);
            tension = getTension(up);
        }

        private double getDt(bool up)
        {
            double t0 = _getTension(pertinentOrg);
            double t1 = _getTension(up);
            return (t1 - t0) / conf.coeff;

        }

        private double getTension(bool up)
        {
            return _getTension(up) / conf.coeff;
        }

        private double getValue(TimeSpan val)
        {
            switch (type)
            {
                case borderType.none: break;
                case borderType.d:
                case borderType.fd:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                case borderType.c:
                    break;
                default: return -1;

            }
            return -1;
        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.none: break;
                case borderType.d:
                case borderType.fd:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                case borderType.c:
                    break;
                default: return new TimeSpan();

            }
            return new TimeSpan();
        }

        private double _getTension(bool up)
        {

            // double t0 = getTension(org, dd);
            newv = org;
            if (up)
            {
                if (_rejected == null)
                    return int.MaxValue;
                newv = Math.Round(getValue(_rejected.val), 8);

            }
            else
            {
                if (_selected == null)
                    return int.MaxValue;
                newv = Math.Round(getValue(_selected.val), 8);
            }
            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            _toSave = true;
        }





        private double _getTension(double org)
        {


            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }

        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");

            sb.Append("tension="); sb.Append(_getTension(org)); sb.Append(" ");
            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }
    }
}
]]></content>
  </file>
  <file path="\Auto\Interfaces.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.podcast.Auto
{

    interface ILimitItemBase
    {
        double Contribution { get; set; }
        DateTime DateMax { get; set; }
        double Duration { get; set; }
        double FeedDuration { get; set; }
    }
    /// <summary>
    /// Source de tracks
    /// </summary>
    interface IBuilderSource
    {
        /// <summary>
        /// Donne la liste des tracks sélectionnés
        /// </summary>
        /// <returns></returns>
        List<TrackInfoItunes> getSelectedTracks();
        /// <summary>
        /// Donne la taille total du conteneur
        /// </summary>
        /// <returns></returns>
        double getTotalSize();
        /// <summary>
        /// Identifie le contenu
        /// </summary>
        /// <returns></returns>
        string getEmpreinte();
        /// <summary>
        /// Abonne le builder
        /// </summary>
        /// <param name="auto"></param>
        void addBorderObs(IBorderTransmit auto);

        bool contains(TrackInfoItunes track); 
    }

    /// <summary>
    /// Est informé lorsque qu'un track est sélectionné ou refusé
    /// </summary>
    public interface IBorder
    {
        void signal(TrackBorderItem tb);
    }
    public interface IBorderTransmit : IBorder
    {
        bool Checked { get; }
    }
}
]]></content>
  </file>
  <file path="\Auto\TrackBorderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using System;
using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Auto
{
    public enum borderType
    {
        none,
        d,
        fd,
        maxdate,
        c
    }
    public enum borderStatus : short
    {
        rejectedXtraLight = -2,
        rejectedLight = 0,
        rejectedStrict = 1,
        selectedLight = 2,
        selectedStrict = 3
    }

    //[Flags]
    //public enum border : byte
    //{
    //    virtuel = 0,
    //    strict = 1,
    //    rejected = 0,
    //    selected = 2
    //}

    /// <summary>
    /// Infos sur la sélection ou la non sélection d'un podcast
    /// </summary>
    public class TrackBorderItem
    {
        /// <summary>
        /// Limite à l'orgine de l'info
        /// </summary>
        public readonly LimitItemBase source;
        /// <summary>
        /// Podcast
        /// </summary>
        public readonly TrackInfoItunes candidat;
        /// <summary>
        /// Type de paramètre pris en compte
        /// </summary>
        public readonly borderType type;
        /// <summary>
        /// Valeur actuelle pour le paramètre
        /// </summary>
        public readonly TimeSpan val;
        public borderStatus status;

        public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan val, borderStatus status)
        {
            this.source = source;
            this.candidat = candidat;
            this.type = type;
            this.val = val;

            //int s = 2 * (selected ? 1 : 0) + (strict ? 1 : 0);
            this.status = status;
        }

        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan ts, borderStatus status) :
        //    this(source, candidat, type, ts.TotalMinutes, status)
        //{
        //}

        public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, DateTime t, borderStatus status) :
            this(source, candidat, type,  new TimeSpan(t - Conf.Date0), status)
        {
        }


        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, double val, border status)
        //    : this
        //        (source, candidat, type, val, (borderStatus)status)
        //{
        //}



        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, DateTime t, border status) :
        //    this(source, candidat, type, (t - Conf.Date0).TotalDays, status)
        //{
        //}

        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan ts, border status) :
        //    this(source, candidat, type, ts.TotalMinutes, status)
        //{
        //}


        public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan val, bool selected, bool strict) :
            this(source, candidat, type, val, (borderStatus)(2 * Convert.ToInt16(selected) + Convert.ToInt16(strict)))
        {
        }


        public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, DateTime t, bool selected, bool strict) :
            this(source, candidat, type,new TimeSpan(t-Conf.Date0),selected,strict)
        {
        }

        //public TrackBorderItem(LimitItemBase source, TrackInfoItunes candidat, borderType type, TimeSpan ts, bool selected, bool strict) :
        //    this(source, candidat, type, ts.TotalMinutes, selected,strict)
        //{
        //}

        public override bool Equals(object obj)
        {
            var o = obj as TrackBorderItem;
            if (o == null)
                return false;
            return candidat.Equals(o.candidat);
        }

        public override int GetHashCode()
        {
            return candidat.GetHashCode();
        }

        public override string ToString()
        {
            // string statut// Selected ? "selected" : "rejected";
            return string.Format("{0} {1} {2} {3} {4}", status, type, val, candidat, source);
        }
        public bool Selected { get { return status >= borderStatus.selectedLight; } }
        public bool Virtual { get { return (short)status % 2 == 0; } }
    }

}
]]></content>
  </file>
  <file path="\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    class LimitItemLoader
    {
        private LimitItem limit;
        private LimitsLoader parent;
        private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();
        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        private Logger log;
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtual = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;

        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var duration = limit.Duration;
            loadEqSel = true;
            if (limit.Dir.Cascading)
            {
                var dd = limit.LoadDuration;
                if (dd > duration)
                {
                    loadEqSel = false;
                    duration = dd;
                }
            }
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                var d = candidat.Pub;
                if (d < dateMin)
                    continue;

                bool okDate = d <= dateMax;
                //if (Conf.BorderVirtual)
                //    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, okDate, false));
                //if (!okDate)
                //    continue;
                //  var tb = new TrackBorderItem(limit, candidat, borderType.m    axdate, candidat.Pub, okDate);
                //  limit.signal(tb);

                //if (Conf.BorderVirtual)
                //{
                //     var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, border.);
                //      limit.signal(tb);
                //}

                //if (!okDate && !Conf.BorderVirtual)
                //    continue;


                var loader = getLoader(candidat.Album);
                bool _control = loader.control(candidat, false, okDate);

                //if (!_control && !Conf.BorderVirtual)
                //    continue;

                var currentDurationBase = (okDate && _control) ? currentDuration : currentDurationVirtual;
                var newDuration = currentDurationBase + candidat.Duree;
                bool okTotalDuration = newDuration <= durationMax;
                bool selected = _control && okTotalDuration; //

                //question fd
                if (loader.LoadEqSel)
                {
                    if (okDate && _control && okTotalDuration)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedStrict));
                    else if (okDate && okTotalDuration)
                    {
                        if (loader.EndByFd)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedStrict));
                    }
                    else if (Conf.BorderVirtual)
                    {
                        if (_control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                        else if (loader.EndByFd)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));
                    }


                    //if (!_control)
                    //{
                    //    if (okDate && okTotalDuration && loader.EndByFd)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                }

                if (loadEqSel)
                {
                    // question d
                    if (okDate && _control && okTotalDuration)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                    else if (okDate && _control)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                    else if (Conf.BorderVirtual)
                    {
                        if (okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                        else
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                    }
                    //if (!okTotalDuration)
                    //{
                    //    if (okDate && _control)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}

                    // question date
                    if (okDate && _control && okTotalDuration)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                    else if (_control && okTotalDuration)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                    else if (Conf.BorderVirtual)
                    {
                        if (okDate)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                        else
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                    }

                }



                //if (loadEqSel)
                //{
                //    if ((okDate && _control) || Conf.BorderVirtual)
                //    {
                //       var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okTotalDuration);
                //        limit.signal(tb);
                //    }
                //}

                //if ((okDate && _control))
                //{                   
                //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okTotalDuration,true);
                //    limit.signal(tb);
                //}

                //if (_control && okTotalDuration)
                //{
                //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate);
                //    limit.signal(tb);
                //}

                //if (okDate && okTotalDuration)
                //{
                //    if (!loader.limit.NbFeedLimit)
                //    {
                //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.CurrentDuration, _control);
                //        limit.signal(tb); 
                //    }
                //}

                // limit.checkBorderDates(candidat, selected);

                // preloaded.Add(location, candidat);
                if (selected)
                {
                    standAlone.Add(location, candidat);
                    candidat.select(selectMode.standAlone, limit);
                    limit.Dir.recordTrackLoad(candidat); 

                }
                else if (okDate && _control && !okTotalDuration)
                {
                    if (!limit.LoadDurationLimitAtteinte)
                        log.log("loadCandidats duréée limite atteinte {0}", (currentDuration)); //.TotalMinutes.ToString("0"));
                    limit.LoadDurationLimitAtteinte = true;
                }

                if (okDate && _control)
                    currentDuration += candidat.Duree;
                currentDurationVirtual += candidat.Duree;

            }

        }

        private bool control(TrackInfoItunes track, bool select, bool real)
        {
            var loader = getLoader(track.Album);
            return loader.control(track, select, real);
        }

        private FeedLimitItemLoader getLoader(string album)
        {

            FeedLimitItemLoader loader = null;
            if (!loaders.ContainsKey(album))
            {
                loader = new FeedLimitItemLoader(limit, album, parent);
                loaders.Add(album, loader);
                if (parent.state == loadState.selection)
                    loader.phase2();
            }
            else
                loader = loaders[album];
            return loader;
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            currentDurationVirtual = new timeSpan();
            currentContrib = new timeSpan();
            limit.DurationLimitAtteinte = false;
            limit.ContributionLimitAtteinte = false;
            limit.DurationFeedLimit = false;
            limit.NbFeedLimit = false;
            foreach (FeedLimitItemLoader loader in loaders.Values)
                loader.phase2();
            limit.Dir.Conteneur.phase2(); 
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            if (standAlone.ContainsKey(location))
                return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            if (standAlone.ContainsKey(location))
                return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }

        public void Selection()
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;

            if (histo)
                relax.Sort(new PodCastComparer());
            else
                relax.Sort(new PodCastComparerInv());
            selection(relax, false, false);

            var list = legacy.List;
            if (histo)
                list.Sort(new PodCastComparer());
            else
                list.Sort(new PodCastComparerInv());

            selection(list, false, true);



            var list2 = standAlone.List;
            if (histo)
                list2.Sort(new PodCastComparer());
            else
                list2.Sort(new PodCastComparerInv());

            selection(list2, true, true);

        }

        private void selection(ICollection<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.Duration;
            var durationMax = timeSpan.FromMinutes(duration);
            var contributionMax = timeSpan.FromMinutes(limit.Contribution);


       
            foreach (TrackInfoItunes candidat in list)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;
                if (selected.ContainsKey(location))
                    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Contribute;

                var d = candidat.Pub; 
                bool okDate =d <= limit.DateMax;
                var loader = getLoader(candidat.Album);
                bool _control = loader.control(candidat, select, okDate);

                if (!loader.LoadEqSel && Conf.BorderVirtual)
                {

                    if (_control)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                    else if (loader.EndByFd)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                }

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {





                    if (okDate && _control)
                        currentDuration += candidat.Duree;
                    currentDurationVirtual += candidat.Duree;

                    var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

                    bool okTotalDuration = newDuration <= durationMax;


                    //question fd
                    if (!loader.LoadEqSel)
                    {
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
                        else if (okDate && okTotalDuration)
                        {
                            if (loader.EndByFd)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
                        }
                        //else if (Conf.BorderVirtual)
                        //{
                        //    if (_control)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
                        //    else if (loader.EndByFd)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
                        //}


                    }

                    if (!loadEqSel)
                    {
                        // question d
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                        else if (okDate && _control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okTotalDuration)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                        }
                       

                        // question date
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                        else if (_control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okDate)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                        }

                    }



                    ////question duree
                    //if (okDate && _control) // || Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
                    //}

                    ////question fd

                    //if (_control)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

                    //    }
                    //}
                    //else //if (!loader.limit.NbFeedLimit)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                    ////question date
                    //if (_control && okDuration)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
                    //    limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
                    //    limit.signal(tb);
                    //}



                    //if (!_control && !Conf.BorderVirtual)
                    //    continue;
                    if (!okDate)
                        continue;

                    if (!_control)
                        continue;
                    if (!okTotalDuration)
                    {
                        if (!Logger.CreateNullLoggers)
                            log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));
                        limit.DurationLimitAtteinte = true;
                        break;
                    }

                    if (!newContribut)
                    {

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }
                        use.Add(candidat);
                    }

                  





                    // enregistrement pour stockage et stats
                    limit.Dir.recordTrack(candidat, limit);

                    selected.Add(location, candidat);

                    if (select)
                        exclu.Add(location, candidat);





                }

            }
        }

        public LimitItem Item { get { return limit; } }

    }
}
]]></content>
  </file>
  <file path="\Report\TrackConteneur.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using System;

namespace pdb.podcast.Report
{
    /// <summary>
    /// Pistes associées à un dir
    /// </summary>
    class TrackConteneur
    {
        /// <summary>
        /// Pistes
        /// </summary>
        public Dictionary<string, TrackInfoItunes> dict = new Dictionary<string, TrackInfoItunes>();
        
        /// <summary>
        /// Données du parent.
        /// </summary>
        private TrackConteneur parent;

        /// <summary>
        /// Ensemble des items alimentant les pistes
        /// </summary>
        private List<LimitItemStat> contributeurs = new List<LimitItemStat>();

        /// <summary>
        /// Ensemble des limites alimentant les pistes
        /// </summary>
        private List<LimitStat> limites = new List<LimitStat>();

        /// <summary>
        /// Ensemble des répertoires alimentant les pistes
        /// </summary>
        private List<DirStat> dirs = new List<DirStat>();

        /// <summary>
        /// Stats au niveau dir
        /// </summary>
        private Stat totaux = new Stat();
        /// <summary>
        /// Stats par niveau
        /// </summary>
        private Stat[] sous_totaux = new Stat[Limits.NB];

        /// <summary>
        /// Stats par album
        /// </summary>
        private GroupStat statsTracks = new GroupStat();
        public GroupStat Tracks { get { return statsTracks; } }

        /// <summary>
        /// Liste des pistes ajoutées et leur provenance
        /// </summary>
        private ITextWriter rapportListe = new StringBuilder();

        /// <summary>
        /// Logger
        /// </summary>
        private Logger logger;

        public void recordTrackLoad(TrackInfoItunes track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            bool found = dict.ContainsKey(location);
            if (!found)
                dict.Add(location, track);
            if (parent != null)
                parent.recordTrackLoad(track);
        }

        public void phase2()
        {
            dict.Clear();
            if (parent != null)
                parent.phase2(); 
        }

        /// <summary>
        /// Enregistrement d'une piste
        /// </summary>
        /// <param name="track">piste</param>
        /// <param name="provider">item de limite</param>
        public void recordTrack(TrackInfoItunes track, LimitItem provider)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;


            var contributeur = contributeurs.Find(c => c.Item == provider);
            if (contributeur == null)
            {
                contributeur = new LimitItemStat(provider);
                contributeurs.Add(contributeur);
            }

            var limite = limites.Find(c => c.Limit == provider.Limit);
            if (limite == null)
            {
                limite = new LimitStat(provider.Limit);
                limites.Add(limite);
            }

            var dirContributeur = dirs.Find(d => d.Dir == provider.Dir);
            if (dirContributeur == null)
            {
                dirContributeur = new DirStat(provider.Dir);
                dirs.Add(dirContributeur);
            }


            int indexRating = track.Rating / 20;
            bool found = dict.ContainsKey(location);
            //bool foundInItem = track.containsload(provider); // Providers1.Contains(provider); 


            if (!found)
            {
                dict.Add(location, track);
                totaux.recordTrack(track);
                sous_totaux[indexRating].recordTrack(track);
                contributeur.recordTrack(track, typeState.use);
                limite.recordTrack(track, typeState.use);
                dirContributeur.recordTrack(track, typeState.use);
                var item = track.Provider;
                var dirProvider = item.Dir;
                if (dirProvider.isChildOf(dir))
                    statsTracks.recordTrack(track, typeState.use);
            }

            //if (foundInItem)
            //{
            //    contributeur.recordTrack(track, typeState.standalone);
            //    dirContributeur.recordTrack(track, typeState.standalone);
            //    statsTracks.recordTrack(track, typeState.standalone);
            //}

            //totaux.recordTrack(track);
            //sous_totaux[indexRating].recordTrack(track);
            contributeur.recordTrack(track, typeState.all);
            limite.recordTrack(track, typeState.all);
            dirContributeur.recordTrack(track, typeState.all);
            statsTracks.recordTrack(track, typeState.all);

            string strNew = "";
            if (!found) strNew = " *";
            var sb = new StringBuilder();

            //sb.Append(provider.Dir.getPath());
            //sb.Append(" ");
            sb.Append(provider.ToString());
            sb.Append(" ");
            sb.Append(track);
            if (!found)
                rapportListe.AppendLine(sb.ToString());
            sb.Append(strNew);

            logger.log(sb.ToString());

            if (parent != null)
                parent.recordTrack(track, provider);


        }

        ///// <summary>
        ///// enregistrement d'une piste en mode virtuel "standalone" : que se passerait-il si la limite était la seule ? 
        ///// </summary>
        ///// <param name="track"></param>
        ///// <param name="provider"></param>
        //public void recordTrackStandAlone(TrackInfoItunes track, LimitItem provider)
        //{
        //    string location = track.Location;
        //    if (string.IsNullOrEmpty(location))
        //        return;


        //    var contributeur = contributeurs.Find(c => c.Item == provider);
        //    if (contributeur == null)
        //    {
        //        contributeur = new LimitItemStat(provider);
        //        contributeurs.Add(contributeur);
        //    }

        //    var dirContributeur = dirs.Find(d => d.Dir == provider.Dir);
        //    if (dirContributeur == null)
        //    {
        //        dirContributeur = new DirStat(provider.Dir);
        //        dirs.Add(dirContributeur);
        //    }


        //    int indexRating = track.Rating / 20;




        //    //totaux.recordTrack(track);
        //    //sous_totaux[indexRating].recordTrack(track);
        //    contributeur.recordTrack(track, typeState.standalone);
        //    dirContributeur.recordTrack(track, typeState.standalone);
        //    statsTracks.recordTrack(track, typeState.standalone);


        //    if (parent != null)
        //        parent.recordTrackStandAlone(track, provider);


        //}

        //public void recordTrackForStats(TrackInfoItunes track, LimitItem provider)
        //{
        //    var contributeur = contributeurs.Find(c => c.Item == provider);
        //    if (contributeur == null)
        //    {
        //        throw new ApplicationException("provider " + provider + " pas trouvé"); 
        //    }


        //}


        private DirConf dir;

        public TrackConteneur(DirConf dir, TrackConteneur parent, Logger logger)
        {
            this.dir = dir;
            this.parent = parent;
            this.logger = logger;
            for (int i = 0; i < Limits.NB; i++)
                sous_totaux[i] = new Stat();
        }

        /// <summary>
        /// Récupération de la liste des pistes
        /// </summary>
        /// <returns></returns>
        public List<TrackInfoItunes> getListe()
        {
            logger.log("");
            logger.log("getListe");
            logger.log(rapportListe.ToString());
            return new List<TrackInfoItunes>(dict.Values);
        }


        /// <summary>
        /// Ecriture du rapport
        /// </summary>
        /// <param name="descBuilder"></param>
        public void rapport(DescBuilder descBuilder)
        {
            // total
            if (dict.Count > 0)
            {

                var totalReport = descBuilder.createChild("Total"); // new DescBuilder(descBuilder, "Total");     
                descBuilder.AppendLine();

                totaux.rapport(totalReport);


                for (int i = 0; i < Limits.NB; i++)
                {
                    if (sous_totaux[i].Nb == 0)
                        continue;

                    var subReport = totalReport.createChild(i.ToString());
                    subReport.beginLine();
                    sous_totaux[i].rapport(subReport);

                }
            }

            // contribution par répertoire
            foreach (DirStat dir in dirs)
            {
                var descCt = descBuilder.createChild("Dir");
                dir.report(descCt);
            }
            // contribution par limite
            foreach (LimitItemStat contributeur in contributeurs)
            {
                var descCt = descBuilder.createChild("Limit");
                contributeur.report(descCt);
            }

            var descTrack = descBuilder.createChild("Tracks");
            if (parent == null)
                statsTracks.forceDetails();
            statsTracks.report(descTrack);

            //rappel
            if (parent == null)
            {
                descBuilder.AppendLine();
                totaux.rapport(descBuilder);
            }
        }

        public double getTotalSize()
        {
            return totaux.getTotalSize();
        }

        public void diff(TrackConteneur old, Logger log)
        {

        }
    }
}
]]></content>
  </file>
  <file path="\Tuning\DirConf.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.podcast.Report;
using pdb.util;
using pdb.podcast.Load;
using pdb.podcast.Auto;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Répertoire de pistes
    /// </summary>
    public class DirConf : LimitItemBase, IEnumerable<DirConf>, IBuilderSource, IBorder
    {
        /// <summary>
        /// logger
        /// </summary>
        private Logger log;
        /// <summary>
        /// Limites associées au noeud
        /// </summary>
        private Limits limites;
        /// <summary>
        /// Nom du répertoire
        /// </summary>
        private string name = "";

        /// <summary>
        /// Sous-répertoires
        /// </summary>
        private List<DirConf> childs = new List<DirConf>();

        /// <summary>
        /// Répertoire parent
        /// </summary>
        private readonly DirConf parent;

        /// <summary>
        /// Stats
        /// </summary>
        private DirStat stat;
        internal DirStat Stat { set { stat = value; } get { return stat; } }
        internal TrackConteneur Conteneur { get { return conteneur; } }


        /// <summary>
        /// Ajout d'un sous-répertoire
        /// </summary>
        /// <param name="dir"></param>
        public void addChild(DirConf dir)
        {
            childs.Add(dir);

        }
        public DirConf Parent
        {
            get { return parent; }
        }

        public bool isChildOf(DirConf dir)
        {
            if (dir == this)
                return true;
            if (parent == null)
                return false;
            return parent.isChildOf(dir);
        }

        /// <summary>
        /// Conteneur des pistes
        /// </summary>
        private TrackConteneur conteneur;

        private FeedsLoader loader;
        internal FeedsLoader Loader
        {
            get
            {
                if (loader == null)
                    loader = new FeedsLoader(this);
                return loader;
            }

        }

        /// <summary>
        /// Enregistrement d'une piste
        /// </summary>
        /// <param name="track">piste</param>
        /// <param name="provider">item de limite</param>
        public void recordTrack(TrackInfoItunes track, LimitItem limit)
        {
            conteneur.recordTrack(track, limit);
            if (parent != null)
                parent.recordTrackFromChild(track, limit, this);
        }

        public void recordTrackLoad(TrackInfoItunes track)
        {
            conteneur.recordTrackLoad(track);          
        }

        //public void recordTrackStandAlone(TrackInfoItunes track, LimitItem limit)
        //{
        //    conteneur.recordTrackStandAlone(track, limit);
        //}

        /// <summary>
        /// Récupération de la liste des pistes
        /// </summary>
        /// <returns></returns>
        public List<TrackInfoItunes> getListe()
        {
            var list = conteneur.getListe();
            if (Histo)
                list.Sort(new PodCastComparer());
            else
                list.Sort(new PodCastComparerInv());
            log.log("");
            log.log(getPath() + " getListe " + list.Count + " elt.");
            foreach (TrackInfoItunes track in list)
            {
                log.log(track.ToString());
            }
            return list;
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, DirConf dirSource)
        {
            if (dirSource.transmitToParent)
                Loader.recordTrackFromChild(track, itemSource, dirSource.transmitTotal);
            if (parent != null)
                parent.recordTrackFromChild(track, itemSource, this);
        }

        /// <summary>
        /// Abandonné
        /// </summary>
        public void TransmissionListToParent(TrackInfoItunes track)
        {
        }


        //public void recordTrackForStats(TrackInfoItunes track, LimitItem provider)
        //{
        //    conteneur.recordTrackForStats(track, provider);
        //}








        public Limits Limites { get { return limites; } set { limites = value; } }


        public DirConf(Limits limites, string name, DirConf parent)
            : base()
        {
            this.name = name;
            this.limites = limites;
            limites.Parent = this;
            this.parent = parent;
            this.setParent(parent);
            this.log = Logger.getLogger(getPath() + "\\dir", false);
            if (parent == null)
                conteneur = new TrackConteneur(this, null, log);
            else
                conteneur = new TrackConteneur(this, parent.conteneur, log);
            transmitToParent = Conf.Transmit;
            transmitTotal = Conf.TransmitTotal;
            transmitTotalGuest = Conf.TransmitTotalGuest;
            cascading = Conf.Cascading;

        }

        ///// <summary>
        ///// durée max de chaque item
        ///// </summary>
        //public float Duration
        //{
        //    set { duration = value; }
        //    get
        //    {
        //        if (parent == null || duration < int.MaxValue)
        //        {
        //            return duration;
        //        }
        //        return parent.Duration;

        //    }
        //}

        /// <summary>
        /// Répertoire de type Info
        /// </summary>
        public bool? Info
        {
            get
            {
                if (name == "info")
                    return true;
                if (name == "PAS Info")
                    return false;
                if (parent == null)
                    return null;
                return parent.Info;
            }
        }

        /// <summary>
        /// Répertoire de type rare
        /// </summary>
        public bool? Rare
        {
            get
            {
                if (name == "RARE")
                    return true;
                if (name == "PAS RARE")
                    return false;
                if (parent == null)
                    return null;
                return parent.Rare;
            }
        }

        /// <summary>
        /// Répertoire de type historique
        /// </summary>
        public bool Histo
        {
            get
            {
                if (name == "Histo")
                    return true;
                if (parent == null)
                    return false;
                return parent.Histo;
            }
        }

        /// <summary>
        /// Généralisation de l'historique à tous les noeuds enfant ou simple sélection nominative(par album)
        /// </summary>
        private bool? histoAll;
        public bool? HistoAll
        {
            get
            {
                if (histoAll.HasValue)
                    return histoAll;
                if (parent == null)
                    return null;
                return parent.HistoAll;
            }
            set
            {
                histoAll = value;
            }
        }

        private bool? cascading;
        public bool Cascading
        {
            get
            {
                if (cascading.HasValue)
                    return cascading != false;
                if (false == histoAll)
                    return false;
                if (parent == null)
                    return true;
                return parent.Cascading;
            }
            set
            {
                cascading = value;
            }
        }

        private bool? selectionPre;
        public bool SelectionPre
        {
            get
            {
                if (selectionPre.HasValue)
                    return selectionPre != false;
                if (false == selectionPre)
                    return false;
                if (parent == null)
                    return false;
                return parent.SelectionPre;
            }
            set
            {
                cascading = value;
            }
        }

        private bool transmitToParent = true;
        public bool TransmitToParent { get { return transmitToParent; } set { transmitToParent = value; } }

        private bool transmitTotal = true;
        public bool TransmitTotal { get { return transmitTotal; } set { transmitTotal = value; } }

        private bool transmitTotalGuest = true;
        public bool TransmitTotalGuest { get { return transmitTotalGuest; } set { transmitTotalGuest = value; } }



        /// <summary>
        /// Arbre généalogique du répertoire permettant de situer les listes à modifier
        /// </summary>
        public List<string> Folders
        {
            get
            {

                if (parent == null)
                    return new List<string> { name };
                var list = parent.Folders;
                list.Add(name);
                return list;

            }

        }
        public string Name { get { return name; } }

        /// <summary>
        /// Représentation du chemin depuis le root
        /// </summary>
        /// <returns></returns>
        public string getPath()
        {
            if (parent == null)
                return name;
            string path = parent.getPath();
            if (string.IsNullOrEmpty(path))
                return name;
            return path + "\\" + name;
        }



        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            //sb.Append(" ");
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            //sb.Append(limites.ToString());
            return sb.ToString();
            // return getPath() + " " + Environment.NewLine + limites.ToString();
        }

        public string display()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            sb.AppendLine();
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            sb.Append(limites.ToString());
            return sb.ToString();
        }



        public IEnumerator<DirConf> GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        public List<LimitItem> getAllListItems()
        {
            var list = new List<LimitItem>();
            buildListLimitItems(list);
            return list;
        }

        protected void buildListLimitItems(ICollection<LimitItem> depot)
        {
            foreach (DirConf sub in this)
                sub.buildListLimitItems(depot);
            foreach (Limit limit in limites)
            {
                foreach (LimitItem item in limit.Items)
                    depot.Add(item);
            }
        }

        #region ITrackReport Members

        /// <summary>
        /// Rapport
        /// </summary>
        /// <param name="sb"></param>
        public void rapport(DescBuilder sb)
        {
            sb.beginLine();

            conteneur.rapport(sb);
            sb.AppendLine();


            if (!LimitItem.includeDetail)
                return;
            foreach (DirConf sub in childs)
            {
                var descBuilder = sb.createChild(sub.getPath());
                sub.rapport(descBuilder);
            }

        }
        public double getTotalSize()
        {
            return conteneur.getTotalSize();
        }





        #endregion

        #region IBuilderSource
        public List<TrackInfoItunes> getSelectedTracks()
        {
            var items = new List<TrackInfoItunes>(conteneur.Tracks.Total.Use.List);
            if (Histo)
                items.Sort(new PodCastComparer());
            else
                items.Sort(new PodCastComparerInv());
            return items;
        }

        public string getEmpreinte()
        {
            return conteneur.Tracks.Total.Use.getEmpreinte();
        }

        public bool contains(TrackInfoItunes track)
        {
            return conteneur.dict.ContainsKey(track.Location); 
        }

        #region IBorder
        private List<IBorderTransmit> borderObs = new List<IBorderTransmit>();
        public void addBorderObs(IBorderTransmit auto)
        {
            borderObs.Add(auto);
        }
        #endregion
        #endregion

        public void signal(TrackBorderItem tb)
        {
            if (false == HistoAll)
                return; 
            bool _checked = false;
            foreach (IBorderTransmit border in borderObs)
            {
                border.signal(tb);
                if (border.Checked)
                    _checked = true; 
            }

            if (_checked)
                return; 
            if (parent != null)
                parent.signal(tb);
        }
        
    }
}
]]></content>
  </file>
  <file path="\Tuning\Limit.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Report;
using pdb.util;
using pdb.podcast.Auto;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Limitations d'une liste Podcast
    /// </summary>
    public class Limit : ICloneable, IComparable<Limit>, IBuilderSource, IBorder
    {
        /// <summary>
        /// nb étoiles (0-5)
        /// </summary>
        private int level;


        public int Level { get { return level; } set { level = value; } }
        //public int Duration { get { return duration; } set { duration = value; } }
        //public int FeedDuration { get { return feedDuration; } set { feedDuration = value; } }
        private Limits parent;
        public Limits Parent { set { parent = value; } get { return parent; } }
        // private StringBuilder sbRapport = new StringBuilder();

        /// <summary>
        /// Considération des durées de chaque podcast
        /// </summary>
        private List<LimitItem> items = new List<LimitItem>();
        public List<LimitItem> Items { get { return items; } set { items = value; } }
        public DirConf Dir { get { return parent.Parent; } }

        public int index(LimitItem item)
        {
            var count = items.Count;
            if (items.Contains(item))
            {
                if (count == 1)
                    return -1; 
                return items.IndexOf(item);
            }
            return count; 
        }

        //public void AppendLine(string observation)
        //{
        //    sbRapport.AppendLine(observation);
        //}
        //public void Append(object observation)
        //{
        //    sbRapport.Append(observation);
        //}

        //   public int Nb { get { return nb; } set { nb = value; } }




        public Limit(int level)
        {
            this.level = level;
            //var defaultitem = new LimitItem(this);
            //items.Add(defaultitem); 
            // this.parent = parent; 
            //this.report = new TrackReport(level); 

        }

        //public Limit(int level, int duration) : this(level)
        //{
        //    this.duration = duration; 
        //}

        //public Limit(int level, int duration, int feedDuration)
        //    : this(level,duration)
        //{
        //    this.feedDuration  = feedDuration;
        //}

        public object Clone()
        {
            var limit = new Limit(level);
            foreach (var item in items)
            {
                var newItem = item.Clone() as LimitItem;
                limit.Items.Add(newItem);
                newItem.Limit = limit;
            }
            return limit;
        }

        public int CompareTo(Limit other)
        {
            return level.CompareTo(other.level);
        }

        #region ITrackReport Members
        //  private ITrackReport report;
        //  private ITrackReport parent; 

        //public void getTotal()
        //{
        //    report.getTotal(); 
        //}

        //public void rapport(DescBuilder sb)
        //{
        //    sb.beginLine();
        //    sb.Append(sbRapport.ToString());
        //    sb.Append(" ");
        //    sb.Append(parent.Parent.getPath());
        //    sb.Append(" "); 
        //    sb.Append(ToString());


        // //   report.rapport(sb);
        //}

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            int nb = 0; 
            for (int i = 0; i < items.Count; i++)
            {
                if (nb > 0)
                    sb.Append("| ");
                var item = items[i];
                if (item.Nb == 0 || item.FeedDuration == 0)
                    continue;
                nb++; 
                sb.Append(item);
            }

            return sb.ToString();
        }

        //public void recordList(Limit provider, IEnumerable<TrackInfoItunes> list)
        //{
        //    report.recordList(provider, list); 
        //}

        #endregion

        private LimitStat stat;
        internal LimitStat Stat { set { stat = value; } get { return stat; } }

        public List<TrackInfoItunes> getSelectedTracks()
        {
            if (stat == null)
                return new List<TrackInfoItunes>();
            return new List<TrackInfoItunes>( stat.Total.Use.List); 
        }

        public double getTotalSize()
        {
            if (stat == null)
                return -1;
            return stat.Total.Use.getTotalSize(); 
        }

        public string getEmpreinte()
        {
            if (stat == null)
                return "NULL";
            return stat.Total.Use.getEmpreinte();
        }


        public void addBorderObs(IBorderTransmit auto)
        {
            throw new NotImplementedException();
        }

        public void signal(TrackBorderItem tb)
        {
            // en attendant d'implémenter les autos pour limitItem
            Dir.signal(tb);
        }


        public bool contains(TrackInfoItunes track)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\Tuning\LimitItem.cs">
    <content><![CDATA[using System;
using pdb.util;
using pdb.podcast.Report;
using pdb.podcast.Auto;
using System.Collections.Generic;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Item de limite concernant la durée 
    /// </summary>
    public class LimitItem : LimitItemBase, IBuilderSource, IBorder
    {


        /// <summary>
        /// Détailler le rapport - à bouger
        /// </summary>
        public static bool includeDetail;


        public int Level { get { return limit.Level; } }
        public int Rating { get { return limit.Level * 20; } }



        private Limit limit;
        private TripleStat stats = new TripleStat();


        public override string ToString()
        {
            if (nb == 0 || feedDuration == 0)
                return Dir.ToString() + string.Format("\\{0}", limit.Level);
            return Dir.ToString() + string.Format("\\{0}:{1} {2} {3} {4} {5} {6} {7} {8}", limit.Level, getS("d", duration), getS("c", contribution), getS("fd", feedDuration), getS("nb", nb), getS("td", td), getS("tdMin", tdMin), getS("date", dateMin), getS("dateMax", dateMax));
        }

        private static string getS(string desc, int v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}->{1}", desc, v);
            return "";
        }

        private static string getS(string desc, double v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}->{1}", desc, v);
            return "";
        }

        private static string getS(string desc, DateTime v)
        {
            if (v > DateTime.MinValue && v < DateTime.MaxValue)
                return string.Format("{0}->{1}", desc, v);
            return "";
        }



        public void recordTrackMoy(TrackInfoItunes track, int countItems)
        {
            stats.recordTrack(track, countItems);
        }


        private bool durationLimitAtteinte;
        private bool contributionLimitAtteinte;
        private bool durationFeedLimit;
        private bool nbFeedLimit;
        public bool DurationLimitAtteinte { get { return durationLimitAtteinte; } set { durationLimitAtteinte = value; } }
        public bool ContributionLimitAtteinte { get { return contributionLimitAtteinte; } set { contributionLimitAtteinte = value; } }
        private bool loadDurationLimitAtteinte;
        public bool LoadDurationLimitAtteinte { get { return loadDurationLimitAtteinte; } set { loadDurationLimitAtteinte = value; } }

        public bool DurationFeedLimit { set { durationFeedLimit = value; } get { return durationFeedLimit; } }
        public bool NbFeedLimit { set { nbFeedLimit = value; } get { return nbFeedLimit; } }

        #region border
        public bool checkPub(TrackInfoItunes candidat)
        {
            var d = candidat.Pub;
            if (d < dateMin)
                return false;
            if (d > dateMax)
                return false;
            return true;
        }
        #endregion
        //#region border
        ///// <summary>
        ///// track In le plus près de la limite dateMin
        ///// </summary>
        //TrackInfoItunes borderDateMinIn;
        ///// <summary>
        ///// Track rejeté le plus près de la limite dateMin
        ///// </summary>
        //TrackInfoItunes borderDateMinOut;

        ///// <summary>
        ///// track In le plus près de la limite dateMax
        ///// </summary>
        //TrackInfoItunes borderDateMaxIn;
        ///// <summary>
        ///// Track rejeté le plus près de la limite dateMax
        ///// </summary>
        //TrackInfoItunes borderDateMaxOut;

        ///// <summary>
        ///// Dernier accepté par rapport à la durée totale
        ///// </summary>
        //TrackInfoItunes borderDurationIn;
        ///// <summary>
        ///// Premier rejeté par rapport à la durée totale
        ///// </summary>
        //TrackInfoItunes borderDurationOut;

        //TimeSpan borderDurationValueIn;
        //TimeSpan borderDurationValueOut;

        ///// <summary>
        ///// Dernier accepté par rapport à la durée de feed
        ///// </summary>
        //TrackInfoItunes borderFdIn;
        ///// <summary>
        ///// Premier rejeté par rapport à la durée Feed
        ///// </summary>
        //TrackInfoItunes borderFdOut;

        //TimeSpan borderFdValueIn;
        //TimeSpan borderFdValueOut; 

        //public void clearBorder()
        //{
        //    borderDateMinIn = null;
        //    borderDateMinOut = null;
        //    borderDateMaxIn = null; 
        //    borderDateMaxOut = null;
        //    borderDurationIn = null;
        //    borderDurationOut = null;
        //    borderDurationValueIn = new TimeSpan();
        //    borderDurationValueOut = new TimeSpan();

        //    borderFdIn = null;
        //    borderFdOut = null;
        //    borderFdValueIn = new TimeSpan();
        //    borderFdValueOut = new TimeSpan(); 
        //}
       

       
        //// --------vIn----limit ------vout
        //public void checkBorderFd(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        //{
        //    if (selected && duration.TotalMinutes <= this.feedDuration )
        //    {
        //        if (borderFdIn == null || duration > borderFdValueIn )
        //        {
        //            borderFdIn = candidat;
        //            borderFdValueIn = duration;
        //        }
        //    }
        //    else if (!selected && duration.TotalMinutes > this.feedDuration)
        //    {
        //        if (borderFdOut == null || duration < borderFdValueOut)
        //        {
        //            borderFdOut = candidat;
        //            borderFdValueOut = duration;
        //        }
        //    }
        //    else
        //    {
        //    }
        //    }

        //public void checkBorderDuration(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        //{
        //    if (selected && duration.TotalMinutes <= this.duration)
        //    {
        //        borderDurationIn = candidat;
        //        borderDurationValueIn = duration;
        //    }
        //    else if (!selected && duration.TotalMinutes > this.duration)
        //    {
        //        if (borderDurationOut == null)
        //        {
        //            borderDurationOut = candidat;
        //            borderDurationValueOut = duration;
        //        }
        //    }
        //    else
        //    {
        //    }
        //}

        //public void checkBorderDates(TrackInfoItunes candidat, bool selected)
        //{
        //    // ---minOut --limit ---minIn ----
        //    var d = candidat.Pub;
        //    if (d < dateMin)
        //    {
        //        if (borderDateMinOut == null ||d > borderDateMinOut.Pub )
        //            borderDateMinOut = candidat;
        //    }
        //    else if (d>=dateMin && selected)
        //    {
        //        if (borderDateMinIn == null || d < borderDateMinIn.Pub)
        //            borderDateMinIn = candidat;

        //    }
        //    // ---maxIn --limit ---maxOut ----
        //    if (d > dateMax)
        //    {
        //        if (borderDateMaxOut == null || d < borderDateMaxOut.Pub)
        //            borderDateMaxOut = candidat;
        //    }
        //    else if (d <= dateMax &&selected)
        //    {
        //        if (borderDateMaxIn == null || d >borderDateMaxIn.Pub )
        //            borderDateMaxIn = candidat;
        //    }
        //}

       

        //#endregion

        public void writeStat(ITextWriter sbRapport)
        {
            writeStatHeader(sbRapport);
            stats.buildValues(sbRapport);

        }

        private LimitItemStat stat;
        internal LimitItemStat Stat { set { stat = value; } get { return stat; } }

        public void writeStatHeader(ITextWriter sbRapport)
        {
            if (loadDurationLimitAtteinte)
                sbRapport.Append("d");
            else
                sbRapport.Append(" ");

            if (durationLimitAtteinte)
                sbRapport.Append("d");
            else
                sbRapport.Append(" ");

            if (contributionLimitAtteinte)
                sbRapport.Append("c");
            else
                sbRapport.Append(" ");

            if (durationFeedLimit)
                sbRapport.Append("f");
            else
                sbRapport.Append(" ");

            if (nbFeedLimit)
                sbRapport.Append("n");
            else
                sbRapport.Append(" ");
            sbRapport.Append(" ");

        }

        public void getToTaux(ITextWriter sb)
        {

        }

        public void rapport(DescBuilder sb)
        {
            sb.Append("\t");
            //sb.Append(Dir.getPath());
            //sb.Append(" ");
            sb.Append(ToString());
            sb.Append(" ");
        }

        public DirConf Dir { get { return limit.Dir; } }
        public string id = null;
        public string ID
        {
            get
            {
                if (id == null)
                {
                    int index = limit.index(this);
                    if (index >= 0)
                        id = Dir.getPath() + "\\" + Level + "\\_" + (index + 1);
                    else
                        id = Dir.getPath() + "\\_" + Level;

                }
                return id;
            }
        }
        private Logger logger;

        public LimitItem(Limit limit)
        {
            this.limit = limit;
        }
        public Logger Logger
        {
            get
            {
                if (logger == null)
                {
                    logger = Logger.getLogger(ID, false);
                }
                return logger;
            }
        }

        public object Clone()
        {
            var limitiItem =  new LimitItem(limit) { Nb = this.nb,  Td = this.td, TdMin = this.tdMin, DateMin = this.dateMin, Contribution = this.contribution, Stat = this.stat };
            limitiItem.duration = this.duration;
            limitiItem.feedDuration = this.feedDuration;
            limitiItem.dateMax = this.dateMax;            
            return limitiItem; 

        }

        public Limit Limit { set { limit = value; } get { return limit; } }


        public List<TrackInfoItunes> getSelectedTracks()
        {
            if (stat == null)
                return new List<TrackInfoItunes>();
            return new List<TrackInfoItunes>(stat.Total.Use.List);
        }

        public double getTotalSize()
        {
            if (stat == null)
                return -1;
            return stat.Total.Use.getTotalSize();
        }

        public string getEmpreinte()
        {
            if (stat == null)
                return "NULL";
            return stat.Total.Use.getEmpreinte();
        }


        public void addBorderObs(IBorderTransmit auto)
        {
            throw new NotImplementedException();
        }

        public void signal(TrackBorderItem tb)
        {
            // en attendant d'implémenter les autos pour limitItem
            if (tb == null)
                return;
            switch (tb.type)
            {
                case borderType.none: return;

                case borderType.d: if (!hduration) return; 
                    break;
                case borderType.fd: if (!hfeedDuration) return; 
                    break;
                case borderType.maxdate: if (!hdateMax) return;
                    break;
                case borderType.c:
                    break;
                default:
                    break;
            }
            limit.signal(tb);
           
        }


        public bool contains(TrackInfoItunes track)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
</db>
