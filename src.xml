<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ConfAlbumSortW" Height="265" Width="1301" Loaded="Window_Loaded">
    <Grid Height="211" Width="1257">
        
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <Grid Grid.Row="0" Name="gfirst" />
       
        <Grid Grid.Row="1" Name="gsecond" />
        <!--<Grid Grid.ColumnSpan="2" Margin="0,0,-172,0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="236*" />
            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="4" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="5" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="6" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="7" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" KeyUp="tb_safe_KeyUp" />
            <TextBox  Grid.Row="0" Grid.Column="8" Name="tb_coeff" Width="40" ToolTip="coeff des morceaux virtuels" Margin="5" KeyUp="tb_safe_KeyUp" />
            <TextBox  Grid.Row="0" Grid.Column="9" Name="tb_coeffT" Width="40" ToolTip="coeff total des morceaux virtuels" Margin="5" KeyUp="tb_coeffT_KeyUp" />
            <CheckBox  Grid.Row="0" Grid.Column="10" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="11" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="0" Grid.Column="12" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="0" Grid.Column="13" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="14" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="15" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="16" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="17" Name="cb_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="18" Name="cb_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="19" Name="cb_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="20" Name="cb_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="21" Name="cb_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="22" Name="cb_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="23" Name="cb_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="24" Name="cb_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" />

            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="0" Grid.Column="25" Name="cbx_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="0" Grid.Column="26" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="4" Name="cb2_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="5" Name="cb2_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="6" Name="cb2_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="7" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="8" Name="tb2_coeff" Width="40" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="9" Name="tb2_coeffT" Width="40" ToolTip="coeff total des morceaux virtuels" Margin="5"  />
            <CheckBox  Grid.Row="1" Grid.Column="10" Name="cb2_removeFirst" ToolTip="removeFirst" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="11" Name="cb2_deleteFirst" ToolTip="deleteFirst" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="1" Grid.Column="12" Name="cbx2_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="1" Grid.Column="13" Name="cb2_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="14" Name="cb2_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="15" Name="tb2_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="16" Name="cb2_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="17" Name="cb2_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="18" Name="cb2_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="19" Name="cb2_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="20" Name="cb2_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="21" Name="cb2_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="22" Name="cb2_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="23" Name="cb2_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="24" Name="cb2_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" />
            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="1" Grid.Column="25" Name="cbx2_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="1" Grid.Column="26" Name="tb2_zero" Width="120" ToolTip="zéro" Margin="5" />
        </Grid>-->
        <Grid Grid.Row="2" Height="65" Margin="0,0,0,-30">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="Auto" />
            </Grid.ColumnDefinitions>
            <StackPanel Grid.Row="2" Grid.Column="0" Orientation="Horizontal"  HorizontalAlignment="Left"  Margin="0,5" >
                <CheckBox Name="cb_createCourant" ToolTip="générer stats en cours (désactivés)"  Margin="5" Padding="2"></CheckBox>
                <CheckBox Name="cb_createInter" ToolTip="générer stats en cours + provisoire"  Margin="5" Padding="2"></CheckBox>
                <CheckBox Name="cb_createAll" ToolTip="générer stats de tout"  Margin="5" Padding="2"></CheckBox>
                <DatePicker Name="dp_date" ToolTip="Date seuil pour considérer un classement provisoire" />
            </StackPanel>
            <StackPanel Orientation="Horizontal"  HorizontalAlignment="Right" Margin="5,5,8,5"  Width="326">
                <TextBox Grid.Row="2" Name="tb_stackSize" Width="30"  VerticalAlignment="Center" Text="10" ToolTip="taille de la pile d'exclusion" Margin="5" Padding="2"/>
                <TextBox Grid.Row="2" Name="tb_coeffEnabled" Width="60"  VerticalAlignment="Center" Text="1" ToolTip="Coeff des morceaux cochés"  KeyUp="tb_safe_KeyUp" Margin="5" Padding="2"/>
                <CheckBox Grid.Row="2" Name="cb_idem" Width="30"  VerticalAlignment="Center" ToolTip="Lier les items" Margin="5" Padding="2" Click="cb_idem_Click" />
                <Button Grid.Row="2" Name="bt_cancel" IsCancel="true" Height="25" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_ok" Height="25" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_coul" Height="25" HorizontalAlignment="Right" Content="Couleurs" Click="bt_coul_Click"   Margin="5" Padding="2"/>
            </StackPanel>
        </Grid>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\ConfMedianneW.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.Conf.ConfMedianneW"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="213" d:DesignWidth="1088">
    <Grid Grid.IsSharedSizeScope="True" >
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="*" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <Grid Grid.IsSharedSizeScope="True" Margin="6">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" SharedSizeGroup="C1" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C2" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C3" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C4" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C5" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C6" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C7" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C8" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C9" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C10" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C11" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C12" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C13" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C14" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C15" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C16" />
            </Grid.ColumnDefinitions>
           


            <CheckBox  Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="2" />


            <CheckBox   Grid.Row="0" Grid.Column="4" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="2" />
            <CheckBox   Grid.Row="0" Grid.Column="5" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast"  Grid.Row="0" Grid.Column="6" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>

            <TextBox   Grid.Row="0" Grid.Column="7" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox   Grid.Row="0" Grid.Column="8" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />




            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin"  Grid.Row="0" Grid.Column="9" Name="cbx_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox   Grid.Row="0" Grid.Column="10" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />




           
        </Grid>
        <Grid Grid.Row="1" Name="gmain">
            <Label Content="main:" Margin="0,0,12,0"></Label></Grid>
        <Grid Grid.Row="2" Name="gmin">
            <Label Content="min:" Margin="0,0,12,0"></Label>
        </Grid>
    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\ConfVirt.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.Conf.ConfVirt"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="85" d:DesignWidth="1352">
    <Grid Grid.IsSharedSizeScope="True" Height="64" Width="1332">
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto" SharedSizeGroup="V1" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V2" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V3" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V4" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V5" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V6" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V7" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V8" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V9" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V10" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V11" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V12" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V13" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V14" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V15" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V16" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V17" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V18" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V19" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V20" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V21" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V22" />

            <ColumnDefinition Width="Auto" SharedSizeGroup="V23" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V24" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V25" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V26" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V27" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V28" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V29" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V30" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V31" />
        </Grid.ColumnDefinitions>
      
     
        <CheckBox Height="20" VerticalAlignment="Center" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="1" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="2" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="2" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="3" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" KeyUp="tb_safe_KeyUp" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="4" Name="tb_coeff" Width="50" ToolTip="coeff des morceaux virtuels" Margin="5" KeyUp="tb_safe_KeyUp" Grid.RowSpan="2" />
        <TextBox  Height="20"  Grid.Column="5" Name="tb_coeffT" Width="50" ToolTip="coeff total des morceaux virtuels" Margin="5" KeyUp="tb_coeffT_KeyUp" Grid.RowSpan="2" />


        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="6" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="7" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" Grid.RowSpan="2" />
       
      
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="8" Name="cb_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="9" Name="cb_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="10" Name="cb_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="11" Name="cb_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="12" Name="cb_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="13" Name="cb_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="14" Name="cb_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="15" Name="cb_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="16" Name="cb_auto" ToolTip="pilotage auto" Margin="5" Padding="2" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="17" Name="tb_dcoeffp" Width="40" ToolTip="delta en montée" Margin="5" Grid.RowSpan="2" KeyUp="tb_dcoeffp_KeyUp" />
        <TextBox  Height="20" Grid.Column="18" Name="tb_serialp" Width="20" ToolTip="série en montée" Margin="5" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="19" Name="tb_dcoeffm" Width="40" ToolTip="delta en descente" Margin="5" Grid.RowSpan="2" />       
        <TextBox  Height="20" Grid.Column="20" Name="tb_serialm" Width="20" ToolTip="série en descente" Margin="5" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="21" Name="tb_serial" Width="20" ToolTip="série en cours" Margin="5" Grid.RowSpan="2" ToolTipService.ShowOnDisabled="True" IsEnabled="False" />
        <TextBox  Height="20" Grid.Column="22" Name="tb_convergence" Width="60" ToolTip="convergence" Margin="5" Grid.RowSpan="2" KeyUp="tb_convergence_KeyUp" />        
        <TextBox  Height="20" Grid.Column="23" Name="tb_dconvdeltap" Width="60" ToolTip="evol convergent +" Margin="5" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="24" Name="tb_dconvdeltam" Width="60" ToolTip="cevol convergent -" Margin="5" Grid.RowSpan="2" />
        
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="25" Name="cb_link" ToolTip="aligner convergence et coeff" Margin="5" Padding="2" Grid.RowSpan="2" Click="cb_link_Click" />
        <TextBox  Height="20" Grid.Column="26" Name="tb_prod" Width="60" ToolTip="produit de convergence" Margin="5" Grid.RowSpan="2" KeyUp="tb_prod_KeyUp" ToolTipService.ShowOnDisabled="True" />
        <TextBox  Height="20" Grid.Column="27" Name="l_prod" Width="60" ToolTip="produit de convergence effectif" Margin="5" Grid.RowSpan="2" ToolTipService.ShowOnDisabled="True"  IsEnabled="False"/>
        <TextBox  Height="20" Grid.Column="28" Name="tb_anti" Width="40" ToolTip="anti-convergence" Margin="5" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="29" Name="tb_antideltap" Width="60" ToolTip="evol anti-convergent +" Margin="5" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="30" Name="tb_antideltam" Width="60" ToolTip="evol anti-convergent -" Margin="5" Grid.RowSpan="2" />
    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\ConfVirt.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using pdb.util;

namespace pdb.player.Vue.Conf
{
    public interface IConfSort
    {
        string CoeffEnabled { get; }
        bool DuplicateItem { get; }
    }
    /// <summary>
    /// Interaction logic for ConfVirt.xaml
    /// </summary>
    public partial class ConfVirt : UserControl
    {
        private ConfMedianneVirt conf;
        private IConfSort parent;
    


        decimal coeffp;
        decimal prod;
        decimal conv; 
        

        public ConfVirt()
        {
            InitializeComponent();
        }

        public ConfVirt(ConfMedianneVirt conf, IConfSort parent)
            : this()
        {
            this.conf = conf;
            this.parent = parent;
            display();
            onchange();
        }

        public ConfMedianneVirt Conf
        {
            set
            {
                this.conf = value; 
            }
        }


        public void display()
        {

           
            cb_lissage.IsChecked = conf.lissage;
            cb_removeEpsilon.IsChecked = conf.removeEpsilon;
            cb_reSort.IsChecked = conf.reSort;


            cb_cumul.IsChecked = conf.cumul;
            cb_noAdd.IsChecked = conf.noAdd;
            tb_safe.Text = conf.safe.ToString();
            tb_coeff.Text = conf.coeffVirt.ToString();


            cb_virtOnlyDisabled.IsChecked = conf.virtOnlyDisabled;
            cb_forceCoeffVirt.IsChecked = conf.forceCoeffVirt;
            cb_virtAlignPrec.IsChecked = conf.virtAlignPrec;
            cb_virtAlignSelected.IsChecked = conf.virtAlignSelected;
            cb_coeffVirtAdjust.IsChecked = conf.coeffVirtAdjust;
            cb_coeffVirtAuto.IsChecked = conf.coeffVirtAuto;


            cb_noaddEnd.IsChecked = conf.noAddEnd;
            cb_noaddAll.IsChecked = conf.noAddAll;

            cb_auto.IsChecked = conf.auto;
            coeffp = conf.dcoeffp;
            tb_dcoeffp.Text = coeffp.ToString("0.###");
            tb_dcoeffm.Text = conf.dcoeffm.ToString("0.###");
            conv = conf.dconvergence; 
            tb_convergence.Text = conv.ToString("0.######");
            tb_dconvdeltap.Text = conf.dconvdeltap.ToString("0.######");
            tb_dconvdeltam.Text = conf.dconvdeltam.ToString("0.######");

            tb_anti.Text = conf.danticonvergence.ToString("0.###");
            tb_antideltap.Text = conf.danticonvdeltap.ToString("0.######");
            tb_antideltam.Text = conf.danticonvdeltam.ToString("0.######");

            cb_link.IsChecked = conf.linkconv;

            prod = conf.LinkProduct;
            tb_prod.Text = prod.ToString("0.######");
            tb_prod.Visibility = conf.linkconv ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed; 
            l_prod.Text = conf.calcProduct(conf.dcoeffp, conf.dconvergence).ToString("0.######");
            tb_prod.IsEnabled = conf.linkconv;

            tb_serialp.Text = conf.serialp.ToString();
            tb_serialm.Text = conf.serialm.ToString();
            tb_serial.Text = conf.Serial.ToString();
            tb_serial.IsEnabled = false;
          

        }

       

        public void record()
        {


            conf.lissage = cb_lissage.IsChecked.Value;
            conf.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            conf.reSort = cb_reSort.IsChecked.Value;

            conf.cumul = cb_cumul.IsChecked.Value;
            conf.noAdd = cb_noAdd.IsChecked.Value;
            conf.safe = Convert.ToInt32(tb_safe.Text);
            conf.coeffVirt = Convert.ToDecimal(tb_coeff.Text);

            conf.virtOnlyDisabled = cb_virtOnlyDisabled.IsChecked.Value;
            conf.forceCoeffVirt = cb_forceCoeffVirt.IsChecked.Value;
            conf.virtAlignPrec = cb_virtAlignPrec.IsChecked.Value;
            conf.virtAlignSelected = cb_virtAlignSelected.IsChecked.Value;
            conf.coeffVirtAuto = cb_coeffVirtAuto.IsChecked.Value;
            conf.coeffVirtAdjust = cb_coeffVirtAdjust.IsChecked.Value;

            conf.noAddEnd = cb_noaddEnd.IsChecked.Value;
            conf.noAddAll = cb_noaddAll.IsChecked.Value;

            conf.auto = cb_auto.IsChecked.Value;
            conf.dcoeffp = coeffp; // Convert.ToDecimal(tb_dcoeffp.Text);
            conf.dcoeffm = Convert.ToDecimal(tb_dcoeffm.Text);
            conf.dconvergence = conv; // Convert.ToDecimal(tb_convergence.Text);
            conf.dconvdeltap = Convert.ToDecimal(tb_dconvdeltap.Text);
            conf.dconvdeltam = Convert.ToDecimal(tb_dconvdeltam.Text);

            conf.danticonvergence = Convert.ToDecimal(tb_anti.Text);
            conf.danticonvdeltap = Convert.ToDecimal(tb_antideltap.Text);
            conf.danticonvdeltam = Convert.ToDecimal(tb_antideltam.Text);


            conf.linkconv = cb_link.IsChecked.Value;

            conf.serialp = Convert.ToInt32(tb_serialp.Text);
            conf.serialm = Convert.ToInt32(tb_serialm.Text); 



        }



        private void onchange2()
        {
            try
            {
                var safe = Convert.ToInt32(tb_safe.Text);
                var coeffT = Convert.ToDouble(tb_coeffT.Text);
                var coeff = Math.Pow(coeffT, (1.0 / (double)safe));
                tb_coeff.Text = coeff.ToString();
            }
            catch
            {
            }
        }

        private void tb_safe_KeyUp(object sender, System.Windows.Input.KeyEventArgs e)
        {
            onchange();
        }

        private void tb_coeffT_KeyUp(object sender, System.Windows.Input.KeyEventArgs e)
        {
            onchange2();
        }

        public void onchange()
        {



            if (true == cb_coeffVirtAdjust.IsChecked)
            {
                try
                {
                    var safe = Convert.ToInt32(tb_safe.Text);
                    var coeffEnabled = Convert.ToDecimal(parent.CoeffEnabled);
                    var coeffVirt = Math.Pow((double)coeffEnabled, 1.0 / (safe + 1.0));
                    tb_coeff.Text = coeffVirt.ToString();
                }
                catch
                {
                }
            }

            try
            {
                var safe = Convert.ToInt32(tb_safe.Text);
                var coeff = Convert.ToDouble(tb_coeff.Text);
                var coeffT = Math.Pow(coeff, (double)safe);
                tb_coeffT.Text = coeffT.ToString("0.###");
            }
            catch
            {
            }

        }

        private void cb_link_Click(object sender, RoutedEventArgs e)
        {
            tb_prod.IsEnabled = cb_link.IsChecked.Value;
            tb_prod.Visibility = cb_link.IsChecked.Value ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed; 
          
        }


       
        private void tb_prod_KeyUp(object sender, KeyEventArgs e)
        {
            try
            {
                prod = Convert.ToDecimal(tb_prod.Text);
                conv = conf.calcConv(coeffp, prod); 
                tb_convergence.Text = conv.ToString("0.######");
            }
            catch 
            {
                
                
            }
        }

        private void tb_dcoeffp_KeyUp(object sender, KeyEventArgs e)
        {
            try
            {
                coeffp = Convert.ToDecimal(tb_dcoeffp.Text);
                prod = conf.calcProduct(coeffp, conv);
                tb_prod.Text = prod.ToString("0.######");


            }
            catch
            {
            }
            
        }

        private void tb_convergence_KeyUp(object sender, KeyEventArgs e)
        {
            try
            {
                conv = Convert.ToDecimal(tb_convergence.Text);
                prod = conf.calcProduct(coeffp, conv);
                tb_prod.Text = prod.ToString("0.######");
            }
            catch
            {
            }
        }

        //private void calcProduct()
        //{
        //    try
        //    {
        //        var coeffp = Convert.ToDecimal(tb_dcoeffp.Text);
        //        var convergence = Convert.ToDecimal(tb_convergence.Text);
        //        tb_prod.Text = conf.calcProduct(coeffp, convergence).ToString("0.###");
        //    }
        //    catch
        //    {
        //    }
        //}

    }
}
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;

namespace pdb.util
{
    public enum selectedCoeff
    {
        none,
        noCoeff,
        main,
        min
    }

    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        unselected = 1,
        virtuel = 2,
        tous = 3
    }

    public enum modeMin
    {
        /// <summary>
        /// On ne gère pas
        /// </summary>
        non = 0,
        /// <summary>
        /// Morceaux supérieurs à la limite ( pas d'influence sur le résultat)
        /// </summary>
        orphelin = 1,
        /// <summary>
        /// Morceaux cochés et notés
        /// </summary>
        toujours = 2

    }
    [Serializable]
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;

        public bool enabled;



        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast;

        public decimal expEnabled = 0m;

        public decimal zero = 0m;
        /// <summary>
        /// 
        /// </summary>
        public bool removeEnabled;




        public modeMin cmpMin;

        private ConfMedianneVirt _main;
        private ConfMedianneVirt _min;

        public ConfMedianneVirt Main { get { return _main; } }
        public ConfMedianneVirt Min { get { return _min; } }
        public ConfMedianne()
        {
            _main = new ConfMedianneVirt();
            _min = new ConfMedianneVirt();

        }

        public void makeIdem()
        {
            _min = _main;
        }

        public void duplicateMainIf()
        {
            if (_min == _main)
                _min = new ConfMedianneVirt(_main);
        }
        public ConfMedianne(ConfMedianne o)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;

            enabled = o.enabled;



            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;

            expEnabled = o.expEnabled;

            zero = o.zero;
            removeEnabled = o.removeEnabled;



            cmpMin = o.cmpMin;

            _main = new ConfMedianneVirt(o._main);
            _min = new ConfMedianneVirt(o._min);

        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            buildb("quasi", v => quasi = v);
            buildb("enabled", v => enabled = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);
            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v);
            string _modeMin = "";
            builds("cmpMin", v => _modeMin = v);
            if (!string.IsNullOrEmpty(_modeMin))
                cmpMin = (modeMin)Enum.Parse(typeof(modeMin), _modeMin, true);

            string _removeLast = null;
            builds("removeLast", v => _removeLast = v);
            removeLast = (removeLast)Enum.Parse(typeof(removeLast), _removeLast, true);

            _main = null;
            _min = null;
            var subs = XMLTool.NodeLookUp(child, "virts");
            if (subs != null)
            {
                foreach (XmlNode _n in subs.ChildNodes)
                {
                    if (_n is XmlElement)
                    {
                        if (_main == null)
                        {
                            _main = new ConfMedianneVirt(child, _n as XmlElement);

                        }
                        else if (_min == null)
                        {
                            _min = new ConfMedianneVirt(child, _n as XmlElement);
                        }
                    }
                }
                if (_min == null && _main != null)
                    _min = new ConfMedianneVirt(_main);
            }
        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("cmp");
            write("type", type);
            write("medianne", medianne);
            write("quasi", quasi);
            write("enabled", enabled);
            write("removeFirst", removeFirst);
            write("deleteFirst", deleteFirst);
            write("expEnabled", expEnabled);
            write("zero", zero);
            write("removeEnabled", removeEnabled);
            write("cmpMin", cmpMin);
            write("removeLast", removeLast);

            writeStart("virts");
            _main.save(w);
            _min.save(w);
            writeEnd();

            writeEnd();



        }


        public void auto(selectedCoeff motif)
        {
            if (!enabled)
                return;
            if (motif == selectedCoeff.none)
                return;
            var coeffPrisEncompte = motif > selectedCoeff.noCoeff;
            if (_min == _main || _min.coeffVirt == 1m)
            {
                _main.calcAuto(coeffPrisEncompte, 1);
            }
            else
            {
                if (coeffPrisEncompte)
                {
                    if (motif == selectedCoeff.main)
                        _main.calcAuto(true, 1);
                    if (motif == selectedCoeff.min)
                        _min.calcAuto(true, 1);
                }
                else
                {
                    _main.calcAuto(false, 1);
                    _min.calcAuto(false, 1);
                }
            }
        }
    }

    [Serializable]
    public class ConfMedianneVirt : TuningBase
    {
        const decimal EPSILON = 0.001m;
        public int safe;
        public decimal coeffVirt = 1m;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        public bool coeffVirtAuto;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;
        public decimal dcoeffp;
        public decimal dcoeffm;

        public int serialp = 1;
        public int serialm = 1;
        /// <summary>
        /// atténuation progressive des coeffs
        /// </summary>
        public decimal dconvergence;

        public decimal dconvdeltap = 1m;
        public decimal dconvdeltam = 1m;

        /// <summary>
        /// anti atténuation
        /// </summary>
        public decimal danticonvergence = 1m;
        public decimal danticonvdeltap = 1m;
        public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        public bool linkconv { get { return _linkconv; } set { _linkconv = value; calcProduct(); } }

        private void calcProduct()
        {
            this.linkProduct = calcProduct(this.dcoeffp, this.dconvergence);
        }

        public decimal calcProduct(decimal dcoeffp, decimal dconvergence)
        {
            var linkProduct = this.linkProduct;
            try
            {
                linkProduct = dcoeffp / dconvergence;
                // 1 0,9 -> 10
                // 0.1 0,99 
            }
            catch
            {
            }

            return linkProduct;
        }

        private void calcConv()
        {
            this.dconvergence = calcConv(this.dcoeffp, this.linkProduct);
        }

        public decimal LinkProduct
        {
            get
            {
                if (linkProduct == 0m)
                    calcProduct();
                return linkProduct;
            }
            set
            {
                linkProduct = value;
                calcConv();

            }
        }

        public decimal calcConv(decimal dcoeffp, decimal linkProduct)
        {
            var dconvergence = this.dconvergence;
            try
            {
                // 1- conv = coeff / prod
                dconvergence = dcoeffp / linkProduct; //1/10
            }
            catch
            {

            }
            return dconvergence;
        }

        private bool? lastAutoDirection;
        private int _nbSameDirection;

        public ConfMedianneVirt()
        { }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            dcoeffp = o.dcoeffp;
            dcoeffm = o.dcoeffm;
            dconvergence = o.dconvergence;
            dconvdeltap = o.dconvdeltap;
            dconvdeltam = o.dconvdeltam;
            danticonvergence = o.danticonvergence;
            danticonvdeltap = o.danticonvdeltap;
            danticonvdeltam = o.danticonvdeltam;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            _nbSameDirection = o._nbSameDirection;
        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {

            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);
            builddec("dcoeffp", v => dcoeffp = v);
            builddec("dcoeffm", v => dcoeffm = v);
            builddec("dconvergence", v => dconvergence = v);
            builddec("dconvdeltap", v => dconvdeltap = v);
            builddec("dconvdeltam", v => dconvdeltam = v);

            builddec("danticonvergence", v => danticonvergence = v);
            builddec("danticonvdeltap", v => danticonvdeltap = v);
            builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serial", v => _nbSameDirection = v);


        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("coeffVirt", coeffVirt);
            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);
            write("dcoeffp", dcoeffp);
            write("dcoeffm", dcoeffm);
            write("dconvergence", dconvergence);
            write("dconvdeltap", dconvdeltap);
            write("dconvdeltam", dconvdeltam);

            write("danticonvergence", danticonvergence);
            write("danticonvdeltap", danticonvdeltap);
            write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);
            write("serial", _nbSameDirection);
            writeEnd();
        }

        public int Serial { get { return _nbSameDirection; } }

        public void calcAuto(bool selectedByCoeff, int nb)
        {
            if (!auto)
                return;
            var last = lastAutoDirection;
            lastAutoDirection = selectedByCoeff;
            if (selectedByCoeff)
                _nbSameDirection--;
            else
                _nbSameDirection++;
            var lastProduct = linkProduct;


            var c0 = dcoeffp;
            /// au debut dconvergence à effet  fort 0.9 doit arriver à 0.999
            /// // quand j'applique la convergence, je fait baisser son effet

            if (dconvergence > 0 && last.HasValue)
            {
                var aux = dconvergence;
                if (last != selectedByCoeff)
                {
                    if (selectedByCoeff)
                    {
                        //dcoeffp *= dconvergence;
                        //dcoeffm *= dconvergence;
                        //if (dcoeffp < EPSILON) dcoeffp = EPSILON;
                        //if (dcoeffm < EPSILON) dcoeffm = EPSILON;

                        // la convergence est maintenant directement le % de baisse
                        var r = 1 - dconvergence;
                        dcoeffp *= r;
                        dcoeffm *= r;
                        var rr = 0m;
                        if (dcoeffp > 0)
                            rr = dcoeffm / dcoeffp;
                        if (dcoeffp < EPSILON)
                        { dcoeffp = EPSILON; if (rr > 0m) dcoeffm = rr * dcoeffp; }
                        if (dcoeffm < EPSILON)
                        { dcoeffm = EPSILON; if (rr > 0m) dcoeffp = dcoeffm / rr; }


                        _nbSameDirection = 0;
                        lastAutoDirection = null;



                        if (_linkconv)
                            calcConv();
                        else
                        {

                            //  var delta = 1 - dconvergence; // 1- 0.9 = 0.1 // 1-0.1 = 0.9
                            dconvergence *= dconvdeltam; // 0.09 // 0.81
                            //  dconvergence = 1 - delta; // 0.9 -> 0.91 // 0.1-> 0.19
                        }



                        danticonvergence *= danticonvdeltam;
                        if (danticonvergence < 1m) danticonvergence = 1;

                        //delta = danticonvergence - 1; // 0.1
                        //delta *= danticonvdeltam;  //0.09; 
                        //    danticonvergence = 1+delta; // 1.1 -> 1.09
                    }



                }
                else
                {
                    bool applyanti = false;
                    if (selectedByCoeff && -_nbSameDirection > serialm)
                        applyanti = true;
                    else if (!selectedByCoeff && _nbSameDirection > serialp)
                        applyanti = true;
                    if (applyanti)
                    {
                        dcoeffp *= danticonvergence;
                        dcoeffm *= danticonvergence;
                        danticonvergence *= danticonvdeltap;
                    }
                    if (_linkconv)
                        calcConv();
                    else if (applyanti)
                    {

                        //   var delta = 1 - dconvergence; // 1- 0.9 = 0.1 // 1-0.1 = 0.9
                        dconvergence *= dconvdeltap; // 0.11 // 0.99
                        //    dconvergence = 1 - delta; // 0.9 -> 0.89 // 0.01
                        if (dconvergence > 1)
                            dconvergence = 1;
                    }





                }
                misc.log("convergence {0:0.##}->{1:0.######}", c0, dcoeffp);
                misc.log("evol convergence {0:0.######}->{1:0.######}", aux, dconvergence);
            }

            if (selectedByCoeff)
                makeDelta(false, dcoeffm, nb);
            else
                makeDelta(true, dcoeffp, nb);



        }

        private void makeDelta(bool sens, decimal delta, int nb)
        {
            try
            {
                decimal coeffT = (decimal)Math.Pow((double)coeffVirt, safe);
                string montee = sens ? "up" : "down";
                var c0 = coeffT;
                if (sens)
                {
                    for (int i = 0; i < nb; i++)
                        coeffT += delta;
                }
                else
                {
                    for (int i = 0; i < nb; i++)
                        coeffT -= delta;
                }
                if (coeffT < 1)
                    coeffT = 1;

                var coeff = (decimal)Math.Pow((double)coeffT, (1.0 / (double)safe));

                misc.log("{0} {1:0.######} {2:0.######}->{3:0.######}", montee, delta, c0, coeffT);
                coeffVirt = coeff;
            }
            catch
            {
            }


        }

    }
    public class CalcMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        //public static DecimalIndex getMedianneLight(IList<decimal> list, ConfMedianne mode)
        //{

        //    DecimalIndex ret = new DecimalIndex();
        //    var medianne = getMedianne_(list, mode.medianne);
        //    ret.d = medianne;
        //    ret.index = index;
        //    if (list.Count == 1)
        //        return ret;

        //    int indexV = 0;

        //    int count = list.Count;

        //    if (mode.safe > 0)
        //    {

        //        int i0 = count - 1;

        //        for (int i = 0; i < count; i++)
        //        {
        //            if (list[i] == 0m)
        //            {
        //                i0 = i;
        //                break;
        //            }
        //        }
        //        if (i0 == 0)
        //            return ret;

        //        //for (int i00 = 1; i00 <= i0; i00++)
        //        //{
        //        //    decimal coeff = (decimal)i00 / (decimal)i0;
        //        List<decimal> _list = new List<decimal>(list);
        //        //for (int i = i00; i < count; i++)
        //        //    _list[i] = 0m;
        //        //liste partielle originale
        //        //  List<decimal> _list0 = new List<decimal>(_list);
        //        int _count = Math.Min(count, i0 + mode.safe);
        //        decimal[] virt = new decimal[_count];
        //        for (int i = 0; i < i0; i++)
        //        {
        //            decimal _coeff = 1m;
        //            decimal _base = _list[i];
        //            for (int j = i + 1; j < _count; j++)
        //            {
        //                _coeff /= mode.coeffVirt;
        //                virt[j] += _base * _coeff;
        //            }
        //        }

        //        decimal value = int.MaxValue;
        //        int ii = 0;
        //        for (ii = 1; ii < count && ii < _count; ii++)
        //        {
        //            value = _list[ii];
        //            var calc = virt[ii];
        //            if (value < calc)
        //            {
        //                if (mode.lissage || value == 0m)
        //                {
        //                    value = calc;
        //                    _list[ii] = value;
        //                }

        //            }
        //            else
        //                indexV = ii;
        //        }
        //        if (mode.removeEpsilon)
        //        {
        //            // j'ai 5 virtuel alors que j'ai deux safe
        //            ///xx---
        //            int nb = 0;
        //            for (int i = indexV + 1; i < _count; i++)
        //            {
        //                nb++;
        //                if (nb <= mode.safe)
        //                    continue;
        //                _list[i] = 0m;
        //            }

        //        }

        //        if (mode.reSort)
        //        {
        //            _list.Sort();
        //            _list.Reverse();
        //        }

        //        //for (int i = 0; i < nbAdd; i++)
        //        //    _list.RemoveAt(0); 


        //        var retAux = calcmedianneVirt(_list, mode.medianne, mode.quasi);
        //        //retAux.d *= coeff;
        //        if (retAux > ret)
        //        {
        //            ret = retAux;
        //            //  ret.index += nbAdd; 
        //        }
        //        //}


        //    }
        //    else
        //        ret = calcmedianneVirt(list, mode.medianne, mode.quasi);

        //    //  ret = getRapport(ret);


        //    return ret;
        //}


        public static DecimalIndex getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt)
        {
            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, coeffMedianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int count = list.Count;


            // decimal ret = medianne; //int.MinValue;

            if (nbVirt > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                for (int i00 = 1; i00 <= i0; i00++)
                {
                    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>(list);
                    for (int i = i00; i < count; i++)
                        _list[i] = 0m;
                    int _count = Math.Min(count, i00 + nbVirt);
                    decimal[] virt = new decimal[_count];
                    for (int i = 0; i < i00; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= 10m;
                            virt[j] += _base * _coeff;
                        }
                    }
                    // decimal prec = -1m;  
                    int _nbVirt = 0;
                    decimal value = int.MaxValue;
                    int ii = 0;
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        //   prec = value;
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (_nbVirt >= nbVirt)
                                break;
                            _nbVirt++;
                            value = calc;  //Math.Min(prec, calc);
                            _list[ii] = value;

                        }
                        else
                            _nbVirt = 0;
                    }
                    for (int i = ii; i < count && i < _count; i++)
                    {
                        _list[i] = 0m;
                    }
                    //_list.Sort();
                    //_list.Reverse(); 



                    var retAux = calcmedianneVirt(_list, coeffMedianne, quasi);
                    retAux.d *= coeff;
                    if (retAux > ret)
                        ret = retAux;
                }


            }
            else
                ret = calcmedianneVirt(list, coeffMedianne, quasi);

            //  ret = getRapport(ret);

            //if (ret < medianne)
            //    ret = medianne;
            return ret;
        }

        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10((double)rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, (double)ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;
using System.Linq;

namespace pdb.gen.albums
{


    public class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;

        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private List<Piece> list = new List<Piece>();
        private static int _sID = 0;
        private int _dID;


        public Album(string name)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string equivLight0 = "";
        public string EquivLight0 { get { return equivLight0; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        public bool Moved { get; set; }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        private HashList<Piece> _tracksSortByClassement;
        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int IndexClass(Piece p)
        {
            return Tracks.IndexOf(p);
        }

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}
        HashList<Piece> trackSortedByExportPriority;
        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0; ;
                    int dx = ix - inext;
                    int dy = iy - inext;

                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.RapportClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.RapportClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    cmp = Math.Abs(dx).CompareTo(Math.Abs(dy));
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);
                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }



        public void makeSort(decimal coeffEnabled, ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            try
            {
                selectedCoeff = util.selectedCoeff.noCoeff;
                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = conf.AlbumMoyOffset;
                int count = list.Count;
                if (count == 0)
                    return;
                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                }

                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                decimal moy = 0m;
                #region calcul brut
                #region init
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    //if (coeffEnabled != 1m && p.Enabled)
                    //{
                    //    rapportClassement /= coeffEnabled;
                    //}
                    p.setClassementVirtuel(list[i].RapportClassement);

                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                list.Sort(new PieceClassementComparer());
                listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].VirtualClassement);

                #endregion

                if (count > 0)
                    moy /= count;
                classMoy = moy;



                var med = CalcMedianne.getMedianne(listSortedValues, medianne);
                classementValue = med.d;
                if (classementValue > 0m)
                    list[med.index].Medianne = true;

                var _med0 = AlbumMedianne.getMedianneLight(new List<Piece>(list), coeffEnabled, mode0, false);




                equivLight0 = Piece.getClassementEquiv(_med0.d);

                #endregion
                #region calcul virtuel
                #region init (prise en compte coeff des enabled)
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    if (coeffEnabled != 1m && p.Enabled)
                    {
                        rapportClassement /= coeffEnabled;
                    }
                    p.setClassementVirtuel(rapportClassement);
                    p.setClassementVirtuel2(rapportClassement);
                }
                list.Sort(new PieceClassementComparer());
                #endregion
                int i0 = 0;
                AlbumMedianne.buildVirtual(new List<Piece>(list), mode, mode.Min, coeffEnabled, false, ref i0);

                med = AlbumMedianne.getMedianneLight(new List<Piece>(list), coeffEnabled, mode, true);
                classementValueLight = med.d;

                #endregion

                equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 


                moyenne = Piece.getClassementEquiv(classMoy);
                var modeMin = mode.cmpMin;


                if (modeMin == util.modeMin.orphelin)
                {
                    Piece min = null;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {
                        var v = p.RapportClassement;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v < _min)
                            {
                                _min = v;
                                min = p;
                            }
                        }
                    }

                    if (min != null)
                    {
                        Next = min;
                        _min = min.VirtualClassement2;
                        if (_min > classementValueLight)
                            classementValueLight = _min;
                    }
                }
                else if (modeMin == util.modeMin.toujours)
                {
                    Piece nextZero = null;

                    Piece min = null;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {
                        var v = p.RapportClassement;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v == 0)
                            {
                                if (nextZero == null)
                                    nextZero = p;
                            }

                            else if (v < _min)
                            {
                                _min = v;
                                min = p;
                            }
                        }
                    }

                    if (min != null)
                    {
                        _min = min.VirtualClassement2;
                    }

                    if (nextZero != null)
                    {
                        // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                        // j'applique le seuil que s'il est inférieur à la médiane
                        if (_min < classementValueLight)
                        {
                            Next = min;
                            classementValueLight = _min;

                            if (min.CoeffVirtuel2 > 1)
                                selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                        }
                        else
                        {
                            var p = list[med.index];
                            if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                                selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;
                        }
                    }
                    else
                    {
                        // tous notés => on prend le plus faible
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (min.CoeffVirtuel2 > 1) // if (min.CoeffVirtuel2 > 1)
                                selectedCoeff = selectedCoeff.min; //selectedByCoeff2 = true;
                        }
                        Next = min;
                    }

                }

                //if (modeMin > modeMin.non)
                //{
                //    int nb = 0;
                //    Piece min = null;
                //    decimal _min = int.MaxValue;
                //    foreach (Piece p in list)
                //    {
                //        var v = p.RapportClassement;
                //        if (v > 0 && !p.Enabled)
                //            nb++;
                //        if (modeMin == util.modeMin.orphelin || v > 0)
                //        {
                //            if (p.Enabled && FileRegister.Exist(p.Location))
                //            {

                //                if (v < _min)
                //                {
                //                    _min = v;
                //                    min = p;
                //                }
                //            }
                //        }
                //    }

                //    if (min != null)
                //    {
                //        _min = min.VirtualClassement;
                //        if (nb > 0)
                //            _min *= (decimal)nb / (decimal)count;
                //        if (modeMin == modeMin.toujours || _min > classementValueLight)
                //            classementValueLight = _min;
                //    }


                //}
                equivLight = Piece.getClassementEquiv(classementValueLight);


            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }



        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return name.Equals(o.name);
        }
        public override int GetHashCode()
        {
            return name.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {
                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }
    }
}
]]></content>
  </file>
</db>
