<db path="C:\Bernard\db1\PieceDb3Ref">
   <file path="\pdb.player\Vue\ClassementCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.ClassementCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid >
        <!--<Grid.ColumnDefinitions>
            <ColumnDefinition Width="*" />
            <ColumnDefinition Width="3" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>-->
        <!--<DataGrid  Grid.Column="0" DockPanel.Dock="Bottom" 
                       Name="dgAlbum" 
                       AutoGenerateColumns="False" 
                       ScrollViewer.CanContentScroll="True" 
                       SelectedItem="{Binding SelectedTrackInAlbumView}">

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding isSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>

            <DataGrid.Columns>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" />
                <DataGridTextColumn Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement}"/>
            </DataGrid.Columns>

        </DataGrid>
        <GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" />-->

        <Grid Grid.Column="0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="*" />
                <RowDefinition Height="3" />
                <RowDefinition Height="*" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>

            <Grid Grid.Row="0" Margin="5">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto" />
                    <ColumnDefinition Width="120" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="Auto" />
                </Grid.ColumnDefinitions>
                <CheckBox Grid.Column="0"  Name="cbEnabled" ToolTip="Afficher seulement les désactivés" IsChecked="{Binding OnlyDisabled, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"  />
                <TextBox Grid.Column="1"  Name="TbClass"   Text="{Binding Classement, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource cl} }"  />
                <TextBox Grid.Column="2"  Name="TbName" Text="{Binding Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                <Button Grid.Column="3" Name="btRecord" DockPanel.Dock="Right" Content="Enregistrer"  Command="{Binding Record,UpdateSourceTrigger=PropertyChanged}" />
            </Grid>


            <!--<ListView  DockPanel.Dock="Top" Grid.Row="0" Name="dg"  ScrollViewer.CanContentScroll="True" >
                <ListView.ItemContainerStyle>
                    <Style TargetType="{x:Type ListViewItem}">
                        <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                        <Setter Property="FontWeight" Value="Normal" />
                        <Style.Triggers>
                            <Trigger Property="IsSelected" Value="True">
                                <Setter Property="FontWeight" Value="Bold" />
                            </Trigger>
                        </Style.Triggers>
                    </Style>
                </ListView.ItemContainerStyle>
                <ListView.View>
                    <GridView>
                        <GridViewColumn DisplayMemberBinding="{Binding Enabled}"/>
                        <GridViewColumn DisplayMemberBinding="{Binding Name}"/>
                        <GridViewColumn DisplayMemberBinding="{Binding Classement}"/>
                    </GridView>
                </ListView.View>
            </ListView>-->

            <DataGrid Grid.Row="1" AutoGenerateColumns="False"  DockPanel.Dock="Top" Name="dg"  ScrollViewer.CanContentScroll="True" 
                      SelectedItem="{Binding SelectedTrackInClassView}" >
                <DataGrid.ContextMenu>
                    <ContextMenu>
                        <MenuItem Header="infos" Command="{Binding}"/>
                    </ContextMenu>
                </DataGrid.ContextMenu>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="FontWeight" Value="Normal" />
                        <Style.Triggers>
                            <Trigger Property="IsSelected" Value="True">
                                <Setter Property="Foreground" Value="Brown" />
                            </Trigger>
                            <DataTrigger Binding="{Binding Exists}" Value="False">
                                <Setter Property="Foreground" Value="LightGray" />
                            </DataTrigger>
                            
                        </Style.Triggers>
                    </Style>
                </DataGrid.ItemContainerStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">
                        <EventSetter Event="MouseDoubleClick" Handler="dgMouseDoubleClick" />
                        <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="DataGridRow.Background" Value="White" />
                        <Style.Triggers>
                            <Trigger Property="DataGridRow.IsSelected" Value="True">
                                <Setter Property="DataGridRow.Background" Value="Brown" />
                            </Trigger>
                          

                        </Style.Triggers>
                    </Style>
                </DataGrid.RowStyle>
                <DataGrid.Columns>
                    <DataGridCheckBoxColumn Header="" Binding="{Binding Enabled}" />
                    <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                    <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl} }"/>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                    <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                    <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay}"/>

                </DataGrid.Columns>

            </DataGrid>


            <GridSplitter Grid.Row="2" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True" />

            <!--<Grid Grid.Row="3" HorizontalAlignment="Stretch">
                <DataGrid ItemsSource="{Binding}" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" 
                       Name="dgStat"  IsReadOnly="True"
          Width="{Binding RelativeSource={RelativeSource AncestorType={x:Type DockPanel}}, Path=ActualWidth}"
                       AutoGenerateColumns="False" >
                    <DataGrid.Columns>
                        <DataGridTextColumn Header="-5" Binding="{Binding -5}"/>
                        <DataGridTextColumn Header="-4" Binding="{Binding -4}"/>
                        <DataGridTextColumn Header="-3" Binding="{Binding -3}"/>
                        <DataGridTextColumn Header="-2" Binding="{Binding -2}"/>
                        <DataGridTextColumn Header="-1" Binding="{Binding -1}"/>
                        <DataGridTextColumn Header="0" Binding="{Binding  0}" >
                            
                        </DataGridTextColumn>
                        <DataGridTextColumn Header="1" Binding="{Binding  1}"/>
                        <DataGridTextColumn Header="2" Binding="{Binding  2}"/>
                        <DataGridTextColumn Header="3" Binding="{Binding  3}"/>
                        <DataGridTextColumn Header="4" Binding="{Binding  4}"/>
                        <DataGridTextColumn Header="5" Binding="{Binding  5}"/>
                    </DataGrid.Columns>
                    <DataGrid.ItemTemplate>
                        <DataTemplate>
                            <TextBlock Text ="{Binding}" Width="Auto"  HorizontalAlignment="Stretch"/>
                        </DataTemplate>
                    </DataGrid.ItemTemplate>
                </DataGrid>
            </Grid>-->
            <Grid Name="tab" Grid.Row="3" >

            </Grid>
            <Grid Grid.Row="4">
                <Grid.RowDefinitions>
                    <RowDefinition  Height="Auto"/>
                    <RowDefinition />
                    <RowDefinition />

                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>
                <!--<TextBlock Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="3" Name="d02" Text="{Binding D02}" />
            <TextBlock Grid.Row="0" Grid.Column="3" Grid.ColumnSpan="3" Name="d35" Text="{Binding D35}" />
            <TextBlock Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="2" Name="d01" Text="{Binding D01}" />
            <TextBlock Grid.Row="1" Grid.Column="2" Grid.ColumnSpan="2" Name="d23" Text="{Binding D23}" />
            <TextBlock Grid.Row="1" Grid.Column="4" Grid.ColumnSpan="2" Name="d45" Text="{Binding D45}" />-->


                <TextBlock Grid.Row="1" Text="{Binding Path=Tracks.Count}" />
                <TextBlock Grid.Row="1" Grid.Column="1" Name="d02" Text="{Binding D02}" />
                <TextBlock Grid.Row="1" Grid.Column="2" Name="d35" Text="{Binding D35}" />
                <TextBlock Grid.Row="1" Grid.Column="3" Name="d01" Text="{Binding D01}" />
                <TextBlock Grid.Row="1" Grid.Column="4" Name="d23" Text="{Binding D23}" />
                <TextBlock Grid.Row="1" Grid.Column="5" Name="d45" Text="{Binding D45}" />
                <TextBlock Grid.Row="2" Grid.Column="0" Name="d0" Text="{Binding D0}" />
                <TextBlock Grid.Row="2" Grid.Column="1" Name="d1" Text="{Binding D1}" />
                <TextBlock Grid.Row="2" Grid.Column="2" Name="d2" Text="{Binding D2}" />
                <TextBlock Grid.Row="2" Grid.Column="3" Name="d3" Text="{Binding D3}" />
                <TextBlock Grid.Row="2" Grid.Column="4" Name="d4" Text="{Binding D4}" />
                <TextBlock Grid.Row="2" Grid.Column="5" Name="d5" Text="{Binding D5}" />
            </Grid>

        </Grid>
    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ConfAlbumSortW" Height="194" Width="978" Loaded="Window_Loaded">
    <Grid Height="116" Width="861">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="182*" />
            <ColumnDefinition Width="201*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="7*" />
        </Grid.RowDefinitions>
        <Grid Grid.ColumnSpan="2" Margin="0,0,-172,0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />

            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="4" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="4" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="5" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="6" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="4" />
            <TextBox  Grid.Row="0" Grid.Column="7" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="0" Grid.Column="8" Name="tb_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="9" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="10" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="4" />
            <ComboBox ToolTip="removelast" Grid.Row="0" Grid.Column="11" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="0" Grid.Column="12" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="13" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="4" />
            <TextBox  Grid.Row="0" Grid.Column="14" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="15" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="4" />
            <TextBox  Grid.Row="0" Grid.Column="16" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="4" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="4" Name="cb2_lissage" ToolTip="lissage" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="5" Name="cb2_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="6" Name="cb2_reSort" ToolTip="reSort" Margin="5" Padding="4" />
            <TextBox  Grid.Row="1" Grid.Column="7" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="8" Name="tb2_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="9" Name="cb2_removeFirst" ToolTip="removeFirst" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="10" Name="cb2_deleteFirst" ToolTip="deleteFirst" Margin="5" Padding="4" />
            <ComboBox ToolTip="removelast" Grid.Row="1" Grid.Column="11" Name="cbx2_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="1" Grid.Column="12" Name="cb2_cumul" ToolTip="cumul" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="13" Name="cb2_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="4" />
            <TextBox  Grid.Row="1" Grid.Column="14" Name="tb2_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="15" Name="cb2_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="4" />
            <TextBox  Grid.Row="1" Grid.Column="16" Name="tb2_zero" Width="120" ToolTip="zéro" Margin="5" />
        </Grid>
        
        <StackPanel Grid.Row="2"  Orientation="Horizontal"  HorizontalAlignment="Right" Margin="0,5" Grid.Column="1" Width="87">
            <Button Grid.Row="2" Name="bt_cancel" Height="25" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" />
            <Button Grid.Row="2" Name="bt_ok" Height="25" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" />
        </StackPanel>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml.cs">
    <content><![CDATA[using System;
using System.Windows;
using pdb.gen.Tuning;
using pdb.gen;
using pdb.db.piece.type;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfAlbumSortW.xaml
    /// </summary>
    public partial class ConfAlbumSortW : Window
    {
        private ConfAlbumSort conf;
        public ConfAlbumSortW()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(ConfAlbumSortW_Loaded);
        }

        void ConfAlbumSortW_Loaded(object sender, RoutedEventArgs e)
        {
            display();
        }

        public ConfAlbumSortW(ConfAlbumSort conf)
            : this()
        {
            this.conf = conf;
        }

        void display()
        {
            var list = conf.Composants;
            var item1 = list[0];
            cb_enabled.IsChecked = item1.enabled;
            cbxSort.SelectedIndex = (int)item1.type;
            tb_medianne.Text = item1.medianne.ToString();
            cb_quasi.IsChecked = item1.quasi;
            cb_lissage.IsChecked = item1.lissage;
            cb_removeEpsilon.IsChecked = item1.removeEpsilon;
            cb_reSort.IsChecked = item1.reSort;
            cb_removeFirst.IsChecked = item1.removeFirst;
            cb_deleteFirst.IsChecked = item1.deleteFirst;
            cbx1_removeLast.SelectedIndex = (int)item1.removeLast;
            cb_cumul.IsChecked = item1.cumul;
            cb_noAdd.IsChecked = item1.noAdd;
            tb_safe.Text = item1.safe.ToString();
            tb_coeff.Text = item1.coeffVirt.ToString();
            tb_exp.Text = item1.expEnabled.ToString();
            tb_zero.Text = Piece.getClassementEquiv(item1.zero);
            cb_removeEnabled.IsChecked = item1.removeEnabled; 
            

            if (list.Count > 1)
            {
                item1 = list[1];
                cb2_enabled.IsChecked = item1.enabled;
                cbx2Sort.SelectedIndex = (int)item1.type;
                tb2_medianne.Text = item1.medianne.ToString();
                cb2_quasi.IsChecked = item1.quasi;
                cb2_lissage.IsChecked = item1.lissage;
                cb2_removeEpsilon.IsChecked = item1.removeEpsilon;
                cb2_reSort.IsChecked = item1.reSort;
                cb2_removeFirst.IsChecked = item1.removeFirst;
                cb2_deleteFirst.IsChecked = item1.deleteFirst;
                cbx2_removeLast.SelectedIndex = (int)item1.removeLast;
                cb2_cumul.IsChecked = item1.cumul;
                cb2_noAdd.IsChecked = item1.noAdd;
                tb2_safe.Text = item1.safe.ToString();
                tb2_coeff.Text = item1.coeffVirt.ToString();
                tb2_exp.Text = item1.expEnabled.ToString();
                tb2_zero.Text = Piece.getClassementEquiv(item1.zero);
                cb2_removeEnabled.IsChecked = item1.removeEnabled; 
            }
        }
        void record()
        {
            var list = conf.Composants;
            var item1 = list[0];
            item1.enabled = cb_enabled.IsChecked.Value;
            item1.type = (util.medianneMode)cbxSort.SelectedIndex;
            item1.medianne = Convert.ToDecimal(tb_medianne.Text);
            item1.quasi = cb_quasi.IsChecked.Value;
            item1.lissage = cb_lissage.IsChecked.Value;
            item1.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            item1.reSort = cb_reSort.IsChecked.Value;
            item1.removeFirst = cb_removeFirst.IsChecked.Value;
            item1.deleteFirst = cb_deleteFirst.IsChecked.Value;
            item1.removeLast = (util.removeLast)cbx1_removeLast.SelectedIndex;
            item1.cumul = cb_cumul.IsChecked.Value;
            item1.noAdd = cb_noAdd.IsChecked.Value;
            item1.safe = Convert.ToInt32(tb_safe.Text);
            item1.coeffVirt = Convert.ToDecimal(tb_coeff.Text);
            item1.expEnabled = Convert.ToDecimal(tb_exp.Text);
            var cl = Classement.create(tb_zero.Text);
            item1.zero = cl.RapportClassement;
            item1.removeEnabled = cb_removeEnabled.IsChecked.Value; 

            if (list.Count > 1)
            {
                if (cbx2Sort.SelectedIndex == 0)
                {
                    list.RemoveAt(1);
                    return;
                }
            }
            else
            {
                if (cbx2Sort.SelectedIndex > 0)
                {
                    item1 = new util.ConfMedianne();
                    list.Add(item1);
                }
            }

            if (list.Count > 1)
            {
                item1 = list[1];

                item1.enabled = cb2_enabled.IsChecked.Value;
                item1.type = (util.medianneMode)cbx2Sort.SelectedIndex;
                item1.medianne = Convert.ToDecimal(tb2_medianne.Text);
                item1.quasi = cb2_quasi.IsChecked.Value;
                item1.lissage = cb2_lissage.IsChecked.Value;
                item1.removeEpsilon = cb2_removeEpsilon.IsChecked.Value;
                item1.reSort = cb2_reSort.IsChecked.Value;
                item1.removeFirst = cb2_removeFirst.IsChecked.Value;
                item1.deleteFirst = cb2_deleteFirst.IsChecked.Value;
                item1.removeLast = (util.removeLast)cbx2_removeLast.SelectedIndex;
                item1.cumul = cb2_cumul.IsChecked.Value;
                item1.noAdd = cb2_noAdd.IsChecked.Value;
                item1.safe = Convert.ToInt32(tb2_safe.Text);
                item1.coeffVirt = Convert.ToDecimal(tb2_coeff.Text);
                item1.expEnabled = Convert.ToDecimal(tb2_exp.Text);
                item1.zero = Convert.ToDecimal(tb2_zero.Text);

                cl = Classement.create(tb2_zero.Text);
                item1.zero = cl.RapportClassement;
                item1.removeEnabled = cb2_removeEnabled.IsChecked.Value; 
            }
        }

        private void bt_cancel_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }

        private void bt_ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close();
            conf.Calcul();
            App.go();
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;

namespace pdb.util
{
    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        virtuel = 1,
        tous = 2
    }
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;
        public int safe;
        public decimal coeffVirt = 10m;
        public bool enabled;
        public bool lissage;
        public bool removeEpsilon;
        public bool reSort;
        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast; 
        public bool cumul;
        public decimal expEnabled = 0m;
        public bool noAdd;
        public decimal zero = 0m;
        public bool removeEnabled; 
        public ConfMedianne()
        {
        }
        public ConfMedianne(ConfMedianne o)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            enabled = o.enabled;
            lissage = o.lissage;
            removeEpsilon = o.removeEpsilon;
            reSort = o.reSort;
            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;
            cumul = o.cumul;
            expEnabled = o.expEnabled;
            noAdd = o.noAdd;
            zero = o.zero;
            removeEnabled = o.removeEnabled; 
        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildb("quasi", v => quasi = v);
            buildi("safe", v => safe = v);
            buildb("enabled", v => enabled = v);
            buildb("lissage", v => lissage = v);
            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("reSort", v => reSort = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);
            buildb("cumul", v => cumul = v);
            buildb("noAdd", v => noAdd = v); 
            bool? _removeLast = null; 
            buildbn("removeLast", v => _removeLast = v);
            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v); 
            switch (_removeLast)
            {
                case true: removeLast = util.removeLast.tous; break; 
                case false: removeLast = util.removeLast.non; break;
                default: removeLast = util.removeLast.virtuel; break; 
            }
        }
    }
    public class CalcMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        public static DecimalIndex getMedianneLight(IList<decimal> list, ConfMedianne mode)
        {

            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, mode.medianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int indexV = 0;

            int count = list.Count;

            if (mode.safe > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                List<decimal> _list = new List<decimal>(list);
                //for (int i = i00; i < count; i++)
                //    _list[i] = 0m;
                //liste partielle originale
                //  List<decimal> _list0 = new List<decimal>(_list);
                int _count = Math.Min(count, i0 + mode.safe);
                decimal[] virt = new decimal[_count];
                for (int i = 0; i < i0; i++)
                {
                    decimal _coeff = 1m;
                    decimal _base = _list[i];
                    for (int j = i + 1; j < _count; j++)
                    {
                        _coeff /= mode.coeffVirt;
                        virt[j] += _base * _coeff;
                    }
                }

                decimal value = int.MaxValue;
                int ii = 0;
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = _list[ii];
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (mode.lissage || value == 0m)
                        {
                            value = calc;
                            _list[ii] = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (mode.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= mode.safe)
                            continue;
                        _list[i] = 0m;
                    }

                }

                if (mode.reSort)
                {
                    _list.Sort();
                    _list.Reverse();
                }

                //for (int i = 0; i < nbAdd; i++)
                //    _list.RemoveAt(0); 


                var retAux = calcmedianneVirt(_list, mode.medianne, mode.quasi);
                //retAux.d *= coeff;
                if (retAux > ret)
                {
                    ret = retAux;
                    //  ret.index += nbAdd; 
                }
                //}


            }
            else
                ret = calcmedianneVirt(list, mode.medianne, mode.quasi);

            //  ret = getRapport(ret);


            return ret;
        }


        public static DecimalIndex getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt)
        {
            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, coeffMedianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int count = list.Count;


            // decimal ret = medianne; //int.MinValue;

            if (nbVirt > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                for (int i00 = 1; i00 <= i0; i00++)
                {
                    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>(list);
                    for (int i = i00; i < count; i++)
                        _list[i] = 0m;
                    int _count = Math.Min(count, i00 + nbVirt);
                    decimal[] virt = new decimal[_count];
                    for (int i = 0; i < i00; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= 10m;
                            virt[j] += _base * _coeff;
                        }
                    }
                    // decimal prec = -1m;  
                    int _nbVirt = 0;
                    decimal value = int.MaxValue;
                    int ii = 0;
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        //   prec = value;
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (_nbVirt >= nbVirt)
                                break;
                            _nbVirt++;
                            value = calc;  //Math.Min(prec, calc);
                            _list[ii] = value;

                        }
                        else
                            _nbVirt = 0;
                    }
                    for (int i = ii; i < count && i < _count; i++)
                    {
                        _list[i] = 0m;
                    }
                    //_list.Sort();
                    //_list.Reverse(); 



                    var retAux = calcmedianneVirt(_list, coeffMedianne, quasi);
                    retAux.d *= coeff;
                    if (retAux > ret)
                        ret = retAux;
                }


            }
            else
                ret = calcmedianneVirt(list, coeffMedianne, quasi);

            //  ret = getRapport(ret);

            //if (ret < medianne)
            //    ret = medianne;
            return ret;
        }

        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10((double)rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, (double)ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }


        private List<Piece> list = new List<Piece>();
        private static int _sID = 0;
        private int _dID;


        public Album(string name)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string equivLight0 = "";
        public string EquivLight0 { get { return equivLight0; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        public List<Piece> Tracks
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceClassementVirtualComparer());
                return l;
            }
        }


        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        public void makeSort(ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            try
            {
                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = conf.AlbumMoyOffset;
                int count = list.Count;
                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric)
                        classed = true;
                }

                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;



                listSortedValues = new List<decimal>();
                list.Sort(new PieceClassementValueComparer());
                decimal moy = 0m;
                for (int i = 0; i < count; i++)
                {
                    var rapportClassement = list[i].RapportClassement;
                    list[i].setClassementVirtuel(rapportClassement);
                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;

                    listSortedValues.Add(rapportClassement);
                }
                if (count > 0)
                    moy /= count;
                classMoy = moy;


                var med = CalcMedianne.getMedianne(listSortedValues, medianne);
                classementValue = med.d;
                if (classementValue > 0m)
                    list[med.index].Medianne = true;

                med = AlbumMedianne.getMedianneLight(new List<Piece>(list), mode, true);
                classementValueLight = med.d;



                var _med = AlbumMedianne.getMedianneLight(listSortedValues, list, mode0, false);
                equivLight0 = Piece.getClassementEquiv(_med.d);

                //int iequiv = CalcMedianne.getEquiv(reference, m_rank.SortValue, 0, reference.Count - 1);
                //equiv = pieces[iequiv];
                equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 
                equivLight = Piece.getClassementEquiv(classementValueLight);

                moyenne = Piece.getClassementEquiv(classMoy);
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }



        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Collections;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(List<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        public static DecimalIndex getMedianneLight(List<decimal> list, List<Piece> pieces, ConfMedianne mode, bool signal)
        {

            DecimalIndex ret0 = new DecimalIndex();

            var _zero = mode.zero; 
            var medianne = getMedianne_(list, mode.medianne);
            ret0.d = medianne;
            ret0.index = index;
            DecimalIndex ret = ret0; 
            if (list.Count == 1)
                return ret0;

            if (mode.safe == 0)
            {
                return calcmedianneVirt(list, mode, 0, 0);
            }

            int indexV = 0;
            int nbAdd = 0;

            int count = list.Count;

            if (mode.safe > 0)
            {

                int i0 = count - 1;
                int _nbNoAdd = 0; 

                for (int i = 0; i < count; i++)
                {
                    if (list[i]<=_zero)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0; 
                        break;
                    }
                }
                if (i0 == 0)
                    return ret0;

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                List<decimal> _list = new List<decimal>(list);
                //for (int i = i00; i < count; i++)
                //    _list[i] = 0m;
                //liste partielle originale
                //  List<decimal> _list0 = new List<decimal>(_list);
                int _count = System.Math.Min(count, i0 + mode.safe);
                decimal[] virt = new decimal[_count];
                _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd); 
                if (mode.noAdd)
                {
                   
                    decimal _coeff = 1m;
                    for (int j = _nbNoAdd-1; j >= 0; j--)
                    {
                        if (j < count)
                        {
                            _coeff /= mode.coeffVirt;
                            _list[j] = _list[j] * _coeff;
                        }
                    }
                }
                else if (mode.lissage || mode.removeEpsilon || mode.cumul)
                {
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= mode.coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
                else
                {
                    decimal courant = _list[0];
                    for (int i = 1; i < _count; i++)
                    {
                        if (_list[i] <=_zero)
                        {
                            courant /= mode.coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = _list[i];
                    }
                }

                decimal value = int.MaxValue;
                int ii = 0;
                if (mode.noAdd)
                {
                    //for (ii = 1; ii < count && ii < _count; ii++)
                    //{
                    //    var calc = virt[ii];
                    //    if (calc > 0m)
                    //        list[ii] = calc;
                    //}
                }
                else
                {
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (mode.lissage || value <= _zero)
                            {
                                if (value <= _zero)
                                    nbAdd++;
                                value = calc;
                                _list[ii] = value;
                            }

                        }
                        else
                            indexV = ii;
                    }
                    if (mode.removeEpsilon)
                    {
                        // j'ai 5 virtuel alors que j'ai deux safe
                        ///xx---
                        int nb = 0;
                        for (int i = indexV + 1; i < _count; i++)
                        {
                            nb++;
                            if (nb <= mode.safe)
                                continue;
                            _list[i] = 0m;
                        }

                    }
                    if (mode.removeFirst)
                    {
                        for (int i = 0; i < nbAdd; i++)
                        {
                            _list[i] = 0m;
                        }
                    }
                }

                for (int i = 0; i < _list.Count && i < pieces.Count; i++)
                    pieces[i].setClassementVirtuel(_list[i]);

                if (mode.deleteFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        _list.RemoveAt(0);
                    }
                }

                if (mode.reSort || mode.removeFirst || mode.noAdd)
                {
                    _list.Sort();
                    _list.Reverse();
                    pieces.Sort(new PieceCmp());
                }



                if (mode.noAdd)
                    nbAdd = _nbNoAdd; 

                ret = calcmedianneVirt(_list, mode, nbAdd, System.Math.Min(i0, mode.safe));
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<Piece>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }


            }
            else
                ret = calcmedianneVirt(list, mode, 0, 0);

            //if (ret < ret0)
            //    ret = ret0; 


            if (signal)
            {
                try
                {
                    pieces[ret.index].MedianneLight = true;
                    pieces[ret.indexBorder].Border = true;
                    pieces[ret.indexBorderEffect].BorderEffect = true;

                }
                catch { }
            }

            return ret;
        }

        public static DecimalIndex getMedianneLight( List<Piece> pieces, ConfMedianne mode, bool signal)
        {

            DecimalIndex ret0 = new DecimalIndex();

            var _zero = mode.zero;
            var medianne = getMedianne_(pieces, mode.medianne);
            ret0.d = medianne;
            ret0.index = index;
            DecimalIndex ret = ret0;
            if (pieces.Count == 1)
                return ret0;

            if (mode.safe == 0)
            {
                return calcmedianneVirt(pieces, mode, 0, 0);
            }

            int indexV = 0;
            int nbAdd = 0;

            int count = pieces.Count;

            if (mode.safe > 0)
            {

                int i0 = count - 1;
                int _nbNoAdd = 0;

                for (int i = 0; i < count; i++)
                {
                    if (pieces[i].RapportClassement == 0m)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret0;

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                List<decimal> _list = new List<decimal>();
                for (int i=0; i< pieces.Count; i++)
                    _list.Add(pieces[i].RapportClassement); 
                //for (int i = i00; i < count; i++)
                //    _list[i] = 0m;
                //liste partielle originale
                //  List<decimal> _list0 = new List<decimal>(_list);
                int _count = System.Math.Min(count, i0 + mode.safe);
                decimal[] virt = new decimal[_count];
                _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
                if (mode.noAdd)
                {

                    decimal _coeff = 1m;
                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < count)
                        {
                            _coeff /= mode.coeffVirt;
                            _list[j] = _list[j] * _coeff;
                        }
                    }
                }
                else if (mode.lissage || mode.removeEpsilon || mode.cumul)
                {
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= mode.coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
                else
                {
                    decimal courant = _list[0];
                    for (int i = 1; i < _count; i++)
                    {
                        if (_list[i] <= _zero)
                        {
                            courant /= mode.coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = _list[i];
                    }
                }

                decimal value = int.MaxValue;
                int ii = 0;
                if (mode.noAdd)
                {
                    //for (ii = 1; ii < count && ii < _count; ii++)
                    //{
                    //    var calc = virt[ii];
                    //    if (calc > 0m)
                    //        list[ii] = calc;
                    //}
                }
                else
                {
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (mode.lissage || value <= _zero)
                            {
                                if (value <= _zero)
                                    nbAdd++;
                                value = calc;
                                _list[ii] = value;
                            }

                        }
                        else
                            indexV = ii;
                    }
                    if (mode.removeEpsilon)
                    {
                        // j'ai 5 virtuel alors que j'ai deux safe
                        ///xx---
                        int nb = 0;
                        for (int i = indexV + 1; i < _count; i++)
                        {
                            nb++;
                            if (nb <= mode.safe)
                                continue;
                            _list[i] = 0m;
                        }

                    }
                    if (mode.removeFirst)
                    {
                        for (int i = 0; i < nbAdd; i++)
                        {
                            _list[i] = 0m;
                        }
                    }
                }

                for (int i = 0; i < _list.Count && i < pieces.Count; i++)
                    pieces[i].setClassementVirtuel(_list[i]);

                if (mode.deleteFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces.RemoveAt(0);
                    }
                }

                if (mode.reSort || mode.removeFirst || mode.noAdd)
                {
                    //_list.Sort();
                    //_list.Reverse();
                    pieces.Sort(new PieceCmp());
                }



                if (mode.noAdd)
                    nbAdd = _nbNoAdd;

                ret = calcmedianneVirt(pieces, mode, nbAdd, System.Math.Min(i0, mode.safe));
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<Piece>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }


            }
            else
                ret = calcmedianneVirt(pieces, mode, 0, 0);

            //if (ret < ret0)
            //    ret = ret0; 


            if (signal)
            {
                try
                {
                    pieces[ret.index].MedianneLight = true;
                    pieces[ret.indexBorder].Border = true;
                    pieces[ret.indexBorderEffect].BorderEffect = true;

                }
                catch { }
            }

            return ret;
        }

        
        
        
        private class PieceCmp : IComparer<Piece>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(Piece x, Piece y)
            {
                int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }




        private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        {
            var _list = new List<decimal>(list); 
            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {

                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                if (_list[count - i - 1] > conf.zero)
                {

                    if (conf.removeLast == removeLast.non)
                        break;
                    _nbSupp++;
                    if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                        break;
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }



        private static DecimalIndex calcmedianneVirt(IList<Piece> list, ConfMedianne conf, int nbAdd, int nbDel)
        {
            var _list = new List<Piece>(list);
            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {

                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                var p = _list[count - i - 1]; 

                if (p.RapportClassement > conf.zero)
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considèere qu'on peut supprimmer les morceaux activé
                   if (!p.Enabled || !conf.removeEnabled)
                   {
                        if (conf.removeLast == removeLast.non)
                            break;
                        _nbSupp++;
                        if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                            break;
                    }
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }

        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        private static decimal getMedianne_(IList<Piece> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0].VirtualClassement;
            if (coeffMedianne == 0)
                return list[0].VirtualClassement;
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1].VirtualClassement;
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].VirtualClassement;
            var val1 = list[i1].VirtualClassement;
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\type\Classement.cs">
    <content><![CDATA[using System;
using pdb.db.obj;
using pdb.util;
using System.Text.RegularExpressions;

namespace pdb.db.piece.type
{

    /// <summary>
    /// type de base de la donnée classement : 
    /// paire : liste / rating 
    /// 
    /// </summary>
    /// <remarks>utilisé comme une valeur simple (entier - string)</remarks>
    public class Classement
    {
        public static Regex regClassement = new Regex(@"([0-5]+)\.([0-5])");
        public static Regex regClassement2 = new Regex(@"([0-5]+)");
        private static bool isClassement(string input) { return string.IsNullOrEmpty(input) || regClassement.IsMatch(input); }

        public static bool canBeClassement(string input) {
            if (string.IsNullOrEmpty(input))
                return true;
            if (regClassement2.IsMatch(input))
                return true;
            if (regClassement.IsMatch(input))
                return true;
            return false; 
        
        }
        public static Classement create(string input)
        {
            if (input != null)
                input = input.Replace(" ", "");
            if (input == "0")
                return new Classement("0", 0); 
            if (!isClassement(input))
                return null;
            if (string.IsNullOrEmpty(input))
                return new Classement("", 0);
            var groups = regClassement.Match(input).Groups;
            return new Classement(groups[1].Value, (20 * Convert.ToInt32(groups[2].Value))); 
        }


        public decimal RapportClassement
        {
            get
            {
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat; 
            }
        }
        private string m_class = "";
        private int m_rating = -1;
        public Classement(string a_class, int a_rating)
        {
            m_class = a_class;
            m_rating = a_rating;
        }
        public string ClassList
        {
            get { return m_class; }
            set { m_class = value; }
        }
        public int Rating
        {
            get { return m_rating; }
            set { m_rating = value; }
        }
        public override bool Equals(object obj)
        {
            if (obj is Classement)
            {
                Classement l_obj = (Classement)obj;
                return m_class.Equals(l_obj.m_class) && m_rating == l_obj.m_rating;
            }
            else
            {
                return false;
            }
        }
        public override int GetHashCode()
        {
            return m_class.GetHashCode() + m_rating.GetHashCode();
        }

        #region rang
        private Bool m_numericClassList;
        //private String m_classNameAndRating = "";
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                if (m_numericClassList == Bool.not_defined)
                {
                    if (String.IsNullOrEmpty(m_class)) return false;
                    bool res = m_class.isInteger();  //CUtil.isInteger(m_class);
                    m_numericClassList = res ? Bool.True : Bool.False;
                    return res;
                }
                else
                {
                    return m_numericClassList == Bool.True ? true : false;
                }
            }
        }
        public String ClassNameAndRating
        {
            get
            {
                if (!isClassListNumeric) return "." + getNbStars();
                return m_class + getNbStars();
            }
        }

        public String ClassNameAndRatingWithPt
        {
            get
            {
                if (!isClassListNumeric) return "." + getNbStars();
                return m_class + "."+ getNbStars();
            }
        }
        /// <summary>
        /// Donne la valeur du classement. Pratique pour la comparaison
        /// </summary>
        /// <returns></returns>
        public double getNormValue()
        {
            if (!isClassListNumeric)
                return -1;
            string classNameAndRating = ClassNameAndRating;
            string strDouble = classNameAndRating.Insert(1, ",");
            return Convert.ToDouble(strDouble);
        }

        private String getNbStars() { return (m_rating / 20).ToString(); }
        public override string ToString()
        {
            if (!isClassListNumeric) return m_class;
            return String.Format("{0}.{1}", m_class, getNbStars());
        }


        public decimal ClassementValueDecimal
        {
            get
            {
                if (!isClassListNumeric) return 0;
                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
                return Convert.ToDecimal(classNameAndRating);
            }
        }

        //public static bool operator ==(Classement c1, Classement c2)
        //{
        //    return c1.ClassementValueDecimal == c2.ClassementValueDecimal; 
        //}
        //public static bool operator !=(Classement c1, Classement c2)
        //{
        //    return c1.ClassementValueDecimal != c2.ClassementValueDecimal;
        //}

        //public static bool operator >(Classement t1, Classement t2)
        //{
        //    return t1.ClassementValueDecimal > t2.ClassementValueDecimal;
        //}
        //public static bool operator >=(Classement t1, Classement t2)
        //{
        //    return t1.ClassementValueDecimal >= t2.ClassementValueDecimal;
        //}
        //public static bool operator <(Classement t1, Classement t2)
        //{
        //    return t1.ClassementValueDecimal < t2.ClassementValueDecimal;
        //}
        //public static bool operator <=(Classement t1, Classement t2)
        //{
        //    return t1.ClassementValueDecimal <= t2.ClassementValueDecimal;
        //}

        #endregion

    }
}
]]></content>
  </file>
</db>
