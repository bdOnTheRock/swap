<db path="C:\bernard\db2\">
  <file path="db4\PieceDb.Consolid\stat\DynamicStatBuilder.cs">
    <content><![CDATA[
using pdb.util;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace pdb.gen.stat
{
    public class DynamicStatPair
    {
        public readonly DynamicStat real;
        public readonly DynamicStat offset;
        public DynamicStatPair(DynamicStat real, DynamicStat offset)
        {
            this.real = real;
            this.offset = offset;
        }
    }
    public class DynamicStat : IEnumerable<DynamicStatLigne>
    {

        public const int ROWS = 5;
        public readonly List<DynamicStatLigne> rows = new List<DynamicStatLigne>(ROWS);
        public string className;
        public DynamicStat()
        {
            for (int r = 0; r < ROWS; r++)
                rows.Add(new DynamicStatLigne(r));
        }

        public DynamicStatLigne this[int row]
        {
            get
            {
                return rows[row];
            }
        }


        public IEnumerator<DynamicStatLigne> GetEnumerator()
        {
            return rows.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return rows.GetEnumerator();
        }

        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.Append(className);
            sb.Append(": ");
            foreach (var stat in rows)
            {
                sb.Append("\t");
                sb.Append(stat.ToString());
                sb.AppendLine();
            }
            return sb.ToString();


        }
    }

    public class DynamicStatLigne : IEnumerable<int>
    {
        public DynamicStatLigne(int row)
        {
            this.row = row;
            for (int i = 0; i < COLS; i++)
            {
                data.Add(0);
            }
        }
        public readonly int row;
        public const int COLS = 13;
        public const int SEMI_COLS = 6;
        private List<int> data = new List<int>(COLS);

        public int min;
        public int max;

        public int this[int col]
        {
            get
            {
                return data[Col(col)];
            }
            set
            {
                data[Col(col)] = value;
            }

        }

        private int Col(int col) { return col + SEMI_COLS; }

        public IEnumerator<int> GetEnumerator()
        {
            return data.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return data.GetEnumerator();
        }

        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.Append(min);
            sb.Append("-");
            sb.Append(max);
            sb.Append(" ");
            for (int i = -SEMI_COLS; i <= SEMI_COLS; i++)
            {
                sb.Append(" ");
                sb.Append(i);
                sb.Append("=");
                sb.Append(this[i]);
            }
            return sb.ToString();
        }
    }

    public class DynamicStatBuilder
    {
        const decimal EPSILON = 0.000000000000000000001m;
        private Regex reg = new Regex("[6789]");
        static NumberFormatInfo nfi;
        private List<Piece> list;
        private int level;
        //private int sub;
        //private int delta;
        //private int coeff;
        private int count;
        private IClient client;

        static DynamicStatBuilder()
        {
            nfi = new NumberFormatInfo() { NumberDecimalSeparator = "." };
        }

        public DynamicStatBuilder(IClient client, IEnumerable<Piece> list)
        {
            this.client = client;
            this.list = new List<Piece>(list);
            if (client.Cancel)
                return;
            this.list.Reverse();
            this.count = this.list.Count;
        }
        static Regex regNoEmpty = new Regex("[1-9]+");
        private static string getClassRecenter(string className)
        {
            if (string.IsNullOrEmpty(className))
                return className;
            if (regNoEmpty.IsMatch(className))
                return className;
            var tab = className.ToCharArray();
            int count = tab.GetLength(0);
            tab[count - 1] = '1';
            var ret = new string(tab);
            return ret;
        }

        public static bool isZero(string className)
        {
            return !regNoEmpty.IsMatch(className);
        }

        public DynamicStat gener(string className, bool real)
        {
            if (!real)
                className = getClassRecenter(className);
            //if (string.IsNullOrEmpty(className))
            //    className = "3";
            DynamicStat stats = new DynamicStat();

            int pt = className.IndexOf('.');
            string classNameAndRating = className;
            var sub = classNameAndRating;
            char csub = '0';
            if (pt > 0)
            {
                int count = classNameAndRating.Length;
                //if (pt < count - 1)
                //{
                //    csub = classNameAndRating[pt + 1];
                //}
                classNameAndRating = classNameAndRating.Remove(pt);
            }

            if (pt < 0)
            {
                sub = classNameAndRating + csub;
            }
            else
            {
                sub = classNameAndRating;
                if (classNameAndRating.Length > 0)
                    classNameAndRating = classNameAndRating.Remove(classNameAndRating.Length - 1);
            }
            if (DynamicStat.ROWS == 1)
            {
                gener(client, stats[0], sub, 1);
            }
            else if (DynamicStat.ROWS == 3)
            {
                gener(client, stats[0], sub, 3);
                gener(client, stats[1], sub, 1);
                sub += "0";
                gener(client, stats[2], sub, 3);
            }
            else if (DynamicStat.ROWS == 5)
            {
                gener(client, stats[0], classNameAndRating, 1);
                gener(client, stats[1], sub, 3);
                //  gener(stats[2], sub, 2);
                gener(client, stats[2], sub, 1);

                sub += "0";

                gener(client, stats[3], sub, 3);
                //  gener(stats[5], sub, 2);
                gener(client, stats[4], sub, 1);
            }




            return stats;
        }

        public List<Piece> getPieces(string className)
        {
            if (string.IsNullOrEmpty(className))
                className = "3";

            var stats = new List<Piece>();
            int pt = className.IndexOf('.');
            string classNameAndRating = className;
            //  var sub = classNameAndRating;
            //  char csub = '0';
            if (pt > 0)
            {
                classNameAndRating = classNameAndRating.Remove(pt);
            }

            //if (pt < 0)
            //{
            //    sub = classNameAndRating + csub;
            //}
            //else
            //{
            //    sub = classNameAndRating;
            //    if (classNameAndRating.Length > 0)
            //        classNameAndRating = classNameAndRating.Remove(classNameAndRating.Length - 1);
            //}

            gener(client, stats, classNameAndRating, 1);

            return stats;
        }


        private void gener(IClient client, DynamicStatLigne ligne, string className, int sub)
        {


            decimal center = 0;
            decimal realCenter = 0;
            //if (string.IsNullOrEmpty(className))
            //{
            //    className = "3";
            //}

            //string classNameAndRating = className.Replace(".", "").Replace(",", "");
            level = 0;
            if (string.IsNullOrEmpty(className))
                center = 3;
            else
            {
                level = className.Length - 1;
                string strDecimal = className.Insert(1, ",");


                //if (level == 0)
                //{
                //    center = 3;
                //}
                //else
                //{

                if (!decimal.TryParse(strDecimal, out center))
                    return;
                //}

            }

            //if (center == 0)
            //{
            //    // 0=>1 level = 0
            //    // 00 > 01 -> 0.1 level=1
            //    center = Convert.ToDecimal(System.Math.Pow(10, -level));
            //}

            decimal precision = 1m;
            decimal deltaBase = 1;

            for (int i = 0; i < level; i++)
            {
                precision /= 10m;
                deltaBase *= 10;
            }

            if (sub == 6)
            {
                precision *= 10m;

            }
            else
            {
                precision *= sub;

            }

            //************************************************
            // 213 =>  210  211  212  |213| 214  215  220
            // puis     2113 2120 2123 |2130|2133 2140 2143   
            // puis    2120 2122 2124 |2130|2132 2134 2140
            // puis    2123 2124 2125 |2130|2131 2132 2133
            //****************************************************

            // ok mais avec ""
            //************************************************
            // "" =>  0  1  2  |3| 4  5 
            // puis     2113 2120 2123 |2130|2133 2140 2143   
            // puis    2120 2122 2124 |2130|2132 2134 2140
            // puis    00 01 02 |03|04 05 10
            //****************************************************
            int delta = sub;
            long min = (long)System.Math.Round(System.Math.Round(center, level) * deltaBase, 0);
            long max = 0;
            int col = 0;
            int index = 0;
            int nb = 0;
            decimal current = 0m;

            if (min > 0)
            {
                for (col = -1; col >= -DynamicStatLigne.SEMI_COLS; col--)
                {
                    if (client.Cancel)
                        return;
                    // trouver min en descendant
                    for (int i = 0; i < sub; i++)
                    {
                        min--;
                        while (reg.IsMatch(min.ToString()))
                            min--;
                    }

                    if (min <= 0)
                        break;
                }
            }

            if (col < -DynamicStatLigne.SEMI_COLS)
                col = -DynamicStatLigne.SEMI_COLS;
            for (; col <= DynamicStatLigne.SEMI_COLS; col++)
            {
                if (client.Cancel)
                    return;
                max = min + delta;
                while (reg.IsMatch(max.ToString()))
                    max++;

                if (min >= 6 * deltaBase)
                    return;



                decimal dmin = (decimal)min / deltaBase;

                while (true)
                {
                    if (client.Cancel)
                        return;

                    if (index < count)
                    {
                        var p = list[index];
                        if (p.Parent != null)
                            continue;
                        current = p.ClassementValueDecimal(false);
                        if (current * deltaBase < min - EPSILON)
                        {
                            index++;
                            continue;
                        }
                    }
                    if (index >= count || current * deltaBase + EPSILON >= max)
                    {
                        ligne[col] = nb;
                        nb = 0;
                        min = max;
                        break;

                    }
                    index++;
                    nb++;
                }
            }

        }




        private void gener(IClient client, List<Piece> ligne, string className, int sub)
        {
            decimal center = 0;
            if (string.IsNullOrEmpty(className))
            {
                className = "3";
            }


            level = className.Length - 1;
            string strDecimal = className.Insert(1, ",");


            if (!decimal.TryParse(strDecimal, out center))
                return;



            decimal precision = 1m;
            long deltaBase = 1;

            for (int i = 0; i < level; i++)
            {
                precision /= 10m;
                deltaBase *= 10;
            }

            if (sub == 6)
            {
                precision *= 10m;

            }
            else
            {
                precision *= sub;

            }


            long delta = sub;
            long min = (long)System.Math.Round(System.Math.Round(center, level) * deltaBase, 0);
            long max = 0;
            //  int col = 0;
            int index = 0;
            //  int nb = 0;
            decimal current = 0m;

            //if (min > 0)
            //{
            //    for (col = -1; col >= -DynamicStatLigne.SEMI_COLS; col--)
            //    {
            //        // trouver min en descendant
            //        for (int i = 0; i < sub; i++)
            //        {
            //            min--;
            //            while (reg.IsMatch(min.ToString()))
            //                min--;
            //        }

            //        if (min <= 0)
            //            break;
            //    }
            //}

            //if (col < -DynamicStatLigne.SEMI_COLS)
            //    col = -DynamicStatLigne.SEMI_COLS;
            //for (; col <= DynamicStatLigne.SEMI_COLS; col++)
            //{
            max = min + delta;
            while (reg.IsMatch(max.ToString()))
                max++;

            if (min >= 6 * deltaBase)
                return;



            decimal dmin = (decimal)min / deltaBase;

            while (true)
            {
                if (client.Cancel)
                    return;
                Piece p = null;
                if (index < count)
                {
                    p = list[index];
                    current = p.ClassementValueDecimal(false);
                    if (current * deltaBase < min - EPSILON)
                    {
                        index++;
                        continue;
                    }
                }
                if (index >= count || current * deltaBase + EPSILON >= max)
                {
                    //  ligne[col] = nb;
                    //  nb = 0;
                    min = max;
                    break;

                }
                ligne.Add(p);
                index++;

            }
        }

    }
}
]]></content>
  </file>
  <file path="db4\PieceDb.Db\CListPiece.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
/// <summary>
/// Liste de pieces contenues dans un fichier
/// Liste de pieces � sauvegarder
/// </summary>
/// <remarks>
/// La liste doit s'assurer de l'absence de doublons
/// maintenir une r�f�rence unique pour un morceau
/// 
/// 
/// </remarks>
namespace pdb.db
{
    public interface IReference
    {
        void referenceChange(CPiece piece);
    }

    public class CListPiece : IData, IReference
    {

        public const string TOKEN_LISTS = "lists";
        public const string TOKEN_LIST = "l";
        public const string TOKEN_FOLDER = "f";
        public const string TOKEN_LIST_NAME = "n";
        public const string TOKEN_LIST_TRACK = "t";

        private System.DateTime m_date = System.DateTime.MinValue;

        private DictRef<CPiece> ht = new DictRef<CPiece>();
        private BgDict<int, CPiece> htIds = new BgDict<int, CPiece>();
        private BgDictString<CPiece> htLoc = new BgDictString<CPiece>();
        private PlayList listes = new PlayList("listes");
        public PlayList Listes { get { return listes; } }

        public const string PIECES = "pieces";
        #region "constructeurs"
        /// <summary>
        /// Création à partir d'une simple collection de Piece
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>recherche doublons - merge manuel �ventuel</remarks>
        public CListPiece(ICollection<CPiece> a_list, System.DateTime a_date)
            : this()
        {
            m_date = a_date;
            init(a_list);

            //foreach (CPiece l_file in a_list)
            //{
            //    htIds[l_file.PieceId] = l_file;
            //    foreach (CFile file in l_file.Files)
            //    {
            //        htLoc[file.Path] = l_file;
            //    }
            //}
            foreach (CPiece piece in a_list)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    var parent = htIds[parentId];
                    if (parent == null)
                        log(string.Format("id={0} parentid={1} parent NULL", piece.PieceId, piece.PieceParentId));
                    else
                        piece.setParent(parent);
                }

                //if (!piece.Exists)
                //{
                //    misc.log("absent: {0}", piece.PathAndRef + " " + piece.Comment);
                //}
            }



            //DateTime maxEnabled = DateTime.MinValue;
            //foreach (CPiece l_file in a_list)
            //{
            //    Add(l_file);
            //    //if (l_file.Enabled)
            //    //{
            //    //    var t = l_file.LastModifClass;
            //    //    if (t > maxEnabled)
            //    //        maxEnabled = t;
            //    //}
            //}
            //misc.log("***********************************************************");
            //misc.log("maxEnabled: {0}", maxEnabled);
            //misc.log("***********************************************************");
        }


        public void refresh()
        {
            var list = getList();
            ht = new DictRef<CPiece>();
            htIds = new BgDict<int, CPiece>();
            htLoc = new BgDictString<CPiece>();

            init(list);
        }

        private void init(ICollection<CPiece> a_list)
        {
            foreach (CPiece l_file in a_list)
            {
                htIds[l_file.PieceId] = l_file;
                foreach (CFile file in l_file.Files)
                {
                    htLoc[file.Path] = l_file;
                }
            }

            foreach (CPiece l_file in a_list)
            {
                Add(l_file);
            }
        }

        public CListPiece()
        {

        }

        #endregion


        public void checkId(CPiece toCheck)
        {
            foreach (CFile f in toCheck.Files)
            {
                if (htLoc.ContainsKey(f.Path))
                {
                    var pOrg = htLoc[f.Path];
                    toCheck.setId(pOrg.PieceId);
                    toCheck.PieceParentId = pOrg.PieceParentId;
                }
            }
        }

        /// <summary>
        /// merge de la base locale et distante
        /// </summary>
        /// <param name="a_remote"></param>
        /// <remarks></remarks>
        public void Consolid(CListPiece a_remote)
        {
            log("ListPiece:Consolid");
            mergePriority l_remotePriority = mergePriority.none;
            System.DateTime l_remoteDate = a_remote.m_date;
            if (l_remoteDate > System.DateTime.MinValue && l_remoteDate.AddSeconds(-3) > m_date)
                l_remotePriority = mergePriority.right;
            foreach (CPiece l_file in a_remote)
            {
                Consolid(l_file, l_remotePriority);
            }

        }

        //public void bilanNatives()
        //{
        //    misc.log("Bilan Natives");
        //    foreach (CPiece piece in this)
        //    {
        //        if (piece.HasNoNative)
        //            misc.logNoDate(piece.ToString());
        //    }
        //}

        //private void merge(CPiece org, CPiece cand)
        //{
        //    misc.log("CList:Add MERGE with key {0}: {1} // {2}", org.Key, org, cand);
        //    org.merge(cand);
        //}

        public void AddOrMerge(CPiece piece, CPiece org)
        {
            if (org != null)
            {
                org.consolid(piece, mergePriority.right);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
            }
            htIds[piece.PieceId] = piece;
            foreach (CFile file in piece.Files)
            {
                htLoc[file.Path] = piece;
            }


        }


        public void Add(CPiece piece)
        {
            TrackIdentity key = piece.Key;

            CPiece org = null;

            // recherche d'une piece avec un niveau de d�tail �gal ou inf�rieur
            org = ht[key];


            if (org != null)
            {
                misc.log("CList:Add MERGE {0}", key);
                org.merge(piece);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
                htIds[piece.PieceId] = piece;
                foreach (CFile file in piece.Files)
                {
                    htLoc[file.Path] = piece;
                }

            }
        }


        public void fusion(CPiece master, CPiece toDelete)
        {
            if (master == null)
                return;
            if (toDelete == null)
                return;
            if (master == toDelete)
                return;
            misc.log("CList:Fusion  {0}  {1}", master, toDelete);
            master.MasterPiece.addDataLink(toDelete.MasterPiece);
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);

        }

        public void delete(CPiece toDelete)
        {
            if (toDelete == null)
                return;
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);
            foreach (CFile file in toDelete.Files)
            {
                htLoc.Remove(file.Path);
            }
        }

        public void referenceChange(CPiece piece)
        {
            piece.keyGener();
            ht.Remove(piece);

            piece.keyGener();
            ht.set(piece, piece.Key);

        }






        public bool Contains(CPiece piece)
        {
            var key = piece.Key;
            return ht[key] != null;
        }

        public void Consolid(CPiece remote, mergePriority a_priority)
        {
            //if (remote.PieceParentId > 0)
            //{
            //    if (remote.Parent == null)
            //        remote.Parent = htIds[remote.PieceParentId];


            //}
            try
            { 
            CPiece l_pieceOrg = getPiece(remote);

            if (l_pieceOrg == null)
            {
                if (!remote.Deleted)
                {
                    l_pieceOrg = new CPiece();
                    l_pieceOrg.consolid(remote, a_priority);
                    Add(l_pieceOrg);
                }
                else
                    misc.log("remote deleted!! Pourquoi je le trouve pas ?? {0}", remote);
            }
            else
            {
                if (remote.Deleted && a_priority == mergePriority.right)
                {
                    l_pieceOrg.Deleted = true;
                    return;
                }
                if (l_pieceOrg.PieceParentId != remote.PieceParentId)
                {
                    if (remote.PieceParentId > 0)
                    {
                        if (l_pieceOrg.PieceParentId > 0)
                        {
                            misc.log("ououh! changement de parent {0} de {1} vers {2} ", l_pieceOrg, l_pieceOrg.PieceParentId, remote.PieceParentId);
                            l_pieceOrg.setParent(htIds[remote.PieceParentId]); 
                        }
                        else
                        {
                            misc.log(l_pieceOrg + " a maintenant un parent: " + remote.PieceParentId);
                             l_pieceOrg.setParent(htIds[remote.PieceParentId]); 
                        }

                        //var parent = htIds[remote.PieceParentId];
                        //misc.log(l_pieceOrg + " a maintenant un parent: " + parent);
                        //l_pieceOrg.PieceParentId = remote.PieceParentId;
                        //l_pieceOrg.Parent = parent;
                    }
                    else
                    {
                        misc.log("ououh! suppression de parent {0} -> {1} ", l_pieceOrg, l_pieceOrg.PieceParentId);
                        l_pieceOrg.Parent = null; 
                    }
                    //if (remote.PieceId > 0 && l_pieceOrg.PieceId < 0)
                    //    l_pieceOrg.Parent = htIds[remote.PieceParentId];
                    l_pieceOrg.PieceParentId = remote.PieceParentId;
                   
                }

                 l_pieceOrg.consolid(remote, a_priority);
            }
            }
            catch(Exception ex)
            {
                log("impossible de consolider " + remote.PieceId); 
            }
        }

        ///// <summary>
        ///// synchro enrte base locale et liste native
        ///// </summary>
        ///// <param name="native"></param>
        ///// <remarks></remarks>
        //public void legacyConsolid(CPiece native)
        //{
        //    CPiece l_pieceOrg = getPiece(native);

        //    if (l_pieceOrg == null)
        //    {
        //        log("add from business:" + native.ToString());
        //        l_pieceOrg = new CPiece(native);
        //        l_pieceOrg.legacyConsolid(native);
        //        Add(l_pieceOrg);
        //    }
        //    else
        //    {
        //        l_pieceOrg.legacyConsolid(native);
        //    }

        //}

        private CPiece getPiece(TrackIdentity key)
        {
            return ht[key];
        }

        public CPiece getPiece(ITrackMetaData a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece getPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece tryGetPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return ht.Try(key);
        }

        public CPiece tryGetPieceWithoutId(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return ht.TryWithoutId(key);
        }

        public CPiece getPiece(string location)
        {
            return htLoc[location];
        }

        public CPiece getPiece(int id)
        {
            return htIds[id];
        }

        public void moveId(int oldId, CPiece piece)
        {

        }

        private bool exists(CPiece a_piece)
        {
            return getPiece(a_piece) != null;
        }

        #region IData Members
        //public void write(ITextWriter a_sw)
        //{
        //    XMLTool.openBalise(a_sw, PIECES);
        //    foreach (CPiece l_piece in this)
        //    {
        //        l_piece.write(a_sw);
        //    }
        //    XMLTool.closeBalise(a_sw, PIECES);
        //}

        public void write(System.Xml.XmlWriter w)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                l_piece.write(w);
            }
            w.WriteEndElement();
            w.WriteStartElement(TOKEN_LISTS);
            writeList(w, listes);
            w.WriteEndElement();
        }

        public void writeDiff(System.Xml.XmlWriter w, CListPiece lastFull)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                var org = lastFull.getPiece(l_piece.PieceId);
                try
                {
                    l_piece.writeDiff(w, org);
                }
                catch (Exception ex)
                {
                    misc.log("impossible d'enregistrer les modifs de " + l_piece, ex.ToString());
                }
            }

            foreach (CPiece org in lastFull)
            {
                var newP = this.getPiece(org.PieceId);
                if (newP == null)
                {
                    org.Deleted = true;
                    org.writeDeleted(w);
                }
            }
            w.WriteEndElement();
        }

        #endregion


        public IEnumerator GetEnumerator()
        {
            return ht.GetEnumerator();
        }

        public int Count
        {
            get { return ht.Count; }
        }
        //public System.Collections.Generic.IEnumerator<CPiece> GetEnumerator1()
        //{
        //    return ht.GetEnumerator1();
        //}
        //System.Collections.Generic.IEnumerator<CPiece> System.Collections.Generic.IEnumerable<CPiece>.GetEnumerator()
        //{
        //    return GetEnumerator1();
        //}

        public List<CPiece> getList()
        {
            var list = new List<CPiece>(ht.Count);
            foreach (CPiece p in ht)
            {
                if (!p.Deleted)
                    list.Add(p);
            }

            Sort(list);

            return list;
        }

        public void Sort(List<CPiece> list)
        {
            list.Sort(new PieceComparer());
        }

        private class PieceComparer : IComparer<CPiece>
        {
            public int Compare(CPiece x, CPiece y)
            {
                int cmp = x.MasterId.CompareTo(y.MasterId);
                if (cmp != 0)
                    return cmp;
                cmp = x.PieceParentId.CompareTo(y.PieceParentId);
                if (cmp != 0)
                    return cmp;
                return x.PieceId.CompareTo(y.PieceId);
            }
        }

        private void log(String txt)
        {
            misc.log(txt);
        }


        #region listes
        public void loadListes(XmlElement xml)
        {
            if (xml == null)
                return;
            buildList(xml, listes);
        }

        private void buildList(XmlElement xparent, PlayList parent)
        {
            foreach (XmlElement xsub in xparent.ChildNodes)
            {
                var tool = new XMLTool(xsub);
                if (xsub.Name == TOKEN_LIST)
                {
                    string name = tool.getAttValue(TOKEN_LIST_NAME);
                    int id = tool.getIntAttValue("id");
                    PlayList sub = new PlayList(name, parent);
                    sub.ID = id;
                    CDb.checkId(sub);
                    buildList(xsub, sub);
                }
                else if (xsub.Name == TOKEN_LIST_TRACK)
                {
                    int id = tool.getIntAttValue("id");
                    var piece = htIds[id];

                    // var tl = new TrackList(piece);
                    parent.add(piece);
                }
            }
        }

        private void writeList(XmlWriter w, PlayList parent)
        {
            foreach (PlayList pl in parent.PlayLists)
            {
                w.WriteStartElement(TOKEN_LIST);
                w.WriteAttributeString("id", pl.ID.ToString());
                w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
                writeList(w, pl);
                w.WriteEndElement();
            }

            foreach (IItem t in parent.Items)
            {
                w.WriteStartElement(TOKEN_LIST_TRACK);
                w.WriteAttributeString("id", t.ID.ToString());
                w.WriteEndElement();
            }
            //foreach (PlComponent c in parent)
            //{
            //    if (c is CPlayList)
            //    {
            //        var pl = c as CPlayList;
            //        w.WriteStartElement(TOKEN_LIST);
            //        w.WriteAttributeString("id", pl.ID.ToString());
            //        w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
            //        writeList(w, pl);
            //        w.WriteEndElement();
            //    }
            //    else if (c is TrackList)
            //    {
            //        var t = c as TrackList;
            //        w.WriteStartElement(TOKEN_LIST_TRACK);
            //        w.WriteAttributeString("id", t.PieceId.ToString());
            //        w.WriteEndElement();
            //    }
            //}
        }

        public void buildLists(PlayList listes)
        {
            //this.listes.DeleteChilds();
            //buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                CDb.checkId(sub);
                subExt.ID = sub.ID;

                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }
        }
        #endregion
    }

}






]]></content>
  </file>
</db>
