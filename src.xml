<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.piece.type;
using pdb.db.obj;


namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log =Logger.getLogger("Program");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background; 


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {

                pdb.player.ViewModel.Colors.MementoColor.recover();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate; 
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode; 

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList(),true);



            if (CConf.ResetOneCl)
            {
                Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                foreach (Piece p in gen.sortByClass())
                {
                    decimal clValue = p.ClassementValueDecimal;
                    if (clValue > zer0d)
                    {
                        if (clValue >= zer0d)
                        {
                            var dPiece = Db.getPiece(p.PieceId);
                            var strNewCl = "0000" + dPiece.getClassement().ToString();
                            var newCl = Classement.create(strNewCl);
                            p.Enabled = true;

                            p.setClassement(newCl.ClassList, newCl.Rating);
                            dPiece.Classement.eraseClassement2(newCl);
                        }
                        else
                            p.Enabled = false;
                    }
                }
                /*
                var _albums = gen.Albums;
                foreach (var album in _albums.List)
                {
                    if (album.Name == "Mémos vocaux" || album.Name == "Pictures at an Exhibition")
                    {
                    }
                    var l = album.Tracks;
                    decimal pluspetitNonNull = int.MaxValue;
                    foreach (Piece t in l)
                    {
                        decimal clValue = t.ClassementValueDecimal;
                        if (clValue > zer0d)
                        {
                            if (clValue < pluspetitNonNull)
                                pluspetitNonNull = clValue;
                        }

                    }
                    foreach (Piece t in l)
                    {
                        if (t.Parent == null)
                        {
                            decimal clValue = t.ClassementValueDecimal;
                            if (t.isClassListNumeric && clValue > zer0d)
                            {
                                if (clValue > pluspetitNonNull)
                                {
                                    var dPiece = Db.getPiece(t.PieceId);
                                    t.Enabled = true;
                                    t.setClassement("0", 0);
                                    dPiece.Classement.eraseClassement2();
                                }
                            }
                        }
                    }
                }*/
                gen.MakeConsolid(Db.List.getList(),true);
            }


            gen.buildMusique();
           // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


          //  gen.timeRanking();
           // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            

            foreach (CPiece p in Db.List)
            {
                if (p.DurationInSec == 0 && p.Exists)
                {
                    try
                    {
                        PlayerViewModel.Player.getDuration(p);
                        log.log("{0} duration {1} s", p, p.DurationInSec);
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }

                }
            }


           // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
           // new Thread(() =>
            gen.builStats(null); 
        }

        private static void _go()
        {
            try
            {
                Memento.Instance.save();
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort; 
                }
                detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                // if (__end || __go) return;

                if (PlayerViewModel.Instance.CreateRot)
                {
                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                    gen.MakeConsolid(Db.List.getList(),_updateStats); //   bib.Musique.Tracks);
                    //  if (__end || __go) return;
                   // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);

                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, App.bib);
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();
                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats)
                        {                           
                            detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => detailClassementViewModel.IhmInDispo = ihmInDispo.none); 

                        }
                        else
                            detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                if (refresh != null && PlayerViewModel.Instance.CreateRot)
                    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats)
                    {
                        _updateStats = false;                         
                    }
                }
            }


        }

        public static event EventHandler refresh;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            App.bib.Aborted = true;
            Db.WriteDB1();
            Db.WriteDB2();
            App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.Track);
            if (l == null)
                return null;
            foreach (ITrackMetaData p in l)
            {

                TrackListViewModel trackList = PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des données morceux dupliqués 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;
        private bool goCompact = true;
        private bool _firstConsolid = true;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
            albums = new Albums(this);
        }
        /// <summary>
        /// Lance le compactage à la prochaine génération
        /// </summary>
        public void GoCompact() { goCompact = true; }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public Albums Albums { get { return albums; } }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList, bool makeSort)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                all = new List<Piece>();

                // albums = new Albums(this);
                VirtualPiece.init();
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>();
                //  htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        Piece piece = null;
                        int pieceId = track.PieceId;
                        if (htIds.ContainsKey(pieceId))
                        {
                            piece = htIds[pieceId];
                            piece.initRank();
                        }
                        else
                        {
                            piece = new Piece(track);
                            htIds.Add(pieceId, piece);
                        }

                        all.Add(piece);

                    }
                }
                // link
                foreach (Piece piece in all)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                albums.checkBuild();
                logger.log("build albums");
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        foreach (Piece p in piece)
                        {
                            if (albums.check(p))
                                listPieceInAlbum.Add(p);
                        }
                    }
                }

                if (_albumVirtual && _firstConsolid)
                {
                    logger.log("build albums virtuels");
                    var listCandidat = new List<Piece>();
                    var dictTmp = new BgDictString<Album>();
                    foreach (Piece piece in all)
                    {
                        if (piece.Parent == null)
                        {
                            piece.buildVirtualAlbums(listCandidat);
                        }
                    }
                    foreach (Piece p in listCandidat)
                        albums.checkVirtual(p, dictTmp);


                    

                    if (CConf.ConfGen.AlbumVirtual && CConf.ConfGen.ArtistVirtual)
                    {
                        var min = CConf.ConfGen.AristVirtualMin;
                        if (min > 0)
                        {
                            foreach (var key in new List<string>(dictTmp.Keys))
                            {
                                var a = dictTmp[key];
                                if (a.VirtualByArtist)
                                {
                                    if (a.Count < min)
                                        dictTmp.Remove(key);

                                }
                            }
                        }

                    }
                    var listAlbums = new List<Album>(dictTmp.Values);

                    listAlbums.Sort(new VirtualAlbumComparer());
                    albums.checkVirtuals(listAlbums, listPieceInAlbum);

                }

                albums.buildDone();



                StackAlbum.Instance.init(all);



                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                if (_firstConsolid)
                    albums.sortVirtual();
                Ranking(makeSort);
            }
            finally
            {
                lock (_lock)
                {
                    _firstConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbum)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(TrackList track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort)
        {
            albums.buildStack(makeSort);
            QRanking();
            LRanking();
            QLRanking();


            var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");


            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);
            // if (makeSort)
            albums.makeSort();
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualité +longueur en cas d'égalité
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }
#if COMPACT
            if (goCompact || CConf.ConfGen.AlbumSort.compactAny)
            {
                goCompact = false;
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();
            }
#endif

            //if (CConf.Condensation)
            //{
            //    var l = new List<Piece>(this.listPiece);
            //    l.Sort(new CPieceComparerByQualityAndLength2());
            //    new Condenseur(m_listQL).gener2();

            //}

        }


        private static volatile object _lockStat = new object();
        //   private static volatile object _lockStat2 = new object();
        private static bool buildingStat;
        const string BUILDING_STATE = @"..\building.txt";
        const string LOADING_EXCEL = @"..\busyExcel.txt";

        private void _buildStat(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 1");
                    return;
                }


                try
                {
                    if (File.Exists(LOADING_EXCEL))
                    {
                        string content = File.ReadAllText(LOADING_EXCEL);
                        misc.log(content);
                        if (content.Contains("BUSY"))
                        {
                            return;
                        }
                    }
                }
                catch (Exception ex)
                {
                    misc.logError("Impossible de lire le fichier lock excel", ex);
                    return;
                }

                buildingStat = true;
            }



            try
            {
                //bool ok = Monitor.TryEnter(_lockStat2, 60 * 1000);
                //if (!ok)
                //{
                //    misc.log("Pas pu entrer pour générer les stats !!!!!!");
                //    return;
                //}


                File.WriteAllText(BUILDING_STATE, "BUILDING");
                bool generDistrib = step % 10 == 0;

                if (_albumSortMode.createCourant)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(m_listQL).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(m_listQL) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                lock (_lockStat)
                {
                    buildingStat = false;
                    File.WriteAllText(BUILDING_STATE, "FREE");
                }
                if (rappel != null)
                    rappel();
            }
        }

        public void builStats(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 0");
                    return;
                }

            }
            new Thread(() => _buildStat(rappel)).Start();

        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table m�tier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfGen.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.gen.conf;
using pdb.util;
using System.Collections.Generic;
using pdb.gen.albums;

namespace pdb.gen.Tuning
{
    public enum writeGrouping
    {
        none = 0,
        selected = 1,
        mix = 2,
        all = 3,

    }

    public enum datesMode
    {
        play = 1,
        @class = 2,
        classMin = 3,
        mix = 4,
        mixMin = 5

    }

    public class ExtendToNative<T>
    {
        public readonly T item;
        public readonly bool extend;
        public readonly bool extendTimeOrder;
        public readonly bool level;

        public ExtendToNative(T item, bool extend, bool extendTimeOrder, bool level)
        {
            this.item = item;
            this.extend = extend;
            this.extendTimeOrder = extendTimeOrder;
            this.level = level;
        }

        public override string ToString()
        {
            return item.ToString();
        }
    }
    public class ConfGen
    {

        private CConfQL confCourbe = new CConfQL();

        private TimeSpan vie = TimeSpan.FromDays(365);
        datesMode dates;
        private List<ExtendToNative<double>> listes = new List<ExtendToNative<double>>();
        private decimal exp = 1;
        private bool withOrder;
        private bool orderZero;
        private bool orderLarge;
        private bool genE;
        private bool genLarge;
        private bool writeGroupingZero;
        private bool genCheck;
        bool albumOrdo;
        bool onlyEnabled;
        /// <summary>
        /// Simuler la conso du premier élément
        /// </summary>
        private bool anticipation;

        //private double equivDelta = 0.00001;
        //private int equivStep = 100000; 
        private writeGrouping writeGrouping = writeGrouping.selected;
        private writeGrouping writeComment = writeGrouping.all;

        private GroupingDisplay groupingDisplay = new GroupingDisplay(null);

        private DateTime minPlayDate = DateTime.MinValue;
        private DateTime minClassDate = DateTime.MinValue;
        private int offsetPlayDate = 0;
        private int offsetClassDate = 0;
        private int offsetClassMin = 1;
        private int listLimit = int.MaxValue;
        private int listReaderAfter = 0;
        private int listReaderBefore = 0;
      //  private decimal medianne = 0.5m;
        private decimal albumMoyOffset = 0m;

        private List<ExtendToNative<datesMode>> cat = new List<ExtendToNative<datesMode>>();
        private ExtendToNative<int> precisionMin = new ExtendToNative<int>(-1, false, false, false);
        private ExtendToNative<int> precisionMax = new ExtendToNative<int>(-1, false, false, false);

        private ConfAlbumSort albumSortMode = new ConfAlbumSort(); 

     
        private bool albumVirtual = false;
        private bool artistVirtual = false;
        private int artistVirtualMin = -1; 
        private bool navAuto = false; 

        public ConfGen()
        {
        }
        public ConfGen(XmlElement a_xml)
        {
            if (a_xml == null)
                return;
            XMLTool l_xml = new XMLTool(a_xml);
            XmlElement xmlQuality = l_xml.NodeLookUp("courbe");
            
            confCourbe = new CConfQL(xmlQuality);

            var str = l_xml.getNodeValue("dates");
            if (!string.IsNullOrEmpty(str))
                dates = (datesMode)Enum.Parse(typeof(datesMode), str, true);
            var xTime = l_xml.NodeLookUp("time");
            if (xTime != null)
            {
                var _xtime = new XMLTool(xTime);
                string l_str = _xtime.getNodeValue("vie").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    vie = TimeSpan.FromDays(Convert.ToDouble(l_str));

                l_str = _xtime.getNodeValue("exp").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    exp = Convert.ToDecimal(l_str);
            }

            var xLists = l_xml.NodeLookUp("lists");
            if (xLists != null)
            {
                foreach (XmlNode xList in xLists.ChildNodes)
                {
                    if (xList is XmlElement)
                    {

                        double iList = Convert.ToDouble(xList.InnerText);
                        bool extend = false;
                        var att = xList.Attributes["nat"];
                        if (att != null && att.Value == "true")
                            extend = true;

                        bool extendtimeOrder = false;
                        att = xList.Attributes["timeOrder"];
                        if (att != null && att.Value == "true")
                            extendtimeOrder = true;

                        bool _level = false;
                        att = xList.Attributes["level"];
                        if (att != null && att.Value == "true")
                            _level = true;

                        ExtendToNative<double> e = new ExtendToNative<double>(iList, extend, extendtimeOrder, _level);
                        listes.Add(e);
                    }
                }
            }

            str = l_xml.getNodeValue("writeGrouping");
            if (!string.IsNullOrEmpty(str))
                writeGrouping = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("writeComment");
            if (!string.IsNullOrEmpty(str))
                writeComment = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("equivDelta");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.coeffDelta = Convert.ToDecimal(str);

            str = l_xml.getNodeValue("equivStep");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.MAX_STEP = Convert.ToInt32(str);

            var l_display = l_xml.NodeLookUp("display");
            groupingDisplay = new GroupingDisplay(l_display);

            withOrder = l_xml.getBoolValue("withOrder");
            orderLarge = l_xml.getBoolValue("orderLarge");
            orderZero = l_xml.getBoolValue("orderZero");
            genE = l_xml.getBoolValue("genE");
            genLarge = l_xml.getBoolValue("genLarge");
            writeGroupingZero = l_xml.getBoolValue("writeGroupingZero");
            genCheck = l_xml.getBoolValue("genCheck");
            anticipation = l_xml.getBoolValue("anticipation");
            albumOrdo = l_xml.getBoolValue("albumOrdo");
            onlyEnabled = l_xml.getBoolValue("onlyEnabled");
           
            albumVirtual = l_xml.getBoolValue("albumVirtual", albumVirtual);
            artistVirtual = l_xml.getBoolValue("artistVirtual", artistVirtual);


            str = l_xml.getNodeValue("artistVirtualMin");
               if (!string.IsNullOrEmpty(str))
                artistVirtualMin = Convert.ToInt32(str);
         
            navAuto = l_xml.getBoolValue("navAuto", navAuto);

            str = l_xml.getNodeValue("minPlayDate");
            if (!string.IsNullOrEmpty(str))
                minPlayDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("minClassDate");
            if (!string.IsNullOrEmpty(str))
                minClassDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("offsetPlayDate");
            if (!string.IsNullOrEmpty(str))
                offsetPlayDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassDate");
            if (!string.IsNullOrEmpty(str))
                offsetClassDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassMin");
            if (!string.IsNullOrEmpty(str))
                offsetClassMin = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listLimit");
            if (!string.IsNullOrEmpty(str))
                listLimit = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderAfter");
            if (!string.IsNullOrEmpty(str))
                listReaderAfter = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderBefore");
            if (!string.IsNullOrEmpty(str))
                listReaderBefore = Convert.ToInt32(str);

            str = l_xml.getNodeValue("albumMoyOffset");
            if (!string.IsNullOrEmpty(str))
                albumMoyOffset = Convert.ToDecimal(str);
            var xalbumSort = l_xml.NodeLookUp("albumSort");

            albumSortMode = new ConfAlbumSort(xalbumSort); 
        

            var xDir = l_xml.NodeLookUp("dir");
            if (xDir != null)
            {
                foreach (XmlNode xSub in xDir.ChildNodes)
                {
                    if (xSub is XmlElement)
                    {
                        if (xSub.Name == "precision")
                        {
                            var _precisionMin = Convert.ToInt32(xSub.Attributes["min"].Value);
                            bool _extend = false;

                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                _extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;
                            var _precisionMax = Convert.ToInt32(xSub.Attributes["max"].Value);

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;


                            precisionMin = new ExtendToNative<int>(_precisionMin, _extend, _extendtimeOrder, _level);
                            precisionMax = new ExtendToNative<int>(_precisionMax, _extend, _extendtimeOrder, _level);
                        }
                        else
                        {
                            datesMode item = (datesMode)(Enum.Parse(typeof(datesMode), xSub.Name, true));
                            bool extend = false;
                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;

                            cat.Add(new ExtendToNative<datesMode>(item, extend, _extendtimeOrder, _level));

                        }
                    }

                }
            }

        }

        public CConfQL Courbe { get { return confCourbe; } }

        public decimal Exp { get { return exp; } }
        public TimeSpan Vie { get { return vie; } }
        public datesMode Dates { get { return dates; } }
        public List<ExtendToNative<double>> Listes { get { return listes; } }

        //public writeGrouping WriteGrouping { get { return writeGrouping; } }
        //public writeGrouping WriteComment { get { return writeComment; } }
        public timeMode TimeMode { get { return groupingDisplay.TimeMode; } }
        public List<DisplayGrouping> DisplayCategories
        {
            get
            {
                var list = groupingDisplay.Categories;
                var found = list.Find(c => c.category == displayCategory.timeValue);

                int indexCurrentTimeValue = -1; 
                if (found != null)
                    indexCurrentTimeValue = list.IndexOf(found);
                if (indexCurrentTimeValue >= 0)
                {
                    list[indexCurrentTimeValue].category = (displayCategory)dates;
                }

                return list;
            }
        }
        public bool WithOrder { get { return withOrder; } }
        public bool OrderLarge { get { return orderLarge; } }
        public bool OrderZero { get { return orderZero; } }
        public bool GenE { get { return genE; } }
        public bool GenLarge { get { return genLarge; } }
        public bool GenCheck { get { return genCheck; } }
        public bool Anticipation { get { return anticipation; } }
        public bool WriteGroupingZero { get { return writeGroupingZero; } }
        public bool AlbumOrdo { get { return albumOrdo; } }
        public bool OnlyEnabled { get { return onlyEnabled; } }


        public DateTime MinPlayDate { get { return minPlayDate; } }
        public DateTime MinClassDate { get { return minClassDate; } }

        public int OffsetPlayDate { get { return offsetPlayDate; } }
        public int OffsetClassDate { get { return offsetClassDate; } }
        public int OffsetClassMin { get { return offsetClassMin; } }
        public override string ToString()
        {
            return string.Format(" vie:{0} exp:{1} quality:{2} onlyPlayed:{3} writeGrouping:{4} display:{5}", vie, exp, confCourbe, dates, writeGrouping, groupingDisplay);
        }

        public List<ExtendToNative<datesMode>> Modes { get { return cat; } }
        public ExtendToNative<int> PrecisionMin { get { return precisionMin; } }
        public ExtendToNative<int> PrecisionMax { get { return precisionMax; } }
        public int ListLimit { get { return listLimit; } }
        public int ListReaderAfter { get { return listReaderAfter; } }
        public int ListReaderBefore { get { return listReaderBefore; } }
        public decimal AlbumMoyOffset { get { return albumMoyOffset; } }
        public ConfAlbumSort AlbumSort { get { return albumSortMode; } set { albumSortMode = value; } }
        public bool AlbumVirtual { get { return albumVirtual; } }
        public bool ArtistVirtual { get { return artistVirtual; } }
        public int AristVirtualMin { get { return artistVirtualMin; } }
        public bool NavAuto { get { return navAuto; } }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceData.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.value;
using pdb.db.piece.version;
using pdb.util;



namespace pdb.db.piece.data
{

    /// <summary>
    /// Donnée + liste des versions
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class CPieceData<T> : IData, IEnumerable<CPieceDataVersion<T>>
    {
        /// <summary>
        /// Liste des versions
        /// </summary>
        protected List<CPieceDataVersion<T>> m_list = new List<CPieceDataVersion<T>>();
        private static CDataVersionComparerInv c_comparerInv = new CDataVersionComparerInv();

        private bool m_bOverride = false;
        public abstract string getToken();
        public abstract T getNullValue();
        public abstract CPieceDataValue<T> createPieceDataValue(XmlElement a_node);
        public abstract CPieceDataValue<T> createPieceDataValue(string a_value);
        public abstract CPieceDataValue<T> createPieceDataValueT(T value);
        // protected Bool empty = Bool.not_defined;
        //   protected static DateTime _now = DateTime.Now;

        protected IDataObserver observer;
        public IDataObserver Observer { set { observer = value; } }

        public bool Override { get { return m_bOverride; } }


        public static DateTime Now
        {
            get
            {
                return ChronoData.Now;
            }
        }

        #region signaux

        //public class PieceDataChangeNativeEventArgs : EventArgs
        //{
        //    public PieceDataChangeNativeEventArgs(T value) { this.Value = value; }
        //    readonly public T Value;
        //}

        //public class PieceDataChangeLocalEventArgs : EventArgs
        //{
        //    public PieceDataChangeLocalEventArgs(T Old, T New) { this.Old = Old; this.New = New; }
        //    readonly public T Old;
        //    readonly public T New;
        //}

        //  public event EventHandler<PieceDataChangeNativeEventArgs> changeNativeValue;
        private void OnchangeNativeValue(T value) { if (observer != null) changeNativeValue(value); }
        protected abstract void changeNativeValue(T value);

        //  public event EventHandler<PieceDataChangeLocalEventArgs> changeLocalValueByRemote;
        private void OnChangeLocalByRemote(T Old, T New)// { if (changeLocalValueByRemote != null) changeLocalValueByRemote(this, new PieceDataChangeLocalEventArgs(Old, New)); }
        {
            if (observer != null)
                observer.changeByRemote(getToken(), Old, New);
        }
        //  public event EventHandler<PieceDataChangeLocalEventArgs> changeLocalValueByNative;
        private void OnChangeLocalByNative(T Old, T New) // { if (changeLocalValueByNative != null) changeLocalValueByNative(this, new PieceDataChangeLocalEventArgs(Old, New)); }
        {
            if (observer != null)
                observer.changeByNative(getToken(), Old, New);
        }
        //public event EventHandler<PieceDataChangeLocalEventArgs> cannotMerge;
        private void OnCannotMerge(T Old, T New) { }

        // public event EventHandler change;
        private void onChange() { if (observer != null) observer.RefChange(); }
        #endregion


        public CPieceData(CPieceData<T> o)
        {
            foreach (CPieceDataVersion<T> v in o.m_list)
                m_list.Add(new CPieceDataVersion<T>(v)); 
        }

        public CPieceData(string a_value)
        {
            CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(a_value, this);
            m_list.Add(l_version);

        }

        public CPieceData(T value)
        {
            CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(value, this);
            m_list.Add(l_version);
        }

        public CPieceData()
        {
        }






        /// <summary>
        /// Ajoute si nécessaire les versions réciproques 
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>On ne prend en compte que les versions de date définie</remarks>
        /// 




        public void mergeOnlyVersion(CPieceData<T> a_list)
        {
            foreach (CPieceDataVersion<T> l_version in a_list.m_list)
            {
                check(l_version);
            }
            sortAndCompact();
            foreach (CPieceDataVersion<T> l_remote in this.m_list)
            {
                a_list.check(l_remote);
            }
            a_list.sortAndCompact();
        }

        public void mergeAll(CPieceData<T> other, mergePriority a_priority)
        {
            T valueOrg = Value;
            mergeOnlyVersion(other);
            if (!this.Equals(other))
            {
                mergePriority l_ret = this.isMaster(other, a_priority);
                if (l_ret == mergePriority.left)
                {
                    OnChangeLocalByNative(other.Value, this.Value);
                    other.eraseSingleFrom(this);
                }
                else if (l_ret == mergePriority.right)
                {
                    this.eraseSingleFrom(other);
                }
                else
                {
                    OnCannotMerge(this.Value, other.Value);
                }
            }

            if (!Value.Equals(valueOrg))
            {
                onChange();
            }
        }

        /// <summary>
        /// Synchronise les infos de deux pieces (local-distant)
        /// </summary>
        /// <param name="remote">Piece sur fichier pdb_export</param>
        /// <remarks>on teste le cgangement de valeur</remarks>
        public virtual void Consolid(CPieceData<T> remote, mergePriority a_priority)
        {
            sortAndCompact();
            remote.sortAndCompact();
            T l_valueOrg = Value;
            mergeAll(remote, a_priority);

            if (!l_valueOrg.Equals(Value))
            {
                m_bOverride = true;
                OnChangeLocalByRemote(l_valueOrg, Value);
            }

            sortAndCompact();
            remote.sortAndCompact();

        }

        public bool Imported
        {
            get { return m_bOverride; }
        }

        protected virtual void LegacyConsolidByNative(CPieceData<T> local)
        {
            local.eraseSingleFrom(this);
        }

        protected virtual bool canErase()
        {
            return false;
        }

        public void removeVersions()
        {
            sortAndCompact();
            if (m_list.Count > 1)
            {
                m_list = new List<CPieceDataVersion<T>> { m_list[0] };
            }
        }






        public virtual void LegacyConsolid(CPieceData<T> local)
        {
            if (!this.Equals(local))
            {
                mergePriority l_merge = checklegacyModif(local);

                if (l_merge == mergePriority.right)
                {
                    this.m_bOverride = true;
                    this.eraseSingleFrom(local);
                    // this.empty = Bool.not_defined;
                    OnchangeNativeValue(Value);
                }
                else
                {
                    OnChangeLocalByNative(local.Value, this.Value);
                    if ((local.Significant || canErase()) && Now != local.LastModif)
                    {
                        CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(Now, m_list[0].Data);
                        local.m_list.Add(l_version);
                        local.sortAndCompact();
                    }
                    else
                    {
                        local.eraseSingleFrom(this);
                    }
                    //    local.empty = Bool.not_defined;
                }

            }
        }

        public virtual void SynchroNative(T native)
        {
            if (native != null && isSignificant(native) && !Value.Equals(native))
            {
                bool update = true;
                if (native is string)
                {
                    if (native.ToString().Trim().Equals(Value.ToString().Trim()))
                        update = false;
                }

                if (update)
                {
                    OnChangeLocalByNative(this.Value, native);
                    CPieceDataValue<T> newValue = createPieceDataValueT(native);
                    CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(Now, newValue);
                    m_list.Add(l_version);
                    sortAndCompact();
                }
            }
        }

        /// <summary>
        /// Dans le cas d'une égalité de principe, tenter une comparaison basée sur la complétude
        /// </summary>
        /// <param name="remote "></param>
        /// <returns>Indique si la comparaison a été faite</returns>
        /// <remarks></remarks>
        public bool choose(CPieceData<T> remote)
        {
            mergeAll(remote, mergePriority.none);
            // si le merge est effectif (ie l'un des deux a une date définie alors le erge est fait
            // pour provoquer un merge manuel il faut que les deux soient sans date et différents
            return Equals(remote);
        }
        public void mergeManual(CPieceData<T> other)
        {
            //Console.WriteLine("master ? 1 (final:1)   2 ( final:2 ) n:no");
            //string l_resp = Console.ReadLine();
            //if (l_resp == "1")
            //{
            //    Console.WriteLine("merge from first to second");
            //    //Console.WriteLine("merge from second to first")
            //    other.eraseSingleFrom(this);

            //}
            //else if (l_resp == "2")
            //{
            //    Console.WriteLine("merge from second to first");
            //    this.eraseSingleFrom(other);
            //}
            //else
            //{
            Console.WriteLine("abort merge");
            //Return choice.no
            //}
        }

        /// <summary>
        /// Parfois, des valeurs identiques sont indiquées commme des modifications. 
        /// Ordonnancement par ordre chronomogique, et élimination des doublons
        /// </summary>
        protected void sortAndCompact()
        {
            if (m_list.Count < 2) return;
            m_list.Sort(c_comparerInv);
            CPieceDataVersion<T> last = m_list[m_list.Count - 1];
            List<CPieceDataVersion<T>> aux = new List<CPieceDataVersion<T>>(m_list);
            for (int i = m_list.Count - 2; i >= 0; i--)
            {
                CPieceDataVersion<T> current = m_list[i];
                if (current.Data.Equals(last.Data))
                    aux.Remove(current);
                last = current;
            }
            m_list = aux;

        }

        private void eraseSingleFrom(CPieceData<T> a_list)
        {


            if (m_list.Count == 0)
            {
                CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(a_list.m_list[0].Date, a_list.m_list[0].Data);
                m_list.Add(l_version);

            }
            else
            {
                m_list[0].Data = a_list.m_list[0].Data;
            }
            //  empty = Bool.not_defined;

            onChange();


        }



        public bool Equals(CPieceData<T> obj)
        {
            return Value.Equals(obj.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        /// <summary>
        /// détermine quelle info est maitre dans la perspective de les merger
        /// </summary>
        /// <param name="remote"></param>
        /// <param name="a_priority"></param>
        /// <returns>True  : Je suis maître</returns>
        /// <remarks>Pre-condition:  me != remote</remarks>
        private mergePriority isMaster(CPieceData<T> remote, mergePriority a_priority)
        {
            if (this.Equals(remote))
                throw new PieceDbException(this.ToString() + " and " + remote.ToString() + " are equivalent");

            mergePriority l_consistencyComp = compareByConsistency(remote);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (LastModif == System.DateTime.MinValue && remote.LastModif == System.DateTime.MinValue)
            {
                return a_priority;
            }
            else
            {
                return mergePriority.none;
                //  throw new PieceDbException("meme date de modif pourtant les fichiers sont différents!");
            }
        }
        protected virtual bool CheckLegacyConsistency()
        {
            return true;
        }
        private mergePriority checklegacyModif(CPieceData<T> local)
        {
            if (CheckLegacyConsistency())
            {
                mergePriority l_consistencyComp = compareByConsistency(local);
                if (l_consistencyComp != mergePriority.none)
                    return l_consistencyComp;
            }

            if (local.Imported) return mergePriority.right;
            return mergePriority.left;
        }

        private mergePriority checklegacyModif(T native)
        {
            if (CheckLegacyConsistency())
            {
                mergePriority l_consistencyComp = compareByConsistency(native);
                if (l_consistencyComp != mergePriority.none)
                    return l_consistencyComp;
                //right = native qui est master
            }
            if (this.Imported) return mergePriority.left;
            return mergePriority.right;
        }


        private mergePriority compareByConsistency(CPieceData<T> other)
        {
            if (!Significant && other.Significant)
                return mergePriority.right;
            if (Significant && !other.Significant)
                return mergePriority.left;

            if (Empty && !other.Empty)
                return mergePriority.right;
            if (!Empty && other.Empty)
                return mergePriority.left;

            return mergePriority.none;
        }

        private mergePriority compareByConsistency(T native)
        {
            if (!Significant && isSignificant(native))
                return mergePriority.right;
            if (Significant && !isSignificant(native))
                return mergePriority.left;

            return mergePriority.none;
        }

        public System.DateTime LastModif
        {
            get
            {
                if (Empty)
                    return System.DateTime.MinValue;
                //  sortAndCompact();
                return m_list[0].Date;
            }
        }

        protected virtual T getPlainValue()
        {
            return m_list[0].Data.Value; 
        }

        public T Value
        {
            get
            {
                if (Empty)
                    return getNullValue();
                //sortAndCompact();
                //int i = 0;
                //while (true)
                //{
                //    var version = m_list[i];
                //    if (!version.Consider)
                //    {
                //        i++;
                //        continue;
                //    }
                //    return version.Data.Value;
                //}
                return getPlainValue(); 

            }
            set
            {
                if (value.Equals(Value)) return;
                m_list.Insert(0, new CPieceDataVersion<T>(Now, createPieceDataValueT(value)));
                sortAndCompact();

            }
        }

        public void removeLastVersion()
        {
            int count = m_list.Count;
            if (count <= 1)
                return;
            m_list.RemoveAt(0);
            sortAndCompact();
        }

        public T LastValue
        {
            get
            {
                if (Empty)
                    return getNullValue();
                int count = m_list.Count;
                if (count < 2)
                    return getNullValue();
                int i = 1;
                while (true)
                {
                    var version = m_list[i];
                    //if (!version.Consider)
                    //{
                    //    i++;
                    //    if (i >= count)
                    //    {
                    //        return getNullValue();
                    //    }
                    //    continue;
                    //}
                    return version.Data.Value;
                }

            }

        }


        private bool Simple
        {
            get { return (m_list.Count == 1 && m_list[0].Date == System.DateTime.MinValue) || Empty; }
        }
        public bool Empty
        {
            get
            {
                //if (empty == Bool.not_defined)
                //{
                bool ret = m_list.Count == 0 || m_list[0].Empty;
                return ret;
                //    empty = ret ? Bool.True : Bool.False;
                //    return ret;
                //}
                //return empty == Bool.True;

            }
        }

        public bool Significant
        {
            get
            {
                if (m_list.Count > 1)
                    return true;
                return m_list.Count == 1 && m_list[0].Significant;
            }
        }
        public abstract bool isSignificant(T value);



        public void checkList(CPieceData<T> other)
        {
            foreach (CPieceDataVersion<T> version in other)
            {
                check(version);
            }
            sortAndCompact();
        }


        /// <summary>
        /// indique si la liste contient déja la version
        /// </summary>
        /// <param name="a_version">version testée</param>
        /// <returns>True : si version connue</returns>
        /// <remarks>On ne prend en compte que les dates définies</remarks>
        private bool Contains(CPieceDataVersion<T> a_version)
        {
            foreach (CPieceDataVersion<T> l_elt in this)
            {
                System.DateTime l_date = l_elt.Date;
                if (l_date > System.DateTime.MinValue && a_version.Date == l_date)
                {
                    return true;
                }
            }
            return false;
        }


        private void check(CPieceDataVersion<T> a_version)
        {
            if (!Contains(a_version))
            {
                if (a_version.Date > System.DateTime.MinValue)
                {
                    //if (a_version.Consider)
                    //{
                        m_list.Add(a_version);
                        //     empty = Bool.not_defined;
                    //}
                }
            }

        }


        public CPieceData(System.Xml.XmlElement a_node)
        {

            bool l_bSingle = false;

            XmlElement l_Mynode = XMLTool.NodeLookUp(a_node, getToken());

            if (l_Mynode == null)
                return;

            XmlAttribute att = l_Mynode.Attributes[CPieceDataValue<T>.TOKEN];
            if (att != null)
            {
                l_bSingle = true;
            }




            foreach (XmlNode l_node in l_Mynode)
            {
                if (!l_bSingle)
                {

                    if (l_node is XmlElement && l_node.Name == CPieceDataVersion<T>.VERSION)
                    {
                        XmlElement l_elt = (XmlElement)l_node;
                        CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(l_elt, this);
                        if ((!l_version.Data.Empty || canErase()))
                        {
                            m_list.Add(l_version);
                        }
                    }
                    else
                    {
                        l_bSingle = true;
                        // break; // TODO: might not be correct. Was : Exit For
                    }
                }
            }

            if (l_bSingle)
            {
                CPieceDataVersion<T> l_version = null;
                if (l_Mynode != null)
                    l_version = new CPieceDataVersion<T>(l_Mynode, this);
                else
                    l_version = new CPieceDataVersion<T>(att.Value, this);
                m_list.Add(l_version);
            }
            sortAndCompact();
        }




        public void write(ITextWriter a_sw)
        {
            if (Empty)
                return;
            XMLTool.openBalise(a_sw, getToken());
            if (Simple)
            {
                a_sw.Append(m_list[0].Data.ToString());
            }
            else
            {
                sortAndCompact();
                //    m_list.Sort(c_comparerInv); 
                foreach (CPieceDataVersion<T> l_version in m_list)
                {
                    l_version.write(a_sw);
                }
            }
            XMLTool.closeBalise(a_sw, getToken());
        }

        protected virtual void writeSimple(XmlWriter w)
        {
            w.WriteElementString(getToken(), m_list[0].Data.ToString());
            //  w.WriteAttributeString(getToken(), m_list[0].Data.ToString()); 
        }

        public void write(XmlWriter w)
        {
            if (Empty)
                return;
            //  w.WriteStartElement(getToken()); 

            if (Simple)
            {
                writeSimple(w);


            }
            else
            {
                w.WriteStartElement(getToken());
                sortAndCompact();
                //    m_list.Sort(c_comparerInv); 
                foreach (CPieceDataVersion<T> l_version in new List<CPieceDataVersion<T>>(m_list))
                {
                    l_version.write(w);
                }
                w.WriteEndElement();
            }

        }

        public bool HasChange(CPieceData<T> lastFull)
        {
            if (lastFull.Value == null || !lastFull.Value.Equals(Value))
                return true;
            return false;
        }

        public void writeDiff(XmlWriter w, CPieceData<T> lastFull)
        {
            //if (Empty)
            //    return;
            ////  w.WriteStartElement(getToken()); 

            sortAndCompact();
            lastFull.sortAndCompact();

            if (Value == null)
            {
                if (lastFull.Value == null)
                    return;
            }

            if (lastFull.Value == null || !lastFull.Value.Equals(Value))
            {

                if (Simple)
                {
                    if (lastFull.m_list.Count < 1 || m_list.Count < 1 || !(lastFull.m_list[0].Data.Value.Equals(m_list[0].Data.Value)))
                    {
                        writeSimple(w);
                        return;
                    }


                }
                else
                {
                    w.WriteStartElement(getToken());

                    //    m_list.Sort(c_comparerInv); 

                    //int count = lastFull.m_list.Count;
                    //int count0 = count; 
                    //if (m_list.Count > count)
                    //    count = m_list.Count;

                    //for (int i = count -1 ; i >=0; i++)
                    //{
                    //    CPieceDataVersion<T> my = m_list[i];
                    //    CPieceDataVersion<T> old = null;
                    //    if (i < count0 - 1)
                    //        old = lastFull.m_list[i]; 

                    //    if (old == null)



                    //}
                    foreach (CPieceDataVersion<T> l_version in new List<CPieceDataVersion<T>>(m_list))
                    {
                        bool found = false;
                        foreach (CPieceDataVersion<T> l_version_old in new List<CPieceDataVersion<T>>(lastFull.m_list))
                        {
                            if (l_version_old.Date == l_version.Date && l_version_old.Data.Equals(l_version.Data))
                            {
                                found = true;
                                break;
                            }

                        }

                        if (found)
                            continue;
                        l_version.write(w);
                    }
                    w.WriteEndElement();
                }
            }

        }



        public virtual CListDate Dates
        {
            get
            {
                CListDate dates = new CListDate();
                foreach (CPieceDataVersion<T> data in m_list)
                {
                    dates.check(data.Date);
                }
                return dates;
            }
        }
        //private class CDataVersionComparer : IComparer<CPieceDataVersion<T>>
        //{


        //    public int Compare(CPieceDataVersion<T> x, CPieceDataVersion<T> y)
        //    {
        //        return System.DateTime.Compare(x.Date, y.Date);
        //    }
        //}
        private class CDataVersionComparerInv : IComparer<CPieceDataVersion<T>>
        {
            public int Compare(CPieceDataVersion<T> x, CPieceDataVersion<T> y)
            {
                //if (!x.Consider)
                //{
                //    if (!y.Consider)
                //        return -1 * System.DateTime.Compare(x.Date, y.Date);
                //    return 1;
                //}
                //if (!y.Consider)
                //    return -1;

                return - System.DateTime.Compare(x.Date, y.Date);
            }
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return m_list.GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public System.Collections.Generic.IEnumerator<CPieceDataVersion<T>> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceDataClassement.cs">
    <content><![CDATA[using System;
using pdb.db.piece.type;
using pdb.db.piece.value;
using pdb.db.piece.version;
using pdb.util;
using pdb.db.obj;
using System.Collections.Generic;
using System.Xml;
namespace pdb.db.piece.data
{


    public class CPieceClassement : CPieceData<Classement>
    {

        private const string TOKEN_CLASSEMENT = "classement";
        public CPieceClassement(CPieceClassement o)
            : base(o)
        {
        }

        public CPieceClassement(System.Xml.XmlElement a_node)
            : base(a_node)
        {
            if (XMLTool.NodeLookUp(a_node, getToken()) == null)
            {
                CPieceDataValueClassement l_data = new CPieceDataValueClassement(a_node);
                m_list.Add(new CPieceDataVersion<Classement>(DateTime.MinValue, l_data));
            }
            //  int count = m_list.Count;
            //            if (count > 0)
            //            {
            //                var version = m_list[count - 1];
            //                if (string.IsNullOrEmpty(version.Data.Value.ClassList))
            //                {
            //                    version.Consider = false;
            //                    //  empty = Bool.not_defined; 
            //                }
            //#if ASC
            //                var versionF = m_list[0];
            //                var valueOrg = versionF.Data;
            //                var classOrg = valueOrg.Value.ClassList;
            //                var rating = valueOrg.Value.Rating;
            //                if (classOrg.StartsWith("0"))
            //                {
            //                    classOrg = "1";
            //                    rating = 0; 
            //                  //  classOrg = classOrg.Remove(0, 1);
            //                }

            //                valueOrg.Value = new Classement(classOrg, rating); 

            //#endif
            //            }


        }

        public void initClassementIfEmpty(string classement)
        {
            if (m_list.Count > 0)
                return;
            var cl = pdb.db.piece.type.Classement.create(classement);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
        }

        public void eraseClassement()
        {
            m_list = new List<CPieceDataVersion<Classement>>();
            initClassementIfEmpty("0.0");
        }

        public CPieceClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
        }

        public CPieceClassement(string a_class, int a_rating)
        {
            Classement l_class = new Classement(a_class, a_rating);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(l_class)));
            // empty = Bool.not_defined; 

        }

        public CPieceClassement(int a_rating)
            : this("", a_rating)
        {
        }
        public CPieceClassement()
            : base()
        {
        }

        protected override bool CheckLegacyConsistency()
        {
            return false;
        }
        public override CPieceDataValue<Classement> createPieceDataValue(System.Xml.XmlElement a_node)
        {
            return new CPieceDataValueClassement(a_node);
        }

        public override string getToken()
        {
            return TOKEN_CLASSEMENT;
        }

        public override CPieceDataValue<Classement> createPieceDataValue(string a_str)
        {
            return null;
        }

        public override Classement getNullValue()
        {
            return new Classement("", 0);
        }
        public override CPieceDataValue<Classement> createPieceDataValueT(Classement value)
        {
            return new CPieceDataValueClassement(value);
        }

        public override bool isSignificant(Classement value)
        {
            return value.ClassList != "";
        }

        public string ClassList
        {
            get { return Value.ClassList; }


            //TODO A REVOIR
            set
            {
                if (m_list.Count == 0)
                {
                    int l_rating = Rating;
                    Classement l_new = new Classement(value, l_rating);
                    m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(l_new)));
                    //  empty = Bool.False;
                }
                else
                {
                    if (Value.ClassList != value)
                    {
                        //int l_rating = Rating;
                        //Classement l_new = new Classement(value, l_rating);
                        //m_list.Add(new CPieceDataVersion<Classement>(now, new CPieceDataValueClassement(l_new)));
                        m_list[0].Data.Value.ClassList = value;
                    }
                    // empty = Bool.not_defined;
                }
            }
        }

        protected override void writeSimple(XmlWriter w)
        {
            w.WriteStartElement(getToken());
            m_list[0].Data.write(w);
            w.WriteEndElement();
        }

        public void setClassement(string className, int rating)
        {
            Classement cl = new Classement(className, rating);
            if (m_list.Count == 0)
                m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
            else
                m_list[0].Data.Value = cl;
            sortAndCompact();
        }

        public void eraseClassement2()
        {
            Classement cl = Classement.create("0.0");
            eraseClassement2(cl);
        }

        public void eraseClassement2(Classement cl)
        {
            m_list = new List<CPieceDataVersion<Classement>>();
            m_list.Add(new CPieceDataVersion<Classement>(DateTime.MinValue, new CPieceDataValueClassement(cl)));
        }

        public int Rating
        {
            get { return Value.Rating; }
            set { Value.Rating = value; }
        }



        protected override bool canErase()
        {
            return true;
        }

        public override void Consolid(CPieceData<Classement> remote, mergePriority a_priority)
        {
            base.Consolid(remote, a_priority);
            this.checkList(remote);
        }

        public override void LegacyConsolid(CPieceData<Classement> local)
        {
            base.LegacyConsolid(local);
            this.checkList(local);
        }

        public bool isClassListNumeric { get { return Value.isClassListNumeric; } }



        public String Evol
        {
            get
            {

                if (m_list.Count <= 1) return "++";

                Classement last = m_list[0].Data.Value;
                Classement before = m_list[1].Data.Value;

                String strLast = last.ClassNameAndRating;
                String strBefore = before.ClassNameAndRating;

                int cmp = compareClassNameAndRating(strLast, strBefore);
                if (cmp == 0)
                    return "=";  // normalement impossible
                if (cmp < 0) return "+";
                return "-";
            }

        }

        public static int compareClassNameAndRating(string strX, string strY)
        {
            int max = strX.Length > strY.Length ? strX.Length : strY.Length;
            for (int i = 0; i < max; i++)
            {
                int iX = strX.getInt(i); // CUtil.getInt(strX, i);
                int iY = strY.getInt(i);//CUtil.getInt(strY, i);
                if (iX != iY)
                    return -iX.CompareTo(iY);
            }
            return 0;
        }

        public List<DateTime> getDates()
        {
            var list = new List<DateTime>();
            foreach (var version in new List<CPieceDataVersion<Classement>>(m_list))
            {
                list.Add(version.Date);
            }
            return list;

        }

        public override CListDate Dates
        {
            get
            {
                var list = new List<DateTime>();
                //    double current = -1;
                sortAndCompact();
                foreach (var version in new List<CPieceDataVersion<Classement>>(m_list))
                {
                    //double aux = version.Data.Value.getNormValue();
                    //if (aux != current)
                    //{
                    list.Add(version.Date);
                    // current = aux; 
                    //}
                }
                return new CListDate(list);
            }
        }

        public void Menage(CPiece piece)
        {
            sortAndCompact();
            //   misc.log("ménage " + this); 

            var aux = new List<CPieceDataVersion<Classement>>(m_list);


            //// 1. parcours jusqu'à trouver 1.0
            //int index1 = -1;
            //int count = aux.Count;

            //for (int i = 0; i < count; i++)
            //{
            //   CPieceDataVersion <Classement> clv = aux[i];
            //   if (clv.Data.Value.getNormValue() == 1)
            //   {
            //       index1 = i;
            //       break; 
            //   }
            //}

            //if (index1 >= 0)
            //{
            //    while (aux.Count > index1 + 1)
            //    {
            //        misc.log( piece  + " suppression " + aux[index1 + 1] + " cause départ à 1");
            //        aux.RemoveAt(index1 + 1);
            //    }
            //}

            //2. vérification des allez-retours 
            int count = aux.Count;

            while (count > 2)
            {
                for (int i = 0; i < count; i++)
                {
                    var clv0 = aux[i].Data.Value;
                    if (i + 2 >= count)
                    {
                        count = -1;
                        break;
                    }
                    var clv2 = aux[i + 2].Data.Value;
                    if (clv2.getNormValue() == clv0.getNormValue())
                    {
                        misc.log(piece + "suppression " + aux[i] + " cause doublon avec " + aux[i + 2]);
                        aux.RemoveAt(i);
                        count = aux.Count;
                        break;
                    }
                }

            }

            m_list = aux;
            sortAndCompact();



        }

        public override string ToString()
        {
            return Value.ToString();
        }

        protected override void changeNativeValue(Classement value)
        {
            observer.changeNativeValueClassement(value);
        }

        #region on repart de zero
        private static DateTime dateMin;
        public static DateTime DateMin { set { dateMin = value; } }

        protected override Classement getPlainValue()
        {
            if (m_list[0].Date < dateMin)
            {
                if (m_list[0].Data.Empty)
                    return getNullValue();
                return new Classement("0", 0);
            }
            return base.getPlainValue();
        }
        #endregion

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\version\CPieceDataVersion.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.value;
using pdb.util;
namespace pdb.db.piece.version
{

    /// <summary>
    /// Enregistrement d'une version d'une valeur
    /// deux parties = date de modif et valeur (générique)
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <remarks></remarks>
    public class CPieceDataVersion<T> : IData
    {
        public const string VERSION = "version";
        private const string TOKEN_DATE = "date";
        private System.DateTime m_date;

        protected CPieceDataValue<T> m_value;
        public CPieceDataVersion(System.DateTime a_date, CPieceDataValue<T> a_value)
        {
            m_date = a_date;
            m_value = a_value;
        }

        public CPieceDataVersion(CPieceDataVersion<T>  o)
        {
            m_date = o.m_date;
            m_value = o.m_value.createCopy();             
        }

      

        //private bool _consider = true;
        //public bool Consider { get { return _consider; } set { _consider = value; } }

        

        public CPieceDataVersion(XmlElement a_node, CPieceData<T> a_pieceData)
        {
            System.DateTime l_date = System.DateTime.MinValue;
            XMLTool l_xml = new XMLTool(a_node);
            string l_strDate = l_xml.getNodeValue(TOKEN_DATE);
            if (string.IsNullOrEmpty(l_strDate))
            {
                var att = a_node.Attributes[TOKEN_DATE];
                if (att != null)
                    l_strDate = att.Value;
            }
            if (!string.IsNullOrEmpty(l_strDate))
                l_date = Convert.ToDateTime(l_strDate);
            m_date = l_date;
            m_value = a_pieceData.createPieceDataValue(a_node);
        }


        public CPieceDataVersion(string a_value, CPieceData<T> a_pieceData)
        {
            m_date = System.DateTime.MinValue;
            m_value = a_pieceData.createPieceDataValue(a_value.TrimSafe());
        }

        public CPieceDataVersion(T value, CPieceData<T> a_pieceData)
        {
            m_date = System.DateTime.MinValue;
            m_value = a_pieceData.createPieceDataValueT(value);
        }

        public bool Significant
        {
            get { return m_value.Significant; }
        }
        public bool Empty
        {
            get { return (m_date == System.DateTime.MinValue && m_value.Empty);} //|| (!_consider); }
        }
        public System.DateTime Date
        {
            get { return m_date; }
        }
        public CPieceDataValue<T> Data
        {
            get { return m_value; }
            set { m_value = value; }
        }

        public override string ToString()
        {
            return m_date + ":" + m_value.Value;
        }

        public void write(ITextWriter a_sw)
        {
            if (Empty)
                return;
            XMLTool.openBalise(a_sw, VERSION);
            if (m_date > System.DateTime.MinValue)
                XMLTool.writeValue(a_sw, TOKEN_DATE, m_date.ToString());
            m_value.write(a_sw);
            XMLTool.closeBalise(a_sw, VERSION);
        }

        #region IData Members


        public void write(XmlWriter w)
        {
            if (Empty)
                return;


            w.WriteStartElement(VERSION);
            if (m_date > System.DateTime.MinValue)
                w.WriteAttributeString(TOKEN_DATE, m_date.ToString());
            //  w.WriteElementString(TOKEN_DATE, m_date.ToString()); 
            m_value.write(w);
            w.WriteEndElement();
        }

        #endregion
    }
}
]]></content>
  </file>
</db>
