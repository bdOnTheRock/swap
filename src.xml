<db path="C:\Bernard\db1\pd4bb">
  <file path="\pdb.util\PathUtil.cs">
    <content><![CDATA[using System.IO;

namespace pdb.util
{
    public static class PathUtil
    {
        /// <summary>
        /// Suffixe un nom de fichier "genre en .org" en préservant l'extension
        /// </summary>
        /// <param name="path"></param>
        /// <param name="suffix"></param>
        /// <returns></returns>
        public static string suffixPath(this string path, string suffix)
        {
            return string.Format("{0}{1}{2}", Path.GetFileNameWithoutExtension(path), suffix, Path.GetExtension(path));
        }
        /// <summary>
        /// Sauvegarde un fichier en écrasant si besoin la sauvegarde précédente
        /// </summary>
        /// <param name="path"></param>
        /// <param name="suffix"></param>
        /// <returns></returns>
        public static FileInfo Sov(this string path, string suffix)
        {
            var file = new FileInfo(path);
            if (!file.Exists)
                return null;
            var sov = string.Format(@"{0}\{1}{2}{3}", file.Directory.FullName, Path.GetFileNameWithoutExtension(file.Name), suffix, Path.GetExtension(file.Name));

            var fsov = file.CopyTo(sov, true);
            file.Delete();
            return fsov;
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\pdb.util.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.util</RootNamespace>
    <AssemblyName>pdb.util</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Debug\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AsyncFileWriter.cs" />
    <Compile Include="BgDict.cs" />
    <Compile Include="CalcMedianne.cs" />
    <Compile Include="Chrono.cs" />
    <Compile Include="CustomFormat.cs" />
    <Compile Include="CUtil.cs" />
    <Compile Include="DateUtil.cs" />
    <Compile Include="DecimalIndex.cs" />
    <Compile Include="DescBuilder.cs" />
    <Compile Include="Dict.cs" />
    <Compile Include="FileRegister.cs" />
    <Compile Include="FileRotator.cs" />
    <Compile Include="FileType.cs" />
    <Compile Include="Generic\Attributs\AttributeHelper.cs" />
    <Compile Include="Generic\Attributs\CustomAttribute.cs" />
    <Compile Include="Generic\Attributs\Db\DbAttributes.cs" />
    <Compile Include="Generic\Attributs\Db\SbAttributes.cs" />
    <Compile Include="Generic\Attributs\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Json\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\NameAttributeBase.cs" />
    <Compile Include="Generic\Attributs\Sp\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Xml\XmlAttributes.cs" />
    <Compile Include="Generic\Encode\Getters.cs" />
    <Compile Include="Generic\Encode\JSON.cs" />
    <Compile Include="Generic\Encode\JsonEncoder.cs" />
    <Compile Include="Generic\Encode\JsonParser.cs" />
    <Compile Include="Generic\Encode\JsonSerializer.cs" />
    <Compile Include="Generic\Encode\JsonXmlEncoder.cs" />
    <Compile Include="Generic\Encode\SafeDictionary.cs" />
    <Compile Include="Generic\INode.cs" />
    <Compile Include="Generic\MappingException.cs" />
    <Compile Include="Generic\Parse\DbParser.cs" />
    <Compile Include="Generic\Parse\DbWrapper.cs" />
    <Compile Include="Generic\Parse\JsonParser.cs" />
    <Compile Include="Generic\Parse\Json\JsonBuilder.cs" />
    <Compile Include="Generic\Parse\Json\JsonParseException.cs" />
    <Compile Include="Generic\Parse\Json\JsonState.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateDeuxPoints.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateFinal.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateName.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValue.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValueIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonWrapper.cs" />
    <Compile Include="Generic\Parse\Node.cs" />
    <Compile Include="Generic\Parse\Parser.cs" />
    <Compile Include="Generic\Parse\ParserBase.cs" />
    <Compile Include="Generic\Parse\XmlParser.cs" />
    <Compile Include="Generic\Parse\XmlSerializer.cs" />
    <Compile Include="Generic\Parse\XmlWrapper.cs" />
    <Compile Include="Generic\TypeInfo.cs" />
    <Compile Include="Generic\Utils.cs" />
    <Compile Include="Generic\XmlParser.cs" />
    <Compile Include="Generic\XmlSerializer.cs" />
    <Compile Include="list\DictList.cs" />
    <Compile Include="DictLocation.cs" />
    <Compile Include="DisposableCounter.cs" />
    <Compile Include="FileUtil.cs" />
    <Compile Include="HashList.cs" />
    <Compile Include="ILogger.cs" />
    <Compile Include="list\LinkedList.cs" />
    <Compile Include="list\SequentialDict.cs" />
    <Compile Include="list\SequentialDictString.cs" />
    <Compile Include="Locker.cs" />
    <Compile Include="Logger.cs" />
    <Compile Include="LoggerConsole.cs" />
    <Compile Include="Math.cs" />
    <Compile Include="MemUtil.cs" />
    <Compile Include="misc.cs" />
    <Compile Include="OutputRecorder.cs" />
    <Compile Include="PathUtil.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Queue.cs" />
    <Compile Include="serialize\Serializer.cs" />
    <Compile Include="serialize\TextSerializer.cs" />
    <Compile Include="StringUtil.cs" />
    <Compile Include="TextWriter.cs" />
    <Compile Include="ThreadUtil.cs" />
    <Compile Include="TimeSpan.cs" />
    <Compile Include="TuningBase.cs" />
    <Compile Include="XMLTool.cs" />
    <Compile Include="ZipUtil.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\auto\ConfMedianneVirt.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using Math = pdb.util.Math;
using StringBuilder = pdb.util.StringBuilder;

namespace pdb.gen.auto
{
    public partial class ConfMedianneVirt : TuningBase
    {
        [NonSerialized]
        const string PATH_DYN = "..\\dynamic";
        private string Path { get { return string.Format("{0}{1}", DIR_CONF, fdata); } }
        private string PathC { get { return string.Format("{0}{1}", DIR_CONF, fdatac); } }
        private string PathDiff { get { return string.Format("{0}{1}", DIR_CONF, fdiff); } }
        private string PathDiffTmp { get { return string.Format("{0}{1}", DIR_CONF, fdiffTmp); } }
        // private string PathLastFull { get { return string.Format("{0}{1}", DIR_CONF, flast); } }
        const string PATH_DYN_DIFF = "..\\dynamic_diff";


        const int NB_HISTO = 1000000;
        public int safe;
        public decimal coeffVirt = 1m;
        public double virtDelay = 1.0;



        public string name;


        /// <summary>
        /// lié au mode db
        /// </summary>
        public dbMode mode;
        /// <summary>
        /// fichier ou est consigné l'historique courant
        /// </summary>
        public string fdata;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique
        /// </summary>
        public string fdiff;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique en mode full en vue de la sauvegarfe
        /// </summary>
        public string fdiffTmp;
        ///// <summary>
        ///// fichier ou est consigné la dernière sauvegarde full de l'historique
        ///// </summary>
        //public string flast;
        /// <summary>
        /// Fichier historique compressé
        /// </summary>
        public string fdatac;

        public int indexDiff = 0;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        /// <summary>
        /// calcul du coeff en fonction du nombre de pistes
        /// </summary>
        public bool coeffVirtAuto;
        /// <summary>
        ///  calcul du coeff en fonction du nombre de pistes dans tous les cas
        /// </summary>
        public bool coeffVirtAutoAll;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;

        public int serialp = 1;
        public int serialm = 1;
        public int serialAlt = 1;
        public decimal serialElastique = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique1dm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique1dp = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique2dm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique2dp = 1m;






        /// <summary>
        /// Coeff appliqué à _nbElastique quand  pas chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique1sm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique quand pas chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique1sp = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand pas chgt de direction et selectedByCoeff
        /// </summary>
        public decimal coeffElastique2sm = 1m;

        /// <summary>
        /// Coeff appliqué à _nbElastique2 quand pas chgt de direction et non selectedByCoeff
        /// </summary>
        public decimal coeffElastique2sp = 1m;


        //public decimal coeffElastique1 = 1m;
        //public decimal coeffElastique2 = 1m;

        //public decimal coeffElastique1r = 1m;
        //public decimal coeffElastique2r = 1m;

        /// <summary>
        /// pas de calcul
        /// </summary>
        public decimal pas = 0.1m;
        /// <summary>
        /// vitesse : augmentation ou diminution du coeff virtuel
        /// </summary>
        public decimal v;

        /// <summary>
        /// variation de la vitesse en proportion
        /// </summary>
        public decimal vv = 1.1m;

        ///// <summary>
        ///// Vitesse virtuelle : pour calculer l'accélaration en tenant compte des contraintes en simulant un augmentation. Mauvaise idée. toujours egal à v en cas de contrainte
        ///// </summary>
        //private decimal vv;
        /// <summary>
        /// borne visant à limiter le delta entre deux pas
        /// </summary>
        public decimal d0 = 0.01m;
        //  public decimal dcoeffm;


        /// <summary>
        /// accélération : augmentation ou diminution de la vitesse
        /// </summary>
        public decimal a;
        //public decimal a0 =0.01m;
        //public decimal dconvergence01;
        /// <summary>
        /// variation de l'accélération en proportion
        /// </summary>
        public decimal aa = 0.01m;
        /// <summary>
        ///accélaration plancher
        /// </summary>
        public decimal aepsilon = 0.001m;

        /// <summary>
        /// ecart min entre deux positions
        /// </summary>
        private decimal epsilon = 0.001m * 0.001m;
        /// <summary>
        /// ecart de vitesse entre deux positions
        /// </summary>
        private decimal vepsilon = 0.001m * 0.001m;

        private bool? lastDelta;
        private bool? lastAutoDirection;
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        private int _nbSameDirection;
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        private int _nbSameDirectionBox;
        /// <summary>
        /// nb allez/retour pour calcul
        /// </summary>
        private int _nbAlt;
        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique;

        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique2;
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        private int _nbAltHisto;

        /// <summary>
        /// Quand plusieurs montées consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticp = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticm = 1;

        /// <summary>
        /// Après plusieurs montées consécutives : retour au coeff nominal 
        /// </summary>
        private decimal coeffStaticpRetour = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : retour au coeff nominal 
        /// </summary>
        private decimal coeffStaticmRetour = 1;
        public decimal CoeffStaticmRetour { get { return coeffStaticmRetour; } }

        /// <summary>
        /// Retour mode large
        /// </summary>
        private bool coeffStaticRetourLarge;

        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des montées consécutives
        /// </summary>
        private decimal currentStaticp = 1;
        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des descentes consécutives
        /// </summary>
        private decimal currentStaticm = 1;
        public decimal CurrentStaticm { get { return currentStaticm; } }

        /// <summary>
        /// On gere spécifiquement le cas des descentes consécutives
        /// </summary>
        public bool checkFall;

        /// <summary>
        /// Rapport de vitesse négative / vitesse positive
        /// </summary>
        private decimal rapportmp = 1m;
        /// <summary>
        /// anti atténuation
        /// </summary>
        //public decimal danticonvergence = 1m;
        //public decimal danticonvergence0;
        //public decimal danticonvergence01;

        //public decimal danticonvdeltap = 1m;
        //public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        private List<HistoValue> histo = new List<HistoValue>();
        //  private List<decimal> histoDiff = new List<decimal>();

        private decimal coeffOld = 1m;

        public bool oldAsZero;
        private bool coeffOldAuto;
        public bool coeffOldSwap;
        public int coeffOldAutoLevel;
        private bool use;


        public bool Use { get { return use; } }

        public ConfMedianneVirt()
        { }

        public ConfMedianneVirt(ConfMedianneVirt o, bool raz)
            : this(o)
        {
            if (raz)
            {
                // safe = 0;
                coeffOld = 1;
                coeffVirt = 1;
            }
        }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            name = o.name;
            mode = o.mode;
            fdata = o.fdata;
            fdatac = o.fdatac;
            fdiff = o.fdiff;
            fdiffTmp = o.fdiffTmp;
            //  flast = o.flast;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAutoAll = o.coeffVirtAutoAll;

            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            //dcoeffp = o.dcoeffp;
            //dcoeffm = o.dcoeffm;
            //dconvergence = o.dconvergence;
            //dconvdeltap = o.dconvdeltap;
            //dconvdeltam = o.dconvdeltam;
            //danticonvergence = o.danticonvergence;
            //danticonvdeltap = o.danticonvdeltap;
            //danticonvdeltam = o.danticonvdeltam;

            pas = o.pas;
            v = o.v;
            d0 = o.d0;
            a = o.a;
            aa = o.aa;
            aepsilon = o.aepsilon;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            serialAlt = o.serialAlt;

            serialElastique = o.serialElastique;
            coeffElastique1dm = o.coeffElastique1dm;
            coeffElastique1dp = o.coeffElastique1dp;
            coeffElastique1sm = o.coeffElastique1sm;
            coeffElastique1sp = o.coeffElastique1sp;
            coeffElastique2dm = o.coeffElastique2dm;
            coeffElastique2dp = o.coeffElastique2dp;
            coeffElastique2sm = o.coeffElastique2sm;
            coeffElastique2sp = o.coeffElastique2sp;


            _nbSameDirection = o._nbSameDirection;
            _nbSameDirectionBox = o._nbSameDirectionBox;
            _nbAlt = o._nbAlt;
            _nbAltHisto = o._nbAltHisto;
            _nbElastique = o._nbElastique;
            _nbElastique2 = o._nbElastique2;

            coeffOld = o.coeffOld;
            coeffOldAuto = o.coeffOldAuto;
            coeffOldSwap = o.coeffOldSwap;
            oldAsZero = o.oldAsZero;
            coeffOldAutoLevel = o.coeffOldAutoLevel;
            epsilon = o.epsilon;

            //dconvergence0 = o.dconvergence0;
            //dconvergence01 = o.dconvergence01;
            //danticonvergence0 = o.danticonvergence0;
            //danticonvergence01 = o.danticonvergence01;

            lastDelta = o.lastDelta;
            use = o.use;
            coeffStaticRetourLarge = o.coeffStaticRetourLarge;
            this.checkFall = o.checkFall;
            this.virtDelay = o.virtDelay;
            histo = new List<HistoValue>(o.histo);

        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var str = "";
            builds("mode", v => str = v);
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);
            builds("name", v => name = v);
            builds("fdata", v => fdata = v);
            builds("fdatac", v => fdatac = v);
            builds("fdiff", v => fdiff = v);
            builds("fdiffTmp", v => fdiffTmp = v);
            // builds("flast", v => flast = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAutoAll", v => coeffVirtAutoAll = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);

            builddec("pas", v => pas = v);
            builddec("v", vv => v = vv);
            builddec("dv", v => dv = v);
            builddec("d0", v => d0 = v);
            builddec("a", v => a = v);
            builddec("aa", v => aa = v);
            builddec("vepsilon", v => vepsilon = v);
            builddec("aepsilon", v => aepsilon = v);


            //builddec("dcoeffp", v => dcoeffp = v);
            //builddec("dcoeffm", v => dcoeffm = v);
            //builddec("dconvergence", v => dconvergence = v);
            //builddec("dconvergence0", v => dconvergence0 = v);
            //builddec("dconvergence01", v => dconvergence01 = v);
            //builddec("dconvdeltap", v => dconvdeltap = v);
            //builddec("dconvdeltam", v => dconvdeltam = v);

            //builddec("danticonvergence", v => danticonvergence = v);
            //builddec("danticonvergence0", v => danticonvergence0 = v);
            //builddec("danticonvergence01", v => danticonvergence01 = v);
            //builddec("danticonvdeltap", v => danticonvdeltap = v);
            //builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serialAlt", v => serialAlt = v);
            buildi("elastique", v => serialElastique = v);


            builddec("coeffElastique1dm", v => coeffElastique1dm = v);
            builddec("coeffElastique1dp", v => coeffElastique1dp = v);
            builddec("coeffElastique1sm", v => coeffElastique1sm = v);
            builddec("coeffElastique1sp", v => coeffElastique1sp = v);
            builddec("coeffElastique2dm", v => coeffElastique2dm = v);
            builddec("coeffElastique2dp", v => coeffElastique2dp = v);

            builddec("coeffElastique2sm", v => coeffElastique2sm = v);
            builddec("coeffElastique2sp", v => coeffElastique2sp = v);


            buildi("serial", v => _nbSameDirection = v);
            buildi("serialBox", v => _nbSameDirectionBox = v);
            buildi("serialAltC", v => _nbAlt = v);
            buildi("serialAltH", v => _nbAltHisto = v);
            builddec("elastiqueC", v => _nbElastique = v);
            builddec("elastiqueC2", v => _nbElastique2 = v);


            builddec("coeffOld", v => coeffOld = v);
            buildb("oldAsZero", v => oldAsZero = v);
            buildb("coeffOldAuto", v => coeffOldAuto = v);
            buildb("coeffOldSwap", v => coeffOldSwap = v);
            buildi("coeffOldAutoLevel", v => coeffOldAutoLevel = v);
            builddec("epsilon", v => epsilon = v);

            buildbn("lastDelta", v => lastDelta = v);

            builddec("coeffStaticp", v => coeffStaticp = v);
            builddec("coeffStaticm", v => coeffStaticm = v);

            builddec("coeffStaticpRetour", v => coeffStaticpRetour = v);
            builddec("coeffStaticmRetour", v => coeffStaticmRetour = v);
            buildb("coeffStaticRetourLarge", v => coeffStaticRetourLarge = v);


            builddec("currentStaticp", v => currentStaticp = v);
            builddec("currentStaticm", v => currentStaticm = v);
            builddec("rapportmp", v => rapportmp = v);

            buildb("use", v => use = v);
            buildb("checkFall", v => checkFall = v);
            buildd("virtDelay", v => virtDelay = v);


            HistoValue last = null;
            var xhisto = XMLTool.NodeLookUp(child, "histo");
            if (xhisto != null)
            {
                foreach (XmlElement sub in xhisto.ChildNodes)
                {
                    var _nevw = new HistoValue(sub.InnerText, last);
                    histo.Add(_nevw);
                    last = _nevw;
                }
            }
            else
            {

                if (File.Exists(Path))
                {
                    var lines = File.ReadAllLines(Path);
                    for (int i = 0; i < lines.GetLength(0); i++)
                    {
                        try
                        {
                            var line = lines[i];

                            if (string.IsNullOrEmpty(line))
                                continue;
                            var _nevw = new HistoValue(line, last);
                            histo.Add(_nevw);
                            last = _nevw;
                        }
                        catch (Exception ex)
                        {
                            misc.log(string.Format("impossible de lire la ligne n° {0}:{1}", i + 1, lines[i]), ex);
                            throw;
                        }
                    }
                    indexDiff = histo.Count;

                    //if (histo.Count >0 )
                    //    coeffVirt = getCoeff(histo[histo.Count -1]);


                }

                if (File.Exists(PathDiff))
                {
                    var histoDiff = new List<HistoValue>();
                    var lines = File.ReadAllLines(PathDiff);
                    for (int i = 0; i < lines.GetLength(0); i++)
                    {
                        try
                        {
                            var line = lines[i];
                            if (string.IsNullOrEmpty(line))
                                continue;

                            var _nevw = new HistoValue(line, last);
                            histoDiff.Add(_nevw);
                            last = _nevw;
                        }
                        catch (Exception ex)
                        {
                            misc.log(string.Format("impossible de lire la ligne n° {0}:{1}", i + 1, lines[i]), ex);
                            throw;
                        }

                    }

                    if (mode == dbMode.full)
                    {
                        histo.AddRange(histoDiff);
                        indexDiff = histo.Count;
                    }
                    else
                    {
                        indexDiff = histo.Count - histoDiff.Count;
                    }

                }



                if (mode == dbMode.full)
                {
                    PathDiff.Sov("0");                    
                }
                   

                if (histo.Count > 0)
                {
                    int index = histo.Count - 1;
                    decimal current = histo[index].coeff;
                    //coeffVirt = getCoeff(current);
                    bool? sens = null;

                    int nbSerie = 0;
                    // decimal delta = 0m;

                    var rr = 1;
                    //if (dcoeffp > 0)
                    //    rr = dcoeffm / dcoeffp;
                    if (rr > 0)
                    {
                        while (true)
                        {
                            index--;
                            if (index < 0)
                                break;
                            var aux = histo[index].coeff;
                            var _sens = current > aux;
                            if (sens == null)
                            {
                                sens = _sens;
                                lastAutoDirection = !_sens;

                                // delta = current - aux;
                            }


                            if (sens != _sens)
                                break;
                            current = aux;
                            nbSerie++;

                        }

                        //_nbSameDirection = nbSerie;
                        //dcoeffp = Math.Abs(delta); dcoeffm = dcoeffp * rr;

                    }
                }
            }

            checkCoeffOld();
            //if (histoDiff.Count > 0)
            //    coeffVirt = getCoeff(histo[histo.Count - 1]); 

        }



        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("name", name);
            write("mode", mode);
            write("use", use);
            write("serial", _nbSameDirection);
            write("elastiqueC", _nbElastique);
            write("elastiqueC2", _nbElastique2);

            write("coeffVirt", coeffVirt);
            write("coeffOld", coeffOld);
            write("serialBox", _nbSameDirectionBox);
            write("serialAltC", _nbAlt);
            write("serialAltH", _nbAltHisto);

            write("coeffStaticp", coeffStaticp);
            write("coeffStaticm", coeffStaticm);
            write("coeffStaticpRetour", coeffStaticpRetour);
            write("coeffStaticmRetour", coeffStaticmRetour);
            write("coeffStaticRetourLarge", coeffStaticRetourLarge);
            write("currentStaticp", currentStaticp);
            write("currentStaticm", currentStaticm);

            write("lastDelta", lastDelta);

            write("serialAlt", serialAlt);
            write("elastique", serialElastique);

            write("fdata", fdata);
            write("fdatac", fdatac);
            write("fdiff", fdiff);
            write("fdiffTmp", fdiffTmp);


            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAutoAll", coeffVirtAutoAll);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);

            write("pas", pas);
            write("v", v);
            write("dv", dv);
            write("d0", d0);
            write("a", a);
            write("aa", aa);
            write("aepsilon", aepsilon);
            write("vepsilon", vepsilon);
            write("rapportmp", rapportmp);

            //write("dcoeffp", dcoeffp);
            //write("dcoeffm", dcoeffm);
            //write("dconvergence", dconvergence);
            //write("dconvergence0", dconvergence0);
            //write("dconvergence01", dconvergence01);
            //write("dconvdeltap", dconvdeltap);
            //write("dconvdeltam", dconvdeltam);

            //write("danticonvergence", danticonvergence);
            //write("danticonvergence0", danticonvergence0);
            //write("danticonvergence01", danticonvergence01);
            //write("danticonvdeltap", danticonvdeltap);
            //write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);

            write("checkFall", checkFall);





            write("oldAsZero", oldAsZero);
            write("coeffOldAuto", coeffOldAuto);
            write("coeffOldSwap", coeffOldSwap);

            write("coeffOldAutoLevel", coeffOldAutoLevel);
            write("epsilon", epsilon);

            write("coeffElastique1dm", coeffElastique1dm);
            write("coeffElastique1dp", coeffElastique1dp);
            write("coeffElastique1sm", coeffElastique1sm);
            write("coeffElastique1sp", coeffElastique1sp);


            write("coeffElastique2dm", coeffElastique2dm);
            write("coeffElastique2dp", coeffElastique2dp);
            write("coeffElastique2sm", coeffElastique2sm);
            write("coeffElastique2sp", coeffElastique2sp);

            write("virtDelay", virtDelay);


            var sb = new StringBuilder();
            var sbDiff = new StringBuilder();
            var sbc = new StringBuilder();




            //if (modeDiff)
            //{
            //    histoDiff = null;
            //}
            //else
            //{
            //    if (histoDiff != null)
            //    {
            //        histo.AddRange(histoDiff);
            //        histoDiff = null;
            //    }

            //    if (File.Exists(PathDiff))
            //        File.Delete(PathDiff);
            //}

            int count = histo.Count;
            HistoValue last = null;
            for (int i = 0; i < count; i++)
            {
                histo[i].write(sb);
                histo[i].writeDiff(sbc, last);

                if (i >= indexDiff)
                    histo[i].writeDiff(sbDiff, last);

                last = histo[i];
            }


            if (!string.IsNullOrEmpty(fdata))
            {
                AsyncFileWriter.Instance.post(Path, sb.ToString());
                if (mode == dbMode.diff)
                    AsyncFileWriter.Instance.post(PathDiff, sbDiff.ToString());
                else
                    AsyncFileWriter.Instance.post(PathDiffTmp, sbDiff.ToString());


                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);
            }

            if (!string.IsNullOrEmpty(fdatac))
            {
                AsyncFileWriter.Instance.post(PathC, sbc.ToString());
            }


            writeEnd();
        }
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        public int Serial { get { return _nbSameDirection; } set { _nbSameDirection = value; } }
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        public int SerialBox { get { return _nbSameDirectionBox; } }
        /// <summary>
        /// nb allez-retours pour calcul
        /// </summary>
        public int Alt { get { return _nbAlt; } }
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        public int AltHisto { get { return _nbAltHisto; } }
        /// <summary>
        /// Position de l'élastique. Positif : tend à agrandir le delta. du à plusieurs séries dans le même sens. Négatif : tend à diminuer le delta. du à plusieurs allez-retours consécutifs
        /// </summary>
        public decimal Elastique { get { return _nbElastique; } }
        public decimal Elastique2 { get { return _nbElastique2; } }
        public decimal dv = 0;
        public decimal dx = 0m;
        public decimal dcoeff = 1;
        //  public decimal da;
        public decimal AccelerationRapport { get { return dv / epsilon; } }
        public decimal VitesseRapport { get { return dx / epsilon; } }
        public decimal danticonvergenceMin
        {
            get
            {
                return epsilon;
            }
        }




        public decimal CoeffOld
        {
            get { return coeffOld; }
            set { coeffOld = value; checkCoeffOld(); }
        }

        public bool CoeffOldAuto
        {
            get { return coeffOldAuto; }
            set { coeffOldAuto = value; checkCoeffOld(); }
        }

        //private decimal getCoeff(decimal coeffT) { return Math.Pow(coeffT, (1.0m / safe)); }


    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\CListPiece.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
/// <summary>
/// Liste de pieces contenues dans un fichier
/// Liste de pieces � sauvegarder
/// </summary>
/// <remarks>
/// La liste doit s'assurer de l'absence de doublons
/// maintenir une r�f�rence unique pour un morceau
/// 
/// 
/// </remarks>
namespace pdb.db
{
    public interface IReference
    {
        void referenceChange(CPiece piece);
    }

    public class CListPiece : IData, IReference
    {

        public const string TOKEN_LISTS = "lists";
        public const string TOKEN_LIST = "l";
        public const string TOKEN_FOLDER = "f";
        public const string TOKEN_LIST_NAME = "n";
        public const string TOKEN_LIST_TRACK = "t";

        private System.DateTime m_date = System.DateTime.MinValue;

        private DictRef<CPiece> ht = new DictRef<CPiece>();
        private BgDict<int, CPiece> htIds = new BgDict<int, CPiece>();
        private BgDictString<CPiece> htLoc = new BgDictString<CPiece>();
        private PlayList listes = new PlayList("listes");
        public PlayList Listes { get { return listes; } }

        public const string PIECES = "pieces";
        #region "constructeurs"
        /// <summary>
        /// Création à partir d'une simple collection de Piece
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>recherche doublons - merge manuel �ventuel</remarks>
        public CListPiece(ICollection<CPiece> a_list, System.DateTime a_date)
            : this()
        {
            m_date = a_date;
            foreach (CPiece l_file in a_list)
            {
                htIds[l_file.PieceId] = l_file;
                foreach (CFile file in l_file.Files)
                {
                    htLoc[file.Path] = l_file;
                }
            }

            foreach (CPiece piece in a_list)
            {
                int parentId = piece.PieceParentId;
                if (parentId > 0)
                {
                    piece.setParent(htIds[parentId]);
                }

                //if (!piece.Exists)
                //{
                //    misc.log("absent: {0}", piece.PathAndRef + " " + piece.Comment);
                //}
            }



            //DateTime maxEnabled = DateTime.MinValue;
            foreach (CPiece l_file in a_list)
            {
                Add(l_file);
                //if (l_file.Enabled)
                //{
                //    var t = l_file.LastModifClass;
                //    if (t > maxEnabled)
                //        maxEnabled = t;
                //}
            }
            //misc.log("***********************************************************");
            //misc.log("maxEnabled: {0}", maxEnabled);
            //misc.log("***********************************************************");
        }

        public CListPiece()
        {

        }

        #endregion


        public void checkId(CPiece toCheck)
        {
            foreach (CFile f in toCheck.Files)
            {
                if (htLoc.ContainsKey(f.Path))
                {
                    var pOrg = htLoc[f.Path];
                    toCheck.setId(pOrg.PieceId);
                    toCheck.PieceParentId = pOrg.PieceParentId;
                }
            }
        }

        /// <summary>
        /// merge de la base locale et distante
        /// </summary>
        /// <param name="a_remote"></param>
        /// <remarks></remarks>
        public void Consolid(CListPiece a_remote)
        {
            log("ListPiece:Consolid");
            mergePriority l_remotePriority = mergePriority.none;
            System.DateTime l_remoteDate = a_remote.m_date;
            if (l_remoteDate > System.DateTime.MinValue && l_remoteDate.AddSeconds(-3) > m_date)
                l_remotePriority = mergePriority.right;
            foreach (CPiece l_file in a_remote)
            {
                Consolid(l_file, l_remotePriority);
            }

        }

        public void bilanNatives()
        {
            misc.log("Bilan Natives");
            foreach (CPiece piece in this)
            {
                if (piece.HasNoNative)
                    misc.logNoDate(piece.ToString());
            }
        }

        private void merge(CPiece org, CPiece cand)
        {
            misc.log("CList:Add MERGE with key {0}: {1} // {2}", org.Key, org, cand);
            org.merge(cand);
        }

        public void AddOrMerge(CPiece piece, CPiece org)
        {
            if (org != null)
            {
                org.consolid(piece, mergePriority.right);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
                htIds[piece.PieceId] = piece;
                foreach (CFile file in piece.Files)
                {
                    htLoc[file.Path] = piece;
                }

            }
        }


        public void Add(CPiece piece)
        {
            TrackIdentity key = piece.Key;

            CPiece org = null;

            // recherche d'une piece avec un niveau de d�tail �gal ou inf�rieur
            org = ht[key];


            if (org != null)
            {
                misc.log("CList:Add MERGE {0}", key);
                org.merge(piece);
            }
            else
            {
                ht.set(piece, piece.Key);

                piece.addReferenceObs(this);
                CDb.checkId(piece);
                htIds[piece.PieceId] = piece;
                foreach (CFile file in piece.Files)
                {
                    htLoc[file.Path] = piece;
                }

            }
        }


        public void fusion(CPiece master, CPiece toDelete)
        {
            if (master == null)
                return;
            if (toDelete == null)
                return;
            if (master == toDelete)
                return;
            misc.log("CList:Fusion  {0}  {1}", master, toDelete);
            master.addDataLink(toDelete);
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);

        }

        public void delete(CPiece toDelete)
        {
            if (toDelete == null)
                return;
            ht.Remove(toDelete);
            htIds.Remove(toDelete.PieceId);
            foreach (CFile file in toDelete.Files)
            {
                htLoc.Remove(file.Path);
            }
        }

        public void referenceChange(CPiece piece)
        {
            piece.keyGener();
            ht.Remove(piece);

            piece.keyGener();
            ht.set(piece, piece.Key);

        }






        public bool Contains(CPiece piece)
        {
            var key = piece.Key;
            return ht[key] != null;
        }

        public void Consolid(CPiece remote, mergePriority a_priority)
        {
            if (remote.PieceParentId > 0)
            {
                if (remote.Parent == null)
                    remote.Parent = htIds[remote.PieceParentId];


            }
            CPiece l_pieceOrg = getPiece(remote);

            if (l_pieceOrg == null)
            {
                if (!remote.Deleted)
                {
                    l_pieceOrg = new CPiece();
                    l_pieceOrg.consolid(remote, a_priority);
                    Add(l_pieceOrg);
                }
                else
                    misc.log("remote deleted!! Pourquoi je le trouve pas ?? {0}", remote);
            }
            else
            {
                if (remote.Deleted && a_priority == mergePriority.right)
                {
                    l_pieceOrg.Deleted = true;
                    return;
                }
                if (remote.PieceParentId > 0)
                {
                    var parent = htIds[remote.PieceParentId];
                    misc.log(l_pieceOrg + " a maintenant un parent: " + parent);
                    l_pieceOrg.PieceParentId = remote.PieceParentId;
                    l_pieceOrg.Parent = parent;
                }
                //if (remote.PieceId > 0 && l_pieceOrg.PieceId < 0)
                //    l_pieceOrg.Parent = htIds[remote.PieceParentId];
                l_pieceOrg.consolid(remote, a_priority);
            }
        }

        /// <summary>
        /// synchro enrte base locale et liste native
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        public void legacyConsolid(CPiece native)
        {
            CPiece l_pieceOrg = getPiece(native);

            if (l_pieceOrg == null)
            {
                log("add from business:" + native.ToString());
                l_pieceOrg = new CPiece(native);
                l_pieceOrg.legacyConsolid(native);
                Add(l_pieceOrg);
            }
            else
            {
                l_pieceOrg.legacyConsolid(native);
            }

        }

        private CPiece getPiece(TrackIdentity key)
        {
            return ht[key];
        }

        public CPiece getPiece(ITrackMetaData a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece getPiece(CPiece a_piece)
        {
            TrackIdentity key = a_piece.Key;
            return getPiece(key);
        }

        public CPiece getPiece(string location)
        {
            return htLoc[location];
        }

        public CPiece getPiece(int id)
        {
            return htIds[id];
        }

        private bool exists(CPiece a_piece)
        {
            return getPiece(a_piece) != null;
        }

        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, PIECES);
            foreach (CPiece l_piece in this)
            {
                l_piece.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, PIECES);
        }

        public void write(System.Xml.XmlWriter w)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                l_piece.write(w);
            }
            w.WriteEndElement();
            w.WriteStartElement(TOKEN_LISTS);
            writeList(w, listes);
            w.WriteEndElement();
        }

        public void writeDiff(System.Xml.XmlWriter w, CListPiece lastFull)
        {
            w.WriteStartElement(PIECES);

            foreach (CPiece l_piece in getList())
            {
                var org = lastFull.getPiece(l_piece.PieceId);
                try
                {
                    l_piece.writeDiff(w, org);
                }
                catch (Exception ex)
                {
                    misc.log("impossible d'enregistrer les modifs de " + l_piece, ex.ToString());
                }
            }

            foreach (CPiece org in lastFull)
            {
                var newP = this.getPiece(org.PieceId);
                if (newP == null)
                {
                    org.Deleted = true;
                    org.writeDeleted(w);
                }
            }
            w.WriteEndElement();
        }

        #endregion


        public IEnumerator GetEnumerator()
        {
            return ht.GetEnumerator();
        }

        public int Count
        {
            get { return ht.Count; }
        }
        //public System.Collections.Generic.IEnumerator<CPiece> GetEnumerator1()
        //{
        //    return ht.GetEnumerator1();
        //}
        //System.Collections.Generic.IEnumerator<CPiece> System.Collections.Generic.IEnumerable<CPiece>.GetEnumerator()
        //{
        //    return GetEnumerator1();
        //}

        public List<CPiece> getList()
        {
            var list = new List<CPiece>(ht.Count);
            foreach (CPiece p in ht)
            {
                if (!p.Deleted)
                    list.Add(p);
            }

            Sort(list);

            return list;
        }

        public void Sort(List<CPiece> list)
        {
            list.Sort(new PieceComparer());
        }

        private class PieceComparer : IComparer<CPiece>
        {
            public int Compare(CPiece x, CPiece y)
            {
                int cmp = x.MasterId.CompareTo(y.MasterId);
                if (cmp != 0)
                    return cmp;
                cmp = x.PieceParentId.CompareTo(y.PieceParentId);
                if (cmp != 0)
                    return cmp;
                return x.PieceId.CompareTo(y.PieceId);
            }
        }

        private void log(String txt)
        {
            misc.log(txt);
        }


        #region listes
        public void loadListes(XmlElement xml)
        {
            if (xml == null)
                return;
            buildList(xml, listes);
        }

        private void buildList(XmlElement xparent, PlayList parent)
        {
            foreach (XmlElement xsub in xparent.ChildNodes)
            {
                var tool = new XMLTool(xsub);
                if (xsub.Name == TOKEN_LIST)
                {
                    string name = tool.getAttValue(TOKEN_LIST_NAME);
                    int id = tool.getIntAttValue("id");
                    PlayList sub = new PlayList(name, parent);
                    sub.ID = id;
                    CDb.checkId(sub);
                    buildList(xsub, sub);
                }
                else if (xsub.Name == TOKEN_LIST_TRACK)
                {
                    int id = tool.getIntAttValue("id");
                    var piece = htIds[id];

                   // var tl = new TrackList(piece);
                    parent.add(piece);
                }
            }
        }

        private void writeList(XmlWriter w, PlayList parent)
        {
            foreach (PlayList pl in parent.PlayLists)
            {
                w.WriteStartElement(TOKEN_LIST);
                w.WriteAttributeString("id", pl.ID.ToString());
                w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
                writeList(w, pl);
                w.WriteEndElement();
            }

            foreach (IItem t in parent.Items)
            {
                w.WriteStartElement(TOKEN_LIST_TRACK);
                w.WriteAttributeString("id", t.ID.ToString());
                w.WriteEndElement();
            }
            //foreach (PlComponent c in parent)
            //{
            //    if (c is CPlayList)
            //    {
            //        var pl = c as CPlayList;
            //        w.WriteStartElement(TOKEN_LIST);
            //        w.WriteAttributeString("id", pl.ID.ToString());
            //        w.WriteAttributeString(TOKEN_LIST_NAME, pl.Name);
            //        writeList(w, pl);
            //        w.WriteEndElement();
            //    }
            //    else if (c is TrackList)
            //    {
            //        var t = c as TrackList;
            //        w.WriteStartElement(TOKEN_LIST_TRACK);
            //        w.WriteAttributeString("id", t.PieceId.ToString());
            //        w.WriteEndElement();
            //    }
            //}
        }

        public void buildLists(PlayList listes)
        {
            this.listes.DeleteChilds();
            buildList(this.listes, listes);
        }

        private void buildList(PlayList mine, PlayList ext)
        {
            foreach (PlayList subExt in ext.PlayLists)
            {
                var sub = new PlayList(subExt.Name, mine);
                sub.ID = subExt.ID;
                CDb.checkId(sub);
                subExt.ID = sub.ID;

                buildList(sub, subExt);
            }

            foreach (IItem t in ext.Items)
            {
                var piece = htIds[t.ID];
                mine.add(piece);
            }
        }
        #endregion
    }

}






]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CPiece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.type;
using pdb.obj;
using pdb.util;
using pdb.db.piece;
using System.Diagnostics;


namespace pdb.db.obj
{

    /// <summary>
    /// Métadonnées d'un fichier
    /// </summary>
    /// <remarks>On veut pouvoir merger les modifications venant de deux sources
    /// exemeple : un modifie le classement, l'autre l'année
    /// Pour cela, il est envisagé d'enregistrer pour chaque modification effectué par le client
    /// tout simplement la date de cette modification
    /// le merge se baserait ainsi sur la comparaison entre les dates de modification
    /// source 1 date modif d1' pour classement > d1
    /// source 2 date modif d2' pour année > d2
    /// 
    /// On pourrait aussi se baser sur un flag => mettre à jour
    /// ainsi on gagnerait de la place, mais on perdrait la date de derniere mise à jour
    /// et se poserait aussi la question de quand retirer le flaf "mettre à jour"
    /// 
    /// On peut aussi établir un historique
    ///
    ///</remarks>
    /// 

    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }

    public class CPiece : IData, ITrackMetaData, ITrackNativeDates, ITrackPlayListRecorder, ITrackPlayListReport, IDataObserver, ITrackInfoItunes, IItem
    {
        private static Logger logTrack = Logger.getLogger("Track");
        //  private static NullTrack NullTrack = new NullTrack();
        private const string TOKEN_PIECE = "piece";

        private const string TOKEN_DISABLED = "disabled";
        private const string TOKEN_ARTWORK = "artWork";
        private const string TOKEN_DURATION = "duration";
        private const string TOKEN_ADDED = "added"; 

        #region "Composants"
        private CListDate m_dates;
        private CListFile m_files;
        private CPieceReference m_ref;
        private CPieceInfo m_infos;
        private CPieceClassement m_classement;
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private DateTime added; 
        private CPieceChecked m_Enabled = new CPieceChecked();


        //private String m_comment = "";
        //private string grouping = ""; 
        private string artWork = "";
        #endregion

        //private class StringEventArgs : EventArgs
        //{
        //    public StringEventArgs(String value) { this.Value = value; }
        //    readonly public String Value;
        //}


        public DateTime Added { get { return added; } }
        public void setAdded(DateTime dt) { added = dt; }

        private void checkNative()
        {
            //if (native == null)
            //{
            //    StackTrace st = new StackTrace();
            //    logTrack.logNoDate("native null " + this + " " + st.ToString());
            //}
        }
        //   public void makeFirstClass() { if (native == null) return; native.makeFirstClass(); }
        public bool FirstClass
        {
            get
            {
                if (native == null) return false;
                return native.FirstClass;
            }
            set { if (native == null) return; native.FirstClass = value; }
        }
        public bool HasNoNative { get { return native == null; } }
        //private void OnCommentChange(String value)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.Comment = value;
        //}
        //private void OnGroupingChange(String value, bool prior)
        //{
        //    checkNative();
        //    if (native == null)
        //        return;
        //    native.setGrouping(value, prior);
        //}
        private void OnNameChange(string value) { if (native == null) return; native.Name = value; }
        private void OnAlbumChanged(String value) { if (native == null) return; native.Album = value; }
        private void OnArtistChanged(String value) { if (native == null) return; native.Artist = value; }
        private void OnUncheck() { if (native == null) return; native.Enabled = false; }



        //private EventHandler<StringEventArgs> commentChanged;
        //private EventHandler<StringEventArgs> groupingChanged;
        //private EventHandler<StringEventArgs> albumChanged;
        //private EventHandler<StringEventArgs> artistChanged;


        private List<IReference> referenceObs = new List<IReference>();
        public void addReferenceObs(IReference obs) { if (!referenceObs.Contains(obs)) referenceObs.Add(obs); }
        public void removeReferenceObs(IReference obs) { referenceObs.Remove(obs); }
        private void OnReferenceChanged() { for (int i = 0; i < referenceObs.Count; i++) { referenceObs[i].referenceChange(this); } }


        #region logs
        private void valueChangedHandler()
        {

            //m_ref.AlbumData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Album", args); };
            //m_ref.ArtistData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Artist", args); };
            //m_ref.NameData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Name", args); };
            //m_infos.YearData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Year", args); };
            //Classement.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Classement", args); };

            //m_ref.AlbumData.changeLocalValueByNative += (o, args) => { langChangeByNative("Album", args); };
            //m_ref.ArtistData.changeLocalValueByNative += (o, args) => { langChangeByNative("Artist", args); };
            //m_ref.NameData.changeLocalValueByNative += (o, args) => { langChangeByNative("Name", args); };
            //m_infos.YearData.changeLocalValueByNative += (o, args) => { langChangeByNative("Year", args); };
            //Classement.changeLocalValueByNative += (o, args) => { langChangeByNative("Classement", args); };

            //m_ref.AlbumData.change += new EventHandler(Ref_change);
            //m_ref.NameData.change += new EventHandler(Ref_change);
            //m_ref.ArtistData.change += new EventHandler(Ref_change);
            //m_ref.TrackData.change += new EventHandler(Ref_change);
            Files.Observer = this;
            m_ref.Observer = this;
            m_infos.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
        }


        private void logChange(String typeChange, String typeData, object Old, object New)
        {
            logTrack.log("{0}:{1} from '{2}' to '{3}' {4}", typeChange, typeData, Old, New, this);
        }
        //private void logChangeByRemote(String typeData, object Old, object New)
        //{
        //    logChange("change by remote", typeData, Old, New);
        //}
        //private void langChangeByNative(String typeData, object Old, object New)
        //{
        //    logChange("change by native", typeData, Old, New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}

        //private void langChangeByNative(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}

        #endregion


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        public void keyGener()
        {
            try
            {
                key = new TrackIdentity(this);
            }
            catch
            {
                logTrack.log("pb de clé " + this);
                throw;
            }
        }

        #endregion

        #region constructeurs





        /// <summary>
        /// création d'un morceau vide
        /// </summary>
        /// <remarks></remarks>
        public CPiece()
        {

            m_dates = new CListDate();
            m_files = new CListFile();
            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();
            m_classement = new CPieceClassement();
            valueChangedHandler();
        }

        public CPiece(string location, string baseClassement)
            : this()
        {
            m_files.add(new CFile(location));
            m_classement = new CPieceClassement(baseClassement);
            valueChangedHandler();
        }

        public CPiece(string location)
            : this()
        {
            m_files.add(new CFile(location));
            valueChangedHandler();
        }

        public void initClassementIfEmpty(string classement)
        {
            m_classement.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            m_classement.eraseClassement();
        }


        private ITrackInfoItunes native = null;

        public void recordJustReadTrack()
        {
            ListDates.check(DateTime.Now);
        }

        public CPiece(ITrackInfoItunes ext)
        {
            native = ext;
            //  ext.registerDependency(this); 

            m_classPlayLists = ext.ClassPlayLists;
            //m_playList = ext.PLayLists;

            string className = ext.ClassName; // getClassName(ext); 

            m_dates = new CListDate();
            ListDates.check(ext.PlayedDate);

            m_files = new CListFile();
            Files.add(new CFile(ext.Location));
            m_ref = new CPieceReference(ext.Artist, ext.Album, ext.Name, ext.TrackNumber);
#if VOL
            m_infos = new CPieceInfo(ext.Year, ext.Volume);
#else
            m_infos = new CPieceInfo(ext.Year);
#endif
            this.artWork = ext.ArtWork;

            m_classement = new CPieceClassement(className, ext.Rating);
            //m_comment = ext.Comment;
            //grouping = ext.Grouping; 

            m_duration = ext.Duration;

            bool enabled = ext.Enabled;
            if (enabled)
                Checked.Enable();
            else
                Checked.Disable();

            //m_ref.AlbumData.changeNativeValue += (o, args) =>  { if (native == null) return; native.Album = args.Value; };
            //m_ref.ArtistData.changeNativeValue += (o, args) => { if (native == null) return; native.Artist = args.Value; };
            //m_ref.NameData.changeNativeValue += (o, args) => { if (native == null) return; native.Name = args.Value; };
            //m_ref.TrackData.changeNativeValue += (o, args) => { if (native == null) return; native.TrackNumber = args.Value; };
            //m_infos.YearData.changeNativeValue += (o, args) => { if (native == null) return; native.Year = args.Value; };
            //Classement.changeNativeValue += (o, args) => { if (native == null) return; native.Rating = args.Value.Rating; native.ClassName = args.Value.ClassList; };

            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            //  m_Enabled.checkedChanged += (o, args) => { if (native == null) return; native.Enabled = false; };





            valueChangedHandler();


        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList(ITrackNative track)
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        /// <summary>
        /// construction à partir de la base maison 
        /// </summary>
        /// <param name="a_xml"></param>
        /// <remarks></remarks>
        public CPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);
            m_id = xmlTool.getIntAttValue("id");
            deleted = xmlTool.getBoolAttValue("deleted");
            m_ref = new CPieceReference(a_xml);
            m_infos = new CPieceInfo(a_xml);

            parentID = xmlTool.getIntAttValue("parent");
            if (parentID < 0)
            {
                m_dates = new CListDate(a_xml);
                m_files = new CListFile(a_xml);
                m_classement = new CPieceClassement(a_xml);
                var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);
                {
                    if (xDisabled != null)
                    {
                        if (xDisabled.InnerText == "false")
                            Checked.Enable();
                        else
                            Checked.Disable(); 
                    }
                }
            }
            else
            {
                m_dates = new CListDate();
                m_files = new CListFile();
                m_classement = new CPieceClassement();

            }





            var xtool = new XMLTool(a_xml);
            artWork = xtool.getNodeValue(TOKEN_ARTWORK);
            //Comment = xtool.getNodeValue("classement");
            //_grouping = xtool.getNodeValue("grouping");
            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xtool.getNodeValue(TOKEN_DURATION);

          


            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }

            string strAdded = "";
            var attAdded = a_xml.Attributes[TOKEN_ADDED];
            if (attAdded != null)
                strAdded = attAdded.Value;
            else
                strAdded = xtool.getNodeValue(TOKEN_ADDED);

            if (!string.IsNullOrEmpty(strAdded))
            {
                try
                {
                    added = Convert.ToDateTime(strAdded);
                }
                catch (Exception ex)
                {
                    log(string.Format("impossible de parser {0} {1} {2}", strAdded, this,ex)); 
                }
            }

          
            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            valueChangedHandler();

        }


        ///// <summary>
        ///// construction à partir de la base propriétaire
        ///// </summary>
        ///// <param name="a_ref"></param>
        ///// <param name="a_file"></param>
        ///// <param name="a_info"></param>
        ///// <param name="a_rating"></param>
        ///// <param name="a_date"></param>
        ///// <remarks></remarks>
        //public CPiece(CPieceReference a_ref, string a_file, CPieceInfo a_info, int a_rating, System.DateTime a_date, TimeSpan a_duration, bool a_bEnabled)
        //{

        //    m_dates = new CListDate();
        //    ListDates.check(a_date);

        //    m_files = new CListFile();
        //    Files.@add(new CFile(a_file));

        //    m_ref = a_ref;
        //    m_infos = a_info;

        //    m_classement = new CPieceClassement(a_rating);
        //    m_duration = a_duration;
        //    if (a_bEnabled)
        //    {
        //        m_Enabled.True();
        //    }
        //    else
        //    {
        //        m_Enabled.False();
        //    }
        //    valueChangedHandler();

        //}

        #endregion


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackMetaData other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.Location) || m_ref.DefinedEquals(other.Artist, other.Album, other.Name, other.TrackNumber));
        //}


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(CPiece other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.m_files) || m_ref.DefinedEquals(other.m_ref));
        //}

        public bool checkFile(CPiece other)
        {
            return Files.HasOnePathInCommonWith(other.Files);
        }



        private void raiseChangeRefEvent()
        {
            if (isRefchanged)
            {
                isRefchanged = false;
                OnReferenceChanged();
            }
        }

        /// <summary>
        /// rapatrie les info d'une piece vers l'autre
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>cas d'égalité enre les deux : doublons de la même liste</remarks>

        public void merge(CPiece other)
        {

            if (!m_ref.AlbumData.choose(other.m_ref.AlbumData))
            {
                log("merge album between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.AlbumData.mergeManual(other.m_ref.AlbumData);
            }

            if (!m_ref.ArtistData.choose(other.m_ref.ArtistData))
            {
                log("merge artist between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.ArtistData.mergeManual(other.m_ref.ArtistData);
            }
            if (!m_ref.NameData.choose(other.m_ref.NameData))
            {
                log("merge name between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.NameData.mergeManual(other.m_ref.NameData);
            }
            if (!m_ref.TrackData.choose(other.m_ref.TrackData))
            {
                log("merge trackNumber between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.TrackData.mergeManual(other.m_ref.TrackData);
            }




            if (!m_infos.YearData.choose(other.m_infos.YearData))
            {
                log("merge infos between " + this.ToString() + "[" + this.Year + "]" + " and " + other.ToString() + "[" + other.Year + "]");
                m_infos.YearData.mergeManual(other.m_infos.YearData);
            }

            if (!Classement.choose(other.Classement))
            {
                log("merge classement between " + this.ToString() + "[" + this.ClassList + ":" + this.Rating + "]" + " and " + other.ToString() + "[" + other.ClassList + ":" + other.Rating + "]");
                Classement.mergeManual(other.Classement);
            }

            addData(other);
            raiseChangeRefEvent();
        }


        /// <summary>
        /// Simple ajout de données venant du doublon
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>Utilisé par legacy pour génération d'une liste propre à partir de la liste native
        /// Les fichiers auront préalablement été triés par classement</remarks>
        public void mergeDataFrom(CPiece other)
        {
            try
            {
                m_ref.mergeDataFrom(other.m_ref);
                m_infos.YearData.mergeAll(other.m_infos.YearData, mergePriority.none);
                Classement.mergeAll(other.Classement, mergePriority.none);

                addData(other);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + @"\r\n" + other.ToString() + @"\r\n" + e.ToString());
            }
        }


        // <summary>
        // addition sans collision des dates et fichiers
        // </summary>

        // <remarks></remarks>

        private void addData(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);
        }


        public void addDataLink(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);


            Classement.mergeOnlyVersion(other.Classement);
            other.Classement.mergeOnlyVersion(Classement); 
        }




        public void consolid(CPiece remote, mergePriority a_priority)
        {

            try
            {
                m_ref.consolid(remote.m_ref, a_priority);
                Classement.Consolid(remote.Classement, a_priority);
                m_infos.consolid(remote.m_infos, a_priority);

                Checked.Consolid(remote.Checked, a_priority);

                if (m_duration.TotalMilliseconds < 2)
                    this.m_duration = remote.m_duration;
                else if (remote.m_duration.TotalMilliseconds < 2)
                    remote.m_duration = this.m_duration;
                else if (a_priority == mergePriority.right)
                    m_duration = remote.m_duration;

                addData(remote);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }


        public mergePriority checklegacyModifString(CPieceData<String> data, String native)
        {

            mergePriority l_consistencyComp = data.Value.compareByConsistency(native);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (data.Imported) return mergePriority.right;
            return mergePriority.left;
        }


        /// <summary>
        /// piece de la liste native consolidée ou mise à jour 
        /// suivant le cas par le fichier maison
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        public void legacyConsolid(CPiece l_native)
        {



            //TODO éviter de créer un objet juste pour la comparaison
            //en fait très complexe de casser le modèle. A la place, on abonne le track natif aux modifications éventuelles de la DB



            //this.grouping = l_native.Grouping;
            //this.m_comment = l_native.Comment; 







            l_native.m_ref.legacyConsolid(this.m_ref);
            l_native.m_infos.legacyConsolid(this.m_infos);

            l_native.setClassPlayList(this);
            l_native.Classement.LegacyConsolid(this.Classement);
            l_native.Checked.LegacyConsolid(this.Checked);

            //   native.synchroLegacy(this);  //plus besoin de synchro dans l'autre sens, on n'utilise pas l'objet créé ==> en fait si : on modifie directement le track

            addData(l_native);

            this.m_playList = l_native.PLayLists;
            this.m_classPlayLists = l_native.ClassPlayLists;
            this.m_duration = l_native.Duration;
            raiseChangeRefEvent();

            //On court-circuite la liste intermédiaire pour toujours pointer directement vers le trackInfoItunes
            this.native = l_native.native;

            checkNative();
        }

        /// <summary>
        /// Synchro directe entre la Db et le track Itunes (mode daemon)
        /// </summary>
        public void SynchroNative()
        {
            checkNative();
            if (native == null)
                return;

            m_ref.SynchroNative(native);
#if VOL
            m_infos.SynchroNative(native.Year, native.Volume);
#else
            m_infos.SynchroNative(native.Year);
#endif
            var newClassList = getClassName(native);
            Classement newCl = new Classement(newClassList, native.Rating);
            Classement.SynchroNative(newCl);
            Checked.SynchroNative(native.Enabled);

            this.ListDates.merge(native.PlayedDate);



            //  this.m_playList = native.PLayLists;
            this.m_classPlayLists = native.ClassPlayLists;
            if (native.Duration.TotalMilliseconds > 1)
                this.m_duration = native.Duration;
            raiseChangeRefEvent();
        }

        public void removeVersions()
        {
            m_ref.removeVersions();
            Classement.removeVersions();
        }

      

        public void Menage()
        {
            //  misc.log("ménage {0}", this); 
            Classement.Menage(this);
        }




        //public void synchroLegacy(CPiece native)
        //{
        //    this.m_classPlayLists = native.m_classPlayLists;

        //    this.ID = native.ID;
        //}

        private List<CPlayList> m_classPlayLists = new List<CPlayList>();
        private List<CPlayList> m_playList = new List<CPlayList>();
        public void AddPlayList(CPlayList a_playList)
        {
            if (a_playList.isClassSubList())
            {
                m_classPlayLists.Add(a_playList);
            }
            m_playList.Add(a_playList);
        }
        public void removePlayList(CPlayList list)
        {
            if (list.isClassSubList())
                m_classPlayLists.Remove(list);
            m_playList.Remove(list);
        }

        public bool belongsTo(string a_list)
        {
            foreach (CPlayList l_pl in m_playList)
            {
                if (l_pl.isSubList(a_list))
                    return true;
            }
            return false;
        }

        ////définit la liste qui le classe
        //public void setClassPlayList()
        //{
        //    int count =  m_classPlayLists.Count; 
        //    if (count > 0)
        //    {
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //        }
        //        Classement.ClassList = m_classPlayLists[0].Name;
        //    }
        //}


        private void setClassPlayList(ITrackNative pieceDb)
        {
            string dbClasslist = pieceDb.ClassName;
            int count = m_classPlayLists.Count;
            if (count > 0)
            {
                string className = m_classPlayLists[0].Name;
                if (count > 1)
                {
                    m_classPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in m_classPlayLists)
                    {
                        className = list.Name;
                        if (className == dbClasslist)
                            continue;
                        break;
                    }
                }

                if (!className.Equals(Classement.Value.ClassList) && className.Equals(Classement.LastValue.ClassList))
                {
                    misc.log("Classement:setClassPlayList {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                    return;
                }

                Classement.ClassList = className;

            }
        }

        public string getClassName(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            var firstStep = getClassName_(native);
            if (!firstStep.Equals(Classement.Value.ClassList) && firstStep.Equals(Classement.LastValue.ClassList))
            {
                misc.log("Classement:getClassName {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                return dbClasslist;
            }
            else
                return firstStep;
        }

        public string getClassName_(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            string className = dbClasslist;
            int count = native.ClassPlayLists.Count;
            if (count > 0)
            {
                className = native.ClassPlayLists[0].Name;
                if (count > 1)
                {
                    native.ClassPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in native.ClassPlayLists)
                    {
                        className = list.Name;
                        if (className.Equals(dbClasslist))
                            continue;
                        break;
                    }
                }
            }
            return className;
        }

        //utilisé par le player maison
        public void setClassPlayList(String name)
        {
            Classement.ClassList = name;
            // TODO Gérer l'absence de classList
        }

        private CPlayList ClassPlayList
        {
            get
            {
                if (m_classPlayLists.Count > 0)
                    return m_classPlayLists[0];
                return null;
            }
        }

        public List<CPlayList> PLayLists { get { return m_playList; } }

        public String ClassName { get { return Classement.ClassList; } set { } }

        public List<CPlayList> ClassPlayLists
        {
            get
            {
                return m_classPlayLists;
            }
        }



        /// <summary>
        /// 
        /// </summary>
        /// <param name="a_sw"></param>
        /// <remarks></remarks>
        /// 
        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, TOKEN_PIECE);

            m_ref.write(a_sw);
            m_infos.write(a_sw);

            Classement.write(a_sw);

            Files.write(a_sw);
            ListDates.write(a_sw);

            if (!Checked.Enabled)
                XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());
            if (artWork.NotNullOrEmpty())
                XMLTool.writeValue(a_sw, TOKEN_ARTWORK, artWork);
            if (m_duration.TotalMilliseconds > 1)
                XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);
            if (added > DateTime.MinValue)
                XMLTool.writeValue(a_sw, TOKEN_ADDED, added.ToString()); 

            XMLTool.closeBalise(a_sw, TOKEN_PIECE);
        }




        public void write(XmlWriter w)
        {           
            try
            {
                w.WriteStartElement(TOKEN_PIECE);
                if (PieceId > 0)
                    w.WriteAttributeString("id", PieceId.ToString());
                if (parent != null)
                    w.WriteAttributeString("parent", parent.PieceId.ToString());
                if (added > DateTime.MinValue)
                    w.WriteAttributeString(TOKEN_ADDED, added.ToString());
                if (parent == null)
                {
                    if (m_duration.TotalMilliseconds > 1)
                        w.WriteAttributeString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
                }

                m_ref.write(w);
                m_infos.write(w);

                if (parent == null)
                {
                    Classement.write(w);
                    Files.write(w);
                    ListDates.write(w);

                    if (!Checked.Enabled)
                        w.WriteElementString(TOKEN_DISABLED, "");
                }

             

                if (artWork.NotNullOrEmpty())
                    w.WriteElementString(TOKEN_ARTWORK, artWork);
              


                w.WriteEndElement();
            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0} {1}", this,ex);
                throw;
            }
        }

    
        public void writeDeleted(XmlWriter w)
        {
            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            w.WriteAttributeString("deleted", "true");
            w.WriteEndElement();

        }

        public void writeDiff(XmlWriter w, CPiece lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }

            if (!HasChange(lastFull))
                return;

            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            if (parent != null)
                w.WriteAttributeString("parent", parent.PieceId.ToString());

            m_ref.writeDiff(w, lastFull.m_ref);
            m_infos.writeDiff(w, lastFull.m_infos);

            if (parent == null)
            {
                Classement.writeDiff(w, lastFull.Classement);
                Files.writeDiff(w, lastFull.Files);
                ListDates.writeDiff(w, lastFull.ListDates);

                if (!Checked.Enabled && lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "");

                if (Checked.Enabled && !lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "false");

                if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                    w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
            }

            


          

            w.WriteEndElement();
        }

        public bool HasChange(CPiece lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }
            if (PieceParentId != lastFull.PieceParentId)
                return true;

            if (m_ref.HasChanged(lastFull.m_ref))
                return true;
            if (m_infos.HasChange(lastFull.m_infos))
                return true;

            if (parent == null)
            {
                if (Classement.HasChange(lastFull.Classement))
                    return true;
                if (Files.HasChange(lastFull.Files))
                    return true;
                if (ListDates.HasChange(lastFull.ListDates))
                    return true;
            }

            if (Checked.Enabled != lastFull.Checked.Enabled)
                return true;


            if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
                return true;

            return false;
        }

        #endregion

        public void setClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);
            if (cl.Equals(Classement.Value))
                return;
            Classement.Value = cl;

        }

        


        public CListFile Files
        {
            get { if (parent == null)return m_files; return parent.m_files; }
        }


        public IList<DateTime> Dates
        {
            get { return ListDates.Dates; }
        }

        public DateTime PlayedDate
        {
            get { return ListDates.LastModif; }
        }

        public string ClassList
        {
            get { return Classement.ClassList; }
        }

        public int Rating
        {
            get { return Classement.Rating; }
            set { Classement.Rating = value; }
        }

        public int RatingCmp
        {
            get
            {
                if (Rating < 0)
                    return 0;
                return Rating;
            }
        }
        public CPieceReference Reference
        {
            get { return m_ref; }
        }
        public string Name
        {
            get { return m_ref.Name; }
            set { m_ref.Name = value; }
        }
        public string Album
        {
            get { return m_ref.Album; }
            set
            {
                if (!m_ref.Album.Equals(value))
                {
                    m_ref.Album = value;
                    OnAlbumChanged(value);
                }
            }
        }
        public string Artist
        {
            get { return m_ref.Artist; }
            set
            {
                if (!m_ref.Artist.Equals(value))
                {
                    m_ref.Artist = value;
                    OnArtistChanged(value);
                }
            }
        }
        public int TrackNumber { get { return m_ref.TrackNumber; } set { m_ref.TrackNumber = value; } }
        public int DurationInSec
        {
            get { return Convert.ToInt32(Duration.TotalSeconds); }
        }
        //public TimeSpan Duration
        //{
        //    get { return m_duration; }
        //    set
        //    {
        //        if (value.TotalMilliseconds > 1)
        //            m_duration = value;
        //    }
        //}
        public int Year
        {
            get { return m_infos.Year; }
            set { m_infos.Year = value; }
        }
#if VOL
        public int Volume { get { return m_infos.Volume; } set { m_infos.Volume = value; } }
#endif
        public bool Enabled
        {
            get { return Checked.Enabled; }
            set
            {
                if (value)
                    Checked.Enable();
                else
                    Checked.Disable();
            }
        }
        public CPieceInfo Infos
        {
            get { return m_infos; }
        }

        public string ArtWork { get { return artWork; } set { artWork = value; } }


        /// <summary>
        /// ID interne
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
        private int parentID = -1;
        public int PieceId
        {
            get { return m_id; }
        }

        public int PieceParentId
        {
            get { return parentID; }
            set { parentID = value; }
        }

        public int MasterId
        {
            get
            {
                if (parentID < 0)
                    return m_id;
                return parentID;
            }
        }

        public CPiece Master
        {
            get
            {
                if (parent == null)
                    return this; 
                return parent;
            }
        }


        public void setId(int value)
        {
            if (m_id < 0)
            {
                m_id = value;
            }
        }

        public CPieceClassement Classement { get { if (parent == null) return m_classement; return parent.m_classement; } }
        public TimeSpan Duration
        {
            get { if (parent == null) return m_duration; return parent.m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    if (parent == null)
                        m_duration = value;
                    else
                        parent.m_duration = value; 
                }
            }
        }
        public CListDate ListDates { get { if (parent == null) return m_dates; return parent.m_dates; } }
        private CPieceChecked Checked { get { if (parent == null) return m_Enabled; return parent.m_Enabled; } }
        //  private CListFile Files { get { if (parent == null) return m_files; return parent.m_files; } }
        public Classement getClassement() { return Classement.Value; }


       


        //Sub synchroClassFrom(ByVal a_list As CListPiece)
        //    Dim l_piece As CPiece = a_list.getPiece(Me)
        //    m_classement = l_piece.m_classement
        //End Sub

        public override string ToString()
        {
            var parent = " ";
            if (PieceParentId >= 0)
                parent = string.Format(" ({0}) ", PieceParentId); 
            return string.Format("{0} {1}{2}{3} {4} {5}", Classement.Value, PieceId, parent, Name, Album, getLocation()); 
            //String location = Location;
            //return location == "" ? Files.File : location;
        }
        //public string File
        //{
        //    get { return Files.File; }
        //}
        public string PathAndRef
        {
            get { return getLocation() + " " + m_ref.ToString(); }
        }
        //private string _location;
        public string Location
        {

            get
            {
                return Files.Path; 
                //if (_location == null)
                //_location =  Files.Path;
                //return _location; 


            }
        }
        public string getLocation()
        {
            return Files.getLocation(); 
        }

        public bool Exists { get { return Files.Exists; } }

        //public bool classListToUpdate()
        //{
        //    string l_strList = "";
        //    if (ClassPlayList != null)
        //        l_strList = ClassPlayList.Name;

        //    //if (Classement.Imported)
        //    //{
        //    if (l_strList != ClassList)
        //    {
        //        return true;
        //    }
        //    //}
        //    return false;
        //}

        //private string _comment;
        //public string Comment
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return "";
        //        if (_comment == null)
        //        {
        //            if (native != null)
        //                _comment = native.Comment;
        //        }
        //        return _comment;

        //        //string l_pref = "";
        //        //string l_str = "";

        //        //string l_strList = "";
        //        //if (ClassPlayList != null)
        //        //    l_strList = ClassPlayList.Name;

        //        //if (Classement.Imported)
        //        //{
        //        //    if (l_strList != ClassList)
        //        //    {
        //        //        l_pref = "m (" + ClassList + ") ";
        //        //    }
        //        //}
        //        //int l_rank = m_rank.Twice;
        //        //if (l_rank > 0)
        //        //{
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }

        //        //    double l_tx = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Goodness, CConf.Sort.Quality));
        //        //    double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //    //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //    //getTx(m_rank.Lenght)
        //        //    l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();
        //        //}

        //        //return l_pref + l_str + getClassementEvol();

        //    }
        //    set
        //    {
        //        if (parent != null)
        //            return;
        //        if (value != _comment)
        //        {
        //            _comment = value;
        //            //if (value != Comment)
        //            //{
        //            // m_comment = value;
        //            OnCommentChange(value);
        //        }
        //        // }
        //    }
        //}
        //private string _grouping;
        //public string Grouping
        //{
        //    get
        //    {
        //        if (_grouping == null)
        //        {
        //            if (native != null)

        //                _grouping = native.Grouping;
        //        }
        //        return _grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (value != Grouping)
        //    //    //{
        //    //    //  grouping = value;
        //    //    OnGroupingChange(value);
        //    //    //}
        //    //}
        //}

        //public void setGrouping(string value, bool prior)
        //{
        //    if (value != _grouping)
        //    {
        //        _grouping = value;
        //        OnGroupingChange(value, prior);
        //    }
        //}

        //private static double getTx(int rank)
        //{
        //    if (rank <= 0)
        //        return 0;
        //    return (Math.Log(Convert.ToDouble(CTuning.Total) / Convert.ToDouble(rank)) / Math.Log(2));
        //}

        //public int QRank
        //{
        //    get { return m_rank.Goodness; }
        //    set { m_rank.Goodness = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}




        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return Classement.isClassListNumeric;
            }
        }

        //  public String ClassNameAndRating { get { return Classement.ClassNameAndRating; } }



        #region "calcul liste dynamiques"
        // Private m_bCanPlay As Boolean = True
        public delegate bool canPlayDel(int a_base);
        //public bool canPlay(int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    if (a_base <= 0)
        //        return true;
        //    DateTime now = DateTime.Now;
        //    bool l_bRet = ListDates.canPlay(now, Delta, a_base);
        //    if (!l_bRet)
        //    {
        //        Console.WriteLine(" " + Comment + " " + Location);
        //    }

        //    return l_bRet;
        //}

        // private CListDate m_datesModifClassement = null;
        private CListDate DatesClassement_
        {
            get
            {
                //if (m_datesModifClassement == null)
                //    m_datesModifClassement = Classement.Dates;
                return Classement.Dates;
            }
        }

        //public bool mustPlayToPreciseClassement(DateTime now, int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    bool bRet = !DatesClassement.canPlay(now, Delta, a_base);
        //    bool bLastModif = DatesClassement.LastModif > DatesPlayed.LastModif;


        //    if (CConf.CheckModifStrict)
        //        // on ne retient que s'i n'a pas été lu depuis la dernière modif.
        //        // encore en cours : j'écoute puis je modifie
        //        bRet = bRet && bLastModif;

        //    if (a_base == 0)
        //        return bLastModif;
        //    return bRet;
        //}

        public String getClassementEvol()
        {
            DateTime playedCorr = ListDates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= m_duration;
            }
            catch (Exception)
            {
                logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, m_duration);
            }
            if (DatesClassement_.LastModif > playedCorr)
            {
                return Classement.Evol;
            }
            return "";

        }

        public static double LogBase = 2.0;
        public static double Scale = 0.1;
        //private TimeSpan Delta
        //{

        //    get
        //    {
        //        if (m_rank.Goodness < 0)
        //            return TimeSpan.MaxValue;
        //        long l_ticks = Convert.ToInt64(new TimeSpan(1, 0, 0, 0).Ticks * Scale);

        //        double r = CPieceInListComparer.Calc(this, CConf.Select);
        //        //     Rapport(m_rank.Goodness, CConf.Sort.Quality)
        //        if (r == -1)
        //            return TimeSpan.MaxValue;

        //        long l_nt = long.MaxValue;
        //        try
        //        {
        //            l_nt = Convert.ToInt64(l_ticks / r);
        //        }
        //        catch (Exception ex)
        //        {
        //        }

        //        return new TimeSpan(l_nt);
        //    }
        //}



        //Sub reinitCanPlay()
        //    m_bCanPlay = True
        //End Sub

        #endregion

        #region "COM"

        //public void checkComRating(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        if (Rating < 0)
        //            return;
        //        //if (!Classement.Imported)
        //        //    return;

        //        int l_trackRating = a_track.Rating;
        //        if (l_trackRating != Rating)
        //        {
        //            log("change rating from " + l_trackRating + " to " + Rating + " " + Location);
        //            a_track.Rating = Rating;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Rating {0} for {1}", Rating, this);
        //    }

        //}


        //public void checkComInfo(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        //if (!m_infos.YearData.Imported)
        //        //    return;
        //        if (Year <= 0) return;
        //        if (a_track.Year != Year)
        //        {
        //            log("change year from " + a_track.Year + " to " + Year + " " + Location);
        //            a_track.Year = Year;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Year {0} for {1}", Year, this);
        //    }

        //}

        //public void checkComRef(ITrackMetaData a_track)
        //{

        //    if (m_ref == null)
        //        return;


        //    string l_trackArtist = a_track.Artist.TrimSafe();
        //    string l_trackAlbum = a_track.Album.TrimSafe();
        //    string l_trackName = a_track.Name.TrimSafe();
        //    int l_trackNumber = a_track.TrackNumber;

        //    if (l_trackArtist != m_ref.Artist)// && m_ref.ArtistData.Imported)
        //    {
        //        log("change Artist from " + l_trackArtist + " to " + m_ref.Artist + " " + Location);
        //        try { a_track.Artist = m_ref.Artist.TrimSafe(); }
        //        catch { misc.log("unable to change Artist {0} for {1}", Artist, this); }
        //    }
        //    if (l_trackAlbum != m_ref.Album) // && m_ref.AlbumData.Imported)
        //    {
        //        log("change Album from " + l_trackAlbum + " to " + m_ref.Album + " " + Location);
        //        try { a_track.Album = m_ref.Album; }
        //        catch { misc.log("unable to change Album {0} for {1}", Album, this); }
        //    }
        //    if (l_trackName != m_ref.Name) // && m_ref.NameData.Imported)
        //    {
        //        log("change Name from " + l_trackName + " to " + m_ref.Name + " " + Location);
        //        try
        //        {
        //            a_track.Name = m_ref.Name.TrimSafe();
        //        }
        //        catch { misc.log("unable to change Name {0} for {1}", Name, this); }
        //    }
        //    if (l_trackNumber != m_ref.TrackNumber && TrackNumber >= 0)//&& m_ref.TrackData.Imported)
        //    {
        //        log("change Track from " + l_trackNumber + " to " + m_ref.TrackNumber + " " + Location);
        //        try { a_track.TrackNumber = TrackNumber; }
        //        catch { misc.log("unable to change TrackNumber {0} for {1}", TrackNumber, this); }
        //    }


        //}


        //public void checkComComment(ITrackMetaData a_track)
        //{
        //    try
        //    {

        //        string l_pieceComment = Comment.Trim();
        //        String l_trackComment = a_track.Comment;
        //        if (l_trackComment == null) l_trackComment = "";
        //        l_trackComment = l_trackComment.Trim();
        //        if (l_trackComment != l_pieceComment)
        //        {
        //            misc.logNoDate("write comment from " + a_track.Comment + " to " + l_pieceComment + " " + Location);
        //            // If l_pieceComment.Trim = "" Then Throw New ApplicationException(Me.ToString() & " set comment to null")
        //            a_track.Comment = l_pieceComment;
        //        }

        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Comments {0} for {1}", Comment, this);
        //    }
        //}

        //public void checkComEnabled(ITrackMetaData a_track)
        //{
        //    if (m_Enabled.isFalse && a_track.Enabled)
        //    {
        //        misc.log("disable {0}", this);
        //        a_track.Enabled = false;
        //    }
        //}

        //public void checkComDate(ITrackInfo a_track)
        //{
        //    //Dim l_date As String = a_track.EQ

        //}
        #endregion


        public bool isPodcast
        {
            get { return Files.isPodcast; }
        }
        private void log(String txt)
        {
            logTrack.log(txt);
        }



        List<DateTime> ITrackPlayedDates.Dates
        {
            get { return new List<DateTime>(ListDates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return new List<DateTime>(DatesClassement_.Dates); }
        }

        public DateTime LastModifClass { get { return m_classement.LastModif; } }

        public string ClassEvol
        {
            get { return getClassementEvol(); }
        }





        public void changeNativeValueAlbum(string value)
        {
            if (native == null)
                return;
            native.Album = value;
        }

        public void changeNativeValueArtist(string value)
        {
            if (native == null) return; native.Artist = value;
        }

        public void changeNativeValueName(string value)
        {
            if (native == null) return; native.Name = value;
        }

        public void changeNativeValueTrack(int value)
        {
            if (native == null) return; native.TrackNumber = value;
        }

        public void changeNativeValueYear(int value)
        {
            if (native == null) return; native.Year = value;
        }

        public void changeNativeValueClassement(Classement value)
        {
            if (native == null)
                return;
            native.Rating = value.Rating; native.ClassName = value.ClassList;
        }
#if VOL
        public void changeNativeValueVolume(int value)
        {
            if (native == null) return;
            native.Volume = value;
        }
#endif

        public void changeByRemote(string type, object Old, object New)
        {
            logChange("change by remote", type, Old, New);
        }

        public void changeByNative(string type, object Old, object New)
        {
            logChange("change by native", type, Old, New);
        }

        private bool isRefchanged;
        public void RefChange()
        {
            isRefchanged = true;
        }

        public void unCheck()
        {
            if (native == null) return; native.Enabled = false;
        }

        public void changeLocalValueByRemoteAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void change()
        {
            throw new NotImplementedException();
        }

        public void setClassement(string className, int rating)
        {
            Classement.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return Classement.ToString();
            }
            set
            {
                setClassement(value);
            }
        }

        public long Size
        {
            get
            {
                var ret = Files.Size;
                if (ret <= 0)
                    return 0;
                return ret;
            }
        }

      
        private CPiece parent;

        public void setParent(CPiece parent)
        {
            this.parent = parent; 
        }
        public CPiece Parent
        {
            get { return parent; }
            set
            {
                var _oldParent = parent;

                if (value == null)
                {
                   
                    PieceParentId = -1;
                    if (_oldParent != null)
                    {
                        addDataLink(_oldParent);
                    }
                    parent = null;
                    return;
                }
                else
                {
                    value.Master.addDataLink(this);
                    parent = value.Master;
                    PieceParentId = parent.PieceId;
                }
               
                

            }
        }

        private bool deleted;
        public bool Deleted
        {
            get { return deleted; }
            set
            {
                if (value != deleted)
                {
                    if (value)
                        misc.log("Suppression de {0}", this);
                    deleted = value;
                }
            }
        }

        private List<string> _RelativesPath;
        public List<string> RelativesPath
        {
            get
            {
                if (_RelativesPath == null)
                {
                    _RelativesPath = new List<string>();
                    foreach (CFile f in m_files)
                    {
                        _RelativesPath.Add(f.File);
                    }
                }
                return _RelativesPath;
            }
        }


        private exportState _exportState; 
        public exportState ExportStatus
        {
            get
            {
                return _exportState; 
            }
            set
            {
                _exportState = value; 
            }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return Classement.getDates(); 
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }
    }
}






]]></content>
  </file>
</db>
