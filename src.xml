<db path="C:\bernard\db2\">
  <file path="buro\buroSimple\Program.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;

namespace buroSimple
{
    class Program
    {
        static List<string> getList(string arg)
        {
            List<string> l = new List<string>();

            var tab = arg.Split(';');
            foreach (string s in tab)
            {
                if (!string.IsNullOrEmpty(s))
                    l.Add(s.ToLower());
            }
            return l;
        }

        static void Main(string[] args)
        {
            int countArgs = args.GetLength(0);
            double delay = 20.0;
            double delayFast = 1.0;
            bool unique = false;
            bool sortBySize = false;
            bool uniqueName = false;
            bool reverse = false;
            bool fullscreen = false;
            bool highResolution = false;
            bool combine = false;
            bool oneScreen = false;
            bool checkScreen = false;
            bool displayImgError = false;
            bool scanImgError = false;
            bool abortScan = false;
            bool modul = false;
            bool useMem = false;

            List<string> include = null;
            List<string> exclude = null;

            for (int i = 0; i < countArgs; i++)
            {
                var arg = args[i];

                switch (arg)
                {
                    case "-t":
                    if (i + 1 < countArgs)
                    {
                        delay = Convert.ToDouble(args[i + 1]);
                    }
                    break;
                    case "-tt":
                    if (i + 1 < countArgs)
                    {
                        delayFast = Convert.ToDouble(args[i + 1]);
                    }
                    break;

                    case "-i":
                    if (i + 1 < countArgs)
                    {
                        include = getList(args[i + 1]);
                    }
                    break;

                    case "-e":
                    if (i + 1 < countArgs)
                    {
                        exclude = getList(args[i + 1]);
                    }
                    break;




                    case "/u": unique = true; break;
                    case "/s": sortBySize = true; break;
                    case "/c": combine = true; break;
                    case "/un": uniqueName = true; break;
                    case "/r": reverse = true; break;
                    case "/fs": fullscreen = true; break;
                    case "/hr": highResolution = true; break;
                    case "/os": oneScreen = true; break;
                    case "/cs": checkScreen = true; break;
                    case "/de": displayImgError = true; break;
                    case "/se": scanImgError = true; break;
                    case "/as": abortScan = true; break;
                    case "/m": modul = true; break;
                    case "/mem": useMem = true; break;

                }
            }

            //var test = buroSimpleLib.ImageUtil.Scale(@"C:\temp\pochette.jpg", 2); 
            //test.Save(@"C:\temp\pochetteScaled.bmp", System.Drawing.Imaging.ImageFormat.Bmp); 
            var wp = new Walpaper()
            {
                delay = delay,
                delayFast = delayFast,
                unique = unique,
                sortBySize = sortBySize,
                uniqueName = uniqueName,
                reverse = reverse,
                fullscreen = fullscreen,
                highResolution = highResolution,
                combine = combine,
                oneScreen = oneScreen,
                checkScreen = checkScreen,
                include = include,
                exclude = exclude,
                displayImgError = displayImgError,
                scanImgError = scanImgError,
                abortScan = abortScan,
                modul = modul,
                useMem = useMem
            };
            wp.go();
        }
    }

}
]]></content>
  </file>
  <file path="buro\buroSimple\Walpaper.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using buroSimpleLib;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using System.Threading;
using System.Diagnostics;
using System.Windows.Forms;
using Microsoft.Win32;
using System.Drawing.Drawing2D;

namespace buroSimple
{
    class Walpaper
    {
        int HAUTEUR;
        int LARGEUR;
        readonly string TMP_FILE; // = @"C:\Temp\wp.bmp";
        readonly string TMP_FILE1; //= @"C:\Temp\wp1.bmp";
        readonly string TMP_FILE2; // = @"C:\Temp\wp2.bmp";
        readonly string TMP_PREPAR; //= @"C:\Temp\wpp.bmp";
        readonly string INDEX_FILE; //= @"C:\Temp\wp.index.txt";
        readonly string TMP_LOADED; //= @"C:\Temp\Loaded";
        readonly string TMP_LOADED_MINI; //= @"C:\Temp\Loaded\Mini";
        readonly string HISTO;// @"C:\Temp\WP_HISTO\";
        readonly string DB;

        /// <summary>
        /// delai en secondes entre deux refreh
        /// </summary>
        public double delay = 30;
        /// <summary>
        /// On ne prend qu'un exemplaire pour une taille donnée
        /// </summary>
        public bool unique = false;
        /// <summary>
        /// Try par taille
        /// </summary>
        public bool sortBySize = false;
        /// <summary>
        /// On considère suex fichiers de même taille et de même nom comme identiques
        /// </summary>
        public bool uniqueName = false;
        /// <summary>
        /// tri inversé
        /// </summary>
        public bool reverse = false;
        /// <summary>
        /// On tente de recreer une image à la taille de l'écran
        /// </summary>
        public bool fullscreen = false;
        /// <summary>
        /// On tente d'utiliser les valeurs &
        /// </summary>
        public bool highResolution = false;
        /// <summary>
        /// tri par pixel et taille
        /// </summary>
        public bool combine = false;
        /// <summary>
        /// Un seul grand écran 
        /// </summary>
        public bool oneScreen = false;
        /// <summary>
        /// Vérification recouvrement 
        /// </summary>
        public bool checkScreen = false;
        /// <summary>
        /// delai après une image floue;
        /// </summary>
        public double delayFast = 1.0;

        /// <summary>
        /// répertoires permis
        /// </summary>
        public List<string> include;
        /// <summary>
        /// Répertoires défendus
        /// </summary>
        public List<string> exclude;

        /// <summary>
        /// En mode fs affiche les images floues
        /// </summary>
        public bool displayImgError = false;
        /// <summary>
        /// en mode fs, vérifie les doublons
        /// </summary>
        public bool scanImgError = false;
        /// <summary>
        /// En cas de vérification trop longue, on interrompt la verif d'identité
        /// </summary>
        public bool abortScan = false;
        /// <summary>
        /// Modulation du délai: on privilégie les carrés
        /// </summary>
        public bool modul;

        /// <summary>
        /// Pour les disques lents: on met les fichiers en mémoire
        /// </summary>
        public bool useMem;

        private bool GO;

        private void checkSession()
        {
            while (currentSwitchSessionStatus != SessionSwitchReason.SessionLogon
                 && currentSwitchSessionStatus != SessionSwitchReason.SessionUnlock)
            {
                Console.WriteLine("Pause reason " + currentSwitchSessionStatus);
                Thread.Sleep(1000);
            }
        }

        public Walpaper()
        {

            var strDir = DirUtil.GetAppDir();
            TMP_FILE = strDir + "wp.bmp";
            TMP_FILE1 = strDir + "wp1.bmp";
            TMP_FILE2 = strDir + "wp2.bmp";
            TMP_PREPAR = strDir + "wpp.bmp";
            INDEX_FILE = strDir + "wp.index.txt";
            TMP_LOADED = strDir + "Loaded";
            TMP_LOADED_MINI = strDir + @"Loaded\Mini";
            HISTO = strDir + @"WP_HISTO\";
            DB = strDir + "buro1.txt";
        }

        public void go()
        {
            if (!Directory.Exists(HISTO))
                Directory.CreateDirectory(HISTO);
            GO = true;
            DirectoryInfo loaded = new DirectoryInfo(TMP_LOADED);
            if (!loaded.Exists)
                loaded.Create();

            DirectoryInfo loadedMini = new DirectoryInfo(TMP_LOADED_MINI);
            if (!loadedMini.Exists)
                loadedMini.Create();


            SystemEvents.PowerModeChanged += new PowerModeChangedEventHandler(SystemEvents_PowerModeChanged);
            SystemEvents.SessionSwitch += SystemEvents_SessionSwitch;


            DateTime nextFlash = DateTime.Now;

            ImageUtil.UseMem = useMem;
            bool first = true;



            HAUTEUR = ScreenUtil.Hauteur;
            LARGEUR = ScreenUtil.Largeur;
            var list = new List<FileDto>();
            using (StreamReader sr = new StreamReader(DB))
            {
                string line = "";
                while ((line = sr.ReadLine()) != null)
                {
                    if (string.IsNullOrEmpty(line))
                        continue;

                    try
                    {
                        FileDto fd = FileDto.FromLine(line); //  new FileDto() { Path = tab[0], Size = Convert.ToInt64(tab[1]) };
                        if (fd != null)
                        {
                            bool go = true;
                            string path = fd.Path.ToLower();
                            if (exclude != null)
                            {
                                foreach (string ex in exclude)
                                {
                                    if (path.StartsWith(ex))
                                    {
                                        go = false;
                                        break;
                                    }
                                }
                            }
                            if (!go)
                                continue;
                            if (include != null)
                            {
                                go = false;
                                foreach (string str in include)
                                {
                                    if (path.StartsWith(str))
                                    {
                                        go = true;
                                        break;
                                    };
                                }
                            }
                            if (!go)
                                continue;
                            list.Add(fd);
                        }
                    }
                    catch
                    {
                    }

                }
            }

            list.Sort((x, y) =>
            {
                int cmp = 0;
                if (sortBySize)
                {
                    cmp = x.Size.CompareTo(y.Size);
                    if (cmp != 0)
                        return cmp;
                    if (combine)
                        cmp = x.Pixels().CompareTo(y.Pixels());
                    if (cmp != 0)
                        return cmp;
                    cmp = x.Width.CompareTo(y.Width);
                }
                else
                {
                    cmp = x.Pixels().CompareTo(y.Pixels());
                    if (cmp != 0)
                        return cmp;
                    cmp = x.Width.CompareTo(y.Width);
                    if (cmp != 0)
                        return cmp;
                    if (combine)
                        cmp = x.Size.CompareTo(y.Size);
                }

                if (cmp != 0)
                    return cmp;
                return x.Path.CompareTo(y.Path);
            });

            if (reverse)
                list.Reverse();

            int count = list.Count;

            string path0 = "";
            int index0 = -1;
            if (File.Exists(INDEX_FILE))
            {
                path0 = File.ReadAllText(INDEX_FILE).Trim();
            }

            if (!string.IsNullOrEmpty(path0))
            {
                for (int i = 0; i < count; i++)
                {
                    if (list[i].Path == path0)
                    {
                        index0 = i;
                        break;
                    }
                }
            }

            HashSet<string> hs = new HashSet<string>();
            int pixels = -1;
            int width = -1;
            long size = -1;
            int nbLoaded = 0;
            bool checkScreen = this.checkScreen;
            bool errorFs = false;

            DateTime last = DateTime.Now;
            FileDto lastF = null;
            if (File.Exists(TMP_FILE))
                File.Delete(TMP_FILE);
            for (int i = index0 + 1; i < count; i++)
            {
                while (!GO)
                {
                    Thread.Sleep(1000);
                }

                checkSession();



                FileDto f = list[i];
                Console.WriteLine("candidat " + f);
                var fpixels = f.Pixels();
                var fwidth = f.Width;
                bool change = false;
                bool sizeChanged = f.Size > size;
                bool pixelChanged = fpixels > pixels || fwidth != width;

                if (combine)
                    change = sizeChanged || pixelChanged;
                else if (sortBySize)
                    change = sizeChanged;
                else
                    change = pixelChanged;
                if (change)
                {
                    hs.Clear();
                    size = f.Size;
                    width = f.Width;
                    if (fpixels > pixels)
                    {
                        if (pixels > 0)
                            File.Copy(INDEX_FILE, HISTO + pixels + "_wp.index.txt", true);

                    }
                    if (fwidth != width)
                        width = fwidth;
                    if (pixels > 0)
                    {
                        ImageUtil.ClearMem();
                        foreach (FileInfo fl in loaded.GetFiles())
                        {
                            fl.Delete();
                        }
                        foreach (FileInfo fl in loadedMini.GetFiles())
                        {
                            fl.Delete();
                        }

                    }
                    pixels = fpixels;
                    nbLoaded = 0;
                }
                else
                {
                    if (unique)
                        continue;
                }
                string fileName = Path.GetFileName(f.Path);
                if (hs.Contains(fileName))
                    continue;
                //  bool abortScan = this.abortScan && errorFs;
                errorFs = false;
                try
                {
                    Image img = null;
                    if (fullscreen)
                    {
                        try
                        {
                            img = createFileFs(f);
                        }
                        catch (Exception ex)
                        {
                            errorFs = true;
                            Console.WriteLine(ex.Message);
                        }
                    }
                    if ((errorFs && displayImgError) || !fullscreen)
                        img = createFile(f);
                    if (img != null)
                    {
                        bool ok = true;
                        DirectoryInfo d = loaded;
                        if (errorFs)
                            d = loadedMini;
                        bool scanAborted = false;
                        var files = d.GetFiles().ToList();
                        files.Sort((x, y) => -x.LastWriteTime.CompareTo(y.LastWriteTime));
                        var next = nextFlash;
                        if (first)
                        {
                            first = false;
                            next = next.AddSeconds(delay);
                        }
                        foreach (FileInfo fl in files)
                        {
                            if (abortScan && DateTime.Now > next)
                            {
                                Console.WriteLine(">>>>>>>>>>>>>>>>>scan aborted");
                                scanAborted = true;
                                break;
                            }
                            if (ImageUtil.AreIdentical(img, fl.FullName))
                            {
                                ok = false;
                                break;
                            }
                        }
                        img.Dispose();

                        if (ok)
                        {
                            Console.WriteLine();
                            Console.WriteLine("----------------------------------------------------------");
                            if (lastF != null)
                                Console.WriteLine("courant:{0}", lastF);
                            Console.WriteLine("à venir:{0}", f);
                            Console.WriteLine("Attente:{0:0} ms Traitement:{1:0} ms", (nextFlash - DateTime.Now).TotalMilliseconds, (DateTime.Now - last).TotalMilliseconds);

                            checkSession();
                            while (DateTime.Now < nextFlash)
                            {
                                Thread.Sleep(30);
                                checkSession();
                            }
                            Console.WriteLine("----------------------------------------------------------");
                            if (checkScreen)
                            {
                                if (File.Exists(TMP_FILE))
                                {
                                    while (ScreenUtil.isRecovered(TMP_FILE, oneScreen))
                                    {
                                        Console.WriteLine("Pause reason Recovered");
                                        Thread.Sleep((int)(1000 * Math.Max(1, delay)));
                                    }
                                }
                            }
                            last = DateTime.Now;
                            File.Copy(TMP_PREPAR, TMP_FILE, true);
                            WinAPI.BmpLoad(TMP_FILE);
                            lastF = f;
                            nbLoaded++;
                            if (!scanAborted && (!errorFs || scanImgError))
                                File.Copy(TMP_FILE, d.FullName + "\\" + Path.GetFileName(f.Path) + "_" + nbLoaded + ".bmp", true);
                            File.WriteAllText(INDEX_FILE, f.Path);
                            double delta = errorFs ? delayFast : delay;
                            if (modul)
                            {
                                var dimMin = Math.Min(f.Width, f.Height);
                                var coeff = Math.Sqrt(f.Pixels()) / dimMin;
                                delta /= coeff;
                            }
                            nextFlash = DateTime.Now.AddSeconds(delta);

                            if (uniqueName)
                                hs.Add(fileName);

                            checkScreen = this.checkScreen && !errorFs;

                        }
                        else
                        {
                            Console.WriteLine("Identique " + f);
                            continue;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Blank " + f);
                        continue;
                    }

                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            }
        }
        private SessionSwitchReason currentSwitchSessionStatus = SessionSwitchReason.SessionLogon;
        private void SystemEvents_SessionSwitch(object sender, SessionSwitchEventArgs e)
        {
            Console.WriteLine("SystemEvents_SessionSwitch:" + e.Reason);
            currentSwitchSessionStatus = e.Reason;

        }

        void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)
        {
            Console.WriteLine("SystemEvents_PowerModeChanged:" + e.Mode.ToString());
            if (e.Mode == PowerModes.Resume)
                GO = true;
            else GO = false;
        }

        private void paramGr(Graphics graphics)
        {
            graphics.CompositingMode = CompositingMode.SourceCopy;
            graphics.CompositingQuality = CompositingQuality.AssumeLinear;
            graphics.InterpolationMode = InterpolationMode.NearestNeighbor;
            graphics.SmoothingMode = SmoothingMode.None;
            graphics.PixelOffsetMode = PixelOffsetMode.None;
        }

        private Image createFileFs(FileDto f)
        {
            Image img = Image.FromFile(f.Path);
            Bitmap bmp = new Bitmap(img.Width, img.Height);
            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.DrawImage(img, 0, 0);
            }

            img.Dispose();
            img = bmp;

            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}={1}x{2} {3} {4}", largeur0 * hauteur0, largeur0, hauteur0, f.HumanReadableSize, img.PixelFormat);

            double r0 = (double)HAUTEUR / (double)LARGEUR;
            double r = (double)hauteur0 / (double)largeur0;

            //facteur d'augmentation
            int scale = 1;

            //1. on teste blank
            int largeurTrame;
            int hauteurTrame;

            Bitmap trame;
            img.Save(TMP_FILE1, ImageFormat.Bmp);
            var imgVerif = ImageUtil.Scan(TMP_FILE1);
            if (imgVerif == null)
            {
                return null;
            }


            imgVerif.Dispose();

            int l = largeur0;
            int h = hauteur0;
            //int l0 = l;
            //int h0 = h;
            ////Image currentImage = img;
            //while (true)
            //{
            //    l *= 2;
            //    if (l > LARGEUR)
            //        break;
            //    h *= 2;
            //    if (h > HAUTEUR)
            //        break;
            //    l0 = l;
            //    h0 = h;
            //}

            if (r > r0)
                scale = HAUTEUR / hauteur0;
            else
                scale = LARGEUR / largeur0;

            l *= scale;
            h *= scale;

            //l=l0; 
            //h=h0; 

            //var trameInter = new Bitmap(l, h, img.PixelFormat);
            //using (Graphics g = Graphics.FromImage(trameInter))
            //{
            //    paramGr(g);
            //    //int _xrec = (int)((LARGEUR - l) / 2.0);
            //    //int _yrec = (int)((HAUTEUR - h) / 2.0);
            //    //Rectangle _centré = new Rectangle(_xrec, _yrec, l, h);
            //    Rectangle rect = new Rectangle(0, 0, l, h);
            //    // g.DrawImageUnscaledAndClipped(img, _centré);
            //   // g.DrawImageUnscaledAndClipped(img, rect);
            // g.DrawImage(img, rect, 0,0, l,h, GraphicsUnit.Pixel); 
            // //    g.DrawImage(img, rect); 

            //  //  trameInter.Dispose();
            //    // img.Dispose();


            //   // return Image.FromFile(TMP_FILE);
            //}
            var trameInter = img;
            if (scale > 1)
            {
                trameInter = ImageUtil.Scale(img, scale);
            }

            img.Dispose();
            trameInter.Save(TMP_FILE2, ImageFormat.Bmp);


            imgVerif = ImageUtil.Scan(TMP_FILE2);
            imgVerif.Dispose();


            if (imgVerif == null)
            {
                return null;
            }


            if (r > r0)
            {
                // image pas assez large --> ajout largeur



                hauteurTrame = HAUTEUR;
                largeurTrame = Convert.ToInt32(LARGEUR * r0 / r); //   Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = LARGEUR;
                hauteurTrame = Convert.ToInt32(HAUTEUR * r / r0);
            }

            trame = new Bitmap(LARGEUR, HAUTEUR);
            Graphics graphics = Graphics.FromImage(trame);
            paramGr(graphics);
            int xrec = (int)((LARGEUR - largeurTrame) / 2.0);
            int yrec = (int)((HAUTEUR - hauteurTrame) / 2.0);



            // var abort = new Image.GetThumbnailImageAbort(ThumbnailCallback);
            //var thumbnail = img.GetThumbnailImage(largeurTrame , hauteurTrame, abort, IntPtr.Zero);

            Rectangle centré = new Rectangle(xrec, yrec, largeurTrame, hauteurTrame);
            // graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);
            // Rectangle all = new Rectangle(0,0,LARGEUR, HAUTEUR); 
            //graphics.DrawImage(img, centré);
            graphics.DrawImageUnscaledAndClipped(trameInter, centré);
            trameInter.Dispose();
            //thumbnail.Save(TMP_FILE, ImageFormat.Bmp);

            //thumbnail.Dispose();
            // image.Dispose();

            trame.Save(TMP_PREPAR, ImageFormat.Bmp);


            trame.Dispose();
            // img.Dispose();
            graphics.Dispose();

            return Image.FromFile(TMP_PREPAR);

        }

        public bool ThumbnailCallback()
        {
            return false;
        }

        private Image createFile(FileDto f)
        {
            Image img = Image.FromFile(f.Path);

            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}={1}x{2} {3}", largeur0 * hauteur0, largeur0, hauteur0, f.HumanReadableSize);

            double r0 = (double)HAUTEUR / (double)LARGEUR;

            int largeurTrame;
            int hauteurTrame;

            double r = (double)hauteur0 / (double)largeur0;





            if (r > r0)
            {
                // image pas assez large --> ajout largeur

                hauteurTrame = hauteur0;
                largeurTrame = Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = largeur0;
                hauteurTrame = Convert.ToInt32((double)largeur0 * (double)r0);
            }
            Graphics graphics = null;
            Bitmap trame = null;
            if (highResolution)
                try
                {
                    trame = new Bitmap(largeurTrame, hauteurTrame, img.PixelFormat);
                    graphics = Graphics.FromImage(trame);
                }
                catch
                {
                    if (trame != null)
                        trame.Dispose();
                }
            if (graphics == null)
            {
                trame = new Bitmap(largeurTrame, hauteurTrame);
                graphics = Graphics.FromImage(trame);
            }

            paramGr(graphics);


            int xrec = (largeurTrame - largeur0) / 2;
            int yrec = (hauteurTrame - hauteur0) / 2;
            Rectangle centré = new Rectangle(xrec, yrec, largeur0, hauteur0);
            graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);


            trame.Save(TMP_PREPAR, ImageFormat.Bmp);
            trame.Dispose();
            img.Dispose();
            graphics.Dispose();

            // verif
            var imgVerif = ImageUtil.Scan(TMP_PREPAR);
            return imgVerif;

            //using (Bitmap fs = new Bitmap(LARGEUR, HAUTEUR))
            //{
            //    Image i0 = null;
            //    Image i1 = null;
            //    using (var g = Graphics.FromImage(fs))
            //    {

            //        if (File.Exists(TMP_FILE))
            //        {
            //            i0 = Image.FromFile(TMP_FILE);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }

            //        if (File.Exists(TMP_FILE1))
            //        {
            //            i1 = Image.FromFile(TMP_FILE1);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }
            //    }
            //    fs.Save(TMP_FILE, ImageFormat.Bmp);
            //    if (i0 != null)
            //        i0.Dispose();
            //    if (i1 != null)
            //        i1.Dispose();
            //}
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimpleLib\DirUtil.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace buroSimpleLib
{
    public class DirUtil
    {
        static string dir;
        public static string GetAppDir()
        {
            if (dir == null)
            {
                var d = new DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\buro");
                if (!d.Exists)
                    d.Create();
                dir = d.FullName + "\\";
            }

            return dir;
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimpleLib\FileDto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.IO;

namespace buroSimpleLib
{
    public class FileDto
    {
        const string SEP = ";";
        public static string PATH; //= @"C:\Temp\buro.txt";
        public string Path;
        public long Size;
        public int Width;
        public int Height;

        static FileDto()
        {
            PATH = DirUtil.GetAppDir() + "buro.txt";
        }

        public override string ToString()
        {
            return string.Format("{0}x{1} {2} {3} ", Width, Height, HumanReadableSize, Path);
        }

        public string ToStringSearch()
        {
            return string.Format("{0} {1} {2}x{3}  ", Path, HumanReadableSize, Width, Height);
        }

        public int Pixels() { return Width * Height; }

        public string HumanReadableSize
        {
            get
            {
                return FileUtil.HumanReadableSize(Size, 1);
            }
        }
        public void appendToDb(StreamWriter sw)
        {
            sw.Write(Path);
            sw.Write(SEP);
            sw.Write(Size);
            sw.Write(SEP);
            sw.Write(Width);
            sw.Write(SEP);
            sw.WriteLine(Height);
        }

        public static FileDto FromLine(string line)
        {
            if (string.IsNullOrEmpty(line))
                return null;
            var tab = line.Split(SEP.ToCharArray());
            try
            {
                FileDto fd = new FileDto() { Path = tab[0], Size = Convert.ToInt64(tab[1]), Width = Convert.ToInt32(tab[2]), Height = Convert.ToInt32(tab[3]) };
                return fd;
            }
            catch
            {
                return null;
            }
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimpleLib\ImageUtil.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;

namespace buroSimpleLib
{
    public class ImageUtil
    {
        public static bool UseMem { get; set; }
        private static Dict<string, Bitmap> mem = new Dict<string, Bitmap>();
        public static void ClearMem()
        {
            foreach (Bitmap b in mem.Values)
            {
                try
                {
                    b.Dispose();
                }
                catch { }

            }
            mem.Clear();
        }
        /// <summary>
        /// Scan d'une image pour déterminer si elle est vide
        /// </summary>
        /// <param name="file"></param>
        /// <returns>null=> image noire</returns>
        public static unsafe Image Scan(string file)
        {
            int LEVEL_MIN = 0;
            Bitmap b = null;
            DateTime debut = DateTime.Now;
            try
            {
                b = new Bitmap(file);//note this has several overloads, including a path to an image
            }

            catch
            {
                ConsoleLogger.log("Impossible de créer un Bitmap {0}", file);
                try
                {
                    Image i = Image.FromFile(file);
                    return i;
                }
                catch
                {
                    return null;
                }
            }
            DateTime debutScan = DateTime.Now;
            BitmapData bData = b.LockBits(new Rectangle(0, 0, b.Width, b.Height), ImageLockMode.ReadOnly, b.PixelFormat);

            var Depth = Bitmap.GetPixelFormatSize(b.PixelFormat);

            //  byte bitsPerPixel = Bitmap.GetBitsPerPixel(bData.PixelFormat);

            /*This time we convert the IntPtr to a ptr*/
            byte* scan0 = (byte*)bData.Scan0.ToPointer();
            bool ok = false;
            for (int i = 0; i < bData.Height; ++i)
            {
                if (ok)
                    break;
                for (int j = 0; j < bData.Width; ++j)
                {
                    byte* data = scan0 + i * bData.Stride + j * Depth / 8;

                    //data is a pointer to the first byte of the 3-byte color data
                    //data[0] = blueComponent;
                    //data[1] = greenComponent;
                    //data[2] = redComponent;
                    if (data[0] > LEVEL_MIN || data[1] > LEVEL_MIN || data[2] > LEVEL_MIN)
                    {
                        //if (data[3] > 0)
                        ok = true;
                        break;
                    }
                }
            }

            b.UnlockBits(bData);

            var ts = (DateTime.Now - debut).TotalMilliseconds.ToString("0");
            var tsLoad = (debutScan - debut).TotalMilliseconds.ToString("0");

            var tsScan = (DateTime.Now - debutScan).TotalMilliseconds.ToString("0");
            if (!ok)
            {
                ConsoleLogger.log("Blank {0} {1} ms", file, tsScan);
                b.Dispose();
                return null;
            }
            else if (ts.Length >= 3)
                ConsoleLogger.log("{0} load:{1}ms scan:{2}ms total:{3} ms", file, tsLoad, tsScan, ts);
            return b;
        }

        public static bool AreIdentical(Image b1, string file2)
        {
            return !AreDifferent(b1, file2);
        }

        /// <summary>
        /// Détermine si deux images sont différentes ( au moins un pixel différent ) 
        /// </summary>
        /// <param name="img"></param>
        /// <param name="file2"></param>
        /// <returns></returns>
        public static unsafe bool AreDifferent(Image img, string file2)
        {
            //  ConsoleLogger.log("checkDif {0}", file2); 

            Bitmap b2 = null;
            Bitmap b1 = null;


            DateTime debut = DateTime.Now;
            DateTime debutScan = DateTime.Now;
            bool dif = false;
            try
            {
                try
                {
                    //b1 = new Bitmap(file1);//note this has several overloads, including a path to an image
                    b2 = mem[file2];
                    if (b2 == null)
                    {
                        b2 = new Bitmap(file2);
                        if (UseMem)
                            mem[file2] = b2;
                    }
                    debutScan = DateTime.Now;
                    if (img is Bitmap)
                        b1 = img as Bitmap;
                    else
                        b1 = new Bitmap(img);
                    if (b1.Width != b2.Width)
                        dif = true;
                    else if (b1.Height != b2.Height)
                        dif = true;
                }

                catch
                {
                    dif = true;
                }
                if (!dif)
                {

                    BitmapData bData1 = b1.LockBits(new Rectangle(0, 0, b1.Width, b1.Height), ImageLockMode.ReadOnly, b1.PixelFormat);
                    BitmapData bData2 = b2.LockBits(new Rectangle(0, 0, b2.Width, b2.Height), ImageLockMode.ReadOnly, b2.PixelFormat);

                    var Depth = Bitmap.GetPixelFormatSize(b1.PixelFormat);

                    //  byte bitsPerPixel = Bitmap.GetBitsPerPixel(bData.PixelFormat);

                    /*This time we convert the IntPtr to a ptr*/
                    byte* scan01 = (byte*)bData1.Scan0.ToPointer();
                    byte* scan02 = (byte*)bData2.Scan0.ToPointer();

                    for (int i = 0; i < bData1.Height; ++i)
                    {
                        if (dif)
                            break;
                        for (int j = 0; j < bData1.Width; ++j)
                        {
                            if (dif)
                                break;
                            byte* data1 = scan01 + i * bData1.Stride + j * Depth / 8;
                            byte* data2 = scan02 + i * bData2.Stride + j * Depth / 8;

                            //data is a pointer to the first byte of the 3-byte color data
                            //data[0] = blueComponent;
                            //data[1] = greenComponent;
                            //data[2] = redComponent;

                            for (int c = 0; c < 3; c++)
                            {
                                if (data1[c] != data2[c])
                                {
                                    dif = true;
                                    break;
                                }
                            }

                        }
                    }

                    b1.UnlockBits(bData1);
                    b2.UnlockBits(bData2);
                }
            }
            finally
            {
                if (b2 != null && !UseMem)
                    b2.Dispose();
            }

            var ts = (DateTime.Now - debut).TotalMilliseconds.ToString("0");
            var tsLoad = (debutScan - debut).TotalMilliseconds.ToString("0");

            var tsScan = (DateTime.Now - debutScan).TotalMilliseconds.ToString("0");
            if (!dif)
            {
                ConsoleLogger.log("equal {0} {1} ms", file2, tsScan);
            }
            else if (ts.Length >= 3)
                ConsoleLogger.log("{0} load:{1}ms checkDif:{2}ms total:{3} ms", file2, tsLoad, tsScan, ts);


            return dif;
        }

        public static Image Scale(string source, int scale)
        {
            return Scale(Image.FromFile(source), scale);
        }

        public static Image Scale2(Image source, int scale)
        {


            scale = 1;

            Bitmap src = null;
            if (source is Bitmap)
                src = source as Bitmap;
            else
                src = new Bitmap(source);

            var scaled = new DirectBitmap(source.Width * scale, source.Height * scale);

            var srcb = new DirectBitmap(src);


            int width = source.Width;
            int height = source.Height;

            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < height; j++)
                {
                    Color c = srcb.GetPixel(i, j);
                    int x0 = scale * i;
                    int x1 = x0 + scale;
                    int y0 = scale * j;
                    int y1 = y0 + scale;
                    for (int x = x0; x < x1; x++)
                    {
                        for (int y = y0; y < y1; y++)
                        {
                            scaled.SetPixel(x, y, c);
                        }
                    }
                }
            }
            return scaled.Bitmap;

        }

        public static unsafe Image Scale1(Image source, int scale)
        {


            if (scale == 1)
                return source;

            Bitmap scaled = new Bitmap(source.Width * scale, source.Height * scale);
            Bitmap src = null;
            if (source is Bitmap)
                src = source as Bitmap;
            else
                src = new Bitmap(source);

            DateTime debut = DateTime.Now;
            DateTime debutScan = DateTime.Now;
            bool dif = false;
            try
            {

                BitmapData bData1 = src.LockBits(new Rectangle(0, 0, src.Width, src.Height), ImageLockMode.ReadOnly, src.PixelFormat);
                BitmapData bData2 = scaled.LockBits(new Rectangle(0, 0, scaled.Width, scaled.Height), ImageLockMode.ReadOnly, scaled.PixelFormat);

                var Depth = Bitmap.GetPixelFormatSize(src.PixelFormat);

                //  byte bitsPerPixel = Bitmap.GetBitsPerPixel(bData.PixelFormat);

                /*This time we convert the IntPtr to a ptr*/
                byte* scan01 = (byte*)bData1.Scan0.ToPointer();
                byte* scan02 = (byte*)bData2.Scan0.ToPointer();

                for (int i = 0; i < bData1.Height; ++i)
                {
                    if (dif)
                        break;
                    for (int j = 0; j < bData1.Width; ++j)
                    {
                        if (dif)
                            break;
                        byte* data1 = scan01 + i * bData1.Stride + j * Depth / 8;
                        byte* data2 = scan02 + i * bData2.Stride + j * Depth / 8;

                        //data is a pointer to the first byte of the 3-byte color data
                        //data[0] = blueComponent;
                        //data[1] = greenComponent;
                        //data[2] = redComponent;


                        int x0 = scale * i;
                        int x1 = x0 + scale;
                        int y0 = scale * j;
                        int y1 = y0 + scale;
                        for (int x = x0; x < x1; x++)
                        {
                            for (int y = y0; y < y1; y++)
                            {
                                data2 = scan02 + x * bData2.Stride + y * Depth / 8;
                                for (int c = 0; c < 3; c++)
                                {
                                    data2[c] = data1[c];
                                }
                                data2[3] = 255;
                            }
                        }
                    }
                }


                src.UnlockBits(bData1);
                scaled.UnlockBits(bData2);

            }
            finally
            {

            }

            var ts = (DateTime.Now - debut).TotalMilliseconds.ToString("0");
            if (ts.Length >= 3)
                ConsoleLogger.log("copie:{0} ms  ms", ts);
            return scaled;
        }


        public static Image Scale(Image source, int scale)
        {
            //    if (scale == 1)
            //        return source;

            Bitmap scaled = new Bitmap(source.Width * scale, source.Height * scale);
            Bitmap src = null;
            //if (source is Bitmap)
            //    src = source as Bitmap;
            //else
            src = new Bitmap(source);
            LockBitmap org = new LockBitmap(src);
            LockBitmap modif = new LockBitmap(scaled);
            org.LockBits(ImageLockMode.ReadOnly);
            modif.LockBits(ImageLockMode.WriteOnly);

            int width = org.Width;
            int height = org.Height;

            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < height; j++)
                {
                    Color c = org.GetPixel(i, j);
                    int x0 = scale * i;
                    int x1 = x0 + scale;
                    int y0 = scale * j;
                    int y1 = y0 + scale;
                    for (int x = x0; x < x1; x++)
                    {
                        for (int y = y0; y < y1; y++)
                        {
                            modif.SetPixel(x, y, c);
                        }
                    }
                }
            }
            org.UnlockBits();
            modif.UnlockBits();
            return scaled;
        }




    }


}
]]></content>
  </file>
  <file path="buro\buroSimpleLib\ScreenUtil.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace buroSimpleLib
{
    public class ScreenUtil
    {
        public static int Hauteur
        {
            get
            {
                return Screen.PrimaryScreen.Bounds.Height; 
            }
        }

        public static int Largeur
        {
            get
            {
                return Screen.PrimaryScreen.Bounds.Width; 
            }
        }
        public static Bitmap getScreenShot(Screen screen)
        {
            var bounds = screen.Bounds;
            Bitmap screenshot = new Bitmap(bounds.Width,
                                   bounds.Height);
            using (Graphics screenGraph = Graphics.FromImage(screenshot))
            {
                screenGraph.CopyFromScreen(bounds.X,
                                           bounds.Y,
                                           0,
                                           0,
                                         bounds.Size,
                                           CopyPixelOperation.SourceCopy);
            }
            return screenshot;
        }

        public static bool isRecovered(string wpf, bool firstScreen)
        {
            var dir = DirUtil.GetAppDir(); 
            try
            {
                Screen sc = Screen.PrimaryScreen;
                if (!firstScreen)
                {
                    foreach (Screen s in Screen.AllScreens)
                    {
                        if (s == sc)
                            continue;
                        sc = s;
                        break;
                    }
                }
                var bound = sc.Bounds;
                int x = 523;
                int y = 907;




                Bitmap wp = new Bitmap(wpf);
                double coeff = (double)wp.Width / (double)bound.Width;

                int xWp = (int)(x * coeff);
                int yWp = (int)(y * coeff);

                Color c = wp.GetPixel(xWp, yWp);


                Bitmap screenShot = getScreenShot(sc);
                screenShot.Save(dir + "sc.bmp");
                screenShot.Dispose();
                screenShot = new Bitmap(dir +"sc.bmp");
                Color cs = screenShot.GetPixel(x, y);
                screenShot.Dispose();
                wp.Dispose();
                int dif = 0;
                dif += Math.Abs(c.B - cs.B);
                dif += Math.Abs(c.G - cs.G);
                dif += Math.Abs(c.R - cs.R);
                if (dif < 16)
                    return false;
                return true;
            }
            catch (Exception ex)
            {
                return true;
            }
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimpleSearch\Program.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util.ordo;
using buroSimpleLib;
using System.IO;
using System.Drawing;
using System.Threading;
using pdb.util;
using System.Configuration;
using System.Drawing.Imaging;
using System.Runtime.ExceptionServices;

namespace buroSimpleSearch
{

    class Program
    {
        static List<FileDto> list = new List<FileDto>();
        static HashSet<string> imageType = new HashSet<string> { "bmp", "gif", "ico", "jpeg", "jpg", "jpe", "png", "svg", "tif", "tiff" };
        static HashSet<string> noImageType = new HashSet<string>();

        static listCandidat imageCandidat = new listCandidat();
        static listCandidat NoImageCandidat = new listCandidat();
        static volatile object _lock = new object();
        static int LEVEL_MIN = 0;

        static void Main(string[] args)
        {
            Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);
            new Program().go();
        }

        static Ordonnanceur ordo;
        static StreamWriter sw = new StreamWriter(FileDto.PATH);
        void go()
        {
            // Scan(@"H:\spacer.gif");
            //  Scan(@"C:\temp\wp.bmp");
            //Scan(@"H:\noir.png");
            //Scan(@"H:\blanc.png");
            //Scan(@"H:\bleu.png");
            //Scan(@"H:\rouge.png");
            //Scan(@"H:\vert.png");


            //Scan(@"C:\apps\oracle\11.2.0.3\client-32\uix\cabo\images\bltdscn.gif");
            //Scan(@"C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\VCWizards\AppWiz\Generic\CustomWizard\Templates\1033\spacer.gif");

            var _nbProc = ConfigurationManager.AppSettings["nbProc"];
            int nbProc = 3;
            if (!string.IsNullOrEmpty(_nbProc))
                nbProc = Convert.ToInt32(_nbProc);
            ordo = new Ordonnanceur(nbProc);

            var dirs = new List<string>();

            var paths = ConfigurationManager.AppSettings["paths"];
            if (string.IsNullOrEmpty(paths))
            {
                foreach (var drive in Environment.GetLogicalDrives())
                {
                    dirs.Add(drive);
                }
            }
            else
            {
                var tab = paths.Split(';');
                foreach (string path in tab)
                {
                    if (string.IsNullOrEmpty(path))
                        continue;
                    dirs.Add(path);
                }
            }

            foreach (string dir in dirs)
            {
                try
                {
                    ordo.addTask(new TaskDir(ordo, new DirectoryInfo(dir)));
                }
                catch (Exception ex)
                {
                    Console.WriteLine("impossible de gérer " + dir + " " + ex);
                }
            }
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"C:\")));
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"E:\")));
            //ordo.addTask(new TaskDir(ordo, new DirectoryInfo(@"I:\")));
            while (ordo.Busy)
                Thread.Sleep(30);
            sw.Flush();
            sw.Dispose();

            Console.WriteLine("fin");
            Console.Read();
        }

        private class TaskDir : Task
        {
            private DirectoryInfo dir;
            public TaskDir(Ordonnanceur ordo, DirectoryInfo dir)
                : base(ordo)
            {
                this.dir = dir;
            }

            protected override void action()
            {
                //   ConsoleLogger.log(dir.FullName);
                List<FileDto> aux = null;
                foreach (FileInfo f in dir.GetFiles())
                {
                    // ConsoleLogger.log("check " + f.FullName);
                    FileDto fd = check(f);
                    if (fd != null)
                    {
                        ConsoleLogger.log(fd.ToStringSearch());
                        if (aux == null)
                            aux = new List<FileDto>();
                        aux.Add(fd);
                    }
                }
                if (aux != null)
                {
                    lock (_lock)
                    {
                        foreach (FileDto fd in aux)
                        {
                            fd.appendToDb(sw);
                        }
                        sw.Flush();
                    }
                }
                //ConsoleLogger.log("fin " +dir.FullName);
                done = true;

                foreach (DirectoryInfo sub in dir.GetDirectories())
                {
                    ordo.addsubTask(new TaskDir(ordo, sub));
                }
            }



            public override string ToString()
            {
                return dir.FullName;
            }
        }

        private class candidat
        {
            public candidat(String ext) { this.ext = ext; }
            private String ext;
            private int note = 0;
            public void increment()
            {
                note++;
            }
            public bool Accepted { get { return note >= 10; } }
        }
        private class listCandidat
        {
            private IDictionary<String, candidat> list = new Dictionary<String, candidat>();

            public bool record(String ext)
            {
                candidat cand;
                if (!list.ContainsKey(ext))
                {
                    cand = new candidat(ext);
                    list.Add(ext, cand);
                }
                cand = list[ext];
                cand.increment();
                return cand.Accepted;
            }
        }

        //static public Image Scan(string file)
        //{
        //   return ImageUtil.Scan(file); 
        //}
        [HandleProcessCorruptedStateExceptionsAttribute]
        static FileDto check(FileInfo f)
        {
            var file = f.FullName;
            //  Console.WriteLine(file.FullName);
            var ext = Path.GetExtension(file).ToLower().Replace(".", "");
            if (noImageType.Contains(ext)) return null;



            Image img;
            FileDto fdto = null;
            try
            {
                img = Image.FromFile(file);
                if (img != null)
                    fdto = new FileDto() { Path = file, Size = f.Length, Height = img.Height, Width = img.Width };

                img.Dispose();
            }

            catch (System.Runtime.InteropServices.SEHException e)
            {
               
            }
            catch (Exception ex)
            {
                
            }
            catch
            { }

            if (ext != null && ext.Length > 1)
            {
                if (!imageType.Contains(ext))
                {
                    ConsoleLogger.log("TYPE:" + ext + " " + file + " " + fdto);
                    if (fdto != null)
                    {
                        lock (imageCandidat)
                        {
                            if (imageCandidat.record(ext))
                            {
                                imageType.Add(ext);
                                ConsoleLogger.log("TYPE OK!!:" + ext + " " + file);
                            }
                        }

                    }
                    else
                    {
                        lock (NoImageCandidat)
                        {
                            if (NoImageCandidat.record(ext))
                            {
                                noImageType.Add(ext);
                                ConsoleLogger.log("TYPE NOK!!:" + ext + " " + file);
                            }
                        }
                        return null;
                    }
                }

            }
            return fdto;




        }

        static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {

            sw.Dispose();
        }

        static void write()
        {
            using (StreamWriter sw = new StreamWriter(FileDto.PATH))
            {
                foreach (FileDto f in list)
                {
                    sw.Write(f.Path);
                    sw.Write(";");
                    sw.WriteLine(f.Size);
                }
            }
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.player\App.xaml">
    <content><![CDATA[<Application x:Class="pdb.player.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:util="clr-namespace:pdb.player.Vue.Util"
             StartupUri="Player.xaml">
    <Application.Resources>
        <util:StringFormatConverter x:Key="StringFormater" />
        <util:TimeFormatConverter x:Key="TimeSpan" />
        <util:IntFormatConverter x:Key="Int" />
        <util:DecimalFormatConverter x:Key="decimal" />
        <util:DecimalFormatEConverter x:Key="decimalE" />
        <util:DecimalFormatElConverter x:Key="decimalEl" />
        <util:ClFormatConverter x:Key="cl" />
       
        <util:BgColorFormatConverter x:Key="colorExport" />
        <util:BgColorFormatConverter0 x:Key="colorExport0" />
        <util:BgColorFormatConverter00 x:Key="colorExport00" />
        <util:ForeColorFormatConverter x:Key="foreColor" />
        <util:ColorDispoConverter x:Key="dispo" />
        <util:BoolToVis x:Key="boolVis" />
        <util:SortModeConverter x:Key="sortAlbum" />
        <util:DateConverter  x:Key="date" />
        <util:DateToDelaiConverter x:Key="delai" />
        <util:SelectedMotifConverter x:Key="motif" />
        <util:FontConverter x:Key="fontWeight" />       
        <Style TargetType="{x:Type CheckBox}" x:Key="cb">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type CheckBox}">
                        <StackPanel Orientation="Horizontal">
                            <Image x:Name="checkboxImage" Source="/Vue/images/cbCoche.png" />
                            <ContentPresenter/>
                        </StackPanel>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsChecked" Value="True">
                                <Setter TargetName="checkboxImage" Property="Source" Value="/Vue/images/cbCoche.png"/>
                            </Trigger>
                            <Trigger Property="IsChecked" Value="False">
                                <Setter TargetName="checkboxImage" Property="Source" Value="/Vue/images/cbDecoche.png"/>
                            </Trigger>                            
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Application.Resources>
    
</Application>
]]></content>
  </file>
  <file path="db4\pdb.player\Player.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Player"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:userCtl="clr-namespace:pdb.player.Vue"
       
        Title="Player" >
    <Window.InputBindings>
        <KeyBinding Key="Right" Command="{Binding RightC}" />
        <KeyBinding Key="Left" Command="{Binding LeftC}" />
        <KeyBinding Key="Space" Command="{Binding SpaceC}" />
    </Window.InputBindings>

    <Grid>
        
        <DockPanel LastChildFill="True">
            <DockPanel.LayoutTransform>
                <ScaleTransform
                        CenterX="0"
                        CenterY="0"
                        ScaleX="{Binding ElementName=slider,Path=Value}"
                        ScaleY="{Binding ElementName=slider,Path=Value}"
                     />
            </DockPanel.LayoutTransform>
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <userCtl:PlayerControler Grid.Row="0" />
                <Grid Grid.Row="1">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition x:Name="cdBib" x:Uid="cdBib" Width="100"/>
                        <ColumnDefinition Width="3"/>
                        <ColumnDefinition x:Name="cdMain" x:Uid="cdMain" Width="40*"/>
                        <ColumnDefinition Width="3"/>
                        <ColumnDefinition x:Name="cdAlbum" x:Uid="cdAlbum" Width="12*"/>
                        <ColumnDefinition Width="3"/>
                        <ColumnDefinition x:Name="cdClassment" x:Uid="cdClassement"  Width="18*"/>
                    </Grid.ColumnDefinitions>
                    <userCtl:BibCtl x:Name="BibCtle" Grid.Column="0"  />
                    <GridSplitter Grid.Column="1" HorizontalAlignment="Stretch" />
                    <userCtl:DataGridPlayList x:Name="dg_pl" Grid.Column="2" />
                    <GridSplitter Grid.Column="3" HorizontalAlignment="Stretch" />
                    <DockPanel Grid.Column="4" HorizontalAlignment="Stretch" >
                        <userCtl:AlbumCtl DockPanel.Dock="Right" />
                    </DockPanel>
                    <GridSplitter Grid.Column="5" HorizontalAlignment="Stretch" />
                    <DockPanel Grid.Column="6" HorizontalAlignment="Stretch" >
                        <userCtl:ClassementCtl DockPanel.Dock="Right" />
                    </DockPanel>

                </Grid>
                <userCtl:StateBar Grid.Row="2" />
                <Slider Grid.Row="3"  x:Name="slider" Value="1" Minimum="0.1" Maximum="10" Visibility="Collapsed"></Slider>
            </Grid>
        </DockPanel>
    </Grid>
</Window>
]]></content>
  </file>
  <file path="db4\pdb.player\Player.xaml.cs">
    <content><![CDATA[using System.ComponentModel;
using System.Windows;
using pdb.util;
using System.Collections.Generic;
using pdb.player.ViewModel;
using System.Windows.Input;
using pdb.player.Vue;
using pdb.player.ViewModel.Colors;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class Player : Window
    {

        private static Logger log;
        private static Player _instance;
        public static Player Instance { get { return _instance; } }
        //public static RoutedCommand Right = new RoutedCommand(); 
        //public static RoutedCommand Left = new RoutedCommand();
        //public static RoutedCommand Space = new RoutedCommand(); 

        private Memento memento;

        public Player()
        {

            InitializeComponent();
            log = App.log;
            this.BibCtle.BibRoot = App.bib;
            this.Loaded += Player_Loaded;
            this.Closing += new CancelEventHandler(Player_Closing);
            _instance = this;
            DataContext = this;

            memento = Memento.Instance;
            var winpos = memento.winPos;
            if (winpos != null)
            {
                this.Top = winpos.Top;
                this.Width = winpos.Width;
                this.Height = winpos.Height;
                this.Left = winpos.Left;
            }

            var cmpPos = memento.cmpPos;

            if (cmpPos != null)
            {
                cdAlbum.Width = cmpPos.cdAlbum.toGrid();
                cdBib.Width = cmpPos.cdBib.toGrid();
                cdClassment.Width = cmpPos.cdClassement.toGrid();
                cdMain.Width = cmpPos.cdMain.toGrid();
            }

            var zoom = memento.Zoom;
            if (zoom > 0)
                slider.Value = zoom;
            this.MouseWheel += Player_MouseWheel;

            //Right.InputGestures.Add(new KeyGesture(Key.Right));
            //var bindingRight = new CommandBinding();
            //bindingRight.Command = Right; 
            //bindingRight.CanExecute+=new CanExecuteRoutedEventHandler(bindingRight_CanExecute);
            //Left.InputGestures.Add(new KeyGesture(Key.Left));
            //Space.InputGestures.Add(new KeyGesture(Key.Space)); 


            PlayListViewModel.initSelected(memento.selectedPlaylist);

            // new ConfCouleurs().Show(); 
        }

        private void Player_MouseWheel(object sender, MouseWheelEventArgs e)
        {
            if (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl))
            {
                if (e.Delta > 0)
                    slider.Value *= 1.01;
                else
                    slider.Value /= 1.01;
                memento.Zoom = slider.Value;
            }
        }

        void Player_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            var cmpPos = memento.cmpPos;
            if (cmpPos == null)
            {
                cmpPos = new CmpPos();
                memento.cmpPos = cmpPos;
            }
            cmpPos.cdAlbum = new Length(cdAlbum.Width);
            cmpPos.cdBib = new Length(cdBib.Width);
            cmpPos.cdClassement = new Length(cdClassment.Width);
            cmpPos.cdMain = new Length(cdMain.Width);
            var winPos = memento.winPos;

            if (winPos == null)
            {
                winPos = new WindowPos();
                memento.winPos = winPos;
            }
            winPos.Top = Top;
            winPos.Height = Height;
            winPos.Left = Left;
            winPos.Width = Width;

            string strPl = "";
            var pl = PlayListViewModel.SelectedPlayList;
            if (pl != null)
                strPl = pl.PlayList.getPath();
            memento.selectedPlaylist = strPl;

            memento.save();
            MementoColor.save();
            App.shutdown();

        }

        void Player_Loaded(object sender, RoutedEventArgs e)
        {
            //new ThreadUtil(() =>
            //App.go(),"go").Start(); 

        }

        public ICommand RightC { get { return PlayerViewModel.Instance.Forward; } }
        public ICommand LeftC { get { return PlayerViewModel.Instance.BackWard; } }
        public ICommand SpaceC { get { return PlayerViewModel.Instance.Play; } }


        // public static List<TrackListViewModel> VisibleItems { get { return _instance.dg_pl.VisibleItems; } }


    }
}
]]></content>
  </file>
  <file path="db4\pdb.player\ViewModel\BibViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.player.ViewModel.Commande;

namespace pdb.player.ViewModel
{
    class BibViewModel : ViewModelBase, IListWriter, IAbortTask
    {
        //  private CPlayList _root;
        private List<PlayListViewModel> windows = new List<PlayListViewModel>();
        private PlayListViewModel currentPlaying;

        public event EventHandler changelistPlaying;
        //   private static BibViewModel _instance;
        private PlayListViewModel root;

        public BibViewModel(PlayList _root)

        {
            this.root = new PlayListViewModel(_root);
            //if (_instance != null)
            //    throw new ApplicationException();
            //   this._root = _root;

            currentPlaying = root;
            //            _instance = this;

        }

        public BibViewModel(PlayListViewModel root)
        {
            this.root = root;
        }
        private double coeff = 1; 
        public double Coeff
        {
            get
            {
                return coeff; 
            }
            set
            {
                if (value != coeff)
                {
                    coeff = value; 
                    OnPropertyChanged("Coeff"); 
                }
            }
        }

        //public BibViewModel(PlayListViewModel root) :base(
        //{
        //}
        public PlayListViewModel Root { get { return root; } }
        private PlayListViewModel _listes;
        public PlayListViewModel Listes
        {
            get
            {
                if (_listes == null)
                {
                    foreach (PlayListViewModel sub in root)
                    {
                        if (sub.Name == "listes")
                        {
                            _listes = sub;
                            break;
                        }
                    }
                }
                return _listes;
            }
        }

        // public static BibViewModel Instance { get { return _instance; } }

        private ICommand cmdImport;
        public ICommand Import
        {
            get
            {
                if (cmdImport == null)
                    cmdImport = new ImportCmd(App.Instance, PlayerViewModel.Instance.Player);
                return cmdImport;
            }
        }

        private ICommand cmdCreateList;
        public ICommand CreateList
        {
            get
            {
                if (cmdCreateList == null)
                {
                    cmdCreateList = new CreateListCmd(App.Instance);
                }
                return cmdCreateList;
            }
        }

        public PlayListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    currentPlaying = value;
                    if (changelistPlaying != null)
                        changelistPlaying(this, EventArgs.Empty);
                }
            }
        }



        public PlayListViewModel Musique { get { return root.get("musique", true); } }
        //private ObservableCollectionTS<PlayListViewModel> _ihmPl; 
        //public ObservableCollectionTS<PlayListViewModel> PlayLists
        //{
        //    get
        //    {
        //        if (_ihmPl == null)
        //            _ihmPl = new ObservableCollectionTS<PlayListViewModel>(new List<PlayListViewModel>{this});
        //        return _ihmPl; 
        //       // return new ObservableCollectionTS<PlayListViewModel>(new List<PlayListViewModel> { _playlists });
        //    }
        //}

        //public PlayListViewModel PlayLists
        //{
        //    get
        //    {
        //        return this;
        //    }
        //}

        public List<PlayListViewModel> PlayLists_
        {
            get
            {
                return new List<PlayListViewModel>(root);
            }
        }

        private delegate void writePlayListDel(string folder, string name, ICollection<IFile> list, bool withOrder, IBgTask task);

        public void writePlayList(string folder, string name, ICollection<IFile> list, bool withOrder, IBgTask task)
        {
            if (aborted || task.Abort)
                return;
            //if (!Dispatcher.CurrentDispatcher.CheckAccess())
            //{
            //    Dispatcher.CurrentDispatcher.Invoke(new writePlayListDel(writePlayList), new object[] { folder, name, withOrder, task });
            //    return; 
            //}

            var conf = CConf.ConfGen;

            if (!conf.GenE)
            {
                if (name.StartsWith("e"))
                    return;
            }
            if (!conf.GenLarge)
            {
                if (name.EndsWith("+"))
                    return;
            }

            // misc.log(">< writePlaylist {0}", task);
            string[] folders = new string[] { folder };
            if (folder.Contains(@"\"))
            {
                folders = folder.Split('\\');
            }

            PlayListViewModel current = root;
            foreach (string f in folders)
            {
                if (aborted)
                    return;
                current = current.getOrCreatePlayList(f);
            }


            //   PlayListComposite plFolder = loader.getOrCreateFolder(folder);
            if (aborted)
                return;
            var playlist = current.getOrCreatePlayList(name);// loader.getOrCreatePlayList(current, name, false);

            // CPlayList playlist = loader.getList(plFolder, name);//  getList(folder, name);
            // return loader.mergeList(playlist, list, withOrder,this);
            //  var truncateList = truncate(playlist, list);
            if (aborted)
                return;
            playlist.mergeList(list, this);


        }




        public string Type
        {
            get { return "player"; }
        }

        private bool aborted;
        public bool Aborted
        {
            get { return aborted; }
            set { aborted = value; }
        }


        #region classement
        private delegate void setClassementDel(TrackListViewModel track, string _class, Classement newCl);
        public void setClassement(TrackListViewModel track, string newValue)
        {
            //if (track == null)
            //    return;

            //var piece = track.Track.Piece;
            //var _class = piece.ClassName;

            //var newCl = Classement.create(newValue);
            //if (newCl.ClassList == _class)
            //    return;

            //if (!Dispatcher.CurrentDispatcher.CheckAccess())
            //{
            //    Dispatcher.CurrentDispatcher.Invoke(new setClassementDel(setClass), new object[] { track, _class, newCl });
            //    return;
            //}
            //else
            //    setClass(track, _class, newCl);




        }

        //private void setClass(TrackListViewModel track, string _class, Classement newCl)
        //{
        //    var org = getClass(_class, false);
        //    var t = TrackListViewModel.getOrCreate(track.Master); // PlayListViewModel.findTrack(org, track.Master.PieceId); 
        //    org.RemoveTrack(t, true);
        //    var newpl = getClass(newCl.ClassList, true);

        //    newpl.AddTrack(track.Master, true);
        //}

        public PlayListViewModel getClass(string className, bool create)
        {
            char[] tab = className.ToCharArray();
            int count = tab.GetLength(0);
            int index = 0;
            PlayListViewModel current = root.get("classement", create);
            while (true)
            {
                if (current == null)
                    return null;
                if (index >= count)
                    break;
                var c = tab[index];
                if (c == '.')
                    break;
                current = current.get(c.ToString(), create);
                index++;
            }

            return current;
        }

        public PlayListViewModel getClass(int className)
        {
            return getClass(className.ToString(), false);
        }
        #endregion

        #region localisation
        #endregion


        public void syncMusique()
        {
            PlayListViewModel musique = Musique;
            musique.Synch();
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.player\Vue\BibCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.BibCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <TreeView Grid.Row="0" Name="tv_bib" ItemsSource="{Binding PLayLists, UpdateSourceTrigger=PropertyChanged}" Margin="0,-2,0,2"  ScrollViewer.CanContentScroll="True"
                
                  VirtualizingStackPanel.IsVirtualizing="True"
                  VirtualizingStackPanel.VirtualizationMode="Recycling"
                  >
            <TreeView.Background>
                <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                    <GradientStop Color="#dfdfdf" Offset="0" />
                    <GradientStop Color="#fff" Offset="1" />

                </LinearGradientBrush>

            </TreeView.Background>
            <TreeView.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Importer" Command="{Binding Import}"/>
                    <MenuItem Header="Créer une liste" Command="{Binding CreateList}" />
                </ContextMenu>
            </TreeView.ContextMenu>
            <TreeView.ItemContainerStyle>
                <Style TargetType="{x:Type TreeViewItem}">
                    <Setter Property="IsExpanded" Value="{Binding IsExpanded, Mode=TwoWay}" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />

                    <Setter Property="FontWeight" Value="Normal" />
                    <Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                    </Style.Triggers>
                </Style>

            </TreeView.ItemContainerStyle>

            <TreeView.ItemTemplate>
                <HierarchicalDataTemplate ItemsSource="{Binding}" >
                    <TextBlock Text="{Binding Name}" />
                </HierarchicalDataTemplate>

            </TreeView.ItemTemplate>
        </TreeView>
        <DockPanel   Grid.Row="1"  HorizontalAlignment="Stretch"  Margin="5">
            <Button Name="btCreateList"  Content="+" ToolTip="Créer une liste" Command="{Binding CreateList}" Width="30" />
            <!--<Slider  x:Name="slider" Value="1" Minimum="0.1" Maximum="10"></Slider>-->
        </DockPanel>

    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="db4\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Height="400"
        Title="ConfAlbumSortW" Loaded="Window_Loaded"  xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="d" d:DesignHeight="258" d:DesignWidth="508" >
    <Grid  IsSharedSizeScope="True" >

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <Grid Grid.Row="0" Name="gfirst" IsSharedSizeScope="True"/>

        <Grid Grid.Row="1" Name="gsecond"  IsSharedSizeScope="True"/>
        <!--<Grid Grid.ColumnSpan="2" Margin="0,0,-172,0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="236*" />
            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="4" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="5" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="6" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="7" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" KeyUp="tb_safe_KeyUp" />
            <TextBox  Grid.Row="0" Grid.Column="8" Name="tb_coeff" Width="40" ToolTip="coeff des morceaux virtuels" Margin="5" KeyUp="tb_safe_KeyUp" />
            <TextBox  Grid.Row="0" Grid.Column="9" Name="tb_coeffT" Width="40" ToolTip="coeff total des morceaux virtuels" Margin="5" KeyUp="tb_coeffT_KeyUp" />
            <CheckBox  Grid.Row="0" Grid.Column="10" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="11" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="0" Grid.Column="12" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="0" Grid.Column="13" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="14" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="15" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="16" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="17" Name="cb_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="18" Name="cb_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="19" Name="cb_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="20" Name="cb_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="21" Name="cb_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="22" Name="cb_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="23" Name="cb_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="24" Name="cb_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" />

            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="0" Grid.Column="25" Name="cbx_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="0" Grid.Column="26" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="4" Name="cb2_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="5" Name="cb2_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="6" Name="cb2_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="7" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="8" Name="tb2_coeff" Width="40" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="9" Name="tb2_coeffT" Width="40" ToolTip="coeff total des morceaux virtuels" Margin="5"  />
            <CheckBox  Grid.Row="1" Grid.Column="10" Name="cb2_removeFirst" ToolTip="removeFirst" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="11" Name="cb2_deleteFirst" ToolTip="deleteFirst" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="1" Grid.Column="12" Name="cbx2_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="1" Grid.Column="13" Name="cb2_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="14" Name="cb2_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="15" Name="tb2_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="16" Name="cb2_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="17" Name="cb2_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="18" Name="cb2_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="19" Name="cb2_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="20" Name="cb2_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="21" Name="cb2_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="22" Name="cb2_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="23" Name="cb2_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="24" Name="cb2_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" />
            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="1" Grid.Column="25" Name="cbx2_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="1" Grid.Column="26" Name="tb2_zero" Width="120" ToolTip="zéro" Margin="5" />
        </Grid>-->
        <Grid Grid.Row="2" Height="137" Margin="0,0,34,34">
            <Grid.RowDefinitions>
                <RowDefinition />
                <RowDefinition />
                <RowDefinition  Height="30"/>

            </Grid.RowDefinitions>
            <StackPanel Grid.Row="0" Orientation="Horizontal"  HorizontalAlignment="Center"  Margin="0,5" >
                <CheckBox Name="cb_createCourant" ToolTip="générer stats en cours (désactivés)"  Margin="5" Padding="2"></CheckBox>
                <CheckBox Name="cb_createInter" ToolTip="générer stats en cours + provisoire"  Margin="5" Padding="2"></CheckBox>
                <CheckBox Name="cb_createAll" ToolTip="générer stats de tout"  Margin="5" Padding="2"></CheckBox>
                <DatePicker Name="dp_date" ToolTip="Date seuil pour considérer un classement provisoire" />
            </StackPanel>
            <StackPanel Grid.Row="1" Orientation="Horizontal"  HorizontalAlignment="Center">
                <TextBox Grid.Row="2" Name="tb_stackSize" Width="30"  VerticalAlignment="Center" Text="20" ToolTip="taille de la pile d'exclusion" Margin="5" Padding="2"/>
                <TextBox Grid.Row="2" Name="tb_stackBefore" Width="30"  VerticalAlignment="Center" Text="10" ToolTip="nb d'éléments devant la pile d'exclusion" Margin="5" Padding="2"/>
                <CheckBox Grid.Row="2" Name="cb_stackEnabled" Width="30"  VerticalAlignment="Center" ToolTip="Utiliser la pile d'exclusion" Margin="5" Padding="2" />
                <CheckBox Grid.Row="2" Name="cb_checkStack" Width="30"  VerticalAlignment="Center" ToolTip="Ne pas prendre en compte les albums retardés dans la file d'attente pour la cinématique" Margin="5" Padding="2" />
                <CheckBox Grid.Row="2" Name="cb_only_new" Width="30"  VerticalAlignment="Center" ToolTip="Ne retarder que les nouveaux" Margin="5" Padding="2" />
                <CheckBox Grid.Row="2" Name="cb_idem" Width="30"  VerticalAlignment="Center" ToolTip="Lier les items" Margin="5" Padding="2" Click="cb_idem_Click" />

                <Button Grid.Row="2" Name="bt_cancel" IsCancel="true" Height="25" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_ok" Height="25" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_coul" Height="25" HorizontalAlignment="Right" Content="Couleurs" Click="bt_coul_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_debug" Height="25" HorizontalAlignment="Right" Content="Debug" Click="bt_debug_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_misc" Height="25" HorizontalAlignment="Right" Content="Misc" Click="bt_misc_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_compact" Height="25" HorizontalAlignment="Right" Content="Compact" Click="bt_compact_Click"   Margin="5" Padding="2"/>
            </StackPanel>
            <StackPanel Grid.Row="2" Orientation="Horizontal"  HorizontalAlignment="Center" Margin="0">
                <TextBox Name="tb_path" Text="pdbr.xml" Margin="5" Padding="2"/>
                <TextBox Name="tb_nb" Text="100" Margin="5" Padding="2"/>
                <Button Name="btBd" Content="Extraction" Click="btBd_Click" Margin="5" Padding="2"/>
                <Button Name="btResetZoom" Content="Reset Zoom" Click="btResetZoom_Click" Margin="5" Padding="2"/>

            </StackPanel>
        </Grid>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="db4\pdb.player\Vue\ConfAlbumSortW.xaml.cs">
    <content><![CDATA[using System;
using System.Windows;
using pdb.gen.Tuning;
using pdb.gen;
using pdb.player.Vue.Conf;
using System.Windows.Controls;
using pdb.gen.stat;
using pdb.player.ViewModel;
using System.Collections.Generic;
using pdb.db.obj;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfAlbumSortW.xaml
    /// </summary>
    public partial class ConfAlbumSortW : Window, IConfSort
    {
        private ConfAlbumSort conf;
        private ConfMedianneW first;
        private ConfMedianneW second;
        private static bool _idem;
        public ConfAlbumSortW()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(ConfAlbumSortW_Loaded);
        }

        void ConfAlbumSortW_Loaded(object sender, RoutedEventArgs e)
        {
            bt_ok.IsDefault = true;

            display();
        }

        public ConfAlbumSortW(ConfAlbumSort conf)
            : this()
        {
            this.conf = conf;
            first = new ConfMedianneW(conf.Composants[0], this);
            gfirst.Children.Add(first);
            if (conf.Composants.Count > 1)
            {
                second = new ConfMedianneW(conf.Composants[1], this);
                gsecond.Children.Add(second);
            }

            InitializeComponent();
        }

        void display()
        {
          
            tb_stackSize.Text = conf.stackSize.ToString();
            tb_stackBefore.Text = conf.stackBefore.ToString();
         
            cb_createAll.IsChecked = conf.createAll;
            cb_createInter.IsChecked = conf.createInter;
            cb_createCourant.IsChecked = conf.createCourant;
            dp_date.SelectedDate = conf.lastModif;
            cb_idem.IsChecked = _idem;
            cb_checkStack.IsChecked = conf.checkStack;
            cb_stackEnabled.IsChecked = conf.stackEnabled;
            cb_only_new.IsChecked = conf.stackOnlyNew; 
         

            first.display();
            if (second != null)
                second.display();


            //var list = conf.Composants;
            //var item1 = list[0];
            //cb_enabled.IsChecked = item1.enabled;
            //cbxSort.SelectedIndex = (int)item1.type;
            //tb_medianne.Text = item1.medianne.ToString();
            //cb_quasi.IsChecked = item1.quasi;
            //cb_lissage.IsChecked = item1.lissage;
            //cb_removeEpsilon.IsChecked = item1.removeEpsilon;
            //cb_reSort.IsChecked = item1.reSort;
            //cb_removeFirst.IsChecked = item1.removeFirst;
            //cb_deleteFirst.IsChecked = item1.deleteFirst;
            //cbx1_removeLast.SelectedIndex = (int)item1.removeLast;
            //cb_cumul.IsChecked = item1.cumul;
            //cb_noAdd.IsChecked = item1.noAdd;
            //tb_safe.Text = item1.safe.ToString();
            //tb_coeff.Text = item1.coeffVirt.ToString();
            //tb_exp.Text = item1.expEnabled.ToString();
            //tb_zero.Text = Piece.getClassementEquiv(item1.zero);
            //cb_removeEnabled.IsChecked = item1.removeEnabled;
            //cb_virtOnlyDisabled.IsChecked = item1.virtOnlyDisabled;
            //cb_forceCoeffVirt.IsChecked = item1.forceCoeffVirt;
            //cb_virtAlignPrec.IsChecked = item1.virtAlignPrec;
            //cb_virtAlignSelected.IsChecked = item1.virtAlignSelected;
            //cb_coeffVirtAdjust.IsChecked = item1.coeffVirtAdjust;
            //cb_coeffVirtAuto.IsChecked = item1.coeffVirtAuto;
            //cbx_cmpMinn.SelectedIndex = (int)item1.cmpMin;
            //cb_noaddEnd.IsChecked = item1.noAddEnd;
            //cb_noaddAll.IsChecked = item1.noAddAll; 





            //if (list.Count > 1)
            //{
            //    item1 = list[1];
            //    cb2_enabled.IsChecked = item1.enabled;
            //    cbx2Sort.SelectedIndex = (int)item1.type;
            //    tb2_medianne.Text = item1.medianne.ToString();
            //    cb2_quasi.IsChecked = item1.quasi;
            //    cb2_lissage.IsChecked = item1.lissage;
            //    cb2_removeEpsilon.IsChecked = item1.removeEpsilon;
            //    cb2_reSort.IsChecked = item1.reSort;
            //    cb2_removeFirst.IsChecked = item1.removeFirst;
            //    cb2_deleteFirst.IsChecked = item1.deleteFirst;
            //    cbx2_removeLast.SelectedIndex = (int)item1.removeLast;
            //    cb2_cumul.IsChecked = item1.cumul;
            //    cb2_noAdd.IsChecked = item1.noAdd;
            //    tb2_safe.Text = item1.safe.ToString();
            //    tb2_coeff.Text = item1.coeffVirt.ToString();
            //    tb2_exp.Text = item1.expEnabled.ToString();
            //    tb2_zero.Text = Piece.getClassementEquiv(item1.zero);
            //    cb2_removeEnabled.IsChecked = item1.removeEnabled;
            //    cb2_virtOnlyDisabled.IsChecked = item1.virtOnlyDisabled;
            //    cb2_forceCoeffVirt.IsChecked = item1.forceCoeffVirt;
            //    cb2_virtAlignPrec.IsChecked = item1.virtAlignPrec;
            //    cb2_virtAlignSelected.IsChecked = item1.virtAlignSelected;
            //    cb2_coeffVirtAdjust.IsChecked = item1.coeffVirtAdjust;
            //    cb2_coeffVirtAuto.IsChecked = item1.coeffVirtAuto;
            //    cbx2_cmpMinn.SelectedIndex = (int)item1.cmpMin;
            //    cb2_noaddEnd.IsChecked = item1.noAddEnd;
            //    cb2_noaddAll.IsChecked = item1.noAddAll; 
            //}
        }
        void record()
        {
          
            conf.stackSize = Convert.ToInt32(tb_stackSize.Text);
            conf.stackBefore = Convert.ToInt32(tb_stackBefore.Text);
            conf.createCourant = cb_createCourant.IsChecked.Value;
            conf.createInter = cb_createInter.IsChecked.Value;
            conf.createAll = cb_createAll.IsChecked.Value;
            conf.lastModif = dp_date.SelectedDate.Value;
            conf.checkStack = cb_checkStack.IsChecked.Value;
            conf.stackEnabled = cb_stackEnabled.IsChecked.Value;
            conf.stackOnlyNew = cb_only_new.IsChecked.Value; 
          

            first.record();
            if (second != null)
                second.record();

           


            //var list = conf.Composants;
            //var item1 = list[0];
            //item1.enabled = cb_enabled.IsChecked.Value;
            //item1.type = (util.medianneMode)cbxSort.SelectedIndex;
            //item1.medianne = Convert.ToDecimal(tb_medianne.Text);
            //item1.quasi = cb_quasi.IsChecked.Value;
            //item1.lissage = cb_lissage.IsChecked.Value;
            //item1.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            //item1.reSort = cb_reSort.IsChecked.Value;
            //item1.removeFirst = cb_removeFirst.IsChecked.Value;
            //item1.deleteFirst = cb_deleteFirst.IsChecked.Value;
            //item1.removeLast = (util.removeLast)cbx1_removeLast.SelectedIndex;
            //item1.cumul = cb_cumul.IsChecked.Value;
            //item1.noAdd = cb_noAdd.IsChecked.Value;
            //item1.safe = Convert.ToInt32(tb_safe.Text);
            //item1.coeffVirt = Convert.ToDecimal(tb_coeff.Text);
            //item1.expEnabled = Convert.ToDecimal(tb_exp.Text);
            //var cl = Classement.create(tb_zero.Text);
            //item1.zero = cl.RapportClassement;
            //item1.removeEnabled = cb_removeEnabled.IsChecked.Value;
            //item1.virtOnlyDisabled = cb_virtOnlyDisabled.IsChecked.Value;
            //item1.forceCoeffVirt = cb_forceCoeffVirt.IsChecked.Value;
            //item1.virtAlignPrec = cb_virtAlignPrec.IsChecked.Value;
            //item1.virtAlignSelected = cb_virtAlignSelected.IsChecked.Value;
            //item1.coeffVirtAuto = cb_coeffVirtAuto.IsChecked.Value;
            //item1.coeffVirtAdjust = cb_coeffVirtAdjust.IsChecked.Value;
            //item1.cmpMin = (util.modeMin)cbx_cmpMinn.SelectedIndex;
            //item1.noAddEnd = cb_noaddEnd.IsChecked.Value;
            //item1.noAddAll = cb_noaddAll.IsChecked.Value; 

            //if (list.Count > 1)
            //{
            //    if (cbx2Sort.SelectedIndex == 0)
            //    {
            //        list.RemoveAt(1);
            //        return;
            //    }
            //}
            //else
            //{
            //    if (cbx2Sort.SelectedIndex > 0)
            //    {
            //        item1 = new util.ConfMedianne();
            //        list.Add(item1);
            //    }
            //}

            //if (list.Count > 1)
            //{
            //    item1 = list[1];

            //    item1.enabled = cb2_enabled.IsChecked.Value;
            //    item1.type = (util.medianneMode)cbx2Sort.SelectedIndex;
            //    item1.medianne = Convert.ToDecimal(tb2_medianne.Text);
            //    item1.quasi = cb2_quasi.IsChecked.Value;
            //    item1.lissage = cb2_lissage.IsChecked.Value;
            //    item1.removeEpsilon = cb2_removeEpsilon.IsChecked.Value;
            //    item1.reSort = cb2_reSort.IsChecked.Value;
            //    item1.removeFirst = cb2_removeFirst.IsChecked.Value;
            //    item1.deleteFirst = cb2_deleteFirst.IsChecked.Value;
            //    item1.removeLast = (util.removeLast)cbx2_removeLast.SelectedIndex;
            //    item1.cumul = cb2_cumul.IsChecked.Value;
            //    item1.noAdd = cb2_noAdd.IsChecked.Value;
            //    item1.safe = Convert.ToInt32(tb2_safe.Text);
            //    item1.coeffVirt = Convert.ToDecimal(tb2_coeff.Text);
            //    item1.expEnabled = Convert.ToDecimal(tb2_exp.Text);
            //    item1.zero = Convert.ToDecimal(tb2_zero.Text);

            //    cl = Classement.create(tb2_zero.Text);
            //    item1.zero = cl.RapportClassement;
            //    item1.removeEnabled = cb2_removeEnabled.IsChecked.Value;
            //    item1.virtOnlyDisabled = cb2_virtOnlyDisabled.IsChecked.Value;
            //    item1.forceCoeffVirt = cb2_forceCoeffVirt.IsChecked.Value;
            //    item1.virtAlignPrec = cb2_virtAlignPrec.IsChecked.Value;
            //    item1.virtAlignSelected = cb2_virtAlignSelected.IsChecked.Value;
            //    item1.coeffVirtAuto = cb2_coeffVirtAuto.IsChecked.Value;
            //    item1.coeffVirtAdjust = cb2_coeffVirtAdjust.IsChecked.Value;
            //    item1.cmpMin = (util.modeMin)cbx2_cmpMinn.SelectedIndex;
            //    item1.noAddEnd = cb2_noaddEnd.IsChecked.Value;
            //    item1.noAddAll = cb2_noaddAll.IsChecked.Value; 
            //}
        }

        private void bt_cancel_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }

        private void bt_ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close();
            conf.Calcul();
            App.go();
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {

        }




        //public string CoeffEnabled
        //{
        //    get { return tb_coeffEnabled.Text; }
        //}

        public bool DuplicateItem
        {
            get
            {
                bool ret = cb_idem.IsChecked.Value;
                _idem = ret;
                return ret;
            }
        }
        private void tb_safe_KeyUp(object sender, System.Windows.Input.KeyEventArgs e)
        {
            first.onchange();

            if (second != null)
                second.onchange();
        }

        private void bt_coul_Click(object sender, RoutedEventArgs e)
        {
            new ConfCouleurs().Show();
        }

        private void cb_idem_Click(object sender, RoutedEventArgs e)
        {
            first.checkIdem();
            if (second != null)
                second.checkIdem();
        }

        private void bt_debug_Click(object sender, RoutedEventArgs e)
        {
            var w = new Debug(conf);
            w.Show(); 
        }

        private void bt_compact_Click(object sender, RoutedEventArgs e)
        {
            Condenseur.deleteFile();
            App.gen.GoCompact();
            App.go(); 
        }

        private void btBd_Click(object sender, RoutedEventArgs e)
        {

            var pl = PlayListViewModel.SelectedPlayList;
            var listT =new List<TrackListViewModel>(pl.Tracks); 
            var list = new List<CPiece>();
            var hs = new HashSet<int>(); 
            int count = Convert.ToInt32(tb_nb.Text);
            string file = tb_path.Text;
            int nb = 0; 
            for (int i = 0; i < listT.Count; i++)
            {
                var track = listT[i];
                if (track.album.Virtual)
                    continue; 
                var p = track.Piece;
                if (hs.Add(p.PieceId))
                {
                    list.Add(p);
                    nb++;
                    if (nb >= count)
                        break;
                }
            }
            App.Db.export(file, list); 
        }

        private void bt_misc_Click(object sender, RoutedEventArgs e)
        {
            var w = new Miscellaneous();
            w.Show(); 
        }

        private void btResetZoom_Click(object sender, RoutedEventArgs e)
        {
            Memento.Instance.Zoom = 1; 
            Player.Instance.slider.Value = 1; 
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.player\Vue\Memento.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;
using System.IO;
using System.Windows;
using pdb.gen.Tuning;
using System.Xml;
using pdb.util;

namespace pdb.player.Vue
{
    [Serializable]
    [DataContract]
    class Memento
    {
        [NonSerialized]
        const string FILE_CONF = "confAlbum.xml";
        [NonSerialized]
        const string PATH = TuningBase.DIR_CONF + "memento.dat";
        [NonSerialized]
        const string PATH_XML = TuningBase.DIR_CONF + "memento.xml";
        [NonSerialized]
        const string PATH_CONF = TuningBase.DIR_CONF + FILE_CONF;
        [NonSerialized]
        const string SOV_CONF = TuningBase.DIR_CONF + "sov\\";
        [NonSerialized]
        private static volatile Memento _instance;
        //[NonSerialized]
        //private FileRotator fileRotator;
        [DataMember]
        public WindowPos winPos = null;
        [DataMember]
        public CmpPos cmpPos = null;
        [DataMember]
        public string selectedPlaylist = "";
        [DataMember]
        public Dictionary<string, object> dict = new Dictionary<string, object>();
        [NonSerialized]
        public ConfAlbumSort confAlbum;
        [DataMember]
        public double Zoom = 1;




        private Memento()
        {
            //  fileRotator = new FileRotator();
        }
        public static Memento Instance
        {
            get
            {
                if (_instance == null)
                {

                    var formater = new BinaryFormatter();
                    try
                    {
                        if (File.Exists(PATH_XML))
                        {
                            _instance = DeSerialize(PATH_XML);
                        }

                        else if (File.Exists(PATH))
                        {
                            using (Stream st = new FileStream(PATH, FileMode.Open))
                            {
                                _instance = (Memento)(formater.Deserialize(st));
                            }
                        }
                        else
                            _instance = new Memento();
                        var doc = new XmlDocument();
                        doc.Load(PATH_CONF);
                        var conf = new ConfAlbumSort(doc.DocumentElement);

                        _instance.confAlbum = conf;
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        if (Application.Current is App)
                            throw;
                    }




                    if (_instance == null)
                        _instance = new Memento();

                    //  _instance.fileRotator = new FileRotator();
                }
                //   _instance.save();
                return _instance;

            }
        }
        public void save()
        {
            DateTime now = DateTime.Now;
            //  var formater = new BinaryFormatter();
            Serialize(PATH_XML, _instance);

            //using (Stream st = new FileStream(PATH, FileMode.Create))
            //{
            //    formater.Serialize(st, this);
            //}
            if (this.confAlbum != null)
            {
                // fileRotator.save(PATH_CONF, SOV_CONF, 100);
                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(PATH_CONF, settings))
                {
                    this.confAlbum.save(writer);
                }
            }
            misc.log("Memento.save:" + (DateTime.Now - now).TotalMilliseconds.ToString("0 ms"));
        }

        private static DataContractSerializer serializer;

        public static void Serialize(string filePath, Memento mem)
        {
            serializer = new DataContractSerializer(typeof(Memento));


            using (var fs = new FileStream(filePath, FileMode.Create, FileAccess.Write))
            {
                using (var xmlWriter = new XmlTextWriter(fs, Encoding.UTF8))
                {
                    xmlWriter.Formatting = Formatting.Indented;
                    serializer.WriteObject(xmlWriter, mem);
                }
            }
        }

        public static Memento DeSerialize(string filePath)
        {
            serializer = new DataContractSerializer(typeof(Memento), new List<Type>() { typeof(ColumnInfo), typeof(ColumnInfos) });

            Memento serializeTest;

            using (var reader = new FileStream(filePath, FileMode.Open, FileAccess.Read))
            {
                serializeTest = serializer.ReadObject(reader) as Memento;
            }

            return serializeTest;
        }
    }
    [Serializable]
    class WindowPos
    {
        public double Top;
        public double Left;
        public double Width;
        public double Height;
    }
    [Serializable]
    class CmpPos
    {
        public Length cdBib;
        public Length cdMain;
        public Length cdAlbum;
        public Length cdClassement;
    }

    [Serializable]
    public class Length
    {
        public double value;
        public GridUnitType unit;
        public Length(GridLength ihm)
        {
            value = ihm.Value;
            unit = ihm.GridUnitType;
        }
        public GridLength toGrid()
        {
            return new GridLength(value, unit);
        }
    }
}
]]></content>
  </file>
</db>
