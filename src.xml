<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Tuning;
using pdb.util;
using System.Collections.Generic;
using System.Xml;
using System;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public class LimitsLoader
    {
        private DirConf dir;
      //  private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
       // public loadState state;
        //  private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
           var limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
            //  log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void init(DirConf dir)
        {
            this.dir = dir;
            var limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].init(this,limit[i]);
            }
        }

        //public void getLoaders(List<LimitItemLoader> list)
        //{
        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].getLoaders(list);
        //    }
        //}

        private bool candidatLoaded;
        public void loadCandidats()
        {
            if (candidatLoaded)
            {
                foreach (LimitLoader item in limites)
                {
                    item.reset();
                }
                return;
            }
            try
            {
                var feeds = dir.Feeds;
                string feedName = null;
                bool histo = dir.Histo;
                bool? histoAll = dir.HistoAll;
                if (histo && false.Equals(histoAll))
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();



                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null)
                    {
                        if (track.Album != feedName)
                            continue;
                    }

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    loaded.Add(track);
                }

                if (histo)
                    loaded.Sort(new PodCastComparerPub2());
                else
                    loaded.Sort(new PodCastComparerInv());


                //   for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    limit.loadCandidats(loaded);

                }


            }
            finally
            {
                //state = loadState.selection;
                candidatLoaded = true;
            }
        }

        private bool recordGuests;
        public void phase2()
        {
           // state = loadState.selection;
            if (dir.Cascading)
                recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        //public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        //{

        //    if (!recordGuests)
        //        return;


        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].recordGuest(track, item);
        //    }
        //}

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
        //    }
        //}


        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                var list = dir.getListe();

                var limits = dir.Limites;
                var usegenPrior = Conf.GenUsePrior;
                var exclugenPrior = Conf.GenExcluPrior;

                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    List<TrackInfoItunes> items;
                    foreach (LimitItemLoader item in limit.Items)
                    {
                        // var index = limit.index(item);
                        //if (Conf.WriteItems)
                        //{
                        //    items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                        //    buildList(item.Item.ID, items, "_sel");
                        //}

                        //if (Conf.WritePreSel)
                        //{
                        //    items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                        //    buildList(item.Item.ID, items, "_sel0");
                        //}
                        //if (Conf.WriteUse)
                        //{
                        //    items = item.use;
                        //    buildList(item.Item.ID, usegenPrior, items, "_use");
                        //}
                        //if (Conf.WriteExclu)
                        //{
                        //    var limite = item.Item;
                        //    items = item.use.FindAll(t => t.Exclu == limite);
                        //    buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                        //}

                    }
                }

                //if (dir.Parent == null)
                //{
                if (dir.Parent == null)
                {

                    var lfolders = dir.Folders;

                    buildListPrior("_auto", list, lfolders);



                    foreach (SelectParamBase listeSuppl in Conf.Listes)
                    {
                        var selector = new TrackSelector(listeSuppl);
                        var l = new List<TrackInfoItunes>();
                        foreach (TrackInfoItunes t in list)
                        {
                            if (selector.select(t))
                                l.Add(t);
                        }
                       
                        buildListPrior(listeSuppl.name, l, lfolders);
                    }

                    //var lHisto = list.FindAll(t => t.Histo);
                    //buildList("_histo", lHisto, lfolders);

                    //var lPasHisto = list.FindAll(t => !t.Histo);
                    //buildList("_pasHisto", lPasHisto, lfolders);

                    //var lSerie = list.FindAll(t => t.Serial);
                    //buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, folders);
        }
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders, false);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0;
            foreach (TrackInfoItunes track in list)
            {
                nb++;
                writer.StartElement("t");
                writer.SetAttribute("dt", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));

                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }

                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                writer.SetAttribute("track", track.Name);

                if (track.Pub2 > track.Pub)
                {
                    writer.SetAttribute("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                    writer.SetAttribute("e", (track.Pub2 - track.Pub).TotalDays.ToString("0.#")); 
                }
                if (nb <= nbmax)
                {
                    WriteCause(dir.CauseRegister.Get(track), true, true);
                    WriteCause(dir.CauseRegister.Get(track), true, false);
                    WriteCause(dir.CauseRegister.Get(track), false, true);
                    WriteCause(dir.CauseRegister.Get(track), false, false);

                }
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodCastComparerPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (false != dir.HistoAll)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;

                
                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    try
                    {
                        writer.StartElement("i");
                        writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                        var sb = new StringBuilder();
                        lim.writeStatHeader(sb);
                        lim.Stat.Total.buildValues(sb);
                        writer.SetAttribute("stats", sb.ToString());

                        writeTracks(dir, lim.Stat, null, false);
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }

                    finally
                    {
                        writer.EndElement();
                    }
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes, bool strict, bool ok)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses(strict, ok, ok))
            {
                string str = "cause";
                if (strict)
                    str += "strict";
                if (!ok)
                    str += "nok";
                writer.StartElement(str);


                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString());
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause > 0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0;
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list = dir.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break;
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        if (track.Pub2 > track.Pub)
                            writer.SetAttribute("pub2", track.Pub2);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes, true, true);
                        WriteCause(causes, true, false);

                        WriteCause(causes, false, true);
                        WriteCause(causes, false, false);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {

            //log.log("{0} Selection", dir);

            //for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                limit.Selection();

            }

        }

        public override string ToString()
        {
            return dir.ToString();
        }

    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;

namespace pdb.podcast.Sort
{
    class Album
    {
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        // private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbRepecheForce = 0;
        private static DateTime dateRepeche = DateTime.MaxValue; public static DateTime DateRepeche { get { return dateRepeche; } }
        private static List<TrackSort> repeches = new List<TrackSort>();
        public static int NbRepeches { get { return repeches.Count; } }
        public static int NbModif { get { return nbModif; } }
        private bool done;

        //  bool checkSelected, apply;
        DateTime date0, newDate0;
        DateTime date1;
        public static void Init()
        {
            //lastReads.Clear(); 
            //nbrepeches = 0;
            repeches.Clear();
            nbModif = 0;
            nbRepecheForce = 0;
            dateRepeche = DateTime.MaxValue;
        }

        public static void Bilan()
        {
            if (dateRepeche < DateTime.MaxValue)
                log.log("*************Date minimum:" + dateRepeche);
            repeches.Sort((x, y) => x.Pub2.CompareTo(y.Pub2));
            foreach (TrackSort t in repeches)
                log.log(string.Format("date={0} {1}", t.Pub2, t));
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;
        public static Logger logDebug;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }



        public void init()
        {
            //done = false;
        }

        //public void buildAll()
        //{
        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;

        //    checkSelected = false;
        //    apply = false;

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        var dt = track.Pub2.AddSeconds(1);
        //        date0 = dt;
        //        newDate0 = dt;
        //        build();
        //        if (dt >= Conf.Date0)
        //            break;
        //    }

        //    apply = true;
        //    date0 = Conf.Date0;
        //    newDate0 = Conf.NewDate0;
        //    // writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        writeComment(track, track.Pub2);
        //    }
        //}

        private void build0()
        {
            int count = list.Count;
            if (count == 0)
                return;



            TrackSort.Date0 = date0;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                            indexNextSelected = i;
                        }
                    }
                    else
                        break;
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;


            var intervalle = conf.getIntervalle(album.Rare, lastRead.DureeEnHeure);
            var intervalleMin = conf.getIntervalleMin(album.Rare, lastRead.DureeEnHeure);
            var intervalleMin0 = conf.getIntervalleMin0(album.Rare);
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = intervalle; // conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    // var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    double rapport = (double)_nbRead / (double)_nbTotal;

                    var coeff = 1 / rapport;

                    if (conf.dureeBornee)
                    {
                        coeff = conf.getCoeff(album.Rare, coeff, lastRead.DureeEnHeure);
                    }

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);



                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                {
                    double _coeff = deltaLimiteEcoule / delta;
                    delta = borne(_coeff, intervalle, intervalleMin);
                }

                if (delta < 1)
                    delta = 1;




                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }





            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();

            DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * delta).truncateToMinute();
            //var cumul = (limitFuture - next.Pub).TotalDays;
            //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
            //if (dtaux > limitFutureRab)
            //    limitFutureRab = dtaux; 
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = delta;
            if (conf.extPente > 0)
                deltaAtterrissage = delta0;


            if (conf.deltaConst || conf.extPente > 0)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                for (int i = indexLastRead + 2; i < count; i++)
                {
                    var t = list[i];
                    if (conf.useVirtuel)
                    {
                        // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                        dt = dt.AddDays(intervalleMin0);
                    }
                    else
                        dt = t.Pub;


                    nb++;
                    if (dt > limitFuture)
                    {
                        nextDate = dt;
                        nblissage++;
                        if (dt <= _deltaMin)
                            continue;
                        if (dt <= _deltaRab)
                            continue;
                        if (nb <= conf.deltaNbMin)
                            continue;
                        if (nblissage <= conf.deltaNbRab)
                            continue;
                        if (dt <= limitFutureRab)
                            continue;

                        break;


                        //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                        //    break;
                    }

                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            //  nb = 0;
            // bool enRetard = limitFuture < date0;
            TrackSort last = next;
            DateTime lastPub2 = limitFuture;
            int indexDepart = indexLastRead + 1;

            bool erased = false;

            for (int i = indexDepart; i < count; i++)
            {
                var t = list[i];
                if (erased && conf.erasedDone)
                {
                    eraseSort(t);
                    continue;
                }

                DateTime dt = lastPub2;

                if (i == indexDepart && !conf.useVirtuel2)
                {
                    dt = limitFuture;
                }
                else
                {

                    //if (conf.deltaCheckSelected)
                    //{
                    //    if (!t.Selected)
                    //        continue;
                    //    if (!t.Enabled)
                    //        continue;
                    //}
                    var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                    if (conf.useVirtuel2)
                        dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                    else
                        dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
                    if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1)
                    {
                        var dt2 = dt;
                        if (conf.useVirtuel2)
                            dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                        else
                            dt2 = lastPub2.AddDays(delta).truncateToMinute();
                        //if (dt2 <= date0)
                        dt = dt2;
                        //else
                        //    dt = date0.AddMinutes(1);
                    }


                }



                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset || erased && conf.erasedDone)
                {
                    erased = true;
                    eraseSort(t);
                }
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }


                    if (dt > DateTime.Now)
                    {
                    }

                    if ((dt - t.Pub).TotalDays > 100)
                    {
                    }

                    writeComment(t, dt);
                    //nb++;
                }


                last = t;
                lastPub2 = dt;


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }

        private void build()
        {
            int count = list.Count;
            if (count == 0)
                return;

            bool rare = album.Rare;

            TrackSort.Date0 = date0;

            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;

            // 1. ordre
            for (int i = 0; i < count; i++)
            {
                var track = list[i];


                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

            //2. si pas recheck on détermine ou on en est

            int index0 = 0;
            int indexCourant = 0;

            TrackSort next = null;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                        }
                    }
                    else
                        break;
                }
            }

            if (indexLastRead < 0)
                return;


            indexCourant = indexLastRead;

            if (!conf.recheck)
                index0 = indexCourant;


            while (true)
            {
                if (index0 >= count - 1)
                    break;
                indexLastRead = -1;
                lastRead = null;
                //  int indexNextSelected = -1;
                DateTime lastPlayed = DateTime.MinValue;
                //  TrackSort next = null;

                // 2. Détermination lastRead et next
                for (int i = index0; i < count; i++)
                {                   
                    var track = list[i];
                    if (track.Name.StartsWith("Big Data"))
                    {
                    }
                    if (track.Played) // && track.PlayedDate > lastPlayed)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        lastRead = track;
                        break;
                    }

                    //else
                    //{
                    //    if (next == null)
                    //    {
                    //        if ((checkSelected && track.Selected) || track.Pub2 >= date0)
                    //        {
                    //            next = track;
                    //            indexNextSelected = i;
                    //        }
                    //    }
                    //    else
                    //        break;
                    //}
                }


                if (indexLastRead < 0)
                    return;


                var intervalle = conf.getIntervalle(rare, lastRead.DureeEnHeure);
                var intervalleMin = conf.getIntervalleMin(rare, lastRead.DureeEnHeure);
                var intervalleMin0 = conf.getIntervalleMin0(rare);
                var atterissageMin = conf.getAtterrissageMin(rare);
                double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                DateTime pub2 = lastRead.Pub2;

                double delta0Corr = deltaLastRead0;

                double cumulMin = conf.getCumulMin(rare);
                double cumulMax = conf.getCumulMax(rare);

                if (pub2 > lastRead.Pub && conf.extPente == 0)
                {
                    if (conf.elastique < 1)
                    {
                        delta0Corr = deltaLastRead0 * conf.elastique;
                        pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                    }


                    //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                    //{
                    //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                    //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                    //}
                }




                var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

                //int nbReads = 0;
                //int nbTotals = 0;

                int nbRead = 0;
                int nbTotal = 0;

                //int _nbRead = 0;
                int _nbTotal = 0;
                double delta = intervalle; // conf.getIntervalle(album.Rare);
                double delta0 = delta;
                var _histo = conf.getHisto(rare);
                double densite = 1;
                if (_histo > 0)
                {

                    double histo = _histo;




                    DateTime limit = lastRead.Pub.AddDays(-histo);
                    for (int i = indexLastRead; i >= 0; i--)
                    {
                        var t = list[i];
                        var dt = t.Pub;
                        if (dt < limit && nbTotal >= conf.totalMin)
                            break;

                        if (t.Played)
                            nbRead++;


                        nbTotal++;

                    }

                    _nbTotal = nbTotal;

                    if (nbRead > 0 && _nbTotal > 0)
                    {
                        if (_nbTotal < conf.totalMin)
                            _nbTotal = conf.totalMin;
                        //  album.Rare ? conf.intervalleR : conf.intervalle;
                        double rapport = (double)nbRead / (double)_nbTotal;
                        var coeff = 1 / rapport;

                        if (conf.dureeBornee)
                        {
                            coeff = conf.getCoeff(rare, coeff, lastRead.DureeEnHeure);
                        }


                        var recup = intervalleMin0 - atterissageMin;

                        var futur = conf.getFutur(rare);

                        if (futur > 0)
                        {
                            DateTime fin = lastRead.Pub.AddDays(futur);
                            if (fin > DateTime.Now)
                                fin = DateTime.Now;
                            int nbFutur = 0;
                            for (int i = indexLastRead + 1; i < count; i++)
                            {
                                if (list[i].Pub <= fin)
                                    nbFutur++;
                                else
                                    break;
                            }

                            double theoric = (fin - lastRead.Pub).TotalDays / intervalleMin0;
                            densite = nbFutur / theoric;
                            if (densite < 1)
                                rapport = rapport * densite;
                        }

                        delta = intervalleMin0 + recup * (1 - rapport) / rapport;

                        var tolerance = conf.getTolerance(rare);
                        if (tolerance > 0)
                        {
                            var ecart0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                            if (ecart0 < tolerance)
                            {
                                delta += (tolerance - ecart0) / conf.getNbTolerance(rare); 
                            }
                        }




                        //0.1 => 10
                        //0.9 => 1.11
                        //coeff -= 1; // 9  0.11
                        //var dminmax = intervalle - intervalleMin;

                        var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                        if (_delta < delta)
                            delta = _delta;
                        else
                        {
                        }

                    }

                    //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


                }



                if (conf.extPente > 0)
                {
                    var d0 = (DateTime.Now - pub2).TotalDays;
                    var dl = conf.extDelta;
                    if (dl == 0)
                    {
                        dl = d0;
                    }

                    delta0 = d0 / conf.extPente;
                    delta = delta0;
                    //01/01/2014 ->01/01/2017
                    //04/01/2017 -> 04/01/2014
                    var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                    var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                    log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                    if (deltaLimiteEcoule > delta)
                    {
                        double _coeff = deltaLimiteEcoule / delta;
                        delta = borne(_coeff, intervalle, intervalleMin);
                    }

                    if (delta < 1)
                        delta = 1;




                    //if (delta > intervalle)
                    //    delta = intervalle;
                }

                if (conf.limitRead && deltaLecture > intervalle)
                {
                    //13 /10 ->7
                    var _old = delta;

                    delta += intervalle - deltaLecture;
                    log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
                }





                if (delta < intervalleMin)
                    delta = intervalleMin;

                if (delta > intervalle)
                    delta = intervalle;



                DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
                TrackSort _next = list[indexLastRead + 1];
                double ecart = (limitFuture - _next.Pub).TotalDays;

                DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * ecart).truncateToMinute();
                //var cumul = (limitFuture - next.Pub).TotalDays;
                //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
                //if (dtaux > limitFutureRab)
                //    limitFutureRab = dtaux; 
                DateTime nextDate = limitFuture;

                int nb = 0;
                int nblissage = 0;
                double deltaAtterrissage = intervalleMin;

                if (conf.noCollision)
                    deltaAtterrissage = delta;
                if (conf.extPente > 0)
                    deltaAtterrissage = delta0;
                string causes = "";

                if (conf.deltaConst || conf.extPente > 0)
                {
                }

                else
                {
                    var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                    var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                    DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                    var sbCause = new StringBuilder();

                    for (int i = indexLastRead + 2; i < count; i++)
                    {
                        var t = list[i];
                        if (conf.useVirtuel)
                        {
                            // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                            dt = dt.AddDays(intervalleMin0);
                        }
                        else
                            dt = t.Pub;


                        nb++;
                        if (dt > limitFuture)
                        {
                            sbCause = new StringBuilder();
                            nextDate = dt;
                            nblissage++;

                            int nbCause = 0;
                            if (dt <= _deltaMin)
                            {
                                sbCause.Append(" deltaMin");
                                nbCause++;
                            }
                            if (dt <= _deltaRab)
                            {
                                sbCause.Append(" deltaRab");
                                nbCause++;
                            }
                            if (nb <= conf.deltaNbMin)
                            {
                                sbCause.Append(" deltaNbMin");
                                nbCause++;
                            }
                            if (nblissage <= conf.deltaNbRab)
                            {
                                sbCause.Append(" deltaNbRab");
                                nbCause++;
                            }
                            if (dt <= limitFutureRab)
                            {
                                sbCause.Append(" coeffRab");
                                nbCause++;
                            }

                            if (nbCause > 0)
                            {
                                causes = sbCause.ToString();
                                continue;
                            }


                            break;


                            //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                            //    break;
                        }

                    }

                    if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                    {
                        deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (deltaAtterrissage > intervalleMin)
                            deltaAtterrissage = intervalleMin;
                    }
                }

                if (deltaAtterrissage < atterissageMin)
                {
                    causes += " corrigé atterrissageMin";
                    deltaAtterrissage = atterissageMin;

                }

                var tsatt = timeSpan.FromDays(deltaAtterrissage);
                if (tsatt.TotalMinute < 1)
                    tsatt = timeSpan.FromMinutes(1);

                string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));
                string stats = string.Format("{0}/{1} {2} {3}",  nbRead, nbTotal, ((double)nbRead / nbTotal).ToString("#.##"), densite.ToString("#.##"));

                var str = string.Format("{0} {1} [{2}] {3} {4} ({5}) lecture={6} causes={7}", deltas,stats, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"), causes);

                if (index0 >= indexCourant)
                    log.log(str);
                else
                    logDebug.log(str);


                //  nb = 0;
                // bool enRetard = limitFuture < date0;
                TrackSort last = lastRead;
                DateTime lastPub2 = limitFuture;
                int indexDepart = indexLastRead + 1;



                for (int i = indexDepart; i < count; i++)
                {
                    var t = list[i];


                    DateTime dt = lastPub2;

                    if (i == indexDepart && !conf.useVirtuel2)
                    {
                        dt = limitFuture;
                    }
                    else
                    {


                        var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                        if (conf.useVirtuel2)
                            dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                        else
                            dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
                        if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1 && t.Pub2 < date1)
                        {
                            var dt2 = dt;
                            if (conf.useVirtuel2)
                                dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                            else
                                dt2 = lastPub2.AddDays(delta).truncateToMinute();
                            //if (dt2 <= date0)
                            dt = dt2;
                            //else
                            //    dt = date0.AddMinutes(1);
                        }


                    }



                    var _delta = (dt - lastRead.Pub2).TotalDays;
                    if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    {

                        eraseSort(t);
                    }
                    else
                    {
                        if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                        {
                            var __delta = (dt - t.Pub).TotalDays;
                            if (__delta > cumulMin)
                            {
                                __delta = borneCumul(__delta, cumulMin, cumulMax);
                                dt = t.Pub.AddDays(__delta).truncateToMinute();
                            }
                        }


                        if (dt > DateTime.Now)
                        {
                        }

                        if ((dt - t.Pub).TotalDays > 100)
                        {
                        }

                        writeComment(t, dt);
                        //nb++;
                    }


                    last = t;
                    lastPub2 = dt;
                    index0 = i;

                    if (t.Played)
                    {
                        break;
                    }
                }
            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }


        public void Build()
        {
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            //if (conf.enabled == sortMode.histo)
            //{
            //    buildAll();
            //    return;
            //}
            //else
            //{
            //checkSelected = true;
            //apply = true;
            date0 = Conf.Date0;
            if (conf.deltaConstLate >= 0)
                date1 = date0.AddDays(conf.deltaConstLate);
            newDate0 = Conf.NewDate0;
            if (conf.extPente > 0 || conf.oldMode)
                build0();
            else
                build();
            return;
            //  }

            #region old
            /* if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true, true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, true);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, true, true, Conf.Date0, Conf.NewDate0);
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            */
            #endregion


        }



        private void eraseSort(TrackSort track)
        {
            writeComment(track, track.Pub);
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (!checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = track.Pub;
            //    return;
            //}

            ////if (!force && !track.Selected)
            ////    return;
            //if (conf.canGoBack || conf.enabled == sortMode.reset)
            //{
            //    if (!track.Played && track.Enabled)
            //    {
            //        DateTime pub = track.Pub;
            //        if (track.Pub2 >= date0 && pub <date0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //        else if (track.Pub2 >=newDate0 && pub < newDate0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //    }

            //    //}
            //    //else
            //    //{
            //    if (track.Pub2 != track.Pub)
            //        nbModif++;
            //    track.Pub2 = track.Pub;
            //    //}
            //    track.track.BuildComment();
            //    // writeComment(track);
            //}
        }

        //private void applyPub(TrackSort track)
        //{
        //    writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);
        //}

        private void writeComment(TrackSort track, DateTime dt)
        {
            dt = dt.truncateToMinute();
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = dt;
            //    return;
            //}



            //if (checkSelected && !track.Selected)
            //    return;


            if (conf.canGoBack)
            {
                if (!track.Played && track.Enabled)
                {
                    if (track.pub20 >= date0 && dt < date0)
                    {
                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            repeches.Add(track);
                        }
                        if (dt < dateRepeche)
                            dateRepeche = dt;
                    }

                    else if (track.pub20 >= newDate0 && dt < newDate0)
                    {

                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.pub20, dt, newDate0);
                            repeches.Add(track);
                        }

                        if (dt < dateRepeche)
                            dateRepeche = dt;

                    }
                }
            }
            else
            {
                if (dt == track.pub20)
                {
                    logDebug.log("\t{0}\t{1} {2}", track.Pub, dt, track.Name);
                    return;
                }
                else if (dt < track.pub20)
                {
                    logDebug.log("\t{0}\t{1}<=\t{2} {3}", track.Pub, track.pub20, dt, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var strDelta = delta.ToString("0.0");

            if (track.pub20 != dt)
            {

                if (track.pub20.truncateToMinute() != dt)
                {
                    //if (track.track.Selected)
                    //{
                    nbModif++;

                    var str = string.Format("\t{0}\t{1}=>\t{2}({3}) {4}", track.Pub, track.pub20, dt, strDelta, track.Name);
                    if (track.track.Selected)
                        log.log(str);
                    else
                        logDebug.log(str);
                    //}
                }
                track.Pub2 = dt;
            }
            else if (track.pub20 > track.Pub)
            {
                // if (track.track.Selected)
                var str = string.Format("\t{0}\t{1}({2}) {3}", track.Pub, track.pub20, strDelta, track.Name);
                if (track.track.Selected)
                    log.log(str);
                else
                    logDebug.log(str);
            }
            else
            {
                var str = string.Format("\t{0} ({1}) {2}", track.Pub, strDelta, track.Name);
                logDebug.log(str);
            }


            track.track.BuildComment();
        }

        private static double borne(double coeff, double intervalle, double intervalleMin)
        {
            if (coeff <= 1)
                return coeff * intervalleMin;
            coeff -= 1; // 9  0.11
            var dminmax = intervalle - intervalleMin;

            var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

            return _delta;
        }

        private static double borneCumul(double delta, double cumulMin, double cumulMax)
        {
            if (cumulMin < 0 || cumulMax < 0)
                return delta;
            if (delta < cumulMin)
                return delta;
            var coeff = delta / cumulMin;
            return borne(coeff, cumulMax, cumulMin);
        }
    }
}]]></content>
  </file>
</db>
