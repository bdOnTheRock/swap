<db path="C:\bernard\db1\db4">

  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.obj;
using pdb.gen.albums;
using System.Linq;
using System.Linq.Expressions;
using System.Windows.Input;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static Logger logPerf = Logger.getLogger("Perf");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public static DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Normal;

        public static void setDispatcherPriority()
        {
            var str = CConf.DispatcherPriority;
            if (!string.IsNullOrEmpty(str))
            {
                DISPATCHER_PRIORITY = (DispatcherPriority)Enum.Parse(typeof(DispatcherPriority), str);
            }
        }

        private class UIItem
        {
            public readonly Action action;
            public readonly IClient client;
            public UIItem(Action action, IClient client)
            {
                this.action = action;
                this.client = client;
            }
        }

        private pdb.util.Queue<UIItem> uiItems = new util.Queue<UIItem>();
        // private DispatcherTimer uiTimer;


        static ILogger logDispatch;
        public static void Dispatch(Action action, IClient client)
        {
            Instance.dispatch(action, client);
        }
        public void dispatch(Action action, IClient client)
        {
            if (!client.HasLog)
                client.Log = logDispatch;
            //if (uiTimer == null)
            //{

            //    lock (_lock)
            //    {
            //        if (uiTimer == null)
            //        {
            //            uiTimer = new DispatcherTimer();

            //        }
            //    }
            //}

            if (!CheckAccess())
            {
                client.log("async");
                client.isAsync = true;
                Dispatcher.BeginInvoke(action, DISPATCHER_PRIORITY);
            }
            else
            {
                Dispatcher.BeginInvoke(action, DISPATCHER_PRIORITY);
                //action();
            }
        }

        //public void dispatchLessPrior(Action action, IClient client)
        //{
        //    Dispatcher.BeginInvoke(action, DispatcherPriority.ApplicationIdle);
        //}



        private void syncAction(Action action, IClient client)
        {
            client.log("debut Effectif");
            action();
            client.log("fin");
        }

        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            var xmlConf = CConf.loadConf();
            setDispatcherPriority();
            pdb.player.ViewModel.Colors.MementoColor.recover();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private string lastMessage;
        private void CheckException(string from, object sender, object ex)
        {
            if (ex is Exception)
            {
                var mess = (ex as Exception).Message;
                if (mess == lastMessage)
                {
                    displayMsg = true;
                }
                lastMessage = mess;

            }
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        private static bool changing;
        public static void setChanging() { changing = true; }
        public static void releaseChanging() { changing = false; }
        public static void invalidateAlbums()
        {
            if (gen == null)
                return;

            gen.invalidateAlbums();
            if (changing)
                return;
            go();
        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                var xmlConf = CConf.loadConf();
                setDispatcherPriority();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                logDispatch = Logger.getLogger("Dispatch");
                misc.init(log);



                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");



                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                gen.FilterNext = CConf.ConfGen.FilterNext;
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0);
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                //  Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }

        private static void resetOneCl()
        {
            lock (_lock)
            {
                try
                {
                    var conf = CConf.ZeroWorkConf;
                    if (conf.enabled)
                    {

                        // CPieceClassement.DateMin = DateTime.MinValue;
                        //   Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                        var oldKepp = new List<Piece>();

                        var _albums = gen.Albums;
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            foreach (Piece t in l)
                            {
                                if (t.Keep)
                                {
                                    t.setKeep(0); //t.Keep = false;
                                    oldKepp.Add(t);
                                    //t.resetMedianneCompact();
                                    //t.invalidateCache(true); 
                                }
                            }
                        }
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            Classement pluspetitNonNull = null;
                            Piece min = null;
                            Piece firstZero = null;
                            int nbnotes = 0;
                            int nbRecent = 0;
                            if (album.Name == "Maxime Le Forestier")
                            {

                            }
                            //foreach (Piece t in l)
                            //{
                            //    var cl = t.DeepClassement; // p.Classement.DbValue;
                            //    // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                            //    if (cl.isPositive())// > zer0d)
                            //    {
                            //        nbnotes++;
                            //        if (t.LastClassementRecent || !t.Enabled)
                            //        {
                            //            if (!conf.alwaysKeep)
                            //            {
                            //                min = null;
                            //                break;
                            //            }

                            //            nbRecent++;
                            //            continue;
                            //        }
                            //        if (pluspetitNonNull == null || cl < pluspetitNonNull)
                            //        {
                            //            pluspetitNonNull = cl;
                            //            min = t;
                            //        }
                            //    }
                            //    else
                            //    {
                            //        if (conf.keep2Enabled)
                            //        {
                            //            if (t.Enabled && !t.LastClassementRecent)
                            //            {
                            //                if (firstZero == null)
                            //                {
                            //                    if (min == null || conf.alwaysKeep2)
                            //                    {
                            //                        firstZero = t;
                            //                    }
                            //                }
                            //            }
                            //        }
                            //    }
                            //}


                            foreach (Piece t in l)
                            {
                                var cl = t.DeepClassement; // p.Classement.DbValue;
                                                           // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);

                                bool isNote = cl.isPositive();
                                bool isRecent = t.LastClassementRecent || !t.Enabled;
                                if (isRecent)
                                    nbRecent++;
                                if (isNote)
                                    nbnotes++;
                                if (isNote)
                                {
                                    if (isRecent)
                                    {
                                        if (!conf.alwaysKeep)
                                        {
                                            min = null;
                                            break;
                                        }
                                        continue;
                                    }
                                    if (pluspetitNonNull == null || cl < pluspetitNonNull)
                                    {
                                        pluspetitNonNull = cl;
                                        min = t;
                                    }
                                }
                                else
                                {
                                    if (conf.keep2Enabled)
                                    {
                                        if (!isRecent)
                                        {
                                            if (firstZero == null)
                                            {
                                                if (min == null || conf.alwaysKeep2)
                                                {
                                                    firstZero = t;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            decimal coeff1 = -1;
                            decimal coeff2 = -1;

                            if (min != null)
                            {
                                if (coeff1 < 0)
                                    coeff1 = ((decimal)nbRecent + 1) / (l.Count + 1);
                                if (coeff2 < 0)
                                    coeff2 = (decimal)nbnotes / l.Count;
                                var coeff = coeff1 * coeff2;
                                min.setKeep(coeff);
                            }
                            if (firstZero != null)
                            {
                                if (nbnotes == 0)
                                    nbnotes++;
                                try
                                {
                                    if (coeff2 < 0)
                                        coeff2 = (decimal)nbnotes / l.Count;

                                    firstZero.setKeep(-coeff2);
                                }
                                catch (Exception ex)
                                {
                                    misc.log(ex);
                                }
                            }



                        }

                        foreach (Piece t in oldKepp)
                        {

                            if (!t.Keep)
                            {
                                t.resetMedianneCompact();
                                t.invalidateCache(true);
                            }
                        }


                    }
                }
                finally
                {
                    //  CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                }
            }
        }



        private static void goInit()
        {
            var client = new SimpleClient("goInit\t", logPerf);
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;



            gen.ConsolidInit(Db.List.getList());
            client.log(" gen.ConsolidInit(Db.List.getList());");
            if (CConf.ZeroWorkConf.enabled)
            {

                resetOneCl();
                client.log("resetOneCl");
                //CPieceClassement.DateMin = DateTime.MinValue;
                ////Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                //Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                ////foreach (Piece p in gen.sortByClass())
                ////{
                ////    decimal clValue = p.ClassementValueDecimal(false) ;
                ////    if (clValue > zer0d)
                ////    {
                ////        if (clValue >= zer0d)
                ////        {
                ////            var dPiece = Db.getPiece(p.PieceId);
                ////            var strNewCl = "0000" + dPiece.getClassement().ToString();
                ////            var newCl = Classement.create(strNewCl);
                ////            p.Enabled = true;

                ////            p.setClassement(newCl.ClassList, newCl.Rating);
                ////            dPiece.Classement.eraseClassement2(newCl);
                ////        }
                ////        else
                ////            p.Enabled = false;
                ////    }
                ////}

                //var _albums = gen.Albums;
                //foreach (var album in _albums.List)
                //{
                //    var l = album.Tracks;
                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in l)
                //    {
                //        decimal clValue = t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        (min.Track as CPiece).Classement.keepValue();
                //    }
                //}
                ////    foreach (Piece t in l)
                ////    {
                ////        if (t.Parent == null)
                ////        {
                ////            decimal clValue = t.ClassementValueDecimal(false);
                ////            if (t.isClassListNumeric && clValue > zer0d)
                ////            {
                ////                if (clValue > pluspetitNonNull)
                ////                {
                ////                    var dPiece = Db.getPiece(t.PieceId);
                ////                    t.Enabled = true;
                ////                    t.setClassement("0", 0);
                ////                    dPiece.Classement.eraseClassement2();
                ////                }
                ////            }
                ////        }
                ////    }
                ////}

                ////gen.MakeConsolid(Db.List.getList(), true);
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
            }

            gen.MakeConsolid(null, true, true, client);
            //  if (CConf.ConfGen.LimitList <= 0)
            gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            client.log("creation bib");
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, client, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
            client.log("Fin goInit");
        }

        private static bool mustBuildCompleteAlbums(TrackListViewModel currentTrack)
        {
            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.RankAlbumReverse.CompareTo(y.RankAlbumReverse));
            int count = tracks.Count;
            int rank0 = currentTrack.RankAlbumReverse;

            int i = 0;
            // recherche trou avant ex rank0=3 pas de 1 ni de 2
            for (; i < count; i++)
            {
                var t = tracks[i];
                if (t.RankAlbumReverse >= rank0)
                    break;

                if (t.RankAlbumReverse > i + 1)
                    return true;
            }

            //if (i + 1 < count && tracks[i + 1].RankAlbumReverse > rank0 + 1)
            //{
            //    return true;
            //}

            return false;
        }

        private static void buildAffectedAlbumsWhenCurrentTrackChange(TrackListViewModel currentTrack, IDictionary<string, Album> dict, HashSet<Album> depot, bool navQuick)
        {
            if (currentTrack == null)
                return;
            TrackListViewModel item = currentTrack;
            var cl = item.PieceGen.getClassement(true);
            var _dict = dict;  // new Dictionary<string,Album>(); 

            //foreach (Album album in dict.Values)
            //{
            //    var current = album.PlusPetitEnabled; 
            //    if (current == null || cl<=current.getClassement(true))
            //        _dict.Add(album.Key, album); 
            //}

            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
            int count = tracks.Count;

            //int index = -1;
            //for (int i = 0; i < count; i++)
            //{
            //    var t = tracks[i];
            //    if (t.PieceId == currentTrack.PieceId)
            //    {
            //        index = i;
            //        break;
            //    }
            //}

            //if (index < 0)
            //{
            //    foreach (Album a in dict.Values)
            //        depot.Add(a);
            //    return;
            //}

            var hs = new HashSet<int>();
            if (navQuick)
                hs.Add(item.MasterId);
            int index = -1;
            try
            {
                while (true)
                {
                    index++;
                    if (index >= count)
                        return;

                    var t = tracks[index];
                    if (!hs.Add(t.MasterId))
                        continue;
                    if (navQuick && t.album == item.album)
                        continue;
                    //if (t.album == item.album)
                    //    continue;

                    if (_dict.ContainsKey(t.album.Key))
                    {
                        depot.Add(t.album);
                        if (depot.Count >= _dict.Count)
                            return;
                    }
                    else
                        break;

                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
            finally
            {

            }
        }

        private void automateNextTrack()
        {
            var client = new SimpleClient("automateNextTrack\t");
            this.dispatch(
                () =>
                {
                    PlayerViewModel.Instance.goToFirst();
                    App.go();
                }, client);
            //if (!CheckAccess())
            //    Dispatcher.BeginInvoke(new Action(this.automateNextTrack), App.DISPATCHER_PRIORITY);
            //else
            //{
            //    PlayerViewModel.Instance.forwardAuto();
            //    App.go();
            //}
        }

        static int nbGo = 0;
        static bool classementChange;
        private static SimpleClient client;
        public static bool Indispo { get; set; }
        private static void _go()
        {
            gen.Albums.endParallelSort();
            bool classementChange = App.classementChange;
            var _currentTrack = App._currentTrack;
            nbGo++;
            bool urgence = false;
            if (client != null)
            {
                client.log("FIN new step");
                client.cancel();
            }

            client = new SimpleClient("<--- chrono " + nbGo + "\t", logPerf);
            var clientArgs = new ClientEventArgs(client);

            try
            {

                bool reInit = !gen.AlbumBuild;
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                //   gen.compact(); 
                if (detailClassementViewModel != null)
                    detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;

                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;

                urgence = gen.Urgence && TrackListViewModel.CurrentPlaying == _currentTrack;
                if (!urgence)
                {
                    Db.saveAsync();
                    Memento.Instance.save();
                }
                client.log(string.Format("debut classementChange={0} gen.ClassementChanged={1} gen.Urgence={2} _currentTrack={3}", classementChange, gen.ClassementChanged, gen.Urgence, _currentTrack));
                if (PlayerViewModel.Instance.CreateRot)
                {
                    if (urgence)
                        PlayerViewModel.Instance.modeFirst();
                    if (gen.ClassementChanged)
                    {
                        classementChange = true;
                        App.classementChange = true;
                    }

                    if (!urgence && classementChange)
                    {
                        resetOneCl();
                        client.log("resetOneCl");
                        App.classementChange = false;
                    }

                    if (_currentTrack != null)
                    {
                        int nbAlbums = 0;
                        // bool sortDone = false;
                        if (urgence)
                        {
                            var affectedAlbums = gen.Albums.GetAndInvalidateAlbums(_currentTrack.PieceGen);
                            bool mustComplete = mustBuildCompleteAlbums(_currentTrack);

                            if (!mustComplete)
                            {

                                //}

                                var depot = new HashSet<Album>();
                                buildAffectedAlbumsWhenCurrentTrackChange(_currentTrack, affectedAlbums, depot, CConf.ConfGen.NavQuick);
                                if (depot.Count == 0)
                                {
                                    if (_currentTrack == TrackListViewModel.CurrentPlaying)
                                    {
                                        log.log("pas de makeSort. on passe au suivant on verra après");
                                        _currentTrack = null;
                                        gen.Urgence = false;

                                        App.Instance.automateNextTrack();
                                        return;

                                    }
                                    else
                                    {
                                        log.log("trop naze c'est trop long");
                                        gen.Urgence = false;

                                    }


                                }
                                //}
                                //}
                                else
                                {
                                    log.log("depot:");
                                    nbAlbums = gen.Albums.makeSort(depot, log);
                                    //sortDone = true;
                                }

                            }
                            else
                            {
                                log.log("y a des trous dans la raquette on force le makesort");
                                gen.Urgence = false;
                            }
                            //if (!sortDone && gen.Urgence)
                            //{
                            //    log.log("affected albums");
                            //    nbAlbums = gen.Albums.makeSort(_currentTrack.PieceGen, log);
                            //}
                            client.log(string.Format("makeSort partial {0} elt", nbAlbums));
                            _currentTrack.refresh();
                            while (Indispo)
                                Thread.Sleep(100);
                            if (nbAlbums > 0)
                            {
                                if (refreshAlbum != null)
                                    refreshAlbum("", clientArgs);
                                client.log("refreshAlbum");
                            }
                        }
                    }

                    _currentTrack = null;


                    // if (__end || __go) return;


                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 

                    while (Indispo)
                        Thread.Sleep(100);
                    gen.MakeConsolid(null, _updateStats, classementChange, client); //   bib.Musique.Tracks);
                    if (reInit)
                        gen.buildMusiqueAgain();
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                        setDispatcherPriority();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    while (Indispo)
                        Thread.Sleep(100);
                    gen.createRot(CConf.ListBase, client, App.bib);
                    if (reInit)
                        bib.syncMusique();
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();

                    while (Indispo)
                        Thread.Sleep(100);
                    if (refresh != null)
                        refresh(PHASE2, clientArgs);
                    client.log("refresh après createRot");


                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats && !urgence)
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => { if (detailClassementViewModel != null) detailClassementViewModel.IhmInDispo = ihmInDispo.none; });

                        }
                        else
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                        }
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    _currentTrack = null;
#if EXPORT
                    ExportCmd.CalculExport();
#endif
                    if (_updateStats && !urgence)
                    {
                        _updateStats = false;
                    }
                }
                client.log("FIN _go()");
                if (urgence && !DetailClassementViewModel.Instance.Auto)
                    go(false);

                if (classementChange && !urgence)
                    gen.Albums.parallelSort();

                if (!urgence && TrackListViewModel.HumanSelectedIsBusy)
                {
                    if (refreshArtWork != null)
                        refreshArtWork.BeginInvoke("toto", clientArgs, null, null);
                }


            }


        }

        public static event EventHandler<ClientEventArgs> refresh;
        public static event EventHandler<ClientEventArgs> refreshAlbum;
        public static event EventHandler<ClientEventArgs> refreshArtWork;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                return null;
                case MessageBoxResult.No:
                return false;
                case MessageBoxResult.None:
                return null;
                case MessageBoxResult.OK:
                return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\pdb.player.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{4166FA60-B33F-4496-9352-EDD8F3214021}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.player</RootNamespace>
    <AssemblyName>pdb.player</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;NONI</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;COMPACT</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>pdb.player.App</StartupObject>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG;COMPACT</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="policy.2.0.taglib-sharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=db62eba44689b5b0, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\policy.2.0.taglib-sharp.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Runtime.Serialization" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="taglib-sharp, Version=2.1.0.0, Culture=neutral, PublicKeyToken=db62eba44689b5b0, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>bin\taglib-sharp.dll</HintPath>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="Xceed.Wpf.Toolkit">
      <HintPath>libs\Extended WPF Toolkit Binaries\Xceed.Wpf.Toolkit.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="model\ArtWorkManager.cs" />
    <Compile Include="model\Equalization.cs" />
    <Compile Include="ViewModel\AllTracksViewModel.cs" />
    <Compile Include="ViewModel\BibViewModel.cs" />
    <Compile Include="ViewModel\BibViewModelBase.cs" />
    <Compile Include="ViewModel\BibViewModelTree.cs" />
    <Compile Include="ViewModel\Colors\ColorViewModel.cs" />
    <Compile Include="ViewModel\Colors\Couleurs.cs" />
    <Compile Include="ViewModel\Colors\MementoColor.cs" />
    <Compile Include="ViewModel\Commande\CommandeBase.cs" />
    <Compile Include="ViewModel\Commande\CoulHistoryBack.cs" />
    <Compile Include="ViewModel\Commande\CreateListCmd.cs" />
    <Compile Include="ViewModel\Commande\DeleteCmd.cs" />
    <Compile Include="ViewModel\Commande\Explorer.cs" />
    <Compile Include="ViewModel\Commande\ImportCmd.cs" />
    <Compile Include="ViewModel\Commande\InfoCmd.cs" />
    <Compile Include="ViewModel\Commande\Link\LinkRegister.cs" />
    <Compile Include="ViewModel\Commande\Link\RecordFather.cs" />
    <Compile Include="ViewModel\Commande\Play.cs" />
    <Compile Include="ViewModel\Commande\PlayList\AddToList.cs" />
    <Compile Include="ViewModel\Commande\PlayList\CheckCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastClassement.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastRead.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCompress.cs" />
    <Compile Include="ViewModel\Commande\PlayList\PlayListCommande.cs" />
    <Compile Include="ViewModel\Commande\RecordClassement.cs" />
    <Compile Include="ViewModel\Commande\RefreshAlbum.cs" />
    <Compile Include="ViewModel\DetailAlbumViewModel.cs" />
    <Compile Include="ViewModel\DetailClassementViewModel.cs" />
    <Compile Include="ViewModel\ClientEventArgs.cs" />
    <Compile Include="ViewModel\gen\ListWriter.cs" />
    <Compile Include="ViewModel\InfoViewModel.cs" />
    <Compile Include="ViewModel\Interfaces.cs" />
    <Compile Include="ViewModel\PlayerViewModel.cs" />
    <Compile Include="ViewModel\PochetteViewModel.cs" />
    <Compile Include="ViewModel\StatItemViewModel.cs" />
    <Compile Include="ViewModel\TrackListViewModel.cs" />
    <Compile Include="ViewModel\PlayListViewModel.cs" />
    <Compile Include="ViewModel\ViewModelBase.cs" />
    <Compile Include="Vue\Adorn\AdornedControl.cs" />
    <Compile Include="Vue\Adorn\AdornerPlacement.cs" />
    <Compile Include="Vue\Adorn\FrameworkElementAdorner.cs" />
    <Compile Include="Vue\AlbumCtl.xaml.cs">
      <DependentUpon>AlbumCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BarAdorner.cs" />
    <Compile Include="Vue\BibCtl.xaml.cs">
      <DependentUpon>BibCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BrowsePlayList.xaml.cs">
      <DependentUpon>BrowsePlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ClassementCtl.xaml.cs">
      <DependentUpon>ClassementCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfAlbumSortW.xaml.cs">
      <DependentUpon>ConfAlbumSortW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfExport.xaml.cs">
      <DependentUpon>ConfExport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfFilterW.xaml.cs">
      <DependentUpon>ConfFilterW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfImport.xaml.cs">
      <DependentUpon>ConfImport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfMedianneW.xaml.cs">
      <DependentUpon>ConfMedianneW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfVirt.xaml.cs">
      <DependentUpon>ConfVirt.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfCouleurs.xaml.cs">
      <DependentUpon>ConfCouleurs.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\Debug.xaml.cs">
      <DependentUpon>Debug.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\Miscellaneous.xaml.cs">
      <DependentUpon>Miscellaneous.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\DataGridPlayList.xaml.cs">
      <DependentUpon>DataGridPlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\EnhancedDataGrid.cs" />
    <Compile Include="Vue\FolderBrowserDialog.xaml.cs">
      <DependentUpon>FolderBrowserDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialogW.xaml.cs">
      <DependentUpon>FolderBrowserDialogW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\getNb.xaml.cs">
      <DependentUpon>getNb.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Info.xaml.cs">
      <DependentUpon>Info.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Memento.cs" />
    <Compile Include="Vue\PlayerControler.xaml.cs">
      <DependentUpon>PlayerControler.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Pochette.xaml.cs">
      <DependentUpon>Pochette.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StatCtl.xaml.cs">
      <DependentUpon>StatCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StateBar.xaml.cs">
      <DependentUpon>StateBar.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StringDialog.xaml.cs">
      <DependentUpon>StringDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Util\BaseConverter.cs" />
    <Compile Include="Vue\Util\GradiantBuilder.cs" />
    <Compile Include="Vue\Util\StringFormatConverter.cs" />
    <Compile Include="Vue\Util\Utils.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Player.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Player.xaml.cs">
      <DependentUpon>Player.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="Vue\AlbumCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BibCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BrowsePlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ClassementCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfAlbumSortW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfExport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfFilterW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfImport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfMedianneW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfVirt.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfCouleurs.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\Debug.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\Miscellaneous.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\DataGridPlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialogW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\getNb.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Vue\Info.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\PlayerControler.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Pochette.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StatCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StateBar.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StringDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="app.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <AppDesigner Include="Properties\" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\engine\pdb.player.engine.build\pdb.player.engine.build.csproj">
      <Project>{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}</Project>
      <Name>pdb.player.engine.build</Name>
    </ProjectReference>
    <ProjectReference Include="..\engine\pdb.player.engine\pdb.player.engine.csproj">
      <Project>{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}</Project>
      <Name>pdb.player.engine</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823d1d-851c-456b-ac4c-b0beec173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{c2b34ca9-3bb2-464f-8691-5f5b7cb2b997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Consolid\pdb.gen.csproj">
      <Project>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</Project>
      <Name>pdb.gen</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Db\pdb.db.csproj">
      <Project>{43D27B47-E615-451D-AD25-67C5B8447C4A}</Project>
      <Name>pdb.db</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\Toolbar-MP3-Forward-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Pause-icon.png" />
    <Resource Include="Vue\images\Toolbar-MP3-Play-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Rewind-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Stop-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\cbCoche.png" />
    <Resource Include="Vue\images\cbDecoche.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PostBuildEvent>copy $(TargetDir)\*.*  $(TargetDir)\..\..\..\PieceDb3Ref\pdb.player\bin  /Y</PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.player\ViewModel\DetailAlbumViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Input;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.gen.albums;
using System.Text.RegularExpressions;
using pdb.player.ViewModel.Commande.Link;
using pdb.player.ViewModel.Commande;
using pdb.db;
using System.Windows.Media.Imaging;
using System.IO;
using pdb.util;
using System.Windows.Media;
using pdb.player.model;
using System.Collections.ObjectModel;
using pdb.obj;
using System.Threading;
using pdb.gen.conf;

namespace pdb.player.ViewModel
{

    public enum albumMode
    {
        identique,
        origine,
        origineSiVirtuel,
        plusLong,
        plusCourt
    }
    class DetailAlbumViewModel : ViewModelBase, ISelectedTracks
    {
        public static ArtWorkManager artworkManager = new ArtWorkManager();
        private TrackListViewModel humanSelected;
        private Album currentAlbum;
        // private List<TrackListViewModel> tracks;
        private albumMode mode;
        private bool albumVirtual;
        private static Logger log = Logger.getLogger("AlbumViewModel");
        private PlayList pl;
        private PlayListViewModel plv;
        public PlayListViewModel PlayListViewModel { get { return plv; } }


        public albumMode Mode
        {
            get
            {
                return mode;
            }
            set
            {
                if (value != mode)
                {
                    mode = value;
                    var client = new SimpleClient("Mode", log);
                    init(null, client);
                    OnPropertyChanged("");
                }
            }
        }

        public DetailAlbumViewModel()
        {
            TrackListViewModel.CurrentHumanSelectedChanged += new EventHandler<ClientEventArgs>(TrackListViewModel_CurrentSelectedChanged);
            App.refreshArtWork += App_refreshArtWork;
        }

        private void App_refreshArtWork(object sender, ClientEventArgs e)
        {
            initImg(TrackListViewModel.HumanSelected, e.client);
        }




        //  private ObservableCollection<ImageSource> images; 

        private IClient client;
        public void initImg(TrackListViewModel h, IClient client)
        {
            if (this.client != null)
                this.client.cancel();
            if (client == null)
                client = new SimpleClient("DetailAlbum", Logger.defaultLogger);
            this.client = client;
            if (client.Cancel)
                return;

            new Thread(() =>
            {
                var delay = CConf.DisplayImg;
                if (delay > 0)
                {
                    var dt = DateTime.Now.AddMilliseconds(delay);
                    while (DateTime.Now < dt)
                    {
                        if (client.Cancel)
                            return;
                        Thread.Sleep(30);
                    }
                    while (App.Indispo)
                    {
                        if (client.Cancel)
                            return;
                        Thread.Sleep(30);
                    }
                }

                if (client.Cancel)
                    return;
                App.Dispatch(() =>
                {
                    var img = DetailAlbumViewModel.artworkManager.get(h.PieceGen, client);
                    client.log("DetailAlbum::init::artworkManager");
                    if (client.Cancel)
                        return;
                    if (img != this.img)
                    {
                        this.img = img;
                        OnPropertyChanged("ArtWork");
                        client.log("DetailAlbum::init::OnPropertyChanged ArtWork");
                    }

                }, client);
            }).Start();
        }

        public void init(TrackListViewModel h, IClient client)
        {
            App.Dispatch(() =>
            {
                // tracks = null;
                if (client.Cancel)
                    return;
                // img = null;
                //images = new ObservableCollection<ImageSource>() ;
                //  long sizeImgMax = 0;
                // if (humanSelected == null)
                if (h == null)
                    humanSelected = TrackListViewModel.HumanSelected;
                if (humanSelected != null)
                {
                    var p = humanSelected.PieceGen;
                    var idOrg = p.PieceId;

                    switch (mode)
                    {
                        case albumMode.identique:
                        break;
                        case albumMode.origine:
                        p = p.Master;
                        break;
                        case albumMode.origineSiVirtuel:
                        if (p.Virtual)
                            p = p.Master;
                        break;
                        case albumMode.plusLong:
                        if (p.Virtual)
                        {
                            var virt = p.PieceAlbum.Count;
                            var master = p.Master.PieceAlbum.Count;
                            if (master > virt)
                                p = p.Master;
                        }

                        break;

                        case albumMode.plusCourt:
                        if (p.Virtual)
                        {
                            var virt = p.PieceAlbum.Count;
                            var master = p.Master.PieceAlbum.Count;
                            if (master < virt)
                                p = p.Master;
                        }

                        break;


                        default:
                        break;
                    }

                    albumVirtual = idOrg != p.PieceId;

                    if (client.Cancel)
                        return;
                    //App.Dispatch(() =>
                    //    {
                    //        img = artworkManager.get(humanSelected.PieceGen, client);
                    //        client.log("DetailAlbum::init::artworkManager");
                    //        OnPropertyChanged("ArtWork");

                    //    }, client);

                    // client.log("DetailAlbum::init::OnPropertyChanged ArtWork");

                    //if (client.Cancel)
                    //    return;
                    currentAlbum = p.PieceAlbum;
                    initAlbums();

                    client.log("DetailAlbum::init::initAlbums");
                    if (client.Cancel)
                        return;
                    if (!TrackListViewModel.HumanSelectedIsBusy)
                        initImg(TrackListViewModel.HumanSelected, client);

                }
                else
                {
                    // currentAlbum = null;
                    //tracks = new List<TrackListViewModel>();
                }
            }, client);
        }

        //public ObservableCollection<ImageSource> Images
        //{
        //    get
        //    {
        //        return images; 
        //    }
        //}

        void TrackListViewModel_CurrentSelectedChanged(object sender, ClientEventArgs e)
        {
            if (humanSelected != TrackListViewModel.HumanSelected)
            {
                init(null, e.client);
            }
        }
        private class PieceTrackNumberComparer : IComparer<TrackListViewModel>
        {
            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
                if (cmp != 0)
                    return cmp;
                return x.getLocation().CompareTo(y.getLocation());
                //  return x.TrackNumber.CompareTo(y.TrackNumber);
            }
        }
        private class PieceVirtualClassementComparer : IComparer<TrackListViewModel>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                int cmp = x.PieceGen.getClassement(true).CompareTo  (y.PieceGen.getClassement(true));


                if (cmp != 0) return -cmp;
                //cmp = x.RapportClassement.CompareTo(y.RapportClassement);
                //if (cmp != 0) return -cmp;
                return tn.Compare(x, y);
                //  return -x.RapportClassement.CompareTo(y.RapportClassement);
            }
        }

        public List<TrackListViewModel> Album
        {
            get
            {
                if (currentAlbum == null || plv == null)
                    return new List<TrackListViewModel>();
                var tracks = plv.Tracks;
                tracks.Sort(new PieceVirtualClassementComparer());
                //int index = 0;
                //foreach (TrackListViewModel t in tracks)
                //{
                //    index++;
                //    t.Index = index;
                //    if (humanSelected != null && t.MasterId == humanSelected.MasterId)
                //        t.IsSelected = true;
                //    else
                //        t.IsSelected = false; 
                //}
                return tracks;

                //var tracks = new List<TrackListViewModel>(); 
                //foreach (var t in currentAlbum.Tracks)
                //{
                //    TrackListViewModel trackList = TrackListViewModel.get(t.PieceId); 
                //    //index++;
                //    //TrackListViewModel trackList = PlayListViewModel.findTrack(App.bib.Musique, t.PieceId);
                //    //if (trackList == null)
                //    //    continue;
                //    //trackList.Index = index;
                //    //if (t.MasterId == humanSelected.MasterId)
                //    //    trackList.IsSelected = true;
                //    //else
                //    //    trackList.IsSelected = false;
                //    tracks.Add(trackList);
                //}
                // //if (tracks != null)
                // //    return tracks;
                //// tracks = new List<TrackListViewModel>();
                // if (currentAlbum == null)
                // {
                //     //tracks = new List<TrackListViewModel>();
                // }
                // else
                // {
                //     // var ll = new List<TrackListViewModel>();

                //   //  int index = 0;
                //     foreach (var t in currentAlbum.Tracks)
                //     {
                //       //  index++;
                //         TrackListViewModel trackList = TrackListViewModel.getOrCreate(t); // PlayListViewModel.findTrack(App.bib.Musique, t.PieceId);
                //         if (trackList == null)
                //             continue;
                //        // trackList.Index = index;
                //         if (t.PieceId == humanSelected.PieceId)
                //             trackList.IsSelected = true;
                //         else
                //             trackList.IsSelected = false;
                //         tracks.Add(trackList);
                //     }
                // }
                //return tracks;

            }
        }

        public TrackListViewModel SelectedTrackInAlbumView
        {
            get
            {


                //var t = humanSelected;


                //if (!albumVirtual)
                //    return t;
                //if (plv != null && !plv.contains(t.PieceId))
                //{
                //    t = plv.Tracks.Find(tt => tt.MasterId == humanSelected.MasterId);
                //    if (t != null)
                //        return t;
                //}
                return humanSelected;

                //if (humanSelected == null)
                //    return null;
                //var tracks = Album;
                //if (tracks == null || tracks.Count == 0)
                //    return null;
                //var tt = tracks.Find(t => t.MasterId == humanSelected.MasterId);
                //return tt;
            }
            set
            {
                if (value == null)
                    return;
                if (humanSelected != null)
                    humanSelected.IsSelected = false;
                humanSelected = value;
                if (humanSelected != null)
                    humanSelected.IsSelected = true;
                // TrackListViewModel.setHumanSelected(App.bib.Musique, value);
                //  initAlbums(); 
                // TrackListViewModel.HumanSelected = humanSelected; 
                var client = new SimpleClient("SelectedTrackInAlbumView", log);
                init(humanSelected, client);
                OnPropertyChanged("");
            }
        }


        #region cmd

        private ICommand _contextCmdCheck;
        public ICommand ContextCmdCheck { get { if (_contextCmdCheck == null) _contextCmdCheck = new CheckCmd(this); return _contextCmdCheck; } }

        private ICommand _contextCmdUnCheck;
        public ICommand ContextCmdUnCheck { get { if (_contextCmdUnCheck == null) _contextCmdUnCheck = new UnCheckCmd(this); return _contextCmdUnCheck; } }


        private ICommand _contextLinkFather;
        public ICommand LinkFather { get { if (_contextLinkFather == null) _contextLinkFather = new LinkFather(); return _contextLinkFather; } }

        private ICommand _contextLinkChild;
        public ICommand LinkChild { get { if (_contextLinkChild == null) _contextLinkChild = new LinkChild(); return _contextLinkChild; } }

        private ICommand _contextLinkFusion;
        public ICommand LinkFusion { get { if (_contextLinkFusion == null) _contextLinkFusion = new LinkFusion(); return _contextLinkFusion; } }

        private ICommand _contextUnLink;
        public ICommand LinkReset { get { if (_contextUnLink == null) _contextUnLink = new LinkReset(); return _contextUnLink; } }

        private ICommand _contextDelete;
        public ICommand DeleteTrack { get { if (_contextDelete == null) _contextDelete = new DeleteCmd(); return _contextDelete; } }

        private ICommand _contexExplorer;
        public ICommand Explorer { get { if (_contexExplorer == null) _contexExplorer = new Explorer(); return _contexExplorer; } }

        private ICommand _contextInfo;
        public ICommand Info { get { if (_contextInfo == null) _contextInfo = new InfoCmd(); return _contextInfo; } }



        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(this, App.Instance); return _ContextCmdAddToList; } }

        private ICommand _ContextCmdDbDeleteClassement;
        public ICommand ContextCmdDbDeleteClassement { get { if (_ContextCmdDbDeleteClassement == null) _ContextCmdDbDeleteClassement = new DbDeleteLastClassement(this); return _ContextCmdDbDeleteClassement; } }

        private ICommand _ContextCmdDbDeleteRead;
        public ICommand ContextCmdDbDeleteRead { get { if (_ContextCmdDbDeleteRead == null) _ContextCmdDbDeleteRead = new DbDeleteLastRead(this); return _ContextCmdDbDeleteRead; } }


        #endregion

        //  static Regex reg = new Regex(@"\[(.*)\]");
        /// <summary>
        /// moche mais pour l'instant on s'en contente
        /// </summary>
        public string Grouping
        {
            get
            {
                return getGrouping(false);
            }
        }

        private string getGrouping(bool albumVirt)
        {
            if (humanSelected == null)
                return "";
            var t = humanSelected.PieceGen;
            if (albumVirt)
                t = humanSelected.PieceGen.Master;

            var a = t.PieceAlbum;
            if (a == null)
                return "";
            string delta = "-";
            var updateClassement = a.UpdateClassement;
            if (updateClassement != null)
                delta = ((int)(DateTime.Now.Date - updateClassement.Value.Date).TotalDays).ToString();

            return string.Format("{0} {1} [{2}] {3}", t.StackIndex, delta, t.RankAlbumReverse, a.EquivLight);

            //var str = t.Grouping;

            //if (!reg.IsMatch(str))
            //    return str;

            //return reg.Match(str).Groups[1].Value;
        }

        public string GroupingAlt
        {
            get
            {
                return getGrouping(true);
            }
        }

        public bool WithVirtualAlbum
        {
            get
            {
                if (humanSelected == null)
                    return false;
                return humanSelected.PieceGen.PieceAlbum.Virtual;
            }
        }

        public string Name
        {
            get
            {
                if (humanSelected == null)
                    return "";
                return humanSelected.Album;
            }
        }

        public string NameAlt
        {
            get
            {
                if (humanSelected == null)
                    return "";
                return humanSelected.Piece.Master.Album;
            }
        }

        #region image
        private ImageSource img;
        public bool HasArtWork
        {
            get
            {
                return img != null;
            }
        }

        public ImageSource ArtWork
        {
            get { return img; }
        }

        #region albums
        public List<TrackListViewModel> Albums { get { return albums; } }
        private List<TrackListViewModel> albums = new List<TrackListViewModel>();
        private void initAlbums()
        {
            if (currentAlbum == null)
                return;

            var _albumName = currentAlbum.Name;
            //if (pl == null || _albumName != pl.Name)
            //{
            pl = new PlayList(_albumName);
            plv = new PlayListViewModel(pl);
            //  plv.setSecondary(); 
            foreach (var t in currentAlbum.Tracks)
            {
                pl.add(t);
            }
            plv.init();
            foreach (TrackListViewModel t in plv.Tracks)
            {
                if (t.PieceId == humanSelected.PieceId)
                    t.IsSelected = true;
                else
                    t.IsSelected = false;
            }
            if (humanSelected == null)
                return;

            albums = new List<TrackListViewModel>();


            foreach (var p in humanSelected.PieceGen.Master)
            {
                var pp = TrackListViewModel.getOrCreate(p); // pl.FindTrack(p.PieceId);
                if (pp != null)
                    albums.Add(pp);
            }
            albums.Sort(new AlbumComparer());

            //foreach (TrackListViewModel t in albums)
            //{
            //    t.IsSelected = t.PieceId == humanSelected.PieceId;
            //}
            //  return albums;
            //TrackListViewModel trackList = TrackListViewModel.getOrCreate(t); // PlayListViewModel.findTrack(App.bib.Musique, t.PieceId);
            //if (trackList == null)
            //    continue;
            //// trackList.Index = index;
            //if (t.PieceId == humanSelected.PieceId)
            //    trackList.IsSelected = true;
            //else
            //    trackList.IsSelected = false;
            //tracks.Add(trackList);
            // }


            //var albums = new List<TrackListViewModel>();
            //if (humanSelected == null)
            //    return albums;
            //var pl_ = PlayListViewModel.SelectedPlayList;
            //if (pl_ == null)
            //    return albums;
            //foreach (var p in humanSelected.PieceGen.Master)
            //{
            //    var pp = TrackListViewModel.getOrCreate(p); // pl.FindTrack(p.PieceId);
            //    if (pp != null)
            //        albums.Add(pp);
            //}
            //albums.Sort(new AlbumComparer());

            //foreach (TrackListViewModel t in albums)
            //{
            //    t.IsSelected = t.PieceId == humanSelected.PieceId;
            //}
            //return albums;


        }



        public TrackListViewModel SelectedTrackInAlbumsView
        {
            get
            {
                return humanSelected;

            }
            set
            {
                if (value == null)
                    return;
                if (humanSelected != null)
                    humanSelected.IsSelected = false;
                humanSelected = value;
                if (humanSelected != null)
                    humanSelected.IsSelected = true;
                //if (humanSelected != null)
                //    humanSelected.IsSelected = true;
                // TrackListViewModel.setHumanSelected(App.bib.Musique, value); // HumanSelected = value;
                var client = new SimpleClient("SelectedTrackInAlbumsView", log);
                init(humanSelected, client);
                OnPropertyChanged("");

            }
        }


        private class AlbumComparer : IComparer<TrackListViewModel>
        {
            //private int theOne; 
            //public AlbumComparer(TrackListViewModel humanselected)
            //{
            //    theOne = humanselected.PieceId; 
            //}

            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {

                //if (x.PieceId == theOne)
                //    return -1;
                //if (y.PieceId == theOne)
                //    return 1;
                return x.RankAlbumReverse.CompareTo(y.RankAlbumReverse);
            }
        }
        #endregion
        #endregion


        public List<TrackListViewModel> SelectedTracks
        {
            get { return Album; }
        }
    }
}

]]></content>
  </file>
  <file path="\pdb.util\CustomFormat.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

namespace pdb.util
{
    public static class CustomFormat
    {
        const char infini = '\u221E';
        private static CultureInfo cu = new CultureInfo("en-US");
        //4.9E+02
        private static Regex reg = new Regex(@"([0-9\.]+)E\+([0-9]+)");

        const string FORMAT = "0.### ### ### ### ### ### ### ### ### ### ### ### ###";

        public static string FormatE(this decimal value, int precision)
        {
            precision = precision - 1;
            var borne = Convert.ToDecimal(System.Math.Pow(10, precision));
            var sb = new StringBuilder();
            if (value == 0)
                return "0";
            bool neg = value < 0;
            if (neg)
            {
                value = -value;               
            }

          
            if (value > borne || value < 1 / borne)
            {

                sb.Append("0.");
                for (int i = 0; i < precision; i++)
                    sb.Append("#");
                sb.Append("e+0");

            }
            else
            {
                sb.Append("g");
                sb.Append(precision + 1);

            }
            var format = sb.ToString();
            var ret = value.ToString(format, cu);
            if (neg)
                ret ="-" + ret; 
            return ret;
        }

        public static string Format(this decimal value, int required, int desired, int limit)
        {
            return Format(value, null, required, desired, limit);
        }
        public static string Format(this decimal value, string format, int required, int desired, int limit)
        {
            if (string.IsNullOrEmpty(format))
                format = FORMAT;
            string ret = value.ToString(FORMAT, cu);

            var sb = new StringBuilder();
            var tab = ret.ToCharArray(); int count = tab.GetLength(0);
            sb.Append(tab[0]);
            bool foundPertinent = false, foundDec = false;
            int nb = 0, _nbpertinent = 0;
            for (int i = 1; i < count; i++)
            {
                var c = tab[i];
                sb.Append(c);
                if (c == '.' || c == ',')
                {
                    foundDec = true;
                    continue;
                }
                if (c == ' ')
                    continue;
                nb++;
                if (c != '0')
                {
                    if (!foundPertinent)
                    {
                        foundPertinent = true;
                    }
                    _nbpertinent++;
                }
                else
                {
                    if (foundPertinent)
                        _nbpertinent++;
                }
                if (foundDec)
                {
                    if (nb >= limit)
                        break;
                    if (_nbpertinent >= required && nb >= desired)
                        break;
                }


            }

            ret = sb.ToString().Trim().Replace(" ", ",");
            return ret;
        }

        public static string FormatCustom(this decimal value, int nb)
        {
            return value.FormatCustom(nb, nb, nb);
        }

        public static string FormatCustom(this double value, int nb)
        {
            return value.FormatCustom(nb, nb, nb);
        }



        public static string FormatCustom(this double value, int nb, int nbMax)
        {
            return value.FormatCustom(nb, nb, nbMax);
        }

        public static string FormatCustom(this decimal value, int nb, int nbMax)
        {
            return value.FormatCustom(nb, nb, nbMax);
        }
        public static string FormatCustom(this double value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(double.MinValue))
                return "-" + infini;
            if (value.Equals(double.MaxValue))
                return infini.ToString();

            if (nbMin < nb)
            {
                if (Math.Abs(value) < Math.PowD(10, nbMin - 1))
                {
                    return FormatCustom(value, nbMin, nbMin, nbMax);
                }
            }

            string ret = value.ToString("G" + nb, cu);
            if (ret.StartsWith("0."))
            {
                ret = ret.Remove(0, 1);
                return ret;
            }

            Match m = reg.Match(ret);
            if (m.Success)
            {
                string strNumber = m.Groups[1].Value;
                string strExp = m.Groups[2].Value;
                if (strExp.StartsWith("0"))
                    strExp = strExp.Remove(0, 1);
                int exp = Convert.ToInt16(strExp);
                var sb = new StringBuilder();
                if (exp <= 3)
                {
                    if (exp < nbMax)
                    {
                        ret = value.ToString("#");
                        return ret;
                    }
                    double dNumber = Convert.ToDouble(strNumber, cu);

                    if (strNumber.Contains("."))
                    {
                        dNumber *= 10;
                        exp--;
                    }

                    int iNumber = Convert.ToInt16(dNumber);
                    sb.Append(iNumber);

                    for (int i = 0; i < exp; i++)
                    {
                        sb.Append("0");
                    }

                    ret = sb.ToString();
                    return ret;

                }

                sb.Append(strNumber);
                sb.Append("e");
                sb.Append(strExp);

                ret = sb.ToString();
                return ret;
            }


            return ret;
        }

        public static string FormatCustom(this decimal value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(double.MinValue))
                return "-" + infini;
            if (value.Equals(double.MaxValue))
                return infini.ToString();

            if (value > int.MaxValue - 20)
                return infini.ToString();
            if (value < -int.MaxValue + 20)
                return "-" + infini;

            return FormatCustom(Convert.ToDouble(value), nb, nbMin, nbMax);

        }

        public static string FormatCustom(this TimeSpan value, int nb)
        {
            return value.FormatCustom(nb, nb, nb);

        }

        public static string FormatCustom(this TimeSpan value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(TimeSpan.MinValue)) return "-" + infini;
            if (value.Equals(TimeSpan.MaxValue)) return infini.ToString();
            return value.TotalDays.FormatCustom(nb, nbMin, nbMax);
        }

        public static string FormatCustomTs(this double value, int nb)
        {
            return value.FormatCustomTs(nb, nb, nb);
        }
        public static string FormatCustomTs(this decimal value, int nb)
        {
            return value.FormatCustomTs(nb, nb, nb);
        }

        public static string FormatCustomTs(this double value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(double.MinValue) || double.IsNegativeInfinity(value))
                return "-" + infini;
            if (value.Equals(double.MaxValue) || double.IsInfinity(value) || double.IsNaN(value))
                return infini.ToString();
            if (value > int.MaxValue - 20)
                return infini.ToString();
            if (value < -int.MaxValue + 20)
                return "-" + infini;
            TimeSpan ts = TimeSpan.FromMilliseconds(value);
            return ts.TotalDays.FormatCustom(nb, nbMin, nbMax);
        }

        public static string FormatCustomTs(this decimal value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(decimal.MinValue))
                return "-" + infini;
            if (value.Equals(decimal.MaxValue)) // || double.IsInfinity(value) || double.IsNaN(value))
                return infini.ToString();

            if (value > int.MaxValue - 20)
                return infini.ToString();
            if (value < -int.MaxValue + 20)
                return "-" + infini;

            TimeSpan ts = TimeSpan.FromMilliseconds(Convert.ToDouble(value));
            return ts.TotalDays.FormatCustom(nb, nbMin, nbMax);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\pdb.gen.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.gen</RootNamespace>
    <AssemblyName>pdb.gen</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;COMPACT_</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="albums\Album.cs" />
    <Compile Include="albums\AlbumComparer.cs" />
    <Compile Include="albums\AlbumMedianne.cs" />
    <Compile Include="albums\Albums.cs" />
    <Compile Include="albums\DecimalPiece.cs" />
    <Compile Include="albums\IPieceAlbum.cs" />
    <Compile Include="albums\PieceExtended.cs" />
    <Compile Include="albums\PieceSort.cs" />
    <Compile Include="albums\StackAlbum.cs" />
    <Compile Include="albums\VirtualAlbumPiece.cs" />
    <Compile Include="auto\CalcAuto.cs" />
    <Compile Include="auto\ConfMedianneVirt.cs" />
    <Compile Include="auto\HistoValue.cs" />
    <Compile Include="auto\Medianne.cs" />
    <Compile Include="auto\MedianneDriver.cs" />
    <Compile Include="CalcEquiv.cs" />
    <Compile Include="ClassementCache.cs" />
    <Compile Include="Consolid.cs" />
    <Compile Include="CLegacyListWriter.cs" />
    <Compile Include="CRank.cs" />
    <Compile Include="IListWriter.cs" />
    <Compile Include="ListPiece.cs" />
    <Compile Include="CPieceComparer.cs" />
    <Compile Include="ListSelection.cs" />
    <Compile Include="ListWriterMgr.cs" />
    <Compile Include="medianne\enums.cs" />
    <Compile Include="pertinence\TrackBuilder.cs" />
    <Compile Include="Piece.cs" />
    <Compile Include="CalcDate.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="stat\ClassStruct.cs" />
    <Compile Include="stat\Condenseur.cs" />
    <Compile Include="stat\DynamicStatBuilder.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="stat\MedianneValue.cs" />
    <Compile Include="stat\NewClassement.cs" />
    <Compile Include="stat\StatBuilder.cs" />
    <Compile Include="stat\StatConteneur.cs" />
    <Compile Include="TrackList.cs" />
    <Compile Include="Tuning\CConf.cs" />
    <Compile Include="Tuning\CConfQL.cs" />
    <Compile Include="Tuning\CConfSort.cs" />
    <Compile Include="Tuning\ConfAlbumSort.cs" />
    <Compile Include="Tuning\ConfFilter.cs" />
    <Compile Include="Tuning\ConfGen.cs" />
    <Compile Include="Tuning\ConfMedianne.cs" />
    <Compile Include="Tuning\CTuning.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\GroupingDisplay.cs" />
    <Compile Include="Tuning\Import.cs" />
    <Compile Include="Tuning\ZeroWorkConf.cs" />
    <Compile Include="Util.cs" />
    <Compile Include="VirtualAlbumPieceLight.cs" />
    <Compile Include="Virtuel\VirtualPiece.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.Text.RegularExpressions;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackInfoItunes, IEnumerable<Piece>, IItem, IPiece, IPieceAlbum
    {
        private ITrackInfoItunes track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual virtualMode VirtualMode { get { return virtualMode.none; } }
        // public virtual bool Dirty { get { return false; } set { throw new ApplicationException();  } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } get { return gen; } }
        /// <summary>
        /// Permet d'utiliser le classement Compact. 
        /// </summary>
        private bool useCompact = Compact;
        // private bool useCompact0 = Compact;
        public static bool Compact;
        public static Classement compact(Classement cl)
        {
            if (!Compact)
                return Classement.NULL;
            if (!cl.isPositive())
                return Classement.NULL;
            //if (ClassementHash.ZERO_KEY == strClassement)
            //    return null;
            // var cl = classementHash.getCache(strClassement);
            var res = tradCompact[cl];
            if (res == null)
            {
            }

            if (res == null)
                return Classement.NULL;
            return res;
        }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackInfoItunes Track { get { return track; } }

        public bool UseCompact { get { return useCompact; } set { useCompact = value; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void resetMedianneCompact() { _infoMedianne = infoMedianne.none; useCompact = Compact; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
            // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        //public int LRank
        //{
        //    get { return Rank.Lenght; }
        //    set { Rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return Rank.Twice; }
        //    set { Rank.Twice = value; }
        //}

        //public int RankAllAlbum
        //{
        //    get { return m_rank.RankAllAlbum; }
        //    set { m_rank.RankAllAlbum = value; }
        //}

        public int RankAlbum { get { if (album == null) return 0; return album.Quality; } }
        public int RankAlbumZero { get { if (album == null) return 0; return Albums.RankZero - album.RankZero; } }
        public int RankAlbumSt { get { if (album == null) return 0; return album.RankSt; } }
        public int RankAlbumZeroSt { get { if (album == null) return 0; return album.RankZeroSt; } }




        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        // public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public decimal ClassementValueLight { get { if (album == null) return 0; return album.ClassementValueLight; } }
        public decimal ClassementValueLight0 { get { if (album == null) return 0; return album.ClassementValueLightZero; } }
        public decimal ClassementValueLightSt { get { if (album == null) return 0; return album.ClassementValueLightSt; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Moved = value; } }
        public bool MovedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Moved;
                    default:
                        return false;
                }
            }
        }

        public bool isEmpeached()
        {
            if (album == null) return false;
            return album.Empeached;
        }

        public int EmpeachedNb { get { if (album == null) return 0; return album.EmpeachedNb; } }

        public bool Empeached { get { if (album == null) return false; return album.Empeached && SelectedMotif == selectedCoeff.noCoeff; } set { if (album != null) album.Empeached = value; } }
        public bool EmpeachedM
        {
            get
            {
                if (album == null) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return album.Empeached;
                    default:
                        return false;
                }
            }
        }
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get { if (album == null) return false; return album.Empeached1 && this == album.Next; } set { if (album != null) album.Empeached1 = value; } }
        public bool AlmostFree { get { if (album == null) return false; return album.AlmostFree && this == album.Next; } }
        public bool AlmostFree1 { get { if (album == null) return false; return album.AlmostFree1 && this == album.Next; } }

        public bool AlbumRecentlyUpdated { get { return StackValue > 0 && SelectedMotif == selectedCoeff.noCoeff; } }
        public bool AlbumRecentlyUpdatedMain
        {
            get
            {
                if (StackValue == 0) return false;
                switch (SelectedMotif)
                {
                    case selectedCoeff.none:
                        return false;
                    case selectedCoeff.noCoeff:
                        return false;
                    case selectedCoeff.main:
                    case selectedCoeff.min:
                        return true;
                    default:
                        return false;
                }
            }
        }


        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackInfoItunes track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch();
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        // public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.MasterPiece.setClassement(className, rating);
            invalidateCache(true);

        }

        public string ClassementCompact
        {
            get
            {

                return getClassement(true).ToString();
                //if (parent != null)
                //    return parent.ClassementCompact;
                //if (Compact)
                //{
                //    if (string.IsNullOrEmpty(_classementCompact))
                //        return ClassementCache.strClassement;
                //    return _classementCompact;
                //}
                //else
                //    return ClassementCache.strClassement;

            }
        }
        //  public static ClassementHash classementHash = new ClassementHash();
        //private ClassementCache _classementCache;
        //private ClassementCache ClassementCache
        //{
        //    get
        //    {


        //        if (_classementCache == null)
        //        {
        //            if (parent != null)
        //                _classementCache = parent.ClassementCache;
        //            if (_classementCache == null)
        //            {
        //                if (Compact)
        //                {
        //                    if (string.IsNullOrEmpty(_classementCompact))
        //                        _classementCache = classementHash.getCache(track.ClassName, track.Rating);
        //                    else
        //                        _classementCache = classementHash.getCache(_classementCompact);
        //                }
        //                else
        //                    _classementCache = classementHash.getCache(track.ClassName, track.Rating);

        //            }
        //        }
        //        return _classementCache;
        //    }
        //}

        // private bool keep;
        private static Dictionary<int, decimal> hsKeep = new Dictionary<int, decimal>();
        public bool Keep
        {
            get { return hsKeep.ContainsKey(PieceId); } //  .Contains(PieceId); }
            //set
            //{
            //    if (value)
            //        hsKeep.Add(PieceId);
            //    else
            //        hsKeep.Remove(PieceId);
            //}
        }

        public decimal KeepCoeff
        {
            get
            {
                if (!Keep)
                    return 0;
                return hsKeep[PieceId];
            }
        }

        public void setKeep(decimal coeff)
        {
            if (hsKeep.ContainsKey(PieceId))
            {
                if (coeff == 0m)
                    hsKeep.Remove(PieceId);
                else
                    hsKeep[PieceId] = coeff;
            }
            else
            {
                if (coeff != 0m)
                    hsKeep.Add(PieceId, coeff);
            }
        }

        private static HashSet<int> ksCompact = new HashSet<int>();
        private static Dict<Classement, Classement> tradCompact = new Dict<Classement, Classement>();
        // private static Dict<int, string> dictCompact = new Dict<int, string>();

        public static void resetCompact() { tradCompact.Clear(); }
        //private bool UseCompact0
        //{
        //    get
        //    {
        //        if (parent == null)
        //            return useCompact0;
        //        return parent.useCompact0;
        //    }
        //}

        public Classement getClassement(bool _compact)
        {
            var cl = ClassementCoeff;
            if (_compact && useCompact && ClassementACompacter)
            {
                var __compact = compact(cl);
                if (__compact == null || !__compact.isPositive())
                {

                }
                else
                    return __compact;



            }
            return cl;
        }
        //private ClassementCache getClassementCache(bool _compact)
        //{
        //    //if (parent != null)
        //    //    return parent.getClassementCache(_compact);
        //    //  ClassementCache compactc = null;

        //    var cl = ClassementCoeff;
        //    if (_compact && useCompact && ClassementACompacter)
        //    {
        //        var strCompact = compact(str);
        //        if (str != ClassementHash.ZERO_KEY && string.IsNullOrEmpty(strCompact))
        //        {
        //        }
        //        else
        //            return classementHash.getCache(strCompact);

        //    }
        //    return classementHash.getCache(str);
        //    // return classementHash.getCache(strClassement);


        //}



        // private string _classementCompact;



        /// <summary>
        /// Compacte le classement - returne OK si fait
        /// </summary>
        /// <param name="classement"></param>
        /// <returns></returns>
        public bool setClassementCompact(string classement)
        {
            invalidateCache(true);

            // _classementCompact = classement;
            var _compact = Classement.create(classement);// classementHash.getCache(classement);
            var org = ClassementCoeff; //  classementHash.getCache(StrClassementCoeff);

            if (org <= _compact)
            {
                //  useCompact0 = false;
                //tradCompact.Remove(org.strClassement); 
                // dictCompact.Remove(MasterId);
                // _classementCache = org;
                return false;
            }
            else
            {
                // useCompact0 = true;
                tradCompact[org] = _compact;
                // dictCompact[MasterId] = classement;
                // _classementCache = _compact;
                return true;
            }
        }

        public bool ClassmentPositive() { return Classement.isPositive(); }

        public decimal ClassementValueDecimal(bool compact)
        {
            return getClassement(compact).ClassementValueDecimal;
        }



        public virtual void invalidateCache(bool razCompact)
        {
            //if (razCompact)
            //{
            //  //  useCompact0 = false;
            //  //  useCompact = false;

            //    //if (parent != null)
            //    //    parent.invalidateCache(razCompact);
            //}
            //  tradCompact.Remove(StrClassement); 
            //dictCompact.Remove(MasterId);

            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
            //_classementProvisoireRecent = null;

            //if (parent != null)
            //    parent.invalidateCache(razCompact);
            //else
            //{
            //    // _classementCache = null;
            //    if (Compact)
            //    {
            //        if (razCompact)
            //            _classementCompact = null;
            //    }
            //    foreach (Piece p in childs)
            //    {
            //        if (Compact)
            //        {
            //            if (razCompact)
            //                p._classementCompact = null;
            //        }
            //        // p._classementCache = null;
            //    }
            //  }


        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité



        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return this.Classement.isClassed();
            }
        }

        // private string _classNameAndRating;
        //public String ClassNameAndRating
        //{
        //    get
        //    {
        //        return ClassementCache.ClassNameAndRating;
        //    }
        //}

        public String ClassNameAndRating(bool compact)
        {
            return getClassement(compact).ClassNameAndRating;

        }

        // private decimal _classementValueDecimal = -1;
        //public decimal ClassementValueDecimal
        //{
        //    get
        //    {
        //        return ClassementCache.ClassementValueDecimal;
        //    }
        //}
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        /// <summary>
        /// Convertit chaine de format 12345 en 0.17
        /// </summary>
        /// <param name="classNameAndRating"></param>
        /// <returns></returns>
        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }
        public decimal RapportClassement(bool compact)
        {
            return getClassement(compact).RapportClassement;
        }

        //  public string HrC { get { return getClassementEquiv(RapportClassement(true)); } }




        // private decimal _rapportClassement = -1;
        //public decimal RapportClassement
        //{
        //    get
        //    {
        //        return ClassementCache.RapportClassement;
        //        //if (parent != null)
        //        //    return parent.RapportClassement;
        //        //if (_rapportClassement != -1)
        //        //    return _rapportClassement;

        //        //decimal resultat = 0;
        //        //try
        //        //{
        //        //    return getRapport(ClassNameAndRating);
        //        //}
        //        //catch
        //        //{
        //        //}
        //        //_rapportClassement = resultat;
        //        //// _classementVirtuel = resultat; 
        //        //return _rapportClassement;
        //    }
        // }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        //private const int END_EQUIV = 13;
        //private const int NB_DEC_EQUIV = 8;
        public static string getStrClassement(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            int lastNotNull = 0;
            int firstNotNull = -1;
            int i = 0;
            for (; i < Classement.END_EQUIV; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);

                if (a > 0)
                {
                    lastNotNull = i;
                    if (firstNotNull < 0)
                        firstNotNull = i;
                }
                if (i >= _ok + Classement.NB_DEC_EQUIV + 2)
                    break;
            }
            var str = sb.ToString();
            sb = new StringBuilder();
            int indexPt = lastNotNull - 1;
            if ((lastNotNull - firstNotNull) > Classement.NB_DEC_EQUIV)
                indexPt--;
            //if (str.Length == 5)
            //    indexPt--; 

            for (int j = 0; j <= lastNotNull; j++)
            {

                sb.Append(str[j]);
                if (j == indexPt)
                    sb.Append('.');

            }
            str = sb.ToString(); // str.Insert(str.Length - 1, ".");
            return str;
        }
        public static string getClassementEquiv(decimal valRapport)
        {
            var str = getStrClassement(valRapport);
            return getReadableCl(str);
        }




        //public decimal RapportClassementDecimal
        //{
        //    get
        //    {
        //        if (parent != null)
        //            return parent.RapportClassementDecimal;
        //        decimal resultat = 0;
        //        try
        //        {
        //            string str = ClassNameAndRating;
        //            char[] tab = str.ToCharArray();

        //            decimal K = 1m;
        //            int count = tab.GetLength(0);


        //            for (int i = 0; i < count; i++)
        //            {
        //                K = K * 6;
        //                int c = Convert.ToInt32(tab[i].ToString());
        //                resultat += (decimal)c / K;
        //            }
        //        }
        //        catch
        //        {
        //        }
        //        return resultat;
        //    }
        //}

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating(false);
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        misc.log("change artist from '{0}' to'{1}'", track.Artist, value);


                        gen.invalidateAlbums();
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        gen.invalidateAlbums();
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        gen.invalidateAlbums();
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        //public string Comment
        //{
        //    get
        //    {
        //        //if (string.IsNullOrEmpty(track.Comment))
        //        //    gen.writeComment(this);
        //        return track.Comment;
        //    }
        //    set
        //    {
        //        //if (track.Comment != value)
        //        //{
        //        try
        //        {
        //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //            track.Comment = value;
        //        }
        //        catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
        //        //}
        //    }
        //}

        //public virtual string Grouping
        //{
        //    get
        //    {
        //        if (string.IsNullOrEmpty(track.Grouping))
        //        {
        //            gen.writeGrouping(this);
        //        }
        //        return track.Grouping;
        //    }
        //    //set
        //    //{
        //    //    //if (track.Grouping != value)
        //    //    //{
        //    //        try
        //    //        {
        //    //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //    //            track.Grouping = value;
        //    //        }
        //    //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //    //    //}
        //    //}

        //}





        //public virtual void setGrouping(string value, bool prior)
        //{
        //    try
        //    {
        //        //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
        //        track.setGrouping(value, prior);
        //    }
        //    catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        //}

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation();
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.MasterPiece.Dates; }
        }
        //public string ArtWork
        //{
        //    get { return track.ArtWork; }
        //    set { track.ArtWork = value; }
        //}

        public DateTime FirstAcces
        {
            get
            {
                var min = DateTime.MaxValue;
                foreach (DateTime dt in Dates)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }
                foreach (DateTime dt in DatesClassementBrut)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }

                return min;
            }
        }

        public DateTime Added
        {
            get
            {
                return track.Added;
            }
        }

        public virtual DateTime AlbumAdded
        {
            get
            {
                return album.AlbumAdded;
            }
        }

        public List<DateTime> DatesClassement { get { return track.MasterPiece.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {
                var list = DatesClassement;
                if (list.Count == 0)
                    return null;
                var dc = list[0];

                if (dc == DateTime.MinValue)
                    return null;
                if (dc == DateTime.MaxValue)
                    return null;

                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {

                foreach (DateTime dt in track.MasterPiece.DatesClassementBrut)
                {
                    if (dt > Piece.SeuilProvisoire)
                        return true;
                }
                return false;

            }
        }

        public bool ClassementRecentCompact
        {
            get
            {
                //  return !string.IsNullOrEmpty(compact(Classement.ToString())) && LastClassementRecent;
                return compact(Classement).isPositive() && LastClassementRecent;
            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? MasterAlbumUpdateClassement
        {
            get
            {
                var album = Master.album;
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }
        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public int NbRecentsInAlbum { get { if (album == null) return 0; return album.Recents; } }
        public int NbDoneInAlbum { get { if (album == null) return 0; return album.NbDone; } }
        public string PlusPetitEnabled
        {
            get
            {
                if (album == null || album.PlusPetitEnabled == null)
                    return "";
                return album.PlusPetitEnabled.Classement.ToString();
            }
        }

        public int MasterTrackNumber
        {
            get
            {
                if (parent == null)
                    return TrackNumber;
                return parent.TrackNumber;
            }
        }

        public int MasterTrackNumberForTri
        {
            get
            {
                var res = MasterTrackNumber;
                if (res <= 0)
                    return int.MaxValue;
                return res;
            }
        }

        public String ClassEvol { get { return track.MasterPiece.ClassEvol; } }




        //public void writeCommentGrouping()
        //{
        //    var mode = CConf.ConfGen.WriteComment;
        //    writeComment(mode);
        //    var modeg = CConf.ConfGen.WriteGrouping;
        //    writeGrouping(modeg);

        //}

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        //public void writeComment(writeGrouping mode)
        //{
        //    if (parent != null)
        //        return;
        //    if (mode == Tuning.writeGrouping.none)
        //        return;


        //    if (mode == Tuning.writeGrouping.mix)
        //    {
        //        StringBuilder sbEnd = new StringBuilder();

        //        sbEnd.Append(ClassName);
        //        sbEnd.Append(".");
        //        sbEnd.Append((RatingCmp / 20).ToString());
        //        sbEnd.Append(ClassEvol);
        //        string strEnd = sbEnd.ToString();
        //        string found = "";

        //        string[] tab = Comment.Split(' ');
        //        int count = tab.GetLength(0);
        //        if (count > 0)
        //        {
        //            found = tab[count - 1];
        //            if (found.Equals(strEnd))
        //                return;
        //        }
        //        writeComment(Tuning.writeGrouping.all);
        //    }

        //    StringBuilder sb = new StringBuilder();
        //    //string l_pref = "";
        //    //string l_str = "";

        //    string l_strList = ClassName;
        //    //if (ClassPlayList != null)
        //    //    l_strList = ClassName;

        //    ////if (m_classement.Imported)
        //    ////{
        //    //if (l_strList != ClassName)
        //    //{
        //    //    sb.Append("m (");
        //    //    sb.Append(ClassName);
        //    //    sb.Append(") "); 
        //    //  //  l_pref = "m (" + ClassName + ") ";
        //    //}
        //    ////}
        //    int l_rank = Rank.Twice;

        //    if (l_rank > 0)
        //    {
        //        CTuning.format(sb, l_rank);
        //        sb.Append(" ");
        //        //    if (l_rank < 1000)
        //        //    {
        //        //        if (CTuning.Total > 1000)
        //        //        {
        //        //            l_str += "0";
        //        //        }
        //        //        if (l_rank < 100)
        //        //        {
        //        //            l_str += "0";
        //        //            if (l_rank < 10)
        //        //            {
        //        //                l_str += "0";
        //        //            }
        //        //        }
        //        //    }


        //        var r = CTuning.Rapport(Rank.Quality);






        //        var quality = CConf.Select.Quality;
        //        //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
        //        //{
        //        double tx0 = Convert.ToInt32(1000 * r);
        //        sb.Append(tx0.ToString());
        //        sb.Append(" ");
        //        //}

        //        //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
        //        var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
        //        //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
        //        //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
        //        //getTx(m_rank.Lenght)
        //        //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


        //        sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
        //        //if (l_tx < 100 || l_tx >= 1000)
        //        //    sb.Append(l_tx.ToString("G2", en));
        //        //else
        //        //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



        //        sb.Append(" ");
        //        var rest = r;

        //        for (int i = 0; i < 4; i++)
        //        {
        //            var ee = rest * 6.0m;
        //            int e = (int)System.Math.Floor(ee);
        //            rest = ee - e;
        //            sb.Append(e);
        //        }



        //        sb.Append(" ");


        //        //sb.Append(l_tx2.ToString());
        //        //sb.Append(" ");
        //        //sb.Append((100 * m_rank.SortValue).ToString("0"));
        //        //sb.Append(" ");

        //        //sb.Append(Dates.Count.ToString()); sb.Append(" ");

        //        //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

        //        //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

        //        //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



        //        sb.Append(l_strList);
        //        sb.Append(".");
        //        sb.Append((RatingCmp / 20).ToString());

        //    }

        //    sb.Append(ClassEvol);



        //    Comment = sb.ToString();
        //    //Comment = l_pref + l_str + ClassEvol;
        //}

        public override string ToString()
        {
            object o = PieceAlbum;
            if (o == null)
                o = VirtualMode;
            return string.Format("{0} {1}", o, track);
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }
        public string ClassementVirtuel { get { return Piece.getClassementEquiv(VirtualClassement); } }

#if GEN2

        private decimal _classementVirtuel;

       
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 1;
                return RapportClassement(true) / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 1;
                return RapportClassement(true) / _classementVirtuel2;
            }
        }
#else
        public decimal VirtualClassement { get { return RapportClassement(true); } }
        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(VirtualClassement); } }
        public decimal CoeffVirtuel
        {
            get
            {
                return 1;
            }
        }
        public decimal CoeffVirtuel2
        {
            get
            {
                return 1;
            }
        }

#endif

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        //private bool haveToUpdateGrouping = false;
        //public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        //public void writeGrouping(writeGrouping writeGrouping)
        //{
        //    var cat = CConf.ConfGen.DisplayCategories;
        //    //if (!CConf.ConfGen.WithOrder)
        //    //    cat = minCategories; 
        //    if (writeGrouping == Tuning.writeGrouping.none)
        //        return;

        //    //if (m_rank.Twice <= 0)
        //    //    return;
        //    if (haveToUpdateGrouping)
        //    {
        //        setGrouping(getGroup(cat), true);
        //    }

        //    else if (writeGrouping == Tuning.writeGrouping.mix)
        //    {
        //        bool haveToUpdate = false;
        //        string org = Grouping;
        //        if (org != null)
        //        {
        //            string[] data = org.Split(' ');

        //            try
        //            {
        //                foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
        //                {
        //                    DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
        //                    //displayCategory found = cat.Find(c => (int)c == (int)mode);
        //                    if (found != null)
        //                    {
        //                        int indexOfTime = cat.IndexOf(found);

        //                        string timeValue = data[indexOfTime];
        //                        string newValue = getTimeValue(mode, found.mode);
        //                        if (!newValue.Equals(timeValue))
        //                        {
        //                            haveToUpdate = true;
        //                            break;
        //                        }
        //                    }
        //                }
        //            }
        //            catch
        //            {
        //                haveToUpdate = true;
        //            }
        //        }
        //        else
        //        {
        //            haveToUpdate = true;
        //        }
        //        if (haveToUpdate)
        //            setGrouping(getGroup(cat), true);
        //    }
        //    else
        //        setGrouping(getGroup(cat), false);
        //}



        //private string getTimeValue(datesMode modeDates, timeMode modeTime)
        //{
        //    switch (modeTime)
        //    {
        //        case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
        //        case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
        //        case timeMode.last:
        //        case timeMode.equiv:
        //        case timeMode.equivNorm:
        //        var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
        //        if (modeTime == timeMode.equivNorm)
        //            return ts.FormatCustomTs(3, 2, 4);
        //        return ts.FormatCustomTs(2);

        //        case timeMode.delta:
        //        case timeMode.deltaNorm:

        //        var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
        //        var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
        //        var delta = tsf - ts0;
        //        delta = delta * 100;
        //        //if (modeTime == timeMode.deltaNorm)
        //        //    return delta.FormatCustom(3, 2, 4);
        //        return "(" + delta.FormatCustomTs(2) + ")";
        //        default:
        //        throw new NotImplementedException();

        //    }

        //    //if (modeTime == timeMode.complex)
        //    //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
        //    //else if (modeTime == Tuning.timeMode.simple)
        //    //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
        //    ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
        //    //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
        //    //{
        //    //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

        //    //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
        //    //        return ts.FormatCustom(3, 2, 4);
        //    //    return ts.FormatCustom(2);
        //    //}
        //    //else
        //    //{
        //    //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
        //    //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
        //    //    var delta = tsf - ts0;

        //    //    if (modeTime == timeMode.equivNorm)
        //    //        return delta.FormatCustom(3, 2, 4);
        //    //    return delta.FormatCustom(2);
        //    //}
        //}

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    return album.RankAlbumReverse;
                    //int rank = album.Quality;
                    //rank = Albums.RankZero - rank; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
                    //return rank;
                }
                return 0;
            }
        }

        public int DeltaRankAbs { get { return System.Math.Abs(RankAlbumReverse - RankAlbumZero); } }
        public int DeltaRank { get { return RankAlbumZero - RankAlbumReverse; } }

        //private string getGroup(List<DisplayGrouping> categories)
        //{
        //    StringBuilder sb = new StringBuilder();

        //    bool begin = false;

        //    displayCategory last = displayCategory.none;
        //    foreach (var category in categories)
        //    {
        //        try
        //        {
        //            if (begin //&& (int)category.category <= (int)displayCategory.pipe
        //                && last != displayCategory.croc1 && last != displayCategory.par1
        //                && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
        //                sb.Append(" ");
        //            begin = true;

        //            switch (category.category)
        //            {
        //                case displayCategory.rankSort:
        //                CTuning.format(sb, Rank.Sort); break;
        //                case displayCategory.rankDelta:
        //                CTuning.format(sb, Rank.RankDelta); break;
        //                case displayCategory.rankTime:
        //                CTuning.format(sb, Rank.RankRest); break;
        //                case displayCategory.rankAllAlbum:
        //                CTuning.format(sb, RankAllAlbum); break;
        //                case displayCategory.rankAlbum:
        //                if (album != null)
        //                    sb.Append(album.Rank.Sort); break;
        //                case displayCategory.rankAlbumReverse:
        //                sb.Append(RankAlbumReverse);
        //                break;
        //                case displayCategory.rankEquiv:
        //                if (album != null)
        //                    sb.Append(album.Equiv);
        //                break;
        //                case displayCategory.rankEquivLight:
        //                if (album != null)
        //                    sb.Append(album.EquivLight);
        //                break;
        //                case displayCategory.rankEquivLight0:
        //                if (album != null)
        //                    sb.Append(album.EquivLight0);
        //                break;
        //                case displayCategory.albumMoy:
        //                if (album != null)
        //                {
        //                    sb.Append(album.Moyenne);
        //                }
        //                break;
        //                case displayCategory.lenght:
        //                sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
        //                case displayCategory.sortValue:
        //                sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
        //                case displayCategory.tplay:
        //                sb.Append(getTimeValue(datesMode.play, category.mode)); break;
        //                case displayCategory.tclass:
        //                sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
        //                case displayCategory.tclassMin:
        //                sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
        //                case displayCategory.tmix:
        //                sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
        //                case displayCategory.tmixMin:
        //                sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
        //                case displayCategory.timeCoeff:
        //                sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
        //                case displayCategory.dplay:
        //                sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
        //                case displayCategory.dclass:
        //                sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
        //                break;
        //                case displayCategory.dclassMin:
        //                sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
        //                case displayCategory.dmix:
        //                sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
        //                break;
        //                case displayCategory.dmixMin:
        //                sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
        //                break;
        //                case displayCategory.pipe:
        //                sb.Append("|");
        //                break;
        //                case displayCategory.par1: sb.Append("("); break;
        //                case displayCategory.par2: sb.Append(")"); break;
        //                case displayCategory.croc1: sb.Append("["); break;
        //                case displayCategory.croc2: sb.Append("]"); break;

        //                default:
        //                break;
        //            }


        //            last = category.category;
        //        }

        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }
        //    }
        //    return sb.ToString();
        //}

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
            //gen.Albums.invalidate(Master); 
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }

        }

        public void setParent(Piece value)
        {

            if (value == parent)
                return;
            var old = parent;
            if (old != null)
            {
                old.albumMustRefresh();
                old.removeChild(this);
            }
            parent = value;
            if (parent == null)
            {
                if (old != null)
                {
                    this.PieceParentId = -1;
                }
            }
            else
            {
                parent = parent.Master;
                parent.addChild(this);
                this.PieceParentId = parent.MasterId;

            }
            if (album != null)
                this.album.mustRefresh();

        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private HashSet<Piece> childs = new HashSet<Piece>();
        public HashSet<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            if (childs.Contains(child))
                return;
            //throw new ApplicationException("enfant déjà enregistré " + this + " " + child); 


            childs.Add(child);

        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public void removeVirtualChilds()
        {
            List<Piece> list = null;
            foreach (var c in childs)
            {
                if (c.Virtual)
                {
                    // c.parent = null;
                    if (list == null)
                        list = new List<Piece>();
                    list.Add(c);
                }
            }
            if (list != null)
            {
                foreach (var c in list)
                {
                    childs.Remove(c);
                }
            }
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return MasterPiece.ExportStatus; // exportState;
            }
            set
            {
                MasterPiece.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return MasterPiece.RelativesPath; }
        }

        //public List<string> getIntermediaryPath()
        //{
        //    var list = new List<string>();
        //    foreach (var path in track.RelativesPath)
        //    {

        //        var tab = path.Split('\\');
        //        var sb = new StringBuilder();

        //        sb.Append(@"\");
        //        var count = tab.GetLength(0);
        //        for (int i = 0; i < count; i++)
        //        {
        //            var _s = tab[i];
        //            if (string.IsNullOrEmpty(_s))
        //                continue;

        //            var s = sb.ToString();
        //            if (!string.IsNullOrEmpty(s))
        //            {
        //                if (s.Length >= 2)
        //                {
        //                    list.Add(s);
        //                }
        //            }



        //            if (i > 0)
        //                sb.Append(@"\");
        //            sb.Append(_s);
        //        }
        //    }


        //    return list;


        //}

        const string ET = " et ";
        const string AND = " and ";
        const string WITH = " with ";
        const string AVEC = " avec ";
        const string EN_DUO_AVEC = " En Duo Avec ";


        public void buildVirtualAlbums(List<Piece> list)
        {
            HashSet<string> hs = new HashSet<string>();


            var reels = new List<Piece>();

            foreach (Piece p in this)
            {
                if (p.Virtual)
                {
                }
                else
                    reels.Add(p);

            }

            childs.Clear();
            foreach (Piece p in reels)
            {
                if (p == this)
                    continue;
                childs.Add(p);
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in reels)
                {
                    if (!string.IsNullOrEmpty(p.Artist))
                    {
                        var virt = createVirtualAlbum(p.Artist, virtualMode.artist, hs);
                        if (virt == null)
                            continue;
                        list.Add(virt);


                        var artists = Regex.Replace(p.Artist, ET, "&", RegexOptions.IgnoreCase);
                        artists = Regex.Replace(artists, AND, "&", RegexOptions.IgnoreCase);
                        artists = Regex.Replace(artists, WITH, "&", RegexOptions.IgnoreCase);
                        artists = Regex.Replace(artists, EN_DUO_AVEC, "&", RegexOptions.IgnoreCase);
                        artists = Regex.Replace(artists, AVEC, "&", RegexOptions.IgnoreCase);
                        var tab = artists.Split(",;:&/\\".ToCharArray());
                        {
                            foreach (string part in tab)
                            {
                                if (string.IsNullOrEmpty(part))
                                    continue;
                                if (part.Equals(p.Artist))
                                    continue;
                                var _part = part.Trim();
                                var virtp = createVirtualAlbum(_part, virtualMode.artist, hs);
                                if (virtp == null)
                                    continue;
                                list.Add(virtp);
                            }
                        }
                    }
                }

            }
            if (CConf.ConfGen.PathVirtual)
            {
                foreach (var path in MasterPiece.RelativesPath)
                {

                    var tab = path.Split('\\');
                    var sb = new StringBuilder();

                    sb.Append(@"\");
                    var count = tab.GetLength(0);
                    for (int i = 0; i < count; i++)
                    {
                        var _s = tab[i];
                        if (string.IsNullOrEmpty(_s))
                            continue;

                        var virt = createVirtualAlbum(sb.ToString(), virtualMode.path, hs);

                        if (virt != null)
                            list.Add(virt);



                        if (i > 0)
                        {
                            sb.Append(@"\");
                            if (CConf.ConfGen.PathVirtualE && i < count - 1)
                            {
                                var extended = createVirtualAlbum(_s, virtualMode.extended, hs);
                                if (extended != null)
                                    list.Add(extended);
                            }
                        }
                        sb.Append(_s);
                    }
                }
            }


            if (CConf.ConfGen.YearVirtual)
            {
                foreach (Piece p in reels)
                {
                    if (p.Year > 0)
                    {
                        var strYear = p.Year.ToString();
                        if (strYear.Length == 4)
                        {
                            var decennie = strYear.Remove(3);
                            var virtDecennie = createVirtualAlbum(decennie, virtualMode.year, hs);
                            if (virtDecennie != null)
                                list.Add(virtDecennie);
                        }
                        var virt = createVirtualAlbum(strYear, virtualMode.year, hs);
                        if (virt == null)
                            continue;
                        list.Add(virt);
                    }
                }

            }

            if (CConf.ConfGen.AddedVirtual)
            {
                bool simu = CConf.ConfGen.AddedVirtualSimu;
                foreach (Piece p in reels)
                {
                    DateTime added = p.Added;
                    if (simu && added == DateTime.MinValue && album != null)
                        added = album.AlbumAdded;
                    if (added > DateTime.MinValue)
                    {
                        var strDate = added.ToString("dd/MM/yyyy");
                        var virt = createVirtualAlbum(strDate, virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                        virt = createVirtualAlbum(added.ToString("MM/yyyy"), virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                        virt = createVirtualAlbum(added.Year.ToString(), virtualMode.added, hs);
                        if (virt != null) list.Add(virt);
                    }
                }
            }
            if (CConf.ConfGen.WordVirtual)
            {
                foreach (Piece p in reels)
                {
                    buildAlbumWord(p.Name, list, hs);
                    buildAlbumWord(p.Album, list, hs);
                    buildAlbumWord(p.Artist, list, hs);
                    buildAlbumWord(p.Year.ToString(), list, hs);
                    buildAlbumWord(p.TrackNumber.ToString(), list, hs);
                }

                foreach (var path in MasterPiece.RelativesPath)
                {
                    buildAlbumWord(path, list, hs);
                }
            }

            //// supprimer les liaisons remontantes ? 
            //foreach (Piece p in childs)
            //{
            //    if (p.Virtual)
            //    {
            //        if (!childs.Contains(p))
            //        {
            //            p.parent = null; 
            //        }
            //    }
            //}


        }

        private void buildAlbumWord(string phr, List<Piece> list, HashSet<string> hs)
        {
            if (string.IsNullOrEmpty(phr))
                return;
            char[] sep = @"\/ ,;:.()_[]-{}".ToCharArray();
            var tab = phr.Split(sep);
            foreach (string str in tab)
            {
                if (!string.IsNullOrEmpty(str))
                {
                    var virt = createVirtualAlbum(str, virtualMode.word, hs);
                    if (virt != null)
                        list.Add(virt);
                }
            }
        }

        public Piece createVirtualAlbum(string path, virtualMode mode, HashSet<string> hs)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2 && (mode == virtualMode.path || mode == virtualMode.extended))
            {
                if (!CConf.ConfGen.VirtualRoot)
                    return null;
            }
            if (hs != null)
            {
                var key = pdb.gen.albums.Album.getKey(path, mode);
                if (!hs.Add(key))
                    return null;
            }
            VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track, Master, path, mode);
            //  virt.setParent(Master);
            return virt;
        }

        public void menageChilds()
        {
            if (parent != null)
                return;
            if (childs.Count == 0)
                return;
            var toDelete = new List<Piece>();

            HashSet<string> hs = new HashSet<string>();

            foreach (Piece p in childs)
            {
                if (p.Virtual)
                {
                    if (!hs.Add(p.PieceAlbum.Key))
                    {
                        toDelete.Add(p);
                    }
                }
            }
            foreach (Piece p in childs)
            {
                if (p.Parent != this)
                    toDelete.Add(p);
            }

            foreach (Piece p in toDelete)
            {
                //removeChild(p);
                p.setParent(null);
            }

        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        //  const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        private static DateTime seuilCompact;
        public static DateTime SeuilCompact
        {
            get { return seuilCompact; }
            set
            {
                seuilCompact = value;
                if (seuilCompact > DateTime.Now)
                    seuilCompact = DateTime.MaxValue;
            }
        }
        // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in MasterPiece.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true;
                }
                return false;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        public bool ClassementACompacter
        {
            get
            {
                if (!Enabled)
                    return false;
                if (seuilCompact == DateTime.MaxValue)
                    return true;
                foreach (DateTime dt in MasterPiece.DatesClassementBrut)
                {
                    if (dt > seuilCompact)
                        return false;
                }
                return true;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        //public bool ClassementProvisoire
        //{
        //    get
        //    {
        //        if (RapportClassement(false) == 0)
        //            return false;
        //        var str = ClassName;
        //        int count = str.Length;
        //        if (count < 4)
        //            return true;
        //        if (count >= 8)
        //            return false;

        //        var tab = str.ToCharArray();
        //        int nb = 0;
        //        for (int i = 0; i < count; i++)
        //        {
        //            if (nb > 0)
        //                nb++;
        //            else
        //            {
        //                if (tab[i] != '0')
        //                {
        //                    nb++;
        //                }
        //            }
        //        }
        //        if (nb >= NB_CHAR_COMPLETE)
        //            return false;

        //        return true;

        //    }
        //}

        public bool Played { get { return track.Played; } }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return MasterPiece.DatesClassementBrut;
            }
        }

        int IItem.ID
        {
            get
            {
                return PieceId;
            }
            set
            {
                throw new NotImplementedException();
            }
        }


        public void setClassement(string classement)
        {
            MasterPiece.setClassement(classement);
        }

        void IPieceAlbum.setCoeff(decimal coeff, bool main)
        {

        }

        bool? IPieceAlbum.getSimpleCause()
        {
            return null;
        }



        public Classement Classement
        {
            get
            {
                var cl = Keep ? DeepClassement : MasterPiece.Classement;
                if (cl == null)
                    return Classement.NULL;
                return cl;
            }
        }

        //public string StrClassementCoeff
        //{
        //    get
        //    {
        //        if (!Keep)
        //            return Classement.ToString();
        //        var coeff = hsKeep[PieceId];
        //        if (coeff == 1m)
        //            return DeepClassement.ToString();
        //        var cl = classementHash.getCache(DeepClassement.ToString());

        //        var rapport = cl.RapportClassement;
        //        rapport *= coeff;
        //        var clReduit = getStrClassement(rapport);
        //        return clReduit;
        //        // return Keep ? DeepClassement : strClassement;
        //    }
        //}


        public Classement ClassementCoeff
        {
            get
            {
                if (!Keep)
                    return Classement;
                var coeff = hsKeep[PieceId];
                if (coeff == 1m)
                    return DeepClassement;
                decimal rapport = 1m;
                if (coeff > 0)
                {
                    Classement cl = DeepClassement;
                    rapport = cl.RapportClassement;
                    rapport *= coeff;
                }
                else
                {
                    rapport = Classement.EPSILON_RAPPORT;
                    rapport *= -coeff;
                }
               
                // var clReduit = getStrClassement(rapport);
                return Classement.create(rapport);
                // return Keep ? DeepClassement : strClassement;
            }
        }


        public Classement DeepClassement
        {
            get { return MasterPiece.DeepClassement; }
        }


        public Classement MaxClassement
        {
            get { return MasterPiece.MaxClassement; }
        }

        public IMasterPiece MasterPiece
        {
            get
            {
                return track.MasterPiece;
            }
        }

        bool IPieceAlbum.Enabled
        {
            get
            {
                return Enabled;
            }
        }



        Classement IPieceAlbum.Classement
        {
            get
            {
                return getClassement(true);
            }
        }

        decimal IPieceAlbum.Value
        {
            get
            {
                return RapportClassement(true);
            }

            set
            {

            }
        }

        bool IPieceAlbum.LastClassementRecent
        {
            get
            {
                return this.LastClassementRecent;
            }
        }

        Piece IPieceAlbum.Piece
        {
            get
            {
                return this;
            }
        }

        bool IPieceAlbum.Empty
        {
            get
            {
                return !(this as IPieceAlbum).Classement.isPositive();
            }
        }

        decimal IPieceAlbum.Coeff
        {
            set
            {

            }
        }

        bool IPieceAlbum.getCauseUp(bool? natureCause)
        {
            return false;
        }

        bool IPieceAlbum.UseCompact
        {
            get
            {
                return this.UseCompact;
            }

            set
            {
                this.UseCompact = value;
            }
        }
        void IPieceAlbum.Combine()
        { }
    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.IO;

namespace pdb.gen.albums
{
    public enum virtualMode
    {
        none = 0,
        artist = 1,
        path = 2,
        year = 3,
        extended = 4,
        added = 5,
        list = 6,
        word = 7
    }

    public enum sortDone : byte
    {
        none,
        phaseUn,
        phaseDeux
    }

    public class Album : IEnumerable<Piece>
    {
        const int NB_DEC = 3;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        const int A_REFAIRE_CAUSE_COMPACT = -10;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
#if GEN2
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;
#endif
        private sortDone sortStatus;

        private int nbRecent;
        private int nbDone;
        public int Recents { get { return nbRecent; } }
        public int NbDone { get { return nbDone; } }
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }


            return ret; ;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
#if GEN2
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
#else
                return ClassementValueLightSt;
#endif
            }
        }
        //  private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero
        {
            get
            {
#if GEN2
                return classementValueLightZero;
#else
                return ClassementValueLight;
#endif
            }
        }
        public decimal Rendement
        {
            get
            {
#if GEN2
                if (classementValueLight == 0) return 1; return classementValueLightZero / classementValueLight;
#else
                return 1;
#endif
            }
        }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private virtualMode mode;
        public virtualMode VirtualMode { get { return mode; } }
        //  private bool _virtual;
        public bool Virtual { get { return mode > virtualMode.none; } }
        public void setVirtual(virtualMode mode) { this.mode = mode; }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return this.mode == virtualMode.artist; } }
        private Piece pluspetitEnabled;
        public Piece PlusPetitEnabled { get { return pluspetitEnabled; } }
        private int stackValue;
        private DateTime majDate;
        public DateTime MajDate { get { return majDate; } }

        public int StackValue
        {
            get
            {

                return stackValue;
            }
            set
            {
                if (value > 0 && this.Name == "\\")
                {
                }
                else
                    stackValue = value;
            }
        }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, mode);
                return key;
            }
        }

        public Album(string name, virtualMode mode)
        {
            this.name = name;
            this.mode = mode;
            quality = CRank.MAX;
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            quality = CRank.MAX;
        }
        private int quality;
        public int Quality
        {
            get { return quality; }
            set { quality = value; }
        }

        public int RankAlbumReverse
        {
            get
            {
                return Albums.RankZero - quality; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
            }
        }

        private decimal timeRest = decimal.MaxValue;
        public decimal TimeRest { get { return timeRest; } set { timeRest = System.Math.Round(value, NB_DEC); } }
        public string Name { get { return name; } }

        public override string ToString()
        {
            return string.Format("{0} {1} {2} elts", name, mode, Count);
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0
        {
            get
            {
#if GEN2
                return Piece.getClassementEquiv(classementValueLightZero);
#else
                return EquivLight;
#endif
            }
        }

        //// private string moyenne = "";
        //public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return StackIndex == stackSize; } }
        public bool AlmostFree1 { get { return StackIndex == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (build)
                throw new ApplicationException("déjà buildé");
            piece.PieceAlbum = this;


            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                quality = CRank.MAX;
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public void ClearAndMenage()
        {
            if (mode == virtualMode.word && name == "029")
            {
            }
            if (mode != virtualMode.none)
            {
                foreach (Piece p in list)
                    p.setParent(null);
            }
            Clear();
        }

        public void ConsolidChilds()
        {
            foreach (Piece p in list)
                p.consolidChild();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && !p.ClassmentPositive())
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                var exists = FileRegister.Exist(next.Location);
                return false == exists;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return false; } }// selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<IPieceAlbum> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {
                #region calcul virtuel



                DecimalPiece med = null;
#if GEN2
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;
#endif



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                // bool combineNow = mode.combine && mode.simple;
#if GEN2
                if (real)
                    _albumMedianne.buildVirtual(mode.combine, mode.simple);
                else
                {
#else
                list.Sort(new PieceClassementComparer(false));
#endif
#if GEN2
            }
#endif
#if GEN2

                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    med1 = med; med2 = med;

                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, pieceExtendedMode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }

                    if (mode.combine && !mode.simple)
                    {
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    }


                }

                
                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }
#else
                med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);
                var median = med.index;

                if (median != null)
                {
                    resultGlobalMin = median.getSimpleCause();
                }
#endif















                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, pieceExtendedMode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var cnext = cause.Next;
                if (cnext != null)
                {
                    if (cnext.UseCompact && !cnext.Empty)
                    {
                        if (cnext.Piece.ClassementRecentCompact)
                        {
                            cnext.UseCompact = false;
                            return A_REFAIRE_CAUSE_COMPACT;
                        }
                    }
                }
                classementValueLight = med.d;
                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    //if (mode.combine && !mode.simple)
                    //{
                    //    _albumMedianne.buildVirtual(true);
                    //    med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                    //    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    //}
                    //else
                    //{
                    //    if (true == cause.selectedMotifMin)
                    //        med = med2;
                    //    else
                    //        med = med1;
                    //}




                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

#if GEN2
                    foreach (var p in list)
                        p.finalyse();

#endif


                    if (cause.motifUp)
                    {
                        if (cause.selectedMotifMin.HasValue)
                        {
                            if (true == cause.selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else if (selectedMotifMin.HasValue)
                        {
                            if (true == selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else
                        {
                            if (true == resultGlobalMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }


                    }

                    try
                    {
                        if (med.index != null)
                            pluspetitEnabled = med.index.Piece;
                        if (med.index != null) med.index.Piece.MedianneLight = true;
                        if (med.indexBorder != null) med.indexBorder.Piece.Border = true;
                        if (med.indexBorderEffect != null) med.indexBorderEffect.Piece.BorderEffect = true;
                        if (med.indexBorderMin != null) med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public IPieceAlbum Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<IPieceAlbum> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;
            bool forceKeep = mode.forceKeep;
            bool forceKeep2 = mode.forceKeep2;
            bool dontDownByKeep = mode.dontDownByKeep;


            // PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            IPieceAlbum nextZero1 = null;
#if GEN2
            IPieceAlbum nextZero2 = null;
             IPieceAlbum min2 = null;
                Classement _min2 = null;
              Classement _minzero2 = null;
#endif

            IPieceAlbum min1 = null;

            IPieceAlbum min = null;
            Classement _min1 = null;

            Classement _minzero1 = null;

            bool realZero = false;
            IPieceAlbum Next = null;

            IPieceAlbum firstKeep = null;
            IPieceAlbum firstKeep2 = null;
            foreach (IPieceAlbum p in list)
            {
                if (p.Piece.Keep)
                {
                    if (forceKeep && p.Piece.KeepCoeff > 0)
                    {
                        if (firstKeep == null)
                            firstKeep = p;
                    }
                    if (p.Piece.KeepCoeff < 0)
                    {
                        if (firstKeep2 == null)
                            firstKeep2 = p;
                    }

                    //min= firstInAlbumEmpty; 
                    //break;
                }
                var v1 = p.Classement;
#if GEN2
                var v2 = p.Classement2;
#endif

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            if (!p.Piece.Keep || !dontDownByKeep)
                            {
                                _minzero1 = v1;
                                nextZero1 = p;
                                if (v1.isZero())
                                    realZero = true;
                            }
                        }
                    }
#if GEN2

                    if (v2.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2.isZero())
                                realZero = true;
                        }

                    }

#endif

                    if (v1.isPositive() && v1 < _min1)
                    {
                        if (!p.Piece.Keep || !dontDownByKeep)
                        {
                            _min1 = v1;
                            min1 = p;
                        }
                    }
#if GEN2
                    if (v2.isPositive() && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }
#endif

                    if (p.Empty)
                        break;
                }
            }
            Classement _min = null;
#if GEN2
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;

            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }
#else
            min = min1;
            _min = _min1;
#endif

            IPieceAlbum nextZero = null;
            Classement _minzero = null;
#if GEN2
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }
#else
            nextZero = nextZero1; _minzero = _minzero1;
#endif

            //if (firstInAlbumEmpty != null)
            //{
            //    Next = firstInAlbumEmpty;
            //    cause.selectedMotifMin = cause.resultByFirstMin;
            //    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
            //}
            //else
            //{

            if (nextZero != null)
            {
                decimal _minValue = _min == null ? int.MaxValue : _min.RapportClassement;
                decimal _minZeroValue = _minzero == null ? int.MaxValue : _minzero.RapportClassement;
                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane

                    if (_minValue < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.ClassementValueLightZero > classementValueLight + EPSILON || (classementValueLight > 0 && this.ClassementValueLightZero / classementValueLight > 1 + EPSILON)) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_minValue < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minZeroValue < classementValueLight)
                    {
                        classementValueLight = _minZeroValue;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {

                        classementValueLight = _min == null ? int.MaxValue : _min.RapportClassement;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min.RapportClassement;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }
            //}

            if (Next == nextZero)
            {
                bool refact = false;

                if (firstKeep2 != null)
                {
                    if (forceKeep2)
                    {
                        Next = firstKeep2; refact = true;
                    }
                    else if (firstKeep2.Piece.DeepClassement.isZero())
                    {
                        Next = firstKeep2; refact = true;
                    }
                }
                else if (firstKeep != null)
                {
                    Next = firstKeep; refact = true;
                }

                if (refact)
                {
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                }
            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            if (real && min != null)
                this.pluspetitEnabled = min.Piece;
            return cause;



        }


        private bool makesort(List<Piece> list, List<IPieceAlbum> listE, ConfMedianne mode, ConfMedianne mode0, int nbrepeat)
        {
            int count = list.Count;

            if (sortStatus == sortDone.none)   //(!sort0Done)
            {
                // list.Sort(new CPieceComparerByQualityAndLength());
                var listSortedValues = new List<decimal>();
                //classed = false;
                //for (int i = 0; i < count; i++)
                //{
                //    listSortedValues.Add(list[i].Rank.SortValue);
                //    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                //        classed = true;
                //}
                ////misc.log("make sort Duration {0}", name); 
                //m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                //  listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                {
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                }
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                //   decimal moy = 0m;
                decimal offset = Album.conf.AlbumMoyOffset;
#if GEN2
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement(true);

                    p.setClassementVirtuel(rapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;
#endif

                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }
                if (sortStatus < sortDone.phaseUn)
                    sortStatus = sortDone.phaseUn;
                //   sort0Done = true;

            }


            if (sortStatus >= sortDone.phaseDeux)
                return false;

            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;
            selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;

#if GEN2
            classementValueLightZeroSt = -1;
           
            classementValueLightZero = makeSort(listE, mode0, false);
            if (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }
#endif
            classementValueLight = makeSort(listE, mode, true);
            if (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }

            //   classementValueLightZero = A_REFAIRE_CAUSE_COMPACT;


            //   while (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLightZero = makeSort(listE, mode0, false);
            //   }

            ////   var _classementValueLight = makeSort(listE, mode, true);

            //   while (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLight = makeSort(listE, mode, true);
            //   }
#if GEN2
            var coeff1 = mode.Main.coeffVirt;
            var coeff2 = mode.Min.CoeffOld;
            var rendementmax = 1m;

            if (mode.combine)
                rendementmax = coeff1 * coeff2;
            else
                rendementmax = pdb.util.Math.Max(coeff1, coeff2);
            if (Rendement > 6 * rendementmax + 1e-6m)
            {
                nbrepeat++;
                sortStatus = sortDone.none;
                if (nbrepeat >= 3)
                {
                    // classementValueLight = classementValueLightZero;
                    return true;
                }
                return makesort(list, listE, mode, mode0, nbrepeat);

            }
#endif
            return true;
        }



        public bool makeSort(ConfMedianne mode, ConfMedianne mode0, ILogger logger, double dureeMinToLog) //IList<double> reference, IList<Piece> pieces)
        {

            if (sortStatus >= sortDone.phaseDeux)
                return false;
            DateTime nowa = DateTime.Now;
            var ts = (nowa - majDate);
            try
            {

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return false;

                var listE = new List<IPieceAlbum>(count);

                //if (CConf.ResetOneCl)
                //{

                //    // CPieceClassement.DateMin = DateTime.MinValue;
                //    decimal zer0d = 0;
                //    Piece oldKeep = null;


                //    foreach (Piece t in list)
                //    {
                //        if (t.Keep)
                //        {
                //            t.Keep = false;
                //            oldKeep = t;
                //            break;
                //        }
                //    }


                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in list)
                //    {
                //        var cl = t.DeepClassement; // p.Classement.DbValue;
                //        decimal clValue = Piece.classementHash.getCache(cl).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {

                //            if (t.LastClassementRecent || !t.Enabled)
                //            {
                //                min = null;
                //                break;
                //            }
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        min.Keep = true;
                //        var r = min.RapportClassement(true);
                //        if (r <= 0)
                //        {
                //        }
                //    }



                //    if (oldKeep != null && !oldKeep.Keep)
                //    {
                //        oldKeep.resetMedianneCompact();
                //        oldKeep.invalidateCache(true);
                //    }
                //}


                atLeastOneEnabled = false;
                int _nbr = 0;
                int _nbdone = 0;


                for (int i = 0; i < count; i++)
                {
                    var p = list[i];


                    if (sortStatus < sortDone.phaseDeux) //  (!sortDone)
                        p.resetMedianneCompact();
                    if (p.Enabled)
                    {
                        atLeastOneEnabled = true;

                    }
                    if (!p.Enabled && p.ClassmentPositive())
                        _nbdone++;
                    if (p.LastClassementRecent)
                        _nbr++;
#if GEN2
                    var pp = new PieceExtended(p);
#else
                    var pp = p;
#endif
                    listE.Add(pp);
                }

                nbRecent = _nbr;
                nbDone = _nbdone;


                bool ret = makesort(list, listE, mode, mode0, 0);

                sortStatus = sortDone.phaseDeux;

                majDate = DateTime.Now;
                var duree = (majDate - nowa);
                if (duree.TotalMilliseconds > dureeMinToLog)
                    logger.log(string.Format("make Sort {0}| {1} {2}", ts.toString(), duree.toString(), this));

                return ret;
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return false;
        }



        public void mustRefresh()
        {
            build = false;
            sortStatus = sortDone.none;

            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
            albumAdded = DateTime.MaxValue;
        }

        public void refreshLight()
        {
            if (sortStatus == sortDone.phaseDeux)
                sortStatus = sortDone.phaseUn;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
        }



        //public decimal getTrackSortValue(int index, List<Piece> list)
        //{
        //    if (index < 0 || index >= list.Count)
        //        return 0;
        //    return list[index].RapportClassement(true);
        //}

        //decimal firstTrackSortValue = -1;
        //public decimal getFirstTrackSortValue()
        //{
        //    if (firstTrackSortValue == -1)
        //    {
        //        int count = list.Count;
        //        if (count == 0)
        //            return -1;
        //        var _list = new List<Piece>(list);
        //        _list.Sort(new PieceSortComparer());
        //        firstTrackSortValue = _list[count - 1].Rank.SortValue;
        //    }
        //    return firstTrackSortValue;
        //}
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            timeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> RawList
        {
            get
            {
                return new List<Piece>(list);
            }
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        //private CRank m_rank = new CRank();

        //public CRank Rank { get { return m_rank; } }



        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            quality = CRank.MAX;
            // rankStack = -1;
        }

        //public int QRank
        //{
        //    get { return m_rank.Quality; }
        //    set { m_rank.Quality = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}


        #endregion

        #region tri



        #endregion

        [Flags]
        private enum unsortMode : byte
        {
            album = 1,
            artist = 2

        }
        const char SEP = '\\';
        const int MAX_PATH_LEVEL = 10;

        public void addPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            paths.Add(p);
                        }
                        ilevel++;
                    }
                    // paths.Add(path);
                }
            }
        }

        public bool containsPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    if (paths.Contains(path))
                        return true; //paths.Add(path);
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            if (paths.Contains(p))
                                return true;
                        }
                        ilevel++;
                    }

                }
            }
            return false;
        }
        public void sortVirtual()
        {
            if (this.VirtualMode == virtualMode.none)
                return;
            var list = this.list.ToList<Piece>();
            int count = list.Count;
            if (count == 0)
                return;
            list.Sort((x, y) =>
            {
                var cmp = x.MasterTrackNumberForTri.CompareTo(y.MasterTrackNumberForTri);
                if (cmp != 0)
                    return cmp;
                return x.Location.CompareTo(y.Location);
            });
            var dictArtist = new Dictionary<string, List<Piece>>();
            var dictAlbum = new Dictionary<int, string>();
            var dictDir = new Dictionary<string, List<Piece>>();
            DirSort.reset();
            foreach (Piece p in list)
            {

                DirSort.record(p);
            }

            DirSort.go();


            foreach (Piece p in list)
            {
                if (p.TrackNumber == 0)
                {
                    p.TrackNumber = list.Count + p.MasterTrackNumber;
                }
            }

            list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;

            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}

            //var list2 = new List<Piece>(list);
            //list2.Sort(new VirtualPieceComparer());

            var hs = new HashSet<int>();
            var unsorted = new List<Piece>();
            Piece pp = list[0];
            hs.Add(pp.PieceId); unsorted.Add(pp);
            //string currentArtist = pp.Artist;
            //string currentAlbum = pp.Master.Album;


            int indexC = 0;
            //  bool singleAlbum = false;
            string currentArtist = Album.getKey(pp.Artist, virtualMode.artist);
            unsortMode mode = unsortMode.album | unsortMode.artist;
            if (VirtualByArtist)
                mode = unsortMode.album;

            HashSet<string> artists = new HashSet<string>();
            HashSet<string> albums = new HashSet<string>();
            artists.Add(currentArtist);
            albums.Add(pp.Master.PieceAlbum.Key);
            //  HashSet<string> paths = new HashSet<string>();
            //int pathlevel = 0;
            //  bool found = false;
            int nbc = 0;
            while (unsorted.Count < count)
            {
                nbc++;
                //int indexAlbum = -1;
                //int indexArtist = -1;


                // addPath(pp, paths, pathlevel);

                artists.Clear();
                albums.Clear();
                //    paths.Clear();
                artists.Add(currentArtist);
                albums.Add(pp.Master.PieceAlbum.Key);


                for (int i = 0; i < count; i++)
                {

                    var p = list[i];
                    if (hs.Contains(p.PieceId))
                        continue;

                    if (mode == 0)
                    {
                        hs.Add(p.PieceId);
                        unsorted.Add(p);
                        pp = p;
                        // indexAlbum = -1;
                        indexC = i;
                        continue;
                    }
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        var artist = p.Artist;
                        if (p.Artist != pp.Artist)
                        {
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            if (currentArtist != cartist)
                            {
                                if (!artists.Contains(cartist))
                                {
                                    if (mode.HasFlag(unsortMode.album))
                                    {
                                        if (albums.Contains(p.Master.PieceAlbum.Key))
                                        {
                                            //if (albums.Count <= 1)
                                            //    indexArtist = i;
                                            continue;
                                        }
                                    }

                                    //if (pathlevel <= MAX_PATH_LEVEL)
                                    //{
                                    //    if (containsPath(p, paths, pathlevel))
                                    //        continue;
                                    //}

                                    hs.Add(p.PieceId);
                                    unsorted.Add(p);
                                    pp = p;
                                    //indexAlbum = -1;
                                    //indexArtist = -1;

                                    albums.Add(pp.Master.PieceAlbum.Key);
                                    artists.Add(cartist);
                                    //  addPath(pp, paths, pathlevel); 
                                    indexC = i;
                                    currentArtist = cartist;
                                    //   found = true;
                                    continue;

                                }
                            }
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                    {
                        var album = p.Master.PieceAlbum.Key;
                        if (!albums.Contains(album))
                        {
                            //if (pathlevel <= MAX_PATH_LEVEL)
                            //{
                            //    if (containsPath(p, paths, pathlevel))
                            //        continue;
                            //}
                            hs.Add(p.PieceId);
                            unsorted.Add(p);
                            pp = p;
                            indexC = i;
                            //indexAlbum = -1;
                            albums.Add(album);
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            artists.Add(cartist);
                            currentArtist = cartist;
                            //   found = true;
                            //  addPath(pp, paths, pathlevel); 
                        }
                    }
                }


                //if (indexAlbum >= 0)
                //{
                //    // pas trouvé d'autre artiste, on se rabat sur l'album
                //    var p = list2[indexAlbum];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexAlbum;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else if (indexArtist >= 0)
                //{
                //    // on a trouvé un autre artiste sur le même album. pas si mal
                //    var p = list2[indexArtist];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexArtist;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else
                //{
                //    // rien trouvé de spécial
                //    if (indexC == 0 && !singleAlbum)
                //    {
                //        singleAlbum = true;
                //    }
                //    indexC = 0;

                //}

                if (indexC == 0)
                {

                    //if (found)
                    //{
                    //    found = false;
                    //}
                    //else
                    //{
                    //{
                    //    if (paths.Count == 0)
                    //    {
                    //        pathlevel = MAX_PATH_LEVEL; 
                    //    }
                    //    if (pathlevel < MAX_PATH_LEVEL)
                    //    {
                    //        pathlevel++;
                    //    }
                    //    else
                    //    {
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        if (mode.HasFlag(unsortMode.album))
                            // on cherche les artistes différents ( éventuellement même album ) 
                            mode &= ~unsortMode.album;
                        else
                        {
                            // on abandonne la recherche artiste et on réactive la recherche album
                            mode &= ~unsortMode.artist;
                            mode |= unsortMode.album;
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                        // on est en mode single album; 
                        mode &= ~unsortMode.album;

                    //pathlevel = 0;
                    //  }
                }
                //}
                // }
                indexC = 0;

            }

            for (int i = 0; i < unsorted.Count; i++)
            {
                unsorted[i].TrackNumber = i + 1;
            }



            //foreach (Piece p in list)
            //{
            //    if (p == null)
            //        continue;
            //    var artist = p.Artist;
            //    FileInfo file = null;
            //    try
            //    {
            //        file = new System.IO.FileInfo(p.Location);
            //    }
            //    catch
            //    {
            //        continue;
            //    }
            //    var dirAlbum = file.Directory;
            //    var dirArtist = dirAlbum.Parent;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = dirArtist.FullName;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = "-";
            //    if (!dictArtist.ContainsKey(artist))
            //        dictArtist.Add(artist, new List<Piece>());
            //    dictArtist[artist].Add(p);

            //    var _album = p.Master.Album;
            //    if (string.IsNullOrEmpty(_album))
            //        _album = dirAlbum.FullName;
            //    dictAlbum.Add(p.PieceId, _album);

            //    //if (!dictAlbum.ContainsKey(_album))
            //    //    dictAlbum.Add(_album, new List<Piece>());
            //    //dictAlbum[_album].Add(p);


            //}

            //foreach (List<Piece> l in dictArtist.Values)
            //{
            //    //
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //var listUnSortArtist = new List<Piece>(list);
            //listUnSortArtist.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));

            //var listUnSortAlbum = new List<Piece>();

            //List<Piece> aux = new List<Piece>();
            //int current = 0;

            //foreach (Piece p in listUnSortArtist)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {
            //        //aux.Add(p);
            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            string xa = x.Master.Album;
            //            string ya = y.Master.Album;
            //            if (dictAlbum.ContainsKey(x.PieceId))
            //                xa = dictAlbum[x.PieceId];
            //            else
            //            { }
            //            if (dictAlbum.ContainsKey(y.PieceId))
            //                ya = dictAlbum[y.PieceId];
            //            else
            //            { }
            //            var cmp = xa.CompareTo(ya);
            //            return cmp;
            //        });

            //        listUnSortAlbum.AddRange(aux);
            //        aux.Clear();

            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    string xa = x.Master.Album;
            //    string ya = y.Master.Album;
            //    if (dictAlbum.ContainsKey(x.PieceId))
            //        xa = dictAlbum[x.PieceId];
            //    else
            //    { }
            //    if (dictAlbum.ContainsKey(y.PieceId))
            //        ya = dictAlbum[y.PieceId];
            //    else
            //    { }
            //    var cmp = xa.CompareTo(ya);
            //    return cmp;
            //});

            //listUnSortAlbum.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnSortAlbum.Count; i++)
            //{
            //    listUnSortAlbum[i].TrackNumber = i + 1;
            //}

            //aux.Clear();
            //current = 0;
            //var listUnsortTrack = new List<Piece>();

            //foreach (Piece p in listUnSortAlbum)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {

            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            var xt = x.MasterTrackNumber;
            //            var yt = y.MasterTrackNumber;
            //            int cmp = 0;
            //            if (xt <= 0 || yt <= 0)
            //            {
            //                try
            //                {
            //                    cmp = x.Location.CompareTo(y.Location);
            //                }
            //                catch
            //                {
            //                }
            //            }
            //            cmp = xt.CompareTo(yt);
            //            return cmp;
            //        });

            //        listUnsortTrack.AddRange(aux);
            //        aux.Clear();
            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    var xt = x.MasterTrackNumber;
            //    var yt = y.MasterTrackNumber;
            //    int cmp = 0;
            //    if (xt <= 0 || yt <= 0)
            //    {
            //        try
            //        {
            //            cmp = x.Location.CompareTo(y.Location);
            //        }
            //        catch
            //        {
            //        }
            //    }
            //    cmp = xt.CompareTo(yt);
            //    return cmp;
            //});

            //listUnsortTrack.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnsortTrack.Count; i++)
            //{
            //    listUnsortTrack[i].TrackNumber = i + 1;
            //}




            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;
            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}
        }

        public bool isSameOf(Album o)
        {
            if (o == this)
                return false;
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && mode == o.mode;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }
        private DateTime albumAdded = DateTime.MaxValue;
        public DateTime AlbumAdded
        {
            get
            {
                if (albumAdded < DateTime.MaxValue)
                    return albumAdded;
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                albumAdded = min;
                return albumAdded;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, virtualMode mode)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();

                if (mode == virtualMode.word)
                {
                    __album = string.Format("¤¤[{0}]", __album);
                    return __album;
                }
                if (mode == virtualMode.list)
                {
                    __album = string.Format("/{0}", __album);
                    return __album;
                }

                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (mode == virtualMode.artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }
                else if (mode == virtualMode.year)
                {
                    if (_album.Length == 3)
                        __album = string.Format("£[{0}0']", __album);
                    else
                        __album = string.Format("£[{0}]", __album);
                }
                else if (mode == virtualMode.extended)
                {
                    __album = string.Format("¤[{0}]", __album);
                }
                else if (mode == virtualMode.added)
                {
                    __album = string.Format("<{0}>", __album);
                }

            }
            return __album;

        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using pdb.gen.auto;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        // private static PieceExtended index;
        //  public static int Index { get { return index; } }
        private static IPieceAlbum median;


        //public static DecimalIndex getMedianne(IList<Piece> list, bool main, decimal coeffMedianne)
        //{

        //    return new DecimalIndex() { d = getMedianne_(list, main, coeffMedianne), index = index };
        //}


        public static DecimalPiece getMedianne(IList<IPieceAlbum> list, bool main, decimal coeffMedianne)
        {
            PieceExtended.Mode = pieceExtendedMode.main;
            var ret = getMedianne_(list, coeffMedianne);
            return new DecimalPiece() { d = ret, index = median };
        }
        private List<IPieceAlbum> pieces;
        private ConfMedianne mode;
        private int _nbNoAdd;
        public AlbumMedianne(List<IPieceAlbum> pieces, ConfMedianne mode)
        {
            this.pieces = pieces;
            this.mode = mode;
            this._nbNoAdd = getNoAdd(mode.Main);
        }



        public void buildVirtual(bool combine, bool simple)
        {

            if (!mode.Min.Use)
            {
                buildVirtual0(mode.Main, true);
                align(mode.Main, pieceExtendedMode.main);
            }
            else
            {
                buildVirtual0(mode.Main, true);
                buildVirtual0(mode.Min, false);

                if (combine)
                {
                    foreach (IPieceAlbum p in pieces)
                        p.Combine();
                    align(mode.Main, pieceExtendedMode.combine);
                }

                if (!simple)
                {
                    align(mode.Main, pieceExtendedMode.main);
                    align(mode.Min, pieceExtendedMode.min);
                }
            }



            //if (!mode.Min.Use)
            //{
            //    buildVirtual0(mode.Main, true);
            //    align(mode.Main, PieceExtended.mode.main);
            //}
            //else if (combine && simple)
            //{
            //    buildVirtual0(mode.Main, true);
            //    buildVirtual0(mode.Min, false);
            //    foreach (PieceExtended p in pieces)
            //        p.Combine();
            //    align(mode.Main, PieceExtended.mode.combine);
            //}
            //else
            //{
            //    buildVirtual0(mode.Main, true);
            //    buildVirtual0(mode.Min, false);
            //    align(mode.Main, PieceExtended.mode.main);
            //    align(mode.Min, PieceExtended.mode.min);

            //    if (combine)
            //    {
            //        foreach (PieceExtended p in pieces)
            //            p.Combine();
            //        align(mode.Main, PieceExtended.mode.combine);
            //    }
            //}
        }

        private int getNoAdd(ConfMedianneVirt modeVirt)
        {

            var safe = modeVirt.safe;
            var _nbNoAdd = 0;

            int i0 = 0;
            int count = pieces.Count;
            if ((modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll) || modeVirt.noAddAll)
                return pieces.Count;
            else if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
            {
                _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
                if (modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll)
                    return _nbNoAdd;
                if (_nbNoAdd > 0)
                    _nbNoAdd--;
            }
            else
            {
                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.Empty)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }
            }

            //if (modeVirt.coeffVirtAuto && modeVirt.coeffVirtAutoAll)
            //    return _nbNoAdd;

            if (modeVirt.noAddEnd)
            {
                // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                // morceaux déjà notés
                var nb2 = pieces.Count<IPieceAlbum>(p => !p.Enabled && !p.Empty);
                _nbNoAdd = _nbNoAdd - nb2;
                if (_nbNoAdd < 0)
                    _nbNoAdd = 0;
            }
            _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

            return _nbNoAdd;
        }

        public void align(ConfMedianneVirt modeVirt, pieceExtendedMode main)
        {
            var count = pieces.Count;
            if (count < 2)
                return;
            PieceExtended.Mode = main;
            pieces.Sort(new PieceCmp0());

            decimal prec = pieces[count - 1].Value;

            var coeffEnabled = modeVirt.CoeffOld;


            for (int j = count - 2; j >= 0; j--)
            {
                var cand = pieces[j].Value;
                bool change = false;
                if (cand == 0)
                    continue;
                if (modeVirt.virtAlignPrec)
                {
                    if (cand < prec)
                    {
                        cand = prec + EPSILON;
                        change = true;
                    }
                }

                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                {

                    // quel serait le score s'il était coché
                    var vu = pieces[j].Value / coeffEnabled;
                    // en plus une petite marge
                    //  vu *= mode.coeffVirt; 
                    if (cand < vu)
                    {
                        cand = vu;
                        change = true;
                    }
                }
                if (change)
                    pieces[j].Value = cand;

                prec = cand;
            }

        }

        //public void align0(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        //{
        //    var count = pieces.Count; 
        //    if (count < 2)
        //        return;
        //    pieces.Sort(new PieceCmp0()); 
        //    //if (main== PieceExtended.mode.main)
        //    //    pieces.Sort(new PieceCmp());
        //    //else if (main == PieceExtended.mode.min)
        //    //    pieces.Sort(new PieceCmp2());
        //    //else
        //    //    pieces.Sort(new PieceCmp3());
        //    decimal prec = 0m;

        //    var coeffEnabled = modeVirt.CoeffOld;

        //    if (modeVirt.virtAlignPrec)
        //    {
        //        //if (_nbNoAdd < pieces.Count)
        //            prec = pieces[_nbNoAdd].Value;
        //    }

        //    for (int j = _nbNoAdd - 1; j >= 0; j--)
        //    {
        //        if (j < pieces.Count)
        //        {

        //            if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //            {
        //                var cand = pieces[j].Value;
        //                if (modeVirt.virtAlignPrec)
        //                {
        //                    if (cand < prec)
        //                        cand = prec + EPSILON;
        //                }

        //                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                {

        //                    // quel serait le score s'il était coché
        //                    var vu = pieces[j].Value / coeffEnabled;
        //                    // en plus une petite marge
        //                    //  vu *= mode.coeffVirt; 
        //                    if (cand < vu)
        //                        cand = vu;
        //                }
        //                pieces[j].Value = cand;

        //            }

        //            prec = pieces[j].Value;
        //        }
        //    }
        //}

        public void buildVirtual0(ConfMedianneVirt modeVirt, bool main)
        {
            DateTime limitDC = DateTime.Now.AddDays(-modeVirt.virtDelay);
            var coeffEnabled = modeVirt.CoeffOld;

            var _coeffVirt = modeVirt.coeffVirt;
            var safe = modeVirt.safe;
            int i0 = 0;

            int count = pieces.Count;
            PieceClassementComparer cmp = null;
            PieceExtended.Mode = main ? pieceExtendedMode.main : pieceExtendedMode.min;

            if (coeffEnabled > 1)
            {
                for (int i = 0; i < count; i++)
                {
                    var p = pieces[i];

                    if (p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
                        p.setCoeff(coeffEnabled, main);
                }
            }

            cmp = new PieceClassementComparer(false, main ? pieceExtendedMode.main : pieceExtendedMode.min);
            pieces.Sort(cmp);

            int indexV = 0;
            int nbAdd = 0;
            var _zero = mode.zero;
            i0 = count - 1;


            int _count = System.Math.Min(count, i0 + safe);
            decimal[] virt = null; // = new decimal[_count];
            //_nbNoAdd = System.Math.Min(safe, _nbNoAdd);
            var _coeffVirt0 = _coeffVirt;

            if (modeVirt.noAdd)
            {
                if (_coeffVirt > 1)
                {
                    if (modeVirt.coeffVirtAuto && (modeVirt.coeffVirtAutoAll || count < safe))
                    // if (count < safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;


                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < pieces.Count)
                        {
                            var dc = pieces[j].Piece.UpdateClassement;

                            if (modeVirt.noVirtZero && pieces[j].Empty)
                                continue;

                            if (modeVirt.forceCoeffVirt)
                                _coeff *= _coeffVirt;
                            else if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
                                _coeff *= _coeffVirt;


                            if (pieces[j].Empty)
                                continue;
                            if (dc == null || dc.Value < limitDC)
                            {
                                pieces[j].Coeff = _coeff; // Value = pieces[j].Value / _coeff;
                            }
                            //pieces[j].EffectMain = coeffEnabled < _coeff;

                        }
                    }
                }

            }
            else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = pieces[i].Value;
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= _coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
            }
            else
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    decimal courant = pieces[0].Value;
                    for (int i = 1; i < _count; i++)
                    {
                        if (pieces[i].Value <= _zero)
                        {
                            courant /= _coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = pieces[i].Value;
                    }
                }
            }

            decimal value = int.MaxValue;


            if (!modeVirt.noAdd)
            {
                int ii = 0;
                if (virt == null)
                    virt = new decimal[_count];
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = pieces[ii].Value;
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (modeVirt.lissage || value <= _zero)
                        {
                            if (value <= _zero)
                                nbAdd++;
                            value = calc;
                            pieces[ii].Value = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (modeVirt.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= safe)
                            continue;
                        pieces[i].Value = 0m;
                    }

                }
                if (mode.removeFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces[i].Value = 0m;
                    }
                }
            }



            if (mode.deleteFirst)
            {
                for (int i = 0; i < nbAdd; i++)
                {
                    pieces.RemoveAt(0);
                }
            }

        }

        //public static int buildVirtual(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, bool main, bool combine, ref int i0)
        //{
        //    var coeffEnabled = modeVirt.CoeffOld;

        //    var _coeffVirt = modeVirt.coeffVirt;
        //    var safe = modeVirt.safe;
        //    if (combine)
        //    {
        //        coeffEnabled = mode.Main.CoeffOld * mode.Min.CoeffOld;
        //        _coeffVirt = mode.Main.coeffVirt * mode.Min.coeffVirt;
        //        safe = (int)Math.Max(mode.Main.safe, mode.Min.safe);
        //    }


        //    //   var coeff = 1 / coeffEnabled; 
        //    int count = pieces.Count;
        //    PieceClassementComparer cmp = new PieceClassementComparer(false);
        //    pieces.Sort(cmp);
        //    //if (coeffEnabled != 1)
        //    //{
        //    if (coeffEnabled > 1)
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            var p = pieces[i];
        //            //  var rapportClassement = p.RapportClassement;
        //            if (coeffEnabled != 1m && p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
        //            {
        //                p.setCoeff(coeffEnabled, main);
        //                //rapportClassement /= coeffEnabled;
        //            }

        //            //p.setClassementVirtuel(rapportClassement);
        //            //if (!main)
        //            //    p.setClassementVirtuel2(rapportClassement);
        //        }
        //    }

        //    cmp = new PieceClassementComparer(false, main ? PieceExtended.mode.main : PieceExtended.mode.min);
        //    pieces.Sort(cmp);
        //    // }

        //    int indexV = 0;
        //    int nbAdd = 0;


        //    // List<Piece> _pieces = pieces;
        //    var _zero = mode.zero;


        //    //if (modeVirt.safe > 0)
        //    //{
        //    i0 = count - 1;
        //    int _nbNoAdd = 0;




        //    if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
        //    {
        //        _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
        //        if (_nbNoAdd > 0)
        //            _nbNoAdd--;
        //    }
        //    else if (modeVirt.noAddAll)
        //        _nbNoAdd = pieces.Count;
        //    else
        //    {
        //        for (int i = 0; i < count; i++)
        //        {
        //            var pp = pieces[i];
        //            if (pp.VirtualClassement == 0m)
        //            {
        //                i0 = i;
        //                _nbNoAdd = count - i0;
        //                break;
        //            }
        //        }
        //    }

        //    if (modeVirt.noAddEnd)
        //    {
        //        // var nb1 = pieces.Count<Piece>(p => p.Enabled);
        //        // morceaux déjà notés
        //        var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
        //        _nbNoAdd = _nbNoAdd - nb2;
        //        if (_nbNoAdd < 0)
        //            _nbNoAdd = 0;
        //    }
        //    //if (i0 == 0)
        //    //    return 0;
        //    //}

        //    //for (int i00 = 1; i00 <= i0; i00++)
        //    //{
        //    //    decimal coeff = (decimal)i00 / (decimal)i0;
        //    //List<decimal> _list = new List<decimal>();
        //    //for (int i = 0; i < pieces.Count; i++)
        //    //    _list.Add(pieces[i].getVirtual(main));
        //    //for (int i = i00; i < count; i++)
        //    //    _list[i] = 0m;
        //    //liste partielle originale
        //    //  List<decimal> _list0 = new List<decimal>(_list);
        //    int _count = System.Math.Min(count, i0 + safe);
        //    decimal[] virt = new decimal[_count];
        //    _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

        //    if (modeVirt.noAdd)
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            // var coeffEnabled = modeVirt.coeffOld; 

        //            if (count < safe && modeVirt.coeffVirtAuto)
        //            {
        //                if (modeVirt.coeffVirtAdjust)
        //                    _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
        //                else
        //                {
        //                    // ex 2^10 = 1024
        //                    // je veux obtenir 1024 avec 3
        //                    _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
        //                }
        //            }

        //            decimal _coeff = 1m;
        //            decimal prec = 0m;
        //            if (modeVirt.virtAlignPrec)
        //            {
        //                if (_nbNoAdd < pieces.Count)
        //                    prec = pieces[_nbNoAdd].Value;
        //            }

        //            for (int j = _nbNoAdd - 1; j >= 0; j--)
        //            {
        //                if (j < pieces.Count)
        //                {

        //                    if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //                    {
        //                        _coeff *= _coeffVirt;
        //                        var cand = pieces[j].Value / _coeff;
        //                        if (modeVirt.virtAlignPrec)
        //                        {
        //                            if (cand < prec)
        //                                cand = prec + EPSILON;
        //                        }

        //                        if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                        {
        //                            // quel serait le score s'il était coché
        //                            var vu = pieces[j].Value / coeffEnabled;
        //                            // en plus une petite marge
        //                            //  vu *= mode.coeffVirt; 
        //                            if (cand < vu)
        //                                cand = vu;
        //                        }
        //                        pieces[j].Value = cand;
        //                        // pieces[j].EffectMain = coeffEnabled < _coeff;
        //                    }
        //                    else if (modeVirt.forceCoeffVirt)
        //                        _coeff /= _coeffVirt;
        //                    prec = pieces[j].Value;
        //                }
        //            }
        //        }

        //    }
        //    else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            for (int i = 0; i < i0; i++)
        //            {
        //                decimal _coeff = 1m;
        //                decimal _base = pieces[i].Value;
        //                for (int j = i + 1; j < _count; j++)
        //                {
        //                    _coeff /= _coeffVirt;
        //                    virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
        //                }
        //            }
        //        }
        //    }
        //    else
        //    {
        //        if (_coeffVirt > 1)
        //        {
        //            decimal courant = pieces[0].Value;
        //            for (int i = 1; i < _count; i++)
        //            {
        //                if (pieces[i].Value <= _zero)
        //                {
        //                    courant /= _coeffVirt;
        //                    virt[i] = courant;
        //                }
        //                else
        //                    courant = pieces[i].Value;
        //            }
        //        }
        //    }

        //    decimal value = int.MaxValue;
        //    int ii = 0;
        //    if (modeVirt.noAdd)
        //    {
        //        //for (ii = 1; ii < count && ii < _count; ii++)
        //        //{
        //        //    var calc = virt[ii];
        //        //    if (calc > 0m)
        //        //        list[ii] = calc;
        //        //}
        //    }
        //    else
        //    {
        //        for (ii = 1; ii < count && ii < _count; ii++)
        //        {
        //            value = pieces[ii].Value;
        //            var calc = virt[ii];
        //            if (value < calc)
        //            {
        //                if (modeVirt.lissage || value <= _zero)
        //                {
        //                    if (value <= _zero)
        //                        nbAdd++;
        //                    value = calc;
        //                    pieces[ii].Value = value;
        //                }

        //            }
        //            else
        //                indexV = ii;
        //        }
        //        if (modeVirt.removeEpsilon)
        //        {
        //            // j'ai 5 virtuel alors que j'ai deux safe
        //            ///xx---
        //            int nb = 0;
        //            for (int i = indexV + 1; i < _count; i++)
        //            {
        //                nb++;
        //                if (nb <= safe)
        //                    continue;
        //                pieces[i].Value = 0m;
        //            }

        //        }
        //        if (mode.removeFirst)
        //        {
        //            for (int i = 0; i < nbAdd; i++)
        //            {
        //                pieces[i].Value = 0m;
        //            }
        //        }
        //    }

        //    //for (int i = 0; i < _list.Count && i < pieces.Count; i++)
        //    //{
        //    //    pieces[i].setValue(_list[i], main); 
        //    //    //if (main)
        //    //    //    pieces[i].setClassementVirtuel(_list[i]);
        //    //    //else
        //    //    //    pieces[i].setClassementVirtuel2(_list[i]);
        //    //}

        //    if (mode.deleteFirst)
        //    {
        //        for (int i = 0; i < nbAdd; i++)
        //        {
        //            pieces.RemoveAt(0);
        //        }
        //    }

        //    if (modeVirt.reSort || mode.removeFirst || modeVirt.noAdd)
        //    {
        //        //_list.Sort();
        //        //_list.Reverse();
        //        if (main)
        //            pieces.Sort(new PieceCmp());
        //        else
        //            pieces.Sort(new PieceCmp2());
        //    }



        //    if (modeVirt.noAdd)
        //        nbAdd = _nbNoAdd;
        //    //}
        //    return nbAdd;
        //}


        public DecimalPiece getMedianneLight(ConfMedianneVirt modeVirt, pieceExtendedMode main)
        {

            DecimalPiece ret0 = new DecimalPiece();
            DecimalPiece ret = ret0;
            try
            {
                var _zero = mode.zero;

                PieceExtended.Mode = main;
                //foreach (PieceExtended p in pieces)
                //    p.Mode = main;

                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = median;
                ret = ret0;


                int i0 = 0;
                int count = pieces.Count;


                ret = calcmedianneVirt(modeVirt);
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<IPieceAlbum>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }




            }
            finally
            {


            }

            return ret;
        }






        //public static DecimalIndex getMedianneLight(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, PieceExtended.mode main, bool combine)
        //{

        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {
        //        var _zero = mode.zero;


        //        foreach (PieceExtended p in pieces)
        //            p.Mode = main;

        //        var medianne = getMedianne_(pieces, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;
        //        ret = ret0;
        //        //if (pieces.Count == 1)
        //        //    return ret0;

        //        int i0 = 0;
        //        int count = pieces.Count;
        //        int nbAdd = buildVirtual(pieces, mode, modeVirt, main, combine, ref i0);
        //        //if (mode.combine && mode.simple)
        //        //{
        //        //    int i1 = 0;
        //        //    buildVirtual(pieces, mode, mode.Min, false, ref i1);
        //        //    foreach (var p in pieces)
        //        //    {
        //        //        p.setClassementVirtuelCombine();
        //        //    }
        //        //}
        //        ret = calcmedianneVirt(pieces, mode, modeVirt, main, nbAdd, System.Math.Min(i0, modeVirt.safe));
        //        if (mode.expEnabled != 0)
        //        {
        //            int _nb = pieces.Count<PieceExtended>(p => !p.Enabled);
        //            decimal _c = (decimal)_nb / (decimal)count;
        //            _c = Math.Pow(_c, mode.expEnabled);
        //            ret.d *= _c;
        //        }




        //    }
        //    finally
        //    {


        //    }

        //    return ret;
        //}

        private class PieceCmp0 : IComparer<IPieceAlbum>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(IPieceAlbum x, IPieceAlbum y)
            {
                int cmp = x.Classement.CompareTo(y.Classement); //   x.RapportClassement.CompareTo(y.RapportClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }


        //private class PieceCmp : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}

        //private class PieceCmp2 : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}

        //private class PieceCmp3 : IComparer<PieceExtended>
        //{
        //    private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        //    public int Compare(PieceExtended x, PieceExtended y)
        //    {
        //        int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
        //        if (cmp != 0)
        //            return -cmp;
        //        return tn.Compare(x, y);
        //    }
        //}




        //private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        //{
        //    var _list = new List<decimal>(list);
        //    int count = _list.Count;

        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        if (_list[count - i - 1] > conf.zero)
        //        {

        //            if (conf.removeLast == removeLast.non)
        //                break;
        //            _nbSupp++;
        //            if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                break;
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}


        private DecimalPiece calcmedianneVirt(ConfMedianneVirt confc)
        {
            int count = pieces.Count;
            var _list = new List<IPieceAlbum>();

            //1=> 1
            //2 =>3
            //3==>5
            int count1 = int.MaxValue;
            for (int i = 0; i < count && i < count1; i++)
            {
                var p = pieces[i];
                if (p.Classement.isZero() && count1 == int.MaxValue)
                {
                    var c = i;
                    count1 = 2 * i - 1;
                }

                _list.Add(p);
            }

            var classes = pieces.FindAll(p => !p.Empty);

            if (confc.oldAsZero)
                classes = pieces.FindAll(p => p.LastClassementRecent);



            int nbEnabled = classes.Count<IPieceAlbum>(p => p.Enabled);
            int nbDisabled = classes.Count<IPieceAlbum>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled);




            DecimalPiece ret = new DecimalPiece() { d = 0m, index = null }; // 0m; // decimal ret = int.MinValue;
            if (pieces.Count > 0)
                ret.index = pieces[0];
            int _nbSupp = 0;
            decimal coeffp = 1m;

            bool beginBorder = false;
            count1 = _list.Count;
            for (int i = 0; i < count1; i++)
            {
                int ilast = _list.Count - 1;
                var last = _list[ilast];
                if (i > 0)
                {
                    if (last.Empty)
                        _list.RemoveAt(ilast);
                    else
                        break;
                    ilast = _list.Count - 1;
                    if (ilast < 0)
                        break;
                    last = _list[ilast];
                    if (mode.puissance > 1m)
                    {
                        if (coeffp < 1e-15m)
                            coeffp = 1e-15m / (decimal)i;
                        else if (coeffp < 1e-12m)
                        {
                            coeffp = 1e-12m / ((decimal)i * i);
                            if (coeffp < 1e-15m)
                                coeffp = 1e-15m / (decimal)i;
                        }
                        else
                            coeffp /= mode.puissance;

                        if (coeffp < 1e-15m)
                            coeffp = 1e-15m / (decimal)i;
                        else if (coeffp < 1e-12m)
                        {
                            coeffp = 1e-12m / ((decimal)i * i);
                            if (coeffp < 1e-15m)
                                coeffp = 1e-15m / (decimal)i;
                        }

                        if (coeffp < 0)
                            coeffp = 0;
                    }
                }

                var aux = getMedianne_(_list, mode.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = last;
                }
                int offset = 0;
                if (count1 < count)
                    offset = count - count1;

                var coeff0 = 1 - ((decimal)i + offset) / (decimal)count; // (decimal)count - i / (decimal)count;
                if (mode.quasi > 1)
                    coeff0 = Math.Pow(coeff0, mode.quasi);

                decimal coeff = coeff0;
                if (coeff < coeffp)
                {
                }
                else
                {
                    coeff = coeffp;
                }





                if (coeff == 0m)
                    break;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = median;
                    ret.indexBorderEffect = last;
                }

                ret.indexBorderMin = last;
                var p = last;

                if (!p.Empty && (!confc.oldAsZero || p.LastClassementRecent))
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--;

                    if (!p.Enabled || !mode.removeEnabled || mode.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((mode.removeLast == removeLast.non || mode.removeLast == removeLast.unselected) && nbEnabled < 0)
                            break;

                        if (mode.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break;
                        }
                        _nbSupp++;
                    }
                }


            }


            return ret;
        }

        //private static DecimalIndex calcmedianneVirt(IList<PieceExtended> list, ConfMedianne conf, ConfMedianneVirt confc, bool main, int nbAdd, int nbDel)
        //{
        //    var _list = new List<PieceExtended>(list);
        //    var classes = _list.FindAll(p => p.VirtualClassement > conf.zero);

        //    if (confc.oldAsZero)
        //        classes = _list.FindAll(p => p.LastClassementRecent);

        //    int count = _list.Count;

        //    int nbEnabled = classes.Count<PieceExtended>(p => p.Enabled);
        //    int nbDisabled = classes.Count<PieceExtended>(p => !p.Enabled);
        //    int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    //int _nbSuppDisabled = 0;
        //    //int _nbSuppEnabled = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {
        //            //var d = _list[count - i];
        //            //if (d.Enabled)
        //            //    nbEnabled--;
        //            //else
        //            //    nbDisabled--;

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        ret.indexBorderMin = count - i - 1;
        //        var p = _list[count - i - 1];

        //        if (p.VirtualClassement > conf.zero && (!confc.oldAsZero || p.LastClassementRecent))
        //        {
        //            // je regarde si le morceau est désactivé
        //            // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
        //            if (p.Enabled)
        //                nbEnabled--;
        //            else
        //                nbDisabled--;
        //            nbdispo--;

        //            if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
        //            {
        //                //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
        //                //if (priseEncompte)
        //                //{
        //                if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected) && nbEnabled < 0)
        //                    break;

        //                if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
        //                {
        //                    if (nbdispo < 0)
        //                        break;
        //                }

        //                _nbSupp++;
        //                if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                    break;
        //                // }


        //            }
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}



        //private static decimal getMedianne_(IList<PieceExtended> list, bool main, decimal coeffMedianne)
        //{
        //    var l = new List<decimal>();
        //    foreach (PieceExtended p in list)
        //    {
        //        if (main)
        //            l.Add(p.VirtualClassement); 
        //        else
        //            l.Add(p.VirtualClassement2); 
        //    }

        //    return CalcMedianne.getMedianneDec(l, coeffMedianne); 
        //}

        //private static decimal getMedianne_(IList<Piece> list, bool main, decimal coeffMedianne)
        //{
        //    var l = new List<decimal>();
        //    foreach (Piece p in list)
        //    {
        //        if (main)
        //            l.Add(p.VirtualClassement);
        //        else
        //            l.Add(p.VirtualClassement2);
        //    }

        //    return CalcMedianne.getMedianneDec(l, coeffMedianne);
        //}


        private static decimal getMedianne_(IList<IPieceAlbum> list, decimal coeffMedianne)
        {

            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1 || coeffMedianne == 1)
            {
                median = list[0];
                return median.Value;
            }

            if (coeffMedianne == 1)
            {
                median = list[count - 1];
                return median.Value;
            }

            var medianne = coeffMedianne * (count - 1);

            var index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].Value;

            median = list[index];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
            {
                return val0;
            }
            median = list[i1];
            var val1 = list[i1].Value;
            return val1;

            //if (Math.Abs(medianne - i1) < PRECISION)
            //{
            //    median = list[i1];
            //    return val1;
            //}
            //if (val1 < PRECISION)
            //{
            //    median = list[i1];
            //    return val1;
            //}
            //var dx = medianne - index;


            //// var ret = val0 + pente * dx;


            //// moyenne avec calcul de log
            //var log0 = Math.Log(val0 + EPSILON_LOG);
            //var log1 = Math.Log(val1 + EPSILON_LOG);
            //// pente = log1 - log0;
            //var log = log0 + (log1 - log0) * dx;
            //return Math.Exp(log) - EPSILON_LOG;


        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\CConf.cs">
    <content><![CDATA[using System;
using System.IO;
using System.Xml;
using pdb.gen.Tuning;
using pdb.ordo.conf;
using pdb.util;
using pdb.gen.albums;
namespace pdb.gen.conf
{
    public enum rankingType
    {
        middle = 0,
        up = 1,
        bottom = 2
    }


    public class CConf
    {
        private static volatile object _lock = new object();
        private const string CONF_FILE = TuningBase.DIR_CONF + "pdb.conf.xml";
        private static string m_listBase = "classement";
        private static int m_before = 0;
        private static int m_after = 0;
        private static bool m_checkModifStrict = true;
        private static bool scan = false;
        private static string copyTo = "";
        private static bool copyModeFile = false;
        private static CConfSort m_sort = new CConfSort();
        private static int classementOffset = 0;
        private static rankingType _rankingType = rankingType.middle;
        // private static bool deleteFile;
        private static int maxTask = int.MaxValue;

        private static CConfSort m_select = new CConfSort();
        private static ConfGen confGen = new ConfGen();

        private static bool removeVersions;
        private static bool condensation;

        private static bool selectAuto;
        private static string dispatcherPriority = "";

        private static int displayImg = 0;

        // private static int taskDelayError = -1;

        private static bool menage = false;


        private static bool ordonnancement;

        //  private static DataConf dataConf;
        private static ConfOrdo ordoConf = new ConfOrdo();



        private static int volumeMin = -125;
        private static bool abortOpe;

        private static Export export = new Export();
        private static Import import = new Import();

        /// <summary>
        /// Temps en secondes entre deux gcCollect
        /// </summary>
        private static double gcCollect = int.MaxValue;

        private static int colorMotifSeuil = 1;

        private static bool compact;

        private static ZeroWorkConf zeroWorkConf = new ZeroWorkConf();

        public static XmlElement loadConf()
        {
            lock (_lock)
            {
                misc.log("load conf");
                if (!File.Exists(CONF_FILE))
                    return null;
                XmlDocument l_doc = new XmlDocument();
                l_doc.Load(CONF_FILE);
                XmlElement l_xmlRoot = l_doc.DocumentElement;
                XMLTool l_xmlConf = new XMLTool(l_xmlRoot);

                string l_str = l_xmlConf.getNodeValue("listBase");
                if (!string.IsNullOrEmpty(l_str))
                    m_listBase = l_str;

                l_str = l_xmlConf.getNodeValue("before");
                if (!string.IsNullOrEmpty(l_str))
                    m_before = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("after");
                if (!string.IsNullOrEmpty(l_str))
                    m_after = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("checkModifStrict");
                if (!string.IsNullOrEmpty(l_str))
                    m_checkModifStrict = Convert.ToBoolean(l_str);

                l_str = l_xmlConf.getNodeValue("scan");
                if (!string.IsNullOrEmpty(l_str))
                    scan = Convert.ToBoolean(l_str);

                l_str = l_xmlConf.getNodeValue("copyTo");
                if (!string.IsNullOrEmpty(l_str))
                {
                    copyTo = l_str;
                    l_str = l_xmlConf.getAttValue("copyTo", "copyModeFile");
                    if (!string.IsNullOrEmpty(l_str))
                        copyModeFile = Convert.ToBoolean(l_str);
                }

                l_str = l_xmlConf.getNodeValue("classementOffset");
                if (!string.IsNullOrEmpty(l_str))
                    classementOffset = Convert.ToInt32(l_str);
                l_str = l_xmlConf.getNodeValue("rankingType");
                if (!string.IsNullOrEmpty(l_str))
                    _rankingType = (rankingType)Enum.Parse(typeof(rankingType), l_str);



                l_str = l_xmlConf.getNodeValue("maxTask");
                if (!string.IsNullOrEmpty(l_str))
                    maxTask = Convert.ToInt32(l_str);







                l_str = l_xmlConf.getNodeValue("volumeMin");
                if (!string.IsNullOrEmpty(l_str))
                    volumeMin = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("gcCollect");
                if (!string.IsNullOrEmpty(l_str))
                    gcCollect = Convert.ToDouble(l_str);


                l_str = l_xmlConf.getNodeValue("colorMotifSeuil");
                if (!string.IsNullOrEmpty(l_str))
                    colorMotifSeuil = Convert.ToInt32(l_str);



                removeVersions = l_xmlConf.getBoolValue("removeVersions", false);
                condensation = l_xmlConf.getBoolValue("condensation", false);

                selectAuto = l_xmlConf.getBoolValue("selectAuto", false);
                abortOpe = l_xmlConf.getBoolValue("abortOpe");


                l_str = l_xmlConf.getNodeValue("dispatcherPriority");
                if (!string.IsNullOrEmpty(l_str))
                    dispatcherPriority = l_str;

                l_str = l_xmlConf.getNodeValue("displayImg");

                if (!string.IsNullOrEmpty(l_str))
                    displayImg = Convert.ToInt32(l_str);



                ordonnancement = l_xmlConf.getBoolValue("ordonnancement");

                menage = l_xmlConf.getBoolValue("menage", false);



                m_sort = new CConfSort(l_xmlConf.NodeLookUp("sort"), 0.5m);
                m_select = new CConfSort(l_xmlConf.NodeLookUp("selection"), 1);

                confGen = new ConfGen(l_xmlConf.NodeLookUp("gen"));
                // Album.Medianne = confGen.Medianne; 


                //   dataConf = new DataConf(l_xmlConf.NodeLookUp("data"));

                ordoConf = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

                export = new Export(l_xmlConf.NodeLookUp("export"));
                import = new Import(l_xmlConf.NodeLookUp("import"));
                zeroWorkConf = new ZeroWorkConf(l_xmlConf.NodeLookUp("zeroWork"));

                compact = l_xmlConf.getBoolValue("compact");








                return l_xmlRoot;
            }

        }


        public static string ListBase
        {
            get { return m_listBase; }
        }

        public static ConfGen ConfGen
        {
            get { return confGen; }
        }

        public static CConfSort Sort
        {
            get { return m_sort; }
        }
        public static CConfSort Select
        {
            get { return m_select; }
        }
        public static int Before
        {
            get { return m_before; }
        }
        public static int After
        {
            get { return m_after; }
        }
        public static bool CheckModifStrict
        {
            get { return m_checkModifStrict; }
        }
        public static int MaxTask { get { return maxTask; } }
        public static rankingType RankingType { get { return _rankingType; } }

        public static bool Scan { get { return scan; } }
        public static string CopyTo { get { return copyTo; } }

        public static bool CopyModeFile { get { return copyModeFile; } }

        public static int ClassementOffset { get { return classementOffset; } }

        // public static bool DeleteFile { get { return deleteFile; } }

        // public static DataConf DataConf { get { return dataConf; } }

        public static bool RemoveVersions { get { return removeVersions; } }
        public static bool Condensation { get { return condensation; } }

        public static bool SelectAuto { get { return selectAuto; } }
        public static string DispatcherPriority { get { return dispatcherPriority; } }



        //  public static int TaskDelayError { get { return taskDelayError; } }

        public static bool Menage { get { return menage; } }


        public static bool Ordonnancement { get { return ordonnancement; } }
        public static bool AbortOpe { get { return abortOpe; } }

        //public static int MaxScan { get { return maxScan; } }
        public static int VolumeMin { get { return volumeMin; } }


        public static ConfOrdo ConfOrdo { get { return ordoConf; } }

        public static Export Export { get { return export; } }
        public static Import Import { get { return import; } }
        public static double GcCollect { get { return gcCollect; } }
        public static bool Compact { get { return compact; } }

        public static int DisplayImg { get { return displayImg; } }



        public static int ColorMotifSeuil { get { return colorMotifSeuil; } }

        public static ZeroWorkConf ZeroWorkConf { get { return zeroWorkConf; } }
        public static string display()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(String.Format("base:{0} before:{1} after: {2} select:{3} sort:{4}", m_listBase, m_before, m_after, m_select, m_sort));
            sb.AppendLine(confGen.ToString());
            sb.AppendLine(ordoConf.ToString());

            return sb.ToString();
        }

    }


    public enum ConfType
    {
        sort,
        selection
    }
}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfMedianne.cs">
    <content><![CDATA[using System;
using pdb.gen.medianne;
using pdb.util;
using System.Xml;
using pdb.gen.auto;

namespace pdb.gen.Tuning
{
    [Serializable]
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public decimal quasi = 1m;

        public bool enabled;
        public decimal puissance = 1m;



        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast;

        public decimal expEnabled = 0m;

        public decimal zero = 0m;
        /// <summary>
        /// 
        /// </summary>
        public bool removeEnabled;
        /// <summary>
        /// cumule l'influence des deux parties main et min
        /// </summary>
        public bool combine;
        /// <summary>
        /// calcul simple des selectedMotif
        /// </summary>
        public bool simple;
        /// <summary>
        /// auto : si motifExclu on ne peut pas avoir un composant qui descent en même temps qu'un composant qui monte
        /// </summary>
        public bool motifExclu;
        /// <summary>
        /// Lors de la détermination du next; s'il est à zero, on force vers le keep
        /// </summary>
        public bool forceKeep;

        /// <summary>
        /// Lors de la détermination du next; s'il est à zero, on force vers le keep2
        /// </summary>
        public bool forceKeep2;

        /// <summary>
        /// Keep sert seulement à pas êter à zero. le classementValueLight ne doit pas baisser à cause d'un Keep
        /// </summary>
        public bool dontDownByKeep;



        public modeMin cmpMin;

        private ConfMedianneVirt _main;
        private ConfMedianneVirt _min;

        public ConfMedianneVirt Main { get { return _main; } }
        public ConfMedianneVirt Min { get { return _min; } }

        public ConfMedianne()
        {
            _main = new ConfMedianneVirt();
            _min = new ConfMedianneVirt();

        }

        public void makeIdem()
        {
            _min = _main;
        }

        public void duplicateMainIf()
        {
            if (_min == _main)
                _min = new ConfMedianneVirt(_main);
        }

        public ConfMedianne(ConfMedianne o, bool raz)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;

            enabled = o.enabled;



            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;

            expEnabled = o.expEnabled;

            zero = o.zero;
            removeEnabled = o.removeEnabled;



            cmpMin = o.cmpMin;

            _main = new ConfMedianneVirt(o._main, raz);
            _min = new ConfMedianneVirt(o._min, raz);

            this.simple = o.simple;
            this.combine = o.combine;
            this.motifExclu = o.motifExclu;
            this.puissance = o.puissance;
            this.forceKeep = o.forceKeep;
            this.forceKeep2 = o.forceKeep2;
            this.dontDownByKeep = o.dontDownByKeep;
        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            builddec("quasi", v => quasi = v);
            buildb("enabled", v => enabled = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);
            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v);
            string _modeMin = "";
            builds("cmpMin", v => _modeMin = v);
            if (!string.IsNullOrEmpty(_modeMin))
                cmpMin = (modeMin)Enum.Parse(typeof(modeMin), _modeMin, true);

            string _removeLast = null;
            builds("removeLast", v => _removeLast = v);
            removeLast = (removeLast)Enum.Parse(typeof(removeLast), _removeLast, true);

            buildb("combine", v => combine = v);
            buildb("simple", v => simple = v);
            buildb("motifExclu", v => motifExclu = v);

            builddec("puissance", v => puissance = v);
            buildb("forceKeep", v => forceKeep = v);
            buildb("forceKeep2", v => forceKeep2 = v);
            buildb("dontDownByKeep", v => dontDownByKeep = v);

            _main = null;
            _min = null;
            var subs = XMLTool.NodeLookUp(child, "virts");
            if (subs != null)
            {
                foreach (XmlNode _n in subs.ChildNodes)
                {
                    if (_n is XmlElement)
                    {
                        if (_main == null)
                        {
                            _main = new ConfMedianneVirt(child, _n as XmlElement);

                        }
                        else if (_min == null)
                        {
                            _min = new ConfMedianneVirt(child, _n as XmlElement);
                        }
                    }
                }
                if (_min == null && _main != null)
                    _min = new ConfMedianneVirt(_main);
            }
        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("cmp");
            write("type", type);
            write("medianne", medianne);
            write("quasi", quasi);
            write("puissance", puissance);
            write("enabled", enabled);
            write("removeFirst", removeFirst);
            write("deleteFirst", deleteFirst);
            write("expEnabled", expEnabled);
            write("zero", zero);
            write("removeEnabled", removeEnabled);
            write("cmpMin", cmpMin);
            write("removeLast", removeLast);
            write("combine", combine);
            write("simple", simple);
            write("motifExclu", motifExclu);
            write("forceKeep", forceKeep);
            write("forceKeep2", forceKeep2);
            write("dontDownByKeep", dontDownByKeep);

            writeStart("virts");
            _main.save(w);
            _min.save(w);
            writeEnd();

            writeEnd();



        }


        //public void auto(selectedCoeff motif)
        //{
        //    if (!enabled)
        //        return;
        //    if (motif == selectedCoeff.none)
        //        return;
        //    var coeffPrisEncompte = motif > selectedCoeff.noCoeff;
        //    if (_min == _main || (_min.coeffVirt == 1m && !_min.coeffOldSwap))
        //    {
        //        _main.calcAuto(coeffPrisEncompte);
        //    }
        //    else
        //    {
        //        if (coeffPrisEncompte)
        //        {
        //            if (motif == selectedCoeff.main)
        //                _main.calcAuto(true);
        //            if (motif == selectedCoeff.min)
        //                _min.calcAuto(true);
        //        }
        //        else
        //        {
        //            _main.calcAuto(false);
        //            _min.calcAuto(false);
        //        }
        //    }
        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ZeroWorkConf.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;

namespace pdb.gen.Tuning
{
    public class ZeroWorkConf : TuningBase
    {
        public bool enabled;
        public bool alwaysKeep;
        public bool keep2Enabled;
        public bool alwaysKeep2;
        public ZeroWorkConf()
            : base()
        { }

        public ZeroWorkConf(XmlElement node) : base(node)
        {
            if (node == null)
                return;
            buildb("enabled", v => enabled = v);
            buildb("alwaysKeep", v => alwaysKeep = v);
            buildb("keep2Enabled", v => keep2Enabled = v);
            buildb("alwaysKeep2", v => alwaysKeep2 = v);
        }
    }
}
]]></content>
  </file>
</db>
