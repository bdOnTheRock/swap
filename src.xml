<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub
    {
        private int albumRating;
        private bool ratingComputed;

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;

        public int DbId { get { return _dbId; } set { if (_dbId <=0) _dbId = value; } }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        private LimitItem exclu;
        public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            var key = item.ID;
            if (!listLoad0.ContainsKey(key))
                listLoad0.Add(key, item);
        }
        public bool containsload(LimitItem item)
        {
            var key = item.ID;
            return listLoad0.ContainsKey(key);
        }

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        public bool containsSelect(LimitItem item)
        {
            var key = item.ID;
            return listSelected.ContainsKey(key);
        }
        public bool isPreselected { get { return listLoad0.Count > 0; } }
        public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {
                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            this.albumRating = track.AlbumRating;
            this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            if (track.PlayedCount > 0)
            {
                played = markAsPlayed(Rating, PlayedDate);
            }

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Comment != commentByReleaseDate)
                    {
                        misc.log("chgt Comment � partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Comment = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Comment;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Comment)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment � partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Comment = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de g�rer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }
        public static bool markAsPlayed(int rating, DateTime date)
        {
            if (maxPlayed.ContainsKey(rating))
                return date > maxPlayed[rating];
            return true;
        }
        public override void build(XmlNode xTrack)
        {
            base.build(xTrack);
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Rating Computed")
                        ratingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break;
                    case "Play Count": playedCount = Convert.ToInt32(value);
                        if (playedCount > 0)
                            played = markAsPlayed(Rating, PlayedDate);
                        break;
                    case "Album Rating": albumRating = Convert.ToInt32(value); break;
                }

            }

            //for (int i = 0; i < xTrack.ChildNodes.Count; i += 2)
            //{
            //    XmlNode xKey = xTrack.ChildNodes[i];
            //    string value = xTrack.ChildNodes[i + 1].InnerText;
            //    string key = xKey.InnerText;

            //    if (string.IsNullOrEmpty(value))
            //        continue;
            //    switch (xKey.InnerText)
            //    {
            //        case "Date Added": added = Convert.ToDateTime(value); break;
            //        case "Release Date": pub = Convert.ToDateTime(value); break;
            //        case "Play Count": int playCount = Convert.ToInt32(value); if (playCount > 0) played = true; break;
            //        case "Album Rating": albumRating = Convert.ToInt32(value); break;


            //    }
            //}


            new PubLoader(this).setPub();

            #region move vers pubLoader
            //
            //string _comment = Comment;
            //DateTime dateComment = DateTime.MinValue;

            //try
            //{
            //    dateComment = Convert.ToDateTime(_comment);
            //}
            //catch
            //{
            //}

            //if ((pub < MIN || pub.DayOfYear == 1)  && (dateComment > MIN && dateComment.DayOfYear > 1))
            //{
            //    pub = dateComment; 
            //}
            //string name = Name;
            //checkDate1(name);
            //checkDate2(name);
            //checkDate3(name);

            //bool pubYear = false;

            //if (!string.IsNullOrEmpty(Location))
            //{
            //    string fileName = Path.GetFileName(Location);
            //    checkDate1(fileName);
            //    checkDate2(fileName);
            //    checkDate3(fileName);
            //}

            //if (pub <= MIN)
            //{
            //    if (Year > 1970)
            //    {
            //        DateTime dtYear = new DateTime(Year, 1, 1);
            //        pub = dtYear;
            //        pubYear = true;
            //    }
            //}



            //if (added < MIN) added = MIN;

            //// DateTime dt_ = pub;
            //if (pub <= MIN)
            //    pub = added;
            //string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
            //if (pubYear)
            //    comment = getFileNameCmp(comment);
            //if (this.Comment != comment)
            //{
            //    try
            //    {
            //        string commentFound = this.Comment;
            //        string truc = commentFound;
            //        if (truc.Contains("_")) 
            //        {
            //            //d�j� fait
            //            return; 
            //        }
            //          //  truc = truc.Split('_')[0];

            //        DateTime iComment = Convert.ToDateTime(truc);
            //        if (iComment.DayOfYear != 1 && pub.DayOfYear == 1)
            //        {
            //            pub = iComment;
            //        }
            //        else
            //        {

            //            this.Comment = comment;
            //        }
            //    }
            //    catch
            //    {
            //        this.Comment = comment;
            //    }
            //}


            //

            #endregion




            duree = new util.timeSpan(Duration);
        }



        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        public DateTime Pub { get { return pub; } }

        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        public DateTime Added { get { return added; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        private bool info;

        public bool Info
        {
            get { return info; }
            set { if (value) info = true; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        private bool rare;
        public bool Rare
        {
            get { return rare; }
            set { if (value) rare = true; }
        }

        private bool played;
        public bool Played { get { return played; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        private bool inJournal = false;

        public bool FreeInJournal { get { return Selected && !inJournal; } }
        public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        private void clearLists()
        {
            selected = selectMode.none;
            exclu = null;
            inJournal = false;
            listSelected = new SequentialDictString<LimitItem>();
            listLoad0 = new SequentialDictString<LimitItem>();
            listStandAlone = new SequentialDictString<LimitItem>();
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }

        private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (value == selectMode.standAlone)
            {
                if (!listStandAlone.ContainsKey(key))
                    listStandAlone.Add(key, limit);
            }
            else
            {
                if (!listSelected.ContainsKey(key))
                    listSelected.Add(key, limit);
            }


            if (selected == value)
                return;

            if (value > selectMode.standAlone)
            {

                selected = value;
                int volume = Volume;
                if (Album.Contains("RFI"))
                {
                    if (volume != -20)
                        Volume = -20;
                }
                else
                {
                    if (volume < volumeMin)
                        Volume = volumeMin;
                }


                if (pub > MIN)
                {


                    string infoShort = pub.ToString("dd.MM.yy");
                    string infoPubName = pub.ToString("dd.MM.yyyy");
                    string infoPubName2 = pub.ToString("dd/MM/yyyy");
                    string infoPubName3 = pub.ToString("dd/MM/yy");
                    string infoYear = Year.ToString();
                    if (pub.DayOfYear == 1)
                    {
                        infoPubName = pub.Year.ToString();
                        infoPubName2 = infoPubName;
                        infoPubName3 = infoPubName;
                        infoShort = infoPubName;
                    }

                    string name = Name;
                    string str = name;

                    if (regInfoShort.IsMatch(str))
                    {
                        var strdate = regInfoShort.Match(str).Groups[1].Value;
                        str = str.Replace(strdate, "");
                    }






                    if (str.Contains(infoPubName))
                        str = str.Replace(infoPubName, infoShort);
                    else if (name.Contains(infoPubName2))
                        str = str.Replace(infoPubName2, infoShort);

                    else
                    {
                        if (!str.Contains(infoShort))
                        {
                            str = str + " " + infoShort;
                        }
                        else
                        {
                            if (Year > 1980 && str.Contains(infoYear))
                                str = str.Replace(infoYear, "").Trim();
                        }
                    }
                    var strBUG = "30.12.99";
                    if (str.Contains(strBUG))
                        str = str.Replace(strBUG, "");

                    str = str.Replace("  ", " ");
                    str = str.Replace("  ", " ");
                    str = str.Replace("  ", " ").Trim();

                    if (!str.Equals(name))
                        Name = str;
                }

            }

        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
            }
        }

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            set
            {
                setGrouping(this.Comment, true);
                Comment = value;
            }
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree { get { return duree; } }
        public bool RatingComputed { get { return ratingComputed; } }
        public int AlbumRating { get { return albumRating; } }
        private int playedCount; 
        public int PlayedCount { get { return playedCount; } }


    }
}



]]></content>
  </file>
  <file path="\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Xml;
using pdb.util.Generic.Parse;
using pdb.util.Generic;
using System.Reflection;

namespace pdb.podcast.DB
{
    class Db
    {
        public const int CURRENT_VERSION = 1;
        const string SEQ_PIECE = "seq";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        private PropertyInfo[] props; 
       
     //   private XmlSerializer xmlSerializer;

        public Db()
        {
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};

            props = typeof(TrackInfoItunes).GetProperties(); 
        }


        public void write(string file)
        {
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(file + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                foreach (TrackInfoItunes track in dict.Values)
                {
                    
                }
                writer.WriteEndDocument();
                writer.Flush();
            }

            //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
        }

        private  void write(XmlWriter writer, TrackInfoItunes track)
        {
            writer.WriteStartElement("t");
            writer.WriteAttributeString("id", track.DbId.ToString());
            string path = track.Location.Replace(TrackInfoItunes.DefaultFolder, "");
            writer.WriteElementString("path", path); 
            foreach (PropertyInfo prop in props)
            {
                switch (prop.Name)
                {
                    case "Name":
                    case "Album":
                    case "Rating":
                    case "AlbumRating":
                    case "RatingComputed": 
                    case "Pub":
                    case "PlayedDate":
                   
                   
                    write(writer, prop, track); break;                         
                    default: break;
                }
            }
            writer.WriteEndElement(); 

        }

        private static void write(XmlWriter writer, PropertyInfo prop, TrackInfoItunes track)
        { 
            var value = prop.GetValue(track, null);
            var str = ""; 
            if (value != null)
                str = value.ToString();
            writer.WriteElementString(prop.Name, str); 
        }
      
    }
}
]]></content>
  </file>
</db>
