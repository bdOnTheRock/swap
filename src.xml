<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.ordo\BackGroundTaskMgr.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using pdb.ordo.conf;
using pdb.util;
using pdb.obj;
using System.IO;
using System.Globalization;
using pdb.ordo.persistance;
using Math = System.Math; 

namespace pdb.ordo
{

    public class BackGroundTaskMgr
    {
        public const int NB_PROC = 5;
        private ThreadUtil th;
        private static ThreadUtil sTh;
        private bool async = true;
        private int nb;
        private bool classAbort;
        private double ms = 1;
        private double cms = 1;
        private double[] msProc = new double[NB_PROC];
        //private double msProc = 0;
        //private double msProc2 = 0;
        private double[] msProcStop = new double[NB_PROC];
        //private double msProcStop = 0;
        //private double msProcStop2 = 0; 
        private bool used;
        private static ConfOrdo conf = new ConfOrdo();
        private DateTime lastActivity = DateTime.Now;
        private static Logger log = Logger.getLogger("Bg");
        private static Logger logOrdo = Logger.getLogger("Ordo", log);
        private static bool playing;
        public static bool Playing
        {
            set
            {
                if (playing != value)
                {
                    log.log("changement status playing:=>{0}", value);
                    playing = value;
                }
            }
            get { return playing; }
        }
        // private static bool _abortSpecial = false; 

        #region obs
        private static List<Action> observersImportant = new List<Action>();
        public static void addObserverImportant(Action obs) { observersImportant.Add(obs); }
        private static void OnImportantTask()
        {
            foreach (Action obs in observersImportant)
                obs();
        }

        private static List<Action> observersClass = new List<Action>();
        public static void addObserverClass(Action obs) { observersClass.Add(obs); }
        private static void OnClassTask()
        {
            foreach (Action obs in observersClass)
                obs();
        }
        #endregion
        public static ConfOrdo Conf
        {
            set
            {
                conf = value;
                _ordonnancement = conf.Enable;
                taskDelayError = conf.TaskDelayError;
                gcCollect = conf.GcCollect;
                gcCollectLoop = conf.GcCollectLoop;
                gcCollectElu = conf.GcCollectElu;
                gcCollectReset = conf.GcCollectReset;
                lock (_lockS)
                {
                    foreach (BackGroundTaskMgr bg in persistList)
                    {
                        bg.classAbort = conf.getClassAbort(bg.name);
                        if (bg.name.StartsWith("scan"))
                        {
                            var p = conf.getScanPriority(scanPriority.low);
                            if (p != null)
                            {
                                bg.increasePriority(p.priority);
                                bg.coeff = p.coeff;
                            }
                        }
                        else
                        {
                            var p = conf.getPriority(bg.name);
                            if (p != null)
                            {
                                bg.increasePriority(p.priority);
                                bg.coeff = p.coeff;
                            }
                        }
                    }
                }

            }
        }
        // private bool _shutdown = true;
        //private int nbTh;
        //   private List<IBgtask> tasks = new List<IBgtask>(); 

        /// <summary>
        /// Empiler sans dépiler
        /// </summary>
        private bool _pause = true;
        private string name;
        //  public string Name { get { return name; } }

        private static bool _ordonnancement;
        public static bool Ordonnancement
        {
            //set
            //{
            //    _ordonnancement = value;
            //}
            get { return _ordonnancement; }
        }
        private int priority = 0;
        private float coeff = 1f;
        private bool persistent;

        private int Priority
        {
            set
            {
                //if (value != priority)
                //{
                //    log.logNoDate("+++++++++++++++++++++++++++++++++");
                //    log.log("{0} Changement de priorité de {1} à {2}", this, priority, value);
                //if (value == 0 && name != "Classement")
                //{
                //    int toto = 0; 
                //}
                priority = value;
                //}
            }
        }


        private void increasePriority(int p)
        {
            if (p == 0)
                return;
            if (p == int.MaxValue)
                return;
            if (p > priority)
                return;
            priority = p;
        }
        public void makePersistent() { persistent = true; }


        private Logger logger;
        private static PersistMgr persistMgr;
        static BackGroundTaskMgr()
        {
            try
            {
                persistMgr = new PersistMgr("..\\ordo.txt");
                var list = persistMgr.Deserialise();
                foreach (var p in list)
                {
                    int pr = 123456;
                    if (p.ID.Equals("Classement"))
                        pr = 0;
                    var bg = getMgr(p.ID, pr, false, true);
                    bg.msProc = p.msProc;
                    bg.ms = p.ms;

                    bg.msProcStop = p.msProcStop;

                }
            }
            catch (Exception ex)
            {
                log.log("impossible de récupérer la persistance " + ex.ToString());
                throw;
            }
        }
        public static void recordMsProc()
        {
            Console.WriteLine("début recordMsProc");
            var list = new List<PersistTaskMgr>();
            double[] total = new double[NB_PROC];
            double[] totalStop = new double[NB_PROC];
            lock (_lockS)
            {

                foreach (BackGroundTaskMgr bg in persistList)
                {
                    var val = calc0(bg);
                    var p = new PersistTaskMgr(bg.name, bg.ms, bg.msProc, bg.msProcStop, bg.nb, val);
                    for (int i = 0; i < BackGroundTaskMgr.NB_PROC; i++)
                    {
                        total[i] += bg.msProc[i];
                        totalStop[i] += bg.msProcStop[i];
                    }

                    list.Add(p);
                }
            }
            PersistTaskMgr.Total = total;

            PersistTaskMgr.TotalStop = totalStop;

            persistMgr.Serialize(list);
            Console.WriteLine("fin recordMsProc");
        }
        private BackGroundTaskMgr(string name, int priority, bool large, bool fromPersist)
        {
            ms = 1;
            msProc[0] = conf.Proc.ProcIni;
            if (conf.Duration >= 0)
            {
                ms = conf.Duration;
                // msProc = ms; 
            }
            this.name = name;
            string _path = name;
            bool foundSlash = false;
            char[] chars = name.ToCharArray();
            int count = chars.GetLength(0);
            var sb = new StringBuilder();

            for (int i = 0; i < count; i++)
            {
                char c = chars[i];
                if (Path.DirectorySeparatorChar == c)
                    foundSlash = true;
                if (c == ' ' && !foundSlash)
                {
                    sb = new StringBuilder();
                }
                else
                    sb.Append(c);
            }
            _path = sb.ToString();


            this.logger = Logger.getLogger(_path, log);
            this.large = large;
            this.priority = priority;
            list.Add(this);
            if (!large)
            {
                lock (_lockS)
                {
                    persistList.Add(this);
                    if (!fromPersist)
                        ordoList.Add(this);
                }
            }

        }
        public bool large;

        public static string Display()
        {
            var sb = new StringBuilder();
            Display(sb);
            return sb.ToString();
        }

        public static void Display(ITextWriter sb)
        {
            if (sAbort)
            {
                sb.Append(" Abort");
            }

            if (sTh != null)
            {
                sb.Append(" sTh=");
                sb.Append(sTh.State.ToString());

            }

            if (elu != null)
            {
                sb.Append(" elu=");
                sb.Append(elu.name);
            }

            sb.AppendLine();

            foreach (BackGroundTaskMgr mgr in new List<BackGroundTaskMgr>(list))
            {
                mgr.display(sb);
                sb.AppendLine();
            }
        }

        public void display(ITextWriter sb)
        {
            sb.Append(name);
            sb.Append(" nb="); sb.Append(nb);
            if (_abort)
                sb.Append(" abort");
            sb.Append(" persistent="); ; sb.Append(persistent);
            sb.Append(" priority="); sb.Append(priority);
            if (th != null)
            {
                sb.Append(" th=");

                sb.Append(th.Name);
                sb.Append(",");
                sb.Append(th.State.ToString());

            }

            if (first != null)
            {
                sb.Append(" first=");
                sb.Append(first.task.Desc);
            }

            if (last != null)
            {
                sb.Append(" last=");
                sb.Append(last.task.Desc);
            }


        }

        public void displayElts(ITextWriter sb)
        {
            try
            {
                sb.Append(" nb="); sb.Append(nb);
                //var current = first;

                //while (current != null)
                //{
                //    sb.AppendLine(current.task.ToString());
                //    current = current.Next;
                //}
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        private static List<BackGroundTaskMgr> list = new List<BackGroundTaskMgr>();
        private static List<BackGroundTaskMgr> ordoList = new List<BackGroundTaskMgr>();
        private static List<BackGroundTaskMgr> persistList = new List<BackGroundTaskMgr>();
        public static int taskDelayError = 100;
        public static int TaskDelayError { set { taskDelayError = value; } }
        private static bool gcCollect;
        private static bool gcCollectLoop;
        private static bool gcCollectElu;
        private static bool gcCollectReset;
        public static void End()
        {
            List<BackGroundTaskMgr> aux = null;
            lock (_lockS)
            {
                aux = new List<BackGroundTaskMgr>(list);
                log.log(Display());
            }
            foreach (BackGroundTaskMgr mgr in aux)
            {
                while (!mgr.IsEnd)
                    Thread.Sleep(30);
            }

            lock (_lockS)
            {
                aux = new List<BackGroundTaskMgr>(list);
                log.log(Display());
            }

            foreach (BackGroundTaskMgr mgr in aux)
            {
                while (!mgr.IsEnd)
                    Thread.Sleep(30);
            }

        }

        public static void AbortSpecial()
        {

            sAbortSpecial = true;
            log.log("-----------------------------------------------");
            log.log("Abort Special");
            List<BackGroundTaskMgr> _list = null;

            lock (_lockS)
            {
                _list = new List<BackGroundTaskMgr>(ordoList);
            }

            foreach (BackGroundTaskMgr mgr in _list)
            {
                if (mgr.classAbort)
                    mgr.reset();
            }


            log.log("fin Abort Special");
            log.log("-----------------------------------------------");

        }


        public static void PauseSpecial()
        {
            log.log("-----------------------------------------------");
            log.log("Pause Special");
            List<BackGroundTaskMgr> _list = null;

            lock (_lockS)
            {
                _list = new List<BackGroundTaskMgr>(ordoList);
            }

            foreach (BackGroundTaskMgr mgr in _list)
            {
                if (mgr.classAbort)
                    mgr.pause();
            }


            log.log("fin Pause Special");
            log.log("-----------------------------------------------");

        }
        private static bool sPauseKeyBoard;
        public static void PlayPause()
        {
            lock (_lockS)
                sPauseKeyBoard = !sPauseKeyBoard;
        }
        public static bool PauseKeyBoard { get { return sPauseKeyBoard; } }

        public static void Reset()
        {
            List<BackGroundTaskMgr> _list = null;

            lock (_lockS)
            {
                _list = new List<BackGroundTaskMgr>(ordoList);


            }

            //  log.log(Display());
            autoStart = false;
            if (_ordonnancement)
                sReset();




            foreach (BackGroundTaskMgr mgr in _list)
            {

                mgr.reset();
            }

            //   log.log(Display());

            if (gcCollect && gcCollectReset)
                misc.gcCollect("Reset");

        }
        private static bool autoStart;
        public static void Start()
        {
            lock (_lockS)
            {
                sAbortSpecial = false;
                autoStart = true;
                sPause = false;
                sAbort = false;

                foreach (BackGroundTaskMgr mgr in list)
                    mgr.start();
            }
        }

        public static void Pause()
        {
            lock (_lockS)
            {
                sPause = true;
                foreach (BackGroundTaskMgr mgr in list)
                    mgr.pause();
            }
        }

        private static volatile object _lockS = new object();
        public static BackGroundTaskMgr getMgr(string name, int priority)
        {
            return getMgr(name, priority, false, false);
        }

        public static BackGroundTaskMgr getMgrlarge(string name)
        {
            return getMgr(name, 0, true, false);
        }

        public static BackGroundTaskMgr getMgr(string name, int priority, bool large, bool fromPersist)
        {
            lock (_lockS)
            {
                var found = list.Find(bg => bg.name == name);
                if (found == null)
                {
                    found = new BackGroundTaskMgr(name, priority, large, fromPersist);
                    found.classAbort = conf.getClassAbort(name);
                    if (!large && !fromPersist)
                    {
                        PriorityCoeff p = null;
                        if (!name.StartsWith("scan"))
                            p = conf.getPriority(name);
                        else
                            p = conf.getScanPriority(scanPriority.low);
                        if (p != null)
                        {
                            found.priority = p.priority;
                            found.coeff = p.coeff;
                        }
                    }
                }
                if (sAbortSpecial && found.classAbort)
                    found._abort = true;
                else if (autoStart) found._pause = false;

                return found;
            }
        }

        public static void checkScanPriority(BackGroundTaskMgr bg, scanPriority prior)
        {
            if (bg == null)
            {
                return;
                // throw new NullReferenceException("checkScanPriority"); 
            }
            var p = conf.getScanPriority(prior);
            bg.Priority = p.priority;
            bg.coeff = p.coeff;

        }

        public static void increaseScanPriority(BackGroundTaskMgr bg, scanPriority prior)
        {
            if (bg == null)
            {
                //  throw new NullReferenceException("checkScanPriority"); 
                return;
            }
            var p = conf.getScanPriority(prior);

            int newp = p.priority;
            float coeff = p.coeff;
            if (newp < bg.priority)
                bg.Priority = newp;
            if (coeff < bg.coeff)
                bg.coeff = coeff;
        }

        public static void increaseScanPriority(BackGroundTaskMgr bg, int priority)
        {
            if (bg == null)
            {
                //  throw new NullReferenceException("checkScanPriority"); 
                return;
            }
            //   var p = conf.getScanPriority(prior);
            if (priority < 0 || priority == int.MaxValue)
                return;

            if (priority < bg.priority)
                bg.priority = priority;

        }

        public static List<BackGroundTaskMgr> findMgr(string startName)
        {
            lock (_lockS)
            {
                var found = list.FindAll(bg => bg.name.ToLower().StartsWith(startName.ToLower()));

                return found;
            }
        }

        public static BackGroundTaskMgr FindMgr(string name)
        {

            var found = list.Find(bg => bg.name.Equals(name));
            return found;

        }

        public override string ToString()
        {
            return name;
        }

        public bool Async { set { async = value; } }
        private volatile object _lock = new object();

      //  private static bool _singleThread;
    //    public static bool SingleThread { set { _singleThread = value; } }
        private LinkedTask first;
        private LinkedTask last;
        private IBgTask current;

        //private bool _end;
        private bool _abort;

        public bool Stopped
        {
            get
            {
                if (_ordonnancement)
                {
                    if (sTh == null)
                    {
                        lock (_lockS)
                        {
                            if (sTh == null)
                                return true;
                        }
                    }
                    return false;
                }
                else
                    return th == null;
            }
        }

        //private bool isEnded;
        public bool IsEnd
        {
            get
            {
                if (_ordonnancement)
                {
                    if (nextTry > DateTime.MinValue)
                        return false;
                    if (first != null)
                        return false;
                    if (nb > 0)
                        return false;
                    lock (_lockS)
                    {
                        if (first == null && current == null && nextTry == DateTime.MinValue && nb == 0)
                            return true;
                        return false;
                    }

                }

                else
                    return th == null && nb == 0;
            }
        }

        public static bool ConfirmEnd(int msWait, int p)
        {
          //  int p = conf.getScanPriority(scanPriority.classement).priority;
            foreach (BackGroundTaskMgr bg in new List<BackGroundTaskMgr>(ordoList))
            {
                if (bg.priority <= p)
                {
                    if (!bg.confirmEnd(msWait))
                        return false;
                }
            }
            return true;
        }

        public static bool ConfirmEnd(int p)
        {
            var ms = (int) (1000 * conf.ConfirmEnd);
            return ConfirmEnd(ms, p); 
        }

        public bool confirmEnd(int msWait)
        {
            return IsEnd && DateTime.Now.AddMilliseconds(-msWait) > lastActivity;
        }

        //public bool Contains(string desc)
        //{
        //    var current = first;
        //    while (current != null)
        //    {
        //        if (current.task.Desc.Contains(desc))
        //            return true;
        //        current = current.Next;
        //    }
        //    return false;

        //}



        public void Abort()
        {
            if (persistent)
                return;
            log.log("{0}==> abort", this);
            _abort = true;
            reset();
        }

        public void start()
        {
            _pause = false;
            _abort = false;
            start_();
        }

        public void pause()
        {
            _pause = true;
        }

        private void start_()
        {
            try
            {
                if (_abort && !persistent)
                {
                   // log.log("start non effectué car abort");
                    return;
                }



                if (_pause && !persistent)
                    return;
                if (async && (large || !_ordonnancement))
                {
                    if (th != null)
                        return;
                    lock (_lock)
                    {
                        lastActivity = DateTime.MaxValue;
                        if (th != null)
                            return;

                        th = new ThreadUtil(loop, name);
                        _abort = false;

                        th.Start();
                    }
                }
                else if (_ordonnancement)
                {
                    if (sAbort || sPause || (sAbortSpecial && this.classAbort))
                    {
                        lock (_lockS)
                        {
                            if (sAbort || sPause || (sAbortSpecial && this.classAbort))
                            {
                              //  log.log("::::::::::::: {0} pas possible de démarrer sAbort {1} sPause {2} sAbortSpecial {3}", name, sAbort, sPause, sAbortSpecial);
                                return;
                            }
                        }
                    }

                    if (sTh != null)
                        return;
                    lock (_lockS)
                    {

                        if (sTh != null)
                            return;

                        if (sAbort || sPause || (sAbortSpecial && this.classAbort))
                            return;

                        sTh = new ThreadUtil(sLoop, "Bg");
                        sTh.Start();
                    }
                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }



        private const int NB = 1000 * 10000;
        public void add(IBgTask task)
        {
            add_(task, true);
        }

        public void addAtFirst(IBgTask task)
        {
            add_(task, true, false);
        }

        public void reset()
        {
            try
            {
                if (persistent)
                {
                    //  checkScanPriority(this, scanPriority.low);
                    return;
                }
                lock (_lock)
                {
                    log.log("reset " + name);
                    _pause = true;
                    _abort = true;
                    //_end = false;
                    //isEnded = false; 
                    if (current != null)
                        current.abort();

                    //var _current = first;

                    //while (_current != null)
                    //{
                    //    _current.task.abort();
                    //    var aux = _current.Next;
                    //    _current.Next = null;
                    //    _current = aux;
                    //}

                    first = null;
                    last = null;
                    nb = 0;

                }

                DateTime dt = DateTime.Now.AddSeconds(30);
                while (th != null && DateTime.Now < dt)
                    Thread.Sleep(30);
                if (DateTime.Now > dt)
                {
                    log.log("abort attente reset {0}", name);
                    try
                    {
                        if (th != null)
                            th.Abort();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    th = null;
                }

                lock (_lock)
                {

                    first = null;
                    last = null;
                    _abort = false;
                    _pause = false;
                    nb = 0;
                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
            if (gcCollect && gcCollectReset)
                misc.gcCollect("reset");
        }

        private static void sReset()
        {
            try
            {
                lock (_lockS)
                {
                    log.log("reset ordonnancement");
                    sPause = true;
                    sAbort = true;


                }



                DateTime dt = DateTime.Now.AddSeconds(30);
                while (sTh != null && DateTime.Now < dt)
                {
                    sAbort = true;
                    sPause = true;
                    Thread.Sleep(30);
                }
                if (DateTime.Now > dt)
                {
                    log.log("abort attente reset Bg");
                    try
                    {
                        if (sTh != null)
                            sTh.Abort();

                    }
                    catch (Exception e)
                    {
                        log.log(e.ToString());
                    }
                    sTh = null;
                }

                //lock (_lockS)
                //{

                //    sAbort = false;
                //    sPause = false;

                //}
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }



        private void add_(IBgTask task, bool withLimit)
        {
            add_(task, withLimit, true);
        }

        private void add_(IBgTask task, bool withLimit, bool atLast)
        {
            if (!used)
            {
                lock (_lockS)
                {
                    if (!ordoList.Contains(this))
                        ordoList.Add(this);
                }
                used = true;
            }

            try
            {
                //   log.log("add {0} {1} {2} {3}", name, nb, task, withLimit);  
                while (withLimit && nb > NB)
                    Thread.Sleep(30);
                object synchro = _lock;
                if (_ordonnancement && !large)
                    synchro = _lockS;


                //   log.log("add OK {0} {1} {2} {3}", name, nb, task, withLimit);  
                if (async)
                {
                    if (_abort && !persistent)
                    {
                        // log.log("tâche non ajoutée car abort " + task.Desc);
                        return;
                    }
                    if (task.Try >= NB)
                    {
                        log.log("{0} tache abandonnée après {1} essais", task, NB);
                        return;
                    }

                    lastActivity = DateTime.MaxValue;

                    var ll = new LinkedTask(task);
                    lock (synchro)
                    {
                        if (_abort && !persistent)
                        {
                            //    log.log("tâche non ajoutée car abort " + task.Desc);
                            return;
                        }

                        start_();
                        if (atLast)
                        {
                            if (last != null)
                            {
                                last.Next = ll;
                            }

                            last = ll;

                            if (first == null)
                                first = last;
                        }
                        else
                        {
                            var f = first;
                            ll.Next = first;
                            first = ll;

                            if (last == null)
                                last = first;
                        }

                        nb++;
                    }

                }
                else
                    task.exec();

            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        private DateTime lastExec;
        private void loop()
        {
            try
            {

                while (!_abort && !_pause)
                {
                    Thread.Sleep(30);

                    lock (_lock)
                    {
                        if (_abort) return;
                        if (first == null)
                        {
                            return;
                        }
                        var aux = first;
                        current = first.task;
                        first = first.Next;
                        aux.Next = null;
                        if (first == null)
                            last = null;
                        if (!large)
                            log.log("{0} {1}", nb, current);
                        nb--;

                    }

                    try
                    {
                        //if (_singleThread && !large)
                        //    Locker.Enter();

                        if (_abort) return;
                        lastExec = DateTime.Now;
                        current.exec();
                    }
                    catch (Exception ex)
                    {
                        log.log("erreur task {0} {1}", current, ex.ToString());
                    }
                    finally
                    {
                        //if (_singleThread && !large)
                        //    Locker.Release();
                    }


                    if (current.Abort)
                    {
                        log.log("{0} tâche interrompue ", name);
                        th = null;
                        return;
                    }

                    if (!current.Success)
                    {
                        lock (_lock)
                        {
                            if (_abort) return;
                        }
                        current.Try++;
                        if (taskDelayError >= 0)
                            Thread.Sleep(taskDelayError * current.Try);
                        add_(current, false, true);

                    }

                    lock (_lock)
                    {
                        current = null;
                    }



                }
            }
            catch (Exception e)
            {
                log.log(this.name + " loop " + e.ToString());
            }
            finally
            {
                lastActivity = DateTime.Now;
                th = null;
                nb = 0;
                if (gcCollectLoop)
                    misc.gcCollect("end loop");

            }
        }


        private static bool sPause;
        private static bool sAbort;
        private static bool sAbortSpecial;
        private static BackGroundTaskMgr elu = null;

        private static void decrementCms(BackGroundTaskMgr bg)
        {
            if (bg == null)
                return;
            // log.log("decrement {0} {1}", bg, bg.cms); 
            if (bg.cms <= 1) // || conf.Duration < 0)
                return;
            var nt = bg.cms / conf.Proc.Cms;
            if (nt < 1)
                nt = 1;
            bg.cms = nt;
        }

        private static void incrementCms(BackGroundTaskMgr bg)
        {
            if (bg == null)
                return;
            if (conf.Proc.Cms == 1)
                return;
            //  log.log("increment {0} {1}", bg, bg.cms); 
            bg.cms *= conf.Proc.Cms;
        }

        private static double calcP(BackGroundTaskMgr bg, double calc0)
        {
            if (conf.Duration < 0)
                return calc0;
            else
                return calc0 * bg.cms;
        }

        private static double calcVal(BackGroundTaskMgr bg)
        {
            double[] t = new double[NB_PROC];


            for (int i = 0; i < NB_PROC; i++)
            {
                if (playing)
                    t[i] = bg.msProc[i];
                else
                    t[i] = bg.msProcStop[i];
            }


            var _conf = conf.Proc;
            double duration1 = _conf.Duration[0];
            double duration2 = _conf.Duration[1];
            if (duration1 <= 0)
            {
                if (duration2 <= 0)
                {
                    return 1;
                }
                return calc1_(t[1]);
            }
            if (duration2 <= 0)
                return calc1_(t[0]);

            for (int i = 0; i < NB_PROC; i++)
            {
                t[i] = calc1_(t[i]);
            }

            var p = _conf.Proportion;
            switch (_conf.Mode)
            {
                case procMode.max:
                    double max = 0;
                    for (int i = 0; i < NB_PROC; i++)
                    {
                        if (t[i] > max)
                            max = t[i];
                    }
                    return max;
                case procMode.min:
                    double min = double.MaxValue;
                    for (int i = 0; i < NB_PROC; i++)
                    {
                        if (t[i] < min)
                            min = t[i];
                    }
                    return min;
                // case procMode.moy: return p * t[0] + (1 - p) * t[1];
                case procMode.somme:
                    double tot = 0;
                    for (int i = 0; i < NB_PROC; i++)
                        tot += p[i] * t[i];
                    return tot;
                case procMode.produit:
                    double prod = 1;
                    for (int i = 0; i < NB_PROC; i++)
                        prod *= Math.Pow(t[i], p[i]);
                    return prod;
                //case procMode.produitM:
                //    return Math.Pow(t[0], p) * Math.Pow(t[1], 1 - p);
            }

            return 1;

        }

        //public static double calcVal(BackGroundTaskMgr bg)
        //{
        //    return calc1_(calcVal_(bg)); 
        //}

        private static double calc0(BackGroundTaskMgr bg)
        {
            return bg.nb * bg.coeff * calcVal(bg);
        }


        private static double calc1(BackGroundTaskMgr bg)
        {
            return bg.nb * bg.coeff * bg.cms * calcVal(bg);
        }

        private static double calc1_(double msProc)
        {
            return -Math.Log(1 - msProc); // msProc / (1 - msProc);
        }
        private confrontationStatus confrontationState;



        private static BackGroundTaskMgr selection(DateTime now, bool withCms)
        {
            BackGroundTaskMgr _elu = BackGroundTaskMgr.elu;
            if (_elu != null && _elu.confrontationState == confrontationStatus.none)
                _elu = null;
            double elut = -1;
            //  bool compet = false;
            foreach (BackGroundTaskMgr bg in ordoList)
            {
                //  logOrdo.log(string.Format("{0} nb:{1} pr:{2} pau:{3} ca:{4} ab:{5} ", bg.name, bg.nb, bg.priority, bg.pause, bg.classAbort, bg._abort)); 
                if (bg.confrontationState == confrontationStatus.none)
                    continue;


                if (_elu == null)
                {
                    _elu = bg; continue;
                }

                if (_elu == bg)
                    continue;

                if (bg.priority < _elu.priority)
                {
                    _elu = bg;
                    elut = -1;
                    continue;
                }

                if (bg.priority > _elu.priority)
                    continue;

                bg.confrontationState = confrontationStatus.enCompet;
                double bgt = withCms ? calc1(bg) : calc0(bg);
                if (elut == -1)
                    elut = withCms ? calc1(_elu) : calc0(_elu);

                if (bgt < elut)
                {
                    _elu = bg;
                    elut = bgt;
                    continue;

                }
                if (bgt > elut)
                {
                    _elu.confrontationState = confrontationStatus.enCompet;
                    continue;
                }


                if (bg.lastExec > _elu.lastExec)
                {
                    _elu = bg;
                    elut = bgt;
                }

            }

            return _elu;
        }
        //private static void confrontation(BackGroundTaskMgr bg, BackGroundTaskMgr elu, bool withCms)
        //{
        //    if (elu == null)
        //    {
        //        elu = bg; return;
        //    }

        //    if (elu == bg)
        //        return;
        //    if (bg.priority < elu.priority)
        //    {
        //        elu = bg; return;
        //    }

        //    if (bg.priority > elu.priority)
        //        return;
        //    double bgt = withCms ? calc1(bg) : calc0(bg);
        //    double elut = withCms ? calc1(_el) : calc0(bg);

        //    var elut = calcP(elu, elut0);
        //    if (bgt < elut)
        //    {
        //        if (bgt0 >= elut0)
        //            decrementCms(elu);
        //        else
        //            incrementCms(bg);
        //        elu.cms /= conf.Cms;
        //        elu = bg;
        //        return;

        //    }
        //    if (bgt > elut)
        //    {
        //        if (bgt0 <= elut0)
        //            decrementCms(bg);
        //        else
        //            incrementCms(elu);
        //        return;
        //    }
        //    if (bg.lastExec > elu.lastExec)
        //    {
        //        elu = bg;
        //    }

        //}

        private static double calcMs(int nbStat, double ms, double ts)
        {
            return (ms * (nbStat - 1) + ts) / (double)nbStat;
        }
        const double EPSILON = 0.0000000000001;
        private static double calcMsProc(double ms, double ts, double pente, bool actif)
        {
            //pente = ts / nbstat ou si ts est grand ts / (nbStat + ts)
            // si on a rien fait : perte = ts / nbstat  (proportion)
            // ex : ms0 = 0.2 ts =300 nbstat = 1000
            //perte = 0.3 
            // ms1 =0.2 *0.7 = 0.14

            // si c'est moi qui bosse : asymptote dans l'autre sens : 
            //dalta = 0.8 augmentation = 0.8 * 0.3 = 0.24 ms1 = 0.44

            var delta = actif ? 1 - ms : -ms;

            var ret = ms + delta  * (1 - Math.Exp (-pente)); //* pente;
            if (1 - ret < EPSILON)
                ret = 1 - EPSILON;
            if (ret < 0)
                ret = 0;

            return ret;
            //  return (ms * (nbStat - 1) + ts) / (double)nbStat;

        }

        private static void sLoop()
        {
            var chrono = BgTask.chrono;
            try
            {

                while (!sAbort)
                {
                    Thread.Sleep(30);
                    //  elu = null;
                    DateTime now = DateTime.Now;
                    if (sAbort) return;
                    if (sPauseKeyBoard)
                        continue;
                    if (sPause)
                        continue; 
                    string strElu0 = "";
                    lock (_lockS)
                    {
                        if (sAbort) return;
                        //election
                        if (elu != null && elu.first == null)
                            elu = null;

                        foreach (BackGroundTaskMgr bg in ordoList)
                        {
                            bg.confrontationState = confrontationStatus.none;
                            //  logOrdo.log(string.Format("{0} nb:{1} pr:{2} pau:{3} ca:{4} ab:{5} ", bg.name, bg.nb, bg.priority, bg.pause, bg.classAbort, bg._abort)); 
                            if (bg._abort)
                                continue;
                            if (bg._pause)
                                continue; 
                            var ll = bg.first;
                            if (ll == null)
                                continue;
                            if (bg.nextTry > now)
                                continue;
                            if (bg.large)
                                continue;
                            bg.confrontationState = confrontationStatus.enCourse;


                        }

                        var elu0 = selection(now, false);
                        if (conf.Duration >= 0 && conf.Proc.Cms > 1)
                        {
                            elu = selection(now, true);

                            if (elu != null && elu.confrontationState > confrontationStatus.enCourse)
                            {

                                if (elu == elu0)
                                {
                                    // gagnerait de toutes façon  malgré le handicap 
                                    incrementCms(elu);
                                }
                                else
                                {
                                    // gagne à l'aide du handicap
                                    //if (elu0.cms > 1)
                                    decrementCms(elu0);
                                    //else
                                    //    incrementCms(elu);
                                    strElu0 = string.Format(" ({0}->{1,4:0.###}", elu0, elu0.cms);
                                }
                            }
                        }
                        else
                            elu = elu0;



                        if (elu == null)
                            continue;


                        var aux = elu.first;
                        if (aux != null)
                        {
                            elu.current = elu.first.task;
                            elu.first = elu.first.Next;
                        }
                        aux.Next = null;
                        if (elu.first == null)
                        {
                            elu.last = null;

                        }

                        if (sAbortSpecial && elu.classAbort)
                        {
                            elu.nb--;
                            continue;
                        }


                        // log.log("[{0}] {1} {2} {3}", elu.name, elu.priority, elu.nb, elu.current);
                        // var logger = elu.logger, Logger.getLogger(@"Task\" + elu.name, log);
                        //  var sb = new StringBuilder(); 
                        //  elu.logger.log("[{0}] {1} {2} {3}", elu.name, elu.priority, elu.nb, elu.current);

                        elu.nb--;
                    }

                    var current = elu.current;

                    try
                    {

                        if (sAbort) return;
                        DateTime _now = DateTime.Now;
                        chrono.reset(elu.name);
                        current.exec();
                        chrono.end();
                        var ts = chrono.Total.TotalMilliseconds;

                        lock (_lockS)
                        {
                            var ts0 = ts;

                            if (elu == null)
                                continue;
                            //   var min = conf.Duration;
                            string moy = "";
                            string cms = "";
                            string moyProc = "";
                            // string moyProc2 = ""; 
                            string valProc = "";
                            double val0 = 0;

                            double val1 = 0;
                            var confProc = conf.Proc;
                            var tsMin = confProc.TsMin;
                            if (ts < tsMin)
                                ts = tsMin;
                            var nbStat = confProc.NbDuration;
                            var nbProcDuration = confProc.Duration;
                            if (nbStat >= 0)
                            {
                                for (int i = NB_PROC - 1; i >= 0; i--)
                                    moyProc += string.Format(CultureInfo.InvariantCulture, " {0,6:##.000}", (100 * (playing ? elu.msProc[i] : elu.msProcStop[i])));
                                moyProc += string.Format(CultureInfo.InvariantCulture, " {0,6:##.000}", (100 * calcVal(elu)));
                                val0 = (elu.nb + 1) * elu.coeff * calcVal(elu);
                                double[] pente = new double[NB_PROC];

                                for (int i = 0; i < NB_PROC; i++)
                                {
                                    var _pente = nbProcDuration[i];
                                    if (_pente > 0)
                                        pente[i] = ts / _pente;
                                    else
                                        pente[i] = 0;
                                }



                                elu.ms = calcMs(nbStat, elu.ms, ts0); // (elu.ms * (nbStat - 1) + ts) / (double)nbStat;
                                moy = string.Format(" {0,4:####}", elu.ms);
                                var calcProcMin = conf.CalcProcMin;
                                if (elu.confrontationState >= calcProcMin || elu.msProc[0] < EPSILON)
                                {
                                    for (int i = 0; i < NB_PROC; i++)
                                    {
                                        if (playing)
                                        {

                                            elu.msProc[i] = calcMsProc(elu.msProc[i], ts, pente[i], true);
                                        }
                                        else
                                        {

                                            elu.msProcStop[i] = calcMsProc(elu.msProcStop[i], ts, pente[i], true);
                                        }
                                    }
                                    //  moyProc += string.Format(CultureInfo.InvariantCulture, " {0,6:##.000}", (100 * elu.msProc));
                                    val1 = calc1(elu);
                                    valProc = string.Format(CultureInfo.InvariantCulture, " {0,8:###.000} {1,8:###.000}", val0, val1);
                                }

                                int nbEnCompet = 2;
                                if (calcProcMin > confrontationStatus.none)
                                {
                                    nbEnCompet = 0;
                                    foreach (BackGroundTaskMgr bg in ordoList)
                                    {
                                        if (bg.used && bg.confrontationState >= calcProcMin)
                                            nbEnCompet++;
                                    }
                                }

                                if (nbEnCompet > 1)
                                {
                                    if (conf.CalcProcDiv)
                                    {
                                        for (int i = 0; i < NB_PROC; i++)
                                        {
                                            pente[i] /= ((double)nbEnCompet - 1);
                                        }
                                    }
                                    foreach (BackGroundTaskMgr bg in persistList)
                                    {
                                        if (bg == elu)
                                            continue;
                                        if (calcProcMin == confrontationStatus.none || (bg.used && bg.confrontationState >= calcProcMin))
                                        {
                                            for (int i = 0; i < NB_PROC; i++)
                                            {
                                                if (playing)
                                                {
                                                    bg.msProc[i] = calcMsProc(bg.msProc[i], ts, pente[i], false);
                                                }
                                                else
                                                {
                                                    bg.msProcStop[i] = calcMsProc(bg.msProcStop[i], ts, pente[i], false);
                                                }
                                            }
                                        }
                                    }
                                }



                                if (confProc.Cms != 1)
                                {
                                    cms = string.Format(" {0,4:0.###}", elu.cms);

                                }
                                //  elu.cms *= conf.Cms;
                            }
                            if (!current.Success)
                                ts0 *= -1;

                            var strMs = string.Format("{0,4:####}", ts0);
                            if (string.IsNullOrWhiteSpace(strMs))
                                strMs = string.Format("{0,4}", "-");
                            var chronoSeuil = conf.ChronoSeuil;
                            if (chronoSeuil >= 0)
                                strMs = string.Format(conf.FormatChrono, chrono.display(chronoSeuil, conf.FormatPhase)) + strMs;

                            //  elu.logger.log(string.Format("[{0}] {1} {2} {3,4:####}{4}{5}{6}{7}{8} {9}", elu.name, elu.priority, elu.nb + 1, ts, moy, moyProc, valProc, cms, strElu0, elu.current));
                            elu.logger.log(string.Format("{0} {1}{2}{3}{4}{5} {6,4:####} [{7}] {8} {9}",
                                                          strMs, moy, moyProc, valProc, cms, strElu0, (elu.nb + 1), elu.name, elu.priority, elu.current));

                        }
                    }
                    catch (Exception ex)
                    {
                        if (elu != null && elu.logger != null && elu.current != null)
                            //   var logger = Logger.getLogger(@"Task\" + elu.name, log);
                            elu.logger.log("erreur task {0} {1}", elu.current, ex.ToString());
                    }
                    finally
                    {

                    }


                    if (current.Abort)
                    {
                        elu.logger.log("{0} tâche interrompue ", elu.name);
                        continue;
                    }

                    bool collect = false;
                    lock (_lockS)
                    {
                        if (!current.Success)
                        {
                            if (sAbort) return;

                            current.Try++;
                            if (taskDelayError >= 0)
                            {
                                TimeSpan ts = TimeSpan.FromMilliseconds(taskDelayError * elu.current.Try);
                                elu.nextTry = DateTime.Now.Add(ts);

                            }

                            elu.add_(current, false, true);

                        }
                        else
                        {
                            elu.nextTry = DateTime.MinValue;
                            elu.lastExec = now;
                            elu.lastActivity = DateTime.Now;
                            if (elu.classAbort)
                                OnImportantTask();
                            if (elu.priority == 0)
                                OnClassTask(); 
                            if (elu.first == null)
                                collect = true;
                        }


                        elu.current = null;


                    }

                    if (collect && gcCollectElu)
                        misc.gcCollect("elu");



                }
            }
            catch (Exception e)
            {

                log.log("ordonnancement loop " + e.ToString());
            }
            finally
            {
                sTh = null;
                if (gcCollectLoop)
                    misc.gcCollect("end sloop");
            }
        }

        private DateTime nextTry;


        private class LinkedTask
        {
            public readonly IBgTask task;
            public LinkedTask Next;
            public LinkedTask(IBgTask task) { this.task = task; }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.ordo\conf\ConfOrdo.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.obj;
using pdb.util;

namespace pdb.ordo.conf
{
    public enum confrontationStatus
    {
        none,
        enCourse,
        enCompet,
        //lost,
        //lostByCms,
        //winByCms,
        //win
    }
    public class ConfOrdo
    {
        private static Logger log = Logger.getLogger("Ordo", Logger.getLogger("Bg"));
        private bool enable = true;
        private PriorityCoeff scanHigh = new PriorityCoeff(1);
        private PriorityCoeff scanLow = new PriorityCoeff(20);
        private PriorityCoeff scanMedium = new PriorityCoeff(12);
        private PriorityCoeff scanClassement = new PriorityCoeff(1);
        private string persistFile = "..\\ordo.txt";



        private confrontationStatus calcProcMin = confrontationStatus.none; public confrontationStatus CalcProcMin { get { return calcProcMin; } }
        private bool calcProcDiv; public bool CalcProcDiv { get { return calcProcDiv; } }
        private List<PriorityRule> rules = new List<PriorityRule>();

        //private bool singleThread;
        //public bool SingleThread { get { return singleThread; } }

        private int taskDelayError = 30;
        public int TaskDelayError { get { return taskDelayError; } }

        private bool gcCollect; public bool GcCollect { get { return gcCollect; } }
        private bool gcCollectLoop; public bool GcCollectLoop { get { return gcCollectLoop; } }
        private bool gcCollectElu; public bool GcCollectElu { get { return gcCollectElu; } }
        private bool gcCollectReset; public bool GcCollectReset { get { return gcCollectReset; } }
        private double chronoSeuil; public double ChronoSeuil { get { return chronoSeuil; } }
        private string formatChrono = "{0 ,-60}"; public string FormatChrono { get { return formatChrono; } }
        private string formatPhase = "{0,2}:{1,-3:#}"; public string FormatPhase { get { return formatPhase; } }
        private double confirmEnd = 3; public double ConfirmEnd { get { return confirmEnd; } }

        private double duration = 0; public double Duration { get { return duration; } }

        private ConfProc proc = new ConfProc(); internal ConfProc Proc { get { return proc; } }

        public ConfOrdo() { }

        public ConfOrdo(XmlElement node)
        {
            if (node == null)
                return;
            XMLTool xml = new XMLTool(node);

            enable = "true" == xml.getAttValue("enable");
            //  singleThread = xml.getBoolValue("singleThread");
            gcCollect = xml.getBoolValue("gcCollect");
            gcCollectLoop = xml.getBoolValue("gcCollectLoop");
            gcCollectElu = xml.getBoolValue("gcCollectElu");
            gcCollectReset = xml.getBoolValue("gcCollectReset");

            string str = xml.getAttValue("scan", "low");
            if (!string.IsNullOrEmpty(str))
                scanLow.priority = Convert.ToInt16(str);

            str = xml.getAttValue("scan", "high");
            if (!string.IsNullOrEmpty(str))
                scanHigh.priority = Convert.ToInt16(str);

            str = xml.getAttValue("scan", "medium");
            if (!string.IsNullOrEmpty(str))
                scanMedium.priority = Convert.ToInt16(str);

            str = xml.getAttValue("scan", "class");
            if (!string.IsNullOrEmpty(str))
                scanClassement.priority = Convert.ToInt16(str);

            str = xml.getNodeValue("taskDelayError");
            if (!string.IsNullOrEmpty(str))
                taskDelayError = Convert.ToInt32(str);

            str = xml.getNodeValue("duration");
            if (!string.IsNullOrEmpty(str))
                duration = Convert.ToDouble(str);

            str = xml.getNodeValue("chronoSeuil");
            if (!string.IsNullOrEmpty(str))
                chronoSeuil = Convert.ToDouble(str);

            str = xml.getNodeValue("calcProcMin");
            if (!string.IsNullOrEmpty(str))
                calcProcMin = (confrontationStatus)Enum.Parse(typeof(confrontationStatus), str, true);

            str = xml.getNodeValue("formatChrono");
            if (!string.IsNullOrEmpty(str))
                formatChrono = str;

            str = xml.getNodeValue("formatPhase");
            if (!string.IsNullOrEmpty(str))
                formatPhase = str;

            str = xml.getNodeValue("persistFile");
            if (!string.IsNullOrEmpty(str))
                persistFile = str;

            str = xml.getNodeValue("confirmEnd");
            if (!string.IsNullOrEmpty(str))
                confirmEnd = Convert.ToDouble(confirmEnd) ; 


            calcProcDiv = xml.getBoolValue("calcProcDiv");


            rules = new List<PriorityRule>();
            foreach (XmlNode sb in node.ChildNodes)
            {
                if (sb.Name == "bg")
                    rules.Add(new PriorityRule(sb as XmlElement));
            }

            var xProc = xml.NodeLookUp("proc");
            proc = new ConfProc(xProc);

        }

        public bool Enable { get { return enable; } }

        public PriorityCoeff getScanPriority(scanPriority _priority)
        {
            switch (_priority)
            {
                case scanPriority.low: return scanLow;
                case scanPriority.medium: return scanMedium;
                case scanPriority.high: return scanHigh;
                case scanPriority.classement: return scanClassement;
                default: throw new NotImplementedException();
            }
        }

        public bool getClassAbort(string name)
        {
            foreach (PriorityRule rule in rules)
            {
                bool? a = rule.getClassAbort(name);
                if (a == null)
                    continue;
                return a.Value;
            }
            //log.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            //log.log("getClassAbort::impossible de matcher le bg de nom {0}", name);
            //log.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"); 
            return false;

        }

        public PriorityCoeff getPriority(string name)
        {
            if (rules.Count > 0)
            {
                foreach (PriorityRule rule in rules)
                {
                    var p = rule.getPriority(name);
                    if (p == null)
                        continue;
                    return p;
                }
                log.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                log.log("getPriority::impossible de matcher le bg de nom {0}", name);
                log.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            }
            return null;

        }
        public override string ToString()
        {
            ITextWriter sb = new StringBuilder();
            sb.Append("enable=");
            sb.Append(enable);
            sb.Append(" low="); sb.Append(scanLow);
            sb.Append(" medium="); sb.Append(scanMedium);
            sb.Append(" high="); sb.Append(scanHigh);


            foreach (PriorityRule pr in rules)
            {
                sb.AppendLine(pr.ToString());
            }

            return sb.ToString();


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel.Commande;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Data;
using System.Windows.Input;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.util;
using System.Collections;
using pdb.gen.conf;
using pdb.gen.albums;
using pdb.gen.Tuning;
using pdb.gen;
using System.Windows.Threading;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg;
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg;
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(TrackListViewModel t)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }



    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object();
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort { get { return confAlbumSort; } set { confAlbumSort = value; } }
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel();
                    }
                }
                return _instance;
            }
        }

        public ConfFilter ConfFilter { get { return FilterTask.conf; } }
        private IPlayerEngine player = PlayerBuilder.create("vlcplugin");

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        public static event EventHandler autoChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        // private bool sortByAlbum = true;
        private bool withVirtualAlbum = CConf.ConfGen.AlbumVirtual;
        private bool withArtistVirtual = CConf.ConfGen.ArtistVirtual;
        private bool navAuto = CConf.ConfGen.NavAuto;
        public bool NavAuto
        {
            get { return navAuto; }
            set
            {
                if (value != navAuto)
                {
                    navAuto = value;
                    OnPropertyChanged("NavAuto");
                }
            }
        }

        private bool filterOnlyNext;
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                    OnPropertyChanged("FilterNext");
                }
            }
        }
        ItrackProvider _real;
        private Logger log;
        public static IPlayerEngine Player { get { return Instance.player; } }


        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }
        private bool createRot = true;
        public bool CreateRot
        {
            get
            {
                return createRot;
            }
            set
            {
                if (value != createRot)
                {
                    createRot = value;
                    OnPropertyChanged("CreateRot");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return confAlbumSort.Enabled;
            }
        }
        //private albumSortMode sortAlbumMode;
        //public albumSortMode SortAlbumMode
        //{
        //    get { return sortAlbumMode; }
        //    set
        //    {
        //        if (value != sortAlbumMode)
        //        {
        //            sortAlbumMode = value;
        //            OnPropertyChanged("SortAlbumMode");
        //            App.go();
        //        }
        //    }
        //}

        public bool WithVirtualAlbum
        {
            get { return withVirtualAlbum; }
            set
            {
                if (value != withVirtualAlbum)
                {
                    withVirtualAlbum = value;
                    OnPropertyChanged("WithVirtualAlbum");
                    App.go();
                }
            }
        }

        public bool WithVirtualArtist
        {
            get { return withArtistVirtual; }
            set
            {
                if (value != withArtistVirtual)
                {
                    withArtistVirtual = value;
                    OnPropertyChanged("WithVirtualArtist");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            player.mediaEndReached += player_mediaEndReached;
            player.Volume = volume;
            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume();
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }

        public void checkNavIni()
        {
            if (!navAuto)
                return;

            var tracks = PresentationTracks;
            bool foundFirst = false;
            TrackListViewModel f = null;

            foreach (TrackListViewModel t in tracks)
            {
                if (t.Index == 1)
                {
                    foundFirst = true;
                }
                if (foundFirst && t.PieceGen.IsNext)
                {
                    f = t;
                    break;
                }
            }

            if (f == null)
                return;

            tracks.MoveCurrentTo(f);
            focus(f);

        }

        public void forward()
        {
            if (!navAuto)
                movetoNext(true);
            else
            {
                var t = TrackListViewModel.HumanSelected;
                if (t != null)
                {
                    t.refresh();
                    //  var g = t.Grouping; 
                }

                var pl = PlayListViewModel.SelectedPlayList;
                if (pl == null)
                {
                    movetoNext(true);
                    return;
                }

                string _album = "";
                if (currentTrack != null)
                    _album = currentTrack.Album;
                movetoNext(true); // des fois le morceaux affiché n'est pas celui joué. Dommage...
                if (currentTrack != null && currentTrack.Album == _album)
                {
                    if (state == playerstate.play)
                        play(false, true);
                    return;
                }

                if (currentTrack == null)
                    return;
                var album = App.gen.Albums.getAlbum(CurrentTrack.Track);
                var tracks = album.Tracks;
                //    tracks.Sort(new PieceClassementComparer());
                //  decimal val = int.MaxValue;
                int i = 0;
                TrackListViewModel choose = null;
                if (confAlbumSort.ComposantsUtiles[0].cmpMin > modeMin.non)
                {
                    var next = album.Next;
                    if (next != null)
                        choose = pl.FindTrack(next.PieceId);
                }
                else
                {
                    for (i = 0; i < tracks.Count; i++)
                    {
                        var item = tracks[i];
                        if (item != null && (!onlyEnabled || item.Enabled))
                        {
                            var tl = pl.FindTrack(item.PieceId);
                            if (!tl.Exists)
                                continue;
                            choose = tl;

                            //val = v;
                            // choose = tl;
                            if (item.VirtualClassement == 0m)
                            {
                                break;
                                //if (confAlbumSort.ComposantsUtiles[0].cmpMin != modeMin.toujours)
                                //    choose = tl;
                                //break;
                            }
                            // choose = tl;
                        }
                    }
                }

                if (choose != null)
                {
                    //var p = choose.PieceGen;
                    //if (p != null)
                    //   confAlbumSort.auto(p.AutoCoeff1, p.AutoCoeff2); 
                    if (choose != currentTrack)
                    {
                        reset(provider, choose, state == playerstate.play);
                        var coll = PresentationTracks;
                        coll.MoveCurrentTo(choose);
                    }
                  
                    focus(choose);

                }

            }
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext(bool autoPlay)
        {
            move(true, autoPlay);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext, bool autoPlay)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {

                int masterId = 0;
                if (currentTrack != null)
                {
                    tracks.MoveCurrentTo(currentTrack);
                    masterId = currentTrack.MasterId;
                }
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.Exists && (!onlyEnabled || item.Enabled) && item.MasterId != masterId)
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    // focus(item);
                    if (playing && autoPlay)
                    {
                        player.play(item.Location, true);
                    }
                    // focus(item);
                }

            }
        }


        private void movetoPrevious()
        {
            move(false, true);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                                break;
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

                //  focus(item);

                State = playerstate.play;
                //item.Playing = true;
                player.play(currentTrack.Location, reload);
                focus(item);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            player.stop();

        }

        private void next()
        {
            if (navAuto)
                forward();
            else
                movetoNext(true);
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }

        public void focusHelp()
        {
            var t = TrackListViewModel.CurrentPlaying;
            if (t == null)
                t = TrackListViewModel.HumanSelected;
            if (t == null) return;
            focus(t);
        }
        private void focus(TrackListViewModel t)
        {
            if (provider == null)
                return;
            provider.Focus(t);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = player.Elapsed;
                this.Length = player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    var sb = new System.Text.StringBuilder();
                    sb.Append(currentTrack.Artist);
                    sb.Append(" - ");
                    sb.Append(currentTrack.Album);
                    if (currentTrack.PieceGen != null)
                    {
                        if (currentTrack.PieceGen.Virtual)
                        {
                            sb.Append(" (");
                            sb.Append(currentTrack.PieceGen.Master.Album);
                            sb.Append(")");
                        }
                    }
                    CurrentAuthorAlbum = sb.ToString();
                    if (currentTrack.Exists)
                        currentTrack.Duration = length;

                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            reset(provider, track, true);
        }

        public static void makeauto(TrackListViewModel current)
        {
            if (current != null)
            {
                var p = current.PieceGen;
                if (p != null)
                {
                    confAlbumSort.auto(p);
                    if (autoChange != null)
                        autoChange(current, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track, bool autoPlay)
        {
            if (provider != null)
            {
                Instance.provider = provider;
                Instance.currentPl = provider.PlayList;
                Instance.provider = provider;
                Instance.tracks = provider.PresentationTracks;

            }
            Instance._positionstate = positionstate.free;






            Instance.CurrentTrack = track;
            if (autoPlay)
                Instance.play(true, true);
            Instance.makeResume();
            App.go();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            var currentPlaying = TrackListViewModel.CurrentPlaying;
                            tracks.MoveCurrentTo(currentPlaying);
                            provider.Focus(currentPlaying);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
        //  private class filterTask
        //  {
        //      public filterTask()
        //      {
        //      }
        //      public string filter;
        //      //public string waitingFilter; 
        //      //private bool cancel; 
        //      //private Thread th;
        //      public Predicate<object> Filter;
        //      //public ICollectionView coll;
        //      //private bool busy;

        //      public void go()
        //      {

        //          if (!string.IsNullOrEmpty(filter))
        //              filter = filter.Trim().ToLower().removeAccent();

        //          var tab = filter.Split(' ');
        //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
        //          lock (this)
        //              busy = true;
        //          coll.Filter = item =>
        //          {
        //              TrackListViewModel vitem = item as TrackListViewModel;
        //              if (vitem == null) return false;

        //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //              //    return vitem.Classement.StartsWith(filter);
        //              bool ok = true;
        //              var name = vitem.Name.Trim().ToLower().removeAccent();
        //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //              var album = vitem.Album.Trim().ToLower().removeAccent();
        //              var classement = vitem.Classement;
        //              foreach (string str in tab)
        //              {
        //                  if (!ok)
        //                      return false;
        //                  if (string.IsNullOrEmpty(str))
        //                      continue;
        //                  var str_ = str.Trim();
        //                  if (str_ == string.Empty)
        //                      continue;

        //                  ok = name.Contains(str_)
        //                      || artist.Contains(str_)
        //                      || album.Contains(str_)
        //                      || classement.StartsWith(str_);

        //              }

        //              return ok;

        //          };

        //          lock (this)
        //              busy = true;

        //      }
        //      private void getItems()
        //      {
        //          try
        //          {
        //              if (!string.IsNullOrEmpty(filter))
        //                  filter = filter.Trim().ToLower().removeAccent();
        //              if (cancel)
        //                  return;
        //              var tab = filter.Split(' ');
        //              if (cancel)
        //                  return;
        //              Filter = item =>
        //              {
        //                  TrackListViewModel vitem = item as TrackListViewModel;
        //                  if (vitem == null) return false;

        //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //                  //    return vitem.Classement.StartsWith(filter);
        //                  bool ok = true;
        //                  var name = vitem.Name.Trim().ToLower().removeAccent();
        //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //                  var album = vitem.Album.Trim().ToLower().removeAccent();
        //                  var classement = vitem.Classement;
        //                  foreach (string str in tab)
        //                  {
        //                      if (!ok)
        //                          return false;
        //                      if (string.IsNullOrEmpty(str))
        //                          continue;
        //                      var str_ = str.Trim();
        //                      if (str_ == string.Empty)
        //                          continue;

        //                      ok = name.Contains(str_)
        //                          || artist.Contains(str_)
        //                          || album.Contains(str_)
        //                          || classement.StartsWith(str_);

        //                  }

        //                  return ok;

        //              };
        //          }
        //          catch (Exception ex)
        //          {
        //              App.log.log(ex.ToString()); 
        //          }
        //      }
        //  }
        ////  private static filterTask filtertask = new filterTask(); 
        private static IDisposable work;
        private static FilterTask filterTask = null;

        private static bool cancel;
        public static void doFilter0(ICollectionView coll, string filter)
        {

            ILogger log = App.log;
            log.log("filter=>{0}", filter);
            lock (_lock)
            {
                if (work == null)
                {
                    log.log("filter=>{0} verrou libre", filter);
                    work = coll.DeferRefresh();
                }
                else
                {
                    log.log("filter=>{0} verrou pris, abandon tâche en cours", filter);
                    cancel = true;
                }
            }

            var _cancel = cancel;
            if (_cancel)
                log.log("filter=>{0} verrou pris, attente fin tâche en cours", filter);
            while (cancel)
                Thread.Sleep(30);

            if (_cancel)
                log.log("filter=>{0} verrou pris, fin d'attente fin tâche en cours", filter);

            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 


            _cancel = cancel;
            if (!_cancel)
            {
                lock (_lock)
                    _cancel = cancel;
            }

            if (!_cancel)
            {
                log.log("filter=>{0} lancement filtre", filter);
                coll.Filter = item =>
                {
                    if (cancel)
                        return false;
                    TrackListViewModel vitem = item as TrackListViewModel;
                    if (vitem == null) return false;



                    //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                    //    return vitem.Classement.StartsWith(filter);
                    bool ok = true;
                    var name = vitem.Name.Trim().ToLower().removeAccent();
                    var artist = vitem.Artist.Trim().ToLower().removeAccent();
                    var album = vitem.Album.Trim().ToLower().removeAccent();
                    var classement = vitem.Classement;
                    foreach (string str in tab)
                    {
                        if (!ok)
                            return false;
                        if (string.IsNullOrEmpty(str))
                            continue;
                        var str_ = str.Trim();
                        if (str_ == string.Empty)
                            continue;

                        ok = name.Contains(str_)
                            || artist.Contains(str_)
                            || album.Contains(str_)
                            || classement.StartsWith(str_);

                    }

                    return ok;

                };

                if (cancel)
                    log.log("filter=>{0} la tâche a été interrompue", filter);
            }
            else
            {
                log.log("filter=>{0} finalement pas de lancement", filter);
            }
            lock (_lock)
            {
                if (!cancel)
                {
                    if (work != null)
                    {
                        log.log("filter=>{0} application du filtre", filter);
                        work.Dispose();
                    }
                    else
                    {
                        log.log("filter=>{0} ben pourquoa le work était null ????", filter);
                    }
                    work = null;

                }
            }

            lock (_lock)
                cancel = false;

            log.log("filter=>{0} fin", filter);
        }




        private class FilterTask
        {
            public static ConfFilter conf = new ConfFilter();
            private ICollectionView coll;
            public readonly string filter0;
            public readonly bool filterNext;

            private string filter;
            private bool _cancel;
            private bool end;
            private Thread th;
            SimpleChrono log;
            public string step;
            private HashSet<int> l = new HashSet<int>();
            public FilterTask(string filter, bool filterNext, ICollectionView coll, SimpleChrono log)
            {
                this.filter0 = filter;
                this.filter = filter;
                this.filterNext = filterNext;

                this.coll = coll;
                this.log = log;
                step = "ini";
                th = new Thread(calc);
                th.Start();
            }

            public void cancel()
            {
                lock (_lock)
                    _cancel = true;
            }

            public bool End { get { return end; } }
            public bool Cancel { get { return _cancel; } }
            private bool toClear;

            private void calc()
            {
                step = "calc";
                try
                {
                    if (string.IsNullOrEmpty(filter) && !filterNext)
                    {
                        toClear = true;
                        apply();
                        return;
                    }
                    toClear = false;

                    filter = filter.Trim().ToLower().removeAccent();
                    //if (string.IsNullOrWhiteSpace(filter) && !filterNext && conf.includeVirtual && conf.includeVirtualArtist)
                    //{
                    //    clear(); 
                    //    return;
                    //}

                    var tab = filter.Split(' ');

                    int nb = 0;
                    int nbOk = 0;

                    foreach (TrackListViewModel vitem in coll.SourceCollection)
                    {
                        if (_cancel)
                            return;

                        if (filterNext && !vitem.PieceGen.IsNext)
                            continue;
                        if (conf.onlyMaster && vitem.Piece.Parent != null)
                            continue;
                        if (!filterNext)
                        {
                            if (vitem.PieceGen.Virtual && !conf.includeVirtual)
                                continue;
                            if (vitem.PieceGen.VirtualByArtist && !conf.includeVirtualArtist)
                                continue;
                        }



                        bool ok = true;

                        if (conf.onlyId)
                        {
                            ok = filter == vitem.PieceId.ToString();
                        }
                        else
                        {

                            var name = vitem.Name.Trim().ToLower().removeAccent();
                            var artist = vitem.Artist.Trim().ToLower().removeAccent();
                            var album = vitem.Album.Trim().ToLower().removeAccent();
                            var classement = vitem.Classement;
                            foreach (string str in tab)
                            {
                                if (ok)
                                {
                                    if (string.IsNullOrEmpty(str))
                                        continue;
                                    var str_ = str.Trim();
                                    if (str_ == string.Empty)
                                        continue;

                                    ok = name.Contains(str_)
                                        || artist.Contains(str_)
                                        || album.Contains(str_)
                                        || classement.StartsWith(str_)
                                        || (conf.includeId && str == vitem.PieceId.ToString())
                                        ;
                                }
                                else
                                    break;

                            }
                        }


                        nb++;
                        if (ok)
                        {
                            if (conf.family)
                            {
                                foreach (Piece p in vitem.PieceGen.Master)
                                {
                                    if (!filterNext)
                                    {
                                        if (p.Virtual && !conf.includeVirtual)
                                            continue;
                                        if (p.VirtualByArtist && !conf.includeVirtualArtist)
                                            continue;
                                    }
                                    l.Add(p.PieceId);
                                }
                            }
                            else
                                l.Add(vitem.PieceId);

                            nbOk++;
                        }
                    }

                    log.log(string.Format("{0}/{1}", nbOk, nb));
                    // log.log(string.Format("calc:{0} item{1} {2} sélectionné{3}", nb, (nb > 1 ? "s" : ""), nbOk, (nbOk > 1 ? "s" : "")));   

                    lock (_lock)
                    {
                        if (_cancel)
                            return;
                    }


                    apply();


                }
                finally
                {
                    if (_cancel)
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par cancel");
                    }
                }





            }




            public void apply()
            {
                step = "apply";

                bool __cancel = _cancel;

                if (!__cancel)
                {
                    lock (_lock)
                        __cancel = _cancel;
                }


                if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
                {

                    if (__cancel)
                        return;
                    step = "applyAppDispatcher";
                    try
                    {
                        if (toClear)
                        {
                            log.log("clear filter");
                            coll.Filter = null;
                            log.log("fin clear filter");
                            return;
                        }

                        if (work == null)
                        {
                            log.log("creation du tempo");
                            work = coll.DeferRefresh();
                        }
                        else
                        {
                            log.log("tempo déjà créé ");

                        }


                        coll.Filter = item =>
                        {
                            if (_cancel)
                                return false;

                            var t = item as TrackListViewModel;
                            if (t == null)
                                return false;
                            if (!l.Contains(t.PieceId))
                                return false;
                            return true;
                        };




                        if (!__cancel)
                        {
                            log.log("application");
                            work.Dispose();
                            work = null;
                            log.log("fin application");
                        }
                        else
                        {
                            log.log("abandon application");
                        }
                    }
                    finally
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par application");
                        PlayerViewModel.Instance.makeResume();
                        PlayerViewModel.Instance.focusHelp();
                    }
                }
                else
                {
                    App.Current.Dispatcher.BeginInvoke(new Action(apply), App.DISPATCHER_PRIORITY);
                }
            }

            public override string ToString()
            {
                return string.Format("en cours:{0} step:{1} end:{2} cancel:{3}", filter0, step, End, Cancel);
            }

        }


        public static void doFilter(ICollectionView coll, string filter)
        {
            SimpleChrono log = new SimpleChrono(string.Format("\tfilter=>{0}\t", filter), App.log);

            log.log("");
            lock (_lock)
            {
                bool _cancelCurrent = false;
                bool _same = false;

                if (filterTask != null)
                {
                    log.log(filterTask.ToString());
                }

                _cancelCurrent = filterTask != null && !filterTask.End;
                _same = _cancelCurrent && filterTask.filter0.Equals(filter) && filterTask.filterNext == Instance.FilterNext;
                if (_same)
                {
                    log.log("identique");
                    return;
                }
                else if (_cancelCurrent)
                {
                    log.log("abandon tâche en cours");
                    filterTask.cancel();
                }

                else
                {
                    log.log("verrou libre");
                }

                filterTask = new FilterTask(filter, Instance.filterOnlyNext, coll, log);

            }





        }



        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}


        public void doFilter(String filter)
        {
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);

        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
            {
                string newResume = resume;
                try
                {

                    IEnumerable items = null;
                    var provider = DisplayProvider;
                    if (provider == null)
                        return;
                    var tracks = provider.PresentationTracks;
                    int nbOrg = -1;
                    items = tracks;
                    if (items == null)
                        return;

                    var selected = provider.SelectedTracks;
                    if (selected.Count > 1)
                    {
                        items = selected;
                        nbOrg = 0;
                        foreach (TrackListViewModel t in tracks)
                            nbOrg++;
                    }
                    int nb = 0, nbSelected = 0, nbPresent = 0;
                    TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationPresent = new TimeSpan();
                    HashSet<int> h = new HashSet<int>();

                    foreach (TrackListViewModel track in items)
                    {
                        if (!h.Add(track.PieceGen.MasterId))
                            continue;
                        nb++;
                        duration += track.Duration;
                        if (track.Enabled)
                        {
                            nbSelected++;
                            durationSelected += track.Duration;
                        }
                        if (track.Exists)
                        {
                            nbPresent++;
                            durationPresent += track.Duration;
                        }
                    }

                    ITextWriter sb = new pdb.util.StringBuilder();
                    sb.Append(nb);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    if (nbOrg >= 0)
                    {
                        sb.Append(" sur ");
                        sb.Append(nbOrg);
                        sb.Append(",");
                    }
                    sb.Append(" ");
                    humanDuration(sb, duration);
                    sb.Append(" ( ");
                    sb.Append(nbSelected);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nbSelected > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationSelected);

                    sb.Append(" )");

                    if (nbPresent > 0)
                    {
                        sb.Append(" presents: ");
                        sb.Append(nbPresent);
                        sb.Append(" ");
                        sb.Append("elt");
                        if (nb > 1)
                            sb.Append("s");
                        sb.Append(" ");
                        humanDuration(sb, durationPresent);
                    }
                    sb.Append("\t");

                    var currentTrack = TrackListViewModel.HumanSelected;
                    if (currentTrack != null)
                    {
                        humanSize(sb, currentTrack.Size);
                        sb.Append(" ");
                        sb.Append(currentTrack.getLocation());
                    }

                    newResume = sb.ToString();

                }
                catch (Exception e0)
                {
                    App.log.log(e0.ToString());
                }
                finally
                {
                    if (newResume != resume)
                    {
                        resume = newResume;
                        if (resumeChange != null)
                        {
                            try
                            {
                                resumeChange(this, EventArgs.Empty);
                            }
                            catch (Exception ex)
                            {
                                App.log.log(ex.ToString());
                            }
                        }
                    }
                }
            }
            else
            {
                App.Current.Dispatcher.BeginInvoke(new Action(makeResume), App.DISPATCHER_PRIORITY);
            }

        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append(size.HumanReadableSize(-1));
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append("j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append("m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append("m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append("s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Threading;
using pdb.db.obj;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;


namespace pdb.player.ViewModel
{
    public class PlayListViewModel : BibViewModelBase, INotifyCollectionChanged, IEnumerable<PlayListViewModel>
    {
        protected Logger log;
        private object _lock = new object();
        private CPlayList pl;
        private List<BibViewModelBase> _childs = new List<BibViewModelBase>();
        protected List<PlayListViewModel> _playlists = new List<PlayListViewModel>();
        //  private List<PlayListViewModel> __playlists = new List<PlayListViewModel>(); 
        private List<TrackListViewModel> _tracks = new List<TrackListViewModel>();

        private static List<IRedraw> gui = new List<IRedraw>();
        internal static void addDrow(IRedraw _gui) { gui.Add(_gui); }
        private static bool _log;
        public static bool Log { set { _log = value; } }

        #region export
        private List<TrackListViewModel> exportTracks = new List<TrackListViewModel>();
        public List<TrackListViewModel> ExportTracks { get { return exportTracks; } set { exportTracks = value; } }
        #endregion

        private static void redraw()
        {
            // foreach (IRedraw _gui in gui)  _gui.redraw();
        }

        #region optim recherche
        private static BgDictString<PlayListViewModel> dictPl = new BgDictString<PlayListViewModel>();
        private static BgDictString<TrackListViewModel> dictT = new BgDictString<TrackListViewModel>();
        protected static void recordPl(PlayListViewModel pl)
        {
            dictPl.Add(pl.pl.getPath(), pl);
        }

        protected static string getKey(PlayListViewModel pl, int id)
        {
            return pl.pl.getPath() + "|" + id;
        }


        protected static void recordTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            dictT.Add(getKey(pl, t.PieceId), t);
        }

        public static bool containsTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            return dictT.ContainsKey(getKey(pl, t.PieceId));
        }

        protected static void removeTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            dictT.Remove(getKey(pl, t.PieceId));
        }

        public static TrackListViewModel findTrack(PlayListViewModel pl, int id)
        {
            var key = getKey(pl, id);
            if (dictT.ContainsKey(key))
                return dictT[key];
            return null;
        }

        public TrackListViewModel FindTrack(int id)
        {
            return findTrack(this, id);
        }

        public static void resetExport(exportState state)
        {
            misc.log("resetExport {0}", state);
            try
            {
                foreach (var t in dictT.Values)
                    t.ExportStatus = state;
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public static void setExport(int id, exportState state)
        {
            if (_selectedPl != null)
            {

                try
                {
                    var t = findTrack(_selectedPl, id);
                    if (t != null)
                    {
                        t.ExportStatus = state;
                    }

                    //foreach (TrackListViewModel t in _selectedPl._tracks)
                    //{
                    //    if (t.PieceId == id)
                    //        t.refresh();
                    //}
                }
                //foreach (TrackListViewModel t in dictT.Values)
                //{
                //    if (t.PieceId == id)
                //        t.ExportStatus = state;
                //}

                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }


        }

        protected bool contains(PlayListViewModel pl, int id)
        {
            var key = getKey(pl, id);
            if (dictT.ContainsKey(key))
                return true;
            return false;
        }


        #endregion


        static PlayListViewModel()
        {
            //  App.refresh += new EventHandler(App_refresh);
        }

        static void App_refresh(object sender, EventArgs e)
        {
            //var pl = _selectedPl;
            //if (pl != null)
            //    pl.refresh(); 
        }

        public bool isSubList(string name)
        {
            return pl.isSubList(name);
        }

        public bool isSubList(PlayListViewModel pl)
        {
            return this.pl.isSubList(pl.PlayList);
        }

        private void init()
        {
            _childs.Clear();
            _playlists.Clear();
            _tracks.Clear();

            foreach (PlComponent component in pl)
            {

                if (component is CPlayList)
                {
                    var sublist = component as CPlayList;
                    var _pl = new PlayListViewModel(sublist, this);
                    _childs.Add(_pl);
                    _playlists.Add(_pl);
                    recordPl(_pl);
                    //_pl.PropertyChanged += new PropertyChangedEventHandler(_pl_PropertyChanged);
                    //_pl.CollectionChanged += new NotifyCollectionChangedEventHandler(_pl_CollectionChanged);
                    //              __playlists.Add(_pl); 
                }
                else
                {
                    var track = component as TrackList;
                    if (track.Virtual && !PlayerViewModel.Instance.WithVirtualAlbum)
                        continue;
                    var _t = new TrackListViewModel(track, this);
                    _childs.Add(_t);
                    _tracks.Add(_t);
                    recordTrack(_t, this);
                }
            }

            allTracks = new AllTracksViewModel(this, false, false);
        }


        public PlayListViewModel get(string name)
        {
            return get(name, false);
        }

        public PlayListViewModel get(string name, bool create)
        {
            foreach (var pl in _playlists)
                if (pl.Name == name)
                    return pl;
            if (!create)
                return null;
            var _pl = new CPlayList(name, this.pl);
            var _new = new PlayListViewModel(_pl, this);
            _playlists.Add(_new);
            _childs.Add(_new);
            recordPl(_new);
            //_new.PropertyChanged += _pl_PropertyChanged;
            //_new.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, _new));

            //  redraw(); 
            return _new;
        }


        private PlayListViewModel _getFromPath(string[] tab, int index)
        {
            for (; index < tab.GetLength(0); index++)
            {
                string dir = tab[index];
                if (string.IsNullOrEmpty(dir))
                    continue;
                if (dir.Equals(Name))
                    continue;
                var sub = get(dir, false);
                if (sub == null)
                    return null;
                return sub._getFromPath(tab, index + 1);
            }

            return this;

        }

        public PlayListViewModel getFromPath(string path)
        {
            var tab = path.Split(PlayListComposite.SEP);
            return _getFromPath(tab, 0);
        }

        public List<TrackListViewModel> Tracks { get { return _tracks; } }
        private AllTracksViewModel allTracks;
        public AllTracksViewModel AlltracksVm { get { return allTracks; } }

        //private AllTracksViewModel alltracksVmd;
        //public AllTracksViewModel AlltracksVmd
        //{
        //    get
        //    {
        //        if (alltracksVmd == null)
        //            alltracksVmd = new AllTracksViewModel(this, true, false);
        //        return alltracksVmd;

        //    }
        //}

        //private AllTracksViewModel alltracksFather;
        //public AllTracksViewModel AllTrackFather
        //{
        //    get
        //    {
        //        if (alltracksFather == null)
        //            alltracksFather = new AllTracksViewModel(this,null, true);
        //        return alltracksFather;
        //    }
        //}


        //private AllTracksViewModel alltracksFatherDisabled;
        //public AllTracksViewModel AllTrackFatherDisabled
        //{
        //    get
        //    {
        //        if (alltracksFatherDisabled == null)
        //            alltracksFatherDisabled = new AllTracksViewModel(this, true, true);
        //        return alltracksFatherDisabled;
        //    }
        //}

        public PlayListViewModel(CPlayList pl)
            : this(pl, null)
        {
        }

        private PlayListViewModel(CPlayList pl, PlayListViewModel parent)
            : base(pl, parent)
        {
            this.pl = pl;
            log = Logger.getLogger(pl.getPath());
            init();

        }
        public CPlayList PlayList { get { return pl; } }

        public string Name
        {
            get
            {
                return pl.Name;
            }
            set
            {
                if (value != Name)
                {
                    pl.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        #region selected

        /// <summary>
        /// element sélectionné. Répercuté jusqu'à la racine de l'arbre
        /// </summary>
        private static PlayListViewModel _selectedPl;
        public static PlayListViewModel SelectedPlayList
        {
            get
            {
                return _selectedPl;
            }
            private set
            {
                if (_selectedPl == value)
                    return;
                var _oldpl = _selectedPl;
                _selectedPl = value;
                if (_selectedPl != null)
                {
                    _selectedPl.IsSelected = true;
                    _selectedPl.IsExpanded = true;
                }
                OnSelectedPlayListChange(_oldpl);
            }
        }

        public static void initSelected(string strPl)
        {
            if (!string.IsNullOrEmpty(strPl))
            {
                var selected = App.bib.Root.getFromPath(strPl);

                if (selected != null)
                    PlayListViewModel.SelectedPlayList = selected;

            }
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;

                if (_isSelected)
                {
                    SelectedPlayList = this;
                }

            }
        }

        #endregion

        public static event EventHandler selectedPlaylistChange;
        private static void OnSelectedPlayListChange(PlayListViewModel oldPl)
        {
            if (selectedPlaylistChange != null)
                selectedPlaylistChange(oldPl, EventArgs.Empty);
        }


        #region INotifyCollectionChanged Members

        public event NotifyCollectionChangedEventHandler CollectionChanged;

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said
            lock (_lock)
            {
                var eventHandler = CollectionChanged;
                if (eventHandler != null)
                {
                    Delegate[] delegates = eventHandler.GetInvocationList();
                    // Walk thru invocation list
                    foreach (NotifyCollectionChangedEventHandler handler in delegates)
                    {
                        try
                        {
                            var dispatcherObject = handler.Target as DispatcherObject;
                            // If the subscriber is a DispatcherObject and different thread
                            if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            {
                                var ope =
                                dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                                   handler, this, e);
                                ope.Completed += ope_Completed;
                            }
                            else // Execute handler as is
                                handler(this, e);
                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString());
                        }
                    }
                }
            }

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (this.CollectionChanged == null)
            //    {
            //        int toto = 0;
            //    }
            //    else
            //        this.CollectionChanged(this, e);               
            //}
            //else
            //    dispatcher.Invoke(new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e); 

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("PlayListViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
        }

        #endregion

        public PlayListViewModel getOrCreatePlayList(string name)
        {

            var found = _playlists.Find(pl => pl.Name == name);
            if (found == null)
            {
                found = AddPlayList(name);
            }

            return found;
        }

        public PlayListViewModel AddPlayList(string name)
        {
            var subModel = new CPlayList(name, pl);
            var sub = new PlayListViewModel(subModel, this);
            _childs.Add(sub);
            _playlists.Add(sub);
            recordPl(sub);
            //   __playlists.Add(sub);
            //sub.PropertyChanged += _pl_PropertyChanged;
            //sub.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, sub));
            // PLayLists.Add(sub); 
            // redraw(); 
            return sub;
        }

        public TrackListViewModel AddTrack(IFile file, bool signal)
        {
            // var piece = App.Db.getPiece(location);
            return AddTrack(file as Piece, signal);

        }

        public TrackListViewModel AddTrack(Piece piece, bool signal)
        {
            if (_log) log.log("{0} AddTrack {1}", pl.getPath(), piece.ToString());
            if (contains(this, piece.PieceId))
            {
                App.Instance.InfoIHm(string.Format("le morceau {0} est déjà présent dans la liste {1}", piece, this), "Ajout dans la playlist");
                return null;
            }
            var tl = new TrackList(piece);
            pl.add(tl);
            var p = piece.Track;
            CPiece cPiece = null;
            if (p is CPiece)
                cPiece = p as CPiece;

            else if (p is TrackListViewModel)
            {
                var pp = ((TrackListViewModel)p).Piece;
                cPiece = pp as CPiece;
            }


            //if (cPiece != null)
            //    pl.addPiece(cPiece);
            var vm = new TrackListViewModel(tl, this);
            _childs.Add(vm);
            _tracks.Add(vm);
            recordTrack(vm, this);
            //  vm.PropertyChanged += _pl_PropertyChanged;
            if (signal)
            {
                //OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, vm));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }

            return vm;
        }

        public void RemoveTrack(TrackListViewModel tl, bool signal)
        {
            if (_log) log.log("{0} RemoveTrack {1}", pl.getPath(), tl.Track.Piece);
            _childs.Remove(tl);
            _tracks.Remove(tl);
            removeTrack(tl, this);


            tl.remove();
            //TODO faire la suppression de l'item de liste org

            if (signal)
            {
                // OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, tl));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }
        }

        private void insert(TrackListViewModel k, List<IFile> newElements)
        {
            int indexInsert = k.Index - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k);
        }

        private void insert2(TrackListViewModel k, List<Piece> newElements)
        {
            int indexInsert = k.Index2 - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k.PieceGen);
        }

        public void mergeList(ICollection<IFile> newElements_, IAbortTask writer)
        {
            lock (Consolid.Lock)
            {
                lock (Albums.Lock)
                {
                    var tt = TrackListViewModel.HumanSelected;
                    if (tt != null)
                    {
                        tt.refresh();
                        //var g = tt.Grouping; 
                        // tt.Grouping = tt.PieceGen.RankAlbumReverse.ToString();
                    }

                    // bool isMe = PlayListViewModel.SelectedPlayList == this;
                    bool isAlbum = this.isSubList("album");
                    bool isGen = this.isSubList("gen");

                    var confalbum = App.gen.SortAlbumMode;
                    int stackBefore = 4;
                    if (confalbum != null && confalbum.stackBefore > 0)
                        stackBefore = confalbum.stackBefore;

                    bool checkStack = (PlayListViewModel.SelectedPlayList == null || PlayListViewModel.SelectedPlayList == this) && isGen && !isAlbum && confalbum.stackEnabled;

                    int _indexAlbumRead = -1;
                    int _indexTrackRead = -1;
                    Album _currentAlbum = null;
                    TrackListViewModel current = TrackListViewModel.CurrentPlaying;
                    Album currentAlbum = null;
                    if (current != null)
                        currentAlbum = current.album;
                    var conf = CConf.ConfGen;
                    List<TrackListViewModel> toDelete = new List<TrackListViewModel>();
                    List<TrackListViewModel> toKeep = new List<TrackListViewModel>();

                    var newElements = new HashList<IFile>(newElements_);


                    BgDict<int, bool?> newElt = new BgDict<int, bool?>();
                    foreach (IFile elt in newElements_)
                    {
                        newElt[elt.PieceId] = false;
                    }

                    int indexAlbumOrg = -1;
                    int indexTrackOrg = -1;
                    var tracks = _tracks;
                    //if (isMe)
                    //{
                    tracks = new List<TrackListViewModel>(_tracks);
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
                    // }

                    foreach (TrackListViewModel tl in tracks)
                    {
                        if (tl.album != _currentAlbum)
                        {
                            _currentAlbum = tl.album;
                            _indexAlbumRead++;
                            _indexTrackRead = 0;
                        }
                        else
                            _indexTrackRead++;
                        var found = newElt[tl.PieceId] != null;
                        bool keep = false;
                        //if (isMe)
                        //{
                        if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                        {
                            keep = true;
                        }
                        else if (current != null && current.PieceId == tl.PieceId)
                        {
                            keep = true;
                            indexAlbumOrg = _indexAlbumRead;
                            indexTrackOrg = _indexTrackRead;
                        }
                        //}

                        newElt[tl.PieceId] = keep;


                        //if (current != null && !keep && tl.Location == current.Location)
                        //{
                        //    App.log.log("bizarre");
                        //}
                        if (!found)
                        {
                            if (keep)
                                toKeep.Add(tl);
                            else
                                toDelete.Add(tl);
                        }
                    }

                    //Addition
                    List<IFile> toAdd = new List<IFile>();
                    foreach (IFile elt in newElements)
                    {
                        if (writer.Aborted)
                            return;

                        bool found = contains(this, elt.PieceId);


                        if (!found)
                            toAdd.Add(elt);

                    }
                    //  log.log("mergeList::fin determination toAdd");

                    if (toAdd.Count > 0 && _log)
                        log.log("{0} {1} elt to add", this, toAdd.Count);

                    if (tracks.Count > 0 && toAdd.Count > 100)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt to add c'est trop!", this, toAdd.Count);
                        toAdd.Clear();
                        //return;
                        //var l = new List<IFile>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toAdd[i]);
                        //toAdd = l;
                    }

                    if (tracks.Count > 0 && toDelete.Count > 0 && _log)
                        log.log("{0} {1} elt to delete", this, toDelete.Count);

                    if (toDelete.Count > 100)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt toDelete c'est trop!", this, toDelete.Count);

                        toDelete.Clear();
                        //var l = new List<TrackListViewModel>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toDelete[i]);
                        //toDelete = l;
                    }


                    int count = toAdd.Count;
                    for (int i = 0; i < count; i++)
                    {
                        if (writer.Aborted) return;

                        AddTrack(toAdd[i], false);
                    }

                    foreach (TrackListViewModel vm in toDelete)
                    {
                        if (writer.Aborted) return;
                        RemoveTrack(vm, false);
                    }


                    var newElements3 = newElements;

                    if (isGen)
                    {
                        HashSet<string> moved = new HashSet<string>();
                        HashSet<Album> empeached = new HashSet<Album>();
                        HashSet<string> unavailable = new HashSet<string>();
                        newElements3 = new HashList<IFile>();
                        // chercher le premier album non quarantaine
                        decimal min = int.MaxValue;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            var t = newElements[i] as Piece;
                            if (t.StackValue == 0 && t.PieceAlbum != null)
                            {
                                min = t.PieceAlbum.ClassementValueLight;
                                break;
                            }
                        }


                        int ifirst = 0;
                        bool b = false;
                        Album courant = null;
                        for (; ifirst < newElements.Count; ifirst++)
                        {
                            var t = newElements[ifirst] as Piece;
                            if (t.PieceAlbum == courant)
                                continue;
                            courant = t.PieceAlbum;

                            if (courant.Absent)
                            {
                                unavailable.Add(courant.Key);
                            }
                            else
                            {
                                if (courant.StackValue > 0 && checkStack && courant.ClassementValueLightSt >= min)
                                {
                                    if (!b)
                                    {
                                        courant.Empeached1 = true;
                                        b = true;
                                    }
                                    moved.Add(courant.Key);
                                    empeached.Add(courant);
                                    courant.Moved = true;
                                    courant.Empeached = true;

                                }
                                else break;
                            }


                        }

                        if (ifirst < newElements.Count && checkStack)
                        {
                          //  int i = 0;

                            //HashSet<Album> aux = new HashSet<Album>();
                            //foreach (Album album in empeached)
                            //{
                            //    aux.Add(album); 
                            //}
                            //for (; i < newElements.Count; i++)
                            //{
                            //    var t = newElements[i] as Piece;
                            //    var a = t.PieceAlbum;
                            //    if (a == null)
                            //        continue;
                            //    if (aux.Add(a))
                            //    {
                            //        a.empeachedDecrement(); 
                            //    }
                            //}
                            HashSet<Album> albs = new HashSet<Album>();
                            //Album alb = null;
                            //Album alb2 = null;
                            //Album alb3 = null;
                            //Album alb4 = null;

                            courant = null;
                            int i = ifirst;
                            while (true)
                            {
                                if (i >= newElements.Count)
                                    break;
                                var t = newElements[i] as Piece;
                                if (t.StackValue > 0 && t.ClassementValueLightSt >= min)
                                {
                                    moved.Add(t.PieceAlbum.Key);
                                    t.Moved = true;
                                    if (t.isEmpeached())
                                        empeached.Add(t.PieceAlbum);

                                }
                                else if (t.AlbumAbsent)
                                { }// moved.Add(t.Album); 
                                else
                                {
                                    var _alb = t.PieceAlbum;
                                    if (courant != _alb)
                                    {
                                        courant = _alb;

                                        if (!albs.Contains(courant))
                                        {
                                            if (albs.Count < stackBefore)
                                            {
                                                albs.Add(courant);
                                            }
                                            else
                                                break;
                                        }




                                        //if (alb == null)
                                        //    alb = courant;
                                        //else if (alb2 == null)
                                        //    alb2 = courant;
                                        //else if (alb3 == null)
                                        //    alb3 = courant;
                                        //else if (alb4 == null)
                                        //    alb4 = courant;
                                        //else
                                        //    break;
                                    }

                                    newElements3.Add(t);
                                }
                                i++;
                            }

                            for (i = 0; i < newElements.Count; i++)
                            {
                                var t = newElements[i] as Piece;
                                var alb_ = t.PieceAlbum;
                                if (alb_ == null)
                                    continue;

                                if (!albs.Contains(alb_))
                                    newElements3.Add(t);
                                //if (alb_ != alb && alb_ != alb2 && alb_ != alb3 && alb_ != alb4)
                                //    newElements3.Add(t);
                            }
                        }
                        else
                            newElements3 = newElements;

                        allTracks.setNbAlbum(unavailable.Count, empeached.Count, moved.Count);



                    }
                    else
                    {
                        allTracks.setNbAlbum(-1, -1, -1);
                    }




                    var newElements2 = new List<IFile>(newElements3);
                    List<Piece> stackSorted = null;
                    if (checkStack)
                    {
                        stackSorted = new List<Piece>();
                        foreach (IFile iFile in newElements2)
                        {
                            var t = findTrack(this, iFile.PieceId);
                            if (t != null)
                            {
                                stackSorted.Add(t.PieceGen);
                            }
                        }

                        stackSorted.Sort(new PieceStackCmp());

                    }
                    foreach (IFile iFile in newElements3)
                    {
                        var keep = newElt[iFile.PieceId];
                        var t = findTrack(this, iFile.PieceId);
                        if (t != null)
                        {
                            if (true == keep)
                            {
                                int index0 = t.Index - 1;
                                int index1 = newElements2.IndexOf(iFile);
                                if (index1 > index0)
                                {
                                    newElements2.Remove(iFile);
                                    insert(t, newElements2);
                                }

                                if (checkStack)
                                {
                                    int index20 = t.Index2 - 1;
                                    int index21 = stackSorted.IndexOf(t.PieceGen);
                                    if (index21 > index20)
                                    {
                                        stackSorted.Remove(t.PieceGen);
                                        insert2(t, stackSorted);
                                    }
                                }
                            }

                        }
                    }

                    foreach (TrackListViewModel k in toKeep)
                    {
                        insert(k, newElements2);
                    }

                    if (checkStack)
                    {
                        foreach (TrackListViewModel k in toKeep)
                        {
                            insert2(k, stackSorted);
                        }
                    }

                    if (indexAlbumOrg >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;
                        bool dontTouch = false;

                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            var ifile = newElements2[i] as Piece;
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = newElements2.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {

                                newElements2.Remove(currentFile);
                                newElements2.Insert(newIndex, currentFile);
                            }

                            var currentFile2 = stackSorted.Find(p => p.PieceId == current.PieceId);
                            if (currentFile2 != null)
                            {
                                stackSorted.Remove(currentFile2);
                                stackSorted.Insert(newIndex, currentFile2);
                            }
                        }


                        // for (int i = 0; i < newElements2.Count; i++)
                        //{
                        //    var ifile = newElements2[i] as Piece;
                        //    var keep = newElt[ifile.PieceId];






                        //    if (true == keep)
                        //    {
                        //        var t = findTrack(this, ifile.PieceId);
                        //        if (t != null)
                        //        {
                        //            ///s'il était en position 0 , le placer en début. s"il était en 1....

                        //            var album = t.Album; 
                        //            if (i + 1 >= newElements2.Count)
                        //                break;



                        //            var inext = newElements2[i + 1];
                        //            var next = findTrack(this, inext.PieceId);
                        //            var nextAlbum = next.Album;
                        //            if (nextAlbum == album)
                        //                break; 

                        //            int iCurrent = i - 1;

                        //            IFile iprec = null;
                        //            TrackListViewModel prec = null;

                        //            while (true)
                        //            {

                        //                if (iCurrent < 0)
                        //                    break;
                        //                iprec = newElements2[iCurrent];
                        //                prec = findTrack(this, iprec.PieceId);
                        //                if (prec.Album == nextAlbum)
                        //                {
                        //                    newIndex = iCurrent;
                        //                }
                        //                else
                        //                    break;

                        //                iCurrent--;
                        //            }

                        //            if (newIndex != i)
                        //            {
                        //                newElements2.Remove(ifile);
                        //                newElements2.Insert(newIndex, ifile);
                        //            }
                        //        }
                        //    }
                        //}
                    }

                    int index = 1;
                    for (int i = 0; i < newElements3.Count; i++)
                    {
                        var ifile = newElements2[i];
                        var t = findTrack(this, ifile.PieceId);
                        if (t == null)
                        {
                            App.log.log("file ID {0} non trouvé dans {1} {2}", ifile.PieceId, this, ifile.Location);

                        }
                        else
                        {
                            //var keep = newElt[ifile.PieceId];
                            //if (true != keep)
                            t.Index = index;
                            // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                            if (i == 0)
                            {
                                t.refresh();
                                // var g = t.Grouping; 
                            }
                        }
                        index++;
                    }

                    if (checkStack)
                    {
                        index = 1;
                        for (int i = 0; i < stackSorted.Count; i++)
                        {
                            var t = findTrack( this,stackSorted[i].PieceId);
                            if (t == null)
                                continue; 

                            //var keep = newElt[ifile.PieceId];
                            //if (true != keep)
                            t.Index2 = index;
                            // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                            if (i == 0)
                            {
                                t.refresh();
                                // var g = t.Grouping; 
                            }

                            index++;
                        }
                    }

                    if (current != null && current.Index > 1)
                    {
                        App.log.log("le courant a l'index {0} {1}", current.Index, current);

                        int index1 = -1;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            if (newElements[i].PieceId == current.PieceId) { index1 = i; break; }
                        }

                        int index2 = -1;
                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            if (newElements2[i].PieceId == current.PieceId) { index2 = i; break; }
                        }

                        int index3 = -1;
                        for (int i = 0; i < newElements3.Count; i++)
                        {
                            if (newElements3[i].PieceId == current.PieceId) { index3 = i; break; }
                        }
                        App.log.log("indexes {0} {1} {2}", index1, index2, index3);

                    }



                }

                //if (toAdd.Count > 0 || toDelete.Count > 0)
                //{
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                //if (alltracksFather != null)
                //    alltracksFather.refresh();
                //if (alltracksFatherDisabled != null)
                //    alltracksFatherDisabled.refresh();

                //}
            }
        }

        private class StackCmp : IComparer<TrackListViewModel>
        {
            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                int cmp = x.ClassementValueLightSt.CompareTo(y.ClassementValueLightSt);
                //if (x.StackValue > 0 && y.StackValue > 0)
                //    cmp = 
                //else
                //    cmp = x.Index.CompareTo(y.Index);
                if (cmp != 0)
                    return cmp;
                return x.Index.CompareTo(y.Index);
            }
        }

        public IEnumerator<PlayListViewModel> GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        private SortDescriptionCollection sort;
        public SortDescriptionCollection Sort { get { return sort; } set { sort = value; } }

        public string getEmpreinte()
        {
            var sb = new StringBuilder();
            sb.Append(exportTracks.Count);
            sb.Append(" éléments:");
            long hash = 0;
            foreach (TrackListViewModel t in exportTracks)
            {
                hash += t.PieceId.GetHashCode();
            }
            sb.Append(hash);

            return sb.ToString();

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\PlayerControler.xaml.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Threading;
using System.Windows.Controls.Primitives;
using System.Windows.Automation.Peers;
using pdb.player.Vue.Util;
using pdb.player.ViewModel.Colors;
using System.Threading;

namespace pdb.player.Vue
{
    /// <summary>
    /// Logique d'interaction pour PlayerControler.xaml
    /// </summary>
    public partial class PlayerControler : UserControl, IRecordClassmentObserver, IGradiant
    {
       // private Gradient confGradiant;
        public PlayerControler()
        {
            InitializeComponent();


            GradiantBuilder.Instance.Add(this);
            this.Loaded += PlayerControler_Loaded;
        }

        void PlayerControler_Loaded(object sender, RoutedEventArgs e)
        {
            this.MouseDoubleClick += new MouseButtonEventHandler(PlayerControler_MouseDoubleClick);
            DataContext = PlayerViewModel.Instance;
            DataGridPlayList.refreshOk += new EventHandler(DataGridPlayList_refreshOk);
            DetailClassementViewModel.RecordObserver = this;
            txtFilter.MouseDoubleClick += new MouseButtonEventHandler(txtFilter_MouseDoubleClick);
            PlayerViewModel.Instance.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(Instance_PropertyChanged);
            PlayerViewModel.Instance.Volume = 0.5; 
        }

        void PlayerControler_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            PlayerViewModel.Instance.focusHelp(); 
        }

        void Instance_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == "FilterNext")
                doFilter(txtFilter.Text); 
        }

      

        void txtFilter_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            new ConfFilterW(PlayerViewModel.Instance.ConfFilter).Show(); 
        }

        void DataGridPlayList_refreshOk(object sender, EventArgs e)
        {
            if (_currentPaying != null)
            {
                if (TrackListViewModel.CurrentPlaying == _currentPaying)
                    automateNextTrack();
                _currentPaying = null;
            }
        }

        void DetailClassementViewModel_classementChanged(object sender, EventArgs e)
        {
            focus();
        }

        private void focus()
        {
            if (!CheckAccess())
                Dispatcher.BeginInvoke(new Action(this.focus), App.DISPATCHER_PRIORITY);
            else
            {
                b_play.Focus();
            }
        }

        private void automateNextTrack()
        {
            if (!CheckAccess())
                Dispatcher.BeginInvoke(new Action(this.automateNextTrack), App.DISPATCHER_PRIORITY);
            else
            {
                ICommand forward = PlayerViewModel.Instance.Forward;
                if (forward.CanExecute(this))
                {
                    forward.Execute(this);
                }


            }
        }

        private void txtFilter_KeyUp(object sender, KeyEventArgs e)
        {
            String filter = txtFilter.Text;
            doFilter(filter);
        }

        private void doFilter(String filter)
        {
            PlayerViewModel.Instance.doFilter(filter);
        }

        private void btSort_Click(object sender, RoutedEventArgs e)
        {
            var conf = PlayerViewModel.ConfAlbumSort;
            var dialog = new ConfAlbumSortW(conf);
            dialog.Show();
        }



        public void signalClassementChange()
        {
            focus();
        }

        private TrackListViewModel _currentPaying;
        public void autoNextTrack(TrackListViewModel track)
        {
            _currentPaying = track;
        }



        ViewModel.Colors.Gradient IGradiant.Conf
        {
            get { return Couleurs.Instance.player.gradient; }
        }

        bool IGradiant.sensGradient
        {
            get { return false; }
        }

        void IBackGround.setBackground(Brush brush)
        {
            gmain.Background = brush;
        }

        private void cbNext_Checked(object sender, RoutedEventArgs e)
        {

        }

        
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Hibernator.cs">
    <content><![CDATA[using pdb.it;
using pdb.util;
using System.IO;
using System;
using System.Collections.Generic;

namespace pdb.podcast
{
    class Hibernator
    {
        public int go(Loader loader, List<TrackInfoItunes> tracks)
        {

            var conf = pdb.podcast.Tuning.Conf.Hibernate;
            if (!conf.enabled)
                return 0;
            var toH = new List<TrackInfoItunes>();
            var dirH = conf.dir;
            var list = conf.list;
            if (!string.IsNullOrEmpty(list))
            {

                var auto = loader.TreePlayList.getComposite("auto");
                if (auto != null)
                {
                    var itl = auto.getComposite(list);
                    if (itl != null)
                    {
                        foreach (var plc in itl)
                        {
                            if (plc is TrackInList)
                            {
                                var t = plc as TrackInList;
                                var piece = t.Piece as TrackInfoItunes;
                                if (piece == null)
                                {
                                    misc.log("plc pas un TrackInfoItunes {0}", plc);
                                    continue;
                                }
                                if (piece.Selected)
                                {
                                    misc.log("non hiberné car selected {0}", piece);
                                    continue;
                                }
                                Program.log.log("hibernation de {0} par liste", piece);
                                toH.Add(piece);
                            }
                        }
                    }
                }
            }

            select(conf, toH, tracks, false);


            int nb = 0;
            foreach (TrackInfoItunes track in toH)
            {
                var fv = FileRegister.Check(track.Location);
                if (fv.Exists)
                {
                    nb++;
                    track.hibernate(fv, dirH);
                }
            }


            return nb;
        }

        public void select(pdb.podcast.Tuning.Hibernate conf, List<TrackInfoItunes> toCheck, List<TrackInfoItunes> tracks, bool import)
        {
            bool critereDate = conf.dateMin > DateTime.MinValue && conf.dateMax < DateTime.MaxValue;
            bool critereAlbum = !string.IsNullOrEmpty(conf.album);
            bool critereLast = conf.nblast > 0;


            if (import || critereAlbum || critereDate || critereLast)
            {

                if (!critereLast)
                {
                    foreach (TrackInfoItunes t in tracks)
                    {
                        if (import)
                        {
                            //if (t.Present)
                            //    continue;
                        }
                        else
                        {
                            if (!t.Present)
                                continue;
                            if (t.Selected)
                                continue;
                        }


                        if (!critereDate || t.Pub >= conf.dateMin && t.Pub <= conf.dateMax)
                        {
                            if (!critereAlbum || t.Album.ToLower().Contains(conf.album.ToLower()))
                            {
                                toCheck.Add(t);
                            }
                        }
                    }
                }
                else
                {
                    Dictionary<string, Album> dict = new Dictionary<string, Album>();
                    tracks.Sort(new PodCastComparer());
                    foreach (TrackInfoItunes track in tracks)
                    {
                        string album = track.Album;
                        string key = album;
                        if (string.IsNullOrEmpty(album))
                        {
                            misc.log("pas d'album pour " + track.Location);
                            if (import)
                                toCheck.Add(track);
                            continue;

                        }

                        if (!dict.ContainsKey(key))
                        {
                            Album a = new Album(key);
                            dict.Add(key, a);
                        }
                        dict[key].add(track);
                    }

                    foreach (Album album in dict.Values)
                    {
                        if (critereAlbum)
                        {
                            if (album.Name.ToLower().Contains(conf.album.ToLower()))
                            {
                            }
                            else continue;
                        }

                        var list = album.List;
                        int count = list.Count;
                        int nb = 0;

                        for (int i = count - 1; i >= 0; i--)
                        {
                            var t = list[i];
                            if (!import)
                            {
                                if (t.Selected)
                                    continue;
                                if (!t.Present)
                                    continue;
                            }
                            if (!critereDate || t.Pub >= conf.dateMin && t.Pub <= conf.dateMax)
                            {
                                if (import)
                                {
                                    nb++;
                                    toCheck.Add(t);
                                    if (nb >= conf.nblast)
                                        break;
                                    continue; 
                                }

                              
                                if (t.Pub > conf.dateLast)
                                {
                                    nb++; 
                                    if (nb <= conf.nblast)
                                        continue; 
                                }                               

                                toCheck.Add(t); 
                            }
                        }
                    }
                }



            }
        }

        private class Album
        {
            private string name;
            private List<TrackInfoItunes> list = new List<TrackInfoItunes>();
            public Album(string name)
            {
                this.name = name;
            }
            public void add(TrackInfoItunes track)
            {
                list.Add(track);
            }
            public List<TrackInfoItunes> List { get { return list; } }
            public string Name { get { return name; } }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Auto;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;
using pdb.podcast.Delta;
using System.Threading.Tasks;
using pdb.podcast.Sort;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static Loader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto;
        static int step = -1;
        static Program _instance = new Program();
        static bool calculRoots = false;

        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        private static Chrono chrono = new Chrono();
        private static Logger logChrono;
        private static DB.Db db;

        //public static DB.Db Db { get { return db; } }


        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {

            Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono", true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true;

            FileRegister.init(new BgDictString0<FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true;

                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                Console.WriteLine("\nFin de l'opération d'enregistrement.");
                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Memory.End();
                Exporter.Abort();

                //if (_writeDb != null)
                //{
                //    misc.log("attente writeDb");
                //    _writeDb.Wait();
                //}
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                if (db != null)
                    db.write();
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}

        #region Task


        private List<ITrackInfoItunes> loadTracks(bool firstStep, bool forceLoad)
        {
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();

            loader.init();
            loader.reset(firstStep, forceLoad);
            loader.loadTracks(listTrack);
            loader.loadLists();

            return listTrack;

        }
        #endregion

        public void go(string[] args)
        {
            int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            if (countArgs > 0)
                confFile = args[0];

            Hibernator hibernator = new Hibernator();

            try
            {
                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start(10);

                // bool firstLoad = true;


                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                TrackInfoItunes.Date0 = Conf.Date0;
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                TrackInfoItunes.PlayedLevel = Conf.DateLevel;
                var itConf = new pdb.it.Conf(xelt);

                // loader = new Loader(itConf, true);
                bool import = Conf.Import.enabled;
                db = new DB.Db();
                loader = new Loader(itConf, import, db,
                    () =>
                    {
                        misc.Pre = "[Load " + step + "] ";

                        PlayList.AbortOpe();
                        BackGroundTaskMgr.AbortSpecial();
                        //   Thread.Sleep(1000); 
                        //  BackGroundTaskMgr.Start(); 
                    })

               ;
                // loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder;

                db.load();


                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();

                List<TrackInfoItunes> listIt = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);

                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}"));
                        chrono.reset("Program");

                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.Conf = new it.Conf(xelt);
                        // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut");

                        if (step == 0 || !Conf.Simulation)
                        {
                            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();


                            listTrack = loadTracks(step == 0, AutoBuilder.MustUpdate);
                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();

                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            // listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.Conf = new it.Conf(xelt);
                            //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {

                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                // loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            //    loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            listIt = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            GroupStat trackStat = new GroupStat();

                            loader.saveIds();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    dictLoc[t.Location] = t;
                                    listIt.Add(t);
                                    if (!t.Played)
                                        trackStat.recordTrack(t, typeState.all);
                                    trackStat.recordTrack(t, typeState.all);
                                }
                            }

                            db.recordIt(listIt);

                            if (Conf.Import.enabled)
                            {
                                var listImport = new List<TrackInfoItunes>();
                                hibernator.select(Conf.Import, listImport, db.Tracks, true);

                                foreach (TrackInfoItunes tdb in listImport)
                                {
                                    loader.import(tdb);
                                }
                            }





                            if (Conf.Import.enabled)
                            {
                                misc.log("fin");
                                return;
                            }

                            db.write();


                            chrono.bip("loadTracks");

                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            trackStat.report(descTrack);
                            log.log(descTrack.ToString());

                            var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            var trackFile = DescBuilder.create("Tracks", sbT);
                            trackStat.report(trackFile);
                            sbT.Flush();

                            asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            chrono.bip("desc tracks");
                            Logger.LogConsole = false;
                            //        loader.loadLists();
                            Logger.LogConsole = true;
                            chrono.bip("load list");

                        }
                        List<TrackInfoItunes> list2 = new List<TrackInfoItunes>();
                        DirConf root = null;
                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program");

                            xelt = Conf.Instance.load(false);
                            loader.Conf = new it.Conf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            var list = db.Tracks;
                            list2 = new List<TrackInfoItunes>(list.Count);
                            foreach (TrackInfoItunes track in list)
                            {
                                var copy = TrackInfoItunes.createCopy(track);
                                list2.Add(copy);
                                //track.clearLists(); // = selectMode.none;
                            }
                            chrono.bip("track.clearLists");
                            // Feeds.createInstance();
                            root = Conf.DirConf;
                            var feeds = root.Feeds;
                            if (Conf.GenFeed)
                            {
                                foreach (RootItItem rootItem in Conf.RootIt)
                                {
                                    var fAuto = loader.TreePlayList.getComposite(rootItem.name);
                                    var fFeeds = fAuto.getComposite("Feed");

                                    if (fFeeds != null)
                                    {
                                        scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                    }

                                }
                            }

                            foreach (TrackInfoItunes track in list2)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds");

                            //if (Conf.Single)
                            //{
                            //    var listS = new List<TrackInfoItunes>();
                            //    for (int i = 0; i < Limits.NB; i++)
                            //    {
                            //        var list0 = feeds.getTracks(i, int.MaxValue, int.MaxValue, null, null, 1, null); //feeds.ListTrackSingle;
                            //        foreach (var t in list0)
                            //        {
                            //            if (!listS.Contains(t))
                            //                listS.Add(t);
                            //        }

                            //    }

                            //    string[] folder = new string[] { "Select", "tmp" };
                            //    buildList("_auto", listS, 0, folder);
                            //}

                            //var sb = DescBuilder.create();

                            //Création des listes
                            //  oldRoot = root;

                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true;
                            AutoBuilder.init(true);
                            loadCandidat(root);

                            //  AutoBuilder.test(); 
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            //**********************************************************************************
                            //***************** Lancement "pour de faux" ***************************************
                            AutoBuilder.Init3();
                            LimitItemLoader.ModeSelection = false;
                            phase2(root);
                            Selection(root);
                            LimitItemLoader.ModeSelection = true;
                            //**********************************************************************************
                            Exporter.TopCopy();
                            chrono.bip("selection");

                           
                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.once)
                            {
                                var sorter = new Sorter(Conf.Sort, list2);
                                sorter.build(loader);
                                misc.log("fin");
                                return;
                            }
                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    if (count == 1)
                                        s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu");


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root);
                            //****************************************



                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                            //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            bool cangoAuto = AutoBuilder.Check(feeds);
                            chrono.bip("AutoBuilder");
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");



                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false;
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true;
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                tw = new StringBuilder();
                                feeds.rapportPreSelected(tw);
                                asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false;
                                log.log(sb2.ToString());
                                Logger.LogConsole = true;


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false;
                                log.log(sb3.ToString());
                                Logger.LogConsole = true;
                                chrono.bip("rapport");
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 


                        Logger.CreateNullLoggers = false;


                        calculRoots = false;
                        WritePlayList(root);




                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;
                            foreach (SelectParam p in listP)
                            {
                                if (p.etendue.Contains("s"))
                                {
                                    listS = new List<TrackInfoItunes>();
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.getFirstSelectedTracks(listS, p);
                                    buildList("_select", listS, prior, folder);
                                }
                            }

                            for (int level = 0; level < Limits.NB; level++)
                            {
                                foreach (SelectParam p in listP)
                                {
                                    if (p.etendue.Contains(level.ToString()))
                                    {
                                        p.level = level;
                                        folder = new string[] { "select", "tmp", p.name };
                                        listS = new List<TrackInfoItunes>();
                                        feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                        buildList("_" + level, listS, prior, folder);
                                    }
                                }
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);

                        foreach (TrackInfoItunes s in root.Feeds.getSelectedTracks())
                        {
                            s.updateNative();
                        }

                        foreach (TrackInfoItunes t in list2)
                        {
                            t.checkInOut();
                            var tdb = db.get(t);
                            if (tdb == null)
                            {
                                log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                continue; 
                            }
                            tdb.synch(t); 

                        }

                        db.write(); 




                        //if (Conf.Hibernate.enabled)
                        //{
                        //    Hibernator hibernator = new Hibernator();
                        //    var nb = hibernator.go(loader); 
                        //    if (nb >0)
                        //    {
                        //        misc.log("{0} elements hibernés", nb);
                        //        misc.log("fin ");
                        //        return; 
                        //    }

                        //}


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                ITextWriter sb = new StringBuilder();

                                log.log("Attente Classement " + sb.ToString());
                            }
                            Thread.Sleep(100);
                        }

                        int nbH = 0;
                        if (Conf.Hibernate.enabled)
                        {
                            nbH = hibernator.go(loader, list2);
                            if (nbH > 0)
                            {
                                misc.log("{0} elements hibernés", nbH);
                                misc.log("fin");
                                return;
                            }
                        }






                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");

                        if (Conf.Sort.enabled == Tuning.Sort.sortMode.all)
                        {
                            var sorter = new Sorter(Conf.Sort, list2);
                            sorter.build(loader);
                        }

                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in db.Tracks)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogAll(ex.ToString());
                        misc.log(ex.ToString());
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        private DirConf _attenteWriteHtml;
        private volatile object _lockReportHtml = new object();
        private bool _end;
        ThreadUtil thReport;

        private void postReport(DirConf dir)
        {
            if (thReport == null)
            {
                lock (_lockReportHtml)
                {
                    if (thReport == null)
                    {
                        thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
                        thReport.Start();
                    }
                }
            }

            lock (_lockReportHtml)
                _attenteWriteHtml = dir;
        }

        private void loopReportHtml()
        {
            DirConf traite = null;
            while (!_end)
            {
                Thread.Sleep(30);
                if (_attenteWriteHtml == null)
                    continue;
                lock (_lockReportHtml)
                {
                    if (_attenteWriteHtml == null)
                        continue;
                    traite = _attenteWriteHtml;
                    _attenteWriteHtml = null;
                }
                reportHtml(traite);
            }
        }


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
                //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
                //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders);
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders)
        {
            try
            {
                if (Conf.Simulation)
                    return;

                foreach (TrackInfoItunes track in list_)
                {
                    loader.reviveIfNecessary(track);
                }


                var rootIt = Conf.RootIt;
                RootItItem currentRoot = rootIt.roots[0];
                int count = rootIt.roots.Count;
                //   log.log("build list {0}",name);
                //  var list = new List<IFile>(list_);
                if (!calculRoots)
                {
                    calculRoots = true;
                    var list__ = new List<TrackInfoItunes>(list_);
                    list__.Sort(new PodCastComparer());



                    int countTrack = list_.Count;

                    long size = 0;
                    int j = 0;
                    int indexRoot = 0;



                    while (true)
                    {
                        if (j >= countTrack)
                            break;
                        TrackInfoItunes track = list__[j];
                        size += track.Size;
                        if (size <= currentRoot.size)
                        {
                            track.IndexRoot = indexRoot;
                        }
                        else
                        {
                            size = 0;
                            size += track.Size;
                            indexRoot++;
                            if (indexRoot >= count)
                                break;
                            currentRoot = rootIt.roots[indexRoot];
                            track.IndexRoot = indexRoot;
                        }
                        j++;
                    }

                }

                for (int r = 0; r < count; r++)
                {
                    currentRoot = rootIt.roots[r];
                    var folder = loader.TreePlayList.getComposite(currentRoot.name);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(currentRoot.name);
                    folders = new List<string>(folders);

                    var nname = name;
                    if (name.Contains(Path.DirectorySeparatorChar.ToString()))
                    {
                        var tab = name.Split(Path.DirectorySeparatorChar);
                        string str = null;
                        for (int i = 0; i < tab.GetLength(0); i++)
                        {
                            if (str != null)
                                folders.Add(str);
                            if (!string.IsNullOrEmpty(tab[i]))
                                str = tab[i];
                        }
                        if (!string.IsNullOrEmpty(str))
                            nname = str;
                    }
                    var list = list_.FindAll(t => t.IndexRoot == r);
                    var l = new List<IFile>(list);

                    for (int i = 0; i < folders.Count; i++)
                    {
                        var aux = folder;
                        folder = folder.getComposite(folders[i]);
                        if (folder == null)
                            folder = loader.getOrCreateFolder(aux, folders[i], l.Count > 0);
                        if (folder == null)
                            return;
                    }

                    //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
                    var playlist = loader.getPlayList(folder, nname, l.Count > 0);
                    if (playlist != null)
                    {
                        if (prior < int.MaxValue && prior >= 0)
                            playlist.setPrior(prior);
                        //if (list.Count > 0)
                        loader.mergeList(playlist, l, false, _instance, null);
                        //else
                        //    loader.removeList(folder, name);
                    }



                    //log.log("clear list {0}", name); 
                    //loader.ClearList(playlist);
                    //log.log("add items {0}", name); 
                    //foreach (TrackInfoItunes track in list)
                    //    loader.addItemToList(playlist, track); 

                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }


        }



        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            //if (pre > action.none && pre < action.writeTracksPre)
            //    log.log("{0} {1}", pre, dir.getPath());
            fLoader.Action(pre);

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());
            fLoader.Action(post);


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                                break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Comment = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.obj;
using pdb.it;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub
    {
        private static Loader loader;
        public static Loader Loader { set { loader = value; } }

        private int albumRating; public int AlbumRating { get { return albumRating; } }
        //  private bool ratingComputed; public bool RatingComputed { get { return ratingComputed; } }

        private void import(IITFileOrCDTrack native)
        {
            misc.log("import {0}", this);
            native.AlbumRating = albumRating;
            if (rating != albumRating)
                native.Rating = rating;
            native.PlayedDate = this.PlayedDate.ToUniversalTime();
            native.Enabled = this.enabled;
            native.PlayedCount = this.playCount;
        }

        public void import()
        {
            if (!isPresent())
                return;

            try
            {
                var native = TrackTrack;
                if (native == null)
                    native = Track;
                if (native == null)
                {
                    bgClass.add(new BgTaskImport(this));
                }
                else
                    import(native);

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public void import(TrackInfoItunes db)
        {
            this.albumRating = db.albumRating;
            this.rating = db.rating;
            this.rare = db.rare;
            this.info = db.info;
            this.playCount = db.playCount;
            this.PlayedDate = db.PlayedDate;
            this.enabled = db.enabled;
            present = true;
            db.present = true;

            import();
        }

        private DateTime offset;
        public DateTime Offset
        {
            set
            {
                if (offset == DateTime.MinValue)
                    offset = value;
            }
            get { return offset; }
        }

        public override IITFileOrCDTrack Track
        {
            get
            {
                if (track != null)
                    return track;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    // loader.resurrection(this);
                }
                return base.Track;
            }
        }

        public override IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (tracktrack != null)
                    return tracktrack;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    //   loader.resurrection(this);
                }
                return base.TrackTrack;
            }
        }

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        //private static bool _updateNative;
        //public static bool UpdateNative { get { return _updateNative; } set { _updateNative = value; } }
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                    defaultFolder += "Podcasts\\";
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;

        public int DbId { get { return _dbId; } set { if (_dbId <= 0) _dbId = value; } }

        private static int NB = 0;
        private int iddebug;

        public TrackInfoItunes()
        {
            NB++;
            iddebug = NB;
        }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        private LimitItem exclu;
        public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            var key = item.ID;
            if (!listLoad0.ContainsKey(key))
                listLoad0.Add(key, item);
        }
        public bool containsload(LimitItem item)
        {
            var key = item.ID;
            return listLoad0.ContainsKey(key);
        }

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        public bool containsSelect(LimitItem item)
        {
            var key = item.ID;
            return listSelected.ContainsKey(key);
        }
        public bool isPreselected { get { return listLoad0.Count > 0; } }
        public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {
                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        public void synch(TrackInfoItunes o)
        {
            _in = o._in;
            _out = o._out; 
        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            this.albumRating = track.AlbumRating;
            // this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!isPodcast)
                return;

            duree = new util.timeSpan(Duration);

            CheckPlay(this);

            //if (track.PlayedCount > 0)
            //{
            //    played = markAsPlayed(Rating, PlayedDate);
            //}

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Comment != commentByReleaseDate)
                    {
                        misc.log("chgt Comment � partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Comment = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Comment;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Comment)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment à partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Comment = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de gérer " + this, ex);
                }
            }
            finally
            {

                if (target)
                {

                    FileInfo file = new FileInfo(loc);
                    DirectoryInfo dirTrack = file.Directory;
                    DirectoryInfo dirPodcast = dirTrack.Parent;
                    if (!dirPodcast.Name.Equals(REFONTE))
                    {
                        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                        if (!dirV1.Exists)
                            dirV1.Create();

                        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                        string dirDest = Path.GetDirectoryName(dest);
                        string fileName = Path.GetFileName(dest);
                        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                        try
                        {
                            misc.log("deplacer " + loc);
                            string newDest = file.copyTree(dest, null);
                            misc.log("-------> " + newDest);
                            track.Location = newDest;
                            try
                            {
                                File.Delete(loc);
                            }

                            catch (Exception del)
                            {

                                misc.log(del.ToString());
                            }

                        }
                        catch (Exception ex)
                        {
                            misc.log(ex.ToString());
                        }
                    }
                }

            }
#endif

        }


        private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }

        private static DateTime playedLevel = DateTime.MinValue;
        public static DateTime PlayedLevel { set { playedLevel = value; } }
        //public static bool markAsPlayed(int rating, DateTime date)
        //{
        //    if (maxPlayed.ContainsKey(rating))
        //        return date > maxPlayed[rating];
        //    return true;
        //}


        public static void CheckPlay(TrackInfoItunes track)
        {
            track.played = isPlayed(track);
        }


        private static bool isPlayed(TrackInfoItunes track)
        {
            if (track.playCount <= 0)
            {
                if (playedLevel == DateTime.MinValue || track.PlayedDate >= playedLevel)
                    return false;
                // pour les vieux on prend quand même en compte la date de dernière lecture
                return true;
            }

            int rating = track.Rating;
            if (maxPlayed.ContainsKey(rating))
                return track.PlayedDate > maxPlayed[rating];
            return true;

        }


        public string ShortName { get { return getShortName(location); } }
        public static string getShortName(string location) { return misc.getShortPath(location, Exporter.PODCASTS, Exporter.ZIQUE, "Y:"); }

        private string hibernateLocation;
        public string HibernateLocation { get { return hibernateLocation; } set { hibernateLocation = value; } }


        public bool isPresent()
        {
            if (!string.IsNullOrEmpty(hibernateLocation))
                return FileRegister.Exist(hibernateLocation);
            return FileRegister.Exist(location);

            //var path = location;
            //if (_extern)
            //{
            //    var shortName = ShortName;
            //    path = TrackInfoItunes.DefaultFolder + shortName;
            //}
            //if (FileRegister.Exist(location))
            //{
            //    location = path;
            //    return true;
            //}
            //return false;
        }

        public void build(XmlReader reader)
        {

            location = reader.GetAttribute("f");
            if (Path.IsPathRooted(location))
            {
            }
            else
                location = TrackInfoItunes.DefaultFolder + location;


            hibernateLocation = reader.GetAttribute("hl");

            album = reader.GetAttribute("alb");
            name = reader.GetAttribute("name");

            var str = reader.GetAttribute("pub");
            if (!string.IsNullOrEmpty(str))
                pub = Convert.ToDateTime(str);

            str = reader.GetAttribute("date");
            if (!string.IsNullOrEmpty(str))
            {
                // playCount = 1;
                PlayedDate = Convert.ToDateTime(str);
            }

            str = reader.GetAttribute("nbr");
            if (!string.IsNullOrEmpty(str))
            {
                playCount = Convert.ToInt16(str);
            }

            str = reader.GetAttribute("albumRating");
            if (!string.IsNullOrEmpty(str))
                albumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                rating = Convert.ToInt32(str);

            if (albumRating > 0 && rating == 0)
                rating = albumRating;

            str = reader.GetAttribute("id");
            _dbId = Convert.ToInt32(str);

            if ("y" == reader.GetAttribute("rare"))
                rare = true;
            if ("y" == reader.GetAttribute("info"))
                info = true;
            if ("y" == reader.GetAttribute("disabled"))
                enabled = false;
            else
                enabled = true;
            str = reader.GetAttribute("s");
            if (!string.IsNullOrEmpty(str))
                _size = Convert.ToInt64(str);
            else
                _size = -1;

            str = reader.GetAttribute("d");
            if (!string.IsNullOrEmpty(str))
                Duree = timeSpan.FromSecondes(Convert.ToInt32(str));

            str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                _in = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                _out = Convert.ToDateTime(str);

            str = reader.GetAttribute("add");
            if (!string.IsNullOrEmpty(str))
                added = Convert.ToDateTime(str);
            str = reader.GetAttribute("add1");
            if (!string.IsNullOrEmpty(str))
                AddedFirst = Convert.ToDateTime(str);

            if (addedFirst == DateTime.MinValue)
                addedFirst = added; 




            CheckPlay(this);

        }



        public override void build(XmlNode xTrack)
        {
            TrackInfoItunes copy = null;
            if (loader.Import)
            {
                copy = createCopy(this);
            }
            albumRating = 0;
            base.build(xTrack);

            //  bool ratingComputed = false;
            bool albumRatingComputed = false;
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            if (!isPodcast)
                return;
            if (Strange)
                return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    //if (key == "Rating Computed")
                    //    ratingComputed = true;
                    if (key == "Album Rating Computed")
                        albumRatingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); AddedFirst = added;  break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Release Date": pub = Convert.ToDateTime(value); break; //DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Album Rating": albumRating = Convert.ToInt32(value); break;
                }

            }
            // gestion des rating
            if (albumRatingComputed)
                albumRating = 0;

            duree = new util.timeSpan(Duration);



            if (copy != null)
            {
                album = copy.album;
                name = copy.name;
                PlayedDate = copy.PlayedDate;
                playCount = copy.playCount;
                albumRating = copy.albumRating;
                rating = copy.rating;
                Duration = copy.Duration;
                duree = copy.duree;


            }
            PubLoader.setPub(false);

            CheckPlay(this);
        }



        //private PubLoader pubLoader;
        //internal PubLoader PubLoader { get { if (pubLoader == null) pubLoader = new PubLoader(this); return pubLoader; } }
        internal PubLoader PubLoader { get { return new PubLoader(this); } }

        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        public DateTime Pub { get { return pub; } }

       
        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        public DateTime Added { get { return added; } }

        /// <summary>
        /// Date de premier ajout; 
        /// </summary>
        private DateTime addedFirst;
        public DateTime AddedFirst
        {
            get { return addedFirst; }

            set
            {
                if (addedFirst == DateTime.MinValue)
                    addedFirst = value;
            }
        }

        private DateTime _in;
        public DateTime In { get { return _in; } }

        private DateTime _out;
        public DateTime Out { get { return _out; } }

        public void checkInOut()
        {
            DateTime now = DateTime.Now;
            if (Selected)
            {
                if (_in == DateTime.MinValue || _out > _in)
                    _in = now;
            }
            else
            {
                if (_in > DateTime.MinValue)
                {
                    if (_out == DateTime.MinValue || _in > _out)
                        _out = now;
                }
            }
        }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        private bool info;

        public bool Info
        {
            get { return info; }
            set { if (value) info = true; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        private bool rare;
        public bool Rare
        {
            get { return rare; }
            set { if (value) rare = true; }
        }

        private bool played;
        public bool Played { get { return played; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        private bool inJournal = false;

        public bool FreeInJournal { get { return Selected && !inJournal; } }
        public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        private void clearLists()
        {
            selected = selectMode.none;
            exclu = null;
            inJournal = false;
            listSelected = new SequentialDictString<LimitItem>();
            listLoad0 = new SequentialDictString<LimitItem>();
            listStandAlone = new SequentialDictString<LimitItem>();
            indexRoot = -1;
            offset = default(DateTime);
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }

        // private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void updateNative()
        {
            PubLoader.setPub(true);

            int volume = Volume;
            if (Album.Contains("RFI"))
            {
                if (volume != -20)
                    Volume = -20;
            }
            else
            {
                if (volume < volumeMin)
                    Volume = volumeMin;
            }


            if (pub > MIN)
            {


                string infoShort = pub.ToString("dd.MM.yy");
                string infoPubName = pub.ToString("dd.MM.yyyy");
                string infoPubName2 = pub.ToString("dd/MM/yyyy");
                string infoPubName3 = pub.ToString("dd/MM/yy");
                string infoYear = Year.ToString();
                if (pub.DayOfYear == 1)
                {
                    infoPubName = pub.Year.ToString();
                    infoPubName2 = infoPubName;
                    infoPubName3 = infoPubName;
                    infoShort = infoPubName;
                }

                string name = Name;
                string str = name;


                while (str.Contains(infoShort))
                    str = str.Replace(infoShort, "");
                while (str.Contains(infoPubName))
                    str = str.Replace(infoPubName, "");
                while (str.Contains(infoPubName2))
                    str = str.Replace(infoPubName2, "");
                while (str.Contains(infoPubName3))
                    str = str.Replace(infoPubName3, "");


                //if (regInfoShort.IsMatch(str))
                //{
                //    var strdate = regInfoShort.Match(str).Groups[1].Value;
                //    str = str.Replace(strdate, "");
                //}


                var strDayOfWeek = "";
                switch (pub.DayOfWeek)
                {
                    case DayOfWeek.Friday:
                        strDayOfWeek = "v";
                        break;
                    case DayOfWeek.Monday:
                        strDayOfWeek = "l";
                        break;
                    case DayOfWeek.Saturday:
                        strDayOfWeek = "s";
                        break;
                    case DayOfWeek.Sunday:
                        strDayOfWeek = "d";
                        break;
                    case DayOfWeek.Thursday:
                        strDayOfWeek = "j";
                        break;
                    case DayOfWeek.Tuesday:
                        strDayOfWeek = "ma";
                        break;
                    case DayOfWeek.Wednesday:
                        strDayOfWeek = "me";
                        break;
                    default:
                        break;
                }
                //Michel Rocard (1/5) l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 17.06.13 l

                var s1 = strDayOfWeek + " ";
                strDayOfWeek = " " + strDayOfWeek;

                while (str.EndsWith(strDayOfWeek))
                    str = str.Remove(str.Length - strDayOfWeek.Length);
                while (str.EndsWith(s1))
                    str = str.Remove(str.Length - s1.Length);

                //if (str.Contains(infoPubName))
                //    str = str.Replace(infoPubName, infoShort);
                //else if (name.Contains(infoPubName2))
                //    str = str.Replace(infoPubName2, infoShort);

                //else
                //{
                //    if (!str.Contains(infoShort))
                //    {
                //        str = str + " " + infoShort;
                //    }
                //    else
                //    {
                //        if (Year > 1980 && str.Contains(infoYear))
                //            str = str.Replace(infoYear, "").Trim();
                //    }
                //}
                var strBUG = "30.12.99";
                if (str.Contains(strBUG))
                    str = str.Replace(strBUG, "");

                str = str.Replace("  ", " ");
                str = str.Replace("  ", " ");
                str = str.Replace("  ", " ").Trim();

                str += " ";
                str += infoShort;


                str += strDayOfWeek;

                if (!str.Equals(name))
                    Name = str;
            }
        }
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (value == selectMode.standAlone)
            {
                if (!listStandAlone.ContainsKey(key))
                    listStandAlone.Add(key, limit);
            }
            else
            {
                if (!listSelected.ContainsKey(key))
                    listSelected.Add(key, limit);
            }


            if (selected == value)
                return;

            if (value > selectMode.standAlone)
            {

                selected = value;
                if (isPresent() && !present)
                {
                    // loader.resurrection(this);
                }


            }

        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            string strYear = Year > 0 ? Year.ToString() : "";
            return level.ToString() + " " + Album + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {
            if (string.IsNullOrEmpty(location))
                return;

            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (string.IsNullOrEmpty(location))
                return;
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" � d�placer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = file.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                        File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
            }
        }

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            set
            {
                if (string.IsNullOrEmpty(this.Grouping))
                    setGrouping(this.Comment, true);
                Comment = value;
            }
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return location; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        DateTime IPub.Offset { get { return offset; } }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree
        {
            get
            {

                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
                return duree;
            }
            private set
            {
                duree = value;
                if (base.Duration.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
            }
        }

        public override TimeSpan Duration
        {
            get
            {
                var dur = base.Duration;
                if (dur.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
                return base.Duration;
            }

            set
            {
                base.Duration = value;
                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
            }
        }

        private long _size = -1;
        public long Size
        {
            get
            {
                if (_size < 0)
                {
                    var f = FileRegister.Check(Location);
                    if (f.Exists)
                        _size = f.Length;
                    else
                        _size = 0;
                }
                return _size;
            }
        }

        private int indexRoot = -1;
        public int IndexRoot { get { return indexRoot; } set { indexRoot = value; } }




        public static DateTime Date0;
        private timeSpan ts;
        public timeSpan Ts
        {
            get
            {
                if (ts == default(timeSpan))
                {
                    if (Date0 == DateTime.MinValue)
                        throw new ApplicationException("Date0 pas initialisée");
                    ts = new timeSpan(Pub - Date0);
                }
                return ts;
            }
        }

        public void hibernate(FileValue fv, string dirH)
        {
            bgClass.add(new BgTaskHibernate(this, fv, dirH));
        }

        protected class BgTaskHibernate : BgTaskDeleteTrackTrack
        {
            private TrackInfoItunes track;
            private FileValue fv;
            string dirH;
            public BgTaskHibernate(TrackInfoItunes track, FileValue fv, string dirH)
                : base(track, string.Format("Hibernate {0}", track))
            {
                this.track = track;
                this.fv = fv;
                this.dirH = dirH;
            }

            public override void exec()
            {
                base.exec();
                if (!success)
                    return;

                if (!string.IsNullOrEmpty(dirH))
                {
                    var dest = misc.copyTree(fv, dirH + track.ShortName, false);
                    track.HibernateLocation = dest;

                    try
                    {
                        File.Delete(track.Location);
                        fv.delete();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }
                }
            }
        }


        private class BgTaskImport : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskImport(TrackInfoItunes info)
                : base(string.Format("import {0}", info.Location))
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    info.import(_track);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

    }
}



]]></content>
  </file>
  <file path="\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using pdb.podcast.Tuning;


namespace pdb.podcast.DB
{
    public class Db
    {
        public const int CURRENT_VERSION = 1;
        const string SEQ_PIECE = "seq";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        private BgDict<int, TrackInfoItunes> dictId = new BgDict<int, TrackInfoItunes>(); 
        private volatile object _lock = new object();






        const string FILE = "..\\db.xml";
        const string SOV = "..\\sov\\";
        //   private XmlSerializer xmlSerializer;

       // private bool import;
        private bool loaded;

        public Db()
        {
           // this.import = import;
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};


        }

        public List<TrackInfoItunes> Tracks
        {
            get
            {
                if (!loaded)
                {
                    lock (_lock)
                    {

                    }
                }

                return new List<TrackInfoItunes>(dict.Values);
            }
        }

        public TrackInfoItunes get(string location)
        {
            if (!loaded)
            {
                lock (_lock)
                {

                }
            }
            return dict[location];
        }

        public TrackInfoItunes get(TrackInfoItunes w)
        {
            return dictId[w.DbId]; 
        }

        public void Check(TrackInfoItunes track)
        {


            var location = track.ShortName;
            if (string.IsNullOrEmpty(location))
                return;
            var dbTrack = dict[location];
            if (dbTrack == null)
            {
                int id = ++pieceSequenceId;
                track.DbId = id;
            }
            else
            {
                track.DbId = dbTrack.DbId;
                //if (import)
                //{
                //    track.import(dbTrack);
                //}
            }
            track.Present = true;
            dict[location] = track;
            dictId[track.DbId] = track; 
        }

        public void Import(IEnumerable<TrackInfoItunes> listIt)
        {
            foreach (TrackInfoItunes it in listIt)
            {
                var location = it.ShortName;
                var tdb = dict[location];
                if (tdb == null)
                    continue;

                it.import(tdb);
            }
        }

        public void createIfExist(pdb.it.ITrackBuilder loader, List<TrackInfoItunes> listIt)
        {
            foreach (TrackInfoItunes tdb in dict.Values)
            {
                if (tdb.isPresent())
                {
                    loader.createTrack(tdb);
                    tdb.import();
                }
            }
        }



        public void load()
        {
            lock (_lock)
            {
                try
                {
                    using (XmlReader reader = XmlReader.Create(FILE))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {
                                    var seq = reader.GetAttribute(SEQ_PIECE);
                                    pieceSequenceId = Convert.ToInt32(seq);
                                }
                                else
                                {
                                    var t = read(reader);
                                    dict[t.ShortName] = t;
                                    dictId[t.DbId] = t; 
                                }
                            }
                        }

                    }
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
                finally
                {
                    loaded = true;
                }
            }
        }



        public TrackInfoItunes read(XmlReader reader)
        {
            var t = new TrackInfoItunes();
            t.build(reader);
            return t;

        }

        private static void write(XmlWriter writer, TrackInfoItunes track)
        {
            writer.WriteStartElement("t");
            writer.WriteAttributeString("id", track.DbId.ToString());
            var location = track.Location;
            if (!string.IsNullOrEmpty(location))
            {
                if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                {
                    location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                }


            }
            writer.WriteAttributeString("f", location);
            writer.WriteAttributeString("alb", track.Album);
            writer.WriteAttributeString("name", track.Name);
            if (track.Pub > DateTime.MinValue)
                writer.WriteAttributeString("pub", track.Pub.ToString());
            if (track.PlayedDate > DateTime.MinValue)
                writer.WriteAttributeString("date", track.PlayedDate.ToString());
            if (track.PlayCount > 0)
                writer.WriteAttributeString("nbr", track.PlayCount.ToString());
            if (track.AlbumRating > 0)
                writer.WriteAttributeString("albumRating", track.AlbumRating.ToString());
            if (track.Rating != track.AlbumRating)
                writer.WriteAttributeString("rating", track.Rating.ToString());


            //if (track.RatingComputed)
            //    writer.WriteAttributeString("computed", "y");
            if (track.Rare)
                writer.WriteAttributeString("rare", "y");
            if (track.Info)
                writer.WriteAttributeString("info", "y");
            var duree = track.Duree;
            if (duree.Value > 0)
            {
                writer.WriteAttributeString("d", duree.Value.ToString("0"));
                var size = track.Size;
                if (size > 0)
                    writer.WriteAttributeString("s", size.ToString());
            }
            if (!track.Enabled)
                writer.WriteAttributeString("disabled", "y");

            if (track.Added > DateTime.MinValue)
                writer.WriteAttributeString("add", track.Added.ToString());
            if (track.AddedFirst > DateTime.MinValue && track.AddedFirst < track.Added)
                writer.WriteAttributeString("add1", track.AddedFirst.ToString());

            if (track.In > DateTime.MinValue)
            {
                if (track.Out == DateTime.MinValue || track.In < track.Out)
                {
                    writer.WriteAttributeString("in", track.In.ToString());
                    if (track.Out > DateTime.MinValue)
                        writer.WriteAttributeString("out", track.Out.ToString());
                }
                else
                {
                    writer.WriteAttributeString("out", track.Out.ToString());
                    writer.WriteAttributeString("in", track.In.ToString());
                }
            }

          

            if (!string.IsNullOrEmpty(track.HibernateLocation))
                writer.WriteAttributeString("hl", track.HibernateLocation);

          
            writer.WriteEndElement();

        }

        public void recordIt(IEnumerable<TrackInfoItunes> listIt)
        {
            if (listIt != null)
            {
                foreach (TrackInfoItunes t in listIt)
                    Check(t);
            }
        }

        public void write()
        {
            misc.log("db::write"); 
            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            lock (_lock)
            {
                try
                {
                    if (!Directory.Exists(SOV))
                        Directory.CreateDirectory(SOV);
                    
                    File.Copy(FILE, string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE)), true);
                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }


                var listMissing = new List<TrackInfoItunes>();
               
                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(FILE + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    foreach (TrackInfoItunes track in Tracks)
                    {
                        if (!Conf.Db.purgemissing || track.isPresent())
                            write(writer, track);
                        else
                            listMissing.Add(track);

                    }
                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE + ".tmp", FILE, true);

                if (listMissing.Count > 0)
                {
                    using (XmlWriter writerMissing = XmlWriter.Create(string.Format("{0}{1}__missing.xml", SOV, timeStamp), settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            write(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }

                }

                misc.log("db::fin write"); 
                //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
            }
        }


        // géopolitique 4 par défaut rating ->80 albumrating ->80 computed =true
        //RFI 0 de temps en temps surcharge pour un par défaut : rating null albumrating->20 computed = true
        //                                  pour un syrchargé  : rating non null ""   
        // adele 1                          pour les défaut   rating:20 album 20 computed
        //                                  pour un surchargé 4 rating 80 album 20 non computed

        //C'est quand même gavant. il fait pas la différence entre les étoiles pleines et creuses
        //prenons adele defaut : 20 /20 computed
        //          autre        80 /20 non computed


        // ayo album zero surcharge 1 deux étoiles creuses => 20/40/computed

        //Ah ok . cas computed 1. album=rating => c'est bien level album
        //                        album != rating => c'est bidon  "étoile creuse"                                
        //        sinon on lit directement level album

        // Quel con j'ai pas vu qu'il y avait RatingComputed et Album Rating computed
        // je me le refele
        //géopolitique ratinet alubm => 80 ratingComputed
        // RFi  defaut rating null album 20 albumcomputed
        //      surchargé   rating 20 idem     
        // adele defaut rating 20 rating computed albumrating 20




    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning.Sort;
using pdb.util;

namespace pdb.podcast.Sort
{
    class Album
    {
        const char SEP = '|'; 
        private string name;
        private SortItem conf;
        private List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        //   private int indexLastRead = -1;
        timeSpan limit;

        public Album(SortItem conf, string name)
        {
            this.conf = conf;
            this.name = name;
            limit = timeSpan.FromMinutes(conf.dureeMin);
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(track);
        }

        public void build(Loader loader)
        {
            if (conf.enabled == sortMode.no)
                return;
            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            for (int i = 0; i < list.Count; i++)
            {
                var track = list[i];
                if (track.Played && track.PlayedDate > lastPlayed)
                {
                    indexLastRead = i;
                    lastPlayed = track.PlayedDate;
                }

                if (track.Selected)
                {
                    indexNextSelected = i;
                    break;
                }
            }


            if (indexLastRead < 0)
                return;
            if (indexNextSelected < 0)
                return;
            TrackInfoItunes lastRead = list[indexLastRead];
            DateTime pub2 = lastRead.Pub;
            loader.reviveIfNecessary(lastRead); 
            var comment = lastRead.Comment; 
            if (comment.Contains(SEP))
            {
                try
                {
                    pub2 = Convert.ToDateTime(comment.Split(SEP)[0]); 
                }
                catch
                {
                }
            }

            TrackInfoItunes nextSelected = list[indexNextSelected];

            int nbRead = 0;
            int nbTotal = 0;
            double delta = conf.intervalle;
            if (conf.histo > 0)
            {
                DateTime limit = nextSelected.Pub.AddDays(-conf.histo);
                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit)
                        break;
                    nbTotal++;
                    if (t.Played)
                        nbRead++;

                }


                if (nbRead > 0)
                {
                    delta = (conf.intervalle * (double)nbTotal) / (conf.ecouteMax * (double)nbRead);
                    if (delta > conf.intervalle)
                        delta = conf.intervalle;
                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);
                misc.log("{0} {1}/{2} [{3}] {4} {5} ({6}) ",delta.ToString("#.##") ,nbRead, nbTotal, name, lastRead.Name, lastRead.Pub, pub2);


            }

           

            if (conf.extPente > 0)
            {
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = (DateTime.Now - pub2).TotalDays;                   
                }

                delta = dl / conf.extPente;

                var deltaDate0 = (TrackInfoItunes.Date0 - pub2).TotalDays;
                misc.log("{0} {1}", delta.ToString("#.##"), deltaDate0.ToString("#.##"));
 
                if (deltaDate0 > delta)
                    delta = deltaDate0;

                if (delta < 1)
                    delta = 1;
                if (delta > conf.intervalle)
                    delta = conf.intervalle; 
            }

            DateTime limitFuture = pub2.AddDays(delta);
            DateTime nextDate = limitFuture; 
            int nb = 0;

            for (int i = indexLastRead + 1; i < list.Count; i++)
            {
                var t = list[i];

                if (!t.Selected)
                    continue;

                if (t.Pub > limitFuture)
                {
                    nextDate = t.Pub; 
                    break;
                }
                nb++;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
            }
            double deltaMinutes = 1;
            if (nextDate > limitFuture && nb > 0)
                deltaMinutes = (nextDate - limitFuture).TotalMinutes / (double)nb;

            if (deltaMinutes < 1)
                deltaMinutes = 1; 

            nb = 0; 
            for (int i = indexLastRead + 1; i < list.Count; i++)
            {
                var t = list[i];

                if (!t.Selected)
                    continue;
                if (t.Pub > limitFuture)
                    eraseSort(t);
                else
                {
                    writeComment(t, limitFuture, deltaMinutes * nb);
                    nb++; 
                }
                

            }


        }

        private void eraseSort(TrackInfoItunes track)
        {
            string comment = track.Pub.ToString("yyyy/MM/dd HH:mm");
            if (comment != track.Comment)
                track.Comment = comment;
        }

        private void writeComment(TrackInfoItunes track, DateTime limitFuture, double deltaMinutes)
        {
         
            var dt = limitFuture.AddMinutes(deltaMinutes);
            misc.log("\t{0} {1} -> {2}+{3}={4}", track.Name, track.Pub, limitFuture, deltaMinutes.ToString("0.#"), dt); 
            string comment = string.Format("{0}|{1}", dt.ToString("yyyy/MM/dd HH:mm"), track.Pub.ToString("yyyy/MM/dd HH:mm"));
            if (comment != track.Comment)
                track.Comment = comment;

        }
    }
}
]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        protected static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        private TrackPlayListManager listManager = new TrackPlayListManager();
        private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        protected static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);

        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }

        

        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            this.album = track.Album;
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;




        }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present; public bool Present { get { return present; } set { present = value; } }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location": Uri uri = new Uri(value);
                        return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.PlayedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded; 
           

            Fill();
        }

        

        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0; 
            string key = "";
            bool nextIgnore = false;
           

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value;                        
                        break;
                    case "Artist": artist = value; break;
                    case "Album": album = value; break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": PlayedDate = Convert.ToDateTime(value);  break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;// Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return TrackTrack;
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;

                bgClass.add(new Bgtask(() =>
                {
                    Track.Artist = value;
                    artist = value;
                }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                ));


            }
        }


        protected string album = "";
        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value == null || value.Equals(album)) return;
                bgClass.add(new Bgtask(() =>
                {
                    // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                    Track.Album = value;
                    album = value;
                }, this,
                "change album from '{0}' to'{1}' {2}", album, value, this
                ));

            }
        }
        protected string name = "";
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;

                var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                bgClass.add(bgtaskName);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }
        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        private bool firstClass;
        public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                firstClass = false;
                if (comment != value)
                {
                    try
                    {
                        var tab0 = comment.Split(' ');
                        var tab1 = value.Split(' ');

                        var count0 = tab0.GetLength(0);
                        var count1 = tab1.GetLength(0);

                        if (count0 != count1)
                            firstClass = true;

                        else if (comment.Length > 3)
                        {
                            string org = tab0[count0 - 1];
                            string fin = tab1[count1 - 1];

                            firstClass = !org.Equals(fin);
                        }
                    }

                    catch
                    {
                        firstClass = true;
                    }

                    var sb = new StringBuilder();
                    sb.Append(ClassName);
                    sb.Append(".");
                    sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format("{0} change comment from '{1}' to '{2}' {3}", sb.ToString(), comment, value, this), value);

                    if (firstClass)
                        bgFirstClass.add(task);
                    else
                        bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled;
        public bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        private bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        private DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {          
                return playedDate;
            }

            set
            {
                if (playedDate > DateTime.MinValue)
                {
                    var dt = (value - playedDate).TotalHours;
                    if (dt > 2 || dt < -2)
                        playedDate = value;
                    else
                        return; 
                    
                }
                playedDate = value; 
            }
        }
        protected string location;
        public string Location
        {
            get { return location; }
            set { location = value; }
        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }


        }

        public void setGrouping(string value, bool prior)
        {
            if (!present)
            {
                grouping = value;
                return;
            }
            if (grouping != value)
            {
                bool _delta = false;
                // bool _deltaRank = false; 
                string rankAlbum = "";
                string equivAlbum = "";
                if (value != null)
                {
                    string[] org = grouping.Split(' ');
                    string[] _new = value.Split(' ');

                    int count = org.GetLength(0);
                    if (_new.GetLength(0) != count || count < 3)
                        _delta = true;
                    else
                    {
                        rankAlbum = _new[1];
                        equivAlbum = _new[2];
                        if (!org[1].Equals(_new[1]))
                        {
                            _delta = true;
                        }
                    }
                }

                var sb = new StringBuilder();
                sb.Append(rankAlbum);
                sb.Append(" ");
                sb.Append(equivAlbum);
                sb.Append(" ");
                sb.Append(album);
                //sb.Append(ClassName);
                //sb.Append(".");
                //sb.Append((Rating / 20).ToString());

                var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

                if (firstClass)
                {
                    bgSeconClass.add(task);
                    return;
                }

                //if (prior)
                //{
                //    bgGroupPrior.add(task);
                //    return;
                //}



                if (_delta)
                {
                    if (prior)
                        bgGroupPrior.add(task);
                    else
                        bgGroup2nd.add(task);
                    return;
                }

                bgg.add(task);

                //if (_delta)
                //    bgGroupDelta.add(task);
                //else
                //{
                //    bgg.add(task);
                //}
                //  grouping = value;
            }
        }



        private int volume;
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        public List<CPlayList> PLayLists
        {
            get { return listManager.PLayLists; }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return listManager.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            listManager.AddPlayList(a_playList);
            // className = listManager.ClassName;
        }

        public void removePlayList(CPlayList list)
        {
            listManager.removePlayList(list);
            // className = listManager.ClassName;
        }


        public string ClassName
        {
            get
            {
                className = listManager.ClassName;
                return className;
            }
            set
            {
                className = listManager.ClassName;
                if (className != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        loader.setClassPlayList(this, className, value);
                        className = value;
                    }, this,
                   "change className from '{0}' to'{1}' {2}", className, value, this));


                    //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
                    //className = value;
                    //OnClassNameChange(value);
                }
            }
        }
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }

        public void Delete()
        {
            if (tracktrack != null)
            {
                log.log("!delete! {0}", this); 
                tracktrack.Delete();
            }
            else
                bgClass.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        protected class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getLocation()
        {
            return location; 
        }

        private DateTime added; 
        public virtual DateTime Added
        {
            get { return added; }
            set { added = value;  }
        }
       
    }
}



]]></content>
  </file>
</db>
