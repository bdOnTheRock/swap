<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;

namespace pdb.podcast.Sort
{
    class Album
    {
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        private static int nbrepeches = 0;
        private static int nbModif = 0;
        public static int NbRepeches { get { return nbrepeches; } }
        public static int NbModif { get { return nbModif; } }
        public static void init()
        {
            //lastReads.Clear(); 
            nbrepeches = 0;
            nbModif = 0;
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }

        public void Build(Loader loader)
        {

            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;
            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            TrackSort lastRead = null;



            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Selected)
                {
                    next = track;
                    indexNextSelected = i;
                    break;
                }
            }

            if (next == null)
                return;

            int nbRead = 0;
            int nbTotal = 0;

            var histo = conf.getHisto(album.Rare);

            DateTime limit = next.Pub.AddDays(-histo);
            for (int i = indexNextSelected - 1; i >= 0; i--)
            {
                var t = list[i];
                var dt = t.Pub;
                if (dt < limit)
                    break;

                if (t.Played)
                    nbRead++;

                if (t.Played || t.track.Enabled)
                    nbTotal++;

            }
            double delta = conf.getIntervalle(album.Rare);
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            if (nbRead > 0 && nbTotal > 0)
            {
                //  album.Rare ? conf.intervalleR : conf.intervalle;
                var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                delta = (intervalle * (double)nbTotal) / (ecouteMax * (double)nbRead);
                var coeff = (double)nbTotal / (double)nbRead;

                //0.1 => 10
                //0.9 => 1.11
                coeff -= 1; // 9  0.11
                var dminmax = intervalle - intervalleMin;

                var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                if (_delta < delta)
                    delta = _delta;
                else
                {
                }
            }


            var deltaLecture = (DateTime.Now - reallyLastRead.PlayedDate).TotalDays;



            for (int j = 0; j < indexNextSelected; j++)
            {
                for (int i = j; i < indexNextSelected; i++)
                {
                    var track = list[i];
                    if (track.Played)
                    {
                        reallyLastRead = track;
                        lastRead = track;
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        j = i;
                        break;
                    }
                }
                var pub2 = lastRead.Pub2;

                if (conf.extPente > 0)
                {
                    var d0 = (DateTime.Now - pub2).TotalDays;
                    var dl = conf.extDelta;
                    if (dl == 0)
                    {
                        dl = d0;
                    }

                    delta = d0 / conf.extPente;
                    //01/01/2014 ->01/01/2017
                    //04/01/2017 -> 04/01/2014
                    var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                    var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                    log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                    if (deltaLimiteEcoule > delta)
                        delta = deltaLimiteEcoule;

                    if (delta < 1)
                        delta = 1;



                }

                if (conf.limitRead && deltaLecture > intervalle)
                {
                    //13 /10 ->7
                    var _old = delta;

                    delta += intervalle - deltaLecture;
                    log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
                }

                if (delta < intervalleMin)
                    delta = intervalleMin;

                if (delta > intervalle)
                    delta = intervalle;


                DateTime limitFuture = pub2.AddDays(delta);

                if (limitFuture.Second > 0)
                {
                    limitFuture = new DateTime(limitFuture.Ticks - limitFuture.Ticks % TimeSpan.TicksPerMinute + TimeSpan.TicksPerMinute);
                }


                DateTime nextDate = limitFuture;
                int nb = 0;
                int nblissage = 0;
                double deltaMinute = 1;

                if (conf.noCollision)
                    deltaMinute = TimeSpan.FromDays(delta).TotalMinutes;

                if (conf.deltaConst)
                {

                }

                else
                {
                    var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                    var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                    for (int i = indexLastRead + 1; i < list.Count; i++)
                    {
                        var t = list[i];
                        if (t.Pub >= limitFuture)
                        {
                            nextDate = t.Pub;
                            nblissage++;
                            if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                                break;
                        }
                        nb++;
                    }

                    if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        deltaMinute = (nextDate - limitFuture).TotalMinutes / (double)nb;
                }

                if (deltaMinute < 1)
                    deltaMinute = 1;



                nb = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {

                    var t = list[i];

                    if (!t.Selected && conf.enabled != sortMode.reset)
                        continue;
                    if (!t.track.Enabled)
                        continue;
                    var dt = limitFuture.AddMinutes(deltaMinute * nb);
                    var _delta = (dt - lastRead.Pub2).TotalDays;

                    if (t.Pub >= dt || conf.enabled == sortMode.reset)
                        t.increasePub(t.Pub);
                    else
                    {
                        t.increasePub(dt);
                        nb++;
                    }


                }
            }

            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (!track.Selected)
                    continue;
                var pub2 = track.Pub2;
                var newPub = track.getPub();

                if (newPub != pub2)
                {
                    writeComment(track, newPub);
                }
            }









            //  log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", delta.ToString("#.##"), nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));









            for (int i = 0; i < list.Count; i++)
            {
                var track = list[i].track;

                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }


        }

   

        public void build(Loader loader)
        {
            if (conf.enabled == sortMode.no)
                return;
            if (list.Count == 0)
                return;
          
            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < list.Count; i++)
            {
                var track = list[i];


                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    reallyLastRead = track;
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            DateTime pub2 = lastRead.Pub2;
           

            var deltaLecture = (DateTime.Now - reallyLastRead.PlayedDate).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0; 
            double delta = conf.getIntervalle(album.Rare);
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;


                DateTime limit = next.Pub.AddDays(-histo);
                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoRead)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    coeff -= 1; // 9  0.11
                    var dminmax = intervalle - intervalleMin;

                    var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta = d0 / conf.extPente;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }

            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", delta.ToString("#.##"), nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute(); 

            //if (limitFuture.Second > 0)
            //{
            //    limitFuture = new DateTime(limitFuture.Ticks - limitFuture.Ticks % TimeSpan.TicksPerMinute);
            //    //   limitFuture = new DateTime(limitFuture.Ticks - limitFuture.Ticks % TimeSpan.TicksPerMinute + TimeSpan.TicksPerMinute);
            //}


            DateTime nextDate = limitFuture;
            int nb = 0;
            int nblissage = 0;
            double deltaMinute = 1;

            if (conf.noCollision)
                deltaMinute = TimeSpan.FromDays(delta).TotalMinutes;

            if (conf.deltaConst)
            {

            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                for (int i = indexLastRead + 1; i < list.Count; i++)
                {
                    var t = list[i];

                    //if (!t.SelectedByDb)
                    //    continue;
                    //if (!t.Enabled)
                    //    continue;

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                    deltaMinute = (nextDate - limitFuture).TotalMinutes / (double)nb;
            }

            if (deltaMinute < 1)
                deltaMinute = 1;


            nb = 0;
            for (int i = indexLastRead + 1; i < list.Count; i++)
            {

                var t = list[i];

                //if (!t.track.SelectedByDb && t.Pub2 < Conf.Date0 && conf.enabled != sortMode.reset)
                //    continue;
                //if (!t.track.Enabled)
                //    continue;
                var dt = limitFuture.AddMinutes((int)(deltaMinute * nb));
                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t);
                else
                {
                    writeComment(t, dt);
                    nb++;
                }


            }


        }

        //private void writeComment(TrackInfoItunes track)
        //{
        //    string comment = track.Pub.ToString("yyyy/MM/dd HH:mm");
        //    if (track.Pub2 > track.Pub)
        //        comment = string.Format("{0}|{1}", track.Pub2.ToString("yyyy/MM/dd HH:mm"), track.Pub.ToString("yyyy/MM/dd HH:mm"));

        //    if (comment != track.Comment)
        //        track.Comment = comment;
        //}

        private void eraseSort(TrackSort track)
        {
            if (!track.Selected)
                return; 
            if (conf.canGoBack || conf.enabled == sortMode.reset)
            {
                DateTime pub = track.Pub;
                if (track.Pub2 >= Conf.Date0 && pub < Conf.Date0)
                {
                    log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
                    nbrepeches++;
                    // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                }
                else if (track.Pub2 >= Conf.NewDate0 && pub < Conf.NewDate0)
                {
                    log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
                    nbrepeches++;
                    // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                }

                //}
                //else
                //{
                if (track.Pub2 != track.Pub)
                    nbModif++;
                track.Pub2 = track.Pub;
                //}
                track.track.BuildComment();
                // writeComment(track);
            }
        }

        private void writeComment(TrackSort track, DateTime dt)
        {
            if (!track.Selected)
                return; 

            if (conf.canGoBack)
            {
                if (track.Pub2 >= Conf.Date0 && dt < Conf.Date0)
                {
                    log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, dt, Conf.Date0);
                    nbrepeches++;
                    //  track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                }

                else if (track.Pub2 >= Conf.NewDate0 && dt < Conf.NewDate0)
                {
                    log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, dt, Conf.NewDate0);
                    nbrepeches++;
                    //  track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                }
            }
            else
            {
                if (dt == track.Pub2)
                {
                    log.log("\t{0}\t{1} {2}", track.Pub, dt, track.Name);
                    return;
                }
                else if (dt < track.Pub2)
                {
                    log.log("\t{0}\t{1}<=\t{2} {3}", track.Pub, track.Pub2, dt, track.Name);
                    return;
                }
            }

            if (track.Pub2 != dt)
            {
                nbModif++;
                log.log("\t{0}\t{1}=>\t{2} {3}", track.Pub, track.Pub2, dt, track.Name);
                track.Pub2 = dt;
            }

            track.track.BuildComment();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Sort.cs">
    <content><![CDATA[using System.Xml;
using pdb.util;
using System;
using System.Collections.Generic;

namespace pdb.podcast.Tuning.Sort
{
    public enum sortMode
    {
        no,
        reset,
        once,
        once_all,
        all
    }
    public class SortItem : TuningBase
    {
        public string name;
        public sortMode enabled;
        public bool checkBefore; 
        /// <summary>
        /// prise en compte des longs podcasts
        /// </summary>
        public double dureeMin;
        /// <summary>
        /// intervalle max entre deux écoutes (une semaine)
        /// </summary>
        private double intervalle=7;
        /// <summary>
        /// intervalle min entre deux écoutes (un jour)
        /// </summary>
        private double intervalleMin=1;
        /// <summary>
        /// intervalle max entre deux écoutes pour un rare
        /// </summary>
        private double intervalleR;
        /// <summary>
        /// intervalle min entre deux écoutes pour un rare
        /// </summary>
        private double intervalleMinR=7;
        /// <summary>
        /// nb d'écoutes maximum dans l'intervalle (typiquement 5)
        /// </summary>
        private double ecouteMax;
        /// <summary>
        /// nb d'écoutes maximum dans l'intervalle pour un rare
        /// </summary>
        private double ecouteMaxR;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute
        /// </summary>
        private double histo;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute pour un rare
        /// </summary>
        private double histoR;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : nombre minimum d'éléments à prendre en compte
        /// </summary>
        public int deltaNbMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'éléments à prendre en compte
        /// </summary>
        public int deltaNbRab;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : intervalle minimum à prendre en compte en jours
        /// </summary>
        public double deltaMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'intervalle à prendre en compte
        /// </summary>
        public double deltaRab;

        /// <summary>
        /// pas d'empilage des tracks repoussés
        /// </summary>
        public bool noCollision;
        /// <summary>
        /// recalcul peut entrainer une date plus récente
        /// </summary>
        public bool canGoBack;
        /// <summary>
        /// écart constant entre les poscasts repoussés
        /// </summary>
        public bool deltaConst; 

        /// <summary>
        /// Date0 lors de l'écoute du dernier podcast externe
        /// </summary>
        public DateTime extLast0;
        /// <summary>
        /// Décalage entre date du podcast supplémentaire et la date0
        /// </summary>
        public double extDelta;
        /// <summary>
        /// coefficient permettant le calcul de la prochaine date en fonction du retard entre la date0 et maintenant
        /// </summary>
        public double extPente;
        /// <summary>
        /// check de la date de dernière lecture
        /// </summary>
        public bool limitRead;

        /// <summary>
        /// On démarre l'historique sur le dernier lu, sinon sur le premier sélectionné
        /// </summary>
        public bool histoRead; 

        public SortItem()
        {
        }

        public SortItem(XmlElement parent, XmlElement node)
            : base(parent, node)
        {

            if (node == null)
                return;
            builds("name", v => name = v);
            var str = "";
            builds("enabled", v => str = v);

            if (!string.IsNullOrEmpty(str))
                enabled = (sortMode)Enum.Parse(typeof(sortMode), str);

            buildd("dureeMin", v => dureeMin = v);
            buildd("intervalle", v => intervalle = v);
            buildd("intervalleMin", v => intervalleMin = v);
            buildd("intervalleR", v => intervalleR = v);
            buildd("intervalleMinR", v => intervalleMinR = v);
            buildd("histo", v => histo = v);
            buildd("histoR", v => histoR = v);
            buildd("ecouteMax", v => ecouteMax = v);
            buildd("ecouteMaxR", v => ecouteMaxR = v);

            buildDate("extLast0", v => extLast0 = v);
            buildd("extDelta", v => extDelta = v);
            buildd("extPente", v => extPente = v);

          
           

            buildb("deltaConst", v => deltaConst = v);

            buildb("noCollision", v => noCollision = v);
            buildb("checkBefore", v => checkBefore = v);
            buildb("limitRead", v => limitRead = v);
            buildb("canGoBack", v => canGoBack = v);

            #region lissage 
            buildi("deltaNbMin", v => deltaNbMin = v);
            buildi("deltaNbRab", v => deltaNbRab = v);

            buildd("deltaMin", v => deltaMin = v);
            buildd("deltaRab", v => deltaRab = v); 

            #endregion

            buildb("histoRead", v => histoRead = v); 
        }

        public double getIntervalle(bool rare)
        {
            return rare && intervalleR >0 ? intervalleR : intervalle; 
        }
        public double getIntervalleMin(bool rare)
        {
            return rare && intervalleMinR > 0 ? intervalleMinR : intervalleMin;
        }
        public double getHisto(bool rare)
        {
            return rare && histoR > 0 ? histoR : histo;
        }
        public double getEcouteMax(bool rare)
        {
            return rare && ecouteMaxR >0? ecouteMaxR : ecouteMax;
        }


    }
    public class Sort : SortItem
    {
        private List<SortItem> items = new List<SortItem>();
        public SortItem getItem(string album)
        {
            return items.Find(a => a.name == album);
        }
        public Sort()
        {
        }

        public Sort(XmlElement node)
            : base(null, node)
        {
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement && sub.Name == "album")
                {
                    items.Add(new SortItem(node, sub as XmlElement));
                }
            }
        }


    }
}]]></content>
  </file>
</db>
