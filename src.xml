<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.IO;

namespace pdb.util
{
    public enum selectedCoeff
    {
        none,
        noCoeff,
        main,
        min
    }

    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        unselected = 1,
        virtuel = 2,
        tous = 3
    }

    public enum modeMin
    {
        /// <summary>
        /// On ne gère pas
        /// </summary>
        non = 0,
        /// <summary>
        /// Morceaux supérieurs à la limite ( pas d'influence sur le résultat)
        /// </summary>
        orphelin = 1,
        /// <summary>
        /// Morceaux cochés et notés
        /// </summary>
        toujours = 2

    }

    public class HistoStat
    {
        public HistoStatItem min;
        public HistoStatItem max;

        public HistoStat()
        {
            min = new HistoStatItem(int.MaxValue);
            max = new HistoStatItem(-1);
        }
        public HistoStat(decimal val)
        {
            min = new HistoStatItem(val);
            max = new HistoStatItem(val);
        }

        //private string desc(decimal d)
        //{
        //    if (d < 0)
        //        return "";
        //    if (d >= int.MaxValue)
        //        return "";
        //    return d.ToString("0.000", System.Globalization.CultureInfo.InvariantCulture);
        //}

        public override string ToString()
        {
            //return string.Format("{0}({1}) {2}({3})", desc(min.absolute), desc(min.relative), desc(max.absolute), desc(max.relative)); 
            return string.Format("{0} {1}", min, max);
        }
    }

    public class HistoStatItem
    {
        public decimal relative;
        public decimal absolute;
        public HistoStatItem()
        {
            relative = -1;
            absolute = -1;
        }
        public HistoStatItem(decimal val)
        {
            relative = val;
            absolute = val;
        }

        public static string desc(decimal d)
        {
            if (d < 0)
                return "";
            if (d >= int.MaxValue)
                return "";
            return d.ToString("0.000", System.Globalization.CultureInfo.InvariantCulture);
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append(desc(absolute));
            if (absolute != relative)
            {
                sb.Append("(");
                sb.Append(desc(relative));
                sb.Append(")");
            }
            return sb.ToString();
        }


    }

    [Serializable]
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;

        public bool enabled;



        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast;

        public decimal expEnabled = 0m;

        public decimal zero = 0m;
        /// <summary>
        /// 
        /// </summary>
        public bool removeEnabled;




        public modeMin cmpMin;

        private ConfMedianneVirt _main;
        private ConfMedianneVirt _min;

        public ConfMedianneVirt Main { get { return _main; } }
        public ConfMedianneVirt Min { get { return _min; } }
        public ConfMedianne()
        {
            _main = new ConfMedianneVirt();
            _min = new ConfMedianneVirt();

        }

        public void makeIdem()
        {
            _min = _main;
        }

        public void duplicateMainIf()
        {
            if (_min == _main)
                _min = new ConfMedianneVirt(_main);
        }
       
        public ConfMedianne(ConfMedianne o, bool raz)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;

            enabled = o.enabled;



            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;

            expEnabled = o.expEnabled;

            zero = o.zero;
            removeEnabled = o.removeEnabled;



            cmpMin = o.cmpMin;

            _main = new ConfMedianneVirt(o._main, raz);
            _min = new ConfMedianneVirt(o._min,raz);

        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            buildb("quasi", v => quasi = v);
            buildb("enabled", v => enabled = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);
            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v);
            string _modeMin = "";
            builds("cmpMin", v => _modeMin = v);
            if (!string.IsNullOrEmpty(_modeMin))
                cmpMin = (modeMin)Enum.Parse(typeof(modeMin), _modeMin, true);

            string _removeLast = null;
            builds("removeLast", v => _removeLast = v);
            removeLast = (removeLast)Enum.Parse(typeof(removeLast), _removeLast, true);

            _main = null;
            _min = null;
            var subs = XMLTool.NodeLookUp(child, "virts");
            if (subs != null)
            {
                foreach (XmlNode _n in subs.ChildNodes)
                {
                    if (_n is XmlElement)
                    {
                        if (_main == null)
                        {
                            _main = new ConfMedianneVirt(child, _n as XmlElement);

                        }
                        else if (_min == null)
                        {
                            _min = new ConfMedianneVirt(child, _n as XmlElement);
                        }
                    }
                }
                if (_min == null && _main != null)
                    _min = new ConfMedianneVirt(_main);
            }
        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("cmp");
            write("type", type);
            write("medianne", medianne);
            write("quasi", quasi);
            write("enabled", enabled);
            write("removeFirst", removeFirst);
            write("deleteFirst", deleteFirst);
            write("expEnabled", expEnabled);
            write("zero", zero);
            write("removeEnabled", removeEnabled);
            write("cmpMin", cmpMin);
            write("removeLast", removeLast);

            writeStart("virts");
            _main.save(w);
            _min.save(w);
            writeEnd();

            writeEnd();



        }


        public void auto(selectedCoeff motif)
        {
            if (!enabled)
                return;
            if (motif == selectedCoeff.none)
                return;
            var coeffPrisEncompte = motif > selectedCoeff.noCoeff;
            if (_min == _main || _min.coeffVirt == 1m)
            {
                _main.calcAuto(coeffPrisEncompte, 1);
            }
            else
            {
                if (coeffPrisEncompte)
                {
                    if (motif == selectedCoeff.main)
                        _main.calcAuto(true, 1);
                    if (motif == selectedCoeff.min)
                        _min.calcAuto(true, 1);
                }
                else
                {
                    _main.calcAuto(false, 1);
                    _min.calcAuto(false, 1);
                }
            }
        }
    }

    [Serializable]
    public class ConfMedianneVirt : TuningBase
    {
        [NonSerialized]
        const string PATH_DYN = "..\\dynamic";
        private string Path { get { return string.Format("{0}{1}", DIR_CONF, fdata); } }
        private string PathDiff { get { return string.Format("{0}{1}", DIR_CONF, fdiff); } }
        private string PathDiffTmp { get { return string.Format("{0}{1}", DIR_CONF, fdiffTmp); } }
        // private string PathLastFull { get { return string.Format("{0}{1}", DIR_CONF, flast); } }
        const string PATH_DYN_DIFF = "..\\dynamic_diff";

        // const decimal EPSILON = 0.000001m;// 0.001m;
        const int NB_HISTO = 1000000;
        public int safe;
        public decimal coeffVirt = 1m;

        //private bool firstSave = true;
        //private static bool modeDiff;
        //public static bool ModeDiff
        //{
        //    get { return modeDiff; }
        //    set
        //    {
        //        modeDiff = value;
        //    }
        //}

        public string name;


        /// <summary>
        /// lié au mode db
        /// </summary>
        public dbMode mode;
        /// <summary>
        /// fichier ou est consigné l'historique courant
        /// </summary>
        public string fdata;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique
        /// </summary>
        public string fdiff;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique en mode full en vue de la sauvegarfe
        /// </summary>
        public string fdiffTmp;
        ///// <summary>
        ///// fichier ou est consigné la dernière sauvegarde full de l'historique
        ///// </summary>
        //public string flast;

        public int indexDiff = 0;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        public bool coeffVirtAuto;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;
        public decimal dcoeffp;
        public decimal dcoeffm;

        public int serialp = 1;
        public int serialm = 1;
        public int serialAlt = 1;
        /// <summary>
        /// atténuation progressive des coeffs
        /// </summary>
        public decimal dconvergence;

        public decimal dconvdeltap = 1m;
        public decimal dconvdeltam = 1m;

        /// <summary>
        /// anti atténuation
        /// </summary>
        public decimal danticonvergence = 1m;
        public decimal danticonvdeltap = 1m;
        public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        private List<decimal> histo = new List<decimal>();
        //  private List<decimal> histoDiff = new List<decimal>();

        public decimal coeffOld = 1m;
        public bool oldAsZero;
        public bool coeffOldAuto;
        public int coeffOldAutoLevel;

        public bool linkconv { get { return _linkconv; } set { _linkconv = value; calcProduct(); } }

        private void calcProduct()
        {
            this.linkProduct = calcProduct(this.dcoeffp, this.dconvergence);
        }

        public decimal calcProduct(decimal dcoeffp, decimal dconvergence)
        {
            var linkProduct = this.linkProduct;
            try
            {
                linkProduct = dcoeffp / dconvergence;
                // 1 0,9 -> 10
                // 0.1 0,99 
            }
            catch
            {
            }

            return linkProduct;
        }

        private void calcConv()
        {
            this.dconvergence = calcConv(this.dcoeffp, this.linkProduct);
        }

        public decimal LinkProduct
        {
            get
            {
                if (linkProduct == 0m)
                    calcProduct();
                return linkProduct;
            }
            set
            {
                linkProduct = value;
                calcConv();

            }
        }

        public decimal calcConv(decimal dcoeffp, decimal linkProduct)
        {
            var dconvergence = this.dconvergence;
            try
            {
                // 1- conv = coeff / prod
                dconvergence = dcoeffp / linkProduct; //1/10
            }
            catch
            {

            }
            return dconvergence;
        }

        private bool? lastAutoDirection;
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        private int _nbSameDirection;
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        private int _nbSameDirectionBox;
        /// <summary>
        /// nb allez/retour pour calcul
        /// </summary>
        private int _nbAlt;
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        private int _nbAltHisto;

        private decimal epsilon = 0.001m;

        public ConfMedianneVirt()
        { }

        public ConfMedianneVirt(ConfMedianneVirt o, bool raz)
            : this(o)
        {
            if (raz)
            {
                safe = 0;
                coeffOld = 1;
                coeffVirt = 1;
            }
        }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            name = o.name;
            mode = o.mode;
            fdata = o.fdata;
            fdiff = o.fdiff;
            fdiffTmp = o.fdiffTmp;
            //  flast = o.flast;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            dcoeffp = o.dcoeffp;
            dcoeffm = o.dcoeffm;
            dconvergence = o.dconvergence;
            dconvdeltap = o.dconvdeltap;
            dconvdeltam = o.dconvdeltam;
            danticonvergence = o.danticonvergence;
            danticonvdeltap = o.danticonvdeltap;
            danticonvdeltam = o.danticonvdeltam;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            serialAlt = o.serialAlt;
            _nbSameDirection = o._nbSameDirection;
            _nbSameDirectionBox = o._nbSameDirectionBox;
            _nbAlt = o._nbAlt;
            _nbAltHisto = o._nbAltHisto;

            coeffOld = o.coeffOld;
            coeffOldAuto = o.coeffOldAuto;
            oldAsZero = o.oldAsZero;
            coeffOldAutoLevel = o.coeffOldAutoLevel;
            epsilon = o.epsilon;
            histo = new List<decimal>(o.histo);

        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var str = "";
            builds("mode", v => str = v);
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);
            builds("name", v => name = v);
            builds("fdata", v => fdata = v);
            builds("fdiff", v => fdiff = v);
            builds("fdiffTmp", v => fdiffTmp = v);
            // builds("flast", v => flast = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);
            builddec("dcoeffp", v => dcoeffp = v);
            builddec("dcoeffm", v => dcoeffm = v);
            builddec("dconvergence", v => dconvergence = v);
            builddec("dconvdeltap", v => dconvdeltap = v);
            builddec("dconvdeltam", v => dconvdeltam = v);

            builddec("danticonvergence", v => danticonvergence = v);
            builddec("danticonvdeltap", v => danticonvdeltap = v);
            builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serialAlt", v => serialAlt = v);
            buildi("serial", v => _nbSameDirection = v);
            buildi("serialBox", v => _nbSameDirectionBox = v);
            buildi("serialAltC", v => _nbAlt = v);
            buildi("serialAltH", v => _nbAltHisto = v);


            builddec("coeffOld", v => coeffOld = v);
            buildb("oldAsZero", v => oldAsZero = v);
            buildb("coeffOldAuto", v => coeffOldAuto = v);
            buildi("coeffOldAutoLevel", v => coeffOldAutoLevel = v);
            builddec("epsilon", v => epsilon = v);



            var xhisto = XMLTool.NodeLookUp(child, "histo");
            if (xhisto != null)
            {
                foreach (XmlElement sub in xhisto.ChildNodes)
                {
                    histo.Add(Convert.ToDecimal(sub.InnerText));
                }
            }
            else
            {
                if (File.Exists(Path))
                {
                    foreach (var line in File.ReadAllLines(Path))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;
                        histo.Add(Convert.ToDecimal(line));
                    }
                    indexDiff = histo.Count;

                    //if (histo.Count >0 )
                    //    coeffVirt = getCoeff(histo[histo.Count -1]);


                }

                if (File.Exists(PathDiff))
                {
                    var histoDiff = new List<decimal>();

                    foreach (var line in File.ReadAllLines(PathDiff))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;
                        histoDiff.Add(Convert.ToDecimal(line));
                    }

                    if (mode == dbMode.full)
                    {
                        histo.AddRange(histoDiff);
                        indexDiff = histo.Count;
                    }
                    else
                    {
                        indexDiff = histo.Count - histoDiff.Count;
                    }

                }



                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);

                if (histo.Count > 0)
                {
                    int index = histo.Count - 1;
                    decimal current = histo[index];
                    //coeffVirt = getCoeff(current);
                    bool? sens = null;
                    int nbSerie = 0;
                    decimal delta = 0m;

                    var rr = 0m;
                    if (dcoeffp > 0)
                        rr = dcoeffm / dcoeffp;
                    if (rr > 0)
                    {
                        while (true)
                        {
                            index--;
                            if (index < 0)
                                break;
                            var aux = histo[index];
                            var _sens = current > aux;
                            if (sens == null)
                            {
                                sens = _sens;
                                lastAutoDirection = !_sens;
                                delta = current - aux;
                            }


                            if (sens != _sens)
                                break;
                            current = aux;
                            nbSerie++;

                        }

                        //_nbSameDirection = nbSerie;
                        //dcoeffp = Math.Abs(delta); dcoeffm = dcoeffp * rr;

                    }
                }
            }

            if (coeffOldAuto)
            {
                coeffOld = (decimal)Math.Pow(coeffVirt, coeffOldAutoLevel);
            }
            //if (histoDiff.Count > 0)
            //    coeffVirt = getCoeff(histo[histo.Count - 1]); 

        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("name", name);
            write("mode", mode);
            write("serial", _nbSameDirection);
            write("serialBox", _nbSameDirectionBox);
            write("serialAltC", _nbAlt);
            write("serialAltH", _nbAltHisto);

            write("serialAlt", serialAlt);
            write("fdata", fdata);
            write("fdiff", fdiff);
            write("fdiffTmp", fdiffTmp);

            write("coeffVirt", coeffVirt);
            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);
            write("dcoeffp", dcoeffp);
            write("dcoeffm", dcoeffm);
            write("dconvergence", dconvergence);
            write("dconvdeltap", dconvdeltap);
            write("dconvdeltam", dconvdeltam);

            write("danticonvergence", danticonvergence);
            write("danticonvdeltap", danticonvdeltap);
            write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);



            write("coeffOld", coeffOld);
            write("oldAsZero", oldAsZero);
            write("coeffOldAuto", coeffOldAuto);

            write("coeffOldAutoLevel", coeffOldAutoLevel);
            write("epsilon", epsilon);


            var sb = new StringBuilder();
            var sbDiff = new StringBuilder();




            //if (modeDiff)
            //{
            //    histoDiff = null;
            //}
            //else
            //{
            //    if (histoDiff != null)
            //    {
            //        histo.AddRange(histoDiff);
            //        histoDiff = null;
            //    }

            //    if (File.Exists(PathDiff))
            //        File.Delete(PathDiff);
            //}

            int count = histo.Count;
            for (int i = 0; i < count; i++)
            {
                var line = histo[i].ToString("0.########");
                sb.AppendLine(line);
                if (i >= indexDiff)
                    sbDiff.AppendLine(line);
            }


            if (!string.IsNullOrEmpty(fdata))
            {
                AsyncFileWriter.Instance.post(Path, sb.ToString());
                if (mode == dbMode.diff)
                    AsyncFileWriter.Instance.post(PathDiff, sbDiff.ToString());
                else
                    AsyncFileWriter.Instance.post(PathDiffTmp, sbDiff.ToString());


                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);
            }


            writeEnd();
        }
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        public int Serial { get { return _nbSameDirection; } set { _nbSameDirection = value; } }
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        public int SerialBox { get { return _nbSameDirectionBox; } }
        /// <summary>
        /// nb allez-retours pour calcul
        /// </summary>
        public int Alt { get { return _nbAlt; } }
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        public int AltHisto { get { return _nbAltHisto; } }

        public void calcAuto(bool selectedByCoeff, int nb)
        {
            if (!auto)
                return;

            if (-_nbSameDirectionBox > serialm)
                _nbSameDirectionBox = -serialm;
            if (_nbSameDirectionBox > serialp)
                _nbSameDirectionBox = serialp;
            if (_nbAlt < 0)
                _nbAlt = 0;
            if (_nbAlt > serialAlt)
                _nbAlt = serialAlt;


            var last = lastAutoDirection;
            lastAutoDirection = selectedByCoeff;

            if (last.HasValue)
            {
                if (last != selectedByCoeff)
                {
                    _nbSameDirection = 0;
                    _nbAlt++;
                    _nbAltHisto++;
                    if (_nbSameDirectionBox > 0 && selectedByCoeff)
                        _nbSameDirectionBox--;
                    if (_nbSameDirectionBox < 0 && !selectedByCoeff)
                        _nbSameDirectionBox++;

                }
                else
                {
                    _nbAlt--;
                    _nbAltHisto = 0;
                    if (selectedByCoeff)
                    {
                        _nbSameDirectionBox--;
                    }
                    else
                    {
                        _nbSameDirectionBox++;
                    }
                }

                if (selectedByCoeff)
                {
                    _nbSameDirection--;
                }
                else
                {
                    _nbSameDirection++;
                }
            }



            var lastProduct = linkProduct;
            var rr = 0m;
            if (dcoeffp > 0)
                rr = dcoeffm / dcoeffp;

            var c0 = dcoeffp;
            /// au debut dconvergence à effet  fort 0.9 doit arriver à 0.999
            /// // quand j'applique la convergence, je fait baisser son effet

            if (dconvergence > 0 && last.HasValue)
            {
                var aux = dconvergence;
                //if (last != selectedByCoeff)
                if (_nbAlt > serialAlt)
                {
                    //if (selectedByCoeff)
                    //{

                    //dcoeffp *= dconvergence;
                    //dcoeffm *= dconvergence;
                    //if (dcoeffp < EPSILON) dcoeffp = EPSILON;
                    //if (dcoeffm < EPSILON) dcoeffm = EPSILON;

                    // la convergence est maintenant directement le % de baisse
                    //0.1 -> 0.9  ==> 1.1
                    var limit = dcoeffp - epsilon;
                    if (limit < 0 && dcoeffp >= 0)
                        limit = dcoeffp;
                    var r = 1 + dconvergence;
                    dcoeffp /= r;
                    dcoeffm /= r;

                    if (limit < dcoeffp)
                    {
                        dcoeffp = limit;
                        if (rr > 0m) dcoeffm = rr * dcoeffp;
                    }

                    if (dcoeffp < epsilon)
                    { dcoeffp = epsilon; if (rr > 0m) dcoeffm = rr * dcoeffp; }
                    if (dcoeffm < epsilon)
                    { dcoeffm = epsilon; if (rr > 0m) dcoeffp = dcoeffm / rr; }



                    //   _nbSameDirection = 0;
                    //  lastAutoDirection = null;



                    if (_linkconv)
                        calcConv();
                    else
                    {

                        //  var delta = 1 - dconvergence; // 1- 0.9 = 0.1 // 1-0.1 = 0.9
                        dconvergence /= (1 + dconvdeltam); // 0.09 // 0.81
                        //  dconvergence = 1 - delta; // 0.9 -> 0.91 // 0.1-> 0.19
                    }


                    danticonvergence /= (1 + danticonvdeltam);
                    //var delta = 1 - danticonvergence; 
                    //delta *= (1- danticonvdeltam) ;
                    //danticonvergence = delta - 1; 
                    // if (danticonvergence < 1m) danticonvergence = 1;

                    //delta = danticonvergence - 1; // 0.1
                    //delta *= danticonvdeltam;  //0.09; 
                    //    danticonvergence = 1+delta; // 1.1 -> 1.09
                    // }



                }
                else
                {
                    bool applyanti = false;
                    if (selectedByCoeff && -_nbSameDirectionBox > serialm)
                        applyanti = true;
                    else if (!selectedByCoeff && _nbSameDirectionBox > serialp)
                        applyanti = true;
                    if (applyanti)
                    {
                        var limit = dcoeffp + epsilon;
                        dcoeffp *= (1 + danticonvergence);
                        dcoeffm *= (1 + danticonvergence);
                        danticonvergence *= (1 + danticonvdeltap);



                        if (danticonvergence > 0 && limit > dcoeffp)
                        {
                            dcoeffp = limit;
                        }

                        if (rr > 0)
                            dcoeffm = rr * dcoeffp;

                    }
                    if (_linkconv)
                        calcConv();
                    else if (applyanti)
                    {
                        dconvergence *= (1 + dconvdeltap);
                        //   var delta = 1 - dconvergence; // 1- 0.9 = 0.1 // 1-0.1 = 0.9
                        //var delta = 1 - dconvergence; //0.1 -> 0.9  0.5->0.5
                        //delta /= (1+ dconvdeltap); // 0.81 0.25
                        //dconvergence = 1 - delta;  // 0.18 0.75
                        // dconvergence *= dconvdeltap; // 0.11 // 0.99
                        //    dconvergence = 1 - delta; // 0.9 -> 0.89 // 0.01
                        if (dconvergence > 1 - epsilon)
                            dconvergence = 1 - epsilon;
                        if (dconvergence < epsilon)
                            dconvergence = epsilon;
                    }





                }
                misc.log("convergence {0:0.##}->{1:0.######}", c0, dcoeffp);
                misc.log("evol convergence {0:0.######}->{1:0.######}", aux, dconvergence);
            }

            if (selectedByCoeff)
                makeDelta(false, dcoeffm, nb);
            else
                makeDelta(true, dcoeffp, nb);








        }

        public decimal CoeffT { get { return (decimal)Math.Pow(coeffVirt, safe); } }
        private decimal getCoeff(decimal coeffT) { return Math.Pow(coeffT, (1.0m / safe)); }

        private void makeDelta(bool sens, decimal delta, int nb)
        {
            try
            {
                decimal coeffT = CoeffT;
                while (histo.Count >= NB_HISTO)
                    histo.RemoveAt(0);


                string montee = sens ? "up" : "down";
                var c0 = coeffT;
                if (sens)
                {
                    for (int i = 0; i < nb; i++)
                        coeffT += delta;
                }
                else
                {
                    for (int i = 0; i < nb; i++)
                        coeffT -= delta;
                }
                if (coeffT < 1)
                    coeffT = 1;

                var coeff = getCoeff(coeffT); // (decimal)Math.Pow((double)coeffT, (1.0 / (double)safe));

                misc.log("{0} {1:0.######} {2:0.######}->{3:0.######}", montee, delta, c0, coeffT);

                coeffVirt = coeff;
                if (coeffOldAuto)
                {
                    coeffOld = (decimal)Math.Pow(coeffVirt, coeffOldAutoLevel);
                }
                histo.Add(coeffT);
            }
            catch
            {
            }


        }

        public HistoStat calcStat(selectedCoeff motif, int nb)
        {
            var stat = new HistoStat();
            int _nb = 0;
            int count = histo.Count;
            for (int i = count - 1; i >= 0; i--)
            {
                var h = histo[i];

                // min 
                if (h < stat.min.absolute)
                    stat.min.absolute = h;
                // calcul du plus faible qui n'a pas fonctionné

                if (h < stat.min.relative)
                {
                    if (i + 1 < count)
                    {
                        var suivant = histo[i + 1];
                        if (suivant < h)
                            stat.min.relative = h;
                    }
                    else
                    {
                        if (motif > selectedCoeff.noCoeff || motif == selectedCoeff.none)
                            stat.min.relative = h;
                    }
                }

                //max
                if (h > stat.max.absolute)
                    stat.max.absolute = h;
                // calcul du max qui fonctionne
                if (h > stat.max.relative)
                {
                    if (i + 1 < count)
                    {
                        var suivant = histo[i + 1];
                        if (suivant > h)
                            stat.max.relative = h;
                    }
                    else
                    {
                        if (motif <= selectedCoeff.noCoeff)
                            stat.max.relative = h;
                    }
                }

                _nb++;
                if (_nb >= nb)
                    break;
            }

            return stat;
        }

        private decimal calcMin(int nb, bool sens)
        {
            decimal min = CoeffT;
            int _nb = 0;
            int count = histo.Count;
            for (int i = count - 1; i >= 0; i--)
            {
                var h = histo[i];

                if ((sens && h > min) || (!sens && h < min))
                {
                    // calcul du max qui fonctionne
                    if (sens)
                    {
                        if (i + 1 < count)
                        {
                            var suivant = histo[i + 1];
                            if (suivant > h)
                                min = h;
                        }
                    }
                    // calcul du plus faible qui n'a pas fonctionné
                    else
                        if (i + 1 < count)
                        {
                            var suivant = histo[i + 1];
                            if (suivant < h)
                                min = h;
                        }
                }

                _nb++;
                if (_nb >= nb)
                    break;
            }
            return min;
        }

        public decimal coeffTMin(int nb)
        {
            return calcMin(nb, false);
        }

        public decimal coeffTMax(int nb)
        {
            return calcMin(nb, true);
        }



    }
    public class CalcMedianne
    {

        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        private static int index;
        public static int Index { get { return index; } }



        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }



        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10(rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var dx = medianne - index;


            // var ret = val0 + pente * dx;


            // moyenne avec calcul de log
            var log0 = Math.Log(val0 + EPSILON_LOG);
            var log1 = Math.Log(val1 + EPSILON_LOG);
            // pente = log1 - log0;
            var log = log0 + (log1 - log0) * dx;
            return Math.Exp(log) - EPSILON_LOG;


        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums : IAlbumInit
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private void check_(Piece piece)
        {
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                var album = dict[__album];
                if (album == null)
                {
                    album = new Album(__album);
                    album.Virtual = piece.Virtual;
                    dict.Add(__album, album);
                }
                album.add(piece);

            }


        }

        public int Count { get { return dict.Count; } }

        private string getKey(string _album)
        {
            string str = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                str = _album.Trim();
            }
            return str;
        }

        public void sortVirtual()
        {
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public void check(Piece piece)
        {
            check_(piece);
            foreach (Piece child in piece.Childs)
                check_(child);
        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void makeSort()
        {

            var confSort = consolid.SortAlbumMode;
            stack.Capacity = confSort.stackSize;
            ///check to find first light
            ConfMedianne confMedianne = null;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne,true);
           

          

            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(confSort, confMedianne, conf0); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(consolid.SortAlbumMode));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            // prise en compte de la stack
            stack.build();
            var listStack = stack.Albums;
            foreach (Album s in listStack)
            {
                string key = getKey(s.Name);
                var alb = dict[key];
                stack.merge(s, alb);
            }
            //list.Sort(new AlbumClassComparerStack());
            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank2 = i + 1; 
            //}
        }

        public List<Album> makeSelection()
        {
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }


        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        public List<Album> ListByUpdate
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumLastModifClassementComparer());

                return list;
            }
        }

        public void signalClassChange(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return;
            stack.Add(album);
        }



    }
}
]]></content>
  </file>
</db>
