<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\ViewModel\Colors\Couleurs.cs">
    <content><![CDATA[
using System.Windows.Input;
using pdb.player.ViewModel.Commande;
namespace pdb.player.ViewModel.Colors
{
    /// <summary>
    /// Arborescence des couleurs
    /// </summary>
    public class Couleurs : ColorViewModel
    {
        public static Couleurs Instance = new Couleurs();

        public readonly General general; 
        public readonly Simple player;
        public readonly Simple bib;
        public readonly General main;
        public readonly General album;
        public readonly General classement;
        private readonly ICommand prec;
        private readonly ICommand next; 
        private Couleurs()
            : base("", null, null, null)
        {
            general = new General(this, this,"general", "paramètres valables pour toute l'application"); 
            player = new Simple(general.gradient, this,"player", "configuration du chapeau");
            bib = new Simple(general.gradient, this, "bibliotheque", "configuration de la bibliothèque (partie gauche");
            main = new General(general, this, "main", "configuration de la grille de lecture");
            album = new General(general, this, "album", "vue album");
            classement = new General(general, this, "classement", "partie classement");

            prec = new CoulHistoryBack();
            next = new CoulHistoryForward(); 
        }

        public ICommand Prec { get { return prec; } }
        public ICommand Suiv { get { return next; } }

        public static ColorViewModel get(string path)
        {
            ColorViewModel found = null;
            Instance.tree((vm) =>
            {
                if (vm.ArboName == path)
                {
                    found = vm;
                    return true;
                }
                return false;
            });

            return found;
        }
      

    }

    public class General : ColorViewModel
    {
        public General(Couleurs parent, ColorViewModel owner, string name, string desc)
            : base(name, desc, parent, owner)
        {
            track = new TrackColor(null, this);
            grille = new Grille(null, this);
            gradient = new Gradient(null, this);
        }
        public General(General parent, ColorViewModel owner, string name, string desc)
            : base(name, desc, parent, owner)
        {
            track = new TrackColor(parent.track, this);
            grille = new Grille(parent.grille, this);
            gradient = new Gradient(parent.gradient, this);
        }

        public readonly TrackColor track;
        public readonly Grille grille;
        public readonly Gradient gradient;
    }

    public class Simple : ColorViewModel
    {
        public readonly Gradient gradient;
        public Simple(Gradient parent, ColorViewModel owner, string name, string desc) : base(name,desc,parent, owner)
        {
            this.gradient = new Gradient(parent, this); 
        }
    }

    /// <summary>
    /// Arrière-plan des morceaux
    /// </summary>
    public class TrackColor : ColorViewModel
    {

        private ColorViewModel selected; new public ColorViewModel Selected { get { return selected; } }
        private ColorViewModel moved; public ColorViewModel Moved { get { return moved; } }
        private ColorViewModel empeached; public ColorViewModel Empeached { get { return empeached; } }
        private ColorViewModel empeached1; public ColorViewModel Empeached1 { get { return empeached1; } }
        private ColorViewModel almostFree; public ColorViewModel AlmostFree { get { return almostFree; } }
        private ColorViewModel almostFree1; public ColorViewModel AlmostFree1 { get { return almostFree1; } }
        private ColorViewModel next; public ColorViewModel Next { get { return next; } }
        public readonly ColorViewModel nextByCoeffMain;
        public readonly ColorViewModel nextByCoeffMin;
        private ColorViewModel nextAbsent; public ColorViewModel NextAbsent { get { return nextAbsent; } }
        public readonly Export export;

        public TrackColor(TrackColor parent, ColorViewModel prop)
            : base("track", "couleur des morceaux", parent, prop)
        {
            selected = new ColorViewModel("selected", "morceau sélectionné", "#3399ff", parent == null ? null : parent.selected, this);
            moved = new ColorViewModel("moved", "morceau déplacé pour éviter répétition (quarantaine)", "#93c8ce", parent == null ? null : parent.moved, this);
            empeached = new ColorViewModel("empeached", "morceau réellement empêché par quarantaine", "#93c8ce", parent == null ? null : parent.empeached, this);
            empeached1 = new ColorViewModel("empeached1", "premier morceau réellement empêché par quarantaine", "#93c8ce", parent == null ? null : parent.empeached1, this);
            next = new ColorViewModel("next", "prochain morceau dans l'album en mode automatique", "#b5eaf0", parent == null ? null : parent.next, this);

            almostFree = new ColorViewModel("almostFree", "libre de quarantaine au prochain tour", "#93c8ce", parent == null ? null : parent.almostFree, this);
            almostFree1 = new ColorViewModel("almostFree1", "libre de quarantaine au prochain tour", "#93c8ce", parent == null ? null : parent.almostFree1, this);

            nextByCoeffMain = new ColorViewModel("nextByCoeffMain", "prochain morceau dans l'album en mode automatique causé par le coefficient principal", "#b5eaf0", parent == null ? null : parent.nextByCoeffMain, this);
            nextByCoeffMin = new ColorViewModel("nextByCoeffMin", "prochain morceau dans l'album en mode automatique causé par le coefficient min", "#b5eaf0", parent == null ? null : parent.nextByCoeffMin, this);
           
            nextAbsent = new ColorViewModel("nextAbsent", "prochain morceau dans l'album en mode automatique malheureusement absent", "#c4dfe3", parent == null ? null : parent.nextAbsent, this);
            Export _parentExport = null; 
            if (parent != null)
                _parentExport = parent.export; 
            export = new Export(_parentExport, this);
        }
    }

    /// <summary>
    /// Arrière-plan des morceaux fondé sur le statut
    /// </summary>
    public class Export : ColorViewModel
    {
        public readonly ColorViewModel none;
        public readonly ColorViewModel miss;
        public readonly ColorViewModel present;
        public readonly ColorViewModel copy;
        public readonly ColorViewModel delete;
        public Export(Export parent, ColorViewModel prop)
            : base("export", "statut export", parent, prop)
        {
            none = new ColorViewModel("none", "pas de statut", "#FFFFFFFF", parent == null ? null : parent.none, this);
            miss = new ColorViewModel("miss", "absent", "#FFD3D3D3", parent == null ? null : parent.miss, this);
            present = new ColorViewModel("present", "présent", "#FFFFFFFF", parent == null ? null : parent.present, this);
            copy = new ColorViewModel("copy", "le morcveau a été copié", "#FF90EE90", parent == null ? null : parent.copy, this);
            delete = new ColorViewModel("delete", "le morceau a été supprimé", "#FFA9A9A9", parent == null ? null : parent.delete, this);
        }
    }

    /// <summary>
    /// Couleur des traits de grille
    /// </summary>
    public class Grille : ColorViewModel
    {
        public readonly ColorViewModel lignes;
        public readonly ColorViewModel colonnes;

        public Grille(Grille parent, ColorViewModel prop)
            : base("grille", "couleur des grilles", parent, prop)
        {
            var black = System.Windows.Media.Colors.Black.ToString();
            lignes = new ColorViewModel("lignes", "traits de lignes", black, parent == null ? null: parent.lignes, this);
            colonnes = new ColorViewModel("colonnes", "traits de colonnes", black, parent == null ? null : parent.colonnes, this);
        }
    }

    /// <summary>
    /// Données Gradient (couleur + autres paarmètres)
    /// </summary>
    public class Gradient : ColorViewModel
    {
        public readonly StartPoint depart;
        public readonly EndPoint arrivee;
        public Gradient(Gradient parent, ColorViewModel prop)
            : this(parent, prop, "gradient", "paramètre des gradiants")
        {

        }

        public Gradient(Gradient parent, ColorViewModel prop, string name, string desc)
            : base(name, desc, parent, prop)
        {
        
            this.depart = new StartPoint(parent == null ? null: parent.depart, this);
            this.arrivee = new EndPoint(parent == null ? null: parent.arrivee, this);
        }
    }

    public class StartPoint : ColorViewModel
    {
        public readonly Pt pt;
        public readonly ColorViewModel couleur;
        public readonly ColorViewModel offset;

        public StartPoint(StartPoint parent, ColorViewModel prop)
            : base("StartPoint", "StartPoint", parent, prop)
        {
            this.pt = new Pt(parent == null? null: parent.pt, this, 0, 0);
            this.couleur = new ColorViewModel("couleur", "couleur", "#dfdfdf", parent == null ?  null: parent.couleur, this);
            this.offset = new ColorViewModel("offset", "offset", "0", parent == null ? null : parent.offset, this);
        }
    }

    public class EndPoint : ColorViewModel
    {
        public readonly Pt pt;
        public readonly ColorViewModel couleur;
        public readonly ColorViewModel offset;

        public EndPoint(EndPoint parent, ColorViewModel prop)
            : base("EndPoint", "EndPoint", parent, prop)
        {
            this.pt = new Pt(parent == null ? null: parent.pt, this, 0, 1);
            this.couleur = new ColorViewModel("couleur", "couleur", "#fff", parent == null ? null : parent.couleur, this);
            this.offset = new ColorViewModel("offset", "offset", "1", parent == null ? null : parent.offset, this);
        }
    }




    public class Pt : ColorViewModel
    {
        public readonly ColorViewModel x;
        public readonly ColorViewModel y;
        public Pt(Pt parent, ColorViewModel prop, double x, double y)
            : base("point", "point", parent, prop)
        {
            this.x = new ColorViewModel("x", "x", x.ToString(), parent == null? null: parent.x, this);
            this.y = new ColorViewModel("y", "y", y.ToString(), parent == null ? null : parent.y, this);
        }
    }

    //public class GradientItem : ColorViewModel
    //{
    //    public readonly ColorViewModel couleur;
    //    public readonly ColorViewModel startPoint;
    //    public readonly ColorViewModel offset;

    //    public GradientItem(GradientItem parent, ColorViewModel prop, string name, string desc, double pt, int offset)
    //        : base(name, desc, parent, prop)
    //    {
    //        this.couleur = new ColorViewModel("couleur", "couleur", parent, this);
    //        this.startPoint = new ColorViewModel("startPoint", "??", pt.ToString(), parent, this);
    //        this.offset = new ColorViewModel("offset", "??", offset.ToString(), parent, this);
    //    }
    //}
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\ImportCmd.cs">
    <content><![CDATA[using System;
using System.IO;
using pdb.db;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.gen.pertinence;
using pdb.gen.Tuning;
using pdb.player.engine;
using pdb.util;
using pdb.obj;

namespace pdb.player.ViewModel.Commande
{
    class ImportCmd : CommandeBase
    {
        private IIhm ihm;
        //  public static IIhm Ihm { set { ihm = value; } }
        private IPlayerEngine player;
        //public static IPlayerEngine Player { set { player = value; } }
        CListPiece list;

        private int nbImport;
        private int nbFile;
        private Import conf;
        private DateTime dtImport; 

        public ImportCmd(IIhm ihm, IPlayerEngine player)
        {
            this.ihm = ihm;
            this.player = player;
        }
        public override bool CanExecute(object parameter)
        {
            return true;
        }

        public override void Execute(object parameter)
        {
            conf = ihm.getConfImport("Import");
            string dir = conf.dir; 
            if (string.IsNullOrEmpty(dir))
                return;
            if (!ihm.Confirm("Importer le contenu de " + dir + " ?", "Import"))
                return;

            dtImport = DateTime.Now; 
            list = App.Db.List;

            ChronoData.refreshDate(DateTime.MinValue);
            ChronoData.DateAuto = false;
            nbImport = 0;
            nbFile = 0; 

            DirectoryInfo root = new DirectoryInfo(dir);
            import(root);
            ChronoData.DateAuto = true;
            ihm.InfoIHm(string.Format("importation de {0} terminée\r\n {1} fichier{2} importé{2} \r\n{3} fichier{4} pris en compte", dir, nbImport, (nbImport > 1 ? "s" : ""), nbFile, (nbFile > 1 ? "s" : "")), "Import");
            App.go(true); 
        }

        private void import(DirectoryInfo dir)
        {
            if (dir.Name == "Podcasts")
                return;
            if (dir.Name.StartsWith("poubelle"))
                return;
            if (dir.Name == "hackit")
                return;
            if (dir.Name == "v1")
                return; 
            foreach (FileInfo f in dir.GetFiles())
                import(f);
            foreach (DirectoryInfo sub in dir.GetDirectories())
                import(sub);
        }


        private void import(FileInfo f)
        {
            try
            {
                if (f.IsMusic())
                {
                    if (list.getPiece(f.FullName) != null)
                    {
                        nbFile++;
                        //    App.log.log("emplacement déjà géré : {0}", f.FullName);
                        return;
                    }

                    App.log.log("chargement de " + f.FullName);
                    var newT = new CPiece(f.FullName);
                    var meta = new Metadata(f.FullName);
                    meta.Album = conf.album;
                    meta.Artist = conf.artist;
                    var year = conf.year;
                    if (year != null)
                        meta.Year = year.Value;
                    if (conf.logical)
                    {
                        TrackBuilder.buildFromFile(meta, conf.bname, conf.balbum, conf.bartist, conf.btrackNumber, conf.byear);
                    }
                    if (!conf.Purelogical)
                    {
                        player.load(meta);
                    }
                    TrackBuilder.correction(meta);
                    if (!string.IsNullOrEmpty(conf.album))
                    {
                        meta.TrackNumber = nbFile + 1;
                    }
                    TrackBuilder.buildFrom(newT, meta);


                    App.log.log("chargé {0} {1} {2} {3} {4}", newT.Year, newT.Artist, newT.Album, newT.Name, newT.TrackNumber);

                    var org = list.getPiece(newT);
                    if (org != null)
                    {
                        //  App.log.log("référence déjà connue : {0} {1} {2} {3} {4} à l'emplacement {5}", org.Year, org.Artist, org.Album, org.Name, org.TrackNumber, org.Location);

                    }


                    list.Add(newT);
                    if (org == null)
                    {
                        newT.initClassementIfEmpty("0.0");
                        newT.setAdded(dtImport);
                        nbImport++;
                        App.log.log("importé {0} {1} {2} {3} {4} à l'emplacement {5}", newT.Year, newT.Artist, newT.Album, newT.Name, newT.TrackNumber, newT.Location);
                    }
                    nbFile++;
                    App.Db.saveAsync();

                }
            }
            catch (Exception ex)
            {
                App.log.Error(string.Format("impossible d'importer {0} {1}", f.FullName, ex)); 
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.db;
using pdb.db.obj;
using pdb.gen;
using pdb.util;
using pdb.gen.Tuning;
using System.Runtime.InteropServices;
using pdb.gen.albums;
using pdb.obj;

namespace pdb.player.ViewModel.Commande.PlayList
{
    class StatAlbum
    {
        private string key;
        private int count;

        public void clear()
        {
            count = 0;
        }

        public StatAlbum(string key)
        {
            this.key = key;
        }

        public override bool Equals(object obj)
        {
            if (obj is StatAlbum)
            {
                return key.Equals(((StatAlbum)obj).key);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return key.GetHashCode();
        }

        public int Count { get { return count; } }
        public void record()
        {
            count++;
        }
    }

    class StatAlbums
    {
        private BgDictString0<StatAlbum> dict = new BgDictString0<StatAlbum>();

        public void clear()
        {
            foreach (var stat in dict)
            {
                stat.Value.clear();
            }
        }

        public StatAlbum getStat(Album album)
        {
            var key = album.Key;
            var s = dict[key];
            if (s == null)
            {
                s = new StatAlbum(key);
                dict.Add(key, s);
            }
            return s;
        }
    }


    public enum compressState
    {
        none,
        enCours,
        reload,
        cancel
    }




    class ExportCmd : CommandeBase
    {
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GetDiskFreeSpaceEx(string lpDirectoryName,
        out ulong lpFreeBytesAvailable,
        out ulong lpTotalNumberOfBytes,
        out ulong lpTotalNumberOfFreeBytes);

        private static long getFreeSpace()
        {
            ulong FreeBytesAvailable;
            ulong TotalNumberOfBytes;
            ulong TotalNumberOfFreeBytes;

            bool success = GetDiskFreeSpaceEx(conf.dir, out FreeBytesAvailable, out TotalNumberOfBytes,
                               out TotalNumberOfFreeBytes);
            if (!success)
                throw new System.ComponentModel.Win32Exception();
            return (long)TotalNumberOfFreeBytes;
        }



        private static IExportTracks ihm;
        public static IExportTracks Ihm { set { ihm = value; } }
        // private static bool cancel;
        // protected static string dir;
        protected static PlayListViewModel lastpl;
        protected static List<PiecePrior> all;
        protected static Dictionary<int, PiecePrior> dict;
        protected static Dictionary<int, PiecePrior> masterDict;
        protected static List<PiecePrior> list;
        protected static List<List<PiecePrior>> listes;

        protected static List<PlayListViewModel> playlists = new List<PlayListViewModel>();
        protected static Dict<string, string> empreintes = new Dict<string, string>();
        protected static StatAlbums statAlbums = new StatAlbums();

        //  protected static Dictionary<int, object> ids;
        protected static HashSet<int> idCopie;
        protected static HashSet<string> idCopieLoc;
        private static int nbLoop = 0;
        protected static Export conf;
        private static bool modeAlbum;
        //private static int nbByAlbumMin = int.MaxValue;
        //private static int nbByAlbumMax = int.MaxValue;
        //private static int nbLot = 100; 
        protected static int nbFicherSup;
        protected static int nbFichierAdd;
        const string CAPTION = "export";
        protected string ANNULATION_EXPORT = "Annulation export";
        protected static volatile object _lock = new object();
        protected static Thread thCalcul;
        protected static Thread thCopy;

        protected static bool endCopy;
        protected static bool endCopyFinal;
        protected static compressState copy;
        protected static bool endCalcul;

        protected static compressState query;

        //protected static BgDictString<List<PiecePrior>> locations = new BgDictString<List<PiecePrior>>();

        protected static ILogger logger = Logger.getLogger("export");
#if DEB
        protected static ILogger debug = Logger.getLogger("exportDebug", false);
#endif

        protected static void sendCancel()
        {
            lock (_lock)
            {
                if (query < compressState.cancel)
                    query = compressState.cancel;
            }
        }
        protected static compressState Query
        {
            get
            {
                lock (_lock)
                    return query;
            }
            set
            {
                lock (_lock)
                    query = value;
            }
        }





        public static void CalculExport()
        {
            if (conf != null && conf.oneShot)
                return;
            switch (Query)
            {
                case compressState.none:
                    break;
                case compressState.enCours:
                    //if (checkSthChange())
                    //{
                    //PlayListViewModel.resetExport(exportState.none);
                    Query = compressState.reload;
                    //lock (_lock)
                    //    state = compressState.reload;
                    //}
                    break;
                case compressState.cancel:
                    PlayListViewModel.resetExport(exportState.none);
                    Query = compressState.none;
                    break;
                default:
                    break;
            }
        }

        private static bool checkSthChange()
        {
            bool ret = false;
            foreach (PlayListViewModel pl in playlists)
            {
                var emp = empreintes[pl.Name];
                logger.log("{0} ancienne empreinte {1}", pl.Name, emp);
                var _newEmpre = pl.getEmpreinte();
                logger.log("{0} nouvelle empreinte {1}", pl.Name, _newEmpre);
                if (emp != _newEmpre)
                {
                    logger.log("on recalcule");
                    ret = true;
                }
                empreintes[pl.Name] = _newEmpre;

            }
            return ret;

        }

        protected class PiecePrior
        {
            private int index = int.MaxValue;
            private int prior0 = int.MaxValue;
            private int prior1 = int.MaxValue;
            private int prior2 = int.MaxValue;
            private int prior3 = int.MaxValue;
            public readonly Piece PieceGen;
            public PiecePrior(Piece piece, int prior)
            {
                this.PieceGen = piece;
                this.prior0 = prior;
            }
            public PiecePrior(PiecePrior o)
            {
                PieceGen = o.PieceGen;
                index = o.index;
                prior0 = o.prior0;
                prior1 = o.prior1;
                prior2 = o.prior2; 
                prior3 = o.prior3;
            }

            public override bool Equals(object obj)
            {
                var o = obj as PiecePrior;
                if (o == null)
                    return false;
                return PieceGen.PieceId == o.PieceGen.PieceId;
            }

            public override int GetHashCode()
            {
                return PieceGen.PieceId.GetHashCode();
            }

            public CListFile Files { get { return (PieceGen.Track as CPiece).Files; } }

            public int Index { get { return index; } }
            public int Prior0 { get { return prior0; } }
            public int Prior1 { get { return prior1; } }
            public int Prior2 { get { return prior2; } }
            public int Prior3 { get { return prior3; } }
           // public int PriorMin { get { return System.Math.Min(prior1, prior2); } }
            // public int MasterId { get { return Piece.MasterId; } }
            public int PieceId { get { return PieceGen.PieceId; } }
            public int MasterId { get { return PieceGen.MasterId; } }

            public void setPrior3(PiecePrior o)
            {
                if (o.prior3 < this.prior3)
                    this.prior3 = o.prior3;
            }

            public void setPrior2(int prior)
            {
                if (prior < this.prior2)
                    this.prior2 = prior;
            }

            public void setPrior3(int prior)
            {
                if (prior < this.prior3)
                    this.prior3 = prior; 
            }

            public void setPrior1(int prior)
            {
                if (prior < this.prior1)
                    this.prior1 = prior;
            }

            public void setPrior0(PiecePrior o)
            {
                if (o.prior0 < this.prior0)
                    this.prior0 = o.prior0;
            }

            public void setIndex(int index)
            {
                this.index = index;
            }

            //public static void mergePrior0(ICollection<PiecePrior> list)
            //{
            //    if (list.Count <= 1)
            //        return;
            //    int min = int.MaxValue;
            //    foreach (PiecePrior p in list)
            //    {
            //        var p0 = p.prior0;
            //        if (p0 < min)
            //            min = p0;
            //    }
            //    foreach (PiecePrior p in list)
            //    {
            //        p.prior0 = min;
            //    }
            //}

            //public static void mergePrior1(ICollection<PiecePrior> list)
            //{
            //    if (list.Count <= 1)
            //        return;
            //    int min = int.MaxValue;
            //    foreach (PiecePrior p in list)
            //    {
            //        var p1 = p.prior1;
            //        if (p1 < min)
            //            min = p1;
            //    }
            //    foreach (PiecePrior p in list)
            //    {
            //        p.prior0 = min;
            //    }
            //}

            public override string ToString()
            {
                int rank = PieceGen.RankAlbumReverse;
                int nb = PieceGen.NbExportPresents;
                var _indexExport = PieceGen.IndexExport;
                int indexExport = 0;
                if (_indexExport < 10000 && _indexExport >= 0)
                    indexExport = PieceGen.IndexExport + 1;

                string priority = string.Format("{0} {1} {2} {3} {4}", display(index), display(prior3), display(prior2),display(prior1), display(prior0)); 

                return string.Format("{0} {1} {2} p={3} i={4} {5} {6}", rank, nb, PieceGen.TrackNumber, priority, indexExport, PieceGen.PieceAlbum.Key, PieceGen.Name);
                //  return rank + " " + PieceGen.TrackNumber + "\t" + prior0 + " " + prior1 + " " + PieceGen.ToString();
            }
            private static string display(int nb)
            {
                if (nb < 0 || nb == int.MaxValue)
                    return "-";
                return nb.ToString();
            }
        }

        protected class PriorComparer : IComparer<PiecePrior>
        {
            protected static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(PiecePrior x, PiecePrior y)
            {
                int cmp = x.Index.CompareTo(y.Index);
                if (cmp != 0)
                    return cmp;
                cmp = x.Prior3.CompareTo(y.Prior3);
                if (cmp != 0)
                    return cmp;
                cmp = x.Prior2.CompareTo(y.Prior2);
                if (cmp != 0)
                    return cmp;
                cmp = x.Prior1.CompareTo(y.Prior1);
                if (cmp != 0)
                    return cmp;
                cmp = x.Prior0.CompareTo(y.Prior0);
                if (cmp != 0)
                    return cmp;
              
                var xx = x.PieceGen;
                var yy = y.PieceGen;
                cmp = xx.RankAlbumReverse.CompareTo(yy.RankAlbumReverse);
                if (cmp != 0)
                    return cmp;
                cmp = xx.IndexExport.CompareTo(yy.IndexExport);
                if (cmp != 0)
                    return cmp;
                cmp = xx.VirtualClassement.CompareTo(yy.VirtualClassement);
                if (cmp != 0)
                    return cmp;
                return tn.Compare(xx, yy);

            }
        }


        protected class PriorComparerDelete : IComparer<PiecePrior>
        {
            protected static PriorComparer tn = new PriorComparer();
            public int Compare(PiecePrior x, PiecePrior y)
            {
                return tn.Compare(x, y);
                //int cmp = x.PriorMin.CompareTo(y.PriorMin);
                //if (cmp != 0)
                //    return cmp;
                //cmp = x.Prior2.CompareTo(y.Prior2);
                //if (cmp != 0)
                //    return cmp;
                //cmp = x.Prior1.CompareTo(y.Prior1);
                //if (cmp != 0)
                //    return cmp;
                //return x.Prior0.CompareTo(y.Prior0);

            }
        }
        public ExportCmd()
        {

        }


        public override bool CanExecute(object parameter)
        {
            return ihm != null;
        }

        public override void Execute(object parameter)
        {
            if (Query <= compressState.none)
                record();
            else
            {
                sendCancel();
                PlayListViewModel.resetExport(exportState.none);
            }
            OnPropertyChanged("Header");
        }


        private class TrackAlbumReverseComparer : IComparer<TrackListViewModel>
        {
            //  private static PieceClassementComparerInv comparer = new PieceClassementComparerInv();
            //private bool disabledAlway;

            //public TrackAlbumReverseComparer(bool disabledAlway)
            //{
            //    this.disabledAlway = disabledAlway; 
            //}

            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var xx = x.PieceGen;
                var yy = y.PieceGen;
                if (xx.PieceAlbum != yy.PieceAlbum)
                    return -xx.RankAllAlbum.CompareTo(yy.RankAllAlbum);

                return xx.IndexExport.CompareTo(yy.IndexExport);

                //if (disabledAlway)
                //{
                //    if (x.Enabled != y.Enabled)
                //    {
                //        return -x.Enabled.CompareTo(y.Enabled); // ? -1 : 1;
                //    }
                //}
                //var xv = x.PieceGen.RapportClassement;
                //var yv = y.PieceGen.RapportClassement;

                //int cmp = 0;
                //if (xv > 0 && yv > 0)
                //{
                //    cmp = xv.CompareTo(yv);
                //    if (cmp != 0) return cmp;
                //    cmp = x.PieceGen.VirtualClassement.CompareTo(y.PieceGen.VirtualClassement);
                //    if (cmp != 0) return cmp;
                //}

                //cmp = x.TrackNumber.CompareTo(y.TrackNumber);
                //if (cmp != 0)
                //    return cmp;
                //return x.Location.CompareTo(y.Location);

            }
        }
        protected virtual void buildList(PlayListViewModel pl)
        {

            var list = new List<PiecePrior>();

            try
            {
                bool onlyEnabled = PlayerViewModel.Instance.OnlyEnabled && !modeAlbum;
                bool _modeAlbum = modeAlbum && !PlayerViewModel.Instance.SortByAlbum;

                // var ids = new Dictionary<int, object>();
                int i = 0;
                List<TrackListViewModel> tracks = null;
                if (pl.isSubList("gen") && pl.Name == "all")
                {
                    tracks = new List<TrackListViewModel>(pl.Tracks);
                    tracks.Sort((x, y) =>   -x.PieceGen. RankAllAlbum.CompareTo(y.PieceGen. RankAllAlbum));  //x.Index.CompareTo(y.Index));
                }
                else
                    tracks = new List<TrackListViewModel>(pl.ExportTracks);
                logger.log("export::buildList {0} {1} elements", pl, tracks.Count);
                if (conf.albumReverse)
                {

                    tracks.Sort(new TrackAlbumReverseComparer()); //conf.disabledAlway));

                }
                else
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
                int iii = 0;
                logger.log("buildlist setPrior1 {0}", pl);
                foreach (TrackListViewModel t in tracks)
                {
                    iii++;
                    var pp = dict[t.PieceId];
                    pp.setPrior1(iii);
                    var master = masterDict[t.MasterId];
                    master.setPrior1(iii);
                }

                foreach (PiecePrior pp in dict.Values)
                {
                    var master = masterDict[pp.MasterId];
                    pp.setPrior1(master.Prior1);
                }
                logger.log("buildlist {0}", pl);
                int lastI = 0;
                Album lastAlbum = null;
                StatAlbum lastStatAlbum = null;
                //  int inext = -1; 
                int nbByAlbum = int.MaxValue;
                int limitMax = int.MaxValue;
                if (conf.modeAlbum)
                {
                    nbByAlbum = conf.nbMax;
                    limitMax = conf.limitMax;
                    if (limitMax < nbByAlbum)
                        limitMax = nbByAlbum;
                }
                int nbLot = 0;
                int ii = -1;
                var ids = new HashSet<int>();
                int passe = 0;
                while (true)
                {

                    if (query != compressState.enCours)
                        return;
                    passe++;
                    int nbInThisAlbum = 0;
                    foreach (TrackListViewModel track in tracks)
                    {
                        if (query != compressState.enCours)
                            return;
                        int id = track.PieceId;
                        if (ids.Contains(id))
                            continue;
                        ii++;


                        //  track.ExportStatus = exportState.miss; 
                        if (!onlyEnabled || track.Enabled)
                        {
                            // CPiece piece = track.Piece;
                            if (track.Exists)
                            {
                                var pp = dict[id]; // list.Add(piece);
                                if (pp == null)
                                {
                                    pp = new PiecePrior(track.PieceGen, ii);
                                    dict[id] = pp;
                                    logger.log("bizarre création de {0}", pp);
                                }

                                //var masterId = track.MasterId;
                                //if (ids.Add(masterId))
                                //{
                                //    presents.Add(pp);
                                //}



                                if (!_modeAlbum)
                                {
                                    if (track.album == lastAlbum)
                                    {
                                        if (lastStatAlbum.Count > limitMax)
                                        {
                                            ids.Add(id);
                                            i++;
                                            pp.setPrior2(i); 
                                            continue;
                                        }
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;

                                    }
                                    else
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);
                                        lastStatAlbum = statAlbums.getStat(lastAlbum);
                                        if (lastStatAlbum.Count > limitMax)
                                        {
                                            ids.Add(id);
                                            i++;
                                            pp.setPrior2(i); 
                                            continue;
                                        }

                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;


                                    }

                                    // pp.setPrior(i);
                                    list.Add(pp);

                                    lastStatAlbum.record();
                                    ids.Add(id);

                                    i++;
                                    pp.setPrior2(i); 

                                    //  if (track.Enabled || conf.countAll)
                                    nbLot++;
                                    #if DEB
                                    debug.log("buildList passe={0} i={1} nbLot={2} nbInThisAlbum={3} pp={4}", passe, i, nbLoop, nbInThisAlbum, pp);
                                    #endif

                                    if (conf.modeAlbum && nbLot > conf.lot)
                                    {
                                        nbLot = 0;
                                        nbByAlbum--;
                                        if (nbByAlbum < conf.nbMin)
                                            nbByAlbum = conf.nbMin;
                                        if (nbByAlbum == 0)
                                            break;

                                        limitMax = conf.limitMax;
                                        if (limitMax < nbByAlbum)
                                            limitMax = nbByAlbum;

                                    }


                                }
                                else
                                {
                                    if (conf.modeAlbum)
                                    {
                                        if (track.album == lastAlbum)
                                            continue;
                                        else
                                        {
                                            nbLot++;
                                            if (nbLot > conf.lot)
                                            {
                                                nbLot = 0;
                                                nbByAlbum--;
                                                if (nbByAlbum < conf.nbMin)
                                                    nbByAlbum = conf.nbMin;
                                                if (nbByAlbum == 0)
                                                    break;

                                                limitMax = conf.limitMax;
                                                if (limitMax < nbByAlbum)
                                                    limitMax = nbByAlbum;
                                            }
                                        }
                                    }
                                    List<Piece> album = null;
                                    if (conf.albumReverse)
                                        album = App.gen.getTracksAlbumReverse(track.Track);
                                    else
                                        album = App.gen.getTracksAlbumByNumber(track.Track); // piece);
                                    if (album != null)
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);  //.Album;
                                        foreach (var p in album)
                                        {
                                            var piece = p.Track as CPiece;
                                            if (piece != null && piece.Exists)
                                            {
                                                if (!onlyEnabled || piece.Enabled)
                                                {
                                                    id = p.PieceId;

                                                    //if (ids.Contains(id))
                                                    //    continue;
                                                    var ppp = dict[id];
                                                    // ppp.setPrior(i);
                                                    list.Add(ppp);
                                                    //   ids.Add(id);
                                                    i++;
                                                    if (piece.Enabled || (conf.countFirsts && p.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && p.VirtualClassement <= lastAlbum.ClassementValueLight))
                                                    {
                                                        nbLot++;
                                                        if (conf.modeAlbum && nbLot > conf.lot)
                                                        {
                                                            nbLot = 0;
                                                            nbByAlbum--;
                                                            if (nbByAlbum < conf.nbMin)
                                                                nbByAlbum = conf.nbMin;

                                                            limitMax = conf.limitMax;
                                                            if (limitMax < nbByAlbum)
                                                                limitMax = nbByAlbum;
                                                        }

                                                        nbInThisAlbum++;
                                                        if (nbInThisAlbum >= nbByAlbum)
                                                            break;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!modeAlbum)
                        break;
                    if (nbByAlbum == int.MaxValue)
                        break;
                    if (nbByAlbum > 0)
                    {
                        if (i == lastI)
                        {
                            #if DEB
                            debug.log("buildList fin passe={0} i={1} nbLot={2} nbInThisAlbum={3}", passe, i, nbLoop, nbInThisAlbum);
                            #endif
                            break;
                        }
                    }

                    lastI = i;
                    lastAlbum = null;
                    if (conf.modeAlbum)
                    {
                        if (conf.resetAfterLoop)
                            nbByAlbum = conf.nbMax;
                        if (nbByAlbum < conf.nbMin)
                            nbByAlbum = conf.nbMin;
                        if (nbByAlbum == 0)
                            nbByAlbum = 1;

                        limitMax = conf.limitMax;
                        if (limitMax < nbByAlbum)
                            limitMax = nbByAlbum;
                    }
                }
                listes.Add(list);

                //   ihm.InfoIHm("liste n° " + listes.Count + " " + list.Count + " éléments", CAPTION);
                OnPropertyChanged("Header");
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }

        }

        public override string Header
        {
            get
            {
                if (query == compressState.enCours || query == compressState.reload)
                    return ANNULATION_EXPORT;

                return "Exporter la liste";
            }
        }



        private void record()
        {
            if (Query == compressState.none)
            {

                OnPropertyChanged("Header");
                nbLoop = 0;
                conf = ihm.getConfExport("Configuration Export");

                //  dir = conf.dir; // ihm.folderDialog();

                if (string.IsNullOrEmpty(conf.dir))
                {
                    Query = compressState.none;
                    return;
                }

                modeAlbum = conf.modeAlbum; // ihm.Confirm("par albums complets?", CAPTION);

                //if (modeAlbum)
                //{
                //    nbByAlbumMin = conf.nbMin; // ihm.getNb("Nombre de morceaux par passe?");
                //    nbByAlbumMax = conf.nbMax;
                //    nbLot = conf.lot;
                //}
                //else
                //    nbByAlbum = int.MaxValue;

                playlists.Clear(); empreintes.Clear();
            }

            bool? status = true;


            var pl = ihm.PlayList;
            if (!playlists.Contains(pl))
            {
                playlists.Add(pl);
                empreintes[pl.Name] = pl.getEmpreinte();
                lastpl = pl;
            }

            status = ihm.TriChoix("liste n° " + playlists.Count + " " + pl.ExportTracks.Count + " éléments\r\n lancer l'export ?", CAPTION);



            if (status == null)
            {
                //listes = new List<List<PiecePrior>>();
                playlists.Clear(); empreintes.Clear();
                Query = compressState.none;
                OnPropertyChanged("Header");
                return;
            }
            if (false.Equals(status))
            {
                OnPropertyChanged("Header");
                return;
            }

            waitCalculForEnd();

            Query = compressState.enCours;

            lock (_lock)
            {
                if (thCalcul == null)
                {
                    thCalcul = new Thread(calculLoop);
                    thCalcul.SetApartmentState(ApartmentState.STA);
                    thCalcul.Start();
                }

                if (thCopy == null)
                {
                    thCopy = new Thread(copyLoop);
                    thCopy.SetApartmentState(ApartmentState.STA);
                    thCopy.Start();
                }
            }


            OnPropertyChanged("Header");
        }
        //protected static long totalSize = 0;
        //protected static long capacity = int.MaxValue;
        //protected static long freeSpace; 
        //private static void refreshInfoFreeSpace()
        //{
        //    DriveInfo drive = new DriveInfo(Path.GetPathRoot(conf.dir));
        //    var calculfree = freeSpace; 
        //    freeSpace = drive.AvailableFreeSpace;
        //    var delta = freeSpace - calculfree;
        //    if (delta > 0)
        //        App.log.log("difference free space " + delta); 

        //}

        private void buildListIni()
        {

            logger.log("export:buildListIni");
            lock (_lock)
            {
                statAlbums.clear();
                listes = new List<List<PiecePrior>>();

                all = new List<PiecePrior>();
                dict = new Dictionary<int, PiecePrior>();
                masterDict = new Dictionary<int, PiecePrior>();
            }
            //  locations = new BgDictString<List<PiecePrior>>();

            try
            {

                if (!conf.dir.EndsWith("\\"))
                    conf.dir += "\\";
                //  refreshInfoFreeSpace(); 

                List<Piece> l = null;


                if (lastpl.isSubList("album") || PlayerViewModel.Instance.SortByAlbum)
                {
                    l = App.gen.sortByAlbum();
                   // l.Reverse();
                }
                else
                    l = App.gen.sortByClass();
                // l.Reverse();

                int i = 0;
                foreach (Piece p in l)
                {

                    if (query != compressState.enCours)
                        return;
                    //var piece = p.Track as CPiece;
                    if (!dict.ContainsKey(p.PieceId))
                    {
                        i++;
                        var pp = new PiecePrior(p, i);

                        all.Add(pp);
                        dict[p.PieceId] = pp;
                    }
                }

                foreach (Piece p in l)
                {
                    if (query != compressState.enCours)
                        return;
                    var id = p.PieceId; 
                    var masterId = p.MasterId;
                    if (!masterDict.ContainsKey(masterId))
                    {
                        var _p = dict[masterId];
                        var pMaster = new PiecePrior(_p);
                        masterDict[masterId] = pMaster;
                    }
                    else
                    {
                        masterDict[masterId].setPrior0(dict[id]); 
                    }
                }

                foreach (Piece p in l)
                {
                    if (query != compressState.enCours)
                        return;
                    dict[p.PieceId].setPrior0(masterDict[p.MasterId]);
                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }

        }

        private void waitCalculForEnd()
        {
            lock (_lock)
            {

                if (query == compressState.none)
                    return;
                if (query == compressState.enCours)
                    query = compressState.cancel;
            }
            var dt = DateTime.Now;
            int nb = 0;
            while (true)
            {
                lock (_lock)
                    if (endCalcul)
                        return;
                Thread.Sleep(100);
                if ((DateTime.Now - dt).TotalSeconds > 10)
                    return;
                nb++;
                if (nb >= 10)
                {
                    nb = 0;
                    logger.log("waitForEnd Calcul");
                }
            }

        }


        private void waitCopyForEnd()
        {
            lock (_lock)
            {
                if (copy == compressState.none)
                    return;
                if (copy == compressState.enCours)
                    copy = compressState.cancel;
                if (endCopy)
                    return;
            }
            var dt = DateTime.Now;
            int nb = 0;
            while (true)
            {
                lock (_lock)
                {
                    if (endCopy)
                        return;
                    if (query != compressState.enCours)
                    {
                        logger.log("abandon attente car query={0}", query);
                        return;
                    }
                }
                Thread.Sleep(100);
                if ((DateTime.Now - dt).TotalSeconds > 10)
                    return;
                nb++;
                if (nb >= 10)
                {
                    nb = 0;
                    logger.log("waitForEnd Copy");
                }
            }

        }


        [STAThread]
        private void copyLoop()
        {
            while (true)
            {
                try
                {
                    compressState _cp;
                    lock (_lock)
                        _cp = copy;
                    if (_cp != compressState.enCours)
                    {
                        Thread.Sleep(1000);
                        continue;
                    }

                    _copy();
                }

                catch (Exception ex)
                {
                    logger.log(ex.ToString());
                }
            }
        }


        [STAThread]
        private void calculLoop()
        {


            while (true)
            {
                switch (Query)
                {
                    case compressState.none: Thread.Sleep(1000); continue;

                    case compressState.enCours:
                        if (endCopyFinal)
                        {
                            Thread.Sleep(1000); continue;
                        }
                        break;
                    case compressState.reload:
                        waitCalculForEnd();
                        break;

                    case compressState.cancel:
                        {
                            waitCalculForEnd();
                            waitCopyForEnd();
                            Query = compressState.none;
                            nbLoop = 0;
                            Thread.Sleep(1000); continue;
                        }

                    default:
                        break;
                }
                lock (_lock)
                {
                    endCalcul = false;
                    query = compressState.enCours;
                    nbLoop++;
                }

                _calc();

            }
        }

        private void _calc()
        {
            try
            {




                buildListIni();

                if (query != compressState.enCours)
                    return;

                foreach (PlayListViewModel pl in playlists)
                {
                    buildList(pl);
                    if (query != compressState.enCours)
                        return;
                }

                //foreach (List<PiecePrior> lp in locations.Values)
                //{
                //    PiecePrior.mergePrior1(lp);
                //}

                // concaténation
                int max = 0;
                list = new List<PiecePrior>();
                var ids = new HashSet<int>();


                logger.log("_calc:concaténation"); 

                foreach (var _l in listes)
                {
                    if (query != compressState.enCours)
                        return;
                    var count_ = _l.Count;
                    if (count_ > max)
                        max = count_;
                }
                int count = listes.Count;

                int nb = 0;
                for (int i = 0; i < max; i++)
                {
                    if (query != compressState.enCours)
                        return;
                    for (int j = 0; j < count; j++)
                    {
                        var l = listes[j];
                        if (i < l.Count)
                        {
                            var p = l[i];
                            if (ids.Add(p.PieceId))
                            {
                                nb++;
                                p.setPrior3(nb);
                                p.setIndex(nb);
                                list.Add(p);
                                var master = masterDict[p.MasterId];
                                if (master != p)
                                    master.setPrior3(p);

                            }
                        }
                    }
                }
                #if DEB
                debug.log("_calc: avant tri");
                #endif
                for (int i = 0; i < list.Count; i++)
                {
                    if (query != compressState.enCours)
                        return;
                    var p = list[i];
                    var master = masterDict[p.MasterId];
                    if (master != p)
                        p.setPrior3(master);
                    #if DEB
                    debug.log("i={0} pp={1}", i, p);
                    #endif  


                }
#if DEB
                debug.log("_calc: apres tri");
                list.Sort(new PriorComparer());
                for (int i = 0; i < list.Count; i++)
                {
                    debug.log("i={0} pp={1}", i, list[i]);
                }

                debug.log("_calc: all apres tri");

                all.Sort(new PriorComparer());
                for (int i = 0; i < all.Count; i++)
                {
                    debug.log("i={0} pp={1}", i, all[i]);
                }
#endif
                waitCopyForEnd();
                lock (_lock)
                {
                    if (query != compressState.enCours)
                        return;
                    App.log.log("Export lancé " + listes.Count + " liste" + (listes.Count > 1 ? "s " : " ") + list.Count + " éléments", CAPTION);
                    endCopy = false; copy = compressState.enCours; endCopyFinal = false;
                }

                while (true)
                {
                    Thread.Sleep(100);

                    if (endCopy || query != compressState.enCours)
                        break;

                }


            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
                Thread.Sleep(1000);
            }

            finally
            {
                lock (_lock)
                    endCalcul = true;


            }
        }

        protected virtual bool noMoreSpace()
        {
            return true;
        }
        protected virtual void prepareExport()
        {
        }

        protected void setExport(exportState state, PiecePrior p)
        {
            setExport(state, p.PieceGen);
        }

        protected void setExport(exportState state, ITrackNativeDates p)
        {
            p.ExportStatus = state;
            PlayListViewModel.setExport(p.PieceId, state);


            var h = TrackListViewModel.HumanSelected;
            if (h != null)
            {
                if (p.Album == h.Album)
                {
                    TrackListViewModel trackAlbum = PlayListViewModel.findTrack(App.bib.Musique, p.PieceId);
                    if (trackAlbum != null)
                    {
                        trackAlbum.ExportStatus = state;
                    }

                }
            }

            //var track = PlayListViewModel.findTrack(lastpl, p.PieceId);
            //if (track != null)
            //{
            //    track.ExportStatus = state;
            //}
            //var h = TrackListViewModel.HumanSelected;
            //if (h != null)
            //{
            //    if (p.Album == h.Album)
            //    {
            //        var album = App.getAlbum(h);
            //        var f = album.Find(t => t.PieceId == p.PieceId);
            //        if (f != null)
            //            track.ExportStatus = state;
            //    }
            //  }
        }
        [STAThread]
        private void _copy()
        {

            PlayListViewModel.resetExport(exportState.none);
            logger.log("check existant files");
            try
            {
                List<PiecePrior> _list = null;
                lock (_lock)
                {
                    _list = new List<PiecePrior>(list);
                }
                foreach (PiecePrior piece in _list)
                {
                    try
                    {
                        if (copy != compressState.enCours)
                            return;
                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        var files = piece.Files;
                        foreach (CFile file in files)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            setExport(exportState.present, piece);
                            // PlayListViewModel.setExport(piece.Piece.PieceId, exportState.present);
                            //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //if (track != null)
                            //{
                            //    track.ExportStatus = exportState.present;
                            //}
                        }
                        else
                            setExport(exportState.miss, piece);
                    }
                    catch (Exception e)
                    {
                        App.log.log(e.ToString());
                    }
                }

                logger.log("prepareExport");

                nbFicherSup = 0; nbFichierAdd = 0;
                idCopie = new HashSet<int>();
                idCopieLoc = new HashSet<string>();
                //  presents.Sort(new PriorComparer());
                prepareExport();

                string orgDir = CFile.DefaultFolder;
                foreach (PiecePrior piece in _list)
                {
                    try
                    {
                        if (copy != compressState.enCours)
                            return;

                        int id = piece.PieceGen.MasterId;
                        if (idCopie.Contains(id))
                            continue;
                        var files = piece.Files;
                        bool contFile = false;
                        foreach (CFile file in files)
                        {
                            if (idCopieLoc.Contains(file.File))
                            {
                                contFile = true;
                                break;
                            }
                        }
                        if (contFile)
                            continue;

                        idCopie.Add(id); // idCopie[id] = piece;
                        foreach (CFile file in files)
                        {
                            idCopieLoc.Add(file.File); // [file.File] = piece;
                        }




                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        foreach (CFile file in files)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {

                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }

                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            //    var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //    if (track != null)
                            //    {
                            //        track.ExportStatus = exportState.present; 
                            //    }
                            continue;
                        }

                        //2. Copie du meilleur fichier
                        CFile pertinent = files.getPertinentFile();
                        if (pertinent == null)
                            continue;


                        while (true)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                var f = FileRegister.Check(pertinent.Path); //  FileInfo f = new  FileInfo FileInfo(pertinent.Path);
                                var freeSpace = getFreeSpace() - conf.marge;
                                long nextfreeAvailable = freeSpace - f.Length;
                                if (nextfreeAvailable < 0)
                                {
                                    if (noMoreSpace())
                                        return;
                                    continue;
                                }
                                App.log.log("copie\t" + piece + "->" + conf.dir + pertinent.File + " ( " + piece.PieceGen + " )");
                                f.copyWithImg(conf.dir + pertinent.File);
                                //  freeSpace = nextfreeAvailable; 
                                //  PlayListViewModel.setExport(piece.Piece.PieceId, exportState.copy);
                                setExport(exportState.copy, piece);
                                //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                                //if (track != null)
                                //{
                                //    track.ExportStatus = exportState.copy;
                                //}
                                nbFichierAdd++;

                                break;
                            }
                            catch (System.IO.IOException io)
                            {
                                App.log.log(io.Message);
                                //  refreshInfoFreeSpace(); 
                                if (noMoreSpace())
                                    return;
                            }
                        }

                    }

                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }


                }
            }
            catch (Exception ex)
            {
                App.log.log(ex.ToString());

            }
            finally
            {
                compressState _copy;
                lock (_lock)
                    _copy = copy;

                if (Query != compressState.none && _copy != compressState.none)
                {
                    var _status = string.Format("statusCalc={0} statusCopy={1} calc={2} copy={3}", endCalcul, endCopy, query, copy);
                    var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6} {7}",
                        listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""), _status);
                    App.log.log(log, CAPTION);
                    if (conf.oneShot)
                        ihm.InfoIHm(log, CAPTION);
                    //  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                    //list = new List<PiecePrior>();
                    //listes = new List<List<PiecePrior>>(); 

                    if (_copy == compressState.enCours)
                    {
                        endCopyFinal = true;
                        // PlayListViewModel.resetExport(exportState.none);
                    }

                    OnPropertyChanged("Header");
                }

                lock (_lock)
                {
                    endCopy = true;
                    copy = compressState.none;
                }
                //var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6}",
                //    listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""));
                //App.log.log(log, CAPTION);
                //if (conf.oneShot)
                //    ihm.InfoIHm(log, CAPTION);
                ////  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                //list = null;
                //listes = null;

                //if (state == compressState.enCours)
                //{
                //}
                //else
                //    PlayListViewModel.resetExport(exportState.none);

                //lock (_lock)
                //    state = compressState.end;
                //OnPropertyChanged("Header");

            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCompress.cs">
    <content><![CDATA[
using System.Collections.Generic;
using pdb.db;
using pdb.db.obj;
using pdb.obj;
using pdb.util;
using pdb.gen;
namespace pdb.player.ViewModel.Commande.PlayList
{
    class ExportCompress : ExportCmd
    {
        private List<CFile> files;
        private int index = 0;
        private int indexPresent = 0;
        List<PiecePrior> _all;


        public ExportCompress()
        {
        }
        public override string Header
        {
            get
            {
                string header = base.Header;
                if (header.Contains(ANNULATION_EXPORT))
                    return header;

                return "Exporter la liste et compresser si besoin";

            }
        }
        protected override void prepareExport()
        {
            logger.log("preparation export"); 
            //   BgDict<int, ITrackIdentity> dict = new BgDict<int, ITrackIdentity>();
            files = new List<CFile>();
            index = 0;
            indexPresent = 0;
            //foreach (PiecePrior track in list)
            //{
            //    int id = track.MasterId;
            //    dict[id] = track.Piece;
            //}

            _all = new List<PiecePrior>(all);
            _all.Sort(new PriorComparerDelete());
            _all.Reverse();
#if DEB
            debug.log("prepareExport: _all apres tri"); 
            for (int i = 0; i < _all.Count; i++)
            {
                debug.log("i={0} pp={1}", i, _all[i]);
            }
#endif

            // phase 1 compress
            foreach (PiecePrior p in _all)
            {
                getSecondaryFiles(p.Files);
            }
        }

        private void getSecondaryFiles(CListFile m_files)
        {
            // var m_files = piece.Files;
            if (m_files.Count <= 1)
                return;

            var l = new List<CFile>();
            foreach (CFile file in m_files)
            {
                if (FileRegister.Exist(conf.dir + file.File))
                {
                    l.Add(file);
                }
            }
            if (l.Count <= 1)
                return;

            l.Sort(new CFileComparer());

            for (int i = 1; i < l.Count; i++)
                files.Add(l[i]);
        }

        //private CFile getPertinentFile(CPiece piece)
        //{
        //    var m_files = piece.Files;
        //    if (m_files.Count < 1)
        //        return null;

        //    var l = new List<CFile>();
        //    foreach (CFile file in m_files)
        //    {
        //        if (FileRegister.Exist(conf.dir + file.File))
        //        {
        //            l.Add(file);
        //        }
        //    }
        //    if (l.Count < 1)
        //        return null;
        //    if (l.Count >= 2)
        //        l.Sort(new CFileComparer());

        //    return l[0];
        //}

        protected override bool noMoreSpace()
        {
            if (index >= files.Count)
            {
                return noMoreSpace2();
            }

            CFile file = null;
            while (true)
            {
                if (index >= files.Count)
                    return noMoreSpace2();
                file = files[index];
                string path = conf.dir + file.File;
                var fi = FileRegister.Check(path);
                if (fi.Exists)
                {
                    misc.deleteFile(path, file.ToString());
                    //   freeSpace += fi.Length; 
                    return false;
                }
                index++;
            }
        }

        private bool noMoreSpace2()
        {
            if (indexPresent >= _all.Count)
                return true;
            while (true)
            {
                if (indexPresent >= _all.Count)
                    return true;
                var p = _all[indexPresent];
                int id = p.MasterId;
                if (!idCopie.Contains(id))
                {

                    var files = p.Files;

                    bool contFile = false;
                    foreach (CFile file in files)
                    {
                        if (idCopieLoc.Contains(file.File))
                        {
                            contFile = true;
                            break;
                        }
                    }

                    if (!contFile)
                    {
                        //if (files.Exists)
                        //{
                        //var track = PlayListViewModel.findTrack(lastpl, p.PieceId);

                        //App.log.log("supression fichiers de {0}", p);
                        foreach (CFile f in files)
                        {
                            string path = conf.dir + f.File;
                            var fv = FileRegister.Check(path);
                            if (fv.Exists)
                            {
                                misc.deleteWithImg(path, string.Format("{0} {1}", p, f));
                                //  freeSpace += fv.Length; 
                                // PlayListViewModel.setExport(piece.PieceId, exportState.delete);
                                setExport(exportState.delete, p.PieceGen);
                                //if (track != null)
                                //    track.ExportStatus = exportState.delete;
                                nbFicherSup++;
                                return false;
                            }
                        }
                        //  }
                    }
                }
                indexPresent++;

            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ConfAlbumSortW" Loaded="Window_Loaded"  xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" >
    <Grid  IsSharedSizeScope="True" >

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <Grid Grid.Row="0" Name="gfirst" IsSharedSizeScope="True"/>

        <Grid Grid.Row="1" Name="gsecond"  IsSharedSizeScope="True"/>
        <!--<Grid Grid.ColumnSpan="2" Margin="0,0,-172,0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="236*" />
            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="4" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="5" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="6" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="7" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" KeyUp="tb_safe_KeyUp" />
            <TextBox  Grid.Row="0" Grid.Column="8" Name="tb_coeff" Width="40" ToolTip="coeff des morceaux virtuels" Margin="5" KeyUp="tb_safe_KeyUp" />
            <TextBox  Grid.Row="0" Grid.Column="9" Name="tb_coeffT" Width="40" ToolTip="coeff total des morceaux virtuels" Margin="5" KeyUp="tb_coeffT_KeyUp" />
            <CheckBox  Grid.Row="0" Grid.Column="10" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="11" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="0" Grid.Column="12" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="0" Grid.Column="13" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="14" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="15" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="16" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="17" Name="cb_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="18" Name="cb_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="19" Name="cb_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="20" Name="cb_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="21" Name="cb_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="22" Name="cb_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="23" Name="cb_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="24" Name="cb_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" />

            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="0" Grid.Column="25" Name="cbx_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="0" Grid.Column="26" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="4" Name="cb2_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="5" Name="cb2_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="6" Name="cb2_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="7" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="8" Name="tb2_coeff" Width="40" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="9" Name="tb2_coeffT" Width="40" ToolTip="coeff total des morceaux virtuels" Margin="5"  />
            <CheckBox  Grid.Row="1" Grid.Column="10" Name="cb2_removeFirst" ToolTip="removeFirst" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="11" Name="cb2_deleteFirst" ToolTip="deleteFirst" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="1" Grid.Column="12" Name="cbx2_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="1" Grid.Column="13" Name="cb2_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="14" Name="cb2_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="15" Name="tb2_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="16" Name="cb2_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="17" Name="cb2_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="18" Name="cb2_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="19" Name="cb2_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="20" Name="cb2_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="21" Name="cb2_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="22" Name="cb2_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="23" Name="cb2_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="24" Name="cb2_noaddAll" ToolTip="tout virtuel" Margin="5" Padding="2" />
            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="1" Grid.Column="25" Name="cbx2_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="1" Grid.Column="26" Name="tb2_zero" Width="120" ToolTip="zéro" Margin="5" />
        </Grid>-->
        <Grid Grid.Row="2" Height="137" Margin="0,0,34,-102">
            <StackPanel Orientation="Horizontal"  HorizontalAlignment="Left"  Margin="0,5" >
                <CheckBox Name="cb_createCourant" ToolTip="générer stats en cours (désactivés)"  Margin="5" Padding="2"></CheckBox>
                <CheckBox Name="cb_createInter" ToolTip="générer stats en cours + provisoire"  Margin="5" Padding="2"></CheckBox>
                <CheckBox Name="cb_createAll" ToolTip="générer stats de tout"  Margin="5" Padding="2"></CheckBox>
                <DatePicker Name="dp_date" ToolTip="Date seuil pour considérer un classement provisoire" />
            </StackPanel>
            <StackPanel Orientation="Horizontal"  HorizontalAlignment="Right" Margin="0,5,-80,5"  Width="414">
                <TextBox Grid.Row="2" Name="tb_stackSize" Width="30"  VerticalAlignment="Center" Text="20" ToolTip="taille de la pile d'exclusion" Margin="5" Padding="2"/>
                <TextBox Grid.Row="2" Name="tb_stackBefore" Width="30"  VerticalAlignment="Center" Text="10" ToolTip="nb d'éléments devant la pile d'exclusion" Margin="5" Padding="2"/>
                <CheckBox Grid.Row="2" Name="cb_stackEnabled" Width="30"  VerticalAlignment="Center" ToolTip="Utiliser la pile d'exclusion" Margin="5" Padding="2" />
                <CheckBox Grid.Row="2" Name="cb_checkStack" Width="30"  VerticalAlignment="Center" ToolTip="Ne pas prendre en compte les albums retardés dans la file d'attente pour la cinématique" Margin="5" Padding="2" />
                <CheckBox Grid.Row="2" Name="cb_idem" Width="30"  VerticalAlignment="Center" ToolTip="Lier les items" Margin="5" Padding="2" Click="cb_idem_Click" />

                <Button Grid.Row="2" Name="bt_cancel" IsCancel="true" Height="25" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_ok" Height="25" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" Padding="2"/>
                <Button Grid.Row="2" Name="bt_coul" Height="25" HorizontalAlignment="Right" Content="Couleurs" Click="bt_coul_Click"   Margin="5" Padding="2"/>
            </StackPanel>
        </Grid>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\ConfMedianneW.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.Conf.ConfMedianneW"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
            >
    <Grid Grid.IsSharedSizeScope="True" >
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="*" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <Grid Grid.IsSharedSizeScope="True" Margin="6">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" SharedSizeGroup="C1" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C2" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C3" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C4" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C5" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C6" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C7" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C8" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C9" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C10" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C11" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C12" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C13" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C14" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C15" />
                <ColumnDefinition Width="Auto" SharedSizeGroup="C16" />
            </Grid.ColumnDefinitions>
           


            <CheckBox  Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="2" />


            <CheckBox   Grid.Row="0" Grid.Column="4" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="2" />
            <CheckBox   Grid.Row="0" Grid.Column="5" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast"  Grid.Row="0" Grid.Column="6" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>

            <TextBox   Grid.Row="0" Grid.Column="7" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox   Grid.Row="0" Grid.Column="8" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />




            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin"  Grid.Row="0" Grid.Column="9" Name="cbx_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox   Grid.Row="0" Grid.Column="10" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />




           
        </Grid>
        <Grid Grid.Row="1" Name="gmain">
            <Label Content="main:" Margin="0,0,12,0"></Label></Grid>
        <Grid Grid.Row="2" Name="gmin">
            <Label Content="min:" Margin="0,0,12,0"></Label>
        </Grid>
    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\ConfVirt.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.Conf.ConfVirt"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
            >
    <Grid Grid.IsSharedSizeScope="True" >
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto" SharedSizeGroup="V1" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V2" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V3" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V4" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V5" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V6" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V7" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V8" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V9" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V10" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V11" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V12" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V13" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V14" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V15" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V16" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V17" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V18" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V19" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V20" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V21" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V22" />

            <ColumnDefinition Width="Auto" SharedSizeGroup="V23" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V24" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V25" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V26" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V27" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V28" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V29" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V30" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V31" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V32" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V33" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V34" />
            <ColumnDefinition Width="Auto" SharedSizeGroup="V35" />
        </Grid.ColumnDefinitions>


        <CheckBox Height="20" VerticalAlignment="Center" Name="cb_lissage" ToolTip="lissage" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="1" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="2" Name="cb_reSort" ToolTip="reSort" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <TextBox Grid.Column="3" Name="tb_safe" ToolTip="safe" Margin="6,22,5,22" KeyUp="tb_safe_KeyUp" Grid.RowSpan="2" />
        <TextBox Grid.Column="4" Name="tb_coeff" ToolTip="coeff des morceaux virtuels" Margin="5,22,6,22" KeyUp="tb_safe_KeyUp" Grid.RowSpan="2" />
        <TextBox  Grid.Column="5" Name="tb_coeffT" ToolTip="coeff total des morceaux virtuels" Margin="6,22,5,22" KeyUp="tb_coeffT_KeyUp" Grid.RowSpan="2" />


        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="6" Name="cb_cumul" ToolTip="cumul" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="7" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5,22" Padding="2" Grid.RowSpan="2" />


        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="8" Name="cb_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="9" Name="cb_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="10" Name="cb_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="11" Name="cb_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="12" Name="cb_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="13" Name="cb_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="14" Name="cb_noaddEnd" ToolTip="en fin d'alum pas de virtuel" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="15" Name="cb_noaddAll" ToolTip="tout virtuel" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="16" Name="cb_auto" ToolTip="pilotage auto" Margin="5,22" Padding="2" Grid.RowSpan="2" />
        <TextBox Grid.Column="17" Name="tb_dcoeffp" ToolTip="delta en montée" Margin="5,22,6,22" Grid.RowSpan="2" KeyUp="tb_dcoeffp_KeyUp" />
        <TextBox Grid.Column="18" Name="tb_serialp" ToolTip="série en montée" Margin="6,22,5,22" Grid.RowSpan="2" />
        <TextBox Grid.Column="19" Name="tb_dcoeffm" ToolTip="delta en descente" Margin="5,22,6,22" Grid.RowSpan="2" />
        <TextBox Grid.Column="20" Name="tb_serialm" ToolTip="série en descente" Margin="6,22,5,22" Grid.RowSpan="2" />
        <TextBox Grid.Column="21" Name="tb_serial" ToolTip="série en cours" Margin="5,22,6,22" Grid.RowSpan="2" ToolTipService.ShowOnDisabled="True" />
        <TextBox Grid.Column="22" Name="tb_convergence" ToolTip="convergence" Margin="6,22,5,22" Grid.RowSpan="2" KeyUp="tb_convergence_KeyUp" />
        <TextBox Grid.Column="23" Name="tb_dconvdeltap" ToolTip="evol convergent +" Margin="5,22,6,22" Grid.RowSpan="2" />
        <TextBox Grid.Column="24" Name="tb_dconvdeltam" ToolTip="cevol convergent -" Margin="6,22,5,22" Grid.RowSpan="2" />

        <CheckBox Height="20" VerticalAlignment="Center" Grid.Column="25" Name="cb_link" ToolTip="aligner convergence et coeff" Margin="5,22" Padding="2" Grid.RowSpan="2" Click="cb_link_Click" />
        <TextBox Grid.Column="26" Name="tb_prod" ToolTip="produit de convergence" Margin="5,22,6,22" Grid.RowSpan="2" KeyUp="tb_prod_KeyUp" ToolTipService.ShowOnDisabled="True" />
        <TextBox Grid.Column="27" Name="l_prod" ToolTip="produit de convergence effectif" Margin="6,22,5,22" Grid.RowSpan="2" ToolTipService.ShowOnDisabled="True"  IsReadOnly="True"/>
        <TextBox Grid.Column="28" Name="tb_anti" ToolTip="anti-convergence" Margin="5,22,6,22" Grid.RowSpan="2" />
        <TextBox Grid.Column="29" Name="tb_antideltap" ToolTip="evol anti-convergent +" Margin="6,22,5,22" Grid.RowSpan="2" />
        <TextBox Grid.Column="30" Name="tb_antideltam" ToolTip="evol anti-convergent -" Margin="5,22,6,22" Grid.RowSpan="2" />
        <TextBox  Height="20" Grid.Column="31" Name="tb_coeffOld"  VerticalAlignment="Center" Text="1" ToolTip="Coeff des vieux morceaux" Margin="6,22,5,22" Grid.RowSpan="2" />
        <CheckBox Height="20" Grid.Column="32" Name="cb_oldAsZero" VerticalAlignment="Center" ToolTip="Vieux comme null" Margin="5,22,6,22" Padding="2" Grid.RowSpan="2" />
        <CheckBox Height="20" Grid.Column="33" Name="cb_coeffOldAuto" VerticalAlignment="Center" ToolTip="Vieux comme null" Margin="6,22,5,22" Padding="2" Grid.RowSpan="2" />
      
        <TextBox  Height="20" Grid.Column="34" Name="tb_coeffAutoLevel"  VerticalAlignment="Center" Text="4" ToolTip="Niveau des vieux" Margin="6,22,5,22" Grid.RowSpan="2" />
    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Util\StringFormatConverter.cs">
    <content><![CDATA[using System;
using System.Windows.Data;
using pdb.util;
using pdb.player.ViewModel;
using System.Windows.Media;
using pdb.gen;
using pdb.gen.albums;
using pdb.player.ViewModel.Colors;
using System.Windows;
using pdb.obj;

namespace pdb.player.Vue.Util
{
    [ValueConversion(typeof(object), typeof(string))]
    public class StringFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            string format = parameter as string;
            if (!string.IsNullOrEmpty(format))
            {
                return string.Format(culture, format, value);
            }
            else
            {
                return value.ToString();
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TimeSpan), typeof(string))]
    public class TimeFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is TimeSpan)
            {
                TimeSpan ts = (TimeSpan)value;
                return String.Format("{0}:{1}{2}", ts.Minutes, ts.Seconds >= 10 ? "" : "0", ts.Seconds);
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(string), typeof(string))]
    public class ClFormatConverter : BaseConverter, IValueConverter
    {
        static int NB_DEC = 4;
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            var str = value.ToString();
            int count = str.Length;
            return Piece.getReadableCl(str);
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            bool second = false;
            //if (str.StartsWith("0"))
            second = true;
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {

                        if (i > NB_DEC || (i >= NB_DEC && second))
                        {
                            if (!second)
                            {
                                second = true;
                                i = 1;
                            }
                            else
                                i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();


        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (value == null) return "";
            return value.ToString().Replace(" ", "");
        }
    }


    [ValueConversion(typeof(int), typeof(string))]
    public class IntFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                int ivalue = (int)value;
                if (ivalue <= 0) return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            int result;
            if (int.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }


    [ValueConversion(typeof(decimal), typeof(string))]
    public class DecimalFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is decimal)
            {
                decimal dvalue = (decimal)value;
                if (dvalue <= 0) return "";
                return dvalue.ToString("0.###");

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            decimal result;
            if (decimal.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }

    [ValueConversion(typeof(DateTime), typeof(string))]
    public class DateToDelaiConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            if (value is DateTime)
            {
                DateTime dvalue = (DateTime)value;
                int delta = (int)((DateTime.Now.Date - dvalue.Date).TotalDays);
                return delta.ToString();

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            decimal result;
            if (decimal.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter0 : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = BgColorFormatConverter.getConf(parameter);

                return BgColorFormatConverter.getColor0(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter00 : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = BgColorFormatConverter.getConf(parameter);

                return BgColorFormatConverter.getcolor00(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }



    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter : BaseConverter, IValueConverter
    {
        public static SolidColorBrush getcolor00(TrackListViewModel tv, TrackColor couleurs)
        {
            if (tv.PieceGen.IsNext)
            {
                if (tv.Exists)
                {
                    if (tv.PieceGen.AlmostFree) return couleurs.AlmostFree.Brush;
                    if (tv.PieceGen.AlmostFree1) return couleurs.AlmostFree1.Brush; 
                    if (tv.PieceGen.Empeached1) return couleurs.Empeached1.Brush;
                    if (tv.PieceGen.Empeached) return couleurs.Empeached.Brush;
                    if (tv.PieceGen.Moved) return couleurs.Moved.Brush;
                    switch (tv.SelectedMotif)
                    {
                        case selectedCoeff.none:
                        case selectedCoeff.noCoeff: return couleurs.Next.Brush;
                        case selectedCoeff.main: return couleurs.nextByCoeffMain.Brush;
                        case selectedCoeff.min: return couleurs.nextByCoeffMin.Brush;
                    }

                }
                return couleurs.NextAbsent.Brush;
            }
            return Brushes.Transparent; 
        }

        public static SolidColorBrush getColor0(TrackListViewModel tv, TrackColor couleurs)
        {

            var c = getcolor00(tv, couleurs);
            if (c != Brushes.Transparent)
                return c; 

            if (tv.IsSelected) return couleurs.Selected.Brush;
            if (tv.PieceGen.AlmostFree) return couleurs.AlmostFree.Brush;
            if (tv.PieceGen.AlmostFree1) return couleurs.AlmostFree1.Brush; 
            if (tv.PieceGen.Empeached1) return couleurs.Empeached1.Brush;
            if (tv.PieceGen.Empeached) return couleurs.Empeached.Brush;
            if (tv.PieceGen.Moved) return couleurs.Moved.Brush;

            exportState es = tv.ExportStatus;
            if (!tv.Exists)
                es = exportState.miss;
            var exp = couleurs.export;
            switch (es)
            {
                case exportState.none: return exp.none.Brush; // Brushes.White;
                case exportState.miss: return exp.miss.Brush;                //return Brushes.LightGray;
                case exportState.present: return exp.present.Brush; // return Brushes.White;
                case exportState.copy: return exp.copy.Brush; //return Brushes.LightGreen;
                case exportState.delete: return exp.delete.Brush; //return Brushes.DarkGray;
                default:
                    break;
            }

            return Brushes.Transparent;
        }

        public static SolidColorBrush getColor(TrackListViewModel tv, TrackColor couleurs)
        {
            if (tv.IsSelected) return couleurs.Selected.Brush;
       
            return getColor0(tv, couleurs);
        }

        public static TrackColor getConf(object parameter)
        {
            var conf = Couleurs.Instance.general.track;
            if (parameter != null)
            {
                string path = parameter.ToString();
                var _c = Couleurs.get(path);

                TrackColor _conf = null;

                if (_c is TrackColor)
                    _conf = _c as TrackColor;
                else
                {
                    if (_c is General)
                    {
                        _conf = (_c as General).track;
                    }
                }


                if (_conf != null)
                    conf = _conf;
            }

            return conf;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = getConf(parameter);

                return getColor(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class ForeColorFormatConverter : BaseConverter, IValueConverter
    {
        public SolidColorBrush getColor(TrackListViewModel tv, object parameter)
        {
            //if (tv.PieceGen.IsNext && tv.IsSelected)
            //{
            //    var conf = BgColorFormatConverter.getConf(parameter);
            //    return BgColorFormatConverter.getColor0(tv, conf);
            //}
            if (tv.IsSelected) return Brushes.White;
            return Brushes.Black;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                return getColor(tv, parameter);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(FontWeights))]
    public class FontConverter : BaseConverter, IValueConverter
    {

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                if (tv.IsSelected && tv.PieceGen.IsNext)
                    return FontWeights.Bold;
                return FontWeights.Normal; 

            }
            catch
            {

            }
            return FontWeights.Normal; 
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(ihmInDispo), typeof(Brush))]
    public class ColorDispoConverter : BaseConverter, IValueConverter
    {
        private SolidColorBrush getColor(ihmInDispo info)
        {

            switch (info)
            {
                case ihmInDispo.none: return Brushes.Transparent;
                case ihmInDispo.rot: return Brushes.Gainsboro;
                case ihmInDispo.stat: return Brushes.LightSlateGray;
                default:
                    break;
            }
            return Brushes.White;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                ihmInDispo info = (ihmInDispo)value;
                return getColor(info);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(bool), typeof(System.Windows.Visibility))]
    public class BoolToVis : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is bool)
            {
                return (bool)value ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
            }
            return null;

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (System.Windows.Visibility.Visible.Equals(value)) return true;
            if (System.Windows.Visibility.Collapsed.Equals(value)) return false;
            return null;

        }
    }
    [ValueConversion(typeof(medianneMode), typeof(int))]
    public class SortModeConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is medianneMode)
            {
                return (int)value;
            }
            return null;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                return (medianneMode)(int)(value);
            }
            return null;
        }
    }

    [ValueConversion(typeof(DateTime?), typeof(string))]
    public class DateConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return null;

            if (value is DateTime)
            {
                if (DateTime.MinValue.Equals(value) || DateTime.MaxValue.Equals(value))
                    return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {

            return null;
        }
    }


    [ValueConversion(typeof(selectedCoeff), typeof(string))]
    public class SelectedMotifConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return null;

            if (value is selectedCoeff)
            {
                var motif = (selectedCoeff)value;
                switch (motif)
                {
                    case selectedCoeff.none: return "";
                    case selectedCoeff.noCoeff: return "no";
                    default:
                        return motif.ToString();

                }

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {

            return null;
        }
    }







}
]]></content>
  </file>
  <file path="\pdb.util\FileRegister.cs">
    <content><![CDATA[using System.IO;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace pdb.util
{
    public class FileRegister
    {
        private static FileRegister _instance = new FileRegister();
        private BgDictString0<FileValue> dict = new BgDictString<FileValue>();
        private BgDictString0<DirValue> dirs = new BgDictString<DirValue>();

        public static void init(BgDictString0<FileValue> dict)
        {
            _instance.dict = dict;
        }


        private DirValue checkDir(FileInfo fmusic)
        {
            var dir = fmusic.Directory;
            if (dirs.ContainsKey(dir.FullName))
                return dirs[dir.FullName];
            var dirV = new DirValue(fmusic);
            dirs.Add(dirV.FullName, dirV);
            return dirV;
        }

        private DirValue checkDir(string fmusic)
        {
            var dir = Path.GetDirectoryName(fmusic); 
            if (dirs.ContainsKey(dir))
                return dirs[dir];
            var dirV = new DirValue(fmusic);
            dirs.Add(dirV.FullName, dirV);
            return dirV;
        }

        public static DirValue CheckDir(FileInfo fmusic)
        {
            return _instance.checkDir(fmusic);
        }

        public static DirValue CheckDir(string fmusic)
        {
            return _instance.checkDir(fmusic);
        }


        private FileValue check(FileInfo infos)
        {
            if (!dict.ContainsKey(infos.FullName))
            {
                bool _exists = false;
                string fullName = "";

                long length = 0;
                try
                {

                    _exists = infos.Exists;
                    fullName = infos.FullName;



                    if (_exists)
                        length = infos.Length;

                }
                catch { }
                var value = new FileValue(fullName, length, _exists);
                dict.Add(fullName, value);
                return value;
            }

            return dict[infos.FullName];
        }

        private FileValue check(string location)
        {
            if (!dict.ContainsKey(location))
            {
                bool _exists = false;
                string fullName = "";

                long length = 0;
                try
                {

                    FileInfo infos = new FileInfo(location);
                    _exists = infos.Exists;
                    fullName = infos.FullName;

                    //DirectoryInfo dir = infos.Directory;
                    //dirAndFileName = dir.Name + Path.DirectorySeparatorChar + infos.Name; 

                    if (_exists)
                        length = infos.Length;

                }
                catch { }
                var value = new FileValue(fullName, length, _exists);
                dict.Add(location, value);
                return value;
            }
            return dict[location];
        }

        private FileValue delete(string location)
        {
            var value = check(location);
            value.delete();
            return value;

        }

        public static FileValue Check(FileInfo f)
        {
            return _instance.check(f);
        }

        public static FileValue Check(string location)
        {
            return _instance.check(location);
        }

        public static bool Exist(string location)
        {
            return _instance.check(location).Exists;
        }
        public static string FullName(string location)
        {
            return _instance.check(location).FullName;
        }
        public static long Length(string location)
        {
            return _instance.check(location).Length;
        }
        public static FileValue Delete(string location)
        {
            return _instance.delete(location);
        }


    }


    public class FileValue
    {
        public readonly string FullName;
        private bool _exists;
        public long Length;
        //public readonly string DirAndFileName;
        public FileValue(string fullName, long length, bool exists)
        {
            this.FullName = fullName;
            // this.DirAndFileName = dirAndFileName; 
            this.Length = length;
            this._exists = exists;
        }

        public bool Exists { get { return _exists; } }
        public override string ToString()
        {
            return string.Format("{0} {1} {2}", Exists, FullName, Length);
        }

        public void delete() { _exists = false; }
        public void copy(long length)
        {
            _exists = true;
            Length = length;
        }

        public override bool Equals(object obj)
        {
            var o = obj as FileValue;
            if (o == null) return false;
            return FullName == o.FullName; //&& Exists == o.Exists;
        }
        public override int GetHashCode()
        {
            return FullName.GetHashCode(); // +Length.GetHashCode();
        }
    }

    public class DirValue
    {
        private bool _exists;
        public readonly string FullName;
        public readonly List<FileValue> imgs = new List<FileValue>();
        public DirValue(FileInfo f)
        {

            var dir = f.Directory;
            FullName = dir.FullName;
            init(dir); 
            _exists = true; 
        }
        private void init(DirectoryInfo dir)
        {
            imgs.Clear();
            foreach (FileInfo ff in dir.GetFiles())
            {
                if (ff.IsImage())
                {
                    var fff = FileRegister.Check(ff);
                    imgs.Add(fff);
                }
            }

        }

        public DirValue(string path)
        {
            FullName = Path.GetDirectoryName(path);
            _exists = Directory.Exists(FullName);
            if (_exists)
                init(new DirectoryInfo(FullName)); 
        }

        public bool Exist { get { return _exists; } set { _exists = value; } }
    }


}
]]></content>
  </file>
  <file path="\pdb.util\FileType.cs">
    <content><![CDATA[
using System.IO;
using System;
namespace pdb.util
{
    public enum FileType : short
    {
        none =-100,
        jpg = -10,
        png = -11,
        tif = -12,
        tiff = -13,
        gif= -14,
       
        unknown = -1,
        mp3 = 1,
        mp4 = 2,
        wma = 3,
        m4v = 4,
        m4a = 6,
        ogg = 8,
        aac = 10,       
        wav = 11,
        flac=30
    }

    public enum listMode
    {
        substract,
        rapport,
        logPure,
        log,
        logAbs,
        linear

    }

    public static class FileTypeUtil
    {
        public static string ext(this FileInfo file)
        {
            return file.Extension.ToLower().Replace(".",""); 
        }

        public static FileType type(this FileInfo file)
        {
            try
            {
                return (FileType)Enum.Parse(typeof(FileType), file.ext()); 
            }
            catch 
            {
                return FileType.unknown; 
            }
        }

        public static FileType type(this string file)
        {
            string ext = Path.GetExtension(file).Replace(".", "").ToLower();

            try
            {
                return (FileType)Enum.Parse(typeof(FileType),ext);
            }
            catch
            {
                return FileType.unknown;
            }
        }

        public static bool isMusic(this string file)
        {
            return file.type().typeMusic(); 
        }

        public static bool typeImg(this FileType type)
        {
            return (int)type <= -10; 
        }

        public static bool typeMusic(this FileType type)
        {
            return (int)type > 0;
        }

        public static bool IsImage(this FileInfo file)
        {
            return file.type().typeImg(); 
        }

        public static bool IsMusic(this FileInfo file)
        {
            return file.type().typeMusic();
        }

    }


}

]]></content>
  </file>
  <file path="\pdb.util\misc.cs">
    <content><![CDATA[using System;
using System.IO;
using System.Threading;

namespace pdb.util
{
    /// <summary>
    /// utilitaires divers
    /// </summary>
    /// <remarks></remarks>
    public static class misc
    {
        const int K = 1024;
        public static void gcCollect(string org)
        {

            DateTime now = DateTime.Now;
            long mem0 = GC.GetTotalMemory(false);
            GC.Collect();
            long mem1 = GC.GetTotalMemory(false);

            var _mem0 = mem0.HumanReadableSize(-1);
            var _mem1 = mem1.HumanReadableSize(-1);
            var delta = (mem0 - mem1).HumanReadableSize(-1);

            misc.log("GC.Collect " + org + " " + _mem0 + " " + _mem1 + " (" + delta + ") " + (DateTime.Now - now).TotalMilliseconds.ToString("0"));
        }
        private static ILogger logger = new DefaultLogger();
        private static getDefaultLogger _getDefaultLogger;
        //public static void init(ILogger a_logger)
        //{
        //    logger = a_logger;
        //    //if (logger is Logger)
        //    //    Logger.init();
        //}

        public static void init(getDefaultLogger getDefaultLogger)
        {
            _getDefaultLogger = getDefaultLogger;
        }

        public static void init(ILogger logger)
        {
            misc.logger = logger;
        }

        public static string Pre { set { Logger.Pre = value; } }

        private static ILogger Logger
        {
            get
            {
                if (logger is DefaultLogger && _getDefaultLogger != null)
                    logger = _getDefaultLogger();
                return logger;
            }
        }


        public static void logNoDate(String txt)
        {
            Logger.logNoDate(txt);
        }

        public static void log(string txt, params object[] other)
        {
            Logger.log(txt, other);
        }

        public static void log(string txt)
        {
            Logger.log(txt);
        }

        public static void logError(string txt, Exception ex)
        {
            log("[Error] " + txt + " " + ex.ToString());
        }

        public static void logWarn(string txt)
        {
            log("[Warn] " + txt);
        }

        public static string moveTree(this FileInfo org, String dest, bool? overWrite)
        {
            return tree(org, dest, true, overWrite);
        }

        public static string copyTree(this FileInfo org, String dest, bool? overWrite)
        {
            return tree(org, dest, false, overWrite);
        }

        public static string copyTree(this FileValue org, String dest, bool? overWrite)
        {
            var fi = new FileInfo(org.FullName); 
            return tree(fi, dest, false, overWrite);
        }

        public static string copyWithImg(this FileValue org, string dest)
        {
            var fi = new FileInfo(org.FullName);
            var dirSource = FileRegister.CheckDir(fi);
            //var dirDest = FileRegister.CheckDir(dest);
            foreach (FileValue img in dirSource.imgs)
            {
                var fdest = string.Format("{0}\\{1}", Path.GetDirectoryName(dest), Path.GetFileName(img.FullName));
                var fv = FileRegister.Check(fdest);
                if (!fv.Exists)
                    copyTree(new FileInfo(img.FullName), fv.FullName, null); 

            }

            return tree(fi, dest, false, null); 

             
        }

        public static string getShortPath(this string path, params string[] keywords)
        {

            string[] dirs = path.Split(Path.DirectorySeparatorChar);
            int found = 0;
            int count = dirs.GetLength(0);
            foreach (string key in keywords)
            {
                for (int i = count - 2; i > 0; i--)
                {
                    var s = dirs[i].ToLower();
                    if (string.IsNullOrEmpty(s))
                        continue;

                    if (key.Equals(s))
                    {
                        found = i;
                        break;
                    }
                }
                if (found > 0)
                    break;
            }


            var sb = new StringBuilder();
            var begin = false;
            for (int i = found + 1; i < count; i++)
            {
                var s = dirs[i];
                if (string.IsNullOrEmpty(s))
                    continue;
                if (begin)
                {
                    sb.Append(Path.DirectorySeparatorChar);
                }
                begin = true;
                sb.Append(s);
            }
            return sb.ToString();
        }


        private static string tree(FileInfo org, String dest, bool deleteOrg, bool? overwrite)
        {
            string newDest = dest;
            String[] dirs = dest.Split(Path.DirectorySeparatorChar);

            int i = 0;
            DirectoryInfo root = new DirectoryInfo(dirs[0] + Path.DirectorySeparatorChar);
            for (i = 1; i < dirs.GetLength(0) - 1; i++)
            {
                String strDir0 = dirs[i] + Path.DirectorySeparatorChar;
                String StrDir = root.FullName + strDir0;
                DirectoryInfo dir = new DirectoryInfo(StrDir);
                if (!dir.Exists)
                {
                    misc.log("création répertoire {0}", dir.FullName); 
                    dir.Create();
                    try
                    {
                        File.SetAttributes(dir.FullName, File.GetAttributes(dir.FullName) & ~FileAttributes.ReadOnly);
                        //dir.Attributes &= ~FileAttributes.ReadOnly;
                    }
                    catch (Exception ea)
                    {
                        //   log("impossible de poser les attributs de répertoire " +ea.ToString()); 
                    }

                }
                root = dir;
            }
            //object o;

            FileInfo orgg = new FileInfo(org.FullName);
            var f = FileRegister.Check(dest);
            if (overwrite == null)
            {

                if (f.Exists)
                    return newDest;
                var d = org.CopyTo(dest, false);
                f.copy(d.Length);

            }
            else if (overwrite.Value)
            {
                var d = org.CopyTo(dest, true);
                f.copy(d.Length);
            }
            else
            {
                if (f.Exists)
                {
                    var d = org.CopyTo(dest, false);
                    f.copy(d.Length);
                }
                else
                {
                    int index = 1;
                    string fdest = Path.GetDirectoryName(dest) + Path.DirectorySeparatorChar + Path.GetFileNameWithoutExtension(dest);
                    string ext = Path.GetExtension(dest);


                    newDest = fdest + "_" + index + ext;
                    var newf = FileRegister.Check(newDest);
                    while (newf.Exists)
                    {
                        index++;
                        newDest = fdest + index + ext;
                        newf = FileRegister.Check(newDest);
                    }
                    var d = org.CopyTo(newDest, false);
                    newf.copy(d.Length);

                }
            }
            try
            {
                File.SetAttributes(newDest, File.GetAttributes(newDest) & ~FileAttributes.ReadOnly);
            }

            catch (Exception ea2)
            {
                // log("impossible de poser les attributs de fichier " + ea2.ToString());
            }



            if (deleteOrg)
            {
                org.Delete();
                FileRegister.Check(org.FullName).delete();
            }
            DirectoryInfo current = orgg.Directory;

            while (current.GetFileSystemInfos().GetLength(0) == 0)
            {
                DirectoryInfo parent = current.Parent;
                current.Delete();
                current = parent;
            }

            return newDest;
        }

        //public static void deleteFile(string path)
        //{
        //}

        public static void deleteFile(string path, string desc)
        {
            var file = FileRegister.Check(path);
            if (!file.Exists)
            {
                log("fichier {0} non présent", desc);
                return;
            }
            var fi = new FileInfo(path);
            log("suppr\t{0}", desc);
            fi.Delete();
            file.delete();

            DirectoryInfo current = fi.Directory;

            while (current.GetFileSystemInfos().GetLength(0) == 0)
            {
                DirectoryInfo parent = current.Parent;
                log("suppression répertoire {0}", current.FullName);
                current.Delete();
                current = parent;
            }


        }

        public static void deleteWithImg(string path, string desc)
        {
            var file = FileRegister.Check(path);
            if (!file.Exists)
            {
                log("fichier {0} non présent", desc);
                return;
            }
            var fi = new FileInfo(path);
            log("suppr\t{0}", desc);
            fi.Delete();
            file.delete();

            DirectoryInfo current = fi.Directory;

            while (true)
            {
                bool _continue = true; 
                foreach (FileInfo f in current.GetFiles())
                {
                    if (f.IsMusic())
                    {
                        _continue = false;
                        break; 
                    }
                }
                if (!_continue)
                    break;

                foreach (FileInfo f in current.GetFiles())
                {
                    log("suppr\t{0}", f.FullName);
                    f.Delete(); 
                }

                if (current.GetFileSystemInfos().GetLength(0) > 0)
                    break;

                DirectoryInfo parent = current.Parent;
                log("suppression répertoire {0}", current.FullName);
                current.Delete();
                current = parent;


            }

         
        }


        public static void DeleteDir(DirectoryInfo dir)
        {
            Console.WriteLine("DeleteDir " + dir.FullName);
            try
            {
                if (!dir.Exists)
                    return;
                foreach (FileInfo file in dir.GetFiles())
                {
                    try
                    {
                        file.Delete();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("impossible de supprimer " + file.FullName + " " + ex);
                    }
                }
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    DeleteDir(sub);
                try
                {
                    dir.Delete();
                }
                catch (Exception edelDir)
                {
                    Console.WriteLine("impossible de supprimer en final " + dir.FullName + " " + edelDir.Message);
                }
            }
            catch (Exception exd)
            {
                Console.WriteLine("impossible de supprimer " + dir.FullName + " " + exd);
            }
        }




    }
}]]></content>
  </file>
  <file path="\pdb.util\pdb.util.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.util</RootNamespace>
    <AssemblyName>pdb.util</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Debug\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.util.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AsyncFileWriter.cs" />
    <Compile Include="BgDict.cs" />
    <Compile Include="Chrono.cs" />
    <Compile Include="CustomFormat.cs" />
    <Compile Include="CUtil.cs" />
    <Compile Include="DateUtil.cs" />
    <Compile Include="DecimalIndex.cs" />
    <Compile Include="DescBuilder.cs" />
    <Compile Include="Dict.cs" />
    <Compile Include="FileRegister.cs" />
    <Compile Include="FileType.cs" />
    <Compile Include="Generic\Attributs\AttributeHelper.cs" />
    <Compile Include="Generic\Attributs\CustomAttribute.cs" />
    <Compile Include="Generic\Attributs\Db\DbAttributes.cs" />
    <Compile Include="Generic\Attributs\Db\SbAttributes.cs" />
    <Compile Include="Generic\Attributs\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Json\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\NameAttributeBase.cs" />
    <Compile Include="Generic\Attributs\Sp\GlobalAttributes.cs" />
    <Compile Include="Generic\Attributs\Xml\XmlAttributes.cs" />
    <Compile Include="Generic\Encode\Getters.cs" />
    <Compile Include="Generic\Encode\JSON.cs" />
    <Compile Include="Generic\Encode\JsonEncoder.cs" />
    <Compile Include="Generic\Encode\JsonParser.cs" />
    <Compile Include="Generic\Encode\JsonSerializer.cs" />
    <Compile Include="Generic\Encode\JsonXmlEncoder.cs" />
    <Compile Include="Generic\Encode\SafeDictionary.cs" />
    <Compile Include="Generic\INode.cs" />
    <Compile Include="Generic\MappingException.cs" />
    <Compile Include="Generic\Parse\DbParser.cs" />
    <Compile Include="Generic\Parse\DbWrapper.cs" />
    <Compile Include="Generic\Parse\JsonParser.cs" />
    <Compile Include="Generic\Parse\Json\JsonBuilder.cs" />
    <Compile Include="Generic\Parse\Json\JsonParseException.cs" />
    <Compile Include="Generic\Parse\Json\JsonState.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateDeuxPoints.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateFinal.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateName.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValue.cs" />
    <Compile Include="Generic\Parse\Json\JsonStateValueIni.cs" />
    <Compile Include="Generic\Parse\Json\JsonWrapper.cs" />
    <Compile Include="Generic\Parse\Node.cs" />
    <Compile Include="Generic\Parse\Parser.cs" />
    <Compile Include="Generic\Parse\ParserBase.cs" />
    <Compile Include="Generic\Parse\XmlParser.cs" />
    <Compile Include="Generic\Parse\XmlSerializer.cs" />
    <Compile Include="Generic\Parse\XmlWrapper.cs" />
    <Compile Include="Generic\TypeInfo.cs" />
    <Compile Include="Generic\Utils.cs" />
    <Compile Include="Generic\XmlParser.cs" />
    <Compile Include="Generic\XmlSerializer.cs" />
    <Compile Include="list\DictList.cs" />
    <Compile Include="DictLocation.cs" />
    <Compile Include="DisposableCounter.cs" />
    <Compile Include="FileUtil.cs" />
    <Compile Include="HashList.cs" />
    <Compile Include="ILogger.cs" />
    <Compile Include="list\LinkedList.cs" />
    <Compile Include="list\SequentialDict.cs" />
    <Compile Include="list\SequentialDictString.cs" />
    <Compile Include="Locker.cs" />
    <Compile Include="Logger.cs" />
    <Compile Include="LoggerConsole.cs" />
    <Compile Include="Math.cs" />
    <Compile Include="Medianne.cs" />
    <Compile Include="MemUtil.cs" />
    <Compile Include="misc.cs" />
    <Compile Include="OutputRecorder.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Queue.cs" />
    <Compile Include="serialize\Serializer.cs" />
    <Compile Include="serialize\TextSerializer.cs" />
    <Compile Include="StringUtil.cs" />
    <Compile Include="TextWriter.cs" />
    <Compile Include="ThreadUtil.cs" />
    <Compile Include="TimeSpan.cs" />
    <Compile Include="TuningBase.cs" />
    <Compile Include="XMLTool.cs" />
    <Compile Include="ZipUtil.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\Piece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace pdb.gen
{
    public enum infoMedianne : short
    {
        none = 0,
        med = 1,
        medLight = 2,
        border = 4,
        borderEff = 8,
        borderMin = 16
    }
    /// <summary>
    /// Ajout de données utiles Ranq
    /// </summary>
    public class Piece : ITrackMetaData, IFile, ITrackNativeDates, IEnumerable<Piece>
    {
        private ITrackNativeDates track;
        public bool Virtual { get { return PieceId < 0; } }
        public virtual bool VirtualByArtist { get { return false; } }
        // private String className = "";
        private static CultureInfo en = new CultureInfo("en-US");
        //  private static List<displayCategory> minCategories;

        protected static Consolid gen;
        public static Consolid Gen { set { gen = value; } }

        static Piece()
        {
            //   minCategories = new List<displayCategory> { displayCategory.rankTime, displayCategory.timeValue, displayCategory.dates, displayCategory.pertinentDates };
        }

        public ITrackNativeDates Track { get { return track; } }

        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank
        {
            get
            {
                if (parent == null)
                    return m_rank;
                return parent.m_rank;
            }
        }

        private infoMedianne _infoMedianne;
        public void eraseInfoMedianne() { _infoMedianne = infoMedianne.none; }
        public infoMedianne InfoMedianne { get { return _infoMedianne; } }
        public bool Medianne
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.med);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Medianne)
                    return;
                _infoMedianne |= infoMedianne.med;
            }
        }
        public bool MedianneLight
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.medLight);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (MedianneLight)
                    return;
                _infoMedianne |= infoMedianne.medLight;
            }
        }

        public bool Border
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.border);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (Border)
                    return;
                _infoMedianne |= infoMedianne.border;
            }
        }

        public bool BorderEffect
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderEff);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderEffect)
                    return;
                _infoMedianne |= infoMedianne.borderEff;
            }
        }

        public bool BorderMin
        {
            get
            {
                return _infoMedianne.HasFlag(infoMedianne.borderMin);
            }

            set
            {
                if (!value)
                    throw new ApplicationException();
                if (BorderMin)
                    return;
                _infoMedianne |= infoMedianne.borderMin;
            }
        }


        public virtual void initRank()
        {
            //  _classementCache = null; 
            //_infoMedianne = infoMedianne.none;
            // _classementProvisoireRecent = null;

            // _lnClassement = int.MinValue; 
            Rank.init();
        }

        public int QRank
        {
            get { return Rank.Quality; }
            set { Rank.Quality = value; }
        }

        public int LRank
        {
            get { return Rank.Lenght; }
            set { Rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return Rank.Twice; }
            set { Rank.Twice = value; }
        }

        public int RankAllAlbum
        {
            get { return m_rank.RankAllAlbum; }
            set { m_rank.RankAllAlbum = value; }
        }

        public int RankAlbum { get { if (album == null) return 0; return album.Rank.Sort; } }

        public bool AlbumAbsent { get { if (album == null) return true; return album.Absent; } }

        //public int nbInAlbum(exportState state ) { if (album == null) return -1; return album.nbInAlbum(state);  }
        public int NbExportPresents { get { if (album == null) return -1; return album.NbExportPresents; } }

        //public bool SameAlbum(Piece x)
        //{
        //    if (x == null)
        //        return false; 
        //    return album == x.album; 
        //}

        public int IndexExport { get { if (album == null) return -1; return album.IndexExport(this); } }

        //  public TuningData TuningData { get { return m_rank.Rest; } set { m_rank.Rest = value; } }
        #endregion



        public bool FirstClass { get { return track.FirstClass; } set { track.FirstClass = value; } }
        private Album album;

        public Album PieceAlbum { get { return album; } set { album = value; } }
        public int StackValue { get { if (album == null) return 0; return album.StackValue; } }
        public int StackIndex { get { if (album == null) return 0; return album.StackIndex; } }
        public bool Moved { get { if (album == null) return false; return album.Moved && this == album.Next; } set { if (album != null) album.Moved = value; } }
        public bool Empeached { get { if (album == null) return false; return album.Empeached && this == album.Next; } set { if (album != null) album.Empeached = value; } }
        public bool Empeached1 { get { if (album == null) return false; return album.Empeached1 && this == album.Next; } set { if (album != null) album.Empeached1 = value; } }
        public bool AlmostFree { get { if (album == null) return false; return album.AlmostFree && this == album.Next; } }
        public bool AlmostFree1 { get { if (album == null) return false; return album.AlmostFree1 && this == album.Next; } }
        //private static int _sID = 0;
        //private int _dID;
        internal Piece(ITrackNativeDates track)
        {
            //_sID++;
            //_dID = _sID;
            if (track == null)
                Debugger.Launch();
            this.track = track; initRank();

#if VOL
            int volumeMin = CConf.VolumeMin;
            if (Volume < volumeMin)
                Volume = volumeMin;
#endif
        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList()
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        public String ClassName { get { return track.ClassName; } set { track.ClassName = value; } }

        public void setClassement(string className, int rating)
        {
            if (className == null)
                return;
            track.setClassement(className, rating);
            invalidateCache();

        }
        private static ClassementHash classementHash = new ClassementHash();
        private ClassementCache _classementCache;
        private ClassementCache ClassementCache
        {
            get
            {


                if (_classementCache == null)
                {
                    if (parent != null)
                        _classementCache = parent.ClassementCache;
                    if (_classementCache == null)
                        _classementCache = classementHash.getCache(track.ClassName, track.Rating);
                }
                return _classementCache;
            }
        }
        public virtual void invalidateCache()
        {

            //_classNameAndRating = null;
            //_classementValueDecimal = -1;
            //_rapportClassement = -1;
            //  _classementProvisoireRecent = null;

            if (parent != null)
                parent.invalidateCache();
            else
            {
                _classementCache = null;
                foreach (Piece p in childs)
                {
                    p._classementCache = null;
                }
            }


        }

        //public bool belongsTo(string a_list)
        //{
        //    foreach (CPlayList l_pl in track.PLayLists)
        //    {
        //        if (l_pl.isSubList(a_list))
        //            return true;
        //    }
        //    return false;
        //}

        #region CPieceComparer compatibilité
        public List<CPlayList> ClassPlayLists
        {
            get { return track.ClassPlayLists; }
        }
        /// <summary>
        /// ClassList principale
        /// </summary>
        public CPlayList ClassPlayList
        {
            get
            {
                List<CPlayList> classLists = track.ClassPlayLists;
                if (classLists.Count > 0)
                    return classLists[0];
                return null;
            }
        }


        public int RatingCmp
        {
            get
            {
                int rating = track.Rating;
                if (rating < 0)
                    return 0;
                return rating;
            }
        }
        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return ClassName.isInteger();
            }
        }

        // private string _classNameAndRating;
        public String ClassNameAndRating
        {
            get
            {
                return ClassementCache.ClassNameAndRating;
            }
        }

        // private decimal _classementValueDecimal = -1;
        public decimal ClassementValueDecimal
        {
            get
            {
                return ClassementCache.ClassementValueDecimal;
            }
        }
        //private double _classementValue = -1; 
        //public double ClassementValue
        //{
        //    get
        //    {
        //        if (_classementValue == -1)
        //        {
        //            if (!isClassListNumeric)
        //                _classementValue = 0;
        //            else
        //            {
        //                string classNameAndRating = ClassNameAndRating.Insert(1, ",");
        //                _classementValue= Convert.ToDouble(classNameAndRating);
        //            }
        //        }

        //        return _classementValue; 
        //    }
        //}

        public static decimal getRapport(decimal base6)
        {
            string str = base6.ToString("0.######").Replace(",", "");
            return getRapport(str);
        }

        public static decimal getRapport(string classNameAndRating)
        {
            decimal resultat = 0m;
            char[] tab = classNameAndRating.ToCharArray();

            decimal K = 1;
            int count = tab.GetLength(0);


            for (int i = 0; i < count; i++)
            {
                K = K * 6;
                int c = Convert.ToInt32(tab[i].ToString());
                resultat += (decimal)c / K;
            }

            return resultat;
        }

        // private decimal _rapportClassement = -1;
        public decimal RapportClassement
        {
            get
            {
                return ClassementCache.RapportClassement;
                //if (parent != null)
                //    return parent.RapportClassement;
                //if (_rapportClassement != -1)
                //    return _rapportClassement;

                //decimal resultat = 0;
                //try
                //{
                //    return getRapport(ClassNameAndRating);
                //}
                //catch
                //{
                //}
                //_rapportClassement = resultat;
                //// _classementVirtuel = resultat; 
                //return _rapportClassement;
            }
        }


        //private decimal _lnClassement = -1;
        //public decimal LnClassement
        //{
        //    get
        //    {
        //        if (_lnClassement == int.MinValue)
        //        {
        //            var rapport = RapportClassement;
        //            if (rapport <= 0m)
        //                _lnClassement = 0m;
        //            else
        //                _lnClassement = Math.Log10(rapport) + 10;
        //        }
        //        return _lnClassement; 
        //    }
        //}
        static int NB_DEC = 4;
        public static string getReadableCl(string str)
        {
            int count = str.Length;
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {
                        if (i >= NB_DEC)
                        {
                            i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();
        }

        public static string getClassementEquiv(decimal valRapport)
        {
            if (valRapport < 0)
                return "";
            if (valRapport == 0m)
                return "0";
            decimal v = 0;
            decimal r = valRapport;
            StringBuilder sb = new StringBuilder();
            int _ok = Int16.MaxValue;

            for (int i = 0; i < 13; i++)
            {
                v = 6 * r;
                int a = (int)(v + 0.0001m);
                if (a > 0 && i < _ok)
                {
                    _ok = i;
                }
                r = v - a;
                if (r < 0)
                    r = 0;
                sb.Append(a);


                if (i >= _ok + 4)
                    break;
            }
            var str = sb.ToString();
            str = str.Insert(str.Length - 1, ".");
            return getReadableCl(str);
        }




        public decimal RapportClassementDecimal
        {
            get
            {
                if (parent != null)
                    return parent.RapportClassementDecimal;
                decimal resultat = 0;
                try
                {
                    string str = ClassNameAndRating;
                    char[] tab = str.ToCharArray();

                    decimal K = 1m;
                    int count = tab.GetLength(0);


                    for (int i = 0; i < count; i++)
                    {
                        K = K * 6;
                        int c = Convert.ToInt32(tab[i].ToString());
                        resultat += (decimal)c / K;
                    }
                }
                catch
                {
                }
                return resultat;
            }
        }

        public int classPrecision()
        {
            string classNameAndRating = ClassNameAndRating;
            int precision = 0;
            char[] tab = classNameAndRating.ToCharArray();
            int count = tab.GetLength(0);

            int iIndexDepart = -1;
            int iIndexFin = -1;
            for (int i = 0; i < count; i++)
            {
                Char c = tab[i];
                if (iIndexDepart < 0)
                {
                    if (c != '0')
                        iIndexDepart = i;
                }

                if (c != '0')
                    iIndexFin = i;
            }

            precision = iIndexFin - iIndexDepart + 1;

            return precision;
        }
        #endregion

        #region compatibilité CList
        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackIdentity other)
        //{
        //    //return track.Location == other.Location; 
        //    String location = track.Location;
        //    return (location.Equals((other.Location)) || CUtil.DefinedEquals(track.Artist, track.Album, track.Name, track.TrackNumber, other.Artist, other.Album, other.Name, other.TrackNumber));
        //}
        #endregion

        #region ITrackNative Membres

        public string Artist
        {
            get
            {
                return track.Artist;
            }
            set
            {
                if (track.Artist != value)
                {
                    try
                    {
                        //                 misc.log("change artist from '{0}' to'{1}'", track.Artist, value);
                        track.Artist = value;
                    }
                    catch { misc.log("unable to change artist {0}  {1}", track.Artist, value); }
                }
            }
        }

        public virtual string Album
        {
            get
            {
                return track.Album;
            }
            set
            {
                if (track.Album != value)
                {
                    try
                    {
                        //                   misc.log("change Album from '{0}' to'{1}'", track.Album, value);
                        track.Album = value;
                    }
                    catch { misc.log("unable to change album {0}  {1}", track.Album, value); }
                }
            }
        }

        public string Name
        {
            get
            {
                return track.Name;
            }
            set
            {
                if (track.Name != value)
                {
                    try
                    {
                        //                 misc.log("change Name from '{0}' to'{1}'", track.Name, value);
                        track.Name = value;
                    }
                    catch { misc.log("unable to change name {0}  {1}", track.Name, value); }
                }
            }
        }

        public virtual int TrackNumber
        {
            get
            {
                return track.TrackNumber;
            }
            set
            {
                if (track.TrackNumber != value)
                {
                    try
                    {
                        //              misc.log("change TrackNumber from '{0}' to'{1}'", track.TrackNumber, value);
                        track.TrackNumber = value;
                    }
                    catch { misc.log("unable to change TrackNumber {0}  {1}", track.TrackNumber, value); }
                }
            }
        }

        public int Rating
        {
            get
            {
                return track.Rating;
            }
            set
            {
                if (track.Rating != value)
                {
                    try
                    {
                        //                misc.log("change Rating from '{0}' to'{1}'", track.Rating, value);
                        track.Rating = value;
                    }
                    catch { misc.log("unable to change Rating {0}  {1}", track.Rating, value); }
                }
            }
        }

        public int Year
        {
            get
            {
                return track.Year;
            }
            set
            {
                if (track.Year != value)
                {
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Year = value;
                    }
                    catch { misc.log("unable to change Year {0}  {1}", track.Year, value); }
                }
            }
        }

#if VOL
        public int Volume
        {
            get
            {
                int volumeMin = CConf.VolumeMin;
                int trackVolume = track.Volume;
                if (trackVolume < volumeMin)
                {
                    Volume = volumeMin;
                }
                return trackVolume;
            }
            set
            {
                if (track.Volume != value)
                {
                    int volumeMin = CConf.VolumeMin;
                    int _value = Math.Max(value, volumeMin);
                    try
                    {
                        //         misc.log("change Year from '{0}' to'{1}'", track.Year, value);
                        track.Volume = _value;
                    }
                    catch { misc.log("unable to change Volume {0}  {1}", track.Volume, _value); }
                }
            }
        }
#endif

        public string Comment
        {
            get
            {
                //if (string.IsNullOrEmpty(track.Comment))
                //    gen.writeComment(this);
                return track.Comment;
            }
            set
            {
                //if (track.Comment != value)
                //{
                try
                {
                    //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                    track.Comment = value;
                }
                catch { misc.log("unable to change Comment {0}  {1}", track.Comment, value); }
                //}
            }
        }

        public virtual string Grouping
        {
            get
            {
                if (string.IsNullOrEmpty(track.Grouping))
                {
                    gen.writeGrouping(this);
                }
                return track.Grouping;
            }
            //set
            //{
            //    //if (track.Grouping != value)
            //    //{
            //        try
            //        {
            //            //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
            //            track.Grouping = value;
            //        }
            //        catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
            //    //}
            //}

        }





        public virtual void setGrouping(string value, bool prior)
        {
            try
            {
                //   misc.log("change Comment from '{0}' to'{1}'", track.Comment, value);
                track.setGrouping(value, prior);
            }
            catch { misc.log("unable to change Grouping {0}  {1}", track.Grouping, value); }
        }

        public bool Enabled
        {
            get
            {
                return track.Enabled;
            }
            set
            {
                if (track.Enabled != value)
                {
                    try
                    {
                        //      misc.log("change Enabled from '{0}' to'{1}'", track.Enabled, value);
                        track.Enabled = value;
                    }
                    catch { misc.log("unable to change Enabled {0}  {1}", track.Enabled, value); }
                }
            }
        }



        public bool isPodcast
        {
            get { return track.isPodcast; }
        }

        public DateTime PlayedDate
        {
            get { return track.PlayedDate; }
        }

        public string Location
        {
            get { return track.Location; }
        }
        public string getLocation()
        {
            return track.getLocation();
        }

        public TimeSpan Duration
        {
            get { return track.Duration; }
            set { track.Duration = value; }
        }

        #endregion

        public List<DateTime> Dates
        {
            get { return track.Dates; }
        }
        public string ArtWork
        {
            get { return track.ArtWork; }
            set { track.ArtWork = value; }
        }

        public DateTime FirstAcces
        {
            get
            {
                var min = DateTime.MaxValue;
                foreach (DateTime dt in Dates)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt; 
                }
                foreach (DateTime dt in DatesClassementBrut)
                {
                    if (dt < min && dt > DateTime.MinValue)
                        min = dt;
                }

                return min;  
            }
        }

        public DateTime Added
        {
            get
            {
                return track.Added; 
            }
        }

        public virtual DateTime AlbumAdded
        {
            get
            {
                return album.AlbumAdded; 
            }
        }

        public List<DateTime> DatesClassement { get { return track.DatesClassement; } }
        public DateTime? UpdateClassement
        {
            get
            {

                var dc = CalcDate.getLastModif(DatesClassement);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public bool LastClassementRecent
        {
            get
            {

                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > Piece.SeuilProvisoire)
                        return true;
                }
                return false;

            }
        }
        public DateTime? AlbumUpdateClassement
        {
            get
            {
                if (album == null)
                    return null;
                return album.UpdateClassement;
            }
        }

        public DateTime? LastRead
        {
            get
            {

                var dc = CalcDate.getLastModif(Dates);
                if (dc == DateTime.MaxValue || dc == DateTime.MaxValue)
                    return null;
                return dc;
            }
        }

        public DateTime? AlbumLastRead
        {
            get
            {
                if (album == null)
                    return null;
                return album.LastRead;
            }
        }

        public String ClassEvol { get { return track.ClassEvol; } }


        public void writeCommentGrouping()
        {
            var mode = CConf.ConfGen.WriteComment;
            writeComment(mode);
            var modeg = CConf.ConfGen.WriteGrouping;
            writeGrouping(modeg);

        }

        //public List<CPlayList> PLayLists
        //{
        //    get { return track.PLayLists; }
        //}

        /// <summary>
        /// Calculer le commentaire
        /// </summary>
        public void writeComment(writeGrouping mode)
        {
            if (parent != null)
                return;
            if (mode == Tuning.writeGrouping.none)
                return;


            if (mode == Tuning.writeGrouping.mix)
            {
                StringBuilder sbEnd = new StringBuilder();

                sbEnd.Append(ClassName);
                sbEnd.Append(".");
                sbEnd.Append((RatingCmp / 20).ToString());
                sbEnd.Append(ClassEvol);
                string strEnd = sbEnd.ToString();
                string found = "";

                string[] tab = Comment.Split(' ');
                int count = tab.GetLength(0);
                if (count > 0)
                {
                    found = tab[count - 1];
                    if (found.Equals(strEnd))
                        return;
                }
                writeComment(Tuning.writeGrouping.all);
            }

            StringBuilder sb = new StringBuilder();
            //string l_pref = "";
            //string l_str = "";

            string l_strList = ClassName;
            //if (ClassPlayList != null)
            //    l_strList = ClassName;

            ////if (m_classement.Imported)
            ////{
            //if (l_strList != ClassName)
            //{
            //    sb.Append("m (");
            //    sb.Append(ClassName);
            //    sb.Append(") "); 
            //  //  l_pref = "m (" + ClassName + ") ";
            //}
            ////}
            int l_rank = Rank.Twice;

            if (l_rank > 0)
            {
                CTuning.format(sb, l_rank);
                sb.Append(" ");
                //    if (l_rank < 1000)
                //    {
                //        if (CTuning.Total > 1000)
                //        {
                //            l_str += "0";
                //        }
                //        if (l_rank < 100)
                //        {
                //            l_str += "0";
                //            if (l_rank < 10)
                //            {
                //                l_str += "0";
                //            }
                //        }
                //    }


                var r = CTuning.Rapport(Rank.Quality);






                var quality = CConf.Select.Quality;
                //if (quality.Mode != listMode.substract || quality.Exp != 1 || quality.Offset != 0 || CConf.Select.TimePriority != 0)
                //{
                double tx0 = Convert.ToInt32(1000 * r);
                sb.Append(tx0.ToString());
                sb.Append(" ");
                //}

                //  double l_tx = Convert.ToInt32(1000 * CTuning.Calc(m_rank, CConf.Select)); //   RapportNorm(m_rank.Quality, CConf.Sort.Quality));
                var l_tx = CConf.ConfGen.Vie.TotalDays() / CTuning.Calc(m_rank, CConf.Select);
                //  double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
                //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
                //getTx(m_rank.Lenght)
                //     l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();


                sb.Append(l_tx.FormatCustom(3, 4)); //   ToString("G2", en));
                //if (l_tx < 100 || l_tx >= 1000)
                //    sb.Append(l_tx.ToString("G2", en));
                //else
                //    sb.Append(Convert.ToInt64(l_tx).ToString("D", en)); 



                sb.Append(" ");
                var rest = r;

                for (int i = 0; i < 4; i++)
                {
                    var ee = rest * 6.0m;
                    int e = (int)System.Math.Floor(ee);
                    rest = ee - e;
                    sb.Append(e);
                }



                sb.Append(" ");


                //sb.Append(l_tx2.ToString());
                //sb.Append(" ");
                //sb.Append((100 * m_rank.SortValue).ToString("0"));
                //sb.Append(" ");

                //sb.Append(Dates.Count.ToString()); sb.Append(" ");

                //sb.Append(DatesClassement.Count.ToString()); sb.Append(" ");

                //sb.Append(ListSelection.buildListReadOrClassementModified(this).Count.ToString()); sb.Append(" ");

                //   sb.Append((100 * m_rank.TimeRest).ToString("0")); sb.Append(" ");



                sb.Append(l_strList);
                sb.Append(".");
                sb.Append((RatingCmp / 20).ToString());

            }

            sb.Append(ClassEvol);



            Comment = sb.ToString();
            //Comment = l_pref + l_str + ClassEvol;
        }

        public override string ToString()
        {
            return track.ToString();
        }

        public override bool Equals(object obj)
        {
            Piece p = obj as Piece;
            if (p == null)
                return false;
            return PieceId.Equals(p.PieceId);
        }

        private decimal _classementVirtuel;

        public string ClassementVirtuel { get { return Piece.getClassementEquiv(_classementVirtuel); } }
        public decimal VirtualClassement { get { return _classementVirtuel; } }
        public void setClassementVirtuel(decimal virt)
        {
            _classementVirtuel = virt;
        }

        public decimal CoeffVirtuel
        {
            get
            {
                if (_classementVirtuel == 0)
                    return 0;
                return RapportClassement / _classementVirtuel;
            }
        }

        private decimal _classementVirtuel2;

        public string ClassementVirtuel2 { get { return Piece.getClassementEquiv(_classementVirtuel2); } }
        public decimal VirtualClassement2 { get { return _classementVirtuel2; } }
        public void setClassementVirtuel2(decimal virt)
        {
            _classementVirtuel2 = virt;
        }

        public decimal CoeffVirtuel2
        {
            get
            {
                if (_classementVirtuel2 == 0)
                    return 0;
                return RapportClassement / _classementVirtuel2;
            }
        }

        public override int GetHashCode()
        {
            return PieceId.GetHashCode();
        }

        private bool haveToUpdateGrouping = false;
        public void MarkAsUpdateGrouping() { haveToUpdateGrouping = true; }

        public void writeGrouping(writeGrouping writeGrouping)
        {
            var cat = CConf.ConfGen.DisplayCategories;
            //if (!CConf.ConfGen.WithOrder)
            //    cat = minCategories; 
            if (writeGrouping == Tuning.writeGrouping.none)
                return;

            //if (m_rank.Twice <= 0)
            //    return;
            if (haveToUpdateGrouping)
            {
                setGrouping(getGroup(cat), true);
            }

            else if (writeGrouping == Tuning.writeGrouping.mix)
            {
                bool haveToUpdate = false;
                string org = Grouping;
                if (org != null)
                {
                    string[] data = org.Split(' ');

                    try
                    {
                        foreach (datesMode mode in Enum.GetValues(typeof(datesMode))) //  CConf.ConfGen.Modes) //  Enum.GetValues(typeof(datesMode)))
                        {
                            DisplayGrouping found = cat.Find(c => (int)c.category == (int)mode);
                            //displayCategory found = cat.Find(c => (int)c == (int)mode);
                            if (found != null)
                            {
                                int indexOfTime = cat.IndexOf(found);

                                string timeValue = data[indexOfTime];
                                string newValue = getTimeValue(mode, found.mode);
                                if (!newValue.Equals(timeValue))
                                {
                                    haveToUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    catch
                    {
                        haveToUpdate = true;
                    }
                }
                else
                {
                    haveToUpdate = true;
                }
                if (haveToUpdate)
                    setGrouping(getGroup(cat), true);
            }
            else
                setGrouping(getGroup(cat), false);
        }



        private string getTimeValue(datesMode modeDates, timeMode modeTime)
        {
            switch (modeTime)
            {
                case timeMode.simple: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates)).FormatCustomTs(2);
                case timeMode.complex: return (CConf.ConfGen.Vie.TotalDays.toDecimal() * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustomTs(2);
                case timeMode.last:
                case timeMode.equiv:
                case timeMode.equivNorm:
                    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    if (modeTime == timeMode.equivNorm)
                        return ts.FormatCustomTs(3, 2, 4);
                    return ts.FormatCustomTs(2);

                case timeMode.delta:
                case timeMode.deltaNorm:

                    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
                    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
                    var delta = tsf - ts0;
                    delta = delta * 100;
                    //if (modeTime == timeMode.deltaNorm)
                    //    return delta.FormatCustom(3, 2, 4);
                    return "(" + delta.FormatCustomTs(2) + ")";
                default:
                    throw new NotImplementedException();

            }

            //if (modeTime == timeMode.complex)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates) / CTuning.Calc(m_rank, CConf.Select)).FormatCustom(2);
            //else if (modeTime == Tuning.timeMode.simple)
            //    return (CConf.ConfGen.Vie.TotalDays * ListSelection.getTuningDateValues(this, modeDates)).FormatCustom(2);
            ////   return m_rank.TimeRest.FormatCustom(2); //.ToString("G2", en); 
            //else if (modeTime == timeMode.equiv || modeTime == timeMode.equivNorm)
            //{
            //    var ts = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);

            //    if (modeTime == timeMode.equivNorm || modeTime == timeMode.deltaNorm)
            //        return ts.FormatCustom(3, 2, 4);
            //    return ts.FormatCustom(2);
            //}
            //else
            //{
            //    var ts0 = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, false);
            //    var tsf = ListSelection.getTuningDatesEquiv(this, modeDates, modeTime, true);
            //    var delta = tsf - ts0;

            //    if (modeTime == timeMode.equivNorm)
            //        return delta.FormatCustom(3, 2, 4);
            //    return delta.FormatCustom(2);
            //}
        }

        public int RankAlbumReverse
        {
            get
            {
                if (album != null)
                {
                    int rank = album.Rank.Sort;
                    rank = 1 + gen.Albums.Count - rank;
                    return rank;
                }
                return 0;
            }
        }

        private string getGroup(List<DisplayGrouping> categories)
        {
            StringBuilder sb = new StringBuilder();

            bool begin = false;

            displayCategory last = displayCategory.none;
            foreach (var category in categories)
            {
                try
                {
                    if (begin //&& (int)category.category <= (int)displayCategory.pipe
                        && last != displayCategory.croc1 && last != displayCategory.par1
                        && category.category != displayCategory.croc2 && category.category != displayCategory.par2)
                        sb.Append(" ");
                    begin = true;

                    switch (category.category)
                    {
                        case displayCategory.rankSort:
                            CTuning.format(sb, Rank.Sort); break;
                        case displayCategory.rankDelta:
                            CTuning.format(sb, Rank.RankDelta); break;
                        case displayCategory.rankTime:
                            CTuning.format(sb, Rank.RankRest); break;
                        case displayCategory.rankAllAlbum:
                            CTuning.format(sb, RankAllAlbum); break;
                        case displayCategory.rankAlbum:
                            if (album != null)
                                sb.Append(album.Rank.Sort); break;
                        case displayCategory.rankAlbumReverse:
                            sb.Append(RankAlbumReverse);
                            break;
                        case displayCategory.rankEquiv:
                            if (album != null)
                                sb.Append(album.Equiv);
                            break;
                        case displayCategory.rankEquivLight:
                            if (album != null)
                                sb.Append(album.EquivLight);
                            break;
                        case displayCategory.rankEquivLight0:
                            if (album != null)
                                sb.Append(album.EquivLight0);
                            break;
                        case displayCategory.albumMoy:
                            if (album != null)
                            {
                                sb.Append(album.Moyenne);
                            }
                            break;
                        case displayCategory.lenght:
                            sb.Append(Convert.ToInt32(100 * CTuning.Rapport(Rank.Lenght))); break; //   CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length))); break;
                        case displayCategory.sortValue:
                            sb.Append((1000 * Rank.SortValue).ToString("####", en)); break;
                        case displayCategory.tplay:
                            sb.Append(getTimeValue(datesMode.play, category.mode)); break;
                        case displayCategory.tclass:
                            sb.Append(getTimeValue(datesMode.@class, category.mode)); break;
                        case displayCategory.tclassMin:
                            sb.Append(getTimeValue(datesMode.classMin, category.mode)); break;
                        case displayCategory.tmix:
                            sb.Append(getTimeValue(datesMode.mix, category.mode)); break;
                        case displayCategory.tmixMin:
                            sb.Append(getTimeValue(datesMode.mixMin, category.mode)); break;
                        case displayCategory.timeCoeff:
                            sb.Append((100 * Rank.TimeCoeff).ToString("G3", en)); break;
                        case displayCategory.dplay:
                            sb.Append(ListSelection.getPlayDates(this).Count.ToString()); break;
                        case displayCategory.dclass:
                            sb.Append(ListSelection.getDatesClassement(this).Count.ToString());
                            break;
                        case displayCategory.dclassMin:
                            sb.Append(ListSelection.getClassDatesMin(this).Count.ToString()); break;
                        case displayCategory.dmix:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, false).Count.ToString());
                            break;
                        case displayCategory.dmixMin:
                            sb.Append(ListSelection.buildListReadOrClassementModified(this, true).Count.ToString());
                            break;
                        case displayCategory.pipe:
                            sb.Append("|");
                            break;
                        case displayCategory.par1: sb.Append("("); break;
                        case displayCategory.par2: sb.Append(")"); break;
                        case displayCategory.croc1: sb.Append("["); break;
                        case displayCategory.croc2: sb.Append("]"); break;

                        default:
                            break;
                    }


                    last = category.category;
                }

                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }
            }
            return sb.ToString();
        }

        public virtual int PieceId
        {
            get
            {
                return track.PieceId;
            }
        }

        public void albumMustRefresh()
        {
            foreach (Piece p in Master)
            {
                if (p.album != null)
                    p.album.mustRefresh();
            }
        }


        protected Piece parent;
        public virtual Piece Parent
        {
            get { return parent; }
            set
            {
                if (value == parent)
                    return;
                var old = parent;
                if (old != null)
                    old.albumMustRefresh();
                parent = value;
                if (parent == null)
                {
                    if (old != null)
                    {
                        old.removeChild(this);
                        this.PieceParentId = -1;
                    }
                }
                else
                {
                    parent = parent.Master;
                    this.PieceParentId = value.MasterId;
                    parent.addChild(this);
                }
                if (album != null)
                    this.album.mustRefresh();
            }
        }
        public Piece Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        public int MasterId { get { return Master.PieceId; } }

        private List<Piece> childs = new List<Piece>();
        public List<Piece> Childs { get { return childs; } }
        protected void addChild(Piece child)
        {
            if (child != null && parent != null)
                throw new ApplicationException(string.Format("on ne doit pas affecter un enfant à un non-maitre. enfant:{0} parent {1}", child, parent));

            //if (childs.Contains(child))
            //{
            //    throw new ApplicationException("enfant déjà enregistré"));
            //}
            childs.Add(child);
        }

        public void consolidChild()
        {
            if (parent != null)
            {
                parent.addChild(this);
            }
        }

        private void removeChild(Piece child)
        {
            childs.Remove(child);
        }

        public virtual int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public exportState ExportStatus
        {
            get
            {
                return track.ExportStatus; // exportState;
            }
            set
            {
                track.ExportStatus = value;
            }
        }




        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public void buildVirtualAlbums(List<Piece> list)
        {

            foreach (var path in track.RelativesPath)
            {

                var tab = path.Split('\\');
                var sb = new StringBuilder();

                sb.Append(@"\");
                var count = tab.GetLength(0);
                for (int i = 0; i < count; i++)
                {
                    var _s = tab[i];
                    if (string.IsNullOrEmpty(_s))
                        continue;

                    var virt = createVirtualAlbum(sb.ToString(), false);

                    if (virt != null)
                        list.Add(virt);

                    if (i > 0)
                        sb.Append(@"\");
                    sb.Append(_s);




                }
            }

            if (CConf.ConfGen.ArtistVirtual)
            {
                foreach (Piece p in this)
                {
                    var virt = createVirtualAlbum(p.Artist, true);
                    if (virt == null)
                        continue;
                    list.Add(virt);
                }

            }

        }

        private Piece createVirtualAlbum(string path, bool artist)
        {
            if (string.IsNullOrEmpty(path))
                return null;
            if (path.Length < 2)
                return null;
            var virt = new VirtualAlbumPiece(track, Master, path, artist);
            return virt;
        }



        public bool IsNext
        {
            get
            {
                if (album == null)
                    return false;
                return this == album.Next;
            }
        }
        const int NB_CHAR_COMPLETE = 4;

        //public bool AutoCoeff1 { get { if (album == null) return false; return album.SelectedByCoeff; } }
        //public bool AutoCoeff2 { get { if (album == null) return false; return album.SelectedByCoeff2; } }
        public selectedCoeff SelectedMotif
        {
            get
            {
                if (album == null || !IsNext) return selectedCoeff.none;
                return album.SelectedCoeff;
            }
        }


        public static DateTime SeuilProvisoire;
        // private bool? _classementProvisoireRecent;
        public bool ClassementProvisoireRecent
        {
            get
            {
                foreach (DateTime dt in track.DatesClassementBrut)
                {
                    if (dt > SeuilProvisoire)
                        return true;
                }
                return false;
                //return getClassementProvisoireRecent();
                //if (_classementProvisoireRecent == null)
                //    _classementProvisoireRecent = getClassementProvisoireRecent();
                //return _classementProvisoireRecent.Value;



            }
        }

        //private bool getClassementProvisoireRecent()
        //{
        //    if (!ClassementProvisoire)
        //        return false;
        //    var list = DatesClassement;
        //    var last = CalcDate.getLastModif(list);
        //    if (last > SeuilProvisoire)
        //        return true;
        //    return false;
        //}

        public int NbClass { get { return DatesClassement.Count<DateTime>(t => t >= Piece.SeuilProvisoire); } }

        public bool ClassementProvisoire
        {
            get
            {
                if (RapportClassement == 0)
                    return false;
                var str = ClassName;
                int count = str.Length;
                if (count < 4)
                    return true;
                if (count >= 8)
                    return false;

                var tab = str.ToCharArray();
                int nb = 0;
                for (int i = 0; i < count; i++)
                {
                    if (nb > 0)
                        nb++;
                    else
                    {
                        if (tab[i] != '0')
                        {
                            nb++;
                        }
                    }
                }
                if (nb >= NB_CHAR_COMPLETE)
                    return false;

                return true;

            }
        }

        private class PieceEnumerator : IEnumerator<Piece>
        {
            private IEnumerator<Piece> childEnumerator;
            private Piece current;
            private Piece piece;

            public PieceEnumerator(Piece piece) { this.piece = piece; }
            public Piece Current
            {
                get { return current; }
            }

            public void Dispose()
            {
                if (childEnumerator != null)
                    childEnumerator.Dispose();
            }

            object System.Collections.IEnumerator.Current
            {
                get { return current; }
            }

            public bool MoveNext()
            {
                if (childEnumerator == null)
                {
                    childEnumerator = piece.childs.GetEnumerator();
                    current = piece;
                    return true;
                }
                var ret = childEnumerator.MoveNext();
                if (!ret)
                    return false;
                current = childEnumerator.Current;
                return true;
            }

            public void Reset()
            {
                if (childEnumerator != null)
                    childEnumerator.Reset();
                childEnumerator = null;
            }
        }


        public IEnumerator<Piece> GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return new PieceEnumerator(this);
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }
    }




}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;
using System.Linq;
using pdb.obj;
using System.Text.RegularExpressions;

namespace pdb.gen.albums
{


    public class Album : IEnumerable<Piece>
    {
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return _virtualByArtist; } set { _virtualByArtist = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, VirtualByArtist);
                return key;
            }
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string equivLight0 = "";
        public string EquivLight0 { get { return equivLight0; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        public bool Moved { get; set; }
        public bool Empeached { get; set; }
        public bool Empeached1 { get; set; }
        private static int stackSize=20;
        public static int StackSize { set { stackSize = value; } }

        public bool AlmostFree { get { return stackValue == stackSize; } }
        public bool AlmostFree1 { get { return stackValue == stackSize -1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            piece.PieceAlbum = this;
            if (build)
                return true;

            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                var status = "";
                if (_virtual)
                    status = "v";
                if (_virtualByArtist)
                    status = "va";
                logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                m_rank.init();
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public bool buildDone()
        {

            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceClassementComparer(false));
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && p.RapportClassement == 0)
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {
                    
                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }


        private bool sortDone;
        DecimalIndex _med0;
        DecimalIndex med;
        public void makeSort(ConfAlbumSort conf, ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;

            try
            {
                if (!sortDone)
                    misc.log("make sort {0}", name);
                //misc.log("make sort SortValue {0}", name); 
                selectedCoeff = util.selectedCoeff.noCoeff;

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return;

                for (int i = 0; i < count; i++)
                {
                    list[i].eraseInfoMedianne();
                }

                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = Album.conf.AlbumMoyOffset;
                //if (!sortDone)
                //{



                    list.Sort(new PieceSortComparer());
                    var listSortedValues = new List<decimal>();
                    classed = false;
                    for (int i = 0; i < count; i++)
                    {
                        listSortedValues.Add(list[i].Rank.SortValue);
                        if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                            classed = true;
                    }
                    //misc.log("make sort Duration {0}", name); 
                    m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                    listSortedValues = new List<decimal>();
                    list.Sort(new PieceDurationValueComparer());
                    for (int i = 0; i < count; i++)
                        listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                    durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                decimal moy = 0m;
                #region calcul brut
                #region init
                // misc.log("make sort calcul brut init {0}", name); 
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    //if (coeffEnabled != 1m && p.Enabled)
                    //{
                    //    rapportClassement /= coeffEnabled;
                    //}
                    p.setClassementVirtuel(list[i].RapportClassement);

                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;


                this.med = AlbumMedianne.getMedianne(new List<Piece>(list), medianne);


                _med0 = AlbumMedianne.getMedianneLight(new List<Piece>(list), conf, mode0, false);
                equivLight0 = Piece.getClassementEquiv(_med0.d);


                //list.Sort(new PieceClassementComparer(false));
                //listSortedValues = new List<decimal>();
                //for (int i = 0; i < count; i++)
                //    listSortedValues.Add(list[i].VirtualClassement);

                classementValue = this.med.d;
                if (classementValue > 0m)
                    list[this.med.index].Medianne = true;

                #endregion




                //misc.log("make sort calcul brut medianne {0}", name); 









                #endregion
                #region calcul virtuel
                //misc.log("make sort calcul virtuel {0}", name); 
                #region init (prise en compte coeff des enabled)
                //var coeffEnabled = conf.coeffEnabled;
                //for (int i = 0; i < count; i++)
                //{
                //    var p = list[i];
                //    var rapportClassement = p.RapportClassement;
                //    if (coeffEnabled != 1m && p.Enabled && (!conf.oldAsZero || !p.LastClassementRecent))
                //    {
                //        rapportClassement *= coeffEnabled;
                //    }
                //    p.setClassementVirtuel(rapportClassement);
                //    p.setClassementVirtuel2(rapportClassement);
                //}
                //list.Sort(new PieceClassementComparer(false));
                #endregion
                int i0 = 0;
                AlbumMedianne.buildVirtual(new List<Piece>(list), mode, mode.Min, conf, false, ref i0);

                var med = AlbumMedianne.getMedianneLight(new List<Piece>(list), conf, mode, true);
                classementValueLight = med.d;

                #endregion

                equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 


                moyenne = Piece.getClassementEquiv(classMoy);
                var modeMin = mode.cmpMin;


                if (modeMin == util.modeMin.orphelin)
                {
                    Piece min = null;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {
                        var v = p.RapportClassement;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v < _min)
                            {
                                _min = v;
                                min = p;
                            }
                        }
                    }

                    if (min != null)
                    {
                        Next = min;
                        _min = min.VirtualClassement2;
                        if (_min > classementValueLight)
                            classementValueLight = _min;
                    }
                }
                else if (modeMin == util.modeMin.toujours)
                {
                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true));
                    Piece nextZero1 = null;
                    Piece nextZero2 = null;

                    Piece min1 = null;
                    Piece min2 = null;
                    Piece min = null;
                    decimal _min1 = int.MaxValue;
                    decimal _min2 = int.MaxValue;
                    decimal _minzero1 = int.MaxValue;
                    decimal _minzero2 = int.MaxValue;
                    bool realZero = false;
                    foreach (Piece p in list)
                    {
                        var v1 = p.VirtualClassement;
                        var v2 = p.VirtualClassement2;

                        if (p.Enabled) // && FileRegister.Exist(p.Location))
                        {
                            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                            {
                                if (v1 < _minzero1)
                                {
                                    _minzero1 = v1;
                                    nextZero1 = p;
                                    if (v1 == 0)
                                        realZero = true;
                                }
                            }

                            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                            {
                                if (v2 < _minzero2)
                                {
                                    _minzero2 = v2;
                                    nextZero2 = p;
                                    if (v2 == 0)
                                        realZero = true;
                                }

                            }



                            if (v1 > 0 && v1 < _min1)
                            {
                                _min1 = v1;
                                min1 = p;
                            }

                            if (v2 > 0 && v2 < _min2)
                            {
                                _min2 = v2;
                                min2 = p;
                            }
                        }
                    }
                    decimal _min = 0;
                    if (_min1 <= _min2)
                    {
                        min = min1;
                        _min = _min1;
                    }
                    else
                    {
                        min = min2;
                        _min = _min2;
                    }

                    Piece nextZero = null;
                    decimal _minzero = int.MaxValue;
                    if (_minzero1 <= _minzero2)
                    {
                        nextZero = nextZero1; _minzero = _minzero1;
                    }
                    else
                    {
                        nextZero = nextZero2; _minzero = _minzero2;
                    }

                    if (nextZero != null)
                    {

                        if (realZero)
                        {
                            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                            // j'applique le seuil que s'il est inférieur à la médiane
                            if (_min < classementValueLight)
                            {
                                if (min != null)
                                {
                                    Next = min;
                                    classementValueLight = _min;
                                    if (Next.CoeffVirtuel > 1)
                                        selectedCoeff = selectedCoeff.main;
                                    if (_min < _min1)
                                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                }
                            }
                            else
                            {
                                //  var p = list[med.index];
                                if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                                Next = nextZero;
                                //if (Next.CoeffVirtuel > 1)
                                //    selectedCoeff = selectedCoeff.main; 
                                //if (_min < _min1)
                                //    selectedCoeff = selectedCoeff.min; 
                            }
                        }
                        else
                        {
                            if (_min < classementValueLight)
                            {
                                if (min != null)
                                {
                                    Next = min;
                                    classementValueLight = _min;

                                    if (Next.CoeffVirtuel > 1)
                                        selectedCoeff = selectedCoeff.main;
                                    if (_min < _min1)
                                        selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                                }

                            }
                            else if (_minzero < classementValueLight)
                            {
                                Next = nextZero;
                                classementValueLight = _minzero;

                                if (Next.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main;
                                if (_minzero < _minzero1)
                                    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }

                            else
                            {
                                Next = min;
                                classementValueLight = _min;
                                //  var p = list[med.index];
                                if (Next.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main;
                                if (_med0.d > med.d) // if (p.CoeffVirtuel > 1)
                                    selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            }
                        }
                    }
                    else
                    {
                        // tous notés => on prend le plus faible
                        Next = min;
                        if (min != null)
                        {
                            classementValueLight = _min;
                            // if (min.CoeffVirtuel2 > 1) // if (min.CoeffVirtuel2 > 1)
                            //if (Next.CoeffVirtuel > 1)
                            //    selectedCoeff = selectedCoeff.main; 
                            //if (_min < _min1)
                            //    selectedCoeff = selectedCoeff.min; //selectedByCoeff2 = true;
                        }

                    }

                }

                //if (modeMin > modeMin.non)
                //{
                //    int nb = 0;
                //    Piece min = null;
                //    decimal _min = int.MaxValue;
                //    foreach (Piece p in list)
                //    {
                //        var v = p.RapportClassement;
                //        if (v > 0 && !p.Enabled)
                //            nb++;
                //        if (modeMin == util.modeMin.orphelin || v > 0)
                //        {
                //            if (p.Enabled && FileRegister.Exist(p.Location))
                //            {

                //                if (v < _min)
                //                {
                //                    _min = v;
                //                    min = p;
                //                }
                //            }
                //        }
                //    }

                //    if (min != null)
                //    {
                //        _min = min.VirtualClassement;
                //        if (nb > 0)
                //            _min *= (decimal)nb / (decimal)count;
                //        if (modeMin == modeMin.toujours || _min > classementValueLight)
                //            classementValueLight = _min;
                //    }


                //}
                equivLight = Piece.getClassementEquiv(classementValueLight);

                sortDone = true;
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }

        public void mustRefresh()
        {
            build = false;
            sortDone = false;
            selectionDone = false;
            atLeastOneEnabled = false;
            _tracksSortByClassement = null;

        }



        public decimal getTrackSortValue(int index, List<Piece> list)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;
            //if (selectionDone)
            //    return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public bool isSameOf(Album o)
        {
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && _virtual == o._virtual && _virtualByArtist == o._virtualByArtist;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public DateTime AlbumAdded
        {
            get
            {
                DateTime min = DateTime.MaxValue; 
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }
                  
                }
                return min; 
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, bool artist)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();


                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }

            }
            return __album;

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;
using pdb.gen.conf;
using System.Text.RegularExpressions;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        public static object Lock { get { return _lock; } }


        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                foreach (Album album in dict.Values)
                {
                    album.checkBuild();
                }
            }
        }

        private string getKey(string _album, bool artist)
        {
            return Album.getKey(_album, artist); 
        }

        public void buildDone()
        {
            lock (_lock)
            {
                foreach (Album album in new List<Album>(dict.Values))
                {
                    if (!album.buildDone())
                    {
                        misc.log("suppression album {0}", album.Name);
                        dict.Remove(getKey(album.Name, album.VirtualByArtist));
                    }
                }
            }
        }

        private bool check_(Piece piece, string albumOrg, bool virtualByArtist, IDictionary<string, Album> dict)
        {
            string __album = getKey(albumOrg, virtualByArtist);


            var album = dict[__album];
            if (album == null)
            {
                misc.log("creation album {0}", __album);
                album = new Album(albumOrg,__album);
                album.Virtual = piece.Virtual;
                album.VirtualByArtist = piece.VirtualByArtist;
                dict.Add(__album, album);
            }

         return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualByArtist, dict);            
        }

        public int Count { get { return dict.Count; } }



       

        public void sortVirtual()
        {
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {

            if (piece.Virtual)
                check_(piece, dict);

        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void buildStack()
        {
            // prise en compte de la stack
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize; 
            Album.StackSize =stackSize; 
            stack.Enabled = confSort.stackEnabled;
            stack.build();
        }

        public void makeSort()
        {
            misc.log("albums.make sort");
          
            ///check to find first light
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);




            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(confSort, confMedianne, conf0); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(consolid.SortAlbumMode));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
           
            //var listStack = stack.Albums;
            //foreach (Album s in listStack)
            //{
            //    string key = getKey(s.Name);
            //    var alb = dict[key];
            //    stack.merge(s, alb);
            //}
            //list.Sort(new AlbumClassComparerStack());
            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank2 = i + 1; 
            //}
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }

        public void changeAlbum(Piece p, string newA)
        {
            var currentAlb = dict[getKey(p.Album, false)];
            if (currentAlb != null)
                currentAlb.mustRefresh();
            check_(p, newA,false, this.dict);    
            var newAlb = dict[getKey(newA, false)];
            if (newAlb != null)
                newAlb.mustRefresh();
            p.albumMustRefresh(); 
        }

        public void changeArtist(Piece p, string newA)
        {
            


            var currentAlb = dict[getKey(p.Artist, true)];
            if (currentAlb != null)
                currentAlb.mustRefresh();

            check_(p, newA, true, this.dict);           
            var newAlb = dict[getKey(newA, true)];
            if (newAlb != null)
                newAlb.mustRefresh();
            p.albumMustRefresh(); 
        }

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                bool found = false;
                foreach (Album album in dict.Values)
                {
                    if (album.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.Clear();
                }
                else
                {
                    // on le prend.
                    dict.Add(getKey(candidat.Name, candidat.VirtualByArtist), candidat);
                    foreach (Piece p in candidat)
                    {
                        p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }




        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(TrackList track)
        {
            track.Piece.albumMustRefresh(); 
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track.Piece);
        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\CFIle.cs">
    <content><![CDATA[using System;
using System.IO;
using pdb.obj;
using pdb.util;
namespace pdb.db
{
    public class CFile : IData
    {
        private const string TOKEN_FILE = "file";

        private string m_file = "";
        // private bool? _exists;
        // private String path = "";
        // private String ext;
        private FileType fileType = FileType.none;
        // private long size = 0;
        //private bool _extern = false;
        // private FileInfo infos;
        public static String DefaultFolder = "";


        FileValue fi;

        public string getPath()
        {
            if (isExtern())
                return m_file;
            return DefaultFolder + m_file; 
        }

        private FileValue Info
        {
            get
            {
                if (fi == null)
                {
                    string path = getPath(); 
                    fi = FileRegister.Check(path);
                }
                return fi;
            }
        }

        public CFile(string a_file)
        {
            try
            {
                m_file = a_file.TrimSafe();
                if (a_file.Contains(@"/"))
                {
                    m_file = XMLTool.FromXml(a_file.Trim());
                    string prefix = "file://";
                    string l_legacyDefaultFolder = new Uri(DefaultFolder).AbsoluteUri;
                    //if (l_legacyDefaultFolder != null && l_legacyDefaultFolder.Contains(l_defaultFolder))
                    //{
                    //    l_defaultFolder = l_legacyDefaultFolder;
                    //}
                    if (!m_file.StartsWith(prefix))
                    {
                        m_file = l_legacyDefaultFolder + m_file;
                    }
                    string l_path = new Uri(m_file).LocalPath;
                    m_file = l_path.Replace("\\\\localhost\\", "");


                }
                m_file = m_file.Replace(DefaultFolder, "");
               
                //path = getPath();

                //  _exists = true;


                // FileInfo infos = new FileInfo(path);
                //var _exists = FileRegister.Exist(path); // infos.Exists;
                //if (false.Equals(_exists))
                //    path = FileRegister.FullName(path); // infos.FullName;




                //String ext = System.IO.Path.GetExtension(path).Replace(".", "").ToLower();
                //fileType = getFileType(ext);
                //if (_exists)
                //    size = infos.Length;

            }
            catch (Exception e)
            {
                String message = String.Format("impossible de construire CFile {0}", m_file);
                throw new ApplicationException(message, e);
            }
        }
        public void write(ITextWriter a_sw)
        {
            XMLTool.writeValue(a_sw, TOKEN_FILE, XMLTool.FileToXml(m_file));
        }

        public void write(System.Xml.XmlWriter w)
        {
            w.WriteElementString(TOKEN_FILE, m_file);
        }
        public string File
        {
            get { return m_file; }
        }
        public bool exists()
        {
            return Info.Exists;
        }
        //public string getUri()
        //{
        //    return new Uri(path).AbsoluteUri;
        //}
        //private string getPath()
        //{
        //    if (isExtern())
        //        return m_file;
        //    return DefaultFolder + m_file;
        //}

        public override string ToString()
        {
            return Info.FullName;
        }



        public bool isExtern()
        {
            return m_file.Substring(1, 2).Equals(@":\");
        }

        public string Path
        {
            get
            {
                if (fi != null)
                    return fi.FullName;
                return getPath();
                //string l_file = "";
                ////if (m_file.Contains("\\"))
                ////{
                //// chemin windows D:\
                //if (m_file.Substring(1, 2).Equals(@":\"))
                //{
                //    //chemin absolu
                //    l_file = m_file;
                //}
                //else
                //{
                //    //chemin relatif
                //    l_file = CLegacy.DefaultFolder + m_file;
                //}
                //return l_file;
            }
            //else
            //{


            //    if (m_file.Contains("file://"))
            //    {
            //        l_file = m_file;
            //    }
            //    else
            //    {
            //        string l_defaultFolder = "file://";
            //        string l_legacyDefaultFolder =  new Uri( CLegacy.DefaultFolder).AbsoluteUri;
            //        if (l_legacyDefaultFolder != null && l_legacyDefaultFolder.Contains(l_defaultFolder))
            //        {
            //            l_defaultFolder = l_legacyDefaultFolder;
            //        }
            //        l_file = l_defaultFolder + m_file;
            //    }

            //    string l_path = new Uri(l_file).LocalPath;
            //    l_path = l_path.Replace("\\\\localhost\\", "");
            //    return l_path;
            //}
            //}
        }
        public bool Equals(CFile other)
        {
            if (other == null)
                return false;

            return m_file.ToLower().Equals(other.m_file.ToLower());
        }
        public bool isPodcast
        {
            get
            {
                if (m_file.StartsWith("Podcasts/"))
                    return true;
                return false;
            }
        }
        public FileType FileType
        {
            get
            {
                if (fileType == FileType.none)
                {
                    fileType = FileType.unknown;
                    String ext = System.IO.Path.GetExtension(m_file).Replace(".", "").ToLower();


                    try
                    {
                        fileType = (FileType)Enum.Parse(typeof(FileType), ext, true);
                    }
                    catch
                    {
                    }
                }
                return fileType;
            }
        }

        public long Size
        {
            get
            {

                return Info.Length;
            }
        }

        //public string DirAndFileName
        //{
        //    get
        //    {
        //        var ret = getPath();
        //        try
        //        {
        //            var infos = FileRegister.Check(ret); // new FileInfo(path);
        //            return infos.DirAndFileName;
        //        }
        //        catch
        //        {

        //        }
        //        return ret;
        //    }
        //}





    }
}

]]></content>
  </file>
  <file path="\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        private static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        private TrackPlayListManager listManager = new TrackPlayListManager();
        private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        private static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);

        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }



        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            this.album = track.Album;
            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.location = track.Location;
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;




        }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present; public bool Present { get { return present; } set { present = value; } }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location": Uri uri = new Uri(value);
                        return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.playedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;

            Fill();
        }

        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0; 
            string key = "";
            bool nextIgnore = false;
           

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": id = Convert.ToInt32(value);
                        break;
                    case "Name": name = value;
                        //if (name == "Le juge et la violence 28.11.13 j")
                        //{
                        //}


                        if (name == "2. Gaëtan Roussel - - 2ème Partie 05.12.13 j")
                        {
                        }
                        break;
                    case "Artist": artist = value; break;
                    case "Album": album = value; break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": playedDate = Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location": Uri uri = new Uri(value);
                        location = uri.LocalPath.Replace(@"\\localhost\", "");
                        break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind": if (value.Equals("Flux audio sur Internet"))
                            strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment": if (!loaded)
                            volume = Convert.ToInt32(value);

                        break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return tracktrack;
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;

                bgClass.add(new Bgtask(() =>
                {
                    Track.Artist = value;
                    artist = value;
                }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                ));


            }
        }


        protected string album = "";
        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value == null || value.Equals(album)) return;
                bgClass.add(new Bgtask(() =>
                {
                    // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                    Track.Album = value;
                    album = value;
                }, this,
                "change album from '{0}' to'{1}' {2}", album, value, this
                ));

            }
        }
        protected string name = "";
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;

                var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                bgClass.add(bgtaskName);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }
        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        private bool firstClass;
        public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                firstClass = false;
                if (comment != value)
                {
                    try
                    {
                        var tab0 = comment.Split(' ');
                        var tab1 = value.Split(' ');

                        var count0 = tab0.GetLength(0);
                        var count1 = tab1.GetLength(0);

                        if (count0 != count1)
                            firstClass = true;

                        else if (comment.Length > 3)
                        {
                            string org = tab0[count0 - 1];
                            string fin = tab1[count1 - 1];

                            firstClass = !org.Equals(fin);
                        }
                    }

                    catch
                    {
                        firstClass = true;
                    }

                    var sb = new StringBuilder();
                    sb.Append(ClassName);
                    sb.Append(".");
                    sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format("{0} change comment from '{1}' to '{2}' {3}", sb.ToString(), comment, value, this), value);

                    if (firstClass)
                        bgFirstClass.add(task);
                    else
                        bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled;
        public bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        private bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        protected DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                //if (playCount > 0)
                return playedDate;
                // return DateTime.MinValue;
            }
        }
        protected string location;
        public string Location
        {
            get { return location; }
            set { location = value; }
        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }


        }

        public void setGrouping(string value, bool prior)
        {
            if (!present)
            {
                grouping = value;
                return;
            }
            if (grouping != value)
            {
                bool _delta = false;
                // bool _deltaRank = false; 
                string rankAlbum = "";
                string equivAlbum = "";
                if (value != null)
                {
                    string[] org = grouping.Split(' ');
                    string[] _new = value.Split(' ');

                    int count = org.GetLength(0);
                    if (_new.GetLength(0) != count || count < 3)
                        _delta = true;
                    else
                    {
                        rankAlbum = _new[1];
                        equivAlbum = _new[2];
                        if (!org[1].Equals(_new[1]))
                        {
                            _delta = true;
                        }
                    }
                }

                var sb = new StringBuilder();
                sb.Append(rankAlbum);
                sb.Append(" ");
                sb.Append(equivAlbum);
                sb.Append(" ");
                sb.Append(album);
                //sb.Append(ClassName);
                //sb.Append(".");
                //sb.Append((Rating / 20).ToString());

                var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

                if (firstClass)
                {
                    bgSeconClass.add(task);
                    return;
                }

                //if (prior)
                //{
                //    bgGroupPrior.add(task);
                //    return;
                //}



                if (_delta)
                {
                    if (prior)
                        bgGroupPrior.add(task);
                    else
                        bgGroup2nd.add(task);
                    return;
                }

                bgg.add(task);

                //if (_delta)
                //    bgGroupDelta.add(task);
                //else
                //{
                //    bgg.add(task);
                //}
                //  grouping = value;
            }
        }



        private int volume;
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return location;
        }



        public List<CPlayList> PLayLists
        {
            get { return listManager.PLayLists; }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return listManager.ClassPlayLists; }
        }

        public void AddPlayList(CPlayList a_playList)
        {
            listManager.AddPlayList(a_playList);
            // className = listManager.ClassName;
        }

        public void removePlayList(CPlayList list)
        {
            listManager.removePlayList(list);
            // className = listManager.ClassName;
        }


        public string ClassName
        {
            get
            {
                className = listManager.ClassName;
                return className;
            }
            set
            {
                className = listManager.ClassName;
                if (className != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        loader.setClassPlayList(this, className, value);
                        className = value;
                    }, this,
                   "change className from '{0}' to'{1}' {2}", className, value, this));


                    //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
                    //className = value;
                    //OnClassNameChange(value);
                }
            }
        }
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }

        public void Delete()
        {
            if (tracktrack != null)
                tracktrack.Delete();
            else
                bgClass.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        private class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                foreach (PlayList pl in info.PLayLists)
                {
                    var tInList = pl.getPieceInList(info) as TrackInList;
                    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                }

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getLocation()
        {
            return location; 
        }


        public DateTime Added
        {
            get { return track.DateAdded; }
        }
    }
}



]]></content>
  </file>
  <file path="\PieceDb.obj\pdb.obj.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.obj</RootNamespace>
    <AssemblyName>pdb.obj</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.obj.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.obj.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CPlayList.cs" />
    <Compile Include="CPlayListComparer.cs" />
    <Compile Include="DictRef.cs" />
    <Compile Include="IBgTask.cs" />
    <Compile Include="ILoader.cs" />
    <Compile Include="Interfaces.cs" />
    <Compile Include="Metadata.cs" />
    <Compile Include="TrackIdentity.cs" />
    <Compile Include="TrackPlayListManager.cs" />
    <Compile Include="PlComponent.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
</db>
