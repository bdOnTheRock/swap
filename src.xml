<db path="C:\bernard\db2\">
  <file path="db4\pdb.player\Vue\ClassementCtl.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using pdb.player.ViewModel;
using pdb.gen.stat;
using pdb.player.Vue.Adorn;
using System.ComponentModel;
using pdb.gen;
using System.Text.RegularExpressions;
using System.Windows.Threading;
using pdb.player.Vue.Util;
using pdb.player.ViewModel.Colors;
using pdb.util;
using System.Threading;

namespace pdb.player.Vue
{
    public class TB : UIElement
    {
        private Border border;
        private TextBlock tb;
        public TB()
        {
            border = new Border();
            border.BorderThickness = new Thickness(0.3);
            border.BorderBrush = Brushes.Gray;

            tb = new TextBlock();
            tb.TextAlignment = TextAlignment.Center;
            border.Child = tb;
            tb.FontSize = 10;
            tb.HorizontalAlignment = HorizontalAlignment.Stretch;
            tb.Visibility = System.Windows.Visibility.Visible;
        }

        public Brush Background { set { tb.Background = value; } }
        public string Content { set { tb.Text = value; } }

        protected override bool IsEnabledCore
        {
            get
            {
                return true;
            }
        }




    }


    /// <summary>
    /// Interaction logic for ClassementCtl.xaml
    /// </summary>
    public partial class ClassementCtl : UserControl, IGradiant, IClassementObserver
    {



        private DetailClassementViewModel model;
        private StatCtl[,] tbs = new StatCtl[DynamicStat.ROWS + 1, DynamicStatLigne.COLS];
        private Border[,] borders = new Border[DynamicStat.ROWS + 1, DynamicStatLigne.COLS];
        private ILogger log;
        private int loupe = 1;
        private void initBandeau(int row)
        {
            for (int c = 0; c < DynamicStatLigne.COLS; c++)
            {
                var border = new Border();
                border.BorderThickness = new Thickness(0.3);
                border.BorderBrush = Brushes.Gray;
                border.Background = Brushes.LightGray;
                border.VerticalAlignment = System.Windows.VerticalAlignment.Bottom;
                border.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                border.ClipToBounds = true;
                var tb = new TextBlock();
                tb.VerticalAlignment = System.Windows.VerticalAlignment.Stretch;
                tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                tb.Background = Brushes.LightGray;
                int cc = c;
                if (c >= DynamicStatLigne.SEMI_COLS)
                    cc = (c - DynamicStatLigne.SEMI_COLS);
                tb.Text = (cc).ToString();
                tb.TextAlignment = TextAlignment.Center;
                border.Child = tb;
                tab.Children.Add(border);
                Grid.SetRow(border, row);
                Grid.SetColumn(border, c);
            }
        }
        public ClassementCtl()
        {

            InitializeComponent();
            GradiantBuilder.Instance.Add(this);
            TbClass.PreviewTextInput += new TextCompositionEventHandler(TbClass_PreviewTextInput);

            for (int i = -DynamicStatLigne.SEMI_COLS; i <= DynamicStatLigne.SEMI_COLS; i++)
            {
                var col = new ColumnDefinition();
                col.Width = new GridLength(1, GridUnitType.Star);
                tab.ColumnDefinitions.Add(col);
            }

            for (int j = 0; j <= DynamicStat.ROWS + 1; j++)
            {
                var row = new RowDefinition();
                if (j == DynamicStat.ROWS+1 || j == 0)
                    row.Height = new GridLength(1, GridUnitType.Auto);
                else if (j == 1)
                    row.Height = new GridLength(1, GridUnitType.Star);
                else
                    continue;

                tab.RowDefinitions.Add(row);
            }

            initBandeau(0);
            initBandeau(2);

            int rr = 0;
            for (int r = 1; r <= DynamicStat.ROWS; r++)
            {
                if (r < 3)
                    continue;
                if (r > 3)
                    continue;
                rr++;
                for (int c = 0; c < DynamicStatLigne.COLS; c++)
                {

                    var tb = new StatCtl();
                    //var border = new Border();
                    //border.BorderThickness = new Thickness(0.3);
                    //border.BorderBrush = Brushes.Gray;

                    //border.VerticalAlignment = System.Windows.VerticalAlignment.Stretch;
                    ////var tb = new TextBlock();
                    ////tb.TextAlignment = TextAlignment.Center;

                    //////tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                    ////tb.VerticalAlignment = System.Windows.VerticalAlignment.Center;
                    ////tb.FontSize = 10;


                    //border.Child = tb;
                    //    border.ClipToBounds = true;
                    tbs[r, c] = tb;
                    // borders[r, c] = border;


                    // AdornedControl ac = new AdornedControl(); 

                    // tb.BorderThickness = new Thickness(0.2) ;
                    // tb.BorderBrush = Brushes.Gray;
                    // tb.FontSize = 10;


                    tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                    tb.Margin = new Thickness(0);
                    tb.Padding = new Thickness(0);

                    //tab.Children.Add(border);

                    //Grid.SetRow(border, r);
                    //Grid.SetColumn(border, c);



                    tab.Children.Add(tb);
                    Grid.SetRow(tb, rr);

                    Grid.SetColumn(tb, c);

                    //if (r == 0)
                    //{
                    //    tb.Background = Brushes.LightGray;
                    //    tb.Text = (c - DynamicStatLigne.SEMI_COLS).ToString();
                    //}


                    if (c == DynamicStatLigne.SEMI_COLS || r == 3)
                        tb.FontWeight = FontWeights.Bold;
                }


            }




            this.Loaded += new RoutedEventHandler(ClassementCtl_Loaded);
        }
        Regex regex = new Regex(@"[0-5.\ ]+");
        void TbClass_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            var text = e.Text;
            if (!string.IsNullOrEmpty(text))
            {
                //regex that matches disallowed text
                if (!regex.IsMatch(text))
                    e.Handled = true;
            }

        }

        void ClassementCtl_Loaded(object sender, RoutedEventArgs e)
        {
            log = Logger.getLogger("ClassementCtl");
            this.classProvider = new Provider(dg);
            // this.albumProvider = new Provider(dgAlbum); 
            this.model = new DetailClassementViewModel(this);
            App.DetailClassementViewModel = model;
            //  model.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(model_PropertyChanged);
            // TrackListViewModel.CurrentSelectedChanged += new EventHandler(TrackListViewModel_CurrentSelectedChanged);
            model.setClassment("", null);
            btRecord.IsDefault = true;

            init(null);

        }

        //void TrackListViewModel_CurrentSelectedChanged(object sender, EventArgs e)
        //{
        //    // init(); 
        //}

        //void model_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        //{
        //    init(NUllClient.NULL);
        //}

        private class CPieceComparerByQualityAndLength2 : IComparer<TrackListViewModel>
        {
            private static IComparer<Piece> qual = new CPieceComparerByQualityAndLength();
            int IComparer<TrackListViewModel>.Compare(TrackListViewModel x, TrackListViewModel y)
            {
                return -qual.Compare(x.PieceGen, y.PieceGen);
                // return -x.PieceGen.Rank.Twice.CompareTo(y.PieceGen.Rank.Twice);
            }
        }

        private void init(IClient client)
        {
            if (client == null)
                client = new SimpleClient("ClassementCtl", log);

            if (client.Cancel)
                return;
            App.Dispatch(() =>
                {
                    client.Start();
                    //SortDescriptionCollection sort = null;
                    //ICollectionView view = null;

                    int caretIndex = TbClass.CaretIndex;
                    // TbClass.IsReadOnly = true;

                    //view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                    //if (view != null)
                    //    sort = view.SortDescriptions;

                    //List<SortDescription> _sort = null;
                    //if (sort != null)
                    //    _sort = new List<SortDescription>(sort);


                    if (client.Cancel)
                        return;
                    base.DataContext = null;
                    try
                    {
                        model.reset();
                        client.log("ClassementCtl::init: model.reset() ");
                        dg.ItemsSource = null;
                        if (client.Cancel)
                            return;
                        var tracks = model.getTracks(client);

                        if (tracks == null)
                            return;
                        if (client.Cancel)
                            return;
                        tracks.Sort(new CPieceComparerByQualityAndLength2());
                        dg.ItemsSource = tracks;
                        client.log("ClassementCtl::init: dg.ItemsSource ");
                        //foreach (TrackListViewModel t in tracks)
                        //    t.refresh(); 

                        //ICollectionView source = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                        //if (source != null)
                        //{
                        //    if (source.SortDescriptions != null)
                        //        source.SortDescriptions.Clear();
                        //    source.SortDescriptions.Add(new SortDescription("Classement", ListSortDirection.Descending));
                        //}
                        //  tracks.init();
                        //dgAlbum.ItemsSource = null;
                        //object sel; 
                        //if (dgAlbum.Items.Count > 0)
                        //{
                        //    sel = dgAlbum.SelectedItem; 
                        //}
                        //dgAlbum.ItemsSource = model.Album;
                        //dgStat.ItemsSource = null;

                        //var stats = model.Stats;
                        //dgStat.DataContext = null; 
                        //dgStat.DataContext = stats.DefaultView;
                        //dgStat.ItemsSource = stats.DefaultView; 
                        if (client.Cancel)
                            return;
                        var stats = model.getStats(client);
                        if (stats == null)
                            return;

                        client.log("ClassementCtl::init: model.getStat ");

                        //for (int c = -DynamicStatLigne.SEMI_COLS; c <= DynamicStatLigne.SEMI_COLS; c++)
                        //{
                        //    var tb = tbs[0, c + DynamicStatLigne.SEMI_COLS];
                        //    tb.Background = Brushes.LightGray;
                        //    tb.Text = (c - DynamicStatLigne.SEMI_COLS).ToString();
                        //    tb.InvalidateVisual();
                        //}
                        if (client.Cancel)
                            return;


                        for (int r = 1; r <= DynamicStat.ROWS; r++)
                        {
                            var stat = stats[r - 1];
                            List<int> list = new List<int>(from c in stat select c);

                            list.Sort();
                            list.Reverse();
                            int count = list.Count;
                            int max = list[0];

                            int _loupe = loupe;
                            if (_loupe < 1)
                                _loupe = 1;
                            if (_loupe > count - 2)
                                _loupe = count - 2;

                            int max2 = list[_loupe];
                            double f = max2 * 1.05;
                            f = System.Math.Round(f);
                            if (f > 0 && f < max)
                                max = (int)f;

                            for (int c = -DynamicStatLigne.SEMI_COLS; c <= DynamicStatLigne.SEMI_COLS; c++)
                            {
                                try
                                {
                                    //  var row = stats.Rows[r-1][c.ToString()]; 
                                    int nb = stats[r - 1][c];
                                    var tb = tbs[r, c + DynamicStatLigne.SEMI_COLS];
                                    if (tb == null)
                                        continue;
                                    if (nb > 0)
                                        tb.Text = nb.ToString();
                                    else
                                        tb.Text = "";
                                    tb.setValue(nb, max);
                                    tb.InvalidateVisual();
                                    //var b = borders[r, c + DynamicStatLigne.SEMI_COLS];
                                    //var layer = AdornerLayer.GetAdornerLayer(b);
                                    //try { layer.Remove((layer.GetAdorners(b))[0]); }
                                    //catch { }
                                    //layer.Add(new BarAdorner(b, nb, max));


                                }
                                catch (Exception ex)
                                {
                                    App.log.log(ex.ToString());
                                }


                                // tbs[r, c + DynamicStatLigne.SEMI_COLS].Text = stats.Rows[r - 1][c.ToString()].ToString(); 
                            }
                        }

                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                    finally
                    {
                        if (!client.Cancel)
                        {
                            base.DataContext = model;
                            // view = CollectionViewSource.GetDefaultView(dg.ItemsSource);

                            //   dg.ApplySort(_sort);
                            TbClass.CaretIndex = caretIndex;
                            // TbClass.IsReadOnly = false;

                            client.log("ClassementCtl::init: end ");
                        }
                    }
                }, client);
        }

        private void btRecord_Click(object sender, RoutedEventArgs e)
        {
            model.record();

        }

        private ItrackProvider classProvider;
        private ItrackProvider albumProvider;

        private void dgMouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            var r = sender as DataGridRow;
            var t = r.Item as TrackListViewModel;
            PlayerViewModel.reset(classProvider, t);
        }

        //private void dgAlbum_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        //{
        //    var r = sender as DataGridRow;
        //    var t = r.Item as TrackListViewModel;
        //    PlayerViewModel.reset(albumProvider, t);
        //}

        private class Provider : ItrackProvider
        {
            private DataGrid dt;
            public Provider(DataGrid dt)
            {
                this.dt = dt;
            }

            public System.ComponentModel.ICollectionView PresentationTracks
            {
                get { return CollectionViewSource.GetDefaultView(dt.ItemsSource); }
            }

            public PlayListViewModel PlayList
            {
                get { return null; }
            }

            public void Focus(TrackListViewModel t)
            {

            }


            public void doFilter(string filter)
            {

            }

            public List<TrackListViewModel> SelectedTracks
            {
                get
                {
                    var list = new List<TrackListViewModel>();
                    foreach (TrackListViewModel track in PresentationTracks)
                        list.Add(track);
                    return list;
                }
            }
        }

        //public System.ComponentModel.ICollectionView PresentationTracks
        //{
        //    get { return CollectionViewSource.GetDefaultView(dgAlbum.ItemsSource); }
        //}

        public PlayListViewModel PlayList
        {
            get { return null; }
        }

        public void Focus(int index)
        {

        }

        ViewModel.Colors.Gradient IGradiant.Conf
        {
            get { return Couleurs.Instance.classement.gradient; }
        }

        bool IGradiant.sensGradient
        {
            get { return true; }
        }

        void IBackGround.setBackground(Brush brush)
        {
            dg.Background = brush;
        }

        void IClassementObserver.signalClassementChange(IClient client)
        {
            init(client);
        }

        private void TbClass_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            log.log("TbClass_PreviewKeyDown");
            App.Indispo = true;
        }

        private void TbClass_MouseEnter(object sender, MouseEventArgs e)
        {
            log.log("TbClass_MouseEnter");
            App.Indispo = true;
        }

        private void TbClass_PreviewMouseDown(object sender, MouseButtonEventArgs e)
        {
            log.log("TbClass_PreviewMouseDown");
            App.Indispo = true;
        }

        private void TbClass_MouseLeave(object sender, MouseEventArgs e)
        {
            log.log("TbClass_MouseLeave");
            App.Indispo = false;
        }

        private void tab_MouseDown(object sender, MouseButtonEventArgs e)
        {

        }

        private void tab_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
        {
            loupe = 1;
            log.log("LOUPE " + loupe);
            init(null);
        }

        private void tab_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            loupe++;
            log.log("LOUPE " + loupe);
            init(null);
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.player\Vue\StatCtl.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using pdb.player.ViewModel;
using System.Globalization;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for StatCtl.xaml
    /// </summary>
    public partial class StatCtl : UserControl
    {
        private StatItemViewModel model;
        public StatCtl()
        {
            InitializeComponent();
            this.model = new StatItemViewModel();
            Loaded += new RoutedEventHandler(StatCtl_Loaded);
        }

        void StatCtl_Loaded(object sender, RoutedEventArgs e)
        {

        }
        private int nb;
        private int max = -1;
        private string txt;

        public int Nb { set { model.Nb = value; } }
        public int Max { set { model.Max = value; } }
        public void setValue(int nb, int max)
        {
            this.nb = nb;
            this.max = max;
            //model.setValue
            //canvas.Children.Clear(); 
            //var des = this.DesiredSize.Height;
            //if (des == 0)
            //    des = this.RenderSize.Height;
            //if (des == 0)
            //    des = this.Height; 
            //model.DesiredHeight = des;
            //model.setValue(nb, max);
            //SolidColorBrush brush = new SolidColorBrush(Colors.Gray);
            //Rectangle rect = new Rectangle();
            //rect.Width = this.Width;
            //rect.Height = model.Height;
            //rect.Fill = brush;
            //canvas.Children.Insert(0,rect); 
        }

        protected override void OnRender(DrawingContext drawingContext)
        {
            base.OnRender(drawingContext);

            try
            {
                Rect adornedElementRect = new Rect(RenderSize);

                // Some arbitrary drawing implements.
                SolidColorBrush renderBrush = new SolidColorBrush(Colors.Gray);
                SolidColorBrush btext = new SolidColorBrush(Colors.Black);
                renderBrush.Opacity = 0.2;
                Pen renderPen = new Pen(new SolidColorBrush(Colors.Navy), 0.3);
                //double renderRadius = 5.0;

                if (max >= 0)
                {
                    double h = 0;
                    if (nb == 0)
                        h = 0;
                    else if (max == 0)
                        h = 0;
                    else
                    {
                        double coeff = (double)nb / max;
                        if (coeff >1)
                            coeff =1; 
                        h = coeff * RenderSize.Height; // adornedElementRect.Height;
                    }

                    double x = adornedElementRect.X;
                    double y = adornedElementRect.Y;
                    double y0 = RenderSize.Height;
                    double yf = y0 - h;


                    Rect graph = new Rect(0, yf, adornedElementRect.Width, h);

                    drawingContext.DrawRectangle(renderBrush, renderPen, graph);

                }
                if (txt == null)
                    txt = "";

                FormattedText formattedText = new FormattedText(
                       txt,
                       CultureInfo.GetCultureInfo("en-us"),
                       FlowDirection.LeftToRight,
                       new Typeface("Helvetica"),
                       10,
                       Brushes.Black);

                formattedText.SetFontWeight(FontWeight);
               // var pt = new Point(Math.Min(10, RenderSize.Width / 4), Math.Min(10, RenderSize.Height / 4));
                var pt = new Point(Math.Min(10, RenderSize.Width / 4), Math.Min(RenderSize.Height -5, RenderSize.Height*0.95));
                drawingContext.DrawText(formattedText, pt);

                var pt2 = new Point(Math.Min(10, RenderSize.Width / 4), Math.Min(5, RenderSize.Height*0.05));
                drawingContext.DrawText(formattedText, pt2);
                // drawingContext.DrawText(new FormattedText(txt, CultureInfo.CurrentCulture, System.Windows.FlowDirection.LeftToRight, new Typeface("Arial") { Weight = FontWeight }, 10, btext), new Point()); 

            }
            catch (Exception ex)
            {
            }
        }

        public string Text { set { txt = value; } }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Loader.cs">
    <content><![CDATA[
using pdb.obj;
using System.Collections.Generic;
using pdb.it;
using pdb.util;
using System;
using pdb.podcast.DB;
using System.Xml;
using pdb.iit;
using pdb.util.RelativePath;

namespace pdb.podcast
{
    public class Loader : pdb.it.Loader, ILoader
    {
        private bool _import; public bool Import { get { return _import; } }
        public Loader(Conf conf, bool useDetect, bool writeOnlyEnabled, bool writeOnlyUnRead) : base(conf, useDetect, writeOnlyEnabled, writeOnlyUnRead) { TrackInfoItunes.Loader = this; }
        public Loader(Conf conf, bool import, Db db, Action abortList, bool writeOnlyEnabled, bool writeOnlyUnRead) : base(conf, abortList, writeOnlyEnabled, writeOnlyUnRead) { this.db = db; this._import = import; TrackInfoItunes.Loader = this; }
        private Db db;
        protected override void afterCreate(it.PlayList playlist, it.TrackInfoItunes track, int id)
        {
            TrackInfoItunes _track = track as TrackInfoItunes;
            //  db.Check(_track); 
            //if (playlist.isSubList("info"))
            //    _track.Info = true;
            //if (playlist.isSubList("rare"))
            //    _track.Rare = true;
            //if (playlist.isSubList("_auto"))
            //    _track.GlobalSelected = true;
        }

        public override it.TrackInfoItunes create(string location)
        {
            TrackInfoItunes t = null;
            //if (import)
            //{
            //    t = new TrackInfoItunes() { Location = location };
            //}
            //else
            //{
            t = db.get(location);
            if (t == null)
                t = new TrackInfoItunes() { File = RelativeFileRegister.Get( location) };
            //}

            t.Present = true;
            return t;
        }

        public override void createTrack(it.TrackInfoItunes piece, bool podcast)
        {
            var track = piece as TrackInfoItunes;
            if (!string.IsNullOrEmpty(track.HibernateLocation))
            {
                misc.moveTree(FileRegister.CheckNow(track.HibernateLocation), track.Location, false);
                track.HibernateLocation = null;
            }

            base.createTrack(piece, true);

        }

        public void loadTracks(bool firstStep, bool forceLoad, List<ITrackInfoItunes> list)
        {
            init();
            reset(firstStep, forceLoad);
            loadTracks(list);
            loadLists();
        }

        public void import(ITrackInfoItunes t)
        {
            var track = t as TrackInfoItunes; 
            if (!track.Present)
            {
                if (track.isPresent())
                {
                    createTrack(track,true);
                    track.Present = true;
                }
                else return;
            }
            track.import();
        }


      


        public void merge(ITrackInfoItunes t)
        {
            var track = t as TrackInfoItunes; 
            if (!track.Present)
                return;
            track.merge();
        }

        private int nbTrackCreated; public int NbTrackCreated { get { return nbTrackCreated; } }
      
        public void reviveIfNecessary(ITrackInfoItunes t)
        {
            var track = t as TrackInfoItunes; 
            try
            {
                if (!track.Present)
                {
                    if (track.isPresent())
                    {
                        createTrack(track, true);
                        track.import();
                        track.Present = true;
                        nbTrackCreated++;
                    }
                    else
                    {
                        log.log("ABSENT:{0} {1}", track, track.Location);
                    }
                }
            }
            catch (Exception ex)
            {
                log.Error(string.Format("Impossible de ressuciter {0}", track), ex);
            }
            

            

        }



        //public void removeReadItems(PlayListComposite folder)
        //{
        //    List<PlComponent> toDelete = new List<PlComponent>();
        //    foreach (PlComponent plc in folder)
        //    {
        //        if (plc is TrackInList)
        //        {
        //            var t = plc as TrackInList;
        //            var piece = t.Piece as TrackInfoItunes;
        //            if (piece == null)
        //            {
        //                misc.log("plc pas un TrackInfoItunes {0}", plc);
        //            }
        //            else
        //            {
        //                if (piece.Played)
        //                    toDelete.Add(plc);
        //            }
        //        }
        //        else if (plc is PlayListComposite)
        //        {
        //            removeReadItems(plc as PlayListComposite);
        //        }
        //    }

        //    foreach (PlComponent plc in toDelete)
        //        plc.Delete();
        //}


        public iit.IPlayList getPlayList(PlayListComposite folder, string name, bool buildIf)
        {
            return base.GetPlayList(folder, name, buildIf); 
        }
        
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Scanneur.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using pdb.util;
using pdb.podcast.DB;
using pdb.iit;
using pdb.util.RelativePath;

namespace pdb.podcast
{
    class Scanneur
    {
        private DirectoryInfo root;
        private Db db;
        private Loader loader;
        public Scanneur(string strRoot, Loader loader, Db db)
        {
            this.root = new DirectoryInfo(strRoot);
            this.loader = loader;
            this.db = db;
        }
        public void Scan()
        {
            scanDir(root);
        }

        private void scanDir(DirectoryInfo dir)
        {
            misc.log("scan " + dir.FullName);
            foreach (FileInfo f in dir.GetFiles())
            {
                if (f.IsMusic())
                {
                    if (db.get(f.FullName) == null)
                    {
                        var t = new TrackInfoItunes() { File = RelativeFileRegister.Get(f.FullName) };
                        loader.discover(t);
                        (t as pdb.it.TrackInfoItunes).build(t.TrackTrack);
                        t.setPub();


                        db.Check(t);
                    }
                }
            }
            foreach (DirectoryInfo sub in dir.GetDirectories())
            {
                scanDir(sub);
            }
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using iTunesLib;
using pdb.ordo;
using pdb.podcast.Build;
using pdb.util;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.obj;
using pdb.it;
using pdb.podcast.Albums;
using pdb.util.RelativePath;

namespace pdb.podcast
{
    public enum selectMode
    {
        none = 0,
        // standAlone = 1,
        simple = 2,
        serial = 3,
        histo = 4
    }

    public class TrackInfoItunes : pdb.it.TrackInfoItunes, IPub, ISelectable
    {
        public const string PUB_DATE_FORMAT_COMMENT = "yyyy/MM/dd HH:mm";
        public const string PUB_DATE_FORMAT_DB = "dd/MM/yyyy HH:mm";
        private static Loader loader;
        private static AlbumMgr albumMgr = AlbumMgr.Instance;
        private DateTime dtDisabled = DateTime.MaxValue;
        public DateTime Disabled { get { return dtDisabled; } }


        public override bool Equals(object obj)
        {
            var o = obj as TrackInfoItunes;
            if (o == null)
                return false;
            return DbId.Equals(o.DbId);
        }

        public new static Loader Loader { set { loader = value; } }
        private TrackAlbum _album;
        public TrackAlbum TrackAlbum
        {
            get
            {
                return _album;
            }
            set
            {
                _album = value;
            }
        }

        public ConfAlbum ConfAlbum
        {
            get
            {
                if (_album != null)
                    return _album.ConfAlbum;
                return ConfAlbums.Main;
            }
        }

        public override string AlbumKey { get { var alb = TrackAlbum; if (alb == null) return base.AlbumKey; return alb.AlbumKey; } }
        public override string Album
        {
            get
            {
                if (string.IsNullOrEmpty(album) && _album != null)
                    return _album.Album;
                return album;
            }
            set
            {
                base.Album = value;
            }
        }

        public int AlbumRating { get { return TrackAlbum.AlbumRating; } }
        //  private bool ratingComputed; public bool RatingComputed { get { return ratingComputed; } }

        //public override void setAlbum(string album)
        //{
        //    TrackInfoItunes.AlbumMgr.setAlbum(this, album);
        //}

        public DateTime getDate()
        {
            return TrackAlbum.ConfAlbum.checkPub ? Pub : Pub2;
        }

        private void import(IITFileOrCDTrack native)
        {
            misc.log("import {0}", this);
            native.Name = name;

            native.AlbumRating = AlbumRating;
            if (rating != AlbumRating)
                native.Rating = rating;
            native.PlayedDate = this.PlayedDate.ToUniversalTime();
            native.Enabled = this.Enabled;
            native.PlayedCount = this.playCount;
            var _comment = buildComment();
            if (!string.IsNullOrEmpty(_comment))
                native.Grouping = _comment;
            var _composer = buildComposer();
            if (!string.IsNullOrEmpty(_composer))
                native.Composer = _composer;

        }

        public string buildComment()
        {
            string comment = pub.ToString(PUB_DATE_FORMAT_COMMENT);
            if (pub2 > pub)
                comment = string.Format("{0}|{1}| {2}",
                    pub2.ToString(PUB_DATE_FORMAT_COMMENT),
                    pub.ToString(PUB_DATE_FORMAT_COMMENT),
                    (pub2 - pub).TotalDays.ToString("#00.#"));
            return comment;
        }

        public string buildComposer()
        {
            string comment = pub.ToString(PUB_DATE_FORMAT_COMMENT);
            //if (pub2 > pub)
            //    comment = string.Format("{0}|{1}", Pub2.ToString(PUB_DATE_FORMAT_COMMENT), Pub.ToString(PUB_DATE_FORMAT_COMMENT));
            return comment;
        }

        public void BuildComment()
        {
            var comment = buildComment();
            if (!string.IsNullOrEmpty(comment) && comment != Grouping)
            {
                //if (!string.IsNullOrEmpty(Grouping))
                //    File.AppendAllText("..\\groupingIni.txt", string.Format("{0};{1};{2}\r\n",DbId,Location,Grouping));
                Grouping = comment;
            }

        }

        public void BuildComposer()
        {
            var composer = buildComposer();
            //  Composer = composer;
            if (!string.IsNullOrEmpty(composer) && composer != Composer)
                Composer = composer;
        }

        public void import()
        {
            if (!isPresent())
                return;

            try
            {
                var native = TrackTrack;
                if (native == null)
                    native = Track;
                if (native == null)
                {
                    bgImport.add(new BgTaskImport(this));
                }
                else
                    import(native);

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public void merge()
        {
            if (!isPresent())
                return;
            bgImport.add(new BgTaskImport(this));
        }

        //public void import(TrackInfoItunes db)
        //{
        //    this._album = db._album;
        //    // this.albumRating = db.albumRating;
        //    this.rating = db.rating;
        //    //this.rare = db.rare;
        //    //this.info = db.info;
        //    this.playCount = db.playCount;
        //    this.PlayedDate = db.PlayedDate;
        //    this.enabled = db.enabled;
        //    present = true;
        //    db.present = true;

        //    import();
        //}

        private DateTime offset;
        public DateTime Offset
        {
            set
            {
                if (offset == DateTime.MinValue)
                    offset = value;
            }
            get { return offset; }
        }

        //public override bool Enabled
        //{
        //    get
        //    {
        //        if (_dbId == 1181)
        //        {
        //        }

        //        if (dtDisabled == DateTime.MaxValue)
        //            return true;

        //        if (_album != null
        //            && _album.ConfAlbum != null
        //            && _album.ConfAlbum.disabledForgot < DateTime.MaxValue)
        //        {
        //            if (dtDisabled < _album.ConfAlbum.disabledForgot)
        //                return true;
        //            else
        //                return false;
        //        }
        //        return base.Enabled;
        //    }
        //    //set
        //    //{
        //    //    if (enabled != value)
        //    //    {
        //    //        base.Enabled = value;
        //    //        if (!enabled)
        //    //        {
        //    //            dtDisabled = DateTime.Now;
        //    //        }
        //    //    }
        //    //}
        //}

        public bool BaseEnabled { get { return base.Enabled; } }


        public override IITFileOrCDTrack Track
        {
            get
            {
                if (track != null)
                    return track;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    // loader.resurrection(this);
                }
                return base.Track;
            }
        }

        public override IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (tracktrack != null)
                    return tracktrack;
                if (!present)
                {
                    if (!isPresent())
                        return new NoTrack(this);
                    //   loader.resurrection(this);
                }
                return base.TrackTrack;
            }
        }

        private static volatile object _lock = new object();
        private static int volumeMin = int.MinValue;
        public static int VolumeMin { set { volumeMin = value; } }
        protected static string defaultFolder;
        //private static bool _updateNative;
        //public static bool UpdateNative { get { return _updateNative; } set { _updateNative = value; } }
        public static string DefaultFolder
        {
            set
            {
                if (defaultFolder == null)
                {
                    defaultFolder = value;
                    if (!defaultFolder.EndsWith("\\"))
                        defaultFolder += ("\\");
                    defaultFolder += "Podcasts\\";
                }
            }
            get { return defaultFolder; }
        }

        private int _dbId;
        public int DbId { get { return _dbId; } set { if (_dbId <= 0) _dbId = value; } }

        /// <summary>
        /// Si Track doublon (genre podcast de voyage) id du podcast à l'origine
        /// </summary>
        private int parentId;

        public int ParentId { get { return parentId; } }

        private TrackInfoItunes parent;

        public bool HasParent { get { return parent != null; } }

        public TrackInfoItunes Parent { get { return parent; } set { parent = value; parentId = parent.DbId; } }

        public TrackInfoItunes Master
        {
            get
            {
                if (parent == null)
                    return this;
                return parent;
            }
        }

        //public override string Location
        //{
        //    get
        //    {
        //        if (parent == null)
        //            return location;
        //        if (true == FileRegister.Exist(location))
        //            return location;
        //        return parent.location;
        //    }

        //    set
        //    {
        //        base.Location = value;
        //    }
        //}

        //private static int NB = 0;
        //private int iddebug;

        public TrackInfoItunes()
        {
            _isPodCast = true;
            //NB++;
            //iddebug = NB;
        }
        public override int GetHashCode()
        {
            return DbId.GetHashCode();
        }
        //  public bool Deleted { get; set; }

        private static BackGroundTaskMgr bgMove;  //new BackGroundTaskMgr("Move"); 

        private SequentialDictString<LimitItem> listSelected = new SequentialDictString<LimitItem>();
        //public List<LimitItem> Providers { get { return listSelected; } }

        //  private SequentialDictString<LimitItem> listLoad0 = new SequentialDictString<LimitItem>();
        // private SequentialDictString<LimitItem> listStandAlone = new SequentialDictString<LimitItem>();
        // public List<LimitItem> Providers0 { get { return listLoad0; } }

        //private List<LimitItem> listLoadRecursif = new List<LimitItem>();
        //public List<LimitItem> ProvidersRecursif { get { return listLoadRecursif; } }

        //private List<LimitItem> listLoadGuest = new List<LimitItem>();
        //public List<LimitItem> ProvidersGuest { get { return listLoadGuest; } }



        /// <summary>
        /// Seule limite contenant le track
        /// </summary>
        //private LimitItem exclu;
        //public LimitItem Exclu { get { return exclu; } set { exclu = value; } }

        public void addPhase1(LimitItem item)
        {
            //var key = item.ID;
            //if (!listLoad0.ContainsKey(key))
            //    listLoad0.Add(key, item);
        }
        //public bool containsload(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listLoad0.ContainsKey(key);
        //}

        //public bool containsStandAlone(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listStandAlone.ContainsKey(key);
        //}

        //public bool containsSelect(LimitItem item)
        //{
        //    var key = item.ID;
        //    return listSelected.ContainsKey(key);
        //}
        //public bool isPreselected { get { return listLoad0.Count > 0; } }
        //public ICollection<LimitItem> Providers1 { get { return listStandAlone.Values; } }
        public ICollection<LimitItem> Providers { get { return listSelected.Values; } }
        public LimitItem Provider
        {
            get
            {

                if (listSelected.Count == 0)
                    return null;
                return listSelected.List[0];
            }
        }
        public string GetProvider()
        {
            var provider = Provider;
            if (provider == null)
                return "";
            return provider.ToString();
        }

        public void addRecursif(LimitItem item)
        {
            //if (!listLoadRecursif.Contains(item))
            //    listLoadRecursif.Add(item);
        }

        public void addGuest(LimitItem item)
        {
            //if (!listLoadGuest.Contains(item))
            //    listLoadGuest.Add(item);
        }

        public static TrackInfoItunes createCopy(TrackInfoItunes org)
        {
            var copy = org.MemberwiseClone() as TrackInfoItunes;
            copy.clearLists();
            return copy;
        }

        public void synch(TrackInfoItunes o)
        {
            _in = o._in;
            _out = o._out;
            pub = o.pub;
            Pub2 = o.pub2;
            if (!string.IsNullOrEmpty(Description))
                Description = o.Description;
            if (!string.IsNullOrEmpty(LongDescription))
                LongDescription = o.LongDescription;

        }

        const string REFONTE = "v1";
        public override void build(IITFileOrCDTrack track)
        {
            base.build(track);

            if (Strange)
                return;

            if (!track.Enabled)
            {
                if (dtDisabled == DateTime.MaxValue || dtDisabled == DateTime.MinValue)
                    dtDisabled = DateTime.Now;
            }

            TrackAlbum.AlbumRating = track.AlbumRating;
            // this.ratingComputed = track.ratingKind == ITRatingKind.ITRatingKindComputed;

#if MOVE
            var loc = track.Location;
            FileInfo file = new FileInfo(loc);
            if (loc.StartsWith("Y:"))
                return;
            string dest = "Y" + loc.Substring(1);


            try
            {
                misc.log("deplacer " + loc);
                string newDest = file.moveTree(dest, false);
                misc.log("-------> " + newDest);
                track.Location = newDest;
                //try
                //{
                //    File.Delete(loc);
                //}

                //catch (Exception del)
                //{

                //    misc.log(del.ToString());
                //}

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
#else

            if (!track.Podcast)
                return;
            //if (!isPodcast)
            //    return;

            duree = new util.timeSpan(Duration);

            CheckPlay(this);

            //if (track.PlayedCount > 0)
            //{
            //    played = markAsPlayed(Rating, PlayedDate);
            //}

            var loc = track.Location;
            //if (loc.ToUpper().Contains("FABRIQUE"))
            //{
            //    int toto = 0; 
            //}
            bool target = true;
            var cuDtFileFormat = new DateTimeFormatInfo();
            cuDtFileFormat.FullDateTimePattern = "yyyy.MM.dd_HH.mm";
            string[] tab = loc.Split('_');
            var count = tab.GetLength(0);
            if (count >= 2)
            {
                var part = tab[0] + "_" + tab[1];
                DateTime dtFile;
                bool fileIsDate = DateTime.TryParse(part, cuDtFileFormat, DateTimeStyles.None, out dtFile);
                target = !fileIsDate;
            }


            //bool target = loc.ToUpper().Contains(@"D:\ZIQUE\PODCASTS\LA FABRIQUE DE L") && loc.ToUpper().Contains("HISTOIRE");

            try
            {

                Pub = track.ReleaseDate;

                var cuDtFormat = new DateTimeFormatInfo();
                cuDtFormat.FullDateTimePattern = "yyyy/MM/dd";

                var cuDtFormat2 = new DateTimeFormatInfo();
                cuDtFormat2.FullDateTimePattern = "yyyy/MM/dd HH:mm";

                if (pub > MIN)
                {
                    string commentByReleaseDate = pub.ToString(cuDtFormat2.FullDateTimePattern);
                    if (Grouping != commentByReleaseDate)
                    {
                        misc.log("chgt Comment à partir de releaseDate {0} de {1} vers {2} {3}", pub, Comment, commentByReleaseDate, this);
                        Grouping = commentByReleaseDate;
                    }

                    return;
                }

                // ici pas de release Date

                string comment = track.Grouping;

                try
                {
                    string partDate = comment.Split(' ')[0];
                    DateTime dtComment = DateTime.MinValue;

                    bool dtCommentBuild = false;

                    dtCommentBuild = DateTime.TryParse(partDate, cuDtFormat, DateTimeStyles.None, out dtComment);

                    bool dtCommentBuild2 = false;
                    if (dtCommentBuild)
                        dtCommentBuild2 = DateTime.TryParse(comment, cuDtFormat2, DateTimeStyles.None, out dtComment);


                    //if (dtComment.DayOfYear > 1)
                    //    return;

                    Regex reg = new Regex(@"(\d{2}.\d{2}.\d{4})");
                    string description = track.Description;

                    if (string.IsNullOrEmpty(description))
                        description = "";

                    DateTime dtDesc = DateTime.MinValue;
                    if (reg.IsMatch(description))
                    {
                        string strDescriptionDate = reg.Match(description).Groups[1].Value;

                        dtDesc = Convert.ToDateTime(strDescriptionDate);
                    }

                    if (dtDesc > DateTime.MinValue)
                    {
                        string newComment = dtDesc.ToString(cuDtFormat2.FullDateTimePattern);
                        if (newComment != track.Grouping)
                        {
                            if (dtCommentBuild2 && dtComment.Minute != 0)
                                return;
                            misc.log("chgt Comment à partir de description {0} de {1} vers {2} {3}", description, comment, newComment, this);
                            track.Grouping = newComment;
                        }
                    }
                    else if (dtCommentBuild2)
                    {

                    }






                }
                catch (Exception ex)
                {
                    misc.logError("impossible de gérer " + this, ex);
                }
            }
            finally
            {

                //if (target)
                //{

                //    FileInfo file = new FileInfo(loc);
                //    DirectoryInfo dirTrack = file.Directory;
                //    DirectoryInfo dirPodcast = dirTrack.Parent;
                //    if (!dirPodcast.Name.Equals(REFONTE))
                //    {
                //        DirectoryInfo dirV1 = new DirectoryInfo(dirPodcast.FullName + Path.DirectorySeparatorChar + REFONTE);
                //        if (!dirV1.Exists)
                //            dirV1.Create();

                //        string dest = dirV1.FullName + Path.DirectorySeparatorChar + dirTrack.Name + Path.DirectorySeparatorChar + file.Name;  // loc.Replace(@"D:\", @"E:\");

                //        string dirDest = Path.GetDirectoryName(dest);
                //        string fileName = Path.GetFileName(dest);
                //        fileName = pub.ToString("yyyy.MM.dd_HH.mm") + "_" + fileName;

                //        dest = dirDest + Path.DirectorySeparatorChar + fileName;
                //        try
                //        {
                //            misc.log("deplacer " + loc);
                //            string newDest = file.copyTree(dest, null);
                //            misc.log("-------> " + newDest);
                //            track.Location = newDest;
                //            try
                //            {
                //                File.Delete(loc);
                //            }

                //            catch (Exception del)
                //            {

                //                misc.log(del.ToString());
                //            }

                //        }
                //        catch (Exception ex)
                //        {
                //            misc.log(ex.ToString());
                //        }
                //    }
                //}

            }
#endif

        }


        //private static IDictionary<int, DateTime> maxPlayed = new Dictionary<int, DateTime>();
        //public static IDictionary<int, DateTime> MaxPlayed { set { maxPlayed = value; } }

        private static DateTime playedLevel = DateTime.MinValue;
        public static DateTime PlayedLevel { set { playedLevel = value; } }
        //public static bool markAsPlayed(int rating, DateTime date)
        //{
        //    if (maxPlayed.ContainsKey(rating))
        //        return date > maxPlayed[rating];
        //    return true;
        //}

        public bool calcEnabled()
        {
            if (dtDisabled == DateTime.MaxValue)
                return true;
            var conf = ConfAlbum;
            if (dtDisabled > conf.forgotMax)
                return false;

            return dtDisabled < conf.forgotDisabled;
        }

        public static void CheckPlay(TrackInfoItunes track)
        {
            var played = isPlayed(track);

            track.played = played;
            track.enabled = track.calcEnabled();
        }


        private static bool isPlayed(TrackInfoItunes track)
        {
            var playDate = track.PlayedDate;
            if (track.playCount <= 0)
            {
                if (playDate == DateTime.MinValue)
                    return false;
                if (playedLevel == DateTime.MinValue || playDate >= playedLevel)
                    return false;
                // pour les vieux on prend quand même en compte la date de dernière lecture
                return true;
            }


            var conf = track.ConfAlbum;
            var playedDate = track.PlayedDate;
            if (playedDate > conf.forgotMax)
                return true;

            if (track.isConcernedBySelection)
            {
                if (playedDate < conf.forgotShort)
                    return false;
            }
            else
            {
                if (playedDate < conf.forgot)
                    return false;
            }
            return true;

        }


        public string ShortName { get { return file.file; } } // { get { return getShortName(location); } }
        public static string getShortName(string location)
        {
            string folder = "";
            return RelativeFile.getRelativeFile(location, ref folder);
        }
        //return misc.getShortPath(location, Exporter.PODCASTS, Exporter.ZIQUE, "Y:"); }

        private string hibernateLocation;
        public string HibernateLocation { get { return hibernateLocation; } set { hibernateLocation = value; } }


        public bool isPresent()
        {
            if (!string.IsNullOrEmpty(hibernateLocation))
                return FileRegister.ExistNow(hibernateLocation);
            return file.ExistsNow;
            //  FileRegister.ExistNow(location);

            //var path = location;
            //if (_extern)
            //{
            //    var shortName = ShortName;
            //    path = TrackInfoItunes.DefaultFolder + shortName;
            //}
            //if (FileRegister.Exist(location))
            //{
            //    location = path;
            //    return true;
            //}
            //return false;
        }

        private double note = int.MaxValue;
        public double Note { get { return note; } set { note = value; } }

        public void build(XmlReader reader)
        {

            file = RelativeFileRegister.Get(reader.GetAttribute("f"));
            //if (!string.IsNullOrEmpty(location))
            //{
            //    if (Path.IsPathRooted(location))
            //    {
            //    }
            //    else
            //        location = TrackInfoItunes.DefaultFolder + location;

            //    FileRegister.Push(location);
            //}
            url = reader.GetAttribute("url");
            hibernateLocation = reader.GetAttribute("hl");

            string album = reader.GetAttribute("alb");

            if (!string.IsNullOrEmpty(album))
                this.album = album;

            name = reader.GetAttribute("name");

            var str = reader.GetAttribute("pub");
            if (!string.IsNullOrEmpty(str))
                Pub = Convert.ToDateTime(str);

            str = reader.GetAttribute("pub2");
            if (!string.IsNullOrEmpty(str))
                Pub2 = Convert.ToDateTime(str);
            else
                Pub2 = Pub;

            str = reader.GetAttribute("date");
            if (!string.IsNullOrEmpty(str))
            {
                // playCount = 1;
                PlayedDate = Convert.ToDateTime(str);
            }

            str = reader.GetAttribute("nbr");
            if (!string.IsNullOrEmpty(str))
            {
                playCount = Convert.ToInt16(str);
            }

            str = reader.GetAttribute("albumRating");
            if (!string.IsNullOrEmpty(str))
                TrackAlbum.AlbumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                rating = Convert.ToInt32(str);

            if (TrackAlbum.AlbumRating > 0 && rating == 0)
                rating = TrackAlbum.AlbumRating;

            str = reader.GetAttribute("id");
            _dbId = Convert.ToInt32(str);

            str = reader.GetAttribute("pid");
            if (!string.IsNullOrEmpty(str))
                parentId = Convert.ToInt32(str);

            //if ("y" == reader.GetAttribute("rare"))
            //    TrackAlbum.Rare = true;
            //if ("y" == reader.GetAttribute("info"))
            //    TrackAlbum.Info = true;
            if ("y" == reader.GetAttribute("disabled"))
            {
                dtDisabled = DateTime.MinValue;
            }
            else
            {
                str = reader.GetAttribute("dd");
                if (string.IsNullOrEmpty(str))
                {
                    dtDisabled = DateTime.MaxValue;
                }
                else
                {
                    if ("y" == str)
                        dtDisabled = DateTime.MinValue;
                    else
                        dtDisabled = Convert.ToDateTime(str);
                }
            }
            str = reader.GetAttribute("s");
            if (!string.IsNullOrEmpty(str))
                _size = Convert.ToInt64(str);
            else
                _size = -1;

            str = reader.GetAttribute("d");
            if (!string.IsNullOrEmpty(str))
                Duree = timeSpan.FromSecondes(Convert.ToInt32(str));



            str = reader.GetAttribute("add");
            if (!string.IsNullOrEmpty(str))
                added = Convert.ToDateTime(str);
            str = reader.GetAttribute("add1");
            if (!string.IsNullOrEmpty(str))
                AddedFirst = Convert.ToDateTime(str);

            if (addedFirst == DateTime.MinValue)
                addedFirst = added;

            Description = reader.GetAttribute("desc");
            LongDescription = reader.GetAttribute("ldesc");
            Comment = reader.GetAttribute("comment");


            str = reader.GetAttribute("note");
            if (!string.IsNullOrEmpty(str))
                note = Convert.ToDouble(str);

            CheckPlay(this);

        }

        /// <summary>
        /// Merge du track db (this) avec celui récupéré par itunes
        /// </summary>
        /// <param name="native"></param>
        public void merge(TrackInfoItunes native)
        {
            if (native == this)
                return;
            if (file == null || string.IsNullOrEmpty(file.file))
                file = native.file;

            string album = native.Album;

            name = native.Name;

            PlayedDate = native.PlayedDate;

            playCount = native.PlayCount;

            rating = native.Rating;


            // enabled = native.enabled;

            Duration = native.Duration;

            if (native.Added > DateTime.MinValue)
                added = native.Added;

            if (addedFirst == DateTime.MinValue)
                addedFirst = added;

            if (!string.IsNullOrEmpty(native.Description))
                Description = native.Description;
            if (!string.IsNullOrEmpty(native.LongDescription))
                LongDescription = native.LongDescription;
            if (string.IsNullOrEmpty(Comment))
                Comment = native.Comment;
            // détection des déselections manuelles
            if (Enabled && !native.Enabled)
            //if (enabled && !native.enabled)
            {
                //  enabled = native.enabled;
                var o = native.dtDisabled;
                if ((dtDisabled == DateTime.MaxValue) || (o > dtDisabled && o < DateTime.MaxValue))
                    dtDisabled = o;
            }


            CheckPlay(this);

        }

        public void readStat(XmlReader reader)
        {
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                _in = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                _out = Convert.ToDateTime(str);
        }

        public bool SelectedByDb { get { return Selected; } }// || _in > _out; } }

        public void readStatGlobal(XmlReader reader)
        {
            DateTime oin = DateTime.MinValue;
            DateTime oout = DateTime.MinValue;
            var str = reader.GetAttribute("in");
            if (!string.IsNullOrEmpty(str))
                oin = Convert.ToDateTime(str);

            str = reader.GetAttribute("out");
            if (!string.IsNullOrEmpty(str))
                oout = Convert.ToDateTime(str);

            if (oin > oout)
            {
                //sélectionné
                _gout = DateTime.MaxValue;
                return;
            }

            if (oout > _gout)
                _gout = oout;
        }

        //public void consolidStat()
        //{
        //    if (_in > DateTime.MinValue)
        //    {
        //        if (_in < _gin || _gin == DateTime.MinValue)
        //            _gin = _in; 
        //    }

        //    if (_out > _gout)
        //        _gout = _out; 
        //}



        public override void build(XmlNode xTrack)
        {
            TrackInfoItunes copy = null;
            if (loader.Import || loader.Slave)
            {
                copy = createCopy(this);
            }

            base.build(xTrack);

            if (!isPodcast)
                return;
            if (Strange)
                return;
            if (this._dbId == 1181)
            {
            }

            if (!base.Enabled)
            {
                if (dtDisabled == DateTime.MaxValue || dtDisabled == DateTime.MinValue)
                    dtDisabled = DateTime.Now;
            }

            var album = TrackAlbum;
            if (album == null)
            {
                album = albumMgr.Get(this.Album);
            }


            //  bool ratingComputed = false;
            bool albumRatingComputed = false;
            //if (Name.Contains("Aubenas"))
            //{
            //    int toto = 0;
            //}
            //if (!isPodcast)
            //    return;
            //if (Strange)
            //    return;
            string key = "";

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    //if (key == "Rating Computed")
                    //    ratingComputed = true;
                    if (key == "Album Rating Computed")
                        albumRatingComputed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(value))
                    continue;
                switch (key)
                {
                    case "Date Added": added = Convert.ToDateTime(value); AddedFirst = added; break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Release Date": pub = Convert.ToDateTime(value).truncateToMinute(); break; //DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;
                    case "Album Rating": if (album != null) album.AlbumRating = Convert.ToInt32(value); break;
                }

            }
            // gestion des rating
            if (albumRatingComputed & album != null)
                album.AlbumRating = 0;

            duree = new util.timeSpan(Duration);


            bool change = false;
            if (copy != null)
            {
                if (copy._album != null)
                    _album = copy._album;
                if (!string.IsNullOrEmpty(copy.name) && copy.name != name)
                {
                    log.log("import cause name '{0}' '{1}' {2}", name, copy.name, this);
                    name = copy.name;
                    change = true;
                }

                if (PlayedDate != copy.PlayedDate)
                {
                    log.log("import cause playDate '{0}' '{1}' {2}", PlayedDate, copy.PlayedDate, this);
                    PlayedDate = copy.PlayedDate;
                    change = true;
                }
                if (playCount != copy.playCount)
                {
                    log.log("import cause playCount '{0}' '{1}' {2}", playCount, copy.playCount, this);
                    change = true;
                    playCount = copy.playCount;
                }
                // albumRating = copy.albumRating;
                //if (base.Enabled != copy.BaseEnabled)
                //{
                //    log.log("import cause enabled '{0}' '{1}' {2}", enabled, copy.enabled, this);
                //    enabled = copy.enabled;
                //    change = true;
                //}

                if (rating != copy.rating)
                {
                    log.log("import cause rating '{0}' '{1}' {2}", rating, copy.rating, this);
                    rating = copy.rating;
                    change = true;
                }
                if (pub2 != copy.pub2)
                {
                    log.log("import cause pub2 '{0}' '{1}' {2}", pub2, copy.pub2, this);
                    pub2 = copy.pub2;
                    change = true;
                }


                var comment = buildComment();
                if (!string.IsNullOrEmpty(comment) && comment != Grouping)
                {
                    log.log("import cause comment '{0}' '{1}' {2}", Grouping, comment, this);
                    change = true;
                }


                //var composer = buildComposer();
                //if (!string.IsNullOrEmpty(composer) && composer != Composer)
                //{
                //    log.log("import cause composer '{0}' '{1}' {2}", Composer, composer, this);
                //    change = true;
                //}

                //var _comment = buildComment();
                //if (_comment != Comment)
                //    change = true;

                Duration = copy.Duration;
                duree = copy.duree;


            }
            setPub();

            CheckPlay(this);

            if (change)
            {
                import();
            }
        }



        //private PubLoader pubLoader;
        //internal PubLoader PubLoader { get { if (pubLoader == null) pubLoader = new PubLoader(this); return pubLoader; } }
        internal PubLoader PubLoader { get { return new PubLoader(this); } }

        public void setPub()
        {
            PubLoader.setPub();
        }

        public static DateTime MIN = new DateTime(1970, 1, 1);
        #region move verspubLoader

        //
        //private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        //private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        //private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");

        //private string getFileNameCmp(string comment)
        //{
        //    string fileName = Path.GetFileNameWithoutExtension(location);

        //    if (fileName.Contains(" "))
        //    {
        //        var tab = fileName.Split(' ');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Contains("_"))
        //    {
        //        var tab = fileName.Split('_');
        //        fileName = tab[tab.GetLength(0) - 1];
        //    }

        //    if (fileName.Length > 3)
        //        return comment;

        //    int nb = 0;
        //    bool isNum = Int32.TryParse(fileName, out nb);

        //    if (!isNum)
        //        return comment;

        //    while (fileName.Length < 3)
        //    {
        //        fileName = "0" + fileName;
        //    }
        //    return comment + "_" + fileName;
        //}
        //private void checkDate1(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex1.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex1.Match(info);
        //            string strDate = m.Groups[1].Value;
        //            DateTime dt = Convert.ToDateTime(strDate);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate2(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex2.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            DateTime dt = new DateTime(year, month, day);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        //private void checkDate3(string info)
        //{
        //    if (pub > MIN)
        //        return;
        //    if (pub < MIN)
        //        pub = MIN;

        //    if (regex3.IsMatch(info))
        //    {
        //        try
        //        {
        //            Match m = regex2.Match(info);
        //            int year = Convert.ToInt16(m.Groups[1].Value);
        //            int month = Convert.ToInt16(m.Groups[2].Value);
        //            int day = Convert.ToInt16(m.Groups[3].Value);
        //            int hh = Convert.ToInt16(m.Groups[4].Value);
        //            int mm = Convert.ToInt16(m.Groups[5].Value);

        //            DateTime dt = new DateTime(year, month, day, hh, mm, 0);
        //            pub = dt;
        //        }
        //        catch { }
        //    }
        //}

        #endregion

        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{
        //    this.track = track;
        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    this._isPodCast = track.Podcast;
        //    this.playedDate = track.PlayedDate;
        //    this.location = track.Location;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.played = track.PlayedCount > 0;
        //    this.pub = track.ReleaseDate;

        //    checkDate1(name);
        //    checkDate2(name);

        //    if (!string.IsNullOrEmpty(location))
        //    {
        //        string fileName = Path.GetFileName(location);
        //        checkDate1(fileName);
        //        checkDate2(fileName);
        //    }

        //    if (pub <= MIN)
        //    {
        //        if (year > 1970)
        //        {
        //            DateTime dtYear = new DateTime(year, 1, 1);
        //            pub = dtYear;
        //        }
        //    }


        //    this.added = track.DateAdded;
        //    if (added < MIN) added = MIN;

        //    // DateTime dt_ = pub;
        //    if (pub <= MIN)
        //        pub = added;
        //    string comment = pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
        //    if (track.Comment != comment)
        //        track.Comment = comment;

        //}




        //public int TrackId { get { return track.trackID; } }
        //public int ID { get { return track.TrackDatabaseID; } }

        //public IITFileOrCDTrack Track { get { return track; } }


        #region ITrackNative Membres




        /// <summary>
        /// Date de publication
        /// </summary>
        private DateTime pub;
        private DateTime pub2;
        public DateTime Pub
        {
            get
            {
                return pub;
            }
            set
            {
                pub = value;
                if (pub2 < pub)
                    pub2 = pub;
            }
        }

        public DateTime Pub2
        {
            get { return pub2; }
            set
            {
                if (value > pub)
                    pub2 = value;
                else
                    pub2 = pub;

            }
        }


        /// <summary>
        /// date d'ajout
        /// </summary>
        private DateTime added;
        new public DateTime Added { get { return added; } }

        /// <summary>
        /// Date de premier ajout; 
        /// </summary>
        private DateTime addedFirst;
        public DateTime AddedFirst
        {
            get { return addedFirst; }

            set
            {
                if (addedFirst == DateTime.MinValue)
                    addedFirst = value;
            }
        }

        private DateTime _in;
        public DateTime In { get { return _in; } }

        private DateTime _out;
        public DateTime Out { get { return _out; } }

        //private DateTime _gin;
        //public DateTime Gin { get { return _gin; } }

        /// <summary>
        /// Dernier out global (MaxValue si encore sélectionné)
        /// </summary>
        private DateTime _gout;
        public DateTime Gout { get { return _gout; } set { _gout = value; } }

        public void checkInOut()
        {
            DateTime now = DateTime.Now;
            if (Selected)
            {
                if (_in == DateTime.MinValue || _out > _in)
                    _in = now;
            }
            else
            {
                if (_in > DateTime.MinValue)
                {
                    if (_out == DateTime.MinValue || _in > _out)
                        _out = now;
                }
            }
        }


        public albumSpec Specif { get { return TrackAlbum.Specif; } }

        /// <summary>
        /// Podcast de type info
        /// </summary>
        // private bool info;

        public bool Info
        {
            get { return TrackAlbum.Info; }
        }

        /// <summary>
        /// Podcast rare (moins de trois fois par semaine)
        /// </summary>
        //  private bool rare;
        public bool Rare
        {
            get { return TrackAlbum.Rare; }
        }
        public bool RareEffect
        {
            get { return TrackAlbum.RareEffect; }
        }

        public bool Actu
        {
            get { return TrackAlbum.Actu; }
        }

        public bool Courant
        {
            get { return TrackAlbum.Courant; }
        }

        public bool Open { get { return TrackAlbum.Open; } }
        public bool Recent { get { return TrackAlbum.Recent; } }
        public bool UnAn { get { return TrackAlbum.UnAn; } }

        private bool played;
        public override bool Played { get { return played; } }
        public bool BasePlayed { get { return base.Played; } }

        //private bool globalSelected;
        //public bool GlobalSelected { get { return globalSelected; } set { globalSelected = value; } }

        //private string feed;
        //public string Feed { get { return feed; } set { feed = value; } }

        private selectMode selected;
        // private bool inJournal = false;

        //public bool FreeInJournal { get { return Selected && !inJournal; } }
        //public void markInJournal() { inJournal = true; }
        //    public bool StandAlone { get { return selected > selectMode.none; } }
        public bool Selected { get { return selected >= selectMode.simple; } }
        public bool Histo { get { return selected == selectMode.histo; } }
        public bool Serial { get { return selected == selectMode.serial; } }
        // public selectMode Select { get { return selected; } }


        public void clearLists()
        {
            selected = selectMode.none;
            //  exclu = null;
            //  inJournal = false;
            listSelected.Clear();// = new SequentialDictString<LimitItem>();
            //listLoad0 = new SequentialDictString<LimitItem>();
            //listStandAlone = new SequentialDictString<LimitItem>();
            //indexRoot = -1;
            offset = default(DateTime);
            //listLoadGuest.Clear();
            //listLoadRecursif.Clear();

        }
        private string pubInfoShort() { return pub.ToString("dd.MM.yy"); }
        public static string pubInfoShort(DateTime pub) { return pub.ToString("dd.MM.yy"); }
        private string getDayOfWeek()
        {
            var strDayOfWeek = "";
            switch (pub.DayOfWeek)
            {
                case DayOfWeek.Friday:
                strDayOfWeek = "v";
                break;
                case DayOfWeek.Monday:
                strDayOfWeek = "l";
                break;
                case DayOfWeek.Saturday:
                strDayOfWeek = "s";
                break;
                case DayOfWeek.Sunday:
                strDayOfWeek = "d";
                break;
                case DayOfWeek.Thursday:
                strDayOfWeek = "j";
                break;
                case DayOfWeek.Tuesday:
                strDayOfWeek = "ma";
                break;
                case DayOfWeek.Wednesday:
                strDayOfWeek = "me";
                break;
                default:
                break;
            }

            return strDayOfWeek;
        }

        // private static Regex regInfoShort = new Regex(@".+(\d\d\.\d\d\.\d\d)");
        public void updateNative()
        {
            PubLoader.setPub();


            int volume = Volume;
            if (Album.Contains("RFI"))
            {
                if (volume != -20)
                    Volume = -20;
            }
            else
            {
                if (volume < volumeMin)
                    Volume = volumeMin;
            }


            if (pub > MIN)
            {

                var target = NameWithDate;
                if (!target.Equals(Name))
                    Name = target;
                BuildComment();
                BuildComposer();
                return;

                //string infoShort = pubInfoShort();
                //string infoPubName = pub.ToString("dd.MM.yyyy");
                //string infoPubName2 = pub.ToString("dd/MM/yyyy");
                //string infoPubName3 = pub.ToString("dd/MM/yy");
                //string infoYear = Year.ToString();
                //if (pub.DayOfYear == 1)
                //{
                //    infoPubName = pub.Year.ToString();
                //    infoPubName2 = infoPubName;
                //    infoPubName3 = infoPubName;
                //    infoShort = infoPubName;
                //}

                //string name = Name;
                //string str = name;

                //while (str.Contains("  "))
                //    str = str.Replace("  ", " ");

                //while (str.Contains(infoShort))
                //    str = str.Replace(infoShort, "");
                //while (str.Contains(infoPubName))
                //    str = str.Replace(infoPubName, "");
                //while (str.Contains(infoPubName2))
                //    str = str.Replace(infoPubName2, "");
                //while (str.Contains(infoPubName3))
                //    str = str.Replace(infoPubName3, "");

                //str = str.Trim();

                ////if (regInfoShort.IsMatch(str))
                ////{
                ////    var strdate = regInfoShort.Match(str).Groups[1].Value;
                ////    str = str.Replace(strdate, "");
                ////}



                ////Michel Rocard (1/5) l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l 17.06.13 l
                //var strDayOfWeek = getDayOfWeek();
                //var s1 = strDayOfWeek + " ";
                //strDayOfWeek = " " + strDayOfWeek;

                //while (str.EndsWith(strDayOfWeek))
                //    str = str.Remove(str.Length - strDayOfWeek.Length - 1);
                ////while (str.EndsWith(s1))
                ////    str = str.Remove(str.Length - s1.Length);

                ////if (str.Contains(infoPubName))
                ////    str = str.Replace(infoPubName, infoShort);
                ////else if (name.Contains(infoPubName2))
                ////    str = str.Replace(infoPubName2, infoShort);

                ////else
                ////{
                ////    if (!str.Contains(infoShort))
                ////    {
                ////        str = str + " " + infoShort;
                ////    }
                ////    else
                ////    {
                ////        if (Year > 1980 && str.Contains(infoYear))
                ////            str = str.Replace(infoYear, "").Trim();
                ////    }
                ////}
                //var strBUG = "30.12.99";
                //if (str.Contains(strBUG))
                //    str = str.Replace(strBUG, "");

                //while (str.Contains("  "))
                //    str = str.Replace("  ", " ");

                //str = str.Trim();

                //str += " ";
                //str += infoShort;


                //str += strDayOfWeek;

                //if (!str.Equals(name))
                //    Name = str;

                //BuildComment();
                //BuildComposer();
            }
        }
        // private LimitItem provider; 
        public void select(selectMode value, LimitItem limit)
        {

            var key = limit.ID;

            if (!listSelected.ContainsKey(key))
                listSelected.Add(key, limit);



            if (selected == value)
                return;

            selected = value;
            //if (isPresent() && !present)
            //{
            //    // loader.resurrection(this);
            //}




        }


        #endregion

        public override string ToString()
        {
            int level = Rating / 20;
            string strPub = pub > MIN ? pub.ToShortDateString() : "";
            // string strYear = Year > 0 ? Year.ToString() : "";
            var strAlbum = "";
            if (_album != null)
                strAlbum = Album;
            var strNote = "";
            if (note < int.MaxValue)
                strNote = note.ToString("0.##");
            return string.Format("{0} {1} {2} {3} {4} {5}", level, strNote, strAlbum, name, strPub, duree);
            // return level.ToString() + " " + strAlbum + " " + Name + " " + strYear + " " + strPub;
        }

        public void copy(string ziqueDest, string log)
        {

            if (string.IsNullOrEmpty(this.file.file))
                return;
            var location = this.file.getPath();
            FileInfo file = new FileInfo(location);
            DirectoryInfo dir = file.Directory;
            if (file.Exists)
            {
                string strPub1 = pub.ToString("dd.MM.yyyy");
                string strPub2 = pub.ToString("yy.MM.dd");

                string fileName = Path.GetFileName(location);

                if (pub > MIN && !fileName.StartsWith(strPub1) && !fileName.StartsWith(strPub2))
                    fileName = strPub2 + "_" + fileName;

                string strDir = dir.Name;
                if (!string.IsNullOrEmpty(Album))
                    strDir = Album;



                string dest = ziqueDest + Path.DirectorySeparatorChar + strDir + Path.DirectorySeparatorChar + fileName;
                misc.log(" {0} {1} à copier vers {2}", log, location, dest);
                try
                {
                    string newDest = file.copyTree(dest, false);

                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public void move(string ziqueOrg, string ziqueDest, DateTime limit)
        {
            if (pub >= limit)
                return;

            if (file == null || string.IsNullOrEmpty(file.file))
                return;
            var location = file.getPath(); 
            FileInfo f = new FileInfo(location);
            DirectoryInfo dir = f.Directory;
            if (f.Exists)
            {
                if (location.StartsWith(ziqueOrg + @"Podcasts"))
                {
                    misc.log(" à suprimer" + location);
                    string dest = location.Replace(ziqueOrg, ziqueDest);

                    string dirDest = Path.GetDirectoryName(dest);
                    string fileName = Path.GetFileName(dest);
                    fileName = pub.ToString("yy.MM.dd_HH.mm") + "_" + fileName;

                    dest = dirDest + Path.DirectorySeparatorChar + fileName;
                    try
                    {
                        string newDest = f.copyTree(dest, false);
                        if (bgMove == null)
                        {
                            lock (_lock)
                            {
                                if (bgMove == null)
                                    bgMove = BackGroundTaskMgr.getMgrlarge("Move");
                            }
                        }
                        //  file.CopyTo(dest, true);
                        bgMove.add(new BgTaskCopy(this, location, newDest));
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }
            }


        }

        private class BgTaskCopy : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskCopy(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Location = value;

                    misc.log("copie effectu�e " + value);
                    try
                    {
                       System.IO.File.Delete(Desc);
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible de supprimer " + Desc + " " + ex.ToString());
                    }
                    success = true;
                }
                catch (Exception e)
                { misc.log("NIET " + e.Message); }

                if (!success && info.Track != null)
                {
                    //misc.log("invalidation track " + info);
                    ////  info.track = null;
                }

            }
        }



        DateTime IPub.Pub
        {
            get
            {
                return pub;
            }
            set
            {
                this.Pub = value;
            }
        }
        //DateTime IPub.Pub2
        //{
        //    get
        //    {
        //        return pub2;
        //    }
        //    set
        //    {
        //        pub2 = value;
        //    }
        //}

        string IPub.Comment
        {
            get
            {
                return Comment;
            }
            //set
            //{
            //    if (string.IsNullOrEmpty(this.Grouping))
            //        setGrouping(this.Comment, true);
            //    Comment = value;
            //}
        }

        string IPub.Name
        {
            get { return Name; }
        }

        string IPub.Location
        {
            get { return file.file; }
        }

        int IPub.Year
        {
            get { return Year; }
        }

        DateTime IPub.Added
        {
            get
            {
                return added;
            }
            set
            {
                added = value;
            }
        }
        DateTime IPub.Offset { get { return offset; } }
        private pdb.util.timeSpan duree;
        public pdb.util.timeSpan Duree
        {
            get
            {

                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
                return duree;
            }
            private set
            {
                duree = value;
                if (base.Duration.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
            }
        }

        static Regex regDeltaPub = new Regex(@"¤[\d,]+$");
        static Regex regDeltaPub2 = new Regex(@"[\d,]+°$");

        static Regex regNbRead = new Regex(@"¤+$");

        public static string getLogicalExternName(string t, DateTime pub)
        {
            if (string.IsNullOrEmpty(t))
                return "";
            t = t.Trim();
            var strBUG = "30.12.99";
            if (t.Contains(strBUG))
                t = t.Replace(strBUG, "").Trim();
            //var tab = t.Split((char)1); 
            //t = tab[0]; 
            while (true)
            {
                var t0 = t;
                while (regNbRead.IsMatch(t))
                    t = regNbRead.Replace(t, "").Trim();
                if (regDeltaPub.IsMatch(t))
                {
                    t = regDeltaPub.Replace(t, "").Trim();
                }
                else if (regDeltaPub2.IsMatch(t))
                {
                    t = regDeltaPub2.Replace(t, "").Trim();
                }

                var strPub = pub.ToString("dd.MM.yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pub.ToString("dd/MM/yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pub.ToString("dd/MM/yy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pubInfoShort(pub);
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                if (t.EndsWith("-"))
                    t = t.Remove(t.Length - 1).Trim();

                strPub = pub.ToString("yy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();

                strPub = pub.ToString("yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();

                if (t.EndsWith("20"))
                    t = t.Remove(t.Length - "20".Length).Trim();

                if (t == t0)
                    break;
            }

            while (t.Contains("  "))
                t = t.Replace("  ", " ");



            return t;
        }

        public string getLogicalName(string t)
        {
            t = t.Trim();
            var strBUG = "30.12.99";
            if (t.Contains(strBUG))
                t = t.Replace(strBUG, "").Trim();
            //var tab = t.Split((char)1); 
            //t = tab[0]; 
            while (true)
            {
                var t0 = t;
                while (regNbRead.IsMatch(t))
                    t = regNbRead.Replace(t, "").Trim();

                if (regDeltaPub.IsMatch(t))
                {
                    t = regDeltaPub.Replace(t, "").Trim();
                }
                else if (regDeltaPub2.IsMatch(t))
                {
                    t = regDeltaPub2.Replace(t, "").Trim();
                }
                if (pub2 > pub)
                {
                    var strD = (pub2 - pub).TotalDays.ToString("0.#");
                    if (t.EndsWith(strD))
                        t = t.Remove(t.Length - strD.Length).Trim();

                }

                var sw = getDayOfWeek();
                if (t.EndsWith(sw))
                    t = t.Remove(t.Length - sw.Length).Trim();
                var strPub = pub.ToString("dd.MM.yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pub.ToString("dd/MM/yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pub.ToString("dd/MM/yy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                strPub = pubInfoShort();
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();
                if (t.EndsWith("-"))
                    t = t.Remove(t.Length - 1).Trim();

                strPub = pub.ToString("yy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();

                strPub = pub.ToString("yyyy");
                if (t.EndsWith(strPub))
                    t = t.Remove(t.Length - strPub.Length).Trim();

                if (t.EndsWith("20"))
                    t = t.Remove(t.Length - "20".Length).Trim();

                if (t == t0)
                    break;
            }

            while (t.Contains("  "))
                t = t.Replace("  ", " ");



            return t;
        }

        /// <summary>
        /// Renvoie le décalage (avec espace avant) le cas échéant ou rien
        /// </summary>
        /// <returns></returns>
        private string getDateOffset()
        {
            if (pub2 > pub)
                return string.Format(" {0}°", (pub2 - pub).TotalDays.ToString("0.#"));
            return "";
        }

        public string NameWithDate
        {
            get
            {
                var sbNbRead = new StringBuilder();
                for (int i = 0; i < PlayCount; i++)
                {
                    if (i == 0)
                        sbNbRead.Append(" ");
                    sbNbRead.Append("¤");
                }
                return string.Format("{0} {1} {2}{3}{4}", LogicalName, pubInfoShort(), getDayOfWeek(), getDateOffset(), sbNbRead.ToString());
            }
        }

        public string LogicalName
        {
            get
            {
                return getLogicalName(name);
            }
        }

        //public override string Name
        //{
        //    get
        //    {
        //        return name;
        //    }
        //    set
        //    {
        //        if (value == null)
        //        {
        //            log.log("set Name null !!! {0}", this);
        //            return;
        //        }

        //        var thisLog = LogicalName;
        //        var newLog = getLogicalName(value);

        //        if (!thisLog.Equals(newLog, StringComparison.InvariantCultureIgnoreCase))
        //        {
        //            log.log("Modification du nom logique !!! {0}->{1} {2}", thisLog, newLog, this);
        //            return;
        //        }
        //        base.Name = value;
        //    }
        //}



        public override TimeSpan Duration
        {
            get
            {
                var dur = base.Duration;
                if (dur.TotalSeconds == 0)
                {
                    base.Duration = TimeSpan.FromSeconds(duree.Value);
                }
                return base.Duration;
            }

            set
            {
                base.Duration = value;
                if (duree.Value == 0)
                {
                    duree = new timeSpan(base.Duration);
                }
            }
        }

        private long _size = -1;
        public long Size
        {
            get
            {
                if (_size < 0)
                {
                    var f = FileRegister.Get(Location);
                    var exist = f.Exists;
                    if (exist == null)
                        return -1;
                    else if (true == exist)
                        _size = f.Length;
                    else
                        _size = 0;
                }
                return _size;
            }
        }

        //private int indexRoot = -1;
        //public int IndexRoot { get { return indexRoot; } set { indexRoot = value; } }



        //public static void setDate0(DateTime date) { Date0 = date; }
        //private static DateTime Date0;
        //private timeSpan ts;
        //public timeSpan Ts
        //{
        //    get
        //    {
        //        if (ts == default(timeSpan))
        //        {
        //            if (Date0 == DateTime.MinValue)
        //                throw new ApplicationException("Date0 pas initialisée");
        //            ts = new timeSpan(Pub2 - Date0);
        //        }
        //        return ts;
        //    }
        //}

        public void hibernate(FileValue fv, string dirH)
        {
            bgHibernate.add(new BgTaskHibernate(this, fv, dirH));
        }

        /// <summary>
        /// pour minimiser les listes de selection on checke la durée. en effet à l'utilisation on mélange de toute façon avec les longs
        /// </summary>
        public bool isConcernedBySelection
        {
            get
            {
                //if (!enabled)
                //    return false;
                //if (played)
                //    return false;
                var globalDuree = TrackAlbum.ConfAlbum.maxGlobal;
                if (globalDuree > 0)
                {
                    if (Duree.TotalMinute > globalDuree)
                        return false;
                }
                return true;
            }
        }

        public bool isLong
        {
            get
            {
                var globalDuree = TrackAlbum.ConfAlbum.maxGlobal;
                if (globalDuree > 0)
                {
                    if (Duree.TotalMinute > globalDuree)
                        return true;
                }
                return false;
            }
        }

        protected class BgTaskHibernate : BgTaskDeleteTrackTrack
        {
            private TrackInfoItunes track;
            private FileValue fv;
            string dirH;
            public BgTaskHibernate(TrackInfoItunes track, FileValue fv, string dirH)
                : base(track, string.Format("Hibernate {0}", track))
            {
                this.track = track;
                this.fv = fv;
                this.dirH = dirH;
            }

            public override void exec()
            {
                base.exec();
                if (!success)
                    return;

                if (!string.IsNullOrEmpty(dirH))
                {
                    var dest = misc.copyTree(fv, dirH + track.ShortName, false);
                    track.HibernateLocation = dest;

                    try
                    {
                        System.IO.File.Delete(track.Location);
                        fv.delete();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }
                }
            }
        }


        private class BgTaskImport : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskImport(TrackInfoItunes info)
                : base(string.Format("import {0}", info.Location))
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    info.import(_track);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



    }
}



]]></content>
  </file>
  <file path="db4\pdb.podcast\DB\Db.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using pdb.podcast.Tuning;
using pdb.podcast.Albums;


namespace pdb.podcast.DB
{
    public class Db
    {
        public const string CURRENT_VERSION = "2.0";
        const string SEQ_PIECE = "seq";
        const string TOKEN_VERSION = "version";
        private static int pieceSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        private BgDictString<TrackInfoItunes> dictUrl = new BgDictString<TrackInfoItunes>();
        private BgDict<int, TrackInfoItunes> dictId = new BgDict<int, TrackInfoItunes>();
        //  private Dictionary<string, TrackAlbum> dictAlbum;
        private volatile object _lock = new object();
        private AlbumMgr albumMgr = AlbumMgr.Instance;






        string FILE = "..\\db.xml";
        string FILE_STAT = "..\\db_stats.xml";
        //string HUMAN_FILE = "..\\dbh.xml";
        private List<string> sources = new List<string>();
        string SOV = "..\\sov\\";
        string zipSov;
        //   private XmlSerializer xmlSerializer;

        // private bool import;
        private bool loaded;
        private bool writing;
        public bool Writing { get { return writing; } }

        public Db()
        {
            var conf = Conf.Db;
            FILE = conf.file;
            FILE_STAT = conf.fileStat;
            SOV = conf.sov;
            zipSov = conf.sovZip.Replace("[date]", DateTime.Now.Date.ToString("yy-MM-dd"));
            foreach (DbSource source in conf.sources)
            {
                sources.Add(source.file);
            }

            // AlbumMgr albums = AlbumMgr.Instance;
            // dictAlbum = albums.Dict;

            // this.import = import;
            //xmlSerializer = new XmlSerializer()
            //{
            //    FillLists = false,
            //    ManageListsWithArbo= false,
            //    IncludeDeclaration = true,
            //    ClearEmpy = true,             
            //    DateFormat = "dd/MM/yyyy HH:mm:ss",  
            //};


        }

        public List<TrackInfoItunes> Tracks
        {
            get
            {
                if (!loaded)
                {
                    lock (_lock)
                    {

                    }
                }

                var l = new List<TrackInfoItunes>(dictId.Values);
                return l;
            }
        }

        public TrackInfoItunes get(string location)
        {
            if (!loaded)
            {
                lock (_lock)
                {

                }
            }
            var shortName = TrackInfoItunes.getShortName(location);
            return dict[shortName];
        }

        //public TrackAlbum getAlbum(string album)
        //{
        //    return albumMgr.getOrNull(album); 
        //    //var key = album.toKey();
        //    //if (dictAlbum.ContainsKey(key))
        //    //    return dictAlbum[key];
        //    //return null;
        //}
        //public TrackAlbum create(string album)
        //{
        //    var key = album.toKey();
        //    var TrackAlbum = new TrackAlbum(album, key);
        //    dictAlbum.Add(key, TrackAlbum);
        //    return TrackAlbum;
        //}

        public TrackInfoItunes get(TrackInfoItunes w)
        {
            return dictId[w.DbId];
        }

        public TrackInfoItunes getByUrl(string url)
        {
            return dictUrl[url];
        }

        public void CheckToDownload(TrackInfoItunes track)
        {
            var url = track.Url;
            if (string.IsNullOrEmpty(url))
                throw new ArgumentException(string.Format("track={0} url NULL", track));
            if (dictUrl.ContainsKey(url))
                throw new ArgumentException(string.Format("track={0} url existe:{1}", track, url));
            dictUrl.Add(url, track);
            int id = ++pieceSequenceId;
            track.DbId = id;
            dictId[track.DbId] = track;
        }

        public void Check(TrackInfoItunes track)
        {
            var location = track.ShortName;
            var url = track.Url;
            if (string.IsNullOrEmpty(location) & string.IsNullOrEmpty(url))
                return;
            TrackInfoItunes dbTrack = null;
            if (!string.IsNullOrEmpty(location))
                dbTrack = dict[location];
            if (dbTrack == null && !string.IsNullOrEmpty(url))
                dbTrack = dictUrl[url];
            //if (dbTrack == null)
            //{
            //    var album = track.TrackAlbum; 
            //    if (album != null && album != TrackAlbum.NULL)
            //    {
            //        var mode = album.DownLoadMode;
            //        TrackInfoItunes org = null;
            //        var list = album.List.FindAll(t => !string.IsNullOrEmpty(t.Location));


            //        switch (mode)
            //        {
            //            case downloadMode.none:
            //                break;
            //            case downloadMode.no:
            //                break;
            //            case downloadMode.last: org = list.Find(t => t.Pub == track.Pub);
            //                break;
            //            case downloadMode.onePerDay: org = list.Find(t => t.Pub.Date == track.Pub.Date);
            //                break;
            //            case downloadMode.onePerMin: org = list.Find(t => t.Pub == track.Pub);
            //                break;
            //            case downloadMode.multiple: org = list.Find(t => t.Pub == track.Pub && t.LogicalName == track.LogicalName);
            //                break;
            //            default:
            //                break;
            //        }

            //        if (org != null && !string.IsNullOrEmpty(org.Location))
            //            dbTrack = dict[org.Location]; 

            //    }
            //}
            if (dbTrack == null)
            {
                int id = ++pieceSequenceId;
                track.DbId = id;
                albumMgr.setAlbum(track, track.Album);
            }
            else
            {
                if (dbTrack != track)
                {
                    track.DbId = dbTrack.DbId;
                    dbTrack.Album = track.Album;
                    if (string.IsNullOrEmpty(dbTrack.Location))
                    {
                        dbTrack.File = track.File;
                    }

                    if (string.IsNullOrEmpty(track.Location))
                    {
                        track.File = dbTrack.File;
                    }

                    if (string.IsNullOrEmpty(dbTrack.Url))
                    {
                        dbTrack.Url = track.Url;
                    }

                    if (string.IsNullOrEmpty(track.Url))
                    {
                        track.Url = dbTrack.Url;
                    }

                    dbTrack.merge(track);
                }

                //if (import)
                //{
                //    track.import(dbTrack);
                //}
            }
            if (track.Pub2 < track.Pub)
            {
                var pub2 = track.Pub2.truncateToMinute();
                var pub = track.Pub.truncateToMinute();
                if (pub2 < pub)
                    track.Pub2 = pub;
            }

            location = track.ShortName;
            if (!string.IsNullOrEmpty(location))
            {
                track.Present = true;
                dict[location] = track;
            }
            if (!string.IsNullOrEmpty(url))
                dictUrl[url] = track;
            dictId[track.DbId] = track;



        }

        //public void Import(IEnumerable<TrackInfoItunes> listIt)
        //{
        //    foreach (TrackInfoItunes it in listIt)
        //    {
        //        var location = it.ShortName;
        //        var tdb = dict[location];
        //        if (tdb == null)
        //            continue;

        //        it.import(tdb);
        //    }
        //}

        //public void createIfExist(pdb.it.ITrackBuilder loader, List<TrackInfoItunes> listIt)
        //{
        //    foreach (TrackInfoItunes tdb in dict.Values)
        //    {
        //        if (tdb.isPresent())
        //        {
        //            loader.createTrack(tdb, true);
        //            tdb.import();
        //        }
        //    }
        //}



        public void load()
        {
            lock (_lock)
            {
                try
                {
                    var strVersion = "1";
                    TrackAlbum currentAlbum = null;
                    // string currentAlbumName = null;
                    using (XmlReader reader = XmlReader.Create(FILE))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {
                                    var seq = reader.GetAttribute(SEQ_PIECE);
                                    pieceSequenceId = Convert.ToInt32(seq);
                                    strVersion = reader.GetAttribute(TOKEN_VERSION);
                                }
                                else if (reader.Name == "a")
                                {
                                    currentAlbum = readAlbum(reader);
                                    // currentAlbumName = currentAlbum.Album.toKey();
                                    //if (dictAlbum.ContainsKey(currentAlbumName))
                                    //{
                                    //    currentAlbum = dictAlbum[currentAlbumName];
                                    //}
                                    //else
                                    //    dictAlbum.Add(currentAlbumName, currentAlbum);
                                }
                                else if (reader.Name == "t")
                                {
                                    var t = read(reader, currentAlbum);
                                    dict[t.ShortName] = t;
                                    if (!string.IsNullOrEmpty(t.Url))
                                        dictUrl[t.Url] = t;
                                    dictId[t.DbId] = t;
                                }

                                else if (reader.Name == "u")
                                {
                                    currentAlbum.Urls.Add(reader.GetAttribute("url"));
                                }
                            }
                        }

                    }

                    using (XmlReader reader = XmlReader.Create(FILE_STAT))
                    {
                        while (reader.Read())
                        {
                            if (reader.NodeType == XmlNodeType.Element)
                            {
                                if (reader.Name == "db")
                                {

                                }
                                else
                                {
                                    int id = Convert.ToInt32(reader.GetAttribute("id"));


                                    var t = dictId[id];
                                    if (t == null)
                                    {
                                        string loc = reader.GetAttribute("f");
                                        Program.log.log("track {0} dans les stats non vu dans db {1}", id, loc);
                                    }
                                    else
                                    {
                                        t.readStat(reader);
                                        t.readStatGlobal(reader);
                                    }
                                }
                            }
                        }

                    }


                    foreach (string source in sources)
                    {
                        try
                        {
                            using (XmlReader reader = XmlReader.Create(source))
                            {
                                while (reader.Read())
                                {
                                    if (reader.NodeType == XmlNodeType.Element)
                                    {
                                        if (reader.Name == "db")
                                        {

                                        }
                                        else
                                        {
                                            int id = Convert.ToInt32(reader.GetAttribute("id"));


                                            var t = dictId[id];
                                            if (t == null)
                                            {

                                            }
                                            else
                                            {
                                                t.readStatGlobal(reader);
                                            }
                                        }
                                    }
                                }

                            }
                        }

                        catch (Exception ex)
                        {
                            misc.log(ex);
                        }
                    }


                    //using (XmlReader reader = XmlReader.Create(GLOBAL_STAT))
                    //{
                    //    while (reader.Read())
                    //    {
                    //        if (reader.NodeType == XmlNodeType.Element)
                    //        {
                    //            if (reader.Name == "db")
                    //            {

                    //            }
                    //            else
                    //            {
                    //                int id = Convert.ToInt32(reader.GetAttribute("id"));


                    //                var t = dictId[id];
                    //                if (t == null)
                    //                {
                    //                    string loc = reader.GetAttribute("f");
                    //                    Program.log.log("track {0} dans les global stats non vu dans db {1}", id, loc);
                    //                }
                    //                else
                    //                {
                    //                    t.readStatGlobal(reader);
                    //                    t.consolidStat();
                    //                }
                    //            }
                    //        }
                    //    }

                    //}

                    foreach (TrackInfoItunes t in dictId.Values)
                    {
                        if (t.ParentId > 0)
                            t.Parent = dictId[t.ParentId];
                    }

                }

                finally
                {
                    loaded = true;
                }
            }
        }


        private void readUrl(XmlReader reader, TrackAlbum currentAlbum)
        {
        }

        private TrackInfoItunes read(XmlReader reader, TrackAlbum currentAlbum)
        {
            var t = new TrackInfoItunes();

            //if (album != null)
            //{
            t.TrackAlbum = currentAlbum;

            // }
            t.build(reader);


            currentAlbum.Add(t, true);
            return t;
        }

        private TrackAlbum readAlbum(XmlReader reader)
        {
            string name = reader.GetAttribute("name");
            var album = albumMgr.Get(name);
            if ("y" == reader.GetAttribute("rare"))
                album.setRare();
            if ("y" == reader.GetAttribute("info"))
                album.setInfo();
            if ("y" == reader.GetAttribute("actu"))
                album.setActu();
            if ("y" == reader.GetAttribute("courant"))
                album.setCourant();


            var str = reader.GetAttribute("rating");
            if (!string.IsNullOrEmpty(str))
                album.AlbumRating = Convert.ToInt32(str);

            str = reader.GetAttribute("note");
            if (!string.IsNullOrEmpty(str))
                album.Note = Convert.ToDouble(str);

            str = reader.GetAttribute("download");
            if (!string.IsNullOrEmpty(str))
                album.DownLoadMode = (downloadMode)Enum.Parse(typeof(downloadMode), str, true);
            else
                album.DownLoadMode = downloadMode.none;

            return album;
        }

        private void write(XmlWriter writer, TrackAlbum album)
        {
            writer.WriteStartElement("a");
            try
            {
                var list = album.List;

                writer.WriteAttributeString("name", album.Album);
                writer.WriteAttributeString("nb", list.Count.ToString());
                if (album.AlbumRating > 0)
                    writer.WriteAttributeString("rating", album.AlbumRating.ToString());
                if (album.Note != 0)
                    writer.WriteAttributeString("note", album.Note.ToString("0.##"));
                if (album.Rare)
                    writer.WriteAttributeString("rare", "y");
                else if (album.RareEffect)
                    writer.WriteAttributeString("rareEffect", "y");
                if (album.Info)
                    writer.WriteAttributeString("info", "y");
                if (album.Actu)
                    writer.WriteAttributeString("actu", "y");
                if (album.Courant)
                    writer.WriteAttributeString("courant", "y");

                writer.WriteAttributeString("spec", album.Specif.ToString());
                if (album.DownLoadMode > downloadMode.none)
                    writer.WriteAttributeString("download", album.DownLoadMode.ToString());


                list.Sort(new TrackComparer());
                // list.Sort(new PodCastComparer());

                TrackInfoItunes last = null;
                var l2 = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (t.TrackAlbum == null || t.TrackAlbum == TrackAlbum.NULL)
                        t.TrackAlbum = album;  // = album; 
                    //if (t.Deleted)
                    //    listDeleted.Add(t);
                    // else
                    if (!Conf.Db.purgemissing || (string.IsNullOrEmpty(t.Location) && !string.IsNullOrEmpty(t.Url)) || t.isPresent())
                    {
                        l2.Add(t); // write(writer, t, false);
                        last = t;
                    }
                    else
                        listMissing.Add(t);
                }
                if (last != null)
                {
                    writer.WriteAttributeString("lastPub", last.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                    writer.WriteAttributeString("last", last.Name);
                }

                foreach (string url in album.Urls)
                {
                    writer.WriteStartElement("u");
                    writer.WriteAttributeString("url", url);
                    writer.WriteEndElement();
                }

                foreach (TrackInfoItunes t in l2)
                {
                    write(writer, t, false);
                }
            }
            catch (Exception ex)
            {
                misc.log("impossible d'enregistrer {0} {1}", album.Album, ex);
            }
            writer.WriteEndElement();

        }

        private static void write(XmlWriter writer, TrackInfoItunes track, bool writeAlbum)
        {
            try
            {
                writer.WriteStartElement("t");
                writer.WriteAttributeString("id", track.DbId.ToString());
                if (track.HasParent)
                    writer.WriteAttributeString("pid", track.Parent.DbId.ToString());
                if (track.Pub > DateTime.MinValue)
                    writer.WriteAttributeString("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                var location = track.Location;
                if (!string.IsNullOrEmpty(location))
                {
                    if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                    {
                        location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                    }


                }
                writer.WriteAttributeString("f", location);
                if (writeAlbum)
                    writer.WriteAttributeString("alb", track.Album);
                else if (track.TrackAlbum.Album.toKey() != track.Album.toKey())
                    writer.WriteAttributeString("alb", track.Album);
                if (track.Note < int.MaxValue && track.isConcernedBySelection)
                    writer.WriteAttributeString("note", track.Note.ToString("0.##"));
                writer.WriteAttributeString("name", track.Name);

                if (track.Pub2 > DateTime.MinValue && track.Pub2 > track.Pub)
                    writer.WriteAttributeString("pub2", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                if (track.PlayedDate > DateTime.MinValue)
                    writer.WriteAttributeString("date", track.PlayedDate.ToString());
                if (track.PlayCount > 0)
                    writer.WriteAttributeString("nbr", track.PlayCount.ToString());
                //if (track.AlbumRating > 0)
                //    writer.WriteAttributeString("albumRating", track.AlbumRating.ToString());
                if (track.Rating != track.AlbumRating)
                    writer.WriteAttributeString("rating", track.Rating.ToString());


                //if (track.RatingComputed)
                //    writer.WriteAttributeString("computed", "y");
                //if (track.Rare)
                //    writer.WriteAttributeString("rare", "y");
                //if (track.Info)
                //    writer.WriteAttributeString("info", "y");
                var duree = track.Duree;
                if (duree.Value > 0)
                {
                    writer.WriteAttributeString("d", duree.Value.ToString("0"));
                    var size = track.Size;
                    if (size > 0)
                        writer.WriteAttributeString("s", size.ToString());
                }

                //if (!track.Enabled)
                //    writer.WriteAttributeString("disabled", "y");
                var dtDisabled = track.Disabled;
                if (dtDisabled == DateTime.MinValue)
                    writer.WriteAttributeString("dd", "y");
                else if (dtDisabled < DateTime.MaxValue)
                    writer.WriteAttributeString("dd", dtDisabled.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));


                if (track.Added > DateTime.MinValue)
                    writer.WriteAttributeString("add", track.Added.ToString());
                if (track.AddedFirst > DateTime.MinValue && track.AddedFirst < track.Added)
                    writer.WriteAttributeString("add1", track.AddedFirst.ToString());

                if (!string.IsNullOrEmpty(track.Description))
                {
                    try
                    {
                        writer.WriteAttributeString("desc", track.Description.Replace("!!", ""));
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible décrire la description de {0} id={1} {2} {3}", track, track.DbId, track.Description, ex);
                    }
                }


                if (!string.IsNullOrEmpty(track.LongDescription))
                {
                    try
                    {
                        writer.WriteAttributeString("ldesc", track.LongDescription.Replace("!!", ""));
                    }
                    catch (Exception ex)
                    {
                        misc.log("impossible décrire la description longue de {0} id={1} {2} {3}", track, track.DbId, track.LongDescription, ex);
                    }
                }

                try
                {
                    var comment = track.Comment;
                    if (!string.IsNullOrEmpty(comment))
                    {
                        var build = track.buildComment();
                        if (comment != build)
                            writer.WriteAttributeString("comment", comment);
                    }
                }
                catch (Exception ex)
                {
                    misc.log("impossible de vérifier comment de {0} id={1} {2}", track, track.DbId, ex);
                }


                if (!string.IsNullOrEmpty(track.HibernateLocation))
                    writer.WriteAttributeString("hl", track.HibernateLocation);

                if (!string.IsNullOrEmpty(track.Url))
                    writer.WriteAttributeString("url", track.Url);

            }
            catch (Exception ex)
            {
                misc.log("impossible d'enregistrer {0} {1} {2}", track.DbId, track, ex);
            }

            writer.WriteEndElement();

        }

        private static void writeStat(XmlWriter writer, TrackInfoItunes track)
        {
            if (track.In > DateTime.MinValue)
            {
                writer.WriteStartElement("t");
                writer.WriteAttributeString("id", track.DbId.ToString());
                var location = track.Location;
                if (!string.IsNullOrEmpty(location))
                {
                    if (location.StartsWith(TrackInfoItunes.DefaultFolder, true, CultureInfo.InvariantCulture))
                    {
                        location = location.Substring(TrackInfoItunes.DefaultFolder.Length);
                    }


                }
                writer.WriteAttributeString("f", location);



                if (track.Out == DateTime.MinValue || track.In < track.Out)
                {
                    writer.WriteAttributeString("in", track.In.ToString());
                    if (track.Out > DateTime.MinValue)
                        writer.WriteAttributeString("out", track.Out.ToString());
                }
                else
                {
                    writer.WriteAttributeString("out", track.Out.ToString());
                    writer.WriteAttributeString("in", track.In.ToString());
                }


                writer.WriteEndElement();
            }

        }

        public void recordIt(IEnumerable<TrackInfoItunes> listIt)
        {
            using (System.IO.StreamWriter sw = new StreamWriter(@"..\load.txt"))
            {
                if (listIt != null)
                {
                    foreach (TrackInfoItunes t in listIt)
                    {
                        Check(t);
                        sw.Write(t.ID);
                        sw.Write("\t");
                        sw.Write(t.Location);
                        sw.Write("\t");
                        sw.WriteLine(t.Url);
                    }
                }
            }
        }

        private List<TrackInfoItunes> listMissing;
        private List<TrackInfoItunes> listDeleted;
        private class TrackComparer : IComparer<TrackInfoItunes>
        {
            public virtual int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                int cmp = x.Pub.CompareTo(y.Pub);
                if (cmp != 0)
                    return cmp;
                return x.DbId.CompareTo(y.DbId);
            }
        }

        private class TrackComparerInv : TrackComparer
        {
            public override int Compare(TrackInfoItunes x, TrackInfoItunes y)
            {
                return -base.Compare(x, y);
            }
        }

        public void writeAsync()
        {
            new ThreadUtil(write, "db.write").Start();
        }
        public void write()
        {
            misc.log("db::write");
            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            var listZip = new List<string>();
            lock (_lock)
            {
                writing = true;
                try
                {
                    if (!Directory.Exists(SOV))
                        Directory.CreateDirectory(SOV);
                    ZipUtil.Exe = @"C:\Program Files\7-Zip\7z.exe";
                    // ZipUtil.Enter();
                    //ZipUtil.CompressAsync(zipSov, FILE, true); 
                    var destCopy = string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE));
                    File.Copy(FILE, destCopy, true);
                    listZip.Add(destCopy);
                    //  ZipUtil.CompressAsync(zipSov, timeStamp, new List<string> { destCopy }, false); 

                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                finally
                {
                    // ZipUtil.Release();
                }


                listMissing = new List<TrackInfoItunes>();
                listDeleted = new List<TrackInfoItunes>();

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(FILE + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());

                    //AlbumMgr mgr = TrackInfoItunes.AlbumMgr as AlbumMgr;
                    var albums = albumMgr.List;

                    //albums.Sort(new TrackComparer()); 
                    albums.Sort((x, y) => x.Album.CompareTo(y.Album));

                    foreach (TrackAlbum album in albums)
                    {
                        write(writer, album);
                    }

                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE + ".tmp", FILE, true);



                if (listMissing.Count > 0)
                {
                    string missing = string.Format("{0}{1}__missing.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(missing, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            write(writerMissing, track, true);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }

                    listZip.Add(missing);

                }

                if (listDeleted.Count > 0)
                {
                    var deleted = string.Format("{0}{1}__deleted.xml", SOV, timeStamp);
                    using (XmlWriter writerDeleted = XmlWriter.Create(deleted, settings))
                    {
                        writerDeleted.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            write(writerDeleted, track, true);
                        }
                        writerDeleted.WriteEndDocument();
                        writerDeleted.Flush();
                    }
                    listZip.Add(deleted);
                }
                var destCopyStat = string.Format("{0}{1}_{2}", SOV, timeStamp, Path.GetFileName(FILE_STAT));
                if (File.Exists(FILE_STAT))
                {
                    File.Copy(FILE_STAT, destCopyStat, true);
                    listZip.Add(destCopyStat);
                }

                using (XmlWriter writer = XmlWriter.Create(FILE_STAT + ".tmp", settings))
                {

                    writer.WriteStartElement("db");
                    writer.WriteAttributeString(TOKEN_VERSION, CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    var tracks = Tracks;
                    tracks.Sort(new PodCastComparer());
                    foreach (TrackInfoItunes track in tracks)
                    {
                        if (!Conf.Db.purgemissing || (string.IsNullOrEmpty(track.Location) && !string.IsNullOrEmpty(track.Url)) || track.isPresent())
                            writeStat(writer, track);
                    }
                    writer.WriteEndDocument();
                    writer.Flush();
                }
                File.Copy(FILE_STAT + ".tmp", FILE_STAT, true);

                // listZip.Add(FILE_STAT); 

                if (listMissing.Count > 0)
                {
                    var missing = string.Format("{0}{1}__missing_stat.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(missing, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listMissing)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }
                    listZip.Add(missing);

                }

                if (listDeleted.Count > 0)
                {
                    var deletedStat = string.Format("{0}{1}__deleted_stat.xml", SOV, timeStamp);
                    using (XmlWriter writerMissing = XmlWriter.Create(deletedStat, settings))
                    {
                        writerMissing.WriteStartElement("db");

                        foreach (TrackInfoItunes track in listDeleted)
                        {
                            writeStat(writerMissing, track);
                        }
                        writerMissing.WriteEndDocument();
                        writerMissing.Flush();
                    }
                    listZip.Add(deletedStat);

                }
                misc.log("db::fin write");
                ZipUtil.Compress(zipSov, null, listZip, false, false);
                misc.log("db::fin write et zip");
                //File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                writing = false;
            }
        }


        // géopolitique 4 par défaut rating ->80 albumrating ->80 computed =true
        //RFI 0 de temps en temps surcharge pour un par défaut : rating null albumrating->20 computed = true
        //                                  pour un syrchargé  : rating non null ""   
        // adele 1                          pour les défaut   rating:20 album 20 computed
        //                                  pour un surchargé 4 rating 80 album 20 non computed

        //C'est quand même gavant. il fait pas la différence entre les étoiles pleines et creuses
        //prenons adele defaut : 20 /20 computed
        //          autre        80 /20 non computed


        // ayo album zero surcharge 1 deux étoiles creuses => 20/40/computed

        //Ah ok . cas computed 1. album=rating => c'est bien level album
        //                        album != rating => c'est bidon  "étoile creuse"                                
        //        sinon on lit directement level album

        // Quel con j'ai pas vu qu'il y avait RatingComputed et Album Rating computed
        // je me le refele
        //géopolitique ratinet alubm => 80 ratingComputed
        // RFi  defaut rating null album 20 albumcomputed
        //      surchargé   rating 20 idem     
        // adele defaut rating 20 rating computed albumrating 20




    }
}]]></content>
  </file>
  <file path="db4\pdb.util\RelativePath\RelativeFile.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace pdb.util.RelativePath
{

    public class RelativeFile
    {
        public readonly string file;
        private string folder;
        private long length;
        public long Length { get { return length; } }
        private bool? _exists;
        public bool? Exists { get { return _exists; } }
       
        public void delete() { _exists = false; }

        private static List<string> folders = new List<string>();
        public static List<string> Folders { get { return folders; } set { folders = value; } }

        private static RelativeFile _NULL = new RelativeFile("", "") { _exists = false, length = 0 };
        public static RelativeFile NULL { get { return _NULL; } }
        public override bool Equals(object obj)
        {
            var o = obj as RelativeFile;
            if (o == null) return false;
            return file == o.file; //&& Exists == o.Exists;
        }
        public override int GetHashCode()
        {
            return file.GetHashCode(); // +Length.GetHashCode();
        }

        //public RelativeFile(string location)
        //{
        //    this.file = location;
        //    if (Path.IsPathRooted(file))
        //    {
        //        var f = file.ToLower();
        //        foreach (string dir in folders)
        //        {
        //            if (f.StartsWith(dir))
        //            {
        //                this.folder = dir;
        //                this.file = file.Substring(dir.Length);
        //            }
        //        }
        //    }
        //}

        public RelativeFile(string location, string folder)
        {

            this.file = location;
            if (!string.IsNullOrEmpty(folder))
            {
                this.folder = folder;
            }
        }

        public static string getRelativeFile(string location, ref string folder)
        {
            if (!Path.IsPathRooted(location))
                return location;
            var f = location.ToLower();
            foreach (string dir in folders)
            {
                if (f.StartsWith(dir))
                {
                    folder = dir;
                    return location.Substring(dir.Length);
                }
            }
            return location;
        }

        private void check(string path)
        {
            var f = new FileInfo(path);
            if (f.Exists)
            {
                _exists = true;
                length = f.Length;
            }
            else
                _exists = false;
        }

        public bool ExistsNow
        {
            get
            {
                check();
                return _exists.Value;
            }
        }

        public void check()
        {
            if (_exists.HasValue)
                return;
            if (Path.IsPathRooted(file))
            {
                check(file);
                return;
            }

            if (!string.IsNullOrEmpty(folder))
            {
                check(folder + file);
                return;
            }
            foreach (string dir in folders)
            {
                check(dir + file);
                if (true == _exists)
                {
                    this.folder = dir;
                    return; 
                }
            }
            _exists = false;
        }
        public string getPath()
        {
            return string.Format("{0}{1}", folder, file); 
        }


    }
}
]]></content>
  </file>
  <file path="db4\pdb.util\RelativePath\RelativeFileRegister.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace pdb.util.RelativePath
{
    public class RelativeFileRegister
    {
        private static RelativeFileRegister _instance = new RelativeFileRegister();
        private IDictionary<string, RelativeFile> dict = new BgDictString<RelativeFile>();
        private static volatile object _lock = new object();
        private static volatile object _lockD = new object();

        /// <summary>
        /// Thread de dépilage en parallèles des fichiers à checker
        /// </summary>
        private ThreadUtil th;
        /// <summary>
        /// Pile filo des fichiers à checker
        /// </summary>
        pdb.util.list.Stack<RelativeFile> stack = new pdb.util.list.Stack<RelativeFile>();
        DateTime lastActivity;

        public static void init(IDictionary<string, RelativeFile> dict)
        {
            _instance.dict = dict;
        }

        public static RelativeFile Get(string location)
        {
            return _instance.get(location); 
        }






        private RelativeFile get(string location)
        {
            RelativeFile fv = null;
            if (string.IsNullOrEmpty(location))
                return RelativeFile.NULL;
            string folder = "";
            location = RelativeFile.getRelativeFile(location, ref folder);
            if (!dict.ContainsKey(location))
            {
                lock (_lockD)
                {
                    if (!dict.ContainsKey(location))
                    {
                        fv = new RelativeFile(location, folder);
                        dict[location] = fv;
                        push(fv); 
                        return fv;
                    }
                }

            }
            return dict[location];
        }



        private RelativeFile delete(string location)
        {
            var value = get(location);
            value.delete();
            return value;

        }

        private void push(RelativeFile f)
        {
            if (f.Exists.HasValue)
                return;
            stack.Push(f);

            if (th == null)
            {
                lock (_lock)
                {
                    if (th == null)
                    {
                        th = new ThreadUtil(loopCheck, "RelativeFileRegister.loopCheck");
                        th.Start();
                    }
                }
            }
        }

        private void loopCheck()
        {
            while (true)
            {
                var f = stack.Peek();
                if (f == null)
                {
                    var now = DateTime.Now;
                    if (lastActivity > DateTime.MinValue)
                    {
                        if ((now - lastActivity).TotalMinutes > 1)
                        {
                            lock (_lock)
                            {
                                f = stack.Peek();
                                if (f == null)
                                {
                                    th = null;
                                    return;
                                }
                            }
                        }
                    }
                    else
                        lastActivity = DateTime.Now;
                    ThreadUtil.Sleep(30);
                    continue;
                }

                lastActivity = DateTime.Now;
                f.check();
            }
        }
    }
}
]]></content>
  </file>
  <file path="db4\pieceDb.iT\Loader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.obj;
using pdb.util;
using System.Diagnostics;
using pdb.it.detect;
using System.Collections;
using pdb.it.auto;
using pdb.it.persistance;
using pdb.ordo;
using System.Threading.Tasks;
using pdb.iit;
using pdb.util.RelativePath;

namespace pdb.it
{

    public class Loader : ITrackBuilder, IAbortTask
    {
        private Action abortList;
        protected Logger log = Logger.getLogger("Loader");
        private iTunesApp app;
        private IITSource mainLibrairy;
        private IITPlaylistCollection mainPlayLists;
        //  private IITUserPlaylist BIB;
        private PlayList root = PlayList.create("root", null);
        private List<PlayList> logicals = new List<PlayList>();
        private bool listLoaded;
        //private CPlayList rootComposite = new PlayListComposite("root");
        private String m_defaultFolder = @"D:\zique\";
        private String _dBLegacyPath = "";
        private String _dBLegacyDir = "";
        private XmlElement contentXml;

        private ITrackBuilder trackBuilder;
        private List<ITrackInfoItunes> list;
        public ITrackBuilder TrackBuilder { set { trackBuilder = value; } }
        private IPlayListFilter filterPlaylist = new PlayListDefaultFilter();
        public IPlayListFilter PlayListFilter { set { filterPlaylist = value; } }
        public int VolumeMin = -125;

        public bool Slave { get { return conf.slave; } }

        private bool checkSong;

        private bool writeOnlyEnabled;
        private bool writeOnlyUnRead;


        private BgDict<int, TrackInfoItunes> m_htPieces = new BgDict<int, TrackInfoItunes>();
        private BgDictString<TrackInfoItunes> m_htLoc = new BgDictString<TrackInfoItunes>();
        private BgDict<int, IITFileOrCDTrack> m_htTracks = new BgDict<int, IITFileOrCDTrack>();

        public void getNatives(ArrayList list)
        {
            foreach (IITFileOrCDTrack t in m_htTracks.Values)
                list.Add(t);
        }

        // private Dictionary<string, IITFileOrCDTrack> m_htFileTracks = new Dictionary<string, IITFileOrCDTrack>();

        //   private Dictionary<int, TrackInList> m_htPiecesInAList = new Dictionary<int, TrackInList>();
        private BgDict<int, PlayListComposite> m_htPlayLists = new BgDict<int, PlayListComposite>();
        private PlayListRegister m_htLegacyPLayList; // Dictionary<int, IITUserPlaylist>();

        /// <summary>
        /// index des listes suivant persistantID (Xml) 
        /// </summary>
        private BgDictString<PlayList> persistentIDs = new BgDictString<PlayList>();

        #region parsing natif asynchrone
        //  private bool bParsingNativeAsync = true;
        //  private ThreadUtil loopbgLoadTracksNative;

        /// <summary>
        /// dictionnaire des Tracks musique par ID
        /// </summary>
        private BgDict<int, IITFileOrCDTrack> dictTracks = new BgDict<int, IITFileOrCDTrack>();

        private TracksDb persist;
        /// <summary>
        /// dictionnaire tracks par location
        /// </summary>
        //   private BgDictString<IITFileOrCDTrack> locationTrack = new BgDictString<IITFileOrCDTrack>();
        //  private TrackDb persistTracks; 
        //  private BgDictString<IITFileOrCDTrack> locationTrack = new BgDictString<IITFileOrCDTrack>();
        /// <summary>
        /// dictionnaires des tracks de playlist par ID (pas l'ID du track de liste mais l'ID du track de bib)
        /// </summary>
        private BgDict<int, IITFileOrCDTrack> dictTrackList = new BgDict<int, IITFileOrCDTrack>();

        /// <summary>
        /// Cumul des dictionnaires des tracks de playList par location
        /// </summary>
        // private BgDictString<IITFileOrCDTrack> memoTrackList = new BgDictString<IITFileOrCDTrack>();
        //  private TrackDb memoTrackList;

        private BgDictString<TrackInList> dictTrackInList = new BgDictString<TrackInList>();

        private BgDictString<TrackInList> logicalDictTrackInList = new BgDictString<TrackInList>();
        private BgDictString<TrackInList> logicalDictTrackInListDeleted = new BgDictString<TrackInList>();


        private static string getKey(string path, string location)
        {
            return String.Concat(path, ":", location).ToLower();
        }

        /// <summary>
        /// Récupération d'un track base ou liste pour ajout de trackListe
        /// </summary>
        /// <param name="location"></param>
        /// <returns></returns>
        public TrackId getAnyTrackByLocation(string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            var t = persist.getTrack(location);
            if (t == null)
            {
                if (FileRegister.ExistNow(location)) //  File.Exists(location))
                    loadScan("recherche location" + location);
            }
            return t;
        }



        public TrackInList getTrackInList(string path, string location)
        {
            if (string.IsNullOrEmpty(location))
                return null;
            return dictTrackInList[getKey(path, location)];
        }

        public void recordTrackList(string pl, IITFileOrCDTrack track, int trackDataBaseID, string location, bool memo)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(location))
            {
                StackTrace st = new StackTrace();
                log.log("Loader::recordTrackList location nulle " + st.ToString());
                return;
            }
            //if (!dictTrackList.ContainsKey(trackDataBaseID))
            dictTrackList[trackDataBaseID] = track;
            var key = getKey(pl, location);
            persist.recordTrackList(key, location, track);
            //if (!locationTrack.ContainsKey(location))
            //    locationTrack.record(location, track);

            //if (memo && !memoTrackList.ContainsKey(key))
            //    memoTrackList.record(key, track);

            //  return id;

        }

        public void invalidationTrack(TrackInfoItunes info)
        {
            log.log("invalidation track lors de modification " + info);

            dictTracks.Remove(info.ID);
            dictTrackList.Remove(info.ID);
            persist.invalidation(info.Location);
        }

        public void invalidationTrackInList(string pl, TrackInList tl, IITUserPlaylist _pl)
        {
            log.log("invalidation trackinList " + tl);
            removeTrackInList(pl, tl, _pl);
        }

        /// <summary>
        /// Appelé en cas d'erreur ajout trackList
        /// </summary>
        /// <param name="location"></param>
        /// <param name="id"></param>
        public void invalidationLocation(string location)
        {
            log.log("invalidation track (AddTrack)" + location);
            persist.invalidation(location);
        }


        //public void recordTrackList(PlayList pl, IITFileOrCDTrack track, string location)
        //{

        //    if (!locationTrack.ContainsKey(location))
        //        locationTrack[location] = track;
        //    var key = getKey(pl, location);
        //    memoTrackList[key] = track;
        //}

        public TrackId getMemoTrackList(string path, IITUserPlaylist pl, string location)
        {
            var key = getKey(path, location);
            return persist.getTrackList(key, path, pl);
            // return memoTrackList.getTrackList(key, pl); //  [key];
        }



        private static bool erreurTrackList;
        public static bool ErreurTrackKist { get { return erreurTrackList; } set { erreurTrackList = value; } }



        public void recordTrackInList(string pl, TrackInList track, bool verifDoublon)
        {
            if (track == null)
                return;
            string key = getKey(pl, track.Location);
            //if (dictTrackInList.ContainsKey(key))
            //{
            //    if (verifDoublon)
            //    {
            //        string txt = "pas deux fois le même élément de liste \r\n" + track + "\r\n" + track.Location;
            //        log.log(txt);

            //        throw new ApplicationException(txt);
            //    }
            //}
            //else
            if (!dictTrackInList.ContainsKey(key))
                dictTrackInList[key] = track;
            // dictTrackInList[getKey(pl, track.Location)] = track;
        }

        public void removeTrackInList(string pl, TrackInList track, IITUserPlaylist plt)
        {
            if (track == null)
                return;
            string key = getKey(pl, track.Location);
            if (dictTrackInList.ContainsKey(key))
                dictTrackInList.Remove(key);


            persist.removeTrackList(key, track.Location, plt);

            dictTrackList.Remove(track.TrackDataBaseId);
            //  locationTrack.remove(track.Location);

        }

        public void removeTrackInList(string pl, string location, int TrackDataBaseId, IITUserPlaylist plt)
        {

            string key = getKey(pl, location);
            if (dictTrackInList.ContainsKey(key))
                dictTrackInList.Remove(key);


            persist.removeTrackList(key, location, plt);

            dictTrackList.Remove(TrackDataBaseId);
            //  locationTrack.remove(track.Location);
        }

        public void removeTrack(TrackInfoItunes track)
        {
            persist.removeTrack(track.Location);
        }
        /// <summary>
        /// Utilisé pour vérifier avant l'ajout que le track existe
        /// </summary>
        /// <param name="pl"></param>
        /// <param name="track"></param>
        /// <returns></returns>
        public bool LogicalContainsTrackInList(string pl, string location)
        {
            if (string.IsNullOrEmpty(location))
                return false;
            string key = getKey(pl, location);
            return logicalDictTrackInList.ContainsKey(key);
        }

        public bool LogicalTrackInListDeleted(string pl, string location)
        {
            if (string.IsNullOrEmpty(location))
                return false;
            string key = getKey(pl, location);
            return logicalDictTrackInListDeleted.ContainsKey(key);
        }


        public void LogicalRecordTrackInList(string pl, TrackInList track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            string key = getKey(pl, location);
            logicalDictTrackInListDeleted.Remove(key);
            logicalDictTrackInList.Add(key, track);
        }

        public void LogicalRemoveTrackInList(string pl, TrackInList track)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            string key = getKey(pl, location);
            logicalDictTrackInList.Remove(key);
            logicalDictTrackInListDeleted.Add(key, track);
        }



        #endregion






        private bool modeXml = true;
        private bool loadUrl = false;
        private bool deleteFile;
        private bool errorAccess;
        private bool singleThread;

        //public static Loader Instance
        //{
        //    get
        //    {
        //        if (_instance == null)
        //            _instance = new Loader();
        //        return _instance;
        //    }
        //}


        private Conf conf = new Conf();

        public Conf Conf
        {
            set
            {
                conf = value;
                if (detector != null)
                    detector.Conf = value.Detect;

                PlayList.Conf = conf;
                if (player != null)
                    player.Conf = value;
                TrackWrapper.SingleThread = conf.SingleThread;
                ItUtil.SingleThread = conf.SingleThread;
                singleThread = conf.SingleThread;
                checkSong = conf.checkSong;

            }
        }

        public void setConf(XmlElement xelt)
        {
            Conf = new Conf(xelt);
        }

        public bool ModeXml { set { modeXml = value; } }
        public bool LoadUrl { set { loadUrl = value; } }
        private Loader(bool deleteFile, bool writeOnlyEnabled, bool writeOnlyUnRead)
        {
            this.deleteFile = deleteFile;
            this.writeOnlyEnabled = writeOnlyEnabled;
            this.writeOnlyUnRead = writeOnlyUnRead;

        }



        #region events
        private string currentReading = "";
        void app_OnPlayerPlayingTrackChangedEvent(object iTrack)
        {

            log.log("app_OnPlayerPlayingTrackChangedEvent:" + iTrack);
            checkChangeSong();
        }

        void app_OnPlayerPlayEvent(object iTrack)
        {
            try
            {
                log.log("app_OnPlayerPlayEvent:" + iTrack);
                checkChangeSong();

            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

        }

        private string currentSong;
        private DateTime currentSongDt;
        private void getCurrentSong()
        {
            if (!checkSong)
                throw new ArgumentException("checkSong!");
            getCurrentTrack();
            getCurrentPlayList();
            currentSongDt = DateTime.Now;


            try
            {

                if (_currentTrack != null)
                {
                    getPlayerState();

                    //BackGroundTaskMgr.Playing = _playerState != ITPlayerState.ITPlayerStateStopped;
                    currentSong = _currentTrack.Location + " " + _playerState.ToString();
                }
            }
            catch { }
            getCurrentPlayList();
        }
        private string CurrentSong
        {
            get
            {
                if (!checkSong)
                    return "";
                if ((DateTime.Now - currentSongDt).TotalMinutes > 1)
                {
                    getCurrentSong();
                }

                return currentSong;
            }
        }

        private PlayListComposite _currentPlayList;
        private DateTime _currentPlayListTempo;
        private void getCurrentPlayList()
        {
            if (!checkSong)
                throw new ArgumentException();
            _currentPlayListTempo = DateTime.Now;
            try
            {
                enter();
                var _cur = app.CurrentPlaylist;
                if (_cur == null)
                    _currentPlayList = null;
                else
                    _currentPlayList = m_htPlayLists[_cur.playlistID];
            }
            finally
            {
                release();
            }
        }
        private IITFileOrCDTrack _currentTrack;
        private void getCurrentTrack()
        {
            if (!checkSong)
                throw new ArgumentException();
            currentTrackTempo = DateTime.Now;
            try
            {
                enter();
                _currentTrack = TrackWrapper.create(app.CurrentTrack);
                _currentTrackLocation = "";
                if (_currentTrack != null)
                    _currentTrackLocation = _currentTrack.Location;
            }
            finally
            {
                release();
            }
        }
        public PlayListComposite CurrentPlaylist
        {
            get
            {
                return null;
                //if ((DateTime.Now - _currentPlayListTempo).TotalMinutes > 1)
                //{
                //    getCurrentPlayList();
                //}
                //return _currentPlayList;
            }
        }
        private DateTime currentTrackTempo;
        public IITFileOrCDTrack CurrentTrack
        {
            get
            {
                if (!checkSong)
                    return null;
                if ((DateTime.Now - currentTrackTempo).TotalMinutes > 1)
                {
                    getCurrentTrack();
                }
                return _currentTrack;
            }

        }
        private string _currentTrackLocation;
        public string CurrentTrackLocation
        {
            get
            {
                if (!checkSong)
                    return null;
                if ((DateTime.Now - currentTrackTempo).TotalMinutes > 1)
                {
                    getCurrentTrack();
                }
                return _currentTrackLocation;

            }
        }

        private ITPlayerState _playerState;
        private void getPlayerState()
        {
            currentStateTempo = DateTime.Now;
            try
            {
                enter();
                _playerState = app.PlayerState;
            }
            finally
            {
                release();
            }
        }
        private DateTime currentStateTempo;
        public ITPlayerState PlayerState
        {
            get
            {
                if (!checkSong)
                    return ITPlayerState.ITPlayerStateStopped;
                if ((DateTime.Now - currentStateTempo).TotalMinutes > 1)
                    getPlayerState();
                return _playerState;
            }
        }


        private void checkChangeSong()
        {
            if (!checkSong)
                return;
            getCurrentSong();

            var track = CurrentTrackLocation;
            if (!track.Equals(currentReading))
            {
                currentReading = track;
                PlayComputedTrack();
            }

        }
        #endregion



        private bool useDetect;
        public Loader(Conf conf, bool useDetect, bool writeOnlyEnabled, bool writeOnlyUnRead)
            : this(conf.DeleteFile, writeOnlyEnabled, writeOnlyUnRead)
        {
            this.Conf = conf;
            this.m_defaultFolder = conf.DefaultFolder;
            if (!m_defaultFolder.EndsWith(@"\"))
                m_defaultFolder += @"\";
            this.useDetect = useDetect;

            this.player = new AutoPlayer(this, conf);

        }

        public Loader(Conf conf, Action abortList, bool writeOnlyEnabled, bool writeOnlyUnRead)
            : this(conf, true, writeOnlyEnabled, writeOnlyUnRead)
        {
            this.abortList = abortList;
        }

        public void saveIds()
        {
            if (persist != null)
                persist.record();
        }

        private bool initialized;

        public void init()
        {
            if (initialized)
                return;
            initialized = true;
            app = new iTunesApp();

            // //   IITSourceCollection sources = app.Sources;
            // //List<IITURLTrack> toDownload = new List<IITURLTrack>(); 

            // //for (int i = 1; i <= sources.Count; i++)
            // //{
            // //    var source = sources[i];
            // //    var kind = source.Kind;

            // //    var coll = source.Playlists;

            // //    foreach (IITPlaylist pl in coll)
            // //    {
            // //        if (pl.Name == "Podcasts")
            // //        {
            // //            var pl_ = pl as IITLibraryPlaylist; 
            // //            if (pl_ != null)
            // //            {

            // //            }
            // //            break; 
            // //        }
            // //    }
            // //}

            //var t = app.LibraryPlaylist.AddURL("http://rf.proxycast.org/1522928301641834496/11710-08.01.2019-ITEMA_21944979-0.mp3");

            //t.DownloadPodcastEpisode();
            mainLibrairy = app.LibrarySource;
            mainPlayLists = mainLibrairy.Playlists;



            TrackInfoItunes.Loader = this;
            PlayList.Loader = this;
            //BackGroundTaskMgr.Async = true;
            //BackGroundTaskMgr.start(); 
            trackBuilder = this;
            m_htLegacyPLayList = new PlayListRegister(this.app);
            m_htLegacyPLayList.load("init");

            app.OnPlayerPlayEvent += new _IiTunesEvents_OnPlayerPlayEventEventHandler(app_OnPlayerPlayEvent);
            app.OnPlayerPlayingTrackChangedEvent += new _IiTunesEvents_OnPlayerPlayingTrackChangedEventEventHandler(app_OnPlayerPlayingTrackChangedEvent);


            detector = new Detector(app.LibraryXMLPath, logDetect, conf.Detect);
            if (useDetect)
                detector.start();


            string file = app.LibraryXMLPath;
            // bool exists = File.Exists(file);
            //while (!File.Exists(file))
            //    Thread.Sleep(30);
            m_defaultFolder = getDefaultFolder();
            log.log(m_defaultFolder);

            log.log("suppression:{0} erreur accès:{1}", deleteFile, errorAccess);

            FileInfo fTrack = new FileInfo(_dBLegacyDir + conf.DbTrack);
            DirectoryInfo dir = fTrack.Directory;
            if (!dir.Exists) dir.Create();
            // persistTracks = new TrackDb(app, f.FullName);

            var fTrackList = new FileInfo(_dBLegacyDir + conf.DbTrackList);
            dir = fTrackList.Directory;
            if (!dir.Exists) dir.Create();
            //memoTrackList = new TrackDb(app, f.FullName);

            persist = new TracksDb(app, fTrack.FullName, fTrackList.FullName, conf.ProxyTrack, conf.ProxyTrackList, conf.PersistIt, conf.SingleThread);








            //if (deleteFile)
            //{

            //    //  log.log("suppression de " + file);
            //    while (true)
            //    {
            //        try
            //        {
            //            //if (!errorAccess)
            //            log.log("suppression de " + file);
            //            File.Delete(app.LibraryXMLPath);
            //            break;
            //        }
            //        catch (Exception e)
            //        {
            //            // log.log("error acces " + file);
            //            errorAccess = true;
            //            Thread.Sleep(1000);
            //        }
            //    }
            //}



            //if (deleteFile && errorAccess)
            //    log.log("finalement pas suppression de " + file + " car erreur accès");


        }

        private void enter()
        {
            if (singleThread)
            {
                BgTask.chrono.bip("l:ent0");
                Locker.Enter();
                BgTask.chrono.bip("l:ent1");
            }
        }
        private void release()
        {
            if (singleThread)
                Locker.Release();
        }

        # region detect
        //  private bool waitForNextSong;


        // public bool WaitForNextSong { get { return waitForNextSong; } set { waitForNextSong = value; } }



        private DateTime lastLoad;
        //private DateTime confirmLoad = DateTime.MaxValue;
        private string currentSongWhenLoaded = "";
        private Detector detector;

        public void logDetect(string info)
        {
            log.logNoDate("------------------------------------------------------------------------------------");
            log.log(info);
            log.logNoDate("------------------------------------------------------------------------------------");
        }

        public bool detectModif() { return !detector.canLoad(); }

        public void checkDetect(DateTime ini)
        {
            detector.check(ini);
        }

        public void exception()
        {
            currentSongWhenLoaded = "-";
        }
        public void reset(bool firstStep, bool forceLoad)
        {
            string _current = CurrentSong;
            log.log("reset ::firstStep {0} forceLoad {1} currentSongWhenLoaded :{2} currentSong:{3}", firstStep, forceLoad, currentSongWhenLoaded, _current);

            if (!forceLoad)
                detector.reset();
            //  DateTime lastLoad = DateTime.Now;
            // string currentSongWhenLoaded = "";

            //if (waitForNextSong)
            //    currentSongWhenLoaded = CurrentSong;


            //if (!deleteFile && firstStep)
            //    lastLoad = DateTime.MinValue;
            bool canread = false;

            FileInfo fLibrary = new FileInfo(app.LibraryXMLPath);
            bool condition = false;

            while (!canread)
            {

                try
                {
                    Thread.Sleep(1000);
                    _current = CurrentSong;
                    fLibrary.Refresh();
                    if (fLibrary.Exists)
                    {
                        //DateTime dt = fLibrary.LastWriteTime;
                        ////if (lastLoad == DateTime.MinValue)
                        ////{
                        ////    lastLoad = dt;
                        ////    confirmLoad = dt.AddSeconds(conf.Confirm);
                        ////    condition = true;
                        ////    log.logNoDate("------------------------------------------------------------------------------------");
                        ////    log.log("temps chargement:{0} confirm :{1}", lastLoad, confirmLoad);
                        ////    log.logNoDate("------------------------------------------------------------------------------------");
                        ////}
                        DateTime now = DateTime.Now;
                        TimeSpan _delta = now - lastLoad;


                        if (condition)
                        {
                            bool load = true;
                            if (!forceLoad)
                                load = detector.canLoad();
                            //if (now > confirmLoad)
                            //{
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    log.log("temps de confirmation dépassé {0}", confirmLoad);
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    load = true;
                            //}
                            //else if (dt > lastLoad)
                            //{
                            //    nbTick++;
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    log.log("library modifiée {0} {1}", dt, nbTick);
                            //    log.logNoDate("------------------------------------------------------------------------------------");
                            //    lastLoad = dt;

                            //    if (nbTick <= conf.TickRefresh)
                            //    {
                            //        int delta = conf.ConfirmTick; // (nbTick <= 1) ? conf.Confirm : conf.ConfirmTick;
                            //        DateTime dt0 = dt; // (nbTick <= 1) ? DateTime.Now : dt;
                            //        var _confirmLoad = dt0.AddSeconds(delta);
                            //        var _confirmLoad2 = lastLoad.AddSeconds(conf.Confirm);
                            //        if (_confirmLoad2 > _confirmLoad)
                            //            _confirmLoad = _confirmLoad2; 
                            //        if (_confirmLoad > confirmLoad)
                            //            confirmLoad = _confirmLoad;
                            //        log.log("confirm {0}", confirmLoad);
                            //    }

                            //}

                            if (load)
                            {
                                DateTime ini = DateTime.Now;
                                try
                                {

                                    log.logNoDate("***********************************************************************");
                                    log.log("chargement library {0} {1}", _current, _delta);
                                    log.logNoDate("***********************************************************************");
                                    DateTime __tick = DateTime.Now;
                                    XmlDocument doc = new XmlDocument();
                                    doc.XmlResolver = null;
                                    contentXml = null;

                                    gcCollect();
                                    string itXml = app.LibraryXMLPath;
                                    doc.Load(itXml);



                                    var root = doc.DocumentElement;
                                    contentXml = root.ChildNodes[0] as XmlElement;

                                    doc = null;
                                    root = null;
                                    gcCollect();
                                    if (!forceLoad)
                                    {

                                        if (conf.Detect.CancelLoad && !detector.canLoad())
                                        {
                                            log.log("Abort car modif fichiers");
                                            continue;
                                        }
                                        checkDetect(ini);
                                        detector.signalLoad();
                                        canread = true;
                                        lastLoad = DateTime.Now;
                                        condition = false;
                                    }

                                    //   confirmLoad = DateTime.MaxValue;
                                    currentSongWhenLoaded = _current;
                                    log.logNoDate("***********************************************************************");
                                    log.log("fin chargement library {0} ", (DateTime.Now - __tick));
                                    log.logNoDate("***********************************************************************");


                                    return;
                                }
                                catch (Exception ex)
                                {

                                    log.log(ex.ToString());
                                    Thread.Sleep(1000);
                                    //nbTick++;
                                    //dt = fLibrary.LastWriteTime;

                                    //int delta = (nbTick <= 1) ? conf.Confirm : conf.ConfirmTick;
                                    //DateTime dt0 = dt; // (nbTick <= 1) ? DateTime.Now : dt;

                                    //var _confirmLoad = dt0.AddSeconds(delta);
                                    //if (_confirmLoad > confirmLoad)
                                    //    confirmLoad = _confirmLoad;
                                    //var _confirmLoad2 = lastLoad.AddSeconds(conf.Confirm);
                                    //if (_confirmLoad2 > _confirmLoad)
                                    //    _confirmLoad = _confirmLoad2; 
                                    //log.log("confirm {0}", confirmLoad);
                                }
                            }
                            else
                            {
                                misc.Pre = "[Load " + detector.Limit.ToLongTimeString() + "] ";
                                continue;
                            }
                        }



                        //  log.log("library modifiée {0}", dt);

                        bool conditionWait = false;
                        bool conditionNoWait = false;


                        if (conf.WaitForNextSong)
                        {
                            conditionWait = _current != currentSongWhenLoaded;
                        }
                        else
                        {
                            conditionNoWait = _delta > conf.Refresh;
                        }




                        if (firstStep || forceLoad || conditionWait || conditionNoWait || _delta > conf.RefreshMax)
                        {

                            condition = true;
                            if (!forceLoad)
                                detector.reset();
                            checkChangeSong();
                            if (abortList != null)
                                abortList();
                            // lastLoad = dt;

                            //if (firstStep)
                            //    confirmLoad = dt.AddSeconds(conf.Confirm);
                            //else
                            //{
                            //    log.log("library modifiée {0} attente modif {1}", dt, (nbTick + 1));
                            //    // if (nbTick <= 1)
                            //    confirmLoad = now.AddSeconds(conf.Confirm);
                            //    log.log("confirm {0}", confirmLoad);


                            //}

                        }
                        //}
                    }


                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }

                if (!canread)
                {
                    Thread.Sleep(100);
                    if (!condition)
                    {
                        if (conf.WaitForNextSong)
                            Thread.Sleep(conf.Delay);
                    }
                }

            }


        }

        #endregion

        #region Infos

        //public CPiece getPiece(IITTrack track)
        //{
        //    return m_htPieces[track.TrackDatabaseID];
        //}


        //public IITFileOrCDTrack getPieceInList(PieceInAList trackList)
        //{
        //    return m_htPiecesInAList[trackList.ID];
        //}

        //public void deleteTrackInList(PieceInAList trackList)
        //{
        //    TrackInList track = m_htPiecesInAList[trackList.ID];
        //    track.Delete();
        //    //   track.Track.Delete();
        //    m_htPiecesInAList.Remove(trackList.ID);
        //}

        private String getDefaultFolder()
        {
            string path = app.LibraryXMLPath;

            _dBLegacyDir = Path.GetDirectoryName(path) + Path.DirectorySeparatorChar;
            _dBLegacyPath = _dBLegacyDir + "iTunes Library.itl";

            String uri = "";

            String token = "<key>Music Folder</key><string>";
            //<key>Music Folder</key><string>file://localhost/F:/bernard/zique/</string>
            log.log("load {0}", path);

            while (true)
            {
                try
                {
                    foreach (String line in File.ReadAllLines(path))
                    {
                        if (line.Contains(token))
                        {
                            Regex regex = new Regex("<string>(.+)</string>");
                            Match m = regex.Match(line);
                            if (!m.Success) return "";
                            uri = m.Groups[1].Value;
                            return new Uri(uri).LocalPath.Replace("\\\\localhost\\", "");
                        }
                    }
                }
                catch
                {
                    errorAccess = true;
                    Thread.Sleep(30);
                }
            }
        }
        public String DefaultFolder
        {
            get
            {
                return m_defaultFolder;
            }
        }
        #endregion



        //public void replace(TrackInfoItunes native, TrackInfoItunes local)
        //{
        //    local.ID = native.ID;
        //    if (m_htPieces.ContainsKey(native.ID))
        //    {
        //        m_htPieces.Remove(native.ID);
        //    }
        //    native.synchroLegacy(local);
        //    m_htPieces[native.ID] = local;
        //}

        #region chargement



        public TrackInfoItunes getInfo(int trackDataBaseId)
        {
            return m_htPieces[trackDataBaseId];
        }

        public void loadTracks(List<ITrackInfoItunes> list)
        {
            lock (this)
            {

                erreurTrackList = false;
                this.list = list;

                //   m_htPieces = new Dictionary<int, TrackInfoItunes>();
                m_htTracks = new BgDict<int, IITFileOrCDTrack>();
                // private Dictionary<string, IITFileOrCDTrack> m_htFileTracks = new Dictionary<string, IITFileOrCDTrack>();
                // m_htPiecesInAList = new Dictionary<int, TrackInList>();
                m_htPlayLists = new BgDict<int, PlayListComposite>();
                persistentIDs = new BgDictString<PlayList>();
                // m_htLegacyPLayList.load("loadTracks"); //  = new Dictionary<int, IITUserPlaylist>();


                /// <summary>
                /// dictionnaire asynchrone
                /// </summary>
                //dictTracks = new BgDict<int, IITFileOrCDTrack>();
                //locationTrack = new BgDict<string, IITFileOrCDTrack>();
                //dictTrackList = new BgDict<int, IITFileOrCDTrack>();
                dictTrackInList = new BgDictString<TrackInList>();

                log.log("DEBUT loadTracks");
                if (!modeXml)
                {
                    //if (loadUrl)
                    //    loadUrlTracksNative();
                    //else
                    loadTracksNative();
                    return;
                }


                //XmlDocument test = new XmlDocument();
                //test.Load(@"C:\Users\bd\Music\iTunes\test.xml");
                //var trackTest = new TrackInfoItunes(test.DocumentElement); 
                //  list = new List<TrackInfoItunes>();

                //recherche du noeud contenant les données Track
                XmlNode xtracks = null;
                for (int i = 0; i < contentXml.ChildNodes.Count; i += 2)
                {
                    XmlNode aux = contentXml.ChildNodes[i];
                    if (aux.InnerText == "Tracks")
                    {
                        xtracks = contentXml.ChildNodes[i + 1];
                        break;
                    }
                }

                //   int nb = 0;
                int count = xtracks.ChildNodes.Count;
                bool impair = false;
                foreach (XmlNode xTrack in xtracks.ChildNodes)

                // for (int i = 0; i < count; i += 2)
                {
                    impair = !impair;
                    if (impair)
                        continue;

                    //  var xTrack = xtracks.ChildNodes[i + 1];
                    //int ID = TrackInfoItunes.getID(xTrack);
                    string loc = TrackInfoItunes.getLocation(xTrack);
                    int ID = TrackInfoItunes.getID(xTrack);
                    //TrackInfoItunes track = trackBuilder.create(xTrack);


                    TrackInfoItunes track = null;
                    if (m_htLoc.ContainsKey(loc))
                    {
                        track = m_htLoc[loc];
                        track.build(xTrack);


                    }
                    else if (m_htPieces.ContainsKey(ID))
                    {
                        track = m_htPieces[ID];
                        track.build(xTrack);

                        m_htLoc.Add(loc, track);
                    }
                    //  log.log("add track {0}", track);

                    else
                    {
                        try
                        {
                            track = create(loc);
                            track.build(xTrack);
                        }
                        catch (Exception ex)
                        {
                            log.log("souci avec {0} impossible de builder le track", loc);
                            continue;
                        }
                        if (track.Strange)
                            continue;



                        m_htPieces.Add(track.ID, track);
                        m_htLoc.Add(loc, track);
                    }

                    string location = track.Location;
                    if (string.IsNullOrEmpty(location))
                    {
                        log.log("phase load :: suppression du track sans localisation " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }
                    else if (!FileRegister.ExistNow(location)) // conf.CheckFileExist && !File.Exists(location))
                    {
                        log.log("phase load :: suppression du track absent " + track.Album + "/" + track.Name + " " + location);
                        track.Delete();
                        continue;
                    }




                    list.Add(track);
                    //  track.Index = nb;
                    //   nb++;

#if VERIF
                track.verif();
#endif
                }
                log.log("FIN loadTracks");
            }


        }

        //private void buildIndexesTracks()
        //{
        //    int count = list.Count;
        //    for (int i = 0; i < count; i++)
        //    {
        //        list[i].Index = i;
        //    }
        //}

        private void bgLoadTracksNative()
        {

            try
            {



                IITTrackCollection tracks = null;
                int count = 0;
                IEnumerator enumerator = null;
                try
                {
                    enter(); tracks = app.LibraryPlaylist.Tracks;
                    count = tracks.Count;
                    enumerator = tracks.GetEnumerator();
                }
                finally { release(); }

                int i = 0;
                while (true)
                //int count  = tracks.Count; 
                //for (int i= 1; i<=count; i++)
                {
                    while (BackGroundTaskMgr.PauseKeyBoard)
                        Thread.Sleep(100);
                    bool _cont = false;

                    try
                    { enter(); _cont = enumerator.MoveNext(); }
                    finally { release(); }
                    if (!_cont)
                        break;
                    i++;

                    try
                    {
                        IITFileOrCDTrack track = null;
                        try
                        {
                            enter();
                            //   var t = tracks[i];
                            track = TrackWrapper.create(enumerator.Current as IITFileOrCDTrack);
                        }
                        finally
                        {
                            release();
                        }
                        if (track == null)
                            continue;

                        //if (t.Kind == ITTrackKind.ITTrackKindFile)
                        //{
                        //lock (this)
                        //{
                        // IITFileOrCDTrack track = t as IITFileOrCDTrack;
                        int l_id = 0;
                        string location = "";
                        try
                        {
                            enter();
                            l_id = track.TrackDatabaseID;
                        }
                        finally
                        {
                            release();
                        }
                        try
                        {
                            enter();
                            location = track.Location;
                        }
                        finally
                        {
                            release();
                        }
                        if (i % 1000 == 0)
                            log.log("scan {0}/{1} id:{2} {3}", i, count, l_id, location);


                        if (location == null)
                        {
                            log.log("suppression du track sans localisation " + track.Album + "/" + track.Name);
                            try
                            {
                                enter(); track.Delete();
                            }
                            finally
                            {
                                release();
                            }
                            continue;
                        }
                        else
                        {

                            //  log.log("bg Add track " + location);
                            dictTracks[l_id] = track;
                            dictTrackList[l_id] = track;
                            this.persist.recordTrack(location, track);


                        }

                    }
                    catch (Exception e)
                    {
                        log.log(e.ToString());
                    }
                }
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
                log.log("!!!!!!!!!!!!!!!!!!!>>>!!!!!!!!!!!!!!!!!>>>>>>!!!!!!!!!!!!!!!!!!>>>>FIN bgLoadTracksNative ");
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
            }
            finally
            {
                lock (this)
                    scanLoaded = false;

                //list = new CListPieceWithoutPodcast(m_htPieces.Values);
            }
        }

        public void loadByUrl(string url)
        {

            if (app == null)
                app = new iTunesApp();
            try
            {
                var track = app.LibraryPlaylist.AddURL(url);
                try
                {
                    track.DownloadPodcastEpisode();
                    log.log("téléchargement phase 2 de {0} {1} {2}", track.Name, track.Album, track.URL);
                }
                catch (Exception ex)
                {
                    log.log("téléchargement phase 2 de {0} {1} {2} NIET", track.Name, track.Album, track.URL);
                    if (track != null)
                    {
                        try
                        {
                            track.Delete();
                        }
                        catch (Exception ed)
                        {
                            misc.log(ed);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                misc.log(e);
            }
        }

        private bool updatePocastsDone;

        public void updatePocasts()
        {
            IITSourceCollection sources = app.Sources;
            List<IITURLTrack> toDownload = new List<IITURLTrack>();

            bool okSource = false;
            log.log("phase un");

            var albums = new HashSet<string>();
            for (int i = 1; i <= sources.Count; i++)
            {
                if (okSource)
                    break;
                var source = sources[i];
                var kind = source.Kind;

                var coll = source.Playlists;

                foreach (IITPlaylist pl in coll)
                {
                    if (pl.Name == "Podcasts")
                    {
                        okSource = true;
                        var tracks = pl.Tracks;


                        foreach (IITTrack t in tracks)
                        {
                            if (t.Kind != ITTrackKind.ITTrackKindFile)
                            {

                                if (t.Kind == ITTrackKind.ITTrackKindURL)
                                {
                                    try
                                    {
                                        IITURLTrack track = t as IITURLTrack;

                                        if (albums.Add(track.Album))
                                        {
                                            log.log("UpdatePodcastFeed {0} {1} {2}", track.Name, track.Album, track.URL);
                                            track.UpdatePodcastFeed();
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        log.log(ex.ToString());
                                    }



                                    //var url = track.URL.ToLower();

                                    //if (hs.Contains(url))
                                    //{



                                    //}
                                }

                            }
                        }
                        break;
                    }
                }

                log.log("FIN UpdatePodcastFeed ");

                //list = new CListPieceWithoutPodcast(m_htPieces.Values);
            }

            updatePocastsDone = true;

        }
        public void loadTrackToDownload(IDictionary<string, ITrackInfoItunes> urls)
        {
            //while (!updatePocastsDone)
            //    Thread.Sleep(30);
            if (app == null)
                app = new iTunesApp();
            Dictionary<string, ITrackInfoItunes> hs = new Dictionary<string, ITrackInfoItunes>(urls);
            log.log("{0} pocasts à télécharger", hs.Count);

            //foreach (string url in urls)
            //{
            //    try
            //    {
            //        var track = app.LibraryPlaylist.AddURL(url);
            //        try
            //        {
            //            track.DownloadPodcastEpisode();
            //            log.log("téléchargement de {0} {1}", track.Name, track.Album);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log("téléchargement de {0} {1} NIET", track.Name, track.Album);
            //        }
            //    }
            //    catch (Exception e)
            //    {
            //        misc.log(e); 
            //    }
            //}
            //reset(true, true);
            IITSourceCollection sources = app.Sources;
            List<IITURLTrack> toDownload = new List<IITURLTrack>();

            bool okSource = false;

            using (System.IO.TextWriter sw = new StreamWriter(@"..\\download.txt"))
            {
                for (int i = 1; i <= sources.Count; i++)
                {
                    if (okSource)
                        break;
                    var source = sources[i];
                    var kind = source.Kind;

                    var coll = source.Playlists;

                    foreach (IITPlaylist pl in coll)
                    {
                        if (pl.Name == "Podcasts")
                        {
                            okSource = true;
                            var tracks = pl.Tracks;


                            foreach (IITTrack t in tracks)
                            {
                                if (t.Kind != ITTrackKind.ITTrackKindFile)
                                {

                                    if (t.Kind == ITTrackKind.ITTrackKindURL)
                                    {
                                        try
                                        {
                                            IITURLTrack track = t as IITURLTrack;
                                            var url = track.URL.ToLower();
                                            if (hs.ContainsKey(url))
                                            {
                                                sw.Write(t.TrackDatabaseID);
                                                sw.Write("\t");
                                                sw.WriteLine(url);


                                                log.log("download {0} {1} {2}", track.Name, track.Album, track.URL);
                                                try
                                                {
                                                    track.DownloadPodcastEpisode();
                                                    hs.Remove(url);
                                                }
                                                catch (Exception ex)
                                                {
                                                    log.log("impossible d'ajouter le track {0} {1} {2} {3}", track.Name, track.Album, track.URL);
                                                }


                                            }
                                        }

                                        catch (Exception ex)
                                        {
                                            log.log("impossible d'ajouter le track");
                                        }
                                    }

                                }
                            }
                            break;
                        }
                    }

                    log.log("FIN LoadTracksNative ");

                    //list = new CListPieceWithoutPodcast(m_htPieces.Values);
                }
            }

            log.log("reste {0} éléments", hs.Count);

            foreach (var track in hs.Values)
            {
                var t = track as TrackInfoItunes;
                log.logNoDate(string.Format("{0} url={1}", t, t.Url));
                // loadByUrl(t.Url);
            }

        }


        public void loadTracksNative()
        {

            IITTrackCollection tracks = app.LibraryPlaylist.Tracks;

            foreach (IITTrack t in tracks)
            {
                if (t.Kind == ITTrackKind.ITTrackKindFile)
                {
                    IITFileOrCDTrack track = TrackWrapper.create(t);
                    string location = "";
                    try
                    {
                        location = track.Location;
                    }
                    catch
                    {
                    }
                    log.log("add track " + location);

                    if (location.isNullorEmpty())
                    {
                        log.log("suppression du track sans localisation " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }
                    if (false == FileRegister.Exist(location)) //  File.Exists(location))
                    {
                        log.log("Suppression du track absent " + track.Album + "/" + track.Name);
                        track.Delete();
                        continue;
                    }



                    //if (persist.containsTrack(location))
                    //{
                    //    log.log("suppression du track doublon " + track.Album + "/" + track.Name + " " + track.Location);
                    ////    track.Delete();
                    //    continue;
                    //}

                    persist.recordTrack(location, track);
                    //              String l_strFile = track.Location.Replace(m_defaultFolder, "");
                    int l_id = track.TrackDatabaseID;

                    //string l_Artist = track.Artist.TrimSafe();
                    //string l_Album = track.Album.TrimSafe();
                    //string l_Name = track.Name.TrimSafe();
                    //int l_trackNumber = -1;
                    //if (track.TrackNumber > 100) track.TrackNumber = 0;
                    //if (track.TrackNumber > 0)
                    //{
                    //    l_trackNumber = track.TrackNumber;
                    //}

                    //CPieceReference l_details = new CPieceReference(l_Artist, l_Album, l_Name, l_trackNumber);

                    //int l_year = -1; if (track.Year > 0) l_year = track.Year;
                    //CPieceInfo l_infos = new CPieceInfo(l_year);

                    //int l_rating = 0; if (track.Rating > 0) l_rating = track.Rating;


                    //DateTime l_date = DateTime.MinValue; if (track.PlayedDate > DateTime.MinValue) l_date = track.PlayedDate;

                    //int l_duration = track.Duration;
                    //bool l_enabled = track.Enabled;


                    //CPiece l_piece = new CPiece(l_details, l_strFile, l_infos, l_rating, l_date, l_duration, l_enabled);
                    TrackInfoItunes l_piece = create(location);
                    l_piece.build(track);
                    //new TrackInfoItunes(track);
                    // l_piece.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                    m_htTracks[l_id] = track;
                    m_htPieces[l_id] = l_piece;
                    //l_piece.ID = l_id;
                    //   buildArt(track); 
                    list.Add(l_piece);
                    //  log.log("add track {0}", l_piece);

                }
            }

            log.log("FIN LoadTracksNative ");
            //list = new CListPieceWithoutPodcast(m_htPieces.Values);
        }

        ///// <summary>
        ///// Récupération d'un track  Itunes en fonction de son index
        ///// </summary>
        ///// <param name="id"></param>
        ///// <returns></returns>
        //public IITFileOrCDTrack getTrack(string location)
        //{
        //    if (m_htFileTracks.ContainsKey(location))
        //        return m_htFileTracks[location];

        //    foreach (IITTrack t in app.LibraryPlaylist.Tracks)
        //    {
        //        if (t.Kind == ITTrackKind.ITTrackKindFile)
        //        {
        //            IITFileOrCDTrack track = t as IITFileOrCDTrack;
        //            string _loc = track.Location;
        //            if (!m_htFileTracks.ContainsKey(_loc))
        //            {
        //                m_htFileTracks.Add(_loc, track);
        //                if (location.Equals(_loc))
        //                    return track;
        //            }
        //        }
        //    }

        //    return null;



        //}
        /// <summary>
        /// Récupération d'un track en vue de le supprimmer
        /// </summary>
        /// <param name="trackInfoItunes"></param>
        /// <returns></returns>
        public TrackId getTrackTrack(TrackInfoItunes trackInfoItunes)
        {
            IITFileOrCDTrack _track = null;
            int ID = trackInfoItunes.ID;

            _track = dictTracks[ID].check(trackInfoItunes.Location);
            TrackPersistantId _id = null;
            TrackId trackId = persist.getTrackTrack(trackInfoItunes.Location);

            if (trackId != null)
            {
                _id = trackId.Id;
                _track = trackId.Track.check(trackInfoItunes.Location);
            }
            #region complique
            if (conf.ComplexSearch)
            {
                if (_track == null)
                {
                    try
                    {
                        enter();
                        int index = list.IndexOf(trackInfoItunes);
                        if (index >= 0)
                            _track = TrackWrapper.create(app.LibraryPlaylist.Tracks[index + 1]).check(trackInfoItunes.Location);


                        if (_track == null)
                        {
                            loadScan("recherche TrackTrack " + trackInfoItunes.Location);
                            return null;
                        }

                        string attendu = trackInfoItunes.Location;
                        string mesure = _track.Location;
                        persist.recordTrack(mesure, _track); // [mesure] = _track;
                        dictTracks[_track.TrackDatabaseID] = _track;

                        if (attendu.Equals(mesure))
                        {
                            //    log.log("-->bg Add track via getTrack: " + _track.Location);
                            // dictTracks[ID] = _track;
                        }
                        else
                        {

                            //   log.log("-->bg Add BAD track via getTrack attendu :{0}, mesuré {1}", attendu, mesure);
                            loadScan("TrackTrack attendu " + attendu + " <> mesuré " + mesure);
                            return null;
                        }
                    }
                    finally { release(); }
                }
            }
            #endregion
            if (_track == null)
                loadScan("?");

            return new TrackId(_id, _track);
        }



        /// <summary>
        /// Récupération d'un track en vue de le modifier
        /// </summary>
        /// <param name="trackInfoItunes"></param>
        /// <returns></returns>
        public IITFileOrCDTrack getTrack(TrackInfoItunes trackInfoItunes)
        {
            IITFileOrCDTrack _track = null;
            int ID = trackInfoItunes.ID;
            //  TrackPersistantId _id = null;
            int IDFound = -1;
            try
            {

                _track = dictTracks[ID];

                if (_track == null)
                {
                    var _t = persist.getTrack(trackInfoItunes.Location);
                    if (_t != null && _t.Track != null)
                    {
                        _track = _t.Track;
                        //_id = _t.Id;
                    }
                }
                BgTask.chrono.bip("getT");
                #region complique
                if (conf.ComplexSearch)
                {
                    if (_track == null)
                    {
                        try
                        {
                            enter();
                            //loadScan("recherche track " + trackInfoItunes);
                            int index = list.IndexOf(trackInfoItunes);
                            if (index >= 0)
                                _track = TrackWrapper.create(app.LibraryPlaylist.Tracks[index + 1]).check(trackInfoItunes.Location);

                            if (_track != null)
                            {
                                IDFound = _track.TrackDatabaseID;
                                dictTracks[IDFound] = _track;
                                dictTrackList[IDFound] = _track;
                                persist.recordTrack(_track); // [_track.Location] = _track;


                                if (IDFound == ID)
                                { //    log.log("getTrack by ID: " + trackInfoItunes.Location);
                                }
                                else if (_track.Location == trackInfoItunes.Location)
                                    log.log("getTrack by location: " + trackInfoItunes.Location);
                                else
                                {
                                    _track = null;
                                }
                            }
                        }
                        finally { release(); }

                    }


                    if (_track == null || _track.TrackDatabaseID != ID)
                    {
                        loadScan("recherche track 2 " + trackInfoItunes);
                        _track = dictTrackList[ID];
                    }


                    if (_track == null || _track.TrackDatabaseID != ID)
                    {
                        loadScan("recherche track 4 " + trackInfoItunes);
                        _track = null;
                    }
                }

                #endregion



            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
                loadScan("recherche track Exception " + trackInfoItunes);
            }

            #region complique
            if (conf.ComplexSearch)
            {
                if (_track != null)
                {
                    IDFound = _track.TrackDatabaseID;
                    dictTracks[IDFound] = _track;
                    dictTrackList[IDFound] = _track;
                    persist.recordTrack(_track);
                }
            }
            #endregion

            // return new TrackId(_id, _track);
            return _track;
        }

        //void Track_classNameChanged(object sender, TrackInfoItunes.TrackClassNameEventArgs e)
        //{
        //    TrackInfoItunes track = sender as TrackInfoItunes;
        //    updateClassList(track);
        //}

        //private void updateClassList(TrackInfoItunes piece)
        //{

        //    List<CPlayList> copy = new List<CPlayList>();
        //    foreach (CPlayList list in piece.ClassPlayLists)
        //    {
        //        PieceInAList pieceInList = list.getPieceInList(piece);
        //        if (pieceInList != null)
        //        {

        //            // deleteTrackInList(pieceInList);
        //            pieceInList.Delete();
        //            //    list.remove(pieceInList);
        //            copy.Add(list); //  piece.removePlayList(list);
        //        }
        //    }

        //    String plName = piece.ClassName;
        //    setClassPlayList(piece, plName);

        //    foreach (CPlayList list in copy)
        //    {
        //        piece.removePlayList(list);
        //    }


        //}

        public IEnumerable<ITrackInfoItunes> ListAllTracks { get { return list; } }
        public IEnumerable<ITrackInfoItunes> ListTracks { get { return list.FindAll(t => !t.isPodcast); } }
        public IEnumerable<ITrackInfoItunes> ListPodCast { get { return list.FindAll(t => t.isPodcast); } }
        public void loadListsNative()
        {
            IITSourceCollection sources = app.Sources;

            for (int i = 1; i <= sources.Count; i++)
            {
                loadPlayListsNative(sources[i]);
            }
            //   Console.WriteLine(root.ToString());
        }

        private bool scanLoaded;
        public void loadScan(string raison)
        {
            if (scanLoaded)
                return;

            lock (this)
            {
                if (scanLoaded)
                    return;
                scanLoaded = true;

                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");
                log.log("!!!!!!!!!!!!!!!!!!!>>>!!!>>>>DEBUT bgLoadTracksNative ( " + raison + " ) ");
                log.logNoDate("***************************************************************************************************");
                log.logNoDate("***************************************************************************************************");


                var loopbgLoadTracksNative = new ThreadUtil(bgLoadTracksNative, "BgT");
                // loopbgLoadTracksNative.Name = "BgT";
                loopbgLoadTracksNative.Start();
            }
        }
        public void loadLists()
        {
            lock (this)
            {
                log.log("Début load list");
                DateTime begin = DateTime.Now;
                // persistentIDs = new Dictionary<string, PlayList>();
                if (listLoaded)
                {
                    foreach (PlayList logical in logicals)
                    {
                        logical.DeleteBase();
                    }
                }
                root.DeleteChilds(); // = new PlayList("root", null);
                gcCollect();
                if (!modeXml)
                {
                    loadListsNative();
                    return;
                }
                // IITSourceCollection sources = app.Sources;


                //for (int i = 1; i <= sources.Count; i++)
                //{
                //    IITSource source = sources[i];
                //    var playlists = source.Playlists;

                //    foreach (IITPlaylist pl in playlists)
                //    {
                //        if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
                //        {
                //            var upl = pl as IITUserPlaylist;
                //            recordlegacyPlayList(upl);
                //        }
                //        checkDetect(begin);
                //    }
                //}


                //if (bParsingNativeAsync)
                //{
                //    Thread loopbgLoadTracksNative = new Thread(bgLoadTracksNative);
                //    loopbgLoadTracksNative.Name = "BgT";
                //    loopbgLoadTracksNative.Start();
                //}



                XmlNode xPlaylists = null;
                int count = contentXml.ChildNodes.Count;
                for (int i = 0; i < count; i += 2)
                {
                    XmlNode aux = contentXml.ChildNodes[i];
                    if (aux.InnerText == "Playlists")
                    {
                        xPlaylists = contentXml.ChildNodes[i + 1];
                        break;
                    }
                    continue;
                }


                foreach (XmlNode xDist in xPlaylists.ChildNodes)
                {
                    string KEY = "key";
                    int ID = -1;
                    string persistentID = null;
                    string parentPersistentID = null;
                    bool forgetIt = false;
                    bool folder = false;
                    string name = null;
                    XmlNode contentList = null;
                    int count2 = xDist.ChildNodes.Count;
                    for (int i = 0; i < count2; i += 2)
                    {
                        XmlNode meta = xDist.ChildNodes[i];
                        string value = xDist.ChildNodes[i + 1].InnerText;
                        if (meta.Name == KEY)
                        {
                            switch (meta.InnerText)
                            {
                                case "Master": forgetIt = true; break;
                                case "Distinguished Kind": forgetIt = true; break;
                                case "Name": name = value; break;
                                case "Playlist ID": ID = Convert.ToInt32(value); break;
                                case "Playlist Persistent ID": persistentID = value; break;
                                case "Folder": folder = true; break;
                                case "Parent Persistent ID": parentPersistentID = value; break;
                                case "Playlist Items": contentList = xDist.ChildNodes[i + 1]; break;

                            }

                        }
                    }

                    if (forgetIt)
                        continue;
                    PlayList parent = null;


                    if (parentPersistentID == null)
                        parent = root;
                    else parent = persistentIDs[parentPersistentID];

                    IITUserPlaylist upl = null;
                    try
                    {
                        upl = m_htLegacyPLayList.getItPl(ID, name);
                    }
                    catch
                    {
                        log.log("impossible de charger la liste " + ID + " " + name);
                        throw;
                    }
                    PlayList current = addChildPlayList2(upl, parent, name, ID, persistentID);
                    log.log("add pl {0}", current);

                    if (folder)
                        continue;
                    if (contentList == null)
                        continue;
                    bool _blogic = false;
                    if (listLoaded)
                    {
                        foreach (PlayList logical in logicals)
                        {
                            if (current.isSubList(logical))
                            {
                                _blogic = true;
                                break;
                            }
                        }
                        if (_blogic)
                            continue;
                    }


                    bool go = filterPlaylist.consider(current);
                    if (!go) continue;

                    ////    if (current.isSubList("gen")) continue;
                    //    if (current.isSubList("auto")) continue;
                    //    if (current.isSubList("d")) continue;
                    //    if (current.isSubList("c")) continue;




                    int countList = contentList.ChildNodes.Count;
                    int ii = 0;
                    foreach (XmlNode xdictTrack in contentList.ChildNodes)
                    {
                        int id = Convert.ToInt32(xdictTrack.ChildNodes[1].InnerText);

                        TrackInfoItunes piece = m_htPieces[id];
                        if (piece == null)
                            continue;

                        TrackInList plPiece = new TrackInList(current, piece, id);
                        plPiece.ID = ID * 1000 * 1000 + ii;
                        current.add(plPiece);
                        //current.addPiece(piece);
                        ii++;
                        afterCreate(current, piece, id);
                    }



                    //   current.scanTracks();



#if VERIF
                current.verif();
#endif
                    log.log("{0} elts", current.ChildsCount);
                }

                if (listLoaded)
                    reintegrateLogical();



                contentXml = null;
                gcCollect();

                checkDetect(begin);
                listLoaded = true;
                log.log("Fin de load Lists");
            }






        }

        private void reintegrateLogical()
        {
            foreach (PlayList pl in logicals)
                pl.reintegrate();
        }

        protected virtual void afterCreate(PlayList playlist, TrackInfoItunes track, int id)
        {
        }

        //private void loadPlayLists(IITSource source)
        //{
        //    log.log("Loader:loadPlayLists source");
        //    IITPlaylist pl;
        //    IITUserPlaylist upl;

        //    for (int index = 1; index <= source.Playlists.Count; index++)
        //    {
        //        pl = source.Playlists[index];
        //        log.log("Loader:loadPlayLists check {0}", pl.Name);
        //        if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
        //        {
        //            upl = pl as IITUserPlaylist;
        //            recordlegacyPlayList(upl);


        //            if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone ||
        //                upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
        //            {

        //                PlayListComposite parent = null;
        //                IITUserPlaylist iparent = upl.get_Parent();
        //                if (iparent != null)
        //                {
        //                    parent = m_htPlayLists[iparent.playlistID];
        //                }
        //                else
        //                {
        //                    parent = root;
        //                }


        //                CPlayList current = addChildPlayList(parent, upl);

        //                if (current.isSubList("gen")) continue;
        //                if (current.isSubList("auto")) continue;
        //                if (current.isSubList("d")) continue;
        //                if (current.isSubList("c")) continue;

        //                log.log("add pl {0}", current);




        //                //current.ID = upl.playlistID;
        //                //m_htPlayLists.Add(upl.playlistID, current);

        //                //parent.add(current);


        //                if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
        //                {
        //                    foreach (IITTrack t in upl.Tracks)
        //                    {
        //                        if (t.Kind == ITTrackKind.ITTrackKindFile)
        //                        {
        //                            IITFileOrCDTrack track = t as IITFileOrCDTrack;
        //                            if (!track.Podcast)
        //                            {
        //                                TrackInfoItunes piece = m_htPieces[track.TrackDatabaseID];
        //                                TrackInList plPiece = new TrackInList(piece, track);
        //                                plPiece.ID = track.trackID;
        //                                m_htPiecesInAList.Add(plPiece.ID, plPiece);
        //                                current.add(plPiece);
        //                                current.addPiece(piece);
        //                            }
        //                        }
        //                    }
        //                    log.log("{0} elts", current.ChildsCount);
        //                }


        //            }

        //        }
        //    }

        //}

        private void loadPlayListsNative(IITSource source)
        {
            log.log("Loader:loadPlayLists source");
            IITPlaylist pl;
            IITUserPlaylist upl;

            for (int index = 1; index <= source.Playlists.Count; index++)
            {
                pl = source.Playlists[index];
                log.log("Loader:loadPlayLists check {0}", pl.Name);
                if (pl.Kind == ITPlaylistKind.ITPlaylistKindUser)
                {
                    upl = pl as IITUserPlaylist;
                    recordlegacyPlayList(upl);


                    if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone ||
                        upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                    {

                        PlayListComposite parent = null;
                        IITUserPlaylist iparent = upl.get_Parent();
                        if (iparent != null)
                        {
                            parent = m_htPlayLists[iparent.playlistID];
                        }
                        else
                        {
                            parent = root;
                        }


                        CPlayList current = addChildPlayList(parent, upl);

                        // if (current.isSubList("gen")) continue;
                        if (current.isSubList("auto")) continue;
                        if (current.isSubList("d")) continue;
                        if (current.isSubList("c")) continue;

                        log.log("add pl {0}", current);




                        //current.ID = upl.playlistID;
                        //m_htPlayLists.Add(upl.playlistID, current);

                        //parent.add(current);


                        if (upl.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                        {
                            foreach (IITTrack t in upl.Tracks)
                            {
                                if (t.Kind == ITTrackKind.ITTrackKindFile)
                                {
                                    IITFileOrCDTrack track = TrackWrapper.create(t); // as IITFileOrCDTrack;
                                    if (!track.Podcast)
                                    {
                                        TrackInfoItunes piece = m_htPieces[track.TrackDatabaseID];
                                        TrackInList plPiece = new TrackInList(piece, track);
                                        plPiece.ID = track.trackID;
                                        // m_htPiecesInAList.Add(plPiece.ID, plPiece);
                                        current.add(plPiece);
                                        // current.addPiece(piece);
                                    }
                                }
                            }
                            log.log("{0} elts", current.ChildsCount);
                        }


                    }

                }
            }

        }

        private CPlayList addChildPlayList(PlayListComposite parent, IITPlaylist iSubList)
        {
            CPlayList subList = new CPlayList(iSubList.Name);
            subList.ID = iSubList.playlistID;
            //  if (m_htPlayLists.ContainsKey(subList.ID))
            m_htPlayLists.Add(subList.ID, subList);
            m_htLegacyPLayList.recordlegacyPlayList(iSubList as IITUserPlaylist);

            parent.add(subList);
            return subList;
        }

        private PlayList addChildPlayList2(IITUserPlaylist upl, PlayList parent, string name, int ID, string persistentID)
        {
            try
            {
                enter();
                if (!m_htPlayLists.ContainsKey(ID))
                {
                    PlayList subList = null;
                    //bool subListIsGenerated = false; // listLoaded && parent.isSubList(gen);
                    //bool subListIsGen = false; // = parent == root && name == "gen";


                    if (listLoaded)
                    {
                        foreach (PlayList logical in logicals)
                        {
                            if (logical.Parent != null && parent != null)
                            {
                                if (parent.isSubList(logical))
                                {
                                    subList = parent.getComposite(ID) as PlayList;
                                    break;
                                }
                            }
                        }
                    }

                    if (subList == null)
                    {

                        var strLists = conf.LogicalLists;
                        for (int l = 0; l < strLists.Count; l++)
                        {
                            if (subList != null)
                                break;
                            string strList = strLists[l];
                            string path = strList; // "root" + strList;
                            string[] parts = path.Split('\\');
                            int count = parts.GetLength(0);
                            PlayListComposite current = root;
                            for (int i = 0; i < count; i++)
                            {
                                string part = parts[i];
                                if (string.IsNullOrEmpty(part))
                                    continue;
                                var plPart = current.getComposite(part) as PlayList;
                                //if (plPart == null)
                                //{
                                //    if (listLoaded)
                                //        break;
                                //}
                                if (i == count - 1)
                                {
                                    if (name == part)
                                    {
                                        if (listLoaded)
                                        {
                                            PlayList pl = logicals.Find(lo => lo.Name == name);
                                            if (pl.Parent == null)
                                            {
                                                current.add(pl);
                                                subList = pl;
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            subList = PlayList.create(name, parent, upl);
                                            if (!logicals.Contains(subList))
                                                logicals.Add(subList);
                                            break;

                                        }
                                    }
                                }

                                current = plPart;
                                if (current == null)
                                    break;
                            }

                        }
                    }

                    //if (listLoaded)
                    //{
                    //    foreach (PlayList logical in logicals)
                    //    {
                    //        if (parent.isSubList(logical))
                    //        {
                    //            subList = parent.getComposite(name) as PlayList;
                    //        }
                    //    }
                    //}



                    //if (subListIsGenerated)
                    //    subList = parent.getComposite(name) as PlayList;
                    //else if (subListIsGen && listLoaded)
                    //{
                    //    subList = gen;
                    //    root.add(gen);
                    //}

                    if (subList == null)
                        subList = PlayList.create(name, parent, upl);
                    //if (subListIsGen)
                    //    gen = subList;

                    if (m_htPlayLists.ContainsKey(ID))
                    {
                        var str = string.Format("zarb:ID{0} subList.ID {1} clé existante {2} {3}", ID, subList.ID, subList.getPath(), m_htPlayLists[ID].getPath());

                    }
                    else
                    {

                        subList.ID = ID;

                        m_htPlayLists.Add(subList.ID, subList);
                        persistentIDs.Add(persistentID, subList);
                    }

                }




            }
            finally { release(); }




            return persistentIDs[persistentID]; // subList;
        }




        private void recordlegacyPlayList(IITUserPlaylist upl)
        {
            //  log.log(upl.playlistID + " " + upl.Name);
            //  m_htLegacyPLayList.Add(upl.playlistID, upl);
        }

        //private void recordlegacyPlayList(IITUserPlaylist upl, int index)
        //{
        //    log.log(upl.playlistID + " " + upl.Name);
        //    m_htLegacyPLayList.Add(index, upl);
        //}

        #endregion

        #region manip
        public PlayListComposite getOrCreateFolder(String folder)
        {
            PlayListComposite plFolder = root.getComposite(folder);
            if (plFolder == null)
            {
                IITPlaylist itFolder = app.createFolder(folder);
                recordlegacyPlayList(itFolder as IITUserPlaylist);
                plFolder = addChildPlayList(root, itFolder);
            }
            return plFolder;
        }

        public PlayListComposite getOrCreateFolder(PlayListComposite folder, String name, bool buildIf)
        {
            PlayListComposite pSub = folder.getComposite(name);
            if (pSub == null && buildIf)
            {
                IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                IITPlaylist itSub = itFolder.createFolder(name);

                pSub = addChildPlayList(folder, itSub);
            }
            return pSub;
        }

        public CPlayList getList(PlayListComposite folder, String name)
        {
            lock (this)
            {
                PlayListComposite plist = folder.getComposite(name);

                if (plist == null)
                {
                    IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                    var itPlist = itFolder.createPlaylist(name);
                    recordlegacyPlayList(itPlist);
                    plist = addChildPlayList(folder, itPlist);
                }
                return plist as CPlayList;
            }

        }

        public PlayList GetPlayList(PlayListComposite folder, string name, bool buildIf)
        {
            if (folder == null)
                return null;
            lock (this)
            {
                PlayListComposite plist = folder.getComposite(name);

                if (plist == null && buildIf)
                {
                    IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                    IITPlaylist itPlist = itFolder.createPlaylist(name);
                    recordlegacyPlayList(itPlist as IITUserPlaylist);
                    plist = addChildPlayList(folder, itPlist);

                    return PlayList.create(name, folder as CPlayList, itPlist as IITUserPlaylist);
                }

                return plist as PlayList;
            }


        }

        public void mergeList(CPlayList playlist, ICollection<IFile> newElements_, HashSet<string> ignore, bool withOrder, IAbortTask writer, IBgTask task)
        {
            PlayList pl = playlist as PlayList;
            if (pl == null)
            {
                log.log("pas un PLayList {0}", playlist);
                return;
            }

            withOrder = !pl.VerifyDoublon;
            if (withOrder)
                pl.mergeListWithOrder(newElements_, writer, task);
            else
                pl.mergeList(newElements_, ignore, writer, writeOnlyEnabled, writeOnlyUnRead);
        }




        public void removeList(PlayListComposite folder, String name)
        {
            PlayListComposite plist = folder.getComposite(name);
            if (plist != null)
            {
                IITPlaylist itPlist = m_htLegacyPLayList.getItPl(plist.ID, plist.Name);
                itPlist.Delete();
                m_htLegacyPLayList.Remove(plist.ID, plist.Name);
                m_htPlayLists.Remove(plist.ID);
                folder.remove(plist);
            }
        }

        public void SynchronizePodcast()
        {
            log.log("UpdateIPod");
            app.UpdateIPod();
        }

        public void addList(PlayListComposite folder, String name, ICollection<IFile> list)
        {
            lock (this)
            {
                IITUserPlaylist itFolder = m_htLegacyPLayList.getItPl(folder.ID, folder.Name);
                IITUserPlaylist itPlist = itFolder.createPlaylist(name);
                recordlegacyPlayList(itPlist as IITUserPlaylist);

                if (list.Count == 0) return;

                //   String[] paths = new String[list.Count+1];

                //for(int i=0; i<list.Count; i++)
                //{
                //    paths[i+1] = list[i].Path ; 
                //}
                //   object objPath = (object)paths;
                //   itPlist.AddFiles(ref objPath); 



                foreach (IFile piece in list)
                {
                    itPlist.AddFile(piece.Location);
                }
            }
        }
        #endregion

        ///// <summary>
        ///// Rangement de la classList
        ///// </summary>
        ///// <param name="track"></param>
        ///// <param name="orgClassName"></param>
        ///// <param name="newClassName"></param>
        //public void setClassPlayList(TrackInfoItunes track, string orgClassName, string newClassName)
        //{
        //    lock (this)
        //    {

        //        //1. Suppression
        //        var list = new List<CPlayList>(track.ClassPlayLists);
        //        foreach (CPlayList pl in list)
        //        {
        //            if (pl.Name.Equals(newClassName))
        //                continue;
        //            var trackInList = pl.getPieceInList(track);
        //            if (trackInList != null)
        //                trackInList.Delete();
        //        }

        //        //2. vérif que la liste cible ne contient pas déjà le track
        //        foreach (CPlayList pl in list)
        //        {
        //            if (!pl.Name.Equals(newClassName))
        //                continue;
        //            var trackInList = pl.getPieceInList(track);
        //            if (trackInList != null)
        //                return;
        //        }

        //        //3. ajout
        //        PlayList newpl = getClassPlayList(newClassName);
        //        newpl.Add(track.Location, "setClassPlayList", true);

        //    }


        //}

        public PlayList getFolderOrList(PlayList root, string name, bool findFolder)
        {
            if (root == null)
                root = this.root;
            var current = root;

            foreach (PlComponent plComponent in current)
            {
                if (plComponent is PlayListComposite)
                {
                    var plComposite = plComponent as PlayListComposite;
                    if (plComposite.Name == name)
                    {
                        var playList = plComposite as PlayList;
                        var specialKind = ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone;
                        if (findFolder)
                            specialKind = ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder;
                        if (playList.ItPlayList.SpecialKind == specialKind)
                        {
                            return playList;

                        }
                    }

                }
            }

            return null;

        }

        private PlayList searchClassList(PlayList current, string listName)
        {
            foreach (PlComponent plComponent in current)
            {
                if (plComponent is PlayListComposite)
                {

                    var plComposite = plComponent as PlayListComposite;
                    var name = plComposite.Name;

                    bool sameBase = true;

                    for (int i = 0; i < listName.Length && i < name.Length; i++)
                    {
                        if (!listName[i].Equals(name[i]))
                        {
                            sameBase = false;
                            break;
                        }
                    }

                    if (!sameBase)
                        continue;

                    var playList = plComposite as PlayList;
                    var subSearch = searchClassList(playList, listName);

                    if (subSearch != null)
                        return subSearch;

                    if (name.Equals(listName))
                    {
                        if (playList.ItPlayList.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                            return playList;
                    }

                }
            }
            return null;
        }


        private PlayList getClassPlayList(string listName)
        {
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;
                var classement = root.getComposite(CPlayList.CLASSEMENT) as PlayList;

                var search = searchClassList(classement, listName);
                if (search != null)
                    return search;
                var current = classement;

                for (int i = 0; i < listName.Length - 1; i++)
                {
                    String FolderOrList = listName.Substring(0, i + 1);
                    PlayList found = getFolderOrList(current, FolderOrList, true);

                    if (found == null)
                    {
                        IITUserPlaylist itFolder = current.ItPlayList.createFolder(FolderOrList);
                        recordlegacyPlayList(itFolder as IITUserPlaylist);
                        found = PlayList.create(FolderOrList, current, itFolder);
                    }
                    current = found as PlayList;
                }

                var last = getFolderOrList(current, listName, false);
                if (last == null)
                {

                    IITUserPlaylist itPlayList = current.ItPlayList.createPlaylist(listName);
                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    last = PlayList.create(listName, current, itPlayList);


                }

                return last as PlayList;
            }

        }


        private PlayList getClassPlayList__OLD(string listName)
        {
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;
                var classement = root.getComposite(CPlayList.CLASSEMENT) as PlayList;
                var current = classement;

                for (int i = 0; i < listName.Length - 1; i++)
                {
                    String FolderOrList = listName.Substring(0, i + 1);
                    PlayList found = getFolderOrList(current, FolderOrList, true);

                    if (found == null)
                    {
                        IITUserPlaylist itFolder = current.ItPlayList.createFolder(FolderOrList);
                        recordlegacyPlayList(itFolder as IITUserPlaylist);
                        found = PlayList.create(FolderOrList, current, itFolder);
                    }
                    current = found as PlayList;
                }

                var last = getFolderOrList(current, listName, false); // current.getComposite(listName);
                if (last == null)
                {
                    //if (current.ItPlayList.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                    //{
                    IITUserPlaylist itPlayList = current.ItPlayList.createPlaylist(listName);
                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    last = PlayList.create(listName, current, itPlayList);
                    //}

                }

                return last as PlayList;
            }

        }


        public PlayList getOrCreatePlayList(PlayList root, string listName, bool isFolder)
        {
            if (_aborted)
                return null;
            lock (this)
            {
                if (listName.isNullorEmpty())
                    return null;

                if (root == null)
                    root = this.root;


                var pl = getFolderOrList(root, listName, isFolder);

                if (pl == null)
                {
                    if (_aborted)
                        return null;
                    IITUserPlaylist itPlayList = null;
                    if (isFolder)
                    {
                        if (root == this.root)
                            itPlayList = app.createFolder(listName);
                        else
                            itPlayList = root.ItPlayList.createFolder(listName);

                    }
                    else
                    {
                        if (root == this.root)
                            itPlayList = app.createPlaylist(listName);
                        else
                            itPlayList = root.ItPlayList.createPlaylist(listName);
                    }

                    recordlegacyPlayList(itPlayList as IITUserPlaylist);
                    pl = PlayList.create(listName, root, itPlayList);
                }

                return pl;
            }
        }

        //public PlayList getOrCreatePlayList(string listName, bool isFolder)
        //{
        //    return getOrCreatePlayList(this.root, listName, isFolder);
        //}



        public void setClassPlayList(ITrackMetaData piece, String listName)
        {
            lock (this)
            {
                if (String.IsNullOrEmpty(listName)) return;
                //String listName = piece.ClassList;
                IITUserPlaylist itCurrent;
                PlayListComposite classement = getOrCreateFolder(CPlayList.CLASSEMENT);

                PlayListComposite current = classement;


                if (listName.isInteger())
                {

                    for (int i = 0; i < listName.Length; i++)
                    {
                        String FolderOrList = listName.Substring(0, i + 1);

                        PlayListComposite subList = current.getComposite(FolderOrList);
                        //  PlayListComposite parent = current.Parent; 
                        IITUserPlaylist itSubList;
                        // IITUserPlaylist itParent = m_htLegacyPLayList[parent.ID]; 
                        if (subList == null)
                        {
                            itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name);

                            if (itCurrent.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindNone)
                            {

                                var currentName = itCurrent.Name;
                                // suppression et mémorisation des pistes
                                var listAux = new List<ITrackMetaData>();
                                foreach (IITFileOrCDTrack track in itCurrent.Tracks)
                                {
                                    ITrackMetaData pieceToMove = m_htPieces[track.TrackDatabaseID];
                                    listAux.Add(pieceToMove);
                                    // m_htPiecesInAList.Remove(track.trackID);
                                    track.Delete();
                                }

                                // suppression de la liste
                                PlayListComposite parent = current.Parent;
                                IITUserPlaylist itParent = m_htLegacyPLayList.getItPl(parent.ID, parent.Name);

                                itCurrent.Delete();
                                parent.remove(current);
                                m_htPlayLists.Remove(current.ID);

                                // création durépertoire                                                       
                                itCurrent = itParent.createFolder(currentName) as IITUserPlaylist;
                                recordlegacyPlayList(itCurrent);
                                current = addChildPlayList(parent, itCurrent);

                                //remplacement de la liste supprimée
                                IITUserPlaylist itRempl = itCurrent.createPlaylist(currentName) as IITUserPlaylist;
                                recordlegacyPlayList(itRempl);
                                PlayListComposite rempl = addChildPlayList(current, itRempl);

                                // ajout des morceaux
                                foreach (ITrackMetaData pieceToMove in listAux)
                                {
                                    IITOperationStatus status = itRempl.AddFile(pieceToMove.Location);
                                    IITFileOrCDTrack track = TrackWrapper.create(status.Tracks[1]); // as IITFileOrCDTrack;

                                    TrackInList plPiece = new TrackInList(pieceToMove, track);
                                    plPiece.ID = track.trackID;
                                    //  m_htPiecesInAList.Add(plPiece.ID, plPiece);
                                    rempl.add(plPiece);
                                }

                            }
                            itSubList = i < listName.Length - 1 ? itCurrent.createFolder(FolderOrList) as IITUserPlaylist : itCurrent.createPlaylist(FolderOrList) as IITUserPlaylist;
                            recordlegacyPlayList(itSubList as IITUserPlaylist);
                            subList = addChildPlayList(current, itSubList);
                        }
                        current = subList;
                    }

                }
                else
                {
                    PlayListComposite subList = current.getComposite(listName);
                    if (subList == null)
                    {
                        itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name); // [current.ID];
                        IITPlaylist itSubList = itCurrent.createPlaylist(listName);
                        recordlegacyPlayList(itSubList as IITUserPlaylist);
                        subList = addChildPlayList(current, itSubList);
                    }
                    current = subList;
                }

                itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name); //  [current.ID];
                if (itCurrent.SpecialKind == ITUserPlaylistSpecialKind.ITUserPlaylistSpecialKindFolder)
                {
                    PlayListComposite sub = current.getComposite(itCurrent.Name);
                    if (sub == null)
                    {
                        IITUserPlaylist itSubList = itCurrent.createPlaylist(itCurrent.Name) as IITUserPlaylist;
                        recordlegacyPlayList(itSubList);
                        sub = addChildPlayList(current, itSubList);
                    }
                    current = sub;
                    itCurrent = m_htLegacyPLayList.getItPl(current.ID, current.Name);
                }


                {
                    IITOperationStatus status = itCurrent.AddFile(piece.Location);
                    if (status == null)
                    {
                        log.log("unable to add {0}", piece);
                        return;
                    }

                    IITFileOrCDTrack track = TrackWrapper.create(status.Tracks[1]); // as IITFileOrCDTrack;

                    if (track == null)
                    {
                        log.log("unable to add {0}", piece);
                        return;
                    }

                    TrackInList plPiece = new TrackInList(piece, track);
                    plPiece.ID = track.trackID;
                    //  m_htPiecesInAList.Add(plPiece.ID, plPiece);
                    current.add(plPiece);
                    TrackInfoItunes trackBib = m_htPieces[track.TrackDatabaseID];
                    CPlayList pl = current as CPlayList;
                    //if (pl != null)
                    //    pl.addPiece(trackBib);

                }
            }


        }
        //public ITrackMetaData getTrack(ITrackMetaData piece)
        //{
        //    TrackInfoItunes track = piece as TrackInfoItunes; 
        //    if (track == null || !exists(piece) )
        //        return new TrackInfoItunes(getNewTrack(piece));

        //    return track;
        //}


        //public IITFileOrCDTrack AddFile(IITUserPlaylist pl, string location)
        //{
        //    IITFileOrCDTrack track = null;
        //    IITOperationStatus status = pl.AddFile(location);
        //    if (status == null)
        //    {
        //        log.log("{0} : unable to AddFile {0}", pl.Name, location);
        //        return null;
        //    }
        //    while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
        //    {
        //        Thread.Sleep(30);
        //    }

        //    track = status.Tracks[1] as IITFileOrCDTrack;
        //    return track;
        //}

        public void discover(TrackInfoItunes t)
        {
            createTrack(t, true);
        }

        public virtual void createTrack(TrackInfoItunes piece, bool podcast)
        {

            try
            {
                log.log(String.Format("create track for {0}", piece.Location));
                IITFileOrCDTrack track = null;
                IITOperationStatus status = app.LibraryPlaylist.AddFile(piece.Location);
                if (status == null)
                {
                    log.log(String.Format("unable to load track {0}", piece.ToString()));
                    return;
                }
                while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
                {
                    Thread.Sleep(30);
                }

                track = TrackWrapper.create(status.Tracks[1]);

                if (track.Location == null)
                {
                    log.log(String.Format("track sans localaisation {0}", piece));
                    piece.TrackTrack = new NoTrack(piece);
                    return;
                }

                if (m_htTracks.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    piece.TrackTrack = track;
                    return; // m_htTracks[track.TrackDatabaseID];
                }

                m_htTracks.Add(track.TrackDatabaseID, track);

                if (m_htPieces.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    piece.TrackTrack = track;
                    return; // m_htTracks[track.TrackDatabaseID];
                }

                // intern.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);


                //var id = persist.recordTrack(track);
                //intern.PersistantId = id;

                m_htPieces.Add(track.TrackDatabaseID, piece);
                m_htLoc.Add(piece.Location, piece);
                piece.TrackTrack = track;

                if (podcast && track.Genre != "Podcast")
                {
                    try { track.Genre = "Podcast"; }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }


                var album = track.Album;
                if (string.IsNullOrEmpty(album))
                {
                    var f = new FileInfo(piece.Location);
                    album = f.Directory.Name;
                }

                //if (piece.TrackAlbum == null)
                //{
                //    piece.setAlbum(album);
                //}
            }
            catch (Exception e)
            {
                log.log(e.ToString());
            }

        }

        public TrackInfoItunes getNewTrack(IFile piece)
        {

            TrackInfoItunes intern = null;
            try
            {
                log.log(String.Format("create track for {0}", piece.ToString()));
                IITFileOrCDTrack track = null;
                IITOperationStatus status = app.LibraryPlaylist.AddFile(piece.Location);
                if (status == null)
                {
                    log.log(String.Format("unable to load track {0}", piece.ToString()));
                    return null;
                }
                while (status.InProgress || (!app.AppCommandMessageProcessingEnabled))
                {
                    Thread.Sleep(30);
                }

                track = TrackWrapper.create(status.Tracks[1]);
                if (m_htTracks.ContainsKey(track.TrackDatabaseID))
                {
                    log.log(String.Format("track déja présent: {0}", piece));
                    return m_htPieces[track.TrackDatabaseID]; // m_htTracks[track.TrackDatabaseID];
                }
                if (track.Location == null)
                {
                    log.log(String.Format("track sans localaisation {0}", piece));
                    return null;
                }

                intern = create(track.Location);
                intern.build(track);
                // intern.classNameChanged += new EventHandler<TrackInfoItunes.TrackClassNameEventArgs>(Track_classNameChanged);

                m_htTracks.Add(track.TrackDatabaseID, track);
                //var id = persist.recordTrack(track);
                //intern.PersistantId = id;

                m_htPieces.Add(track.TrackDatabaseID, intern);
                m_htLoc.Add(track.Location, intern);
            }
            catch (Exception e)
            {
                log.log(e.ToString());
            }
            return intern;
        }



        private TrackInfoItunes getNewTrack(ITrackInfoItunes piece)
        {

            //PlayListComposite plNew = root.getComposite("news");
            //IITUserPlaylist itNews;
            //if (plNew == null)
            //{
            //    itNews = app.CreatePlaylist("news") as IITUserPlaylist;
            //    recordlegacyPlayList(itNews);
            //    plNew = addChildPlayList(root, itNews);
            //}

            //itNews = m_htLegacyPLayList[plNew.ID];

            //// String[] path = new String[] { piece.Path };
            //IITOperationStatus status = itNews.AddFile(piece.Path);
            //track = status.Tracks[1] as IITFileOrCDTrack;
            //piece.ID = track.TrackDatabaseID;
            //m_htTracks.Add(track.TrackDatabaseID, track);
            //m_htPieces.Add(track.TrackDatabaseID, piece);
            //return track;

            TrackInfoItunes intern = getNewTrack(piece as IFile);

            try
            {
                intern.Artist = piece.Artist;
            }
            catch { log.log("unable to change artist {0}  {1}", piece.Artist, piece); }
            try
            {
                intern.Album = piece.Album;
            }
            catch { log.log("unable to change album  {0}  {1}", piece.Album, piece); }
            try
            {
                intern.Name = piece.Name;
            }
            catch { log.log("unable to change name  {0}  {1}", piece.Name, piece); }
            try
            {
                if (piece.TrackNumber > 100000) intern.TrackNumber = 0;
                if (piece.TrackNumber > 0)
                {
                    intern.TrackNumber = piece.TrackNumber;
                }
                else
                {
                    intern.TrackNumber = 0;
                }
            }
            catch { log.log("unable to change number  {0} {1}", piece.TrackNumber, piece); }
            if (piece.Year > 0) try { intern.Year = piece.Year; }
                catch { log.log("unable to change year  {0} {1}", piece.Year, piece); }

            if (piece.Rating >= 0) try { intern.Rating = piece.Rating; }
                catch { log.log("unable to change rating  {0} {1}", piece.Rating, piece); }

            //try
            //{
            //    if (!string.IsNullOrEmpty(piece.ClassName))
            //    {
            //        setClassPlayList(intern, "", piece.ClassName);
            //    }
            //}
            //catch
            //{
            //    log.log("unable to change className  {0} {1}", intern.ClassName, piece);
            //}

            try { intern.Enabled = piece.Enabled; }
            catch { log.log("unable to change check  {0} {1}", piece.Enabled, piece); }

            return intern;


        }


        //private bool exists(ITrackMetaData piece)
        //{
        //    TrackInfoItunes track = piece as TrackInfoItunes;
        //    if (track == null) return false;
        //    return m_htTracks.ContainsKey(track.ID);
        //}

        public ITrackInfoItunes createLegacyTrack(ITrackInfoItunes piece)
        {
            return getNewTrack(piece);
        }

        //public IITTrackCollection Tracks
        //{
        //    get { return app.LibraryPlaylist.Tracks; }
        //}

        public void Disconnect()
        {
            app = null;
            gcCollect();
        }
        private void gcCollect()
        {
            if (conf.GcCollect)
                misc.gcCollect("Loader");
        }
        public String DbPath { get { return _dBLegacyPath; } }
        public string DbDir { get { return _dBLegacyDir; } }

        public void deleteTrack(String location)
        {
            if (location.isNullorEmpty())
            {
                log.log("Loader: unable to delete track, location empty!");
                return;
            }
            location = location.ToLower();
            //     private Dictionary<int, TrackInfoItunes> m_htPieces = new Dictionary<int, TrackInfoItunes>();
            //private Dictionary<int, IITFileOrCDTrack> m_htTracks = new Dictionary<int, IITFileOrCDTrack>();
            // private Dictionary<int, IITFileOrCDTrack> m_htPiecesInAList = new Dictionary<int, IITFileOrCDTrack>();
            // private Dictionary<int, PlayListComposite> m_htPlayLists = new Dictionary<int, PlayListComposite>();
            // private Dictionary<int, IITUserPlaylist> m_htLegacyPLayList = new Dictionary<int, IITUserPlaylist>();
            TrackInfoItunes info = null;
            foreach (TrackInfoItunes _info in m_htPieces.Values)
            {
                if (_info.Location.isNullorEmpty()) continue;
                if (_info.Location.ToLower() == location)
                {
                    info = _info;
                    break;
                }

            }
            if (info == null)
            {
                log.log("Loader:deleteTrack '{0}' non trouvé", location);
                return;
            }

            try
            {
                log.log("Loader:deleteTrack: delete'{0}'", location);
                int ID = info.ID;
                // IITFileOrCDTrack track = info.Track;

                List<TrackInList> listToDelete = new List<TrackInList>();
                //foreach (TrackInList trackInList in info.ClassPlayLists
                //{
                //    if (trackInList.ID == ID)
                //    {
                //        listToDelete.Add(trackInList);
                //    }
                //}

                //foreach (TrackInList trackInList in listToDelete)
                //{
                //    m_htPiecesInAList.Remove(trackInList.ID);
                //    trackInList.Delete();
                //}


                info.Delete();
                list.Remove(info);
                //buildIndexesTracks();
            }
            catch
            {

                log.log("Loader:unable to deleteTrack: '{0}'", location);
            }
        }



        public ITrackInfoItunes createTrack(int id, String location)
        {
            if (!location.isMusic())
                return null;
            //if (location.ToLower().EndsWith(".m3u")) return null;
            //if (location.ToLower().EndsWith(".pls")) return null;
            //if (location.ToLower().EndsWith(".jpg")) return null;
            //if (location.ToLower().EndsWith(".png")) return null;
            return getNewTrack(new FileLocation(location, id));
        }
        private class FileLocation : IFile
        {
            String file;
            int id;
            public FileLocation(String file, int id) { this.file = file; this.id = id; }
            public string Location { get { return file; } }

            public override string ToString()
            {
                return file;
            }



            public int PieceId
            {
                get { return id; }
            }


            public string getPath()
            {
                return file;
            }
        }


        public PlayListComposite TreePlayList
        {
            get { return root; }
        }



        #region ITrackBuilder Members



        #endregion

        public virtual TrackInfoItunes create(string location)
        {
            return new TrackInfoItunes() { File = RelativeFileRegister.Get(location) };
        }

        # region lecture
        private AutoPlayer player;
        public List<TrackInList> NextTracks { set { player.NextTracks = value; } }
        public TrackInList CurrentTrackInList { get { return player.CurrentTrack; } }
        public void PlayComputedTrack()
        {
            player.PlayComputedTrack();
        }
        //private TrackInList nextTrack;
        //private TrackInList currentTrack; 
        //public TrackInList NextTrack
        //{
        //    set
        //    {
        //        if (value == null)
        //            return;
        //        log.log("NextTrack:: old : {0}, new {1}", nextTrack, value);
        //        nextTrack = value;
        //    }
        //    get
        //    {
        //        return nextTrack;
        //    }
        //}

        //public TrackInList CurrentTrackInList
        //{
        //    set
        //    {
        //        if (value == null)
        //            return;
        //        log.log("CurrentTrack:: old : {0}, new {1}", currentTrack, value);
        //        currentTrack = value;
        //    }
        //    get
        //    {
        //        return currentTrack;
        //    }
        //}

        //public void PlayComputedTrack()
        //{
        //    if (conf == null || !conf.AutoPlay)
        //        return;
        //    try
        //    {
        //        if (app.PlayerState != ITPlayerState.ITPlayerStatePlaying)
        //            return;
        //        var usualTrack = CurrentTrackLocation;
        //        if (nextTrack == null)
        //            return;
        //        if (currentTrack == null)
        //            return;
        //        if (usualTrack.Equals(currentTrack.Location))
        //            return;
        //        if (usualTrack.Equals(nextTrack.Location))
        //            return;
        //        log.log("PlayComputedTrack::usualTrack:{0} nextTrack:{1}", usualTrack, nextTrack.Location);
        //        nextTrack.play();
        //        currentReading = nextTrack.Location;
        //        nextTrack = null;


        //    }
        //    catch (Exception e)
        //    {
        //        log.log(e.ToString());
        //    }


        //}
        #endregion

        private bool _aborted;
        public bool Aborted
        {
            get
            {
                return _aborted;
            }
            set
            {
                _aborted = value;
            }
        }
    }

    public static class TrackUtil
    {

    }
}


]]></content>
  </file>
  <file path="db4\pieceDb.iT\PlayList.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using iTunesLib;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.IO;
using pdb.it.persistance;

namespace pdb.it
{


    public class PlayList : CPlayList, IPlayList, pdb.iit.IPlayList
    {
        private static Loader loader;
        private static Conf conf;
        private static volatile object _lockP = new object();

        private string path;

        public static Loader Loader { set { loader = value; } }
        //  private static int nbReq;
        // private static int nbErr;
        //  private volatile object _lock = new object();
        //private bool scanLaunched = false; 
        // private int indexScan = 1;
        private static BgDictString<int> dictIndex = new BgDictString<int>();
        public static Conf Conf
        {
            set
            {
                conf = value;
                _singleThread = conf.SingleThread;
                scanListLimit = conf.ScanListLimit;
                _gcCollect = conf.GcCollect;
                NbScan = conf.MaxScan;
            }
        }
        private void enter()
        {
            if (_singleThread)
            {
                BgTask.chrono.bip("pl:ent0");
                Locker.Enter();
                BgTask.chrono.bip("pl:ent1");
            }
        }
        private void release()
        {
            if (_singleThread)
                Locker.Release();
        }

        private static bool scanListLimit;
        public static bool ScanListLimit { set { scanListLimit = value; } }
        public bool VerifyDoublon { set { verifyDoublon = value; } get { return verifyDoublon; } }

        private IITUserPlaylist _pl;
        public IITUserPlaylist ItPlayList { get { return _pl; } }

        private static bool _singleThread;
        //  public static bool SingleThread { set { _singleThread = value; } }

        private static bool _gcCollect;

        private bool _abort;
        public static void AbortOpe()
        {
            lock (playLists)
            {
                foreach (PlayList pl in playLists)
                    pl._abort = true;
                //  playLists.Clear();
            }
        }

        public static void StartOpe()
        {
            lock (playLists)
            {
                foreach (PlayList pl in playLists)
                    pl._abort = false;
                //  playLists.Clear();
            }
        }

        private static void addScan(PlayList pl)
        {

            //   log.log("===============>debut scan de {0}", pl);

        }



        private static void removeScan(PlayList pl)
        {

            //   log.log("===============>fin scan de {0}", pl);

        }

        private bool verifyDoublon = true;

        private static List<PlayList> playLists = new List<PlayList>();
        public static PlayList create(string name, CPlayList parent, IITUserPlaylist pl)
        {
            lock (playLists)
            {
                var _pl = new PlayList(name, parent, pl);
                playLists.Add(_pl);
                return _pl;
            }
        }


        public static PlayList create(string name, IITUserPlaylist pl)
        {
            lock (playLists)
            {
                var _pl = new PlayList(name, pl);
                playLists.Add(_pl);
                return _pl;
            }
        }

        protected Logger log;
        public Logger Log { get { return log; } }
        private PlayList(string name, CPlayList parent, IITUserPlaylist pl)
            : base(name, parent)
        {
            this._pl = pl;
            this.path = getPath();
            log = Logger.getLogger(path);
            //this.indexScan = dictIndex[path];
        }
        private PlayList(string name, IITUserPlaylist pl)
            : base(name)
        {
            this._pl = pl;
            this.path = getPath();
            log = Logger.getLogger(path);
            //    this.indexScan = dictIndex[path];
        }
        private static BackGroundTaskMgr _backGroundTaskMgr; //  BackGroundTaskMgr BackGroundTaskMgr("PlayList",false);
        private BackGroundTaskMgr _scanBgMgr;
        private BackGroundTaskMgr _addMgr;
        private static BackGroundTaskMgr _addMgrClassement;
        // private Task task;
        private int nbTaskScan;
        public static int NbScan = 3;

        public bool MaxScan { get { return nbTaskScan > NbScan; } }
        //  private int scanPrior;

        public void updatePriority(scanPriority prior)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                if (prior >= scanPriority.high && isClassSubList())
                    prior = scanPriority.classement;
                BackGroundTaskMgr.checkScanPriority(_scanBgMgr, prior); // _scanBgMgr.Priority = scanPrior;
            }
        }

        public void increasePriority(scanPriority prior)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                if (prior >= scanPriority.high && isClassSubList())
                    prior = scanPriority.classement;
                BackGroundTaskMgr.increaseScanPriority(_scanBgMgr, prior); // _scanBgMgr.Priority = scanPrior;

            }
        }

        public BackGroundTaskMgr ScanMgr
        {
            get
            {
                // getScanMgr();
                return _scanBgMgr;
            }
        }

        private void getScanMgr()
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {

                if (_scanBgMgr == null)
                {
                    lock (this)
                    {
                        if (_scanBgMgr == null)
                        {
                            _scanBgMgr = BackGroundTaskMgr.getMgr("scan " + path, 0);
                            _scanBgMgr.makePersistent();
                        }
                    }
                }

            }
        }
        private void loadScanTracks(bool searchDoublon, PlComponent source)
        {
            scanPriority prior = scanPriority.high;
            if (searchDoublon)
                prior = scanPriority.medium;
            increasePriority(prior);

            TaskScan task = TaskScan.create(this, source);
            //if (currentTaskScan == null)
            //{
            //    lock (this)
            //    {
            //        if (currentTaskScan == null)
            //            task = new TaskScan(this);
            //    }
            //}


            if (task == null)
                return;


            if (scanListLimit)
            {
                if (_backGroundTaskMgr == null)
                {
                    lock (this)
                    {
                        if (_backGroundTaskMgr == null)
                            _backGroundTaskMgr = BackGroundTaskMgr.getMgrlarge("PlayList");
                    }
                }
                _backGroundTaskMgr.add(task);
            }
            else
            {
                //if (currentTaskScan == null)
                //{
                //    lock (this)
                //    {
                //        if (currentTaskScan == null)
                //        {
                var th = new ThreadUtil(task.exec, path);
                th.Start();
                //}

                //}
                //}
            }




            //    return;
            //scanLaunched = true; 
            //_backGroundTaskMgr.add(new Task(this)); // new Thread(_scan).Start();
        }

#if V
       private BgDict<string, TrackInList> dict = new BgDict<string, TrackInList>();
#endif

        //private BackGroundTaskMgr _classement;
        //private BackGroundTaskMgr _trackList;
        //private void checkBgMgrFriends()
        //{
        //    if (_classement == null)
        //        _classement = BackGroundTaskMgr.FindMgr("Classement");
        //    if (_trackList == null)
        //        _trackList = BackGroundTaskMgr.FindMgr("TrackList " + path);

        //}
        //private TaskScan currentTaskScan = null;
        private void _scan(TaskScan task)
        {
            if (BackGroundTaskMgr.Ordonnancement)
            {
                getScanMgr();
                //if (!_scanBgMgr.IsEnd)
                //{
                //    lock (this)
                //    {
                //        if (!_scanBgMgr.IsEnd)
                //        {
                //            log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                //            log.log("ATTENTION TENTATIVE CONCURRENTE DE SCAN");
                //            log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                //            return;
                //        }
                //    }

                //}

            }


            //lock (this)
            //{
            //    if (currentTaskScan != null)
            //    {
            //        log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            //        log.log("ATTENTION TENTATIVE CONCURRENTE DE SCAN LOCK");
            //        log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            //        return;
            //    }
            //    currentTaskScan = task;
            //}



            addScan(this);


            try
            {
                BgDictString<IITTrack> dict = new BgDictString<IITTrack>();
                int count = 0;
                try
                {
                    enter();
                    count = _pl.Tracks.Count;
                }
                finally
                {
                    release();
                }
                var i = dictIndex[path];
                if (i >= count - 1)
                    i = 0;
                i -= 100;
                if (i < 0)
                    i = 0;

                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                log.log("démarrage tâche scan:{0} index:{1} / {2}", path, i, count);
                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");


                int logNb = 0;
                if (i == 0)
                {
                    nbTaskScan++;
                    logNb = TaskScan.logScan(task);
                }

                var sourceScan = task.source;
                int indexSource = IndexOf(sourceScan);
                string fileSource = sourceScan.Location;

                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                log.log("démarrage tâche scan: nbLog:{0} {1} index:{2} / {3} cause:i={4} {5} ", logNb, path, i, count,
                    indexSource, fileSource);
                log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");

                if (nbTaskScan > 1)
                {
                    log.logNoDate("--------------------------------------------------------------------------------------------------");
                    log.log("{0} NB SCAN {1}/{2}", this, nbTaskScan, NbScan);

                    log.logNoDate("--------------------------------------------------------------------------------------------------");
                }

                if (MaxScan)
                {
                    log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                    log.log("{0} MAX SCAN {1}", this, nbTaskScan);
                    log.logNoDate("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                }



                if (BackGroundTaskMgr.Ordonnancement)
                {
                    while (true)
                    {
                        Scan scanItem = new Scan(this, dict, i);
                        _scanBgMgr.add(scanItem);
                        i++;
                        if (i >= count)
                        {
                            //count = _pl.Tracks.Count;
                            //if (count > i)
                            //{
                            //    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            //    log.log("modification count {0} index:{1} / {2}", path, i, count);
                            //    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            //}
                            //  if (i >= count)
                            break;
                        }
                    }

                    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    log.log("attente fin scan {0} index:{1} / {2}", path, i, count);
                    log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");



                }
                else
                {

                    #region old
                    // for (int i = 1; i <= count; i++)
                    // {

                    //foreach (IITTrack t in _pl.Tracks)

                    for (int ii = i; ii < count; i++)

                    //var enumerator = _pl.Tracks.GetEnumerator();
                    //while (enumerator.MoveNext())
                    {
                        var _track = TrackWrapper.create(_pl.Tracks[ii + 1]); // as IITFileOrCDTrack;// enumerator.Current as IITFileOrCDTrack;

                        // IITTrack t = _pl.Tracks[i];
                        if (_track == null)
                            continue;
                        if (task.Abort) // || _abortScan)
                        {
                            log.log("tache abandonnée {0}", this);
                            return;
                        }
                        try
                        {
                            //if (_singleThread && !BackGroundTaskMgr.Ordonnancement)
                            //    Locker.Enter();
                            if (task.Abort) // || _abortScan)
                            {
                                log.log("tache abandonnée {0}", this);
                                return;
                            }
                            //if (t.Kind  == ITTrackKind.ITTrackKindFile)
                            //{
                            //IITFileOrCDTrack _track = t as IITFileOrCDTrack;
                            //if (t == null)
                            //    continue;

                            //  checkBgMgrFriends();

                            //if (BackGroundTaskMgr.Ordonnancement)
                            //{
                            //    Scan scanItem = new Scan(this, dict, i);
                            //    _scanBgMgr.add(scanItem);
                            //}
                            //else
                            //{

#if V
                    TrackInList track =  dict[_track.Location];

#else
                            if (string.IsNullOrEmpty(_track.Location))
                            {
                                log.log("{0}===============>suppression du track de liste sans localisation ", this);
                                _track.Delete();
                                continue;
                            }

                            if (!FileRegister.ExistNow(_track.Location)) //   conf.CheckFileExist && !File.Exists(_track.Location))
                            {
                                log.log("{0}===============>suppression du track de liste absent du système de fichier", this);
                                _track.Delete();
                                continue;
                            }

                            if (verifyDoublon)
                            {
                                if (dict.ContainsKey(_track.Location))
                                {
                                    log.log("{0} {1}===============>suppression du track de liste en doublon ", this, _track.Location);
                                    _track.Delete();
                                    continue;
                                }
                                dict.Add(_track.Location, _track);
                            }
                            BgTask.chrono.bip("oldscan");
                            loader.recordTrackList(getPath(), _track, _track.TrackDatabaseID, _track.Location, true);

                            TrackInList track = loader.getTrackInList(getPath(), _track.Location);
#endif
                            if (track == null)
                            {
                                //TODO vérifier
                                //log.log("ajout exceptionnel du track {0} à la liste {1}", _track.Location, this);
                                //TrackInfoItunes piece = new TrackInfoItunes(_track);
                                //track = new TrackInList(piece, _track);
                                //add(track);
                                //addPiece(piece);



                            }
                            else
                            {
#if V

#else

#endif

                                track.setTrack(_track);
                            }

                            //}
                            //  }
                        }
                        catch (Exception e)
                        {
                            log.log(e.ToString());
                        }
                        finally
                        {
                            //if (_singleThread && !BackGroundTaskMgr.Ordonnancement)
                            //    Locker.Release();
                        }
                    }

                    #endregion


                }

                if (BackGroundTaskMgr.Ordonnancement)
                {
                    if (_scanBgMgr.Stopped)
                    {
                        log.log("{0} stoppé après la fin de l'empilage, bizarre...", this);
                        _scanBgMgr.start();
                    }
                    while (true)
                    {
                        while (i < count)
                        {
                            i++;
                            Scan scanItem = new Scan(this, dict, i);
                            _scanBgMgr.add(scanItem);
                        }
                        Thread.Sleep(30);
                        if (!_scanBgMgr.IsEnd)
                            continue;
                        int count0 = count;
                        try
                        {
                            enter(); count = _pl.Tracks.Count;
                        }
                        finally { release(); }
                        if (count > count0)
                        {
                            log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                            log.log("modification 2 count {0} index:{1} / {2}", path, i, count);
                            log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");

                        }
                        else
                            break;
                    }



                }

            }

            catch (Exception e)
            {
                log.log(e.ToString());
            }

            finally
            {
                log.logNoDate("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                log.log("fin tâche scan:{0}", path);
                log.logNoDate("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                //lock (this)
                //{
                //    TaskScan.remove(task); // currentTaskScan = null;
                //}
                removeScan(this);
            }


        }

        class Scan : BgTaskBase
        {
            private PlayList pl;
            //  private IITFileOrCDTrack _track;
            private BgDictString<IITTrack> dict;
            private string path;
            private int index;

            public Scan(PlayList pl, BgDictString<IITTrack> dict, int index)
                : base("i=" + index.ToString())
            {
                //    this._track = _track;
                this.pl = pl;
                this.dict = dict;
                this.path = pl.getPath();
                this.index = index;
            }

            public override void exec()
            {
                success = true;
                try
                {
                    pl.enter();
                    var _track = TrackWrapper.create(pl._pl.Tracks[index + 1]);
                    if (_track == null)
                        return;
                    string location = _track.Location;
                    if (string.IsNullOrEmpty(location))
                    {
                        pl.log.log("{0} ===============>suppression du track de liste sans localisation ", path);
                        pl.increasePriority(scanPriority.medium);

                        _track.Delete();
                        return;
                    }

                    //this.Desc = _track.Location; 
                    if (pl.verifyDoublon)
                    {
                        if (dict.ContainsKey(location))
                        {
                            pl.log.log("{0} {1} ===============>suppression du track de liste en doublon ", path, location);
                            pl.increasePriority(scanPriority.medium);
                            _track.Delete();
                            return;
                        }
                        dict.Add(location, _track);
                    }
                    BgTask.chrono.bip("spl:t");
                    PlayList.loader.recordTrackList(path, _track, _track.TrackDatabaseID, location, true);

                    TrackInList track = PlayList.loader.getTrackInList(path, location);
                    PlayList.dictIndex[path] = index;

                    if (track == null)
                    {
                        //track = pl.getPieceInList(new FileImpl(location)) as TrackInList;
                        //if (track == null)
                        //{
                        //success = false;  // bonne idée mais au rejeu on supprimme un faux doublon
                        return;
                        //}

                        //PlayList.loader.recordTrackInList(pl, track, false);
                    }

                    BgTask.chrono.bip("spl:t2");
                    track.setTrack(_track);


                }
                catch (Exception e)
                { pl.log.log("NIET " + e.Message); }




                finally
                {
                    pl.release();
                    //bool highPriority = false;
                    //if (pl._trackList != null && pl._trackList.Contains(path))
                    //    highPriority = true;
                    //else if (pl._classement != null && pl._classement.Contains(path))
                    //    highPriority = true;

                    //pl.checkPriority(highPriority);
                }
            }
        }



        private class FileImpl : IFile
        {
            private string location;
            private int id;

            public FileImpl(string location, int id)
            {
                this.location = Location;
                this.id = id;
            }

            #region IFile Members

            public string Location
            {
                get { return location; }
            }

            public int PieceId { get { return id; } }

            public override bool Equals(object obj)
            {
                var o = obj as IFile;
                if (o == null)
                    return false;
                return location.Equals(o.Location);

            }

            public override int GetHashCode()
            {
                return location.GetHashCode();
            }

            public override string ToString()
            {
                return location;
            }

            #endregion


            public string getPath()
            {
                return location;
            }
        }
        //public override bool Contains(string location)
        //{
        //    bool ret =  base.Contains(location);
        //    if (!ret)
        //        return ret;
        //    return loader.LogicalContainsTrackInList(path, location); 
        //}

        public bool LogicalContainsTrackInList(string location)
        {
            return loader.LogicalContainsTrackInList(path, location);
        }

        public bool LogicalTrackInListDeleted(TrackInList track)
        {
            return loader.LogicalTrackInListDeleted(path, track.Location);
        }

        public void removeTrack(TrackInList track)
        {
            // if (!Contains(track.Location))
            loader.removeTrackInList(path, track, _pl);
            loader.LogicalRemoveTrackInList(path, track);
        }


        public void invalidationTrack(TrackInList track)
        {
            loader.invalidationTrackInList(path, track, _pl);
        }

        //public void locateNextTrack(TrackInList current, IFile nextLocation)
        //{
        //    if (current == null)
        //        return; 
        //    int count = Count;

        //    current.locate();
        //    loader.CurrentTrackInList = current;

        //    var next = getPieceInList(nextLocation) as TrackInList; 

        //    if (next != null)
        //    {
        //        next.locate();
        //        loader.NextTrack = next; 
        //    }
        //}

        public void recordNextTracks(List<IFile> nextLocation)
        {

            var list = new List<TrackInList>();

            foreach (IFile file in nextLocation)
            {
                var track = getPieceInList(file) as TrackInList;
                if (track == null)
                    continue;
                if (!track.Enabled)
                    continue;
                list.Add(track);
            }

            loader.NextTracks = list;
        }


        public void findTrack(TrackInList track)
        {

            string location = track.Location;
            var memo = loader.getMemoTrackList(path, _pl, location);
            if (memo != null && memo.Track != null)
            {
                track.setTrack(memo.Track);
                return;
            }

            #region complique
            bool _ok = false;
            if (conf.ComplexSearch)
            {
                //  loadScanTracks(false);




                int index = IndexOf(track);
                IITFileOrCDTrack _track1 = null;
                IITFileOrCDTrack _track2 = null;
                if (index >= 0)
                {
                    try
                    {
                        BgTask.chrono.bip("plf:0");
                        enter();
                        _track1 = TrackWrapper.create(_pl.Tracks[index + 1]); // as IITFileOrCDTrack;
                    }
                    finally
                    {
                        release();
                    }
                    BgTask.chrono.bip("plf:1");
                    //if (_track == null)
                    try
                    {
                        enter();
                        _track2 = TrackWrapper.create(_pl.Tracks.ItemByPlayOrder[index + 1]); // as IITFileOrCDTrack;
                        BgTask.chrono.bip("plf:2");
                    }
                    finally { release(); }

                }
                //if (_track1 == null || _track2 == null)
                //{
                //    // nbErr++;
                //    loadScanTracks(false, track);
                //    return;
                //}

                string location1 = null;
                string location2 = null;

                //TrackPersistantId id1 = null;
                //TrackPersistantId id2 = null;


                try
                {
                    enter();
                    if (_track1 != null)
                    {
                        location1 = _track1.Location;
                        if (!string.IsNullOrEmpty(location1) && (FileRegister.ExistNow(location1))) //  conf.CheckFileExist || File.Exists(location1)))
                        {
                            _ok = true;
                            if (location1 != location)
                                loader.recordTrackList(path, _track1, _track1.TrackDatabaseID, location1, true);
                        }
                    }
                    if (_track2 != null)
                    {

                        location2 = _track2.Location;
                        if (!string.IsNullOrEmpty(location2) && (FileRegister.ExistNow(location2)))
                        {
                            _ok = true;
                            if (location2 != location)
                                loader.recordTrackList(path, _track2, _track2.TrackDatabaseID, location2, true);
                        }
                    }

                    if (!_ok)
                    {
                        loadScanTracks(false, track);
                        return;
                    }


                }
                catch (Exception ex)
                {
                    log.log("findTrack::", ex);
                    //nbErr++;
                    loadScanTracks(false, track);
                    return;
                }
                finally { release(); }

#if V
                            TrackInList track2 = dict[location];
#else
                _ok = false;
                TrackInList track21 = loader.getTrackInList(path, location1);
                TrackInList track22 = loader.getTrackInList(path, location2);
#endif


                if (track21 == track)
                {
                    _ok = true;
                    track21.setTrack(_track1);
                    //log.log("==>track bien retrouvé par index {0}/{1} {2} {3} ", (nbReq - nbErr), nbReq, this, track);
                }

                if (track22 == track)
                {
                    _ok = true;
                    track22.setTrack(_track2);
                    //log.log("==>track bien retrouvé par index {0}/{1} {2} {3} ", (nbReq - nbErr), nbReq, this, track);
                }
            }

            #endregion

            if (!_ok)
                loadScanTracks(false, track);



        }

        private class mergeListWithOrderTask
        {
            private PlayList playlist;
            private ICollection<IFile> newElements_;
            private IAbortTask writer;
            private IBgTask task;
            private Logger log;
            public mergeListWithOrderTask(PlayList playlist, ICollection<IFile> newElements_, IAbortTask writer, IBgTask task)
            {
                this.playlist = playlist;
                this.newElements_ = newElements_;
                this.writer = writer;
                this.task = task;
                log = playlist.log;
            }

            public void launch()
            {
                new Thread(go).Start();
            }

            private void go()
            {
                var newElements = new List<IFile>(newElements_);

                playlist.verifyDoublon = false;

                IITFileOrCDTrack currentPlaying = null;
                string currentAlbum = "----";

                try
                {
                    lock (playlist)
                    {


                        try
                        {
                            if (loader.CurrentPlaylist == playlist)
                            {
                                if (loader.PlayerState == ITPlayerState.ITPlayerStatePlaying)
                                {
                                    currentPlaying = loader.CurrentTrack;
                                    if (currentPlaying != null)
                                        //  currentIndex = currentPlaying.Index;
                                        currentAlbum = currentPlaying.Album;
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            log.log("impossible de déterminer la liste courante", ex);
                        }
                    }


                    // 1. suppression
                    //List<TrackInList> toDelete = new List<TrackInList>();
                    //List<IFile> toAdd = new List<IFile>();



                    //123475
                    //15634


                    // phase 1 
                    int iNew = 0;
                    int iThis = 0;

                    int newCount = newElements.Count;
                    //int thisCount = this.LeafsCount;

                    DateTime debut = DateTime.Now;
                    log.log("debut calcul liste triée " + this);


                    while (true)
                    {
                        if (writer.Aborted || task.Abort || playlist._abort) return;
                        TrackInList currentList = null;
                        if (iThis >= newCount)
                        {
                            currentList = playlist[iThis] as TrackInList;
                            while (currentList != null)
                            {
                                if (writer.Aborted || task.Abort || playlist._abort) return;
                                if (currentAlbum != currentList.Piece.Album)
                                    currentList.Delete();
                                iThis++;
                                currentList = playlist[iThis] as TrackInList;
                            }

                            break;
                        }



                        IFile newCurrent = null;

                        try
                        {
                            newCurrent = newElements[iNew];
                        }
                        catch (Exception ex)
                        {
                            log.log("impossible d'accéder à l'item " + iNew + " " + ex.ToString());
                            break;

                        }



                        var toDelete = new List<IBgTask>();
                        while (true)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            if (iThis >= playlist.LeafsCount)
                                currentList = null;
                            else
                            {
                                currentList = playlist[iThis] as TrackInList; // _pl.Tracks[iThis + 1] as IITFileOrCDTrack;
                            }

                            if (currentList == null)
                                break;
                            // currentListLocation = currentList.Location;
                            if (newCurrent.Location.Equals(currentList.Location))
                            {
                                break;
                            }

                            var _task = currentList.delete();
                            toDelete.Add(_task);


                            iThis++;

                        }

                        if (toDelete.Count > 0)
                            log.log("{0} {1} elt to delete", this, toDelete.Count);



                        while (true)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            var found = toDelete.Find(t => !t.Success);
                            if (found == null)
                                break;
                            Thread.Sleep(30);
                        }



                        if (currentList == null)
                        {
                            if (writer.Aborted || task.Abort || playlist._abort) return;
                            var taskAdd = playlist.Add(newCurrent.Location, string.Format("{0}/{1}", iNew, playlist.LeafsCount), true);

                            while (!taskAdd.Success)
                            {
                                if (writer.Aborted || task.Abort || playlist._abort) return;
                                Thread.Sleep(30);
                            }



                        }
                        else
                        {

                            if (currentAlbum != currentList.Piece.Album && !currentList.Location.Equals(newCurrent.Location))
                                throw new ApplicationException();
                        }

                        iNew++;
                        iThis = iNew;




                    }


                    log.log("fin de lancement liste triée " + (int)((DateTime.Now - debut).TotalMilliseconds) + " ms " + this);


                }

                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }

                //finally
                //{
                //    try
                //    {
                //        bool _break = false;
                //        if (currentPlaying != null)
                //        {

                //            var newCurrent = loader.CurrentTrack;
                //            string location = null;
                //            try
                //            {
                //                location = currentPlaying.Location;
                //                if (location == newCurrent.Location)
                //                    _break = true;
                //            }
                //            catch
                //            {
                //                log.log("track en lecture avant le merge doit etre suprimmé");
                //            }

                //            if (!_break)
                //            {
                //                log.log("retour à l'index " + currentIndex);
                //                var tr = playlist._pl.Tracks.ItemByPlayOrder[currentIndex];
                //                if (tr != null)
                //                {
                //                    tr.Play();
                //                }
                //            }


                //        }
                //    }
                //    catch (Exception ex)
                //    {
                //        log.log(ex.ToString());
                //    }

                //}

            }
        }


        public void mergeListWithOrder(ICollection<IFile> newElements_, IAbortTask writer, IBgTask task)
        {
            new mergeListWithOrderTask(this, newElements_, writer, task).launch();
        }


        //public void mergeList(ICollection<IFile> newElements_, bool withOrder, IAbortTask writer, IBgTask task)
        //{
        //    withOrder = !verifyDoublon;
        //    if (withOrder)
        //        mergeListWithOrder(newElements_, writer, task);
        //    else
        //        mergeList(newElements_, writer);
        //}



        public bool mergeList(ICollection<IFile> newElements_, HashSet<string> ignore, IAbortTask writer, bool writeOnlyEnabled, bool writeOnlyUnRead)
        {

            if (writer.Aborted || _abort) return true;
            verifyDoublon = true;

            // log.log("mergeList"); 

            string currentAlbum = "----";



            lock (this)
            {


                try
                {
                    if (loader.CurrentPlaylist == this)
                    {
                        if (loader.PlayerState == ITPlayerState.ITPlayerStatePlaying)
                        {
                            var currentPlaying = loader.CurrentTrack;
                            if (currentPlaying != null)
                                currentAlbum = currentPlaying.Album;
                        }
                    }
                }
                catch (Exception ex)
                {
                    log.log("impossible de déterminer la liste courant", ex);
                }
            }

            //    log.log("mergeList::begin"); 

            List<TrackInList> toDeleteRead = new List<TrackInList>();
            List<TrackInList> toDeleteEnabled = new List<TrackInList>();
            List<TrackInList> toDeleteRejet = new List<TrackInList>();
            List<IFile> newElements = null;
            BgDictString<IFile> newElt =null;
            if (newElements_ != null)
            {
                newElements = new List<IFile>(newElements_);
                newElt = new BgDictString<IFile>(); 
                foreach (IFile elt in newElements_)
                {
                    newElt[elt.Location] = elt;
                }
            }
            //   log.log("mergeList::fin hashtable"); 
            foreach (TrackInList pl in this)
            {
                if (pl.Played && writeOnlyUnRead && !ignore.Contains(pl.Location))
                    toDeleteRead.Add(pl);
                else if (!pl.Enabled && writeOnlyEnabled && !ignore.Contains(pl.Location))
                    toDeleteEnabled.Add(pl);
                else if (newElt != null && newElt[pl.Location] == null && !ignore.Contains(pl.Location))
                {
                    //if ((!conf.AutoPlay || loader.CurrentPlaylist != this) || (conf.DeleteCurrentAlbum || pl.Piece.Album != currentAlbum))
                    toDeleteRejet.Add(pl);
                    //pl.FirstClass = true; 
                }
            }
            // log.log("mergeList::fin determination toDelete"); 
            //foreach (TrackInList pl in this)
            //{
            //    IFile elt = newElements.Find(t => t.Location == pl.Location);
            //    if (elt == null)
            //        toDelete.Add(pl);
            //}


            //Addition
            List<IFile> toAdd = new List<IFile>();
            if (newElements != null)
            {
                foreach (IFile elt in newElements)
                {
                    if (writer.Aborted || _abort) return true;
                    string location = elt.Location;
                    //   bool founded = false;

#if V
             PieceInAList found = dict[location]; 
#else
                    PieceInAList found = loader.getTrackInList(path, location);
#endif

                    if (found == null && ! ignore.Contains(elt.Location))
                        toAdd.Add(elt);
                    //foreach (PieceInAList pl in this)
                    //{
                    //    if (pl.Location == location)
                    //    {
                    //        founded = true;
                    //        break;
                    //    }
                    //}

                    //if (!founded)
                    //    toAdd.Add(elt);
                }
            }
            //  log.log("mergeList::fin determination toAdd");

            var toDelete = new List<TrackInList>();
            toDelete.AddRange(toDeleteRead);
            toDelete.AddRange(toDeleteEnabled);
            toDelete.AddRange(toDeleteRejet);

            if (toAdd.Count > 0 || toDelete.Count > 0)
                log.log("{0} add:{1}\tdelete:{2}\t:read={3}\tdisabled={4}\trejet={5}", this, toAdd.Count, toDelete.Count, toDeleteRead.Count, toDeleteEnabled.Count, toDeleteRejet.Count);

            //if (toAdd.Count > 0)
            //    log.log("{0} {1} elt to add", this, toAdd.Count);

            //if (toDelete.Count > 0)
            //    log.log("{0} {1} elt to delete", this, toDelete.Count);




            int count = toAdd.Count;
            for (int i = 0; i < count; i++)

            //foreach (IFile track in toAdd)
            {
                if (writer.Aborted || _abort) return true;
                var e = toAdd[i];
               
                Add(e.Location, string.Format("{0}{1}/{2}", e, i + 1, toAdd.Count), true);

            }

            foreach (TrackInList pl in toDelete)
            {
                if (writer.Aborted || _abort) return true;
                pl.Delete();
            }



            //  log.log("mergeList::fin determination toAdd");
            return true;



        }


        private class AddTrack : BgTaskBase
        {
            private string location;
            //   private string desc;
            private Loader loader;
            private PlayList playlist;
            public AddTrack(string location, string desc, Loader loader, PlayList playlist)
                : base(desc)
            {
                //    this.desc = playlist.path + " "+ location + " " + desc;
                this.loader = loader;
                this.location = location;
                this.playlist = playlist;
            }
            public override void exec()
            {

                if (_abort) return;
                if (playlist.verifyDoublon)
                {

                    if (playlist.Contains(location))
                    {
                        playlist.log.log("vérif 1 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }
                    chrono.bip("v1");

                    if (playlist.LogicalContainsTrackInList(location))
                    {
                        playlist.log.log("vérif 2 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }
                    chrono.bip("v2");


#if V
           //  PieceInAList found = dict[location]; 
#else

                    var found = loader.getTrackInList(playlist.path, location);
#endif

                    if (found != null)
                    {
                        playlist.log.log("vérif 3 {0} track déjà ajouté", Desc);
                        success = true;
                        return;
                    }

                    chrono.bip("v3");

                    var memo = loader.getMemoTrackList(playlist.path, playlist._pl, location);
                    chrono.bip("vm");
                    if (memo != null)
                    {
                        int TrackDatabaseID = -1;
                        string _test = null;
                        try
                        {
                            _test = memo.Track.Location;
                            TrackDatabaseID = memo.Track.TrackDatabaseID;
                        }

                        catch
                        {
                        }
                        if (location == _test)
                        {
                            playlist.log.log("{0} vérif persist :  track déjà ajouté", Desc);
                            success = true;
                            return;
                        }
                        else
                        {
                            loader.removeTrackInList(playlist.path, location, TrackDatabaseID, playlist._pl);
                        }
                        chrono.bip("vm2");
                    }

                }


                IITFileOrCDTrack newTrack = null;
                var sourceTrack = loader.getAnyTrackByLocation(location);

                chrono.bip("fts");

                if (sourceTrack != null)
                {
                    try
                    {

                        if (_abort) return;
                        var st = sourceTrack.Track;
                        if (st is TrackWrapper)
                        {
                            st = (st as TrackWrapper).InnerTrack;
                        }
                        playlist.enter();
                        newTrack = TrackWrapper.create(playlist._pl.AddTrack(st));
                    }
                    catch (Exception ex)
                    {
                        playlist.log.log("{0} Erreur ajout par track {1}", Desc, ex.ToString());
                        loader.invalidationLocation(location);
                    }

                    finally
                    {
                        playlist.release();
                        chrono.bip("Add");

                    }
                }

                if (newTrack == null)
                {
                    try
                    {
                        success = false;
                        if (!conf.PlayListAddFile)
                            return;


                        if (_abort) return;
                        IITOperationStatus status = null;
                        try
                        {
                            playlist.enter();
                            status = playlist._pl.AddFile(location);
                        }

                        finally
                        {
                            playlist.release();
                        }

                        if (status == null)
                        {
                            playlist.log.log("impossible d'ajouter le track par fichier " + location);
                            success = true;
                            return;


                        }
                        while (status.InProgress)
                            Thread.Sleep(30);
                        try { playlist.enter(); newTrack = TrackWrapper.create(status.Tracks[1]); }
                        finally { playlist.release(); } // as IITFileOrCDTrack;
                        playlist.log.log("{0} track ajouté par fichier ", Desc);
                    }
                    catch (Exception ex)
                    {
                        playlist.log.log("{0} Erreur ajout par fichier {1}", Desc, ex.ToString());
                        success = false;
                        return;

                    }

                    finally
                    {
                        chrono.bip("Add2");
                    }


                }


                if (_abort)
                {
                    success = true;
                    return;
                }


                chrono.bip("Add:?");
                var newTrackTrackDatabaseID = newTrack.TrackDatabaseID;
                loader.recordTrackList(playlist.path, newTrack, newTrackTrackDatabaseID, location, true);
                chrono.bip("f1");
                TrackInfoItunes piece = loader.getInfo(newTrackTrackDatabaseID);
               // piece.FirstClass = true;
                chrono.bip("f2");
                TrackInList plPiece = new TrackInList(playlist, piece, newTrackTrackDatabaseID);
                chrono.bip("f3");
                loader.LogicalRecordTrackInList(playlist.path, plPiece);


                // new TrackInfoItunes(newTrack);
                //TrackInList t = new TrackInList(  (this, ti, newTrack.TrackDatabaseID);
                plPiece.setTrack(newTrack);
                //if (verifyDoublon)
                playlist.add(plPiece);
                //  playlist.addPiece(piece);

                success = true;

            }



        }
        private bool? isClass;
        private int priority = int.MaxValue;
        public void setPrior(int p) { priority = 0; }
        public int Prior { get { return priority; } }
        // public bool? IsClass { set { isClass = value; } } 
        public override bool isClassSubList()
        {
            if (isClass != null)
                return isClass.Value;

            isClass = base.isClassSubList();
            return isClass.Value;
        }

        public IBgTask Add(string location, string desc, bool async)
        {
            var task = new AddTrack(location, desc, loader, this);
            if (!async)
            {
                task.exec();
                return task;
            }


            if (BackGroundTaskMgr.Ordonnancement)
            {
                if (!isClassSubList())
                {
                    if (_addMgr == null)
                    {
                        lock (_lockP)
                        {
                            if (_addMgr == null)
                            {
                                _addMgr = BackGroundTaskMgr.getMgr("AddTrack " + path, 0);
                            }
                        }
                    }

                    BackGroundTaskMgr.increaseScanPriority(_addMgr, priority);
                    _addMgr.add(task);
                    return task;
                }
                else
                {
                    if (_addMgrClassement == null)
                    {
                        lock (_lockP)
                        {
                            if (_addMgrClassement == null)
                            {
                                _addMgrClassement = BackGroundTaskMgr.getMgr("Classement", 0);
                            }
                        }
                    }
                    _addMgrClassement.addAtFirst(task);
                    return task;
                }
            }
            else
            {
                task.exec();
            }

            return task;

        }


        public override bool add(PlComponent component)
        {
            TrackInList found = null;
            if (verifyDoublon)
            {
                found = loader.getTrackInList(path, component.Location);
                if (found != null)
                {
                    log.log("track déjà ajouté {0} {1}", this, component.Location);
                    loadScanTracks(true, component);
                }
            }

            bool ret = base.add(component);
            if (!ret)
                return ret;

            TrackInList info = component as TrackInList;
            if (info != null)
            {

                if (found == null)
                    loader.recordTrackInList(path, info, verifyDoublon);

            }



            if (info == null)
                return false;

            //     nb++;

#if V
            dict.Add(info.Location, info); 
          //  dict[info.Location] = info; 
#else



#endif


            return ret;


        }

        public void reintegrate()
        {
            foreach (PlComponent t in this)
            {
                if (t is TrackInList)
                    loader.recordTrackInList(path, t as TrackInList, verifyDoublon);
                else if (t is PlayList)
                    (t as PlayList).reintegrate();
            }


        }



        public override bool remove(PlComponent child)
        {
            //    TrackInList track = child as TrackInList;
            //    if (track != null)
            //        track.Delete(); 

            return base.remove(child);
        }




#if VERIF
        public void verif()
        {
            foreach (TrackInList info in this)
            {
                info.verif(); 
            }
        }
#endif
        //private void scanWithoutLimit()
        //{
        //    try
        //    {
        //        _scan(task);
        //    }

        //    catch (Exception e)
        //    {
        //        log.log(e.ToString());
        //    }

        //    task = null;

        //}


        private class TaskScan : BgTaskBase
        {
            private static BgDictString<TaskScan> dict = new BgDictString<TaskScan>();
            private static BgDictString<int> logs = new BgDictString<int>();
            private static volatile object _lock = new object();

            public readonly PlComponent source;
            public static TaskScan create(PlayList playlist, PlComponent source)
            {
                string key = playlist.path;
                if (dict.ContainsKey(key))
                    return null;
                TaskScan task = null;
                lock (_lock)
                {
                    if (dict.ContainsKey(key))
                        return null;
                    task = new TaskScan(playlist, source);
                    dict.Add(key, task);
                    logs[key]++;

                }

                playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                playlist.log.log("creation tâche scan:{0}", key);
                playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                return task;
            }

            public static int logScan(TaskScan task)
            {
                return logs[task.playlist.path];
            }

            private static void remove(TaskScan task)
            {
                dict.Remove(task.playlist.path);
            }


            private TaskScan(PlayList playlist, PlComponent source)
                : base(playlist.path)
            {
                this.playlist = playlist;
                this.source = source;
            }
            private PlayList playlist;
            public override void exec()
            {
                try
                {
                    //if (dict.ContainsKey(playlist.path))
                    //    return;
                    //lock (_lock)
                    //{
                    //    if (dict.ContainsKey(playlist.path))
                    //        return;
                    //    dict.Add(playlist.path, this); 
                    //}
                    playlist._scan(this);

                }
                catch (Exception e)
                {
                    playlist.log.log(e.ToString());

                }

                finally
                {
                    success = true;
                    playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    playlist.log.log("remove tâche scan:{0}", playlist);
                    playlist.log.logNoDate(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                    lock (_lock)
                        dict.Remove(playlist.path);
                }

            }

        }

        public override string ToString()
        {
            return base.ToString() + " " + verifyDoublon;
        }







    }


}
]]></content>
  </file>
  <file path="db4\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using pdb.util.RelativePath;
//using pdb.it.Albums;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        protected static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        //protected static IAlbumMgr albumMgr;
        //public static IAlbumMgr AlbumMgr { set { albumMgr = value; } get { return albumMgr; } }
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        // private TrackPlayListManager listManager = new TrackPlayListManager();
        //  private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        //private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        //private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        // private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        //private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        protected static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);
        protected static BackGroundTaskMgr bgImport = BackGroundTaskMgr.getMgr("Import", 0);
        protected static BackGroundTaskMgr bgHibernate = BackGroundTaskMgr.getMgr("Hibernate", 0);
        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }

        //public virtual void setAlbum(string album)
        //{
        //    albumMgr.setAlbum(this, album);
        //}

        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            this.album = track.Album;

            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.file = RelativeFileRegister.Get(track.Location);
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;

            fillDesc(track);




        }

        //private void FIll(IITURLTrack track)
        //{
        //    this.id = track.TrackDatabaseID;

        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    // this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    // this._isPodCast = track.Podcast;
        //    // this.playedDate = track.PlayedDate;
        //    //  this.location = track.Location;
        //    //this.grouping = track.Grouping;
        //    this.playCount = track.PlayedCount;
        //    this.location = track.URL;
        //    if (string.IsNullOrEmpty(description))
        //        description = track.Description;
        //    if (string.IsNullOrEmpty(longDescription))
        //        longDescription = track.LongDescription;
        //}

        public virtual bool Played { get { return this.playCount > 0; } }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present;
        public bool Present
        {
            get { return present; }
            set { present = value; }
        }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location":
                    Uri uri = new Uri(value);
                    return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.PlayedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded;


            Fill();
        }

        //public void build(IITURLTrack track)
        //{
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;
        //    this.added = track.DateAdded;
        //    FIll(track);
        //}



        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0;
            string key = "";
            bool nextIgnore = false;
            _isPodCast = false;


            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID":
                    id = Convert.ToInt32(value);
                    break;
                    case "Name":
                    name = value;
                    break;
                    case "Artist": artist = value; break;
                    case "Album": album = value; break; // albumMgr.setAlbum(this, value); break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": PlayedDate = Convert.ToDateTime(value); break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;// Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location":
                    Uri uri = new Uri(value);
                    var location = uri.LocalPath.Replace(@"\\localhost\", "");
                    file = RelativeFileRegister.Get(location);
                    break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind":
                    if (value.Equals("Flux audio sur Internet") || value.Equals("Flux audio MPEG"))
                        strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment":
                    if (!loaded)
                        volume = Convert.ToInt32(value);

                    break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                fillDesc(tracktrack);
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        private string description;
        private string longDescription;

        public string Description { get { return description; } protected set { description = value; } }
        public string LongDescription { get { return longDescription; } protected set { longDescription = value; } }


        public void fillDesc(IITFileOrCDTrack track)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(description))
                description = track.Description;
            if (string.IsNullOrEmpty(longDescription))
                longDescription = track.LongDescription;
        }
        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return TrackTrack;

                fillDesc(track);
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        private static BackGroundTaskMgr bgArtist = BackGroundTaskMgr.getMgr("Artist", 0);
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;
                if (string.IsNullOrEmpty(file.file))
                    artist = value;
                else
                {
                    bgArtist.add(new Bgtask(() =>
                    {
                        Track.Artist = value;
                        artist = value;
                    }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                    ));
                }


            }
        }
        //protected IAlbum _album;
        //public IAlbum TrackAlbum { get { return _album; } set { _album = value; } }
        private static BackGroundTaskMgr bgAlbum = BackGroundTaskMgr.getMgr("Album", 0);
        public virtual string AlbumKey { get { return Album.toKey(); } }
        protected string album;
        public virtual string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value == null || value.Equals(album)) return;
                if (string.IsNullOrEmpty(file.file))
                    album = value;
                else
                {
                    bgAlbum.add(new Bgtask(() =>
                    {
                        // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                        Track.Album = value;
                        // albumMgr.setAlbum(this, value);
                    }, this,
                    "change album from '{0}' to'{1}' {2}", Album, value, this
                    ));
                }

            }
        }
        protected string name = "";
        private static BackGroundTaskMgr bgName = BackGroundTaskMgr.getMgr("Name", 0);
        public virtual string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;
                if (string.IsNullOrEmpty(file.file))
                    name = value;
                else
                {

                    int lengh = 0;
                    if (name != null)
                        lengh = name.Length;

                    if (value.Length < lengh)
                    {
                        log.log("Attention On raccourcit le nom !!! {0}->{1} {2}", name, value, this);
                        // return; 
                    }




                    var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                    bgName.add(bgtaskName);
                }

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }

        protected string composer = "";
        private static BackGroundTaskMgr bgComposer = BackGroundTaskMgr.getMgr("Composer", 0);
        public virtual string Composer
        {
            get
            {
                if (present && string.IsNullOrEmpty(composer))
                {
                    var t = Track;
                    if (t != null)
                        composer = t.Composer;
                }
                return composer;
            }
            set
            {
                if (!present)
                {
                    composer = value;
                    return;
                }

                if (value == null || value.Equals(composer)) return;

                var t = Track;
                if (t != null)
                    composer = t.Composer;
                if (value.Equals(composer))
                    return;


                var bgtaskComposer = new BgTaskComposer(this, string.Format("change composer from '{0}' to '{1}' {2}", composer, value, this), value);
                bgComposer.add(bgtaskComposer);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }


        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        //private bool firstClass;
        //public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        protected static BackGroundTaskMgr bgComment = BackGroundTaskMgr.getMgr("Comment", 0);
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                // firstClass = false;
                if (comment != value)
                {
                    //try
                    //{
                    //    var tab0 = comment.Split(' ');
                    //    var tab1 = value.Split(' ');

                    //    var count0 = tab0.GetLength(0);
                    //    var count1 = tab1.GetLength(0);

                    //    if (count0 != count1)
                    //        firstClass = true;

                    //    else if (comment.Length > 3)
                    //    {
                    //        string org = tab0[count0 - 1];
                    //        string fin = tab1[count1 - 1];

                    //        firstClass = !org.Equals(fin);
                    //    }
                    //}

                    //catch
                    //{
                    //    firstClass = true;
                    //}

                    //var sb = new StringBuilder();
                    //sb.Append(ClassName);
                    //sb.Append(".");
                    //sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format(" change comment from '{0}' to '{1}' {2}", comment, value, this), value);

                    //if (firstClass)
                    //    bgFirstClass.add(task);
                    //else
                    bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled = true;
        public virtual bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        protected bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        private DateTime playedDate;
        public DateTime PlayedDate
        {
            get
            {
                return playedDate;
            }

            set
            {
                if (playedDate > DateTime.MinValue)
                {
                    var dt = (value - playedDate).TotalHours;
                    if (dt > 2 || dt < -2)
                        playedDate = value;
                    else
                        return;

                }
                playedDate = value;
            }
        }
        //protected string location;
        //public string Location
        //{
        //    get { return location; }
        //    set { location = value; }
        //}

        protected RelativeFile file;
        public string Location { get { if (file == null) return ""; return file.file; } }
        public RelativeFile File { get { return file; } set { file = value; } }

        protected string url;
        public string Url
        {
            get { return url; }
            set
            {
                if (string.IsNullOrEmpty(url))
                    url = value;
            }

        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }

            set
            {
                if (!present)
                {
                    grouping = value;
                    return;
                }
                if (grouping != value)
                {
                    var task = new BgTaskGrouping(this, string.Format("change grouping from '{0}' to'{1}' {2}", grouping, value, this), value);
                    bgg.add(task);
                }
            }


        }

        //public void setGrouping(string value, bool prior)
        //{
        //    if (!present)
        //    {
        //        grouping = value;
        //        return;
        //    }
        //    if (grouping != value)
        //    {
        //        bool _delta = false;
        //        // bool _deltaRank = false; 
        //        string rankAlbum = "";
        //        string equivAlbum = "";
        //        if (value != null)
        //        {
        //            string[] org = grouping.Split(' ');
        //            string[] _new = value.Split(' ');

        //            int count = org.GetLength(0);
        //            if (_new.GetLength(0) != count || count < 3)
        //                _delta = true;
        //            else
        //            {
        //                rankAlbum = _new[1];
        //                equivAlbum = _new[2];
        //                if (!org[1].Equals(_new[1]))
        //                {
        //                    _delta = true;
        //                }
        //            }
        //        }

        //        var sb = new StringBuilder();
        //        sb.Append(rankAlbum);
        //        sb.Append(" ");
        //        sb.Append(equivAlbum);
        //        sb.Append(" ");
        //        sb.Append(Album);
        //        //sb.Append(ClassName);
        //        //sb.Append(".");
        //        //sb.Append((Rating / 20).ToString());

        //        var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

        //        if (firstClass)
        //        {
        //            bgSeconClass.add(task);
        //            return;
        //        }

        //        //if (prior)
        //        //{
        //        //    bgGroupPrior.add(task);
        //        //    return;
        //        //}



        //        if (_delta)
        //        {
        //            if (prior)
        //                bgGroupPrior.add(task);
        //            else
        //                bgGroup2nd.add(task);
        //            return;
        //        }

        //        bgg.add(task);

        //        //if (_delta)
        //        //    bgGroupDelta.add(task);
        //        //else
        //        //{
        //        //    bgg.add(task);
        //        //}
        //        //  grouping = value;
        //    }
        //}



        private int volume;
        private static BackGroundTaskMgr bgVolume = BackGroundTaskMgr.getMgr("Volume", 0);
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgVolume.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return file.file;
        }



        //public List<CPlayList> PLayLists
        //{
        //    get { return listManager.PLayLists; }
        //}

        //public List<CPlayList> ClassPlayLists
        //{
        //    get { return listManager.ClassPlayLists; }
        //}

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    listManager.AddPlayList(a_playList);
        //    // className = listManager.ClassName;
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    listManager.removePlayList(list);
        //    // className = listManager.ClassName;
        //}


        //public string ClassName
        //{
        //    get
        //    {
        //        className = listManager.ClassName;
        //        return className;
        //    }
        //    set
        //    {
        //        className = listManager.ClassName;
        //        if (className != value)
        //        {
        //            bgClass.add(new Bgtask(() =>
        //            {
        //                loader.setClassPlayList(this, className, value);
        //                className = value;
        //            }, this,
        //           "change className from '{0}' to'{1}' {2}", className, value, this));


        //            //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
        //            //className = value;
        //            //OnClassNameChange(value);
        //        }
        //    }
        //}
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }
        private static BackGroundTaskMgr bgDelete = BackGroundTaskMgr.getMgr("Delete", 10);
        public void Delete()
        {
            if (tracktrack != null)
            {
                log.log("!delete! {0}", this);
                tracktrack.Delete();
            }
            else
                bgDelete.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        protected class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComposer : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComposer(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Composer = value;
                    info.composer = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getPath()
        {
            return file.getPath();
        }

        private DateTime added;
        public virtual DateTime Added
        {
            get { return added; }
            set { added = value; }
        }



        public string strClassement
        {
            get { throw new NotImplementedException(); }
        }

        public Classement DeepClassement
        {
            get { throw new NotImplementedException(); }
        }


        public Classement MaxClassement
        {
            get { throw new NotImplementedException(); }
        }

        public Classement Classement
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        public IMasterPiece MasterPiece
        {
            get
            {
                throw new NotImplementedException();
            }
        }
    }
}



]]></content>
  </file>
  <file path="db4\PieceDb.obj\Interfaces.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;

namespace pdb.obj
{

    public enum exportState
    {
        none = 0,
        miss = 1,
        present = 2,
        copy = 3,
        delete = 4
    }

    /// <summary>
    /// définit chemin d'un fichier
    /// </summary>
    public interface IFile
    {
        String Location { get; }
        string getPath();
        int PieceId { get; }
    }

    public interface IPiece
    {
        bool Virtual { get;  }
        int PieceId { get; }
        string Album { get; }
    }

    /// <summary>
    /// carte d'identité d'un morceau
    /// </summary>
    public interface ITrackReference
    {
        String Artist { get; set; }
        String Album { get; set; }
        String Name { get; set; }
        int TrackNumber { get; set; }
    }

    // définition non ambigue d'un morceau
    public interface ITrackIdentity : IFile, ITrackReference
    {

        int PieceParentId { get; set; }
        TrackIdentity Key { get; }
    }


    /// <summary>
    /// infos de base du morceau :métafonnées de la piste
    /// </summary> 
    public interface ITrackMetaData : ITrackIdentity
    {

        int Rating { get; set; }
        int Year { get; set; }
        //   String Comment { get; set; }
        bool Enabled { get; set; }
        bool isPodcast { get; }
        DateTime PlayedDate { get; }
        DateTime Added { get; }
        TimeSpan Duration { get; set; }
        bool Played { get; }
        //  string ArtWork { get; set; }
        //   string Grouping { get; }
        //  void setGrouping(string value,bool prior);
        // bool FirstClass { get; set; }
#if VOL
        int Volume { get; set; }
#endif
    }

    /// <summary>
    /// Supplément d'infos fournies par Db. liste de dates
    /// </summary>
    //public interface ITrackPlayedDates
    //{
    //    List<DateTime> Dates { get; }
    //    List<DateTime> DatesClassement { get; }
    //    List<DateTime> DatesClassementBrut { get; }
    //    String ClassEvol { get; }
    //}

    /// <summary>
    /// infos max récupérées de iTunes: 
    /// Métadonnées + listes
    /// 
    /// </summary>
    //public interface ITrackNative : ITrackMetaData, ITrackPlayListReport
    //{       
    //    Classement Classement { get; }
    //    Classement DeepClassement { get; }       
    //    Classement MaxClassement { get; }

    //  //  void registerDependency(ITrackNative local);
    // //   void releaseDependency();
    //}

    /// <summary>
    /// infos de base + liste de dates
    /// Infos que Db met à dispo
    /// </summary>
    //public interface ITrackNativeDates : ITrackNative, ITrackPlayedDates
    //{
    //    void setClassement(string className, int rating);
    //    void setClassement(string classement);
    //    List<string> RelativesPath { get; }
    //    exportState ExportStatus { get; set;}

    //}

    /// <summary>
    /// Enregistrement des playlists associées au morceau
    /// </summary>
    //public interface ITrackPlayListRecorder
    //{
    //    void AddPlayList(CPlayList a_playList);
    //    void removePlayList(CPlayList list);
    //}

    /// <summary>
    /// récupération des infos PlayList du morceau
    /// </summary>
    //public interface ITrackPlayListReport
    //{
    //   // List<CPlayList> PLayLists { get; }
    //    List<CPlayList> ClassPlayLists { get; }
    //}

    /// <summary>
    /// abstraction de trackInfoItunes
    /// </summary>
    //public interface ITrackInfoItunes : ITrackNative, ITrackPlayListRecorder
    //{


    //}

    public interface ITrackInfoItunes : ITrackMetaData
    {
        IMasterPiece MasterPiece { get; }
    }

    //public class NullTrack : ITrackNative
    //{

    //    #region ITrackNative Members

    //    public string ClassName
    //    {
    //        get
    //        {
    //            return "";
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public void registerDependency(ITrackNative local) { }
    //    public void releaseDependency() { }

    //    #endregion

    //    #region ITrackMetaData Members

    //    public int Rating
    //    {
    //        get
    //        {
    //            return -1;
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public int Year
    //    {
    //        get
    //        {
    //            return -1;
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public string Comment
    //    {
    //        get
    //        {
    //            return "";
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public bool Enabled
    //    {
    //        get
    //        {
    //            return false;
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public bool isPodcast
    //    {
    //        get { return false; }
    //    }

    //    public DateTime PlayedDate
    //    {
    //        get { return DateTime.MinValue; }
    //    }

    //    public TimeSpan Duration
    //    {
    //        get { return new TimeSpan(); }
    //        set { }
    //    }

    //    public string ArtWork
    //    {
    //        get
    //        {
    //            return "";
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public string Grouping
    //    {
    //        get
    //        {
    //            return "";
    //        }

    //    }

    //    //  public void setGrouping(string value, bool prior) { }


    //    public int Volume { get { return 0; } set { } }

    //    #endregion

    //    #region IFile Members

    //    public string Location
    //    {
    //        get { return ""; }
    //    }

    //    public string getLocation()
    //    {
    //        return "";
    //    }

    //    #endregion

    //    #region ITrackReference Members

    //    public string Artist
    //    {
    //        get
    //        {
    //            return "";
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public string Album
    //    {
    //        get
    //        {
    //            return "";
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public string Name
    //    {
    //        get
    //        {
    //            return "";
    //        }
    //        set
    //        {

    //        }
    //    }

    //    public int TrackNumber
    //    {
    //        get
    //        {
    //            return -1;
    //        }
    //        set
    //        {

    //        }
    //    }

    //    #endregion

    //    #region ITrackPlayListReport Members

    //    public List<CPlayList> PLayLists
    //    {
    //        get { return new List<CPlayList>(); }
    //    }

    //    public List<CPlayList> ClassPlayLists
    //    {
    //        get { return new List<CPlayList>(); }
    //    }

    //    #endregion

    //    public bool FirstClass { get { return false; } set { } }

    //    public int PieceId
    //    {
    //        get { return -1; }
    //    }

    //    public int PieceParentId
    //    {
    //        get { return -1; }
    //        set { }
    //    }



    //    public TrackIdentity Key
    //    {
    //        get { return new TrackIdentity(this); }
    //    }


    //    public DateTime Added
    //    {
    //        get { return DateTime.MinValue; }
    //    }


    //    public bool Played
    //    {
    //        get { return false; }
    //    }


    //    public string strClassement
    //    {
    //        get { return ""; }
    //    }

    //    public Classement Classement
    //    {
    //        get { return Classement.NULL; }
    //    }


    //    public Classement DeepClassement
    //    {
    //        get { return Classement.NULL; }
    //    }


    //    public Classement MaxClassement
    //    {
    //        get { return Classement.create("0.0"); }
    //    }
    //}





}


]]></content>
  </file>
  <file path="db4\PieceDb.obj\Metadata.cs">
    <content><![CDATA[using System;
using pdb.obj;

namespace pdb.obj
{
    /// <summary>
    /// Simple conteneur de métadonnées
    /// </summary>
    public class Metadata : ITrackMetaData
    {
        public Metadata()
        {
        }

        public Metadata(string location)
        {
            this.location = location;
        }
        #region ITrackMetaData
        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }
        private int year = -1;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                year = value;
            }
        }

        public string Comment
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public bool isPodcast
        {
            get { return true; }
        }

        public DateTime PlayedDate
        {
            get { return DateTime.MinValue; }
        }

        private TimeSpan duration;
        public TimeSpan Duration
        {
            get
            {
                return duration;
            }
            set
            {
                duration = value;
            }
        }

        public string ArtWork
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Grouping
        {
            get { return ""; }
        }

        //public void setGrouping(string value, bool prior)
        //{

        //}

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public int PieceParentId
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public TrackIdentity Key
        {
            get { return null; }
        }
        private string location;
        public string Location
        {
            get { return location; }
        }

        public int PieceId
        {
            get { return -1; }
        }
        private string artist;
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                artist = value;
            }
        }
        private string album;
        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                album = value;
            }
        }
        private string name;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }
        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                trackNumber = value;
            }
        }
        #endregion


        public string getPath()
        {
            return location; 
        }


        public DateTime Added
        {
            get { return DateTime.MinValue;  }
        }


        public bool Played
        {
            get { throw new NotImplementedException(); }
        }
    }
}
]]></content>
  </file>
</db>
