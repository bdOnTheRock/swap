<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\App.xaml">
    <content><![CDATA[<Application x:Class="pdb.player.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:util="clr-namespace:pdb.player.Vue.Util"
             StartupUri="Player.xaml">
    <Application.Resources>
        <util:StringFormatConverter x:Key="StringFormater" />
        <util:TimeFormatConverter x:Key="TimeSpan" />
        <util:IntFormatConverter x:Key="Int" />
        <util:DecimalFormatConverter x:Key="decimal" />
        <util:DecimalFormatEConverter x:Key="decimalE" />
        <util:ClFormatConverter x:Key="cl" />
       
        <util:BgColorFormatConverter x:Key="colorExport" />
        <util:BgColorFormatConverter0 x:Key="colorExport0" />
        <util:BgColorFormatConverter00 x:Key="colorExport00" />
        <util:ForeColorFormatConverter x:Key="foreColor" />
        <util:ColorDispoConverter x:Key="dispo" />
        <util:BoolToVis x:Key="boolVis" />
        <util:SortModeConverter x:Key="sortAlbum" />
        <util:DateConverter  x:Key="date" />
        <util:DateToDelaiConverter x:Key="delai" />
        <util:SelectedMotifConverter x:Key="motif" />
        <util:FontConverter x:Key="fontWeight" />
    </Application.Resources>
</Application>
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\AllTracksViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.player.ViewModel.Commande.Link;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.Commande;
using pdb.util;
using System.Globalization;
using pdb.gen.auto;

namespace pdb.player.ViewModel
{
    public enum listDisplay
    {
        all,
        onlyDisabled,
        onlyEnabled
    }

    public class AllTracksViewModel : List<TrackListViewModel>, INotifyCollectionChanged, INotifyPropertyChanged
    {
        public event NotifyCollectionChangedEventHandler CollectionChanged;
        public event PropertyChangedEventHandler PropertyChanged;
        //   private List<TrackListViewModel> tracks;
        private Dictionary<int, TrackListViewModel> dict;
        private object _lock = new object();
        private PlayListViewModel parent;
        private DispatcherOperation ope;



        private bool? onlyDisabled;
        private bool onlyFathers;
        public AllTracksViewModel(PlayListViewModel parent, bool? onlyDisabled, bool onlyFathers)
        {
            this.parent = parent;
            this.onlyDisabled = onlyDisabled;
            this.onlyFathers = onlyFathers;
            //   this.mode = mode; 
            build();
            PlayerViewModel.Instance.resumeChange += playerResumeChange;
            PlayerViewModel.autoChange += new EventHandler(PlayerViewModel_autoChange);
            //TrackListViewModel.CurrentHumanSelectedChanged += PlayerViewModel_autoChange; 
        }

        void PlayerViewModel_autoChange(object sender, EventArgs e)
        {
            OnPropertyChanged("AutoResume");
        }


        void playerResumeChange(object sender, EventArgs e)
        {
            OnPropertyChanged("TV");
            OnPropertyChanged("Resume");
            OnPropertyChanged("AutoResume");
        }

        public string Resume
        {
            get
            {
                return PlayerViewModel.Instance.Resume;
            }
            set
            {

            }
        }

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (CollectionChanged == null)
            //    {
            //    }
            //    else
            //    {
            //        CollectionChanged(this, e); 
            //    }
            //    return; 
            //}

            //dispatcher.Invoke(DispatcherPriority.DataBind, new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e);



            var eventHandler = CollectionChanged;
            if (eventHandler != null)
            {
                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (NotifyCollectionChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        // Invoke handler in the target dispatcher's thread
                        {
                            ope =
                               dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                            handler, this, e);
                            ope.Completed += ope_Completed;


                        }
                        else // Execute handler as is
                            handler(this, e);
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
            else
            {
            }

            // PlayerViewModel.Instance.makeResume();

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("AllTracksViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
            PlayerViewModel.Instance.makeResume();
        }


        protected virtual void OnPropertyChanged(string propertyName)
        {
            var eventHandler = PropertyChanged;
            if (eventHandler == null)
            {
                //   int toto = 0;
            }
            else
            {
                //var dispatcher = Dispatcher.CurrentDispatcher;
                //if (dispatcher.CheckAccess())
                //    PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
                //else
                //    dispatcher.Invoke(new Action<string>(OnPropertyChanged), propertyName);

                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (PropertyChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                          handler, this, new PropertyChangedEventArgs(propertyName));
                        else // Execute handler as is
                            handler(this, new PropertyChangedEventArgs(propertyName));
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
        }

        public void refresh()
        {
            build();
            foreach (TrackListViewModel track in this)
                track.refresh();

        }

        //public void init()
        //{
        //    refresh();
        //    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        //}

        public TrackListViewModel TV { get { return TrackListViewModel.HumanSelected; } }

        public void build()
        {
            lock (_lock)
            {
                var list = new List<TrackListViewModel>();
                var dict = new Dictionary<int, TrackListViewModel>();
                buildAllTraks(list, dict, onlyDisabled, onlyFathers);
                if (this.dict == null)
                {
                    this.dict = new Dictionary<int, TrackListViewModel>();
                    foreach (TrackListViewModel track in list)
                    {
                        Add(track);
                        this.dict.Add(track.PieceId, track);
                        // track.PropertyChanged += track_PropertyChanged;
                    }

                    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
                }
                else
                {

                    foreach (TrackListViewModel newTrack in list)
                    {
                        if (!this.dict.ContainsKey(newTrack.PieceId))
                        {
                            Add(newTrack);
                            this.dict.Add(newTrack.PieceId, newTrack);
                            // newTrack.PropertyChanged += track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, newTrack));
                        }
                    }

                    foreach (TrackListViewModel track in new List<TrackListViewModel>(this))
                    {
                        if (!dict.ContainsKey(track.PieceId))
                        {
                            Remove(track);
                            this.dict.Remove(track.PieceId);
                            // track.PropertyChanged -= track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, track));
                        }
                    }
                }
            }

            //Clear(); 
            //foreach (TrackListViewModel track in parent.Tracks)
            //    Add(track); 
        }

        //void track_PropertyChanged(object sender, PropertyChangedEventArgs e)
        //{
        //    switch (e.PropertyName)
        //    {
        //        case "Duration":
        //        case "Enabled":
        //            PlayerViewModel.Instance.makeResume();
        //            break;
        //    }
        //}

        public List<TrackListViewModel> AllTracks
        {
            get
            {
                build();
                return this;
            }
        }

        public List<TrackListViewModel> Tracks
        {
            get
            {
                return parent.Tracks;
            }
        }

        protected void buildAllTraks(List<TrackListViewModel> container, Dictionary<int, TrackListViewModel> dict, bool? onlyDisabled, bool onlyFathers)
        {
            foreach (TrackListViewModel t in parent.Tracks)
            {
                if (!t.Enabled || true != onlyDisabled)
                {
                    if (onlyDisabled == null && t.Enabled)
                    {
                        if (!t.PieceGen.ClassementProvisoireRecent)
                            continue;
                    }
                    if (t.PieceParentId < 0 || !onlyFathers)
                    {
                        if (!t.Track.Virtual || PlayerViewModel.Instance.WithVirtualAlbum)
                        {

                            if (!dict.ContainsKey(t.PieceId))
                            {
                                dict.Add(t.PieceId, t);
                                container.Add(t);
                                //  t.Index = container.Count; 
                            }
                        }
                    }
                }

            }

            foreach (PlayListViewModel pl in parent)
            {
                AllTracksViewModel other = pl.AlltracksVm;
                //if (true == onlyDisabled)
                //    other = pl.AlltracksVmd;
                //else
                //    other = pl.AlltracksVm;
                other.buildAllTraks(container, dict, onlyDisabled, onlyFathers);
            }
        }

        #region cmd

        private ICommand _contextCmdCheck;
        public ICommand ContextCmdCheck { get { if (_contextCmdCheck == null) _contextCmdCheck = new CheckCmd(); return _contextCmdCheck; } }

        private ICommand _contextCmdUnCheck;
        public ICommand ContextCmdUnCheck { get { if (_contextCmdUnCheck == null) _contextCmdUnCheck = new UnCheckCmd(); return _contextCmdUnCheck; } }


        private ICommand _contextLinkFather;
        public ICommand LinkFather { get { if (_contextLinkFather == null) _contextLinkFather = new LinkFather(); return _contextLinkFather; } }

        private ICommand _contextLinkChild;
        public ICommand LinkChild { get { if (_contextLinkChild == null) _contextLinkChild = new LinkChild(); return _contextLinkChild; } }

        private ICommand _contextLinkFusion;
        public ICommand LinkFusion { get { if (_contextLinkFusion == null) _contextLinkFusion = new LinkFusion(); return _contextLinkFusion; } }

        private ICommand _contextUnLink;
        public ICommand LinkReset { get { if (_contextUnLink == null) _contextUnLink = new LinkReset(); return _contextUnLink; } }

        private ICommand _contextExport;
        public ICommand Export { get { if (_contextExport == null) _contextExport = new ExportCmd(); return _contextExport; } }

        private ICommand _contextExportCompress;
        public ICommand ExportCompress { get { if (_contextExportCompress == null) _contextExportCompress = new ExportCompress(); return _contextExportCompress; } }

        private ICommand _contextDelete;
        public ICommand DeleteTrack { get { if (_contextDelete == null) _contextDelete = new DeleteCmd(); return _contextDelete; } }

        private ICommand _contexExplorer;
        public ICommand Explorer { get { if (_contexExplorer == null) _contexExplorer = new Explorer(); return _contexExplorer; } }



        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(App.Instance); return _ContextCmdAddToList; } }

        private ICommand _ContextCmdDbDeleteClassement;
        public ICommand ContextCmdDbDeleteClassement { get { if (_ContextCmdDbDeleteClassement == null) _ContextCmdDbDeleteClassement = new DbDeleteLastClassement(); return _ContextCmdDbDeleteClassement; } }

        private ICommand _ContextCmdDbDeleteRead;
        public ICommand ContextCmdDbDeleteRead { get { if (_ContextCmdDbDeleteRead == null) _ContextCmdDbDeleteRead = new DbDeleteLastRead(); return _ContextCmdDbDeleteRead; } }


        #endregion

        public TrackListViewModel HumanSelected
        {
            get
            {
                return TrackListViewModel.HumanSelected;
            }
        }

        #region from Ihm
        private TrackListViewModel selectedTrack;
        public TrackListViewModel SelectedTrack
        {
            get
            {
                return selectedTrack;
            }
            set
            {
                selectedTrack = value;
                TrackListViewModel.setHumanSelected(parent, value); //  .HumanSelected = value;
                if (selectedTrack != null)
                    selectedTrack.IsSelected = true;
            }
        }
        #endregion

        private int nbAlbumMoved;

        public int NbAlbumMoved
        {
            get { return nbAlbumMoved; }
        }

        private int nbEmpeached;
        public int NbEmpeached { get { return nbEmpeached; } }

        private void writeConf(StringBuilder sb, ConfMedianneVirt conf)
        {
            sb.Append((conf.coeffVirt - 1).FormatE(4)); sb.Append("\t "); //(3,3,9));                  

            sb.Append((conf.v).FormatE(4)); sb.Append("\t ");  //sb.Append("m  ");

            sb.Append(conf.a.FormatE(4)); sb.Append("\t ");
            sb.Append(conf.CurrentStaticm.FormatE(3)); sb.Append("\t ");


            sb.Append(conf.Serial); sb.Append(" ");
            //  sb.Append(conf.SerialBox); sb.Append(" ");
            // sb.Append(conf.Alt); sb.Append(" ");
            sb.Append(conf.AltHisto); sb.Append("  ");
            sb.Append(conf.Elastique.ToString("0.##")); sb.Append(" ");
            sb.Append(conf.Elastique2.ToString("0.##"));
        }

        private void check(StringBuilder sb, StringBuilder sb2)
        {
            sb.Append(" ");
            sb2.Append(" ");

            while (sb.Length < sb2.Length)
                sb.Append(" ");
            while (sb2.Length < sb.Length)
                sb2.Append(" "); 

        }

        private void writeConf(StringBuilder sb, ConfMedianneVirt conf, StringBuilder sb2, ConfMedianneVirt conf2)
        {
            sb.Append((conf.coeffVirt - 1).FormatE(4));
            sb2.Append((conf2.coeffVirt - 1).FormatE(4));

            check(sb, sb2); 

            sb.Append((conf.v).FormatE(4));
            sb2.Append((conf2.v).FormatE(4));
            check(sb, sb2); 

            sb.Append(conf.a.FormatE(4));
            sb2.Append(conf2.a.FormatE(4));
            check(sb, sb2); 

            sb.Append(conf.CurrentStaticm.FormatE(3));
            sb2.Append(conf2.CurrentStaticm.FormatE(3));
            check(sb, sb2);

            sb.Append(conf.Serial);
            sb2.Append(conf2.Serial);
            check(sb, sb2);
            //  sb.Append(conf.SerialBox); sb.Append(" ");
            // sb.Append(conf.Alt); sb.Append(" ");
            sb.Append(conf.AltHisto); 
            sb2.Append(conf2.AltHisto);
            check(sb, sb2);


            sb.Append(conf.Elastique.ToString("0.##"));
            sb2.Append(conf2.Elastique.ToString("0.##"));

            check(sb, sb2); 
            sb.Append(conf.Elastique2.ToString("0.##"));
            sb2.Append(conf2.Elastique2.ToString("0.##"));
        }

        public string AutoResume
        {
            get
            {

                try
                {
                    var confM = App.gen.SortAlbumMode.ComposantsUtiles[0];
                    var conf = confM.Main;
                    var min = confM.Min;
                    var sb = new StringBuilder();
                 

                   
                    //if (min.Use)
                    //{
                    //    var sb2 = new StringBuilder();
                    //    writeConf(sb, conf, sb2, min);
                    //    sb.AppendLine();
                    //    sb.Append(sb2.ToString()); 
                    //}

                    //else
                    //    writeConf(sb, conf);


                    writeConf(sb, conf);
                    if (min.Use)
                    {
                        sb.AppendLine();
                        writeConf(sb, min);
                    }


                    return sb.ToString();

                }
                catch
                {
                    return "";
                }
            }
        }
        public string NbAlbumMovedDesc
        {
            get
            {
                if (nbAlbumMoved < 0)
                    return "";
                if (nbAlbumMoved == 0)
                    return "pas d'album en quarantaine";
                return string.Format("{0} albums en quarantaine", nbAlbumMoved);
            }
        }

        public void setNbAlbum(int nbanavailable, int empeches, int moved)
        {
            if (nbanavailable != this.nbAlbumMovedUnavailable)
            {
                this.nbAlbumMovedUnavailable = nbanavailable;
                OnPropertyChanged("NbAlbumMovedUnavailable");
            }

            if (empeches != nbEmpeached)
            {
                nbEmpeached = empeches;
                OnPropertyChanged("NbEmpeached");
            }

            if (moved != nbAlbumMoved)
            {
                nbAlbumMoved = moved;
                OnPropertyChanged("NbAlbumMoved");
            }
        }

        //public void setNbAlbumMoved(int nb)
        //{
        //    if (nb != nbAlbumMoved)
        //    {
        //        nbAlbumMoved = nb;
        //        OnPropertyChanged("NbAlbumMoved");
        //        OnPropertyChanged("NbAlbumMovedDesc");
        //    }

        //}

        private int nbAlbumMovedUnavailable;
        public int NbAlbumMovedUnavailable
        {
            get
            {
                return nbAlbumMovedUnavailable;
            }

            //set
            //{
            //    if (value != nbAlbumMovedUnavailable)
            //    {
            //        nbAlbumMovedUnavailable = value;
            //        OnPropertyChanged("NbAlbumMovedUnavailable");
            //    }
            //}
        }

    }


}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;
using pdb.gen.medianne;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            // piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            //OnPropertyChanged("Comment");
            //OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        private int index2;
        public int Index2
        {
            get { return index2; }
            set
            {
                if (value != index2)
                {
                    index2 = value;
                    OnPropertyChanged("Index2");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public bool Empeached { get { return PieceGen.isEmpeached(); } set { PieceGen.Empeached = value; } }
        public int EmpeachedNb { get { return PieceGen.EmpeachedNb; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        private static bool setHumanSelectedUsed;
        private static volatile object _lock = new object();
        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            lock (_lock)
            {
                if (setHumanSelectedUsed)
                    return;
            }

            try
            {
                lock (_lock)
                    setHumanSelectedUsed = true;
                //if (humanSelected != null)
                //{
                //    humanSelected.refresh();
                //   // var b = humanSelected.Grouping; 
                //}
                if (track != humanSelected)
                {
                    humanSelected = track;


                    //  humanSelected.refresh();
                    // var b = humanSelected.Grouping; 
                    int id = 0;
                    if (track != null) id = track.PieceId;
                    if (id != humanSelectedId)
                    {
                        humanSelectedId = id;
                        if (CurrentHumanSelectedChanged != null)
                            CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                    }
                }
            }
            finally
            {
                lock (_lock)
                    setHumanSelectedUsed = false;
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }








        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }

        public string ClassementCompact
        {
            get { return PieceGen.ClassementCompact; }
        }

        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {

                // piece.StrClassement = value;
                //if (value != piece.Piece.StrClassement)
                //{

                lock (Albums.LockSort)
                {
                    piece.Classement = value;
                    PieceGen.invalidateCache();
                    App.gen.Albums.signalClassChange(track);
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    App.go(true);
                    // onPropertyChanged("Classement");


                    // }

                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }

        public DateTime Added { get { return piece.Added; } }

        public DateTime FirstAcces
        {
            get
            {
                return piece.FirstAcces;
            }
        }



        public DateTime AlbumAdded
        {
            get
            {
                return piece.AlbumAdded;
            }
        }

        public int RankAlbum { get { return PieceGen.RankAlbum; } }
        public int RankAlbumZero { get { return PieceGen.RankAlbumZero; } }
        public int RankAlbumReverse { get { return PieceGen.RankAlbumReverse; } }
        public int RankAllAlbum { get { return PieceGen.RankAllAlbum; } }
        public int RankAlbumSt { get { return PieceGen.RankAlbumSt; } }
        public int RankAlbumZeroSt { get { return PieceGen.RankAlbumZeroSt; } }


        public int Rank { get { return PieceGen.Rank.Twice; } }
        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        //public string Comment
        //{
        //    get
        //    {
        //        if (PieceGen.Virtual)
        //            return "";
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        if (PieceGen.Virtual)
        //            return;
        //        //piece.Comment = value; 
        //        if (value != piece.Comment)
        //        {
        //            //  track.Comment = value;
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get { return track.Piece.Grouping; }
        //    set
        //    {
        //        //  piece.Grouping = value;
        //        if (value != track.Piece.Grouping)
        //        {
        //            track.Piece.setGrouping(value, true);
        //            // track.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    if (track.Piece.VirtualByArtist)
                        return string.Format("[{0}]", track.Album);
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.Piece.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        //public void setGrouping(string value, bool prior)
        //{
        //    track.Piece.setGrouping(value, prior);
        //    piece.Grouping = value; // TODO je fait quoi de ça ???
        //    // onPropertyChanged("Grouping");
        //}

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel -1; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2-1; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();

            piece.Piece.Parent = parent.Piece.Master;
            track.Piece.Parent = parent.track.Piece;

            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }

        public string EquivLight
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight;
            }
        }

        public string EquivLight0
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight0;
            }
        }

        public string EquivLightSt
        {
            get
            {

                if (album == null)
                    return "";
                return album.EquivLightSt;
            }
        }

        public decimal ClassementValueLightSt
        {
            get
            {
                if (album == null)
                    return 0;
                return album.ClassementValueLightSt;
            }
        }

        public int AlbumCount
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Count;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="3" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="album"
                       x:Name="dg" x:Uid="album"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="false" 
                                        
                       SelectedItem="{Binding SelectedTrackInAlbumView}">



            <!--<DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>-->

            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <!--<DataGridCheckBoxColumn Header=""  Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                <DataGridTextColumn Header="" Binding="{Binding Index,Mode=OneWay}" />
                <DataGridTextColumn Header="p" Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="" Binding="{Binding MedianneStatus,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Virtuel" Binding="{Binding ClassementVirtuel,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Virtuel2" Binding="{Binding ClassementVirtuel2,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2,Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>
                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>


                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />

                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}" />
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
            </DataGrid.Columns>


            <DataGrid.ItemContainerStyle>

                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="BorderThickness" Value="0" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exis
                    ts}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},ConverterParameter=album,   UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />
                   
                    
                    
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />




                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected"  Value="True">-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Foreground"  Value="White" />-->
                    <!--<Setter Property="BorderThickness" Value="1" />-->
                    <!--</Trigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <!--<Setter Property="Height"  Value="20" />-->
                  
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Padding" Value="10,10,10,10" />
                </Style>
            </DataGrid.RowStyle>

            <DataGrid.ContextMenu>
                <ContextMenu>

                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
        </l:EnhancedDataGrid>
        <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True"  />
        <Grid Grid.Row="2"  Visibility="{Binding HasArtWork, Converter={StaticResource boolVis}}">
            <Image Source="{Binding ArtWork}" ></Image>
            <!--<ListView ItemsSource="{Binding Images}">
                <ListView.ItemTemplate>
                    <DataTemplate>
                        <StackPanel>
                            <Image Source="{Binding}"  />
                        </StackPanel>
                    </DataTemplate>
                </ListView.ItemTemplate>
                <ListView.ItemsPanel>
                    <ItemsPanelTemplate>
                        <StackPanel Orientation="Horizontal" HorizontalAlignment="Stretch" VerticalAlignment="Stretch"></StackPanel>
                    </ItemsPanelTemplate>
                </ListView.ItemsPanel>

            </ListView>-->

            <Image Source="{Binding ArtWork}" ></Image>
           
        </Grid>
        <Grid Grid.Row="3">

            <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="albums"
                       x:Name="dgalbums" x:Uid="albums"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="False" 
                                
                                HeadersVisibility="All" 
                                
                                 >
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album,Mode=OneWay}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="RankRev" Binding="{Binding RankAlbumReverse,Mode=OneWay}" />
                    <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                    <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                    <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                    <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                    <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>


                </DataGrid.Columns>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <!--<Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />-->
                        <Setter Property="FontWeight" Value="Normal" />                        
                    </Style>
                </DataGrid.ItemContainerStyle>
                
                <DataGrid.CellStyle>
                    <Style TargetType="DataGridCell">
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=albums, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="BorderBrush" Value="Transparent" />
                    </Style>
                </DataGrid.CellStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">                        
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                    </Style>
                </DataGrid.RowStyle>


            </l:EnhancedDataGrid>
            <ComboBox Name="cbx_mode" HorizontalAlignment="Right"  Width="20" Height="25" VerticalAlignment="Top" SelectionChanged="cbx_mode_SelectionChanged" >
                <ComboBoxItem  ToolTip="album du morceau sélectionné" >identique</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre" >origine</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre si virtuel" >origine si virtuel</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus long entre le maitre et le virtuel" >le plus long</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus court entre le maitre et le virtuel" >le plus court</ComboBoxItem>
            </ComboBox>



        </Grid>

       
    </Grid>
</UserControl>  
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="main" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt" Binding="{Binding RankAlbumSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt0" Binding="{Binding RankAlbumZeroSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLight0"  Binding="{Binding EquivLight0, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLightSt"  Binding="{Binding EquivLightSt, Mode=OneWay}" />
                <DataGridCheckBoxColumn Header="Empêché" Binding="{Binding Empeached, UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ClassementValueLightSt"  Binding="{Binding ClassementValueLightSt, Mode=OneWay}" />

                <DataGridTextColumn Header="is" Binding="{Binding Index2,Mode=OneWay}"/>
                <DataGridTextColumn Header="EmpêchéHisto"  Binding="{Binding EmpeachedNb, Mode=OneWay}" />

                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>





            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <ContentControl Name="Cctl" Grid.Row="1" >
            <DockPanel Grid.Row="1" Name="dp_status" >
                <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMovedUnavailable,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbEmpeached,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" HorizontalAlignment="Left" Text="{Binding AutoResume,UpdateSourceTrigger=PropertyChanged}" FontWeight="DemiBold" FontSize="11" Margin="0,0,10,0"/>



                <TextBlock DockPanel.Dock="Bottom" FontSize="11" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
            </DockPanel>
        </ContentControl>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Util\StringFormatConverter.cs">
    <content><![CDATA[using System;
using System.Windows;
using System.Windows.Data;
using System.Windows.Media;
using pdb.gen;
using pdb.gen.medianne;
using pdb.obj;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Colors;
using pdb.util;

namespace pdb.player.Vue.Util
{
    [ValueConversion(typeof(object), typeof(string))]
    public class StringFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            string format = parameter as string;
            if (!string.IsNullOrEmpty(format))
            {
                return string.Format(culture, format, value);
            }
            else
            {
                return value.ToString();
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TimeSpan), typeof(string))]
    public class TimeFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is TimeSpan)
            {
                TimeSpan ts = (TimeSpan)value;
                return String.Format("{0}:{1}{2}", ts.Minutes, ts.Seconds >= 10 ? "" : "0", ts.Seconds);
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(decimal), typeof(string))]
    public class DecimalFormatEConverter : BaseConverter, IValueConverter
    {
        object IValueConverter.Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            return ((decimal)value).FormatE(4);
        }

        object IValueConverter.ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    [ValueConversion(typeof(string), typeof(string))]
    public class ClFormatConverter : BaseConverter, IValueConverter
    {
        static int NB_DEC = 4;
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            var str = value.ToString();
            int count = str.Length;
            return Piece.getReadableCl(str);
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            bool second = false;
            //if (str.StartsWith("0"))
            second = true;
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {

                        if (i > NB_DEC || (i >= NB_DEC && second))
                        {
                            if (!second)
                            {
                                second = true;
                                i = 1;
                            }
                            else
                                i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();


        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (value == null) return "";
            return value.ToString().Replace(" ", "");
        }
    }


    [ValueConversion(typeof(int), typeof(string))]
    public class IntFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                int ivalue = (int)value;
                if (ivalue <= 0) return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            int result;
            if (int.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }


    [ValueConversion(typeof(decimal), typeof(string))]
    public class DecimalFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is decimal)
            {
                decimal dvalue = (decimal)value;
                if (dvalue <= 0) return "";
                return dvalue.ToString("0.###");

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            decimal result;
            if (decimal.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }

    [ValueConversion(typeof(DateTime), typeof(string))]
    public class DateToDelaiConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            if (value is DateTime)
            {
                DateTime dvalue = (DateTime)value;
                int delta = (int)((DateTime.Now.Date - dvalue.Date).TotalDays);
                return delta.ToString();

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            decimal result;
            if (decimal.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter0 : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = BgColorFormatConverter.getConf(parameter);

                return BgColorFormatConverter.getColor0(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter00 : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = BgColorFormatConverter.getConf(parameter);

                return BgColorFormatConverter.getcolor00(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }



    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter : BaseConverter, IValueConverter
    {
        public static SolidColorBrush getcolor00(TrackListViewModel tv, TrackColor couleurs)
        {
            if (tv.PieceGen.IsNext)
            {
                if (tv.Exists)
                {
                    if (tv.PieceGen.AlmostFree) return couleurs.AlmostFree.Brush;
                    if (tv.PieceGen.AlmostFree1) return couleurs.AlmostFree1.Brush;

                    if (tv.PieceGen.Empeached1) return couleurs.Empeached1.Brush;

                    if (tv.PieceGen.Empeached) return couleurs.Empeached.Brush;
                    if (tv.PieceGen.EmpeachedM) return couleurs.EmpeachedM.Brush;

                    if (tv.PieceGen.Moved) return couleurs.Moved.Brush;
                    if (tv.PieceGen.MovedM) return couleurs.MovedM.Brush;

                    if (tv.PieceGen.AlbumRecentlyUpdated) return couleurs.Recent.Brush;
                    if (tv.PieceGen.AlbumRecentlyUpdatedMain) return couleurs.RecentM.Brush;

                    switch (tv.SelectedMotif)
                    {
                        case selectedCoeff.none:
                        case selectedCoeff.noCoeff: return couleurs.Next.Brush;
                        case selectedCoeff.main: return couleurs.nextByCoeffMain.Brush;
                        case selectedCoeff.min: return couleurs.nextByCoeffMin.Brush;
                    }

                }
                return couleurs.NextAbsent.Brush;
            }
            return Brushes.Transparent;
        }

        public static SolidColorBrush getColor0(TrackListViewModel tv, TrackColor couleurs)
        {

            var c = getcolor00(tv, couleurs);
            if (c != Brushes.Transparent)
                return c;

            if (tv.IsSelected) return couleurs.Selected.Brush;


            if (tv.PieceGen.AlmostFree) return couleurs.AlmostFree.Brush;
            if (tv.PieceGen.AlmostFree1) return couleurs.AlmostFree1.Brush;

            if (tv.PieceGen.Empeached1) return couleurs.Empeached1.Brush;

            if (tv.PieceGen.Empeached) return couleurs.Empeached.Brush;
            if (tv.PieceGen.EmpeachedM) return couleurs.EmpeachedM.Brush;

            if (tv.PieceGen.Moved) return couleurs.Moved.Brush;
            if (tv.PieceGen.MovedM) return couleurs.MovedM.Brush;

            if (tv.PieceGen.AlbumRecentlyUpdated) return couleurs.Recent.Brush;
            if (tv.PieceGen.AlbumRecentlyUpdatedMain) return couleurs.RecentM.Brush;

            exportState es = tv.ExportStatus;
            if (!tv.Exists)
                es = exportState.miss;
            var exp = couleurs.export;
            switch (es)
            {
                case exportState.none: return exp.none.Brush; // Brushes.White;
                case exportState.miss: return exp.miss.Brush;                //return Brushes.LightGray;
                case exportState.present: return exp.present.Brush; // return Brushes.White;
                case exportState.copy: return exp.copy.Brush; //return Brushes.LightGreen;
                case exportState.delete: return exp.delete.Brush; //return Brushes.DarkGray;
                default:
                    break;
            }

            return Brushes.Transparent;
        }

        public static SolidColorBrush getColor(TrackListViewModel tv, TrackColor couleurs)
        {
            if (tv.IsSelected) return couleurs.Selected.Brush;

            return getColor0(tv, couleurs);
        }

        public static TrackColor getConf(object parameter)
        {
            var conf = Couleurs.Instance.general.track;
            if (parameter != null)
            {
                string path = parameter.ToString();
                var _c = Couleurs.get(path);

                TrackColor _conf = null;

                if (_c is TrackColor)
                    _conf = _c as TrackColor;
                else
                {
                    if (_c is General)
                    {
                        _conf = (_c as General).track;
                    }
                }


                if (_conf != null)
                    conf = _conf;
            }

            return conf;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                var conf = getConf(parameter);

                return getColor(tv, conf);

            }
            catch
            {

            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class ForeColorFormatConverter : BaseConverter, IValueConverter
    {
        public SolidColorBrush getColor(TrackListViewModel tv, object parameter)
        {
            //if (tv.PieceGen.IsNext && tv.IsSelected)
            //{
            //    var conf = BgColorFormatConverter.getConf(parameter);
            //    return BgColorFormatConverter.getColor0(tv, conf);
            //}
            if (tv.IsSelected) return Brushes.White;
            return Brushes.Black;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                return getColor(tv, parameter);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(FontWeights))]
    public class FontConverter : BaseConverter, IValueConverter
    {

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                if (tv.IsSelected && tv.PieceGen.IsNext)
                    return FontWeights.Bold;
                return FontWeights.Normal;

            }
            catch
            {

            }
            return FontWeights.Normal;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(ihmInDispo), typeof(Brush))]
    public class ColorDispoConverter : BaseConverter, IValueConverter
    {
        private SolidColorBrush getColor(ihmInDispo info)
        {

            switch (info)
            {
                case ihmInDispo.none: return Brushes.Transparent;
                case ihmInDispo.rot: return Brushes.Gainsboro;
                case ihmInDispo.stat: return Brushes.LightSlateGray;
                default:
                    break;
            }
            return Brushes.White;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                ihmInDispo info = (ihmInDispo)value;
                return getColor(info);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(bool), typeof(System.Windows.Visibility))]
    public class BoolToVis : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is bool)
            {
                return (bool)value ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
            }
            return null;

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (System.Windows.Visibility.Visible.Equals(value)) return true;
            if (System.Windows.Visibility.Collapsed.Equals(value)) return false;
            return null;

        }
    }
    [ValueConversion(typeof(medianneMode), typeof(int))]
    public class SortModeConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is medianneMode)
            {
                return (int)value;
            }
            return null;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                return (medianneMode)(int)(value);
            }
            return null;
        }
    }

    [ValueConversion(typeof(DateTime?), typeof(string))]
    public class DateConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return null;

            if (value is DateTime)
            {
                if (DateTime.MinValue.Equals(value) || DateTime.MaxValue.Equals(value))
                    return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {

            return null;
        }
    }


    [ValueConversion(typeof(selectedCoeff), typeof(string))]
    public class SelectedMotifConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return null;

            if (value is selectedCoeff)
            {
                var motif = (selectedCoeff)value;
                switch (motif)
                {
                    case selectedCoeff.none: return "";
                    case selectedCoeff.noCoeff: return "no";
                    default:
                        return motif.ToString();

                }

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {

            return null;
        }
    }







}
]]></content>
  </file>
  <file path="\pdb.util\CustomFormat.cs">
    <content><![CDATA[using System;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

namespace pdb.util
{
    public static class CustomFormat
    {
        const char infini = '\u221E';
        private static CultureInfo cu = new CultureInfo("en-US");
        //4.9E+02
        private static Regex reg = new Regex(@"([0-9\.]+)E\+([0-9]+)");

        const string FORMAT = "0.### ### ### ### ### ### ### ### ### ### ### ### ###";

        public static string FormatE(this decimal value, int precision)
        {
            precision = precision - 1;
            var borne = Convert.ToDecimal(System.Math.Pow(10, precision));
            var sb = new StringBuilder();
            if (value == 0)
                return "0"; 

            if (value > borne || value < 1 / borne)
            {

                sb.Append("0.");
                for (int i = 0; i < precision; i++)
                    sb.Append("#");
                sb.Append("e+0");

            }
            else
            {
                sb.Append("g");
                sb.Append(precision + 1);

            }
            var format = sb.ToString();
            var ret = value.ToString(format, cu);
            return ret;
        }

        public static string Format(this decimal value, int required, int desired, int limit)
        {
            return Format(value, null, required, desired, limit);
        }
        public static string Format(this decimal value, string format, int required, int desired, int limit)
        {
            if (string.IsNullOrEmpty(format))
                format = FORMAT;
            string ret = value.ToString(FORMAT, cu);

            var sb = new StringBuilder();
            var tab = ret.ToCharArray(); int count = tab.GetLength(0);
            sb.Append(tab[0]);
            bool foundPertinent = false, foundDec = false;
            int nb = 0, _nbpertinent = 0;
            for (int i = 1; i < count; i++)
            {
                var c = tab[i];
                sb.Append(c);
                if (c == '.' || c == ',')
                {
                    foundDec = true;
                    continue;
                }
                if (c == ' ')
                    continue;
                nb++;
                if (c != '0')
                {
                    if (!foundPertinent)
                    {
                        foundPertinent = true;
                    }
                    _nbpertinent++;
                }
                else
                {
                    if (foundPertinent)
                        _nbpertinent++;
                }
                if (foundDec)
                {
                    if (nb >= limit)
                        break;
                    if (_nbpertinent >= required && nb >= desired)
                        break;
                }


            }

            ret = sb.ToString().Trim().Replace(" ", ",");
            return ret;
        }

        public static string FormatCustom(this decimal value, int nb)
        {
            return value.FormatCustom(nb, nb, nb);
        }

        public static string FormatCustom(this double value, int nb)
        {
            return value.FormatCustom(nb, nb, nb);
        }



        public static string FormatCustom(this double value, int nb, int nbMax)
        {
            return value.FormatCustom(nb, nb, nbMax);
        }

        public static string FormatCustom(this decimal value, int nb, int nbMax)
        {
            return value.FormatCustom(nb, nb, nbMax);
        }
        public static string FormatCustom(this double value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(double.MinValue))
                return "-" + infini;
            if (value.Equals(double.MaxValue))
                return infini.ToString();

            if (nbMin < nb)
            {
                if (Math.Abs(value) < Math.PowD(10, nbMin - 1))
                {
                    return FormatCustom(value, nbMin, nbMin, nbMax);
                }
            }

            string ret = value.ToString("G" + nb, cu);
            if (ret.StartsWith("0."))
            {
                ret = ret.Remove(0, 1);
                return ret;
            }

            Match m = reg.Match(ret);
            if (m.Success)
            {
                string strNumber = m.Groups[1].Value;
                string strExp = m.Groups[2].Value;
                if (strExp.StartsWith("0"))
                    strExp = strExp.Remove(0, 1);
                int exp = Convert.ToInt16(strExp);
                var sb = new StringBuilder();
                if (exp <= 3)
                {
                    if (exp < nbMax)
                    {
                        ret = value.ToString("#");
                        return ret;
                    }
                    double dNumber = Convert.ToDouble(strNumber, cu);

                    if (strNumber.Contains("."))
                    {
                        dNumber *= 10;
                        exp--;
                    }

                    int iNumber = Convert.ToInt16(dNumber);
                    sb.Append(iNumber);

                    for (int i = 0; i < exp; i++)
                    {
                        sb.Append("0");
                    }

                    ret = sb.ToString();
                    return ret;

                }

                sb.Append(strNumber);
                sb.Append("e");
                sb.Append(strExp);

                ret = sb.ToString();
                return ret;
            }


            return ret;
        }

        public static string FormatCustom(this decimal value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(double.MinValue))
                return "-" + infini;
            if (value.Equals(double.MaxValue))
                return infini.ToString();

            if (value > int.MaxValue - 20)
                return infini.ToString();
            if (value < -int.MaxValue + 20)
                return "-" + infini;

            return FormatCustom(Convert.ToDouble(value), nb, nbMin, nbMax);

        }

        public static string FormatCustom(this TimeSpan value, int nb)
        {
            return value.FormatCustom(nb, nb, nb);

        }

        public static string FormatCustom(this TimeSpan value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(TimeSpan.MinValue)) return "-" + infini;
            if (value.Equals(TimeSpan.MaxValue)) return infini.ToString();
            return value.TotalDays.FormatCustom(nb, nbMin, nbMax);
        }

        public static string FormatCustomTs(this double value, int nb)
        {
            return value.FormatCustomTs(nb, nb, nb);
        }
        public static string FormatCustomTs(this decimal value, int nb)
        {
            return value.FormatCustomTs(nb, nb, nb);
        }

        public static string FormatCustomTs(this double value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(double.MinValue) || double.IsNegativeInfinity(value))
                return "-" + infini;
            if (value.Equals(double.MaxValue) || double.IsInfinity(value) || double.IsNaN(value))
                return infini.ToString();
            if (value > int.MaxValue - 20)
                return infini.ToString();
            if (value < -int.MaxValue + 20)
                return "-" + infini;
            TimeSpan ts = TimeSpan.FromMilliseconds(value);
            return ts.TotalDays.FormatCustom(nb, nbMin, nbMax);
        }

        public static string FormatCustomTs(this decimal value, int nb, int nbMin, int nbMax)
        {
            if (value.Equals(decimal.MinValue))
                return "-" + infini;
            if (value.Equals(decimal.MaxValue)) // || double.IsInfinity(value) || double.IsNaN(value))
                return infini.ToString();

            if (value > int.MaxValue - 20)
                return infini.ToString();
            if (value < -int.MaxValue + 20)
                return "-" + infini;

            TimeSpan ts = TimeSpan.FromMilliseconds(Convert.ToDouble(value));
            return ts.TotalDays.FormatCustom(nb, nbMin, nbMax);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\DecimalIndex.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util
{
    public class DecimalIndex
    {
        public decimal d;
        public int index;
        public int indexBorder;
        public int indexBorderEffect;
        public int indexBorderMin; 

        public override bool Equals(object obj)
        {
            if (obj is DecimalIndex)
            {
                var o = (DecimalIndex)obj;
                return o.d.Equals(d); 
            }
            else
                return false; 

        }

        public override int GetHashCode()
        {
            return d.GetHashCode() + index.GetHashCode() + indexBorder.GetHashCode() + indexBorderEffect.GetHashCode() + indexBorderMin.GetHashCode(); 
        }

        public static bool operator == (DecimalIndex x, DecimalIndex y)
        {
            if (object.ReferenceEquals(x, null))
                return object.ReferenceEquals(y, null);
            if (object.ReferenceEquals(y, null))
                return object.ReferenceEquals(x, null); 
            return x.d == y.d; 
        }
        public static bool operator !=(DecimalIndex x, DecimalIndex y)
        {
            if (object.ReferenceEquals(x, null))
                return !object.ReferenceEquals(y, null);
            if (object.ReferenceEquals(y, null))
                return !object.ReferenceEquals(x, null); 
            return x.d != y.d;
        }
        public static bool operator >(DecimalIndex x, DecimalIndex y)
        {
            return x.d > y.d;
        }
        public static bool operator >=(DecimalIndex x, DecimalIndex y)
        {
            return x.d >= y.d;
        }
        public static bool operator <(DecimalIndex x, DecimalIndex y)
        {
            return x.d < y.d;
        }
        public static bool operator <=(DecimalIndex x, DecimalIndex y)
        {
            return x.d <= y.d;
        }

        public override string ToString()
        {
            return d.ToString();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\TextWriter.cs">
    <content><![CDATA[using System;
using System.IO;
using System.Text;

namespace pdb.util
{
    /// <summary>
    /// Interface permettant de mettre en commun les opération d'écriture dans un flux texte
    /// </summary>
    public interface ITextWriter
    {
        void Append(object txt);
        void AppendLine(string txt);
        void AppendLine();
        void Flush();
        
    }

    /// <summary>
    /// Wrapper de StringBuilder implémentant ITextWriter
    /// </summary>
    public class StringBuilder : ITextWriter
    {
        private System.Text.StringBuilder sb; 
        public StringBuilder(System.Text.StringBuilder sb)
        {
            this.sb = sb; 
        }

        public StringBuilder()
        {
            this.sb = new System.Text.StringBuilder(); 
        }

        public override string ToString()
        {
            return sb.ToString(); 
        }


        #region ITextWriter Members

        public void Append(object txt)
        {
            sb.Append(txt); 
        }

        public void AppendLine(string txt)
        {
            sb.AppendLine(txt);
        }

        public void AppendLine()
        {
            sb.AppendLine(); 
        }

        #endregion


        public void Flush()
        {
           
        }


        public int Length
        {
            get { return sb.Length; }
        }
    }

    /// <summary>
    /// Wrapper de TextWriter implémentant ITextWriter
    /// </summary>
    public class TextWriter : ITextWriter, IDisposable
    {
        #region ITextWriter Members

        private StreamWriter sw;

        public TextWriter(StreamWriter sw)
        {
            this.sw = sw; 
        }

        public TextWriter(Stream streamBase)
        {
            this.sw = new StreamWriter(streamBase); 
        }

        public TextWriter(Stream streamBase, Encoding encoding)
        {
            this.sw = new StreamWriter(streamBase,encoding);
        }
       
        public void Append(object txt)
        {
            sw.Write(txt);
         //   sw.Flush(); 
        }

        public void AppendLine(string txt)
        {
            sw.WriteLine(txt);
        //    sw.Flush(); 
        }

        public void AppendLine()
        {
            sw.WriteLine();
            sw.Flush(); 
        }

        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            sw.Dispose(); 
        }

        #endregion


        public void Flush()
        {
            sw.Flush(); 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;

namespace pdb.gen.albums
{


    public class Album : IEnumerable<Piece>
    {
        const decimal EPSILON = 0.001m * 0.001m * 0.001m;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }


            return ret; ;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
            }
        }
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero { get { return classementValueLightZero; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return _virtualByArtist; } set { _virtualByArtist = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, VirtualByArtist);
                return key;
            }
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0 { get { return Piece.getClassementEquiv(classementValueLightZero); } }

        // private string moyenne = "";
        public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return stackValue == stackSize; } }
        public bool AlmostFree1 { get { return stackValue == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            piece.PieceAlbum = this;
            if (build)
                return true;

            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                var status = "";
                if (_virtual)
                    status = "v";
                if (_virtualByArtist)
                    status = "va";
                logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                m_rank.init();
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public bool buildDone()
        {

            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && p.RapportClassement == 0)
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }
        public void InvalidateMain()
        {
            if (selectedCoeff == selectedCoeff.main)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
      //  DecimalIndex _med0 = null;
        DecimalIndex med = null; 


        private decimal makeSort(List<PieceExtended> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {

                #region calcul virtuel



                DecimalIndex med = null;
                DecimalIndex med1 = null;
                DecimalIndex med2 = null;

              

                bool? resultGlobalMin = null;

                if (!real || (mode.combine && mode.simple || (mode.Min.coeffVirt ==1 && mode.Min.CoeffOld == 1)))
                {
                    med = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode, mode.Main, true, true);
                    med1 = med; med2 = med;
                }

                else
                {


                    med2 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode, mode.Min, false, false);
                    med1 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode, mode.Main, true, false);

                    //comparaison des médiannes


                    if (med2.d < med1.d && med2.d > 0)
                    {

                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;

                    }
                }




                classementValueLight = med.d;



                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {




                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true));

                    cause = checkCause(list, mode, real, resultGlobalMin, classementValueLight);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight; 

                if (real)
                {
                    if (mode.combine && !mode.simple)
                    {
                        med = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode, mode.Main, true, true);
                        cause = checkCause(list,mode, real, resultGlobalMin, med.d);

                    }

                    if (true == cause.selectedMotifMin)
                        med = med2;
                    else
                        med = med1;



                    this.Next = cause.Next == null? null: cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;

                    foreach (var p in list)
                        p.finalyse();



                    if (cause.motifUp)
                    {
                        if (true == selectedMotifMin)
                            selectedCoeff = selectedCoeff.min;
                        else
                            selectedCoeff = selectedCoeff.main; 
                    }

                    try
                    {
                        list[med.index].Piece.MedianneLight = true;
                        list[med.indexBorder].Piece.Border = true;
                        list[med.indexBorderEffect].Piece.BorderEffect = true;
                        list[med.indexBorderMin].Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public PieceExtended Next = null;
            public bool motifUp;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<PieceExtended> list, ConfMedianne mode, bool real, bool? resultGlobalMin,  decimal classementValueLight)
        {
            var modeMin = mode.cmpMin;
            AutoCause cause = new AutoCause();
        

            PieceExtended nextZero1 = null;
            PieceExtended nextZero2 = null;

            PieceExtended min1 = null;
            PieceExtended min2 = null;
            PieceExtended min = null;
            decimal _min1 = int.MaxValue;
            decimal _min2 = int.MaxValue;
            decimal _minzero1 = int.MaxValue;
            decimal _minzero2 = int.MaxValue;
            bool realZero = false;
            PieceExtended Next = null;
            foreach (PieceExtended p in list)
            {
                var v1 = p.VirtualClassement;
                var v2 = p.VirtualClassement2;

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            _minzero1 = v1;
                            nextZero1 = p;
                            if (v1 == 0)
                                realZero = true;
                        }
                    }

                    if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2 == 0)
                                realZero = true;
                        }

                    }



                    if (v1 > 0 && v1 < _min1)
                    {
                        _min1 = v1;
                        min1 = p;
                    }

                    if (v2 > 0 && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }
                }
            }
            decimal _min = 0;
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;
            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }

            PieceExtended nextZero = null;
            decimal _minzero = int.MaxValue;
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }

            if (nextZero != null)
            {

                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.classementValueLightZero > classementValueLight + EPSILON) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }

                    }
                    else if (_minzero < classementValueLight)
                    {
                        if (real)
                        {
                            Next = nextZero;
                            classementValueLight = _minzero;
                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                        }
                    }

                    else
                    {
                        classementValueLight = _min;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                }

            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            return cause;



        }




        public void makeSort(ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;
            classementValueLightZeroSt = -1;


            try
            {

                selectedCoeff = selectedCoeff.noCoeff;

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return;

                var listE = new List<PieceExtended>(count);
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    p.eraseInfoMedianne();
                    listE.Add(new PieceExtended(p));
                }


                decimal offset = Album.conf.AlbumMoyOffset;



                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                classed = false;
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                }
                //misc.log("make sort Duration {0}", name); 
                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                decimal moy = 0m;

                #region init
                // misc.log("make sort calcul brut init {0}", name); 
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;

                    p.setClassementVirtuel(list[i].RapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;


                this.med = AlbumMedianne.getMedianne(new List<Piece>(list), true, medianne);


             //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                    list[this.med.index].Medianne = true;

                #endregion


                #region calcul virtuel
                //misc.log("make sort calcul virtuel {0}", name); 
                #region init (prise en compte coeff des enabled)
                //var coeffEnabled = conf.coeffEnabled;
                //for (int i = 0; i < count; i++)
                //{
                //    var p = list[i];
                //    var rapportClassement = p.RapportClassement;
                //    if (coeffEnabled != 1m && p.Enabled && (!conf.oldAsZero || !p.LastClassementRecent))
                //    {
                //        rapportClassement *= coeffEnabled;
                //    }
                //    p.setClassementVirtuel(rapportClassement);
                //    p.setClassementVirtuel2(rapportClassement);
                //}
                //list.Sort(new PieceClassementComparer(false));
                #endregion

                classementValueLightZero = makeSort(listE,mode0, false);
                classementValueLight = makeSort(listE, mode, true);

                #endregion

            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

        }



        public void mustRefresh()
        {
            build = false;
            //   sortDone = false;
            // selectionDone = false;
            atLeastOneEnabled = false;
            _tracksSortByClassement = null;

        }



        public decimal getTrackSortValue(int index, List<Piece> list)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }
        //  private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;
            //if (selectionDone)
            //    return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            // selectionDone = true;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            m_rank.init();
            // rankStack = -1;
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public bool isSameOf(Album o)
        {
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && _virtual == o._virtual && _virtualByArtist == o._virtualByArtist;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public DateTime AlbumAdded
        {
            get
            {
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                return min;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, bool artist)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();


                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }

            }
            return __album;

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using pdb.gen.auto;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IList<Piece> list,bool main, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list,main, coeffMedianne), index = index };
        }

        //public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        //{
        //    var _list = new List<decimal>();
        //    foreach (object o in list)
        //    {
        //        _list.Add(Convert.ToDecimal(o));
        //    }
        //    return getMedianne(_list, coeffMedianne);
        //}

        //public static DecimalIndex getMedianne(List<decimal> list, decimal coeffMedianne)
        //{
        //    return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        //}

        //public static DecimalIndex getMedianneLight(List<decimal> list, List<Piece> pieces, ConfMedianne mode, bool signal)
        //{
        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {


        //        var _zero = mode.zero;
        //        var medianne = getMedianne_(list, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;

        //        if (list.Count == 1)
        //            return ret0;

        //        if (mode.safe == 0)
        //        {
        //            return calcmedianneVirt(list, mode, 0, 0);
        //        }

        //        int indexV = 0;
        //        int nbAdd = 0;

        //        int count = list.Count;

        //        if (mode.safe > 0)
        //        {

        //            int i0 = count - 1;
        //            int _nbNoAdd = 0;

        //            for (int i = 0; i < count; i++)
        //            {
        //                if (list[i] <= _zero)
        //                {
        //                    i0 = i;
        //                    _nbNoAdd = count - i0;
        //                    break;
        //                }
        //            }
        //            if (i0 == 0)
        //                return ret0;

        //            //for (int i00 = 1; i00 <= i0; i00++)
        //            //{
        //            //    decimal coeff = (decimal)i00 / (decimal)i0;
        //            List<decimal> _list = new List<decimal>(list);
        //            //for (int i = i00; i < count; i++)
        //            //    _list[i] = 0m;
        //            //liste partielle originale
        //            //  List<decimal> _list0 = new List<decimal>(_list);
        //            int _count = System.Math.Min(count, i0 + mode.safe);
        //            decimal[] virt = new decimal[_count];
        //            _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
        //            if (mode.noAdd)
        //            {

        //                decimal _coeff = 1m;
        //                for (int j = _nbNoAdd - 1; j >= 0; j--)
        //                {
        //                    if (j < count)
        //                    {
        //                        _coeff /= mode.coeffVirt;
        //                        _list[j] = _list[j] * _coeff;
        //                    }
        //                }
        //            }
        //            else if (mode.lissage || mode.removeEpsilon || mode.cumul)
        //            {
        //                for (int i = 0; i < i0; i++)
        //                {
        //                    decimal _coeff = 1m;
        //                    decimal _base = _list[i];
        //                    for (int j = i + 1; j < _count; j++)
        //                    {
        //                        _coeff /= mode.coeffVirt;
        //                        virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
        //                    }
        //                }
        //            }
        //            else
        //            {
        //                decimal courant = _list[0];
        //                for (int i = 1; i < _count; i++)
        //                {
        //                    if (_list[i] <= _zero)
        //                    {
        //                        courant /= mode.coeffVirt;
        //                        virt[i] = courant;
        //                    }
        //                    else
        //                        courant = _list[i];
        //                }
        //            }

        //            decimal value = int.MaxValue;
        //            int ii = 0;
        //            if (mode.noAdd)
        //            {
        //                //for (ii = 1; ii < count && ii < _count; ii++)
        //                //{
        //                //    var calc = virt[ii];
        //                //    if (calc > 0m)
        //                //        list[ii] = calc;
        //                //}
        //            }
        //            else
        //            {
        //                for (ii = 1; ii < count && ii < _count; ii++)
        //                {
        //                    value = _list[ii];
        //                    var calc = virt[ii];
        //                    if (value < calc)
        //                    {
        //                        if (mode.lissage || value <= _zero)
        //                        {
        //                            if (value <= _zero)
        //                                nbAdd++;
        //                            value = calc;
        //                            _list[ii] = value;
        //                        }

        //                    }
        //                    else
        //                        indexV = ii;
        //                }
        //                if (mode.removeEpsilon)
        //                {
        //                    // j'ai 5 virtuel alors que j'ai deux safe
        //                    ///xx---
        //                    int nb = 0;
        //                    for (int i = indexV + 1; i < _count; i++)
        //                    {
        //                        nb++;
        //                        if (nb <= mode.safe)
        //                            continue;
        //                        _list[i] = 0m;
        //                    }

        //                }
        //                if (mode.removeFirst)
        //                {
        //                    for (int i = 0; i < nbAdd; i++)
        //                    {
        //                        _list[i] = 0m;
        //                    }
        //                }
        //            }

        //            for (int i = 0; i < _list.Count && i < pieces.Count; i++)
        //                pieces[i].setClassementVirtuel(_list[i]);

        //            if (mode.deleteFirst)
        //            {
        //                for (int i = 0; i < nbAdd; i++)
        //                {
        //                    _list.RemoveAt(0);
        //                }
        //            }

        //            if (mode.reSort || mode.removeFirst || mode.noAdd)
        //            {
        //                _list.Sort();
        //                _list.Reverse();
        //                pieces.Sort(new PieceCmp());
        //            }



        //            if (mode.noAdd)
        //                nbAdd = _nbNoAdd;

        //            ret = calcmedianneVirt(_list, mode, nbAdd, System.Math.Min(i0, mode.safe));
        //            if (mode.expEnabled != 0)
        //            {
        //                int _nb = pieces.Count<Piece>(p => !p.Enabled);
        //                decimal _c = (decimal)_nb / (decimal)count;
        //                _c = Math.Pow(_c, mode.expEnabled);
        //                ret.d *= _c;
        //            }


        //        }
        //        else
        //            ret = calcmedianneVirt(list, mode, 0, 0);

        //        //if (ret < ret0)
        //        //    ret = ret0; 



        //    }
        //    finally
        //    {
        //        if (signal)
        //        {
        //            try
        //            {
        //                pieces[ret.index].MedianneLight = true;
        //                pieces[ret.indexBorder].Border = true;
        //                pieces[ret.indexBorderEffect].BorderEffect = true;
        //                pieces[ret.indexBorderMin].BorderMin = true;

        //            }
        //            catch { }
        //        }
        //    }

        //    return ret;
        //}

        public static int buildVirtual(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, bool main, bool combine,ref int i0)
        {
            var coeffEnabled = modeVirt.CoeffOld;

            var _coeffVirt = modeVirt.coeffVirt;
            var safe = modeVirt.safe;
            if (combine)
            {
                coeffEnabled = mode.Main.CoeffOld * mode.Min.CoeffOld; 
                _coeffVirt = mode.Main.coeffVirt * mode.Min.coeffVirt;
                safe = (int)Math.Max(mode.Main.safe, mode.Min.safe);
            }

           
         //   var coeff = 1 / coeffEnabled; 
            int count = pieces.Count;
            PieceClassementComparer cmp = new PieceClassementComparer(false);
            pieces.Sort(cmp);
            //if (coeffEnabled != 1)
            //{
            for (int i = 0; i < count; i++)
            {
                var p = pieces[i];
              //  var rapportClassement = p.RapportClassement;
                if (coeffEnabled != 1m && p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
                {
                    p.setCoeff(coeffEnabled, main); 
                    //rapportClassement /= coeffEnabled;
                }

                //p.setClassementVirtuel(rapportClassement);
                //if (!main)
                //    p.setClassementVirtuel2(rapportClassement);
            }

            cmp = new PieceClassementComparer(false, main);
            pieces.Sort(cmp);
            // }

            int indexV = 0;
            int nbAdd = 0;


           // List<Piece> _pieces = pieces;
            var _zero = mode.zero;


            //if (modeVirt.safe > 0)
            //{
            i0 = count - 1;
            int _nbNoAdd = 0;




            if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
            {
                _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
                if (_nbNoAdd > 0)
                    _nbNoAdd--;
            }
            else if (modeVirt.noAddAll)
                _nbNoAdd = pieces.Count;
            else
            {
                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.VirtualClassement == 0m)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }
            }

            if (modeVirt.noAddEnd)
            {
                // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                // morceaux déjà notés
                var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
                _nbNoAdd = _nbNoAdd - nb2;
                if (_nbNoAdd < 0)
                    _nbNoAdd = 0;
            }
            //if (i0 == 0)
            //    return 0;
            //}

            //for (int i00 = 1; i00 <= i0; i00++)
            //{
            //    decimal coeff = (decimal)i00 / (decimal)i0;
            List<decimal> _list = new List<decimal>();
            for (int i = 0; i < pieces.Count; i++)
                _list.Add(pieces[i].getVirtual(main));
            //for (int i = i00; i < count; i++)
            //    _list[i] = 0m;
            //liste partielle originale
            //  List<decimal> _list0 = new List<decimal>(_list);
            int _count = System.Math.Min(count, i0 + safe);
            decimal[] virt = new decimal[_count];
            _nbNoAdd = System.Math.Min(safe, _nbNoAdd);
           
            if (modeVirt.noAdd)
            {
                if (_coeffVirt > 1)
                {
                    // var coeffEnabled = modeVirt.coeffOld; 

                    if (count < safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;
                    decimal prec = 0m;
                    if (modeVirt.virtAlignPrec)
                    {
                        if (_nbNoAdd < _list.Count)
                            prec = _list[_nbNoAdd];
                    }

                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < pieces.Count)
                        {

                            if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
                            {
                                _coeff /= _coeffVirt;
                                var cand = _list[j] * _coeff;
                                if (modeVirt.virtAlignPrec)
                                {
                                    if (cand < prec)
                                        cand = prec + EPSILON;
                                }

                                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                                {
                                    // quel serait le score s'il était coché
                                    var vu = _list[j] / coeffEnabled;
                                    // en plus une petite marge
                                    //  vu *= mode.coeffVirt; 
                                    if (cand < vu)
                                        cand = vu;
                                }
                                _list[j] = cand;
                            }
                            else if (modeVirt.forceCoeffVirt)
                                _coeff /= _coeffVirt;
                            prec = _list[j];
                        }
                    }
                }

            }
            else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
            {
                if (_coeffVirt > 1)
                {
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= _coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
            }
            else
            {
                if (_coeffVirt > 1)
                {
                    decimal courant = _list[0];
                    for (int i = 1; i < _count; i++)
                    {
                        if (_list[i] <= _zero)
                        {
                            courant /= _coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = _list[i];
                    }
                }
            }

            decimal value = int.MaxValue;
            int ii = 0;
            if (modeVirt.noAdd)
            {
                //for (ii = 1; ii < count && ii < _count; ii++)
                //{
                //    var calc = virt[ii];
                //    if (calc > 0m)
                //        list[ii] = calc;
                //}
            }
            else
            {
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = _list[ii];
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (modeVirt.lissage || value <= _zero)
                        {
                            if (value <= _zero)
                                nbAdd++;
                            value = calc;
                            _list[ii] = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (modeVirt.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= safe)
                            continue;
                        _list[i] = 0m;
                    }

                }
                if (mode.removeFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        _list[i] = 0m;
                    }
                }
            }

            for (int i = 0; i < _list.Count && i < pieces.Count; i++)
            {
                pieces[i].setValue(_list[i], main); 
                //if (main)
                //    pieces[i].setClassementVirtuel(_list[i]);
                //else
                //    pieces[i].setClassementVirtuel2(_list[i]);
            }

            if (mode.deleteFirst)
            {
                for (int i = 0; i < nbAdd; i++)
                {
                    pieces.RemoveAt(0);
                }
            }

            if (modeVirt.reSort || mode.removeFirst || modeVirt.noAdd)
            {
                //_list.Sort();
                //_list.Reverse();
                if (main)
                    pieces.Sort(new PieceCmp());
                else
                    pieces.Sort(new PieceCmp2());
            }



            if (modeVirt.noAdd)
                nbAdd = _nbNoAdd;
            //}
            return nbAdd;
        }

        public static DecimalIndex getMedianneLight(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, bool main, bool combine)
        {

            DecimalIndex ret0 = new DecimalIndex();
            DecimalIndex ret = ret0;
            try
            {
                var _zero = mode.zero;
                var medianne = getMedianne_(pieces,main, mode.medianne);
                ret0.d = medianne;
                ret0.index = index;
                ret = ret0;
                //if (pieces.Count == 1)
                //    return ret0;

                int i0 = 0;
                int count = pieces.Count;
                int nbAdd = buildVirtual(pieces, mode, modeVirt, main, combine, ref i0);
                //if (mode.combine && mode.simple)
                //{
                //    int i1 = 0;
                //    buildVirtual(pieces, mode, mode.Min, false, ref i1);
                //    foreach (var p in pieces)
                //    {
                //        p.setClassementVirtuelCombine();
                //    }
                //}
                ret = calcmedianneVirt(pieces, mode, modeVirt, main, nbAdd, System.Math.Min(i0, modeVirt.safe));
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<PieceExtended>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }


              

            }
            finally
            {

               
            }

            return ret;
        }




        private class PieceCmp : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }

        private class PieceCmp2 : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }




        //private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        //{
        //    var _list = new List<decimal>(list);
        //    int count = _list.Count;

        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        if (_list[count - i - 1] > conf.zero)
        //        {

        //            if (conf.removeLast == removeLast.non)
        //                break;
        //            _nbSupp++;
        //            if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                break;
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}



        private static DecimalIndex calcmedianneVirt(IList<PieceExtended> list, ConfMedianne conf, ConfMedianneVirt confc,bool main, int nbAdd, int nbDel)
        {
            var _list = new List<PieceExtended>(list);
            var classes = _list.FindAll(p => p.VirtualClassement > conf.zero);

            if (confc.oldAsZero)
                classes = _list.FindAll(p => p.LastClassementRecent);

            int count = _list.Count;

            int nbEnabled = classes.Count<PieceExtended>(p => p.Enabled);
            int nbDisabled = classes.Count<PieceExtended>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            //int _nbSuppDisabled = 0;
            //int _nbSuppEnabled = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {
                    //var d = _list[count - i];
                    //if (d.Enabled)
                    //    nbEnabled--;
                    //else
                    //    nbDisabled--;

                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, main,conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                ret.indexBorderMin = count - i - 1;
                var p = _list[count - i - 1];

                if (p.VirtualClassement > conf.zero && (!confc.oldAsZero || p.LastClassementRecent))
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--;

                    if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected) && nbEnabled < 0)
                            break;

                        if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break;
                        }

                        _nbSupp++;
                        if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                            break;
                        // }


                    }
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }

      

        private static decimal getMedianne_(IList<PieceExtended> list, bool main, decimal coeffMedianne)
        {
            var l = new List<decimal>();
            foreach (PieceExtended p in list)
            {
                if (main)
                    l.Add(p.VirtualClassement); 
                else
                    l.Add(p.VirtualClassement2); 
            }

            return CalcMedianne.getMedianneDec(l, coeffMedianne); 
        }

        private static decimal getMedianne_(IList<Piece> list, bool main, decimal coeffMedianne)
        {
            var l = new List<decimal>();
            foreach (Piece p in list)
            {
                if (main)
                    l.Add(p.VirtualClassement);
                else
                    l.Add(p.VirtualClassement2);
            }

            return CalcMedianne.getMedianneDec(l, coeffMedianne);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\PieceExtended.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.gen.albums
{
    public class PieceExtended
    {
        private Piece piece;
        private PieceSupInfo main;
        private PieceSupInfo min;


        public PieceExtended(Piece piece)
        {
            this.piece = piece;
            var cl = piece.RapportClassement;
            this.main = new PieceSupInfo(cl);
            this.min = new PieceSupInfo(cl);

        }

        public decimal VirtualClassement { get { return main.Value; } }
        public decimal VirtualClassement2 { get { return min.Value; } }

        public bool getCauseUp(bool? natureCause)
        {
            if (true == natureCause)
                return min.Coeff > 1;
            if (false == natureCause)
                return main.Coeff > 1;
            return min.Coeff > 1 || main.Coeff > 1;
        }

        public decimal CoeffVirtuel { get { return main.Coeff; } }
        public decimal CoeffVirtuel2 { get { return min.Coeff; } }
        public decimal getVirtual(bool main)
        {
            if (main)
                return this.main.Value;
            else
                return this.min.Value;
        }
        public Piece Piece { get { return piece; } }
        public bool Enabled { get { return piece.Enabled; } }

        public bool LastClassementRecent { get { return piece.LastClassementRecent; } }
        public decimal RapportClassement { get { return piece.RapportClassement; } }


        public void setCoeff(decimal coeff, bool main)
        {
            if (main)
                this.main.Coeff = coeff;
            else
                this.min.Coeff = coeff;
        }

        public void setValue(decimal value, bool main)
        {
            if (main)
                this.main.Value = value;
            else
                this.min.Value = value;
        }

        public void finalyse()
        {
            this.piece.setClassementVirtuel(this.main.Value);
            this.piece.setClassementVirtuel2(this.min.Value);
        }

    }

    class PieceSupInfo
    {


        public readonly decimal value0;
        private decimal value;

        public PieceSupInfo(decimal value)
        {
            this.value = value;
            this.value0 = value;
        }

        public decimal Coeff
        {
            get { if (value <= 0) return 1m; return value0 / value; }
            set
            {
                this.value = value0 / value;
            }
        }

        public decimal Value { get { return value; } set { this.value = value; } }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\auto\ConfMedianneVirt.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.util;
using Math = pdb.util.Math;
using StringBuilder = pdb.util.StringBuilder;

namespace pdb.gen.auto
{
    public partial class ConfMedianneVirt : TuningBase
    {
        [NonSerialized]
        const string PATH_DYN = "..\\dynamic";
        private string Path { get { return string.Format("{0}{1}", DIR_CONF, fdata); } }
        private string PathDiff { get { return string.Format("{0}{1}", DIR_CONF, fdiff); } }
        private string PathDiffTmp { get { return string.Format("{0}{1}", DIR_CONF, fdiffTmp); } }
        // private string PathLastFull { get { return string.Format("{0}{1}", DIR_CONF, flast); } }
        const string PATH_DYN_DIFF = "..\\dynamic_diff";


        const int NB_HISTO = 1000000;
        public int safe;
        public decimal coeffVirt = 1m;



        public string name;


        /// <summary>
        /// lié au mode db
        /// </summary>
        public dbMode mode;
        /// <summary>
        /// fichier ou est consigné l'historique courant
        /// </summary>
        public string fdata;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique
        /// </summary>
        public string fdiff;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique en mode full en vue de la sauvegarfe
        /// </summary>
        public string fdiffTmp;
        ///// <summary>
        ///// fichier ou est consigné la dernière sauvegarde full de l'historique
        ///// </summary>
        //public string flast;

        public int indexDiff = 0;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        public bool coeffVirtAuto;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;

        public int serialp = 1;
        public int serialm = 1;
        public int serialAlt = 1;
        public decimal serialElastique = 1m;
        public decimal coeffElastique1 = 1m;
        public decimal coeffElastique2 = 1m;

        public decimal coeffElastique1r = 1m;
        public decimal coeffElastique2r = 1m;

        /// <summary>
        /// pas de calcul
        /// </summary>
        public decimal pas = 0.1m;
        /// <summary>
        /// vitesse : augmentation ou diminution du coeff virtuel
        /// </summary>
        public decimal v;

        /// <summary>
        /// variation de la vitesse en proportion
        /// </summary>
        public decimal vv = 1.1m;

        ///// <summary>
        ///// Vitesse virtuelle : pour calculer l'accélaration en tenant compte des contraintes en simulant un augmentation. Mauvaise idée. toujours egal à v en cas de contrainte
        ///// </summary>
        //private decimal vv;
        /// <summary>
        /// borne visant à limiter le delta entre deux pas
        /// </summary>
        public decimal d0 = 0.01m;
        //  public decimal dcoeffm;


        /// <summary>
        /// accélération : augmentation ou diminution de la vitesse
        /// </summary>
        public decimal a;
        //public decimal a0 =0.01m;
        //public decimal dconvergence01;
        /// <summary>
        /// variation de l'accélération en proportion
        /// </summary>
        public decimal aa = 0.01m;
        /// <summary>
        ///accélaration plancher
        /// </summary>
        public decimal aepsilon = 0.001m;

        /// <summary>
        /// ecart min entre deux positions
        /// </summary>
        private decimal epsilon = 0.001m * 0.001m;
        /// <summary>
        /// ecart de vitesse entre deux positions
        /// </summary>
        private decimal vepsilon = 0.001m * 0.001m;

        private bool? lastDelta;
        private bool? lastAutoDirection;
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        private int _nbSameDirection;
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        private int _nbSameDirectionBox;
        /// <summary>
        /// nb allez/retour pour calcul
        /// </summary>
        private int _nbAlt;
        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique;

        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique2;
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        private int _nbAltHisto;

        /// <summary>
        /// Quand plusieurs montées consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticp = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticm = 1;

        /// <summary>
        /// Après plusieurs montées consécutives : retour au coeff nominal 
        /// </summary>
        private decimal coeffStaticpRetour = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : retour au coeff nominal 
        /// </summary>
        private decimal coeffStaticmRetour = 1;

        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des montées consécutives
        /// </summary>
        private decimal currentStaticp = 1;
        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des descentes consécutives
        /// </summary>
        private decimal currentStaticm = 1;
        public decimal CurrentStaticm { get { return currentStaticm; } }

        /// <summary>
        /// Rapport de vitesse négative / vitesse positive
        /// </summary>
        private decimal rapportmp = 1m;
        /// <summary>
        /// anti atténuation
        /// </summary>
        //public decimal danticonvergence = 1m;
        //public decimal danticonvergence0;
        //public decimal danticonvergence01;

        //public decimal danticonvdeltap = 1m;
        //public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        private List<HistoValue> histo = new List<HistoValue>();
        //  private List<decimal> histoDiff = new List<decimal>();

        private decimal coeffOld = 1m;

        public bool oldAsZero;
        private bool coeffOldAuto;
        public bool coeffOldSwap;
        public int coeffOldAutoLevel;


        public bool Use { get { return coeffVirt > 1 || coeffOld > 1; } }

        public ConfMedianneVirt()
        { }

        public ConfMedianneVirt(ConfMedianneVirt o, bool raz)
            : this(o)
        {
            if (raz)
            {
                // safe = 0;
                coeffOld = 1;
                coeffVirt = 1;
            }
        }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            name = o.name;
            mode = o.mode;
            fdata = o.fdata;
            fdiff = o.fdiff;
            fdiffTmp = o.fdiffTmp;
            //  flast = o.flast;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;

            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            //dcoeffp = o.dcoeffp;
            //dcoeffm = o.dcoeffm;
            //dconvergence = o.dconvergence;
            //dconvdeltap = o.dconvdeltap;
            //dconvdeltam = o.dconvdeltam;
            //danticonvergence = o.danticonvergence;
            //danticonvdeltap = o.danticonvdeltap;
            //danticonvdeltam = o.danticonvdeltam;

            pas = o.pas;
            v = o.v;
            d0 = o.d0;
            a = o.a;
            aa = o.aa;
            aepsilon = o.aepsilon;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            serialAlt = o.serialAlt;
            serialElastique = o.serialElastique;
            coeffElastique1 = o.coeffElastique1;
            coeffElastique2 = o.coeffElastique2;

            coeffElastique1r = o.coeffElastique1r;
            coeffElastique2r = o.coeffElastique2r;


            _nbSameDirection = o._nbSameDirection;
            _nbSameDirectionBox = o._nbSameDirectionBox;
            _nbAlt = o._nbAlt;
            _nbAltHisto = o._nbAltHisto;
            _nbElastique = o._nbElastique;
            _nbElastique2 = o._nbElastique2;

            coeffOld = o.coeffOld;
            coeffOldAuto = o.coeffOldAuto;
            coeffOldSwap = o.coeffOldSwap;
            oldAsZero = o.oldAsZero;
            coeffOldAutoLevel = o.coeffOldAutoLevel;
            epsilon = o.epsilon;

            //dconvergence0 = o.dconvergence0;
            //dconvergence01 = o.dconvergence01;
            //danticonvergence0 = o.danticonvergence0;
            //danticonvergence01 = o.danticonvergence01;

            lastDelta = o.lastDelta;
            histo = new List<HistoValue>(o.histo);

        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var str = "";
            builds("mode", v => str = v);
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);
            builds("name", v => name = v);
            builds("fdata", v => fdata = v);
            builds("fdiff", v => fdiff = v);
            builds("fdiffTmp", v => fdiffTmp = v);
            // builds("flast", v => flast = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);

            builddec("pas", v => pas = v);
            builddec("v", vv => v = vv);
            builddec("dv", v => dv = v);
            builddec("d0", v => d0 = v);
            builddec("a", v => a = v);
            builddec("aa", v => aa = v);
            builddec("vepsilon", v => vepsilon = v);
            builddec("aepsilon", v => aepsilon = v);


            //builddec("dcoeffp", v => dcoeffp = v);
            //builddec("dcoeffm", v => dcoeffm = v);
            //builddec("dconvergence", v => dconvergence = v);
            //builddec("dconvergence0", v => dconvergence0 = v);
            //builddec("dconvergence01", v => dconvergence01 = v);
            //builddec("dconvdeltap", v => dconvdeltap = v);
            //builddec("dconvdeltam", v => dconvdeltam = v);

            //builddec("danticonvergence", v => danticonvergence = v);
            //builddec("danticonvergence0", v => danticonvergence0 = v);
            //builddec("danticonvergence01", v => danticonvergence01 = v);
            //builddec("danticonvdeltap", v => danticonvdeltap = v);
            //builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serialAlt", v => serialAlt = v);
            buildi("elastique", v => serialElastique = v);
            builddec("coeffElastique1", v => coeffElastique1 = v);
            builddec("coeffElastique2", v => coeffElastique2 = v);
            builddec("coeffElastique1r", v => coeffElastique1r = v);
            builddec("coeffElastique2r", v => coeffElastique2r = v);
            buildi("serial", v => _nbSameDirection = v);
            buildi("serialBox", v => _nbSameDirectionBox = v);
            buildi("serialAltC", v => _nbAlt = v);
            buildi("serialAltH", v => _nbAltHisto = v);
            builddec("elastiqueC", v => _nbElastique = v);
            builddec("elastiqueC2", v => _nbElastique2 = v);


            builddec("coeffOld", v => coeffOld = v);
            buildb("oldAsZero", v => oldAsZero = v);
            buildb("coeffOldAuto", v => coeffOldAuto = v);
            buildb("coeffOldSwap", v => coeffOldSwap = v);
            buildi("coeffOldAutoLevel", v => coeffOldAutoLevel = v);
            builddec("epsilon", v => epsilon = v);

            buildbn("lastDelta", v => lastDelta = v);

            builddec("coeffStaticp", v => coeffStaticp = v);
            builddec("coeffStaticm", v => coeffStaticm = v);

            builddec("coeffStaticpRetour", v => coeffStaticpRetour = v);
            builddec("coeffStaticmRetour", v => coeffStaticmRetour = v);

            builddec("currentStaticp", v => currentStaticp = v);
            builddec("currentStaticm", v => currentStaticm = v);
            builddec("rapportmp", v => rapportmp = v);


            HistoValue last = null;
            var xhisto = XMLTool.NodeLookUp(child, "histo");
            if (xhisto != null)
            {
                foreach (XmlElement sub in xhisto.ChildNodes)
                {
                    var _nevw = new HistoValue(sub.InnerText, last);
                    histo.Add(_nevw);
                    last = _nevw;
                }
            }
            else
            {

                if (File.Exists(Path))
                {
                    var lines = File.ReadAllLines(Path);
                    for (int i = 0; i < lines.GetLength(0); i++)
                    {
                        try
                        {
                            var line = lines[i];

                            if (string.IsNullOrEmpty(line))
                                continue;
                            var _nevw = new HistoValue(line, last);
                            histo.Add(_nevw);
                            last = _nevw;
                        }
                        catch (Exception ex)
                        {
                            misc.log(string.Format("impossible de lire la ligne n° {0}:{1}", i + 1, lines[i]), ex);
                            throw;
                        }
                    }
                    indexDiff = histo.Count;

                    //if (histo.Count >0 )
                    //    coeffVirt = getCoeff(histo[histo.Count -1]);


                }

                if (File.Exists(PathDiff))
                {
                    var histoDiff = new List<HistoValue>();
                    var lines = File.ReadAllLines(PathDiff);
                    for (int i = 0; i < lines.GetLength(0); i++)
                    {
                        try
                        {
                            var line = lines[i];
                            if (string.IsNullOrEmpty(line))
                                continue;

                            var _nevw = new HistoValue(line, last);
                            histoDiff.Add(_nevw);
                            last = _nevw;
                        }
                        catch (Exception ex)
                        {
                            misc.log(string.Format("impossible de lire la ligne n° {0}:{1}", i + 1, lines[i]), ex);
                            throw;
                        }

                    }

                    if (mode == dbMode.full)
                    {
                        histo.AddRange(histoDiff);
                        indexDiff = histo.Count;
                    }
                    else
                    {
                        indexDiff = histo.Count - histoDiff.Count;
                    }

                }



                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);

                if (histo.Count > 0)
                {
                    int index = histo.Count - 1;
                    decimal current = histo[index].coeff;
                    //coeffVirt = getCoeff(current);
                    bool? sens = null;

                    int nbSerie = 0;
                    // decimal delta = 0m;

                    var rr = 1;
                    //if (dcoeffp > 0)
                    //    rr = dcoeffm / dcoeffp;
                    if (rr > 0)
                    {
                        while (true)
                        {
                            index--;
                            if (index < 0)
                                break;
                            var aux = histo[index].coeff;
                            var _sens = current > aux;
                            if (sens == null)
                            {
                                sens = _sens;
                                lastAutoDirection = !_sens;

                                // delta = current - aux;
                            }


                            if (sens != _sens)
                                break;
                            current = aux;
                            nbSerie++;

                        }

                        //_nbSameDirection = nbSerie;
                        //dcoeffp = Math.Abs(delta); dcoeffm = dcoeffp * rr;

                    }
                }
            }

            checkCoeffOld();
            //if (histoDiff.Count > 0)
            //    coeffVirt = getCoeff(histo[histo.Count - 1]); 

        }



        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("name", name);
            write("mode", mode);
            write("serial", _nbSameDirection);
            write("serialBox", _nbSameDirectionBox);
            write("serialAltC", _nbAlt);
            write("serialAltH", _nbAltHisto);
            write("elastiqueC", _nbElastique);
            write("elastiqueC2", _nbElastique2);
            write("lastDelta", lastDelta);

            write("serialAlt", serialAlt);
            write("elastique", serialElastique);
            write("coeffElastique1", coeffElastique1);
            write("coeffElastique2", coeffElastique2);
            write("coeffElastique1r", coeffElastique1r);
            write("coeffElastique2r", coeffElastique2r);
            write("fdata", fdata);
            write("fdiff", fdiff);
            write("fdiffTmp", fdiffTmp);

            write("coeffVirt", coeffVirt);
            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);

            write("pas", pas);
            write("v", v);
            write("dv", dv);
            write("d0", d0);
            write("a", a);
            write("aa", aa);
            write("aepsilon", aepsilon);
            write("vepsilon", vepsilon);
            write("rapportmp", rapportmp);

            //write("dcoeffp", dcoeffp);
            //write("dcoeffm", dcoeffm);
            //write("dconvergence", dconvergence);
            //write("dconvergence0", dconvergence0);
            //write("dconvergence01", dconvergence01);
            //write("dconvdeltap", dconvdeltap);
            //write("dconvdeltam", dconvdeltam);

            //write("danticonvergence", danticonvergence);
            //write("danticonvergence0", danticonvergence0);
            //write("danticonvergence01", danticonvergence01);
            //write("danticonvdeltap", danticonvdeltap);
            //write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);



            write("coeffOld", coeffOld);

            write("oldAsZero", oldAsZero);
            write("coeffOldAuto", coeffOldAuto);
            write("coeffOldSwap", coeffOldSwap);

            write("coeffOldAutoLevel", coeffOldAutoLevel);
            write("epsilon", epsilon);

            write("coeffStaticp", coeffStaticp);
            write("coeffStaticm", coeffStaticm);
            write("coeffStaticpRetour", coeffStaticpRetour);
            write("coeffStaticmRetour", coeffStaticmRetour);
            write("currentStaticp", currentStaticp);
            write("currentStaticm", currentStaticm);



            var sb = new StringBuilder();
            var sbDiff = new StringBuilder();




            //if (modeDiff)
            //{
            //    histoDiff = null;
            //}
            //else
            //{
            //    if (histoDiff != null)
            //    {
            //        histo.AddRange(histoDiff);
            //        histoDiff = null;
            //    }

            //    if (File.Exists(PathDiff))
            //        File.Delete(PathDiff);
            //}

            int count = histo.Count;
            HistoValue last = null;
            for (int i = 0; i < count; i++)
            {
                histo[i].write(sb);
                //var v = Math.Round(histo[i].coeff, 10);
                //var sc = v.ToString();
                //var v2 = Math.Round(1000m * histo[i].delta, 10);
                //var sc2 = v2.ToString();

                //var v3 = Math.Round(1000m * histo[i].conv, 10);
                //var sc3 = v3.ToString();

                //sb.Append(sc);
                //sb.Append("|");
                //sb.Append(sc2);
                //sb.Append("|");
                //sb.AppendLine(sc3);

                if (i >= indexDiff)
                {
                    histo[i].writeDiff(sbDiff, last);
                    //sbDiff.Append(sc);
                    //sbDiff.Append("|");
                    //sbDiff.Append(sc2);
                    //sbDiff.Append("|");
                    //sbDiff.AppendLine(sc3);
                }
                last = histo[i];
            }


            if (!string.IsNullOrEmpty(fdata))
            {
                AsyncFileWriter.Instance.post(Path, sb.ToString());
                if (mode == dbMode.diff)
                    AsyncFileWriter.Instance.post(PathDiff, sbDiff.ToString());
                else
                    AsyncFileWriter.Instance.post(PathDiffTmp, sbDiff.ToString());


                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);
            }


            writeEnd();
        }
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        public int Serial { get { return _nbSameDirection; } set { _nbSameDirection = value; } }
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        public int SerialBox { get { return _nbSameDirectionBox; } }
        /// <summary>
        /// nb allez-retours pour calcul
        /// </summary>
        public int Alt { get { return _nbAlt; } }
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        public int AltHisto { get { return _nbAltHisto; } }
        /// <summary>
        /// Position de l'élastique. Positif : tend à agrandir le delta. du à plusieurs séries dans le même sens. Négatif : tend à diminuer le delta. du à plusieurs allez-retours consécutifs
        /// </summary>
        public decimal Elastique { get { return _nbElastique; } }
        public decimal Elastique2 { get { return _nbElastique2; } }
        public decimal dv = 0;
        public decimal dx = 0m;
        //  public decimal da;
        public decimal AccelerationRapport { get { return dv / epsilon; } }
        public decimal VitesseRapport { get { return dx / epsilon; } }
        public decimal danticonvergenceMin
        {
            get
            {
                return epsilon;
            }
        }




        public decimal CoeffOld
        {
            get { return coeffOld; }
            set { coeffOld = value; checkCoeffOld(); }
        }

        public bool CoeffOldAuto
        {
            get { return coeffOldAuto; }
            set { coeffOldAuto = value; checkCoeffOld(); }
        }

        //private decimal getCoeff(decimal coeffT) { return Math.Pow(coeffT, (1.0m / safe)); }


    }
}
]]></content>
  </file>
</db>
