<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\ViewModel\AllTracksViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.player.ViewModel.Commande.Link;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.Commande;
using pdb.util;
using System.Globalization;

namespace pdb.player.ViewModel
{
    public enum listDisplay
    {
        all,
        onlyDisabled,
        onlyEnabled
    }

    public class AllTracksViewModel : List<TrackListViewModel>, INotifyCollectionChanged, INotifyPropertyChanged
    {
        public event NotifyCollectionChangedEventHandler CollectionChanged;
        public event PropertyChangedEventHandler PropertyChanged;
        //   private List<TrackListViewModel> tracks;
        private Dictionary<int, TrackListViewModel> dict;
        private object _lock = new object();
        private PlayListViewModel parent;
        private DispatcherOperation ope;



        private bool? onlyDisabled;
        private bool onlyFathers;
        public AllTracksViewModel(PlayListViewModel parent, bool? onlyDisabled, bool onlyFathers)
        {
            this.parent = parent;
            this.onlyDisabled = onlyDisabled;
            this.onlyFathers = onlyFathers;
            //   this.mode = mode; 
            build();
            PlayerViewModel.Instance.resumeChange += playerResumeChange;
            PlayerViewModel.autoChange += new EventHandler(PlayerViewModel_autoChange);
            //TrackListViewModel.CurrentHumanSelectedChanged += PlayerViewModel_autoChange; 
        }

        void PlayerViewModel_autoChange(object sender, EventArgs e)
        {
            OnPropertyChanged("AutoResume");
        }


        void playerResumeChange(object sender, EventArgs e)
        {
            OnPropertyChanged("TV");
            OnPropertyChanged("Resume");
            OnPropertyChanged("AutoResume");
        }

        public string Resume
        {
            get
            {
                return PlayerViewModel.Instance.Resume;
            }
            set
            {

            }
        }

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (CollectionChanged == null)
            //    {
            //    }
            //    else
            //    {
            //        CollectionChanged(this, e); 
            //    }
            //    return; 
            //}

            //dispatcher.Invoke(DispatcherPriority.DataBind, new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e);



            var eventHandler = CollectionChanged;
            if (eventHandler != null)
            {
                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (NotifyCollectionChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        // Invoke handler in the target dispatcher's thread
                        {
                            ope =
                               dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                            handler, this, e);
                            ope.Completed += ope_Completed;


                        }
                        else // Execute handler as is
                            handler(this, e);
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
            else
            {
            }

            // PlayerViewModel.Instance.makeResume();

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("AllTracksViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
            PlayerViewModel.Instance.makeResume();
        }


        protected virtual void OnPropertyChanged(string propertyName)
        {
            var eventHandler = PropertyChanged;
            if (eventHandler == null)
            {
                //   int toto = 0;
            }
            else
            {
                //var dispatcher = Dispatcher.CurrentDispatcher;
                //if (dispatcher.CheckAccess())
                //    PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
                //else
                //    dispatcher.Invoke(new Action<string>(OnPropertyChanged), propertyName);

                Delegate[] delegates = eventHandler.GetInvocationList();
                // Walk thru invocation list
                foreach (PropertyChangedEventHandler handler in delegates)
                {
                    try
                    {
                        var dispatcherObject = handler.Target as DispatcherObject;
                        // If the subscriber is a DispatcherObject and different thread
                        if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                          handler, this, new PropertyChangedEventArgs(propertyName));
                        else // Execute handler as is
                            handler(this, new PropertyChangedEventArgs(propertyName));
                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                }
            }
        }

        public void refresh()
        {
            build();
            foreach (TrackListViewModel track in this)
                track.refresh();

        }

        //public void init()
        //{
        //    refresh();
        //    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        //}

        public TrackListViewModel TV { get { return TrackListViewModel.HumanSelected; } }

        public void build()
        {
            lock (_lock)
            {
                var list = new List<TrackListViewModel>();
                var dict = new Dictionary<int, TrackListViewModel>();
                buildAllTraks(list, dict, onlyDisabled, onlyFathers);
                if (this.dict == null)
                {
                    this.dict = new Dictionary<int, TrackListViewModel>();
                    foreach (TrackListViewModel track in list)
                    {
                        Add(track);
                        this.dict.Add(track.PieceId, track);
                        // track.PropertyChanged += track_PropertyChanged;
                    }

                    OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
                }
                else
                {

                    foreach (TrackListViewModel newTrack in list)
                    {
                        if (!this.dict.ContainsKey(newTrack.PieceId))
                        {
                            Add(newTrack);
                            this.dict.Add(newTrack.PieceId, newTrack);
                            // newTrack.PropertyChanged += track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, newTrack));
                        }
                    }

                    foreach (TrackListViewModel track in new List<TrackListViewModel>(this))
                    {
                        if (!dict.ContainsKey(track.PieceId))
                        {
                            Remove(track);
                            this.dict.Remove(track.PieceId);
                            // track.PropertyChanged -= track_PropertyChanged;
                            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, track));
                        }
                    }
                }
            }

            //Clear(); 
            //foreach (TrackListViewModel track in parent.Tracks)
            //    Add(track); 
        }

        //void track_PropertyChanged(object sender, PropertyChangedEventArgs e)
        //{
        //    switch (e.PropertyName)
        //    {
        //        case "Duration":
        //        case "Enabled":
        //            PlayerViewModel.Instance.makeResume();
        //            break;
        //    }
        //}

        public List<TrackListViewModel> AllTracks
        {
            get
            {
                build();
                return this;
            }
        }

        public List<TrackListViewModel> Tracks
        {
            get
            {
                return parent.Tracks;
            }
        }

        protected void buildAllTraks(List<TrackListViewModel> container, Dictionary<int, TrackListViewModel> dict, bool? onlyDisabled, bool onlyFathers)
        {
            foreach (TrackListViewModel t in parent.Tracks)
            {
                if (!t.Enabled || true != onlyDisabled)
                {
                    if (onlyDisabled == null && t.Enabled)
                    {
                        if (!t.PieceGen.ClassementProvisoireRecent)
                            continue;
                    }
                    if (t.PieceParentId < 0 || !onlyFathers)
                    {
                        if (!t.Track.Virtual || PlayerViewModel.Instance.WithVirtualAlbum)
                        {

                            if (!dict.ContainsKey(t.PieceId))
                            {
                                dict.Add(t.PieceId, t);
                                container.Add(t);
                                //  t.Index = container.Count; 
                            }
                        }
                    }
                }

            }

            foreach (PlayListViewModel pl in parent)
            {
                AllTracksViewModel other = pl.AlltracksVm;
                //if (true == onlyDisabled)
                //    other = pl.AlltracksVmd;
                //else
                //    other = pl.AlltracksVm;
                other.buildAllTraks(container, dict, onlyDisabled, onlyFathers);
            }
        }

        #region cmd

        private ICommand _contextCmdCheck;
        public ICommand ContextCmdCheck { get { if (_contextCmdCheck == null) _contextCmdCheck = new CheckCmd(); return _contextCmdCheck; } }

        private ICommand _contextCmdUnCheck;
        public ICommand ContextCmdUnCheck { get { if (_contextCmdUnCheck == null) _contextCmdUnCheck = new UnCheckCmd(); return _contextCmdUnCheck; } }


        private ICommand _contextLinkFather;
        public ICommand LinkFather { get { if (_contextLinkFather == null) _contextLinkFather = new LinkFather(); return _contextLinkFather; } }

        private ICommand _contextLinkChild;
        public ICommand LinkChild { get { if (_contextLinkChild == null) _contextLinkChild = new LinkChild(); return _contextLinkChild; } }

        private ICommand _contextLinkFusion;
        public ICommand LinkFusion { get { if (_contextLinkFusion == null) _contextLinkFusion = new LinkFusion(); return _contextLinkFusion; } }

        private ICommand _contextUnLink;
        public ICommand LinkReset { get { if (_contextUnLink == null) _contextUnLink = new LinkReset(); return _contextUnLink; } }

        private ICommand _contextExport;
        public ICommand Export { get { if (_contextExport == null) _contextExport = new ExportCmd(); return _contextExport; } }

        private ICommand _contextExportCompress;
        public ICommand ExportCompress { get { if (_contextExportCompress == null) _contextExportCompress = new ExportCompress(); return _contextExportCompress; } }

        private ICommand _contextDelete;
        public ICommand DeleteTrack { get { if (_contextDelete == null) _contextDelete = new DeleteCmd(); return _contextDelete; } }

        private ICommand _contexExplorer;
        public ICommand Explorer { get { if (_contexExplorer == null) _contexExplorer = new Explorer(); return _contexExplorer; } }



        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(App.Instance); return _ContextCmdAddToList; } }

        private ICommand _ContextCmdDbDeleteClassement;
        public ICommand ContextCmdDbDeleteClassement { get { if (_ContextCmdDbDeleteClassement == null) _ContextCmdDbDeleteClassement = new DbDeleteLastClassement(); return _ContextCmdDbDeleteClassement; } }

        private ICommand _ContextCmdDbDeleteRead;
        public ICommand ContextCmdDbDeleteRead { get { if (_ContextCmdDbDeleteRead == null) _ContextCmdDbDeleteRead = new DbDeleteLastRead(); return _ContextCmdDbDeleteRead; } }


        #endregion

        public TrackListViewModel HumanSelected
        {
            get
            {
                return TrackListViewModel.HumanSelected;
            }
        }

        #region from Ihm
        private TrackListViewModel selectedTrack;
        public TrackListViewModel SelectedTrack
        {
            get
            {
                return selectedTrack;
            }
            set
            {
                selectedTrack = value;
                TrackListViewModel.setHumanSelected(parent, value); //  .HumanSelected = value;
                if (selectedTrack != null)
                    selectedTrack.IsSelected = true;
            }
        }
        #endregion

        private int nbAlbumMoved;

        public int NbAlbumMoved
        {
            get { return nbAlbumMoved; }
        }

        private int nbEmpeached;
        public int NbEmpeached { get { return nbEmpeached; } }

        public string AutoResume
        {
            get
            {

                try
                {

                    var conf = App.gen.SortAlbumMode.ComposantsUtiles[0].Main;
                    var sb = new StringBuilder();


                    sb.Append((conf.coeffVirt - 1).FormatE(4)); sb.Append("  "); //(3,3,9));
                    //var str = (conf.coeffVirt -1) .ToString("0.000######", CultureInfo.InvariantCulture);
                    //decimal val = Convert.ToDecimal(str, CultureInfo.InvariantCulture); 
                    //val += 1m;


                    //str = val.ToString("0.000 ### ###", CultureInfo.InvariantCulture); 


                    //sb.Append(str); sb.Append(" ");

                    sb.Append((conf.v).FormatE(4)); sb.Append("  ");  //sb.Append("m  ");
                    //var percentConv = 0m;
                    //if (conf.a > 0)
                    //{
                    //percentConv = 100 * conf.a / conf.a;
                    //sb.Append((percentConv).Format(2, 2, 6)); sb.Append("/");
                    //percentConv = conf.acceleration / conf.danticonvergenceMin;
                    //sb.Append((percentConv).ToString("0.##", CultureInfo.InvariantCulture)); sb.Append(" ");
                    sb.Append(conf.a.FormatE(4)); sb.Append("  ");
                    sb.Append(conf.CurrentStaticm.FormatE(3)); sb.Append("  ");
                    // sb.Append(conf.dv.FormatE(4)); sb.Append("   "); 

                    // sb.Append(conf.AccelerationRapport.ToString("0.###", CultureInfo.InvariantCulture)); sb.Append("  ");
                    //    }

                    sb.Append(conf.Serial); sb.Append(" ");
                    sb.Append(conf.SerialBox); sb.Append(" ");
                    sb.Append(conf.Alt); sb.Append(" ");
                    sb.Append(conf.AltHisto); sb.Append("  ");
                    sb.Append(conf.Elastique.ToString("0.#")); sb.Append(" ");
                    sb.Append(conf.Elastique2.ToString("0.#"));
                    //var motif = selectedCoeff.none;
                    //var current = TrackListViewModel.HumanSelected;
                    //if (current != null)
                    //    motif = current.SelectedMotif; 
                    //  var stat10 = conf.calcStat(motif,10);
                    // sb.Append(stat10); sb.Append(" - ");
                    //   var stat100 = conf.calcStat(motif,100);
                    //  sb.Append(stat100); 

                    //sb.Append(conf.coeffTMin(10).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" "); sb.Append(conf.coeffTMax(10).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" - ");
                    //sb.Append(conf.coeffTMin(100).ToString("0.000", CultureInfo.InvariantCulture)); sb.Append(" "); sb.Append(conf.coeffTMax(100).ToString("0.000", CultureInfo.InvariantCulture)); 
                    return sb.ToString();

                }
                catch
                {
                    return "";
                }
            }
        }
        public string NbAlbumMovedDesc
        {
            get
            {
                if (nbAlbumMoved < 0)
                    return "";
                if (nbAlbumMoved == 0)
                    return "pas d'album en quarantaine";
                return string.Format("{0} albums en quarantaine", nbAlbumMoved);
            }
        }

        public void setNbAlbum(int nbanavailable, int empeches, int moved)
        {
            if (nbanavailable != this.nbAlbumMovedUnavailable)
            {
                this.nbAlbumMovedUnavailable = nbanavailable;
                OnPropertyChanged("NbAlbumMovedUnavailable");
            }

            if (empeches != nbEmpeached)
            {
                nbEmpeached = empeches;
                OnPropertyChanged("NbEmpeached");
            }

            if (moved != nbAlbumMoved)
            {
                nbAlbumMoved = moved;
                OnPropertyChanged("NbAlbumMoved");
            }
        }

        //public void setNbAlbumMoved(int nb)
        //{
        //    if (nb != nbAlbumMoved)
        //    {
        //        nbAlbumMoved = nb;
        //        OnPropertyChanged("NbAlbumMoved");
        //        OnPropertyChanged("NbAlbumMovedDesc");
        //    }

        //}

        private int nbAlbumMovedUnavailable;
        public int NbAlbumMovedUnavailable
        {
            get
            {
                return nbAlbumMovedUnavailable;
            }

            //set
            //{
            //    if (value != nbAlbumMovedUnavailable)
            //    {
            //        nbAlbumMovedUnavailable = value;
            //        OnPropertyChanged("NbAlbumMovedUnavailable");
            //    }
            //}
        }

    }


}
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.IO;

namespace pdb.util
{
    public class HistoValue
    {
        char SEP = '|';
        public decimal coeff;
        public decimal delta;
        public decimal accel;
        // pour info
        public decimal dcoeffp;
        public decimal dv;

        //private HistoValue(string line)
        //{
        //    var tab = line.Split(SEP);
        //    int count = tab.GetLength(0);
        //    if (count >= 1 && !string.IsNullOrEmpty(tab[0]))
        //        coeff = Convert.ToDecimal(tab[0]);
        //    if (count >= 2 && !string.IsNullOrEmpty(tab[1]))
        //        delta = Convert.ToDecimal(tab[1]) / 1000m;
        //    if (count >= 3 && !string.IsNullOrEmpty(tab[2]))
        //        conv = Convert.ToDecimal(tab[2]) / 1000m;
        //}

        public HistoValue(string line, HistoValue last)
        {
            var tab = line.Split(SEP);
            int count = tab.GetLength(0);
            string str = "";
            if (count >= 1)
            {
                str = tab[0];
                if (!string.IsNullOrEmpty(str))
                    coeff = Convert.ToDecimal(str);
                else if (last != null)
                    coeff = last.coeff;
            }
            if (count >= 2)
            {
                str = tab[1];
                if (!string.IsNullOrEmpty(str))
                    delta = Convert.ToDecimal(str) / 1000m;
                else if (last != null)
                    delta = last.delta;
            }
            if (count >= 3)
            {
                str = tab[2];
                if (!string.IsNullOrEmpty(str))
                    accel = Convert.ToDecimal(str) / 1000m;
                else if (last != null)
                    accel = last.accel;
            }

            if (count >= 4)
            {
                str = tab[3];
                if (!string.IsNullOrEmpty(str))
                    dcoeffp = Convert.ToDecimal(str) / 1000m;
                else if (last != null)
                    dcoeffp = last.dcoeffp;
            }

            if (count >= 5)
            {
                str = tab[4];
                if (!string.IsNullOrEmpty(str))
                    dv = Convert.ToDecimal(str) / 1000m;
                else if (last != null)
                    dv = last.dv;
            }
        }

        public HistoValue(decimal coeff, decimal delta, decimal accel, decimal dcoeff, decimal dv)
        {
            this.coeff = coeff;
            this.delta = delta;
            this.accel = accel;
            this.dcoeffp = dcoeff;
            this.dv = dv;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            write(sb);
            return sb.ToString();
        }

        public void write(ITextWriter sb)
        {
            var v = Math.Round(coeff, 12);
            var sc = v.ToString();
            var v2 = Math.Round(1000m * delta, 10);
            var sc2 = v2.ToString();

            var v3 = Math.Round(1000m * accel, 10);
            var sc3 = v3.ToString();

            var v4 = Math.Round(1000m * dcoeffp, 10);
            var sc4 = v4.ToString();

            var v5 = Math.Round(1000m * dv, 10);
            var sc5 = v5.ToString();

            sb.Append(sc);
            sb.Append(SEP);
            sb.Append(sc2);
            sb.Append(SEP);
            sb.Append(sc3);
            sb.Append(SEP);

            sb.Append(sc4);
            sb.Append(SEP);
            sb.AppendLine(sc5);
        }

        private static decimal getTruncate(decimal v)
        {
            return Math.Round(1000m * v, 10);
        }

        public void writeDiff(ITextWriter sb, HistoValue last)
        {


            var v = Math.Round(coeff, 12);
            var sc = v.ToString();
            sb.Append(sc);

            sb.Append(SEP);
            var v2 = getTruncate(delta);
            if (last == null || v2 != getTruncate(last.delta))
            {
                var sc2 = v2.ToString();
                sb.Append(sc2);
            }

            sb.Append(SEP);
            var v3 = getTruncate(accel);
            if (last == null || v3 != getTruncate(last.accel))
            {
                var sc3 = v3.ToString();
                sb.Append(sc3);
            }
            sb.Append(SEP);

            var v4 = getTruncate(dcoeffp);
            if (last == null || v4 != getTruncate(last.dcoeffp))
            {
                var sc4 = v4.ToString();
                sb.Append(sc4);
            }
            sb.Append(SEP);
            var v5 = getTruncate(dv);
            if (last == null || v5 != getTruncate(last.dv))
            {
                var sc5 = v5.ToString();
                sb.Append(sc5);
            }
            sb.AppendLine();

        }
    }
    public enum selectedCoeff
    {
        none,
        noCoeff,
        main,
        min
    }

    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        unselected = 1,
        virtuel = 2,
        tous = 3
    }

    public enum modeMin
    {
        /// <summary>
        /// On ne gère pas
        /// </summary>
        non = 0,
        /// <summary>
        /// Morceaux supérieurs à la limite ( pas d'influence sur le résultat)
        /// </summary>
        orphelin = 1,
        /// <summary>
        /// Morceaux cochés et notés
        /// </summary>
        toujours = 2

    }

    //public class HistoStat
    //{
    //    public HistoStatItem min;
    //    public HistoStatItem max;

    //    public HistoStat()
    //    {
    //        min = new HistoStatItem(int.MaxValue);
    //        max = new HistoStatItem(-1);
    //    }
    //    public HistoStat(decimal val)
    //    {
    //        min = new HistoStatItem(val);
    //        max = new HistoStatItem(val);
    //    }

    //    //private string desc(decimal d)
    //    //{
    //    //    if (d < 0)
    //    //        return "";
    //    //    if (d >= int.MaxValue)
    //    //        return "";
    //    //    return d.ToString("0.000", System.Globalization.CultureInfo.InvariantCulture);
    //    //}

    //    public override string ToString()
    //    {
    //        //return string.Format("{0}({1}) {2}({3})", desc(min.absolute), desc(min.relative), desc(max.absolute), desc(max.relative)); 
    //        return string.Format("{0} {1}", min, max);
    //    }
    //}

    //public class HistoStatItem
    //{
    //    public decimal relative;
    //    public decimal absolute;
    //    public HistoStatItem()
    //    {
    //        relative = -1;
    //        absolute = -1;
    //    }
    //    public HistoStatItem(decimal val)
    //    {
    //        relative = val;
    //        absolute = val;
    //    }

    //    public static string desc(decimal d)
    //    {
    //        if (d < 0)
    //            return "";
    //        if (d >= int.MaxValue)
    //            return "";
    //        return d.ToString("0.000", System.Globalization.CultureInfo.InvariantCulture);
    //    }

    //    public override string ToString()
    //    {
    //        var sb = new StringBuilder();
    //        sb.Append(desc(absolute));
    //        if (absolute != relative)
    //        {
    //            sb.Append("(");
    //            sb.Append(desc(relative));
    //            sb.Append(")");
    //        }
    //        return sb.ToString();
    //    }


    //}

    [Serializable]
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;

        public bool enabled;



        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast;

        public decimal expEnabled = 0m;

        public decimal zero = 0m;
        /// <summary>
        /// 
        /// </summary>
        public bool removeEnabled;




        public modeMin cmpMin;

        private ConfMedianneVirt _main;
        private ConfMedianneVirt _min;

        public ConfMedianneVirt Main { get { return _main; } }
        public ConfMedianneVirt Min { get { return _min; } }
        public ConfMedianne()
        {
            _main = new ConfMedianneVirt();
            _min = new ConfMedianneVirt();

        }

        public void makeIdem()
        {
            _min = _main;
        }

        public void duplicateMainIf()
        {
            if (_min == _main)
                _min = new ConfMedianneVirt(_main);
        }

        public ConfMedianne(ConfMedianne o, bool raz)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;

            enabled = o.enabled;



            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;

            expEnabled = o.expEnabled;

            zero = o.zero;
            removeEnabled = o.removeEnabled;



            cmpMin = o.cmpMin;

            _main = new ConfMedianneVirt(o._main, raz);
            _min = new ConfMedianneVirt(o._min, raz);

        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            buildb("quasi", v => quasi = v);
            buildb("enabled", v => enabled = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);
            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v);
            string _modeMin = "";
            builds("cmpMin", v => _modeMin = v);
            if (!string.IsNullOrEmpty(_modeMin))
                cmpMin = (modeMin)Enum.Parse(typeof(modeMin), _modeMin, true);

            string _removeLast = null;
            builds("removeLast", v => _removeLast = v);
            removeLast = (removeLast)Enum.Parse(typeof(removeLast), _removeLast, true);

            _main = null;
            _min = null;
            var subs = XMLTool.NodeLookUp(child, "virts");
            if (subs != null)
            {
                foreach (XmlNode _n in subs.ChildNodes)
                {
                    if (_n is XmlElement)
                    {
                        if (_main == null)
                        {
                            _main = new ConfMedianneVirt(child, _n as XmlElement);

                        }
                        else if (_min == null)
                        {
                            _min = new ConfMedianneVirt(child, _n as XmlElement);
                        }
                    }
                }
                if (_min == null && _main != null)
                    _min = new ConfMedianneVirt(_main);
            }
        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("cmp");
            write("type", type);
            write("medianne", medianne);
            write("quasi", quasi);
            write("enabled", enabled);
            write("removeFirst", removeFirst);
            write("deleteFirst", deleteFirst);
            write("expEnabled", expEnabled);
            write("zero", zero);
            write("removeEnabled", removeEnabled);
            write("cmpMin", cmpMin);
            write("removeLast", removeLast);

            writeStart("virts");
            _main.save(w);
            _min.save(w);
            writeEnd();

            writeEnd();



        }


        public void auto(selectedCoeff motif)
        {
            if (!enabled)
                return;
            if (motif == selectedCoeff.none)
                return;
            var coeffPrisEncompte = motif > selectedCoeff.noCoeff;
            if (_min == _main || _min.coeffVirt == 1m)
            {
                _main.calcAuto(coeffPrisEncompte);
            }
            else
            {
                if (coeffPrisEncompte)
                {
                    if (motif == selectedCoeff.main)
                        _main.calcAuto(true);
                    if (motif == selectedCoeff.min)
                        _min.calcAuto(true);
                }
                else
                {
                    _main.calcAuto(false);
                    _min.calcAuto(false);
                }
            }
        }
    }

    [Serializable]
    public class ConfMedianneVirt : TuningBase
    {
        [NonSerialized]
        const string PATH_DYN = "..\\dynamic";
        private string Path { get { return string.Format("{0}{1}", DIR_CONF, fdata); } }
        private string PathDiff { get { return string.Format("{0}{1}", DIR_CONF, fdiff); } }
        private string PathDiffTmp { get { return string.Format("{0}{1}", DIR_CONF, fdiffTmp); } }
        // private string PathLastFull { get { return string.Format("{0}{1}", DIR_CONF, flast); } }
        const string PATH_DYN_DIFF = "..\\dynamic_diff";

        // const decimal EPSILON = 0.000001m;// 0.001m;
        const int NB_HISTO = 1000000;
        public int safe;
        public decimal coeffVirt = 1m;

        //private bool firstSave = true;
        //private static bool modeDiff;
        //public static bool ModeDiff
        //{
        //    get { return modeDiff; }
        //    set
        //    {
        //        modeDiff = value;
        //    }
        //}

        public string name;


        /// <summary>
        /// lié au mode db
        /// </summary>
        public dbMode mode;
        /// <summary>
        /// fichier ou est consigné l'historique courant
        /// </summary>
        public string fdata;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique
        /// </summary>
        public string fdiff;
        /// <summary>
        /// fichier ou est consigné l'incrémental de l'historique en mode full en vue de la sauvegarfe
        /// </summary>
        public string fdiffTmp;
        ///// <summary>
        ///// fichier ou est consigné la dernière sauvegarde full de l'historique
        ///// </summary>
        //public string flast;

        public int indexDiff = 0;

        public bool virtOnlyDisabled;
        public bool noAddEnd;
        public bool noAddAll;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        public bool coeffVirtAuto;
        public bool coeffVirtAdjust;

        public bool removeEpsilon;

        public bool forceCoeffVirt;
        public bool lissage;
        public bool cumul;

        public bool reSort;
        public bool noAdd;


        public bool auto;

        public int serialp = 1;
        public int serialm = 1;
        public int serialAlt = 1;
        public decimal serialElastique = 1m;
        public decimal coeffElastique1 = 1m;
        public decimal coeffElastique2 = 1m;

        /// <summary>
        /// pas de calcul
        /// </summary>
        public decimal pas = 0.1m;
        /// <summary>
        /// vitesse : augmentation ou diminution du coeff virtuel
        /// </summary>
        public decimal v;

        ///// <summary>
        ///// Vitesse virtuelle : pour calculer l'accélaration en tenant compte des contraintes en simulant un augmentation. Mauvaise idée. toujours egal à v en cas de contrainte
        ///// </summary>
        //private decimal vv;
        /// <summary>
        /// borne visant à limiter le delta entre deux pas
        /// </summary>
        public decimal d0 = 0.01m;
        //  public decimal dcoeffm;


        /// <summary>
        /// accélération : augmentation ou diminution de la vitesse
        /// </summary>
        public decimal a;
        //public decimal a0 =0.01m;
        //public decimal dconvergence01;
        /// <summary>
        /// variation de l'accélération en proportion
        /// </summary>
        public decimal aa = 0.01m;
        /// <summary>
        ///accélaration plancher
        /// </summary>
        public decimal aepsilon = 0.001m;

        /// <summary>
        /// ecart min entre deux positions
        /// </summary>
        private decimal epsilon = 0.001m * 0.001m;
        /// <summary>
        /// ecart de vitesse entre deux positions
        /// </summary>
        private decimal vepsilon = 0.001m * 0.001m;

        private bool? lastDelta;
        private bool? lastAutoDirection;
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        private int _nbSameDirection;
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        private int _nbSameDirectionBox;
        /// <summary>
        /// nb allez/retour pour calcul
        /// </summary>
        private int _nbAlt;
        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique;

        /// <summary>
        /// bilan même sens vs allez-retour. Quand trop grand on agrandit le delta, quand trop petit on diminue
        /// </summary>
        private decimal _nbElastique2;
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        private int _nbAltHisto;

        /// <summary>
        /// Quand plusieurs montées consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticp = 1;
        /// <summary>
        /// Quand plusieurs descentes consécutives : application d'un coeff à la vitesse pour accélérer la reprise à la normale
        /// </summary>
        private decimal coeffStaticm = 1;

        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des montées consécutives
        /// </summary>
        private decimal currentStaticp = 1;
        /// <summary>
        /// Valeur courante du coeff corrigeant les situations anormales du point de vue des descentes consécutives
        /// </summary>
        private decimal currentStaticm = 1;
        public decimal CurrentStaticm { get { return currentStaticm; } }
        /// <summary>
        /// anti atténuation
        /// </summary>
        //public decimal danticonvergence = 1m;
        //public decimal danticonvergence0;
        //public decimal danticonvergence01;

        //public decimal danticonvdeltap = 1m;
        //public decimal danticonvdeltam = 1m;
        private bool _linkconv;
        private decimal linkProduct;
        private List<HistoValue> histo = new List<HistoValue>();
        //  private List<decimal> histoDiff = new List<decimal>();

        private decimal coeffOld = 1m;

        public bool oldAsZero;
        private bool coeffOldAuto;
        public int coeffOldAutoLevel;

        public bool linkconv { get { return _linkconv; } set { _linkconv = value; calcProduct(); } }

        private void calcProduct()
        {
            this.linkProduct = calcProduct(this.v, this.a);
        }

        public decimal calcProduct(decimal dcoeffp, decimal dconvergence)
        {
            var linkProduct = this.linkProduct;
            try
            {
                linkProduct = dcoeffp / dconvergence;
                // 1 0,9 -> 10
                // 0.1 0,99 
            }
            catch
            {
            }

            return linkProduct;
        }

        private void calcConv()
        {
            this.a = calcConv(this.v, this.linkProduct);
        }

        public decimal LinkProduct
        {
            get
            {
                if (linkProduct == 0m)
                    calcProduct();
                return linkProduct;
            }
            set
            {
                linkProduct = value;
                calcConv();

            }
        }

        public decimal calcConv(decimal dcoeffp, decimal linkProduct)
        {
            var dconvergence = this.a;
            try
            {
                // 1- conv = coeff / prod
                dconvergence = dcoeffp / linkProduct; //1/10
            }
            catch
            {

            }
            return dconvergence;
        }



        public ConfMedianneVirt()
        { }

        public ConfMedianneVirt(ConfMedianneVirt o, bool raz)
            : this(o)
        {
            if (raz)
            {
                safe = 0;
                coeffOld = 1;
                coeffVirt = 1;
            }
        }
        public ConfMedianneVirt(ConfMedianneVirt o)
        {
            name = o.name;
            mode = o.mode;
            fdata = o.fdata;
            fdiff = o.fdiff;
            fdiffTmp = o.fdiffTmp;
            //  flast = o.flast;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            virtOnlyDisabled = o.virtOnlyDisabled;
            noAddEnd = o.noAddEnd;
            noAddAll = o.noAddAll;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAdjust = o.coeffVirtAdjust;
            removeEpsilon = o.removeEpsilon;
            forceCoeffVirt = o.forceCoeffVirt;
            lissage = o.lissage;
            cumul = o.cumul;
            reSort = o.reSort;
            noAdd = o.noAdd;
            auto = o.auto;
            //dcoeffp = o.dcoeffp;
            //dcoeffm = o.dcoeffm;
            //dconvergence = o.dconvergence;
            //dconvdeltap = o.dconvdeltap;
            //dconvdeltam = o.dconvdeltam;
            //danticonvergence = o.danticonvergence;
            //danticonvdeltap = o.danticonvdeltap;
            //danticonvdeltam = o.danticonvdeltam;

            pas = o.pas;
            v = o.v;
            d0 = o.d0;
            a = o.a;
            aa = o.aa;
            aepsilon = o.aepsilon;
            _linkconv = o._linkconv;
            serialp = o.serialp;
            serialm = o.serialm;
            serialAlt = o.serialAlt;
            serialElastique = o.serialElastique;
            coeffElastique1 = o.coeffElastique1;
            coeffElastique2 = o.coeffElastique2;

            _nbSameDirection = o._nbSameDirection;
            _nbSameDirectionBox = o._nbSameDirectionBox;
            _nbAlt = o._nbAlt;
            _nbAltHisto = o._nbAltHisto;
            _nbElastique = o._nbElastique;
            _nbElastique2 = o._nbElastique2;

            coeffOld = o.coeffOld;
            coeffOldAuto = o.coeffOldAuto;
            oldAsZero = o.oldAsZero;
            coeffOldAutoLevel = o.coeffOldAutoLevel;
            epsilon = o.epsilon;

            //dconvergence0 = o.dconvergence0;
            //dconvergence01 = o.dconvergence01;
            //danticonvergence0 = o.danticonvergence0;
            //danticonvergence01 = o.danticonvergence01;

            lastDelta = o.lastDelta;
            histo = new List<HistoValue>(o.histo);

        }
        public ConfMedianneVirt(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var str = "";
            builds("mode", v => str = v);
            if (!string.IsNullOrEmpty(str))
                mode = (dbMode)Enum.Parse(typeof(dbMode), str);
            builds("name", v => name = v);
            builds("fdata", v => fdata = v);
            builds("fdiff", v => fdiff = v);
            builds("fdiffTmp", v => fdiffTmp = v);
            // builds("flast", v => flast = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildi("safe", v => safe = v);

            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("noAddEnd", v => noAddEnd = v);
            buildb("noAddAll", v => noAddAll = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v => virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);

            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("lissage", v => lissage = v);
            buildb("cumul", v => cumul = v);
            buildb("reSort", v => reSort = v);
            buildb("noAdd", v => noAdd = v);
            buildb("auto", v => auto = v);

            builddec("pas", v => pas = v);
            builddec("v", vv => v = vv);
            builddec("dv", v => dv = v);
            builddec("d0", v => d0 = v);
            builddec("a", v => a = v);
            builddec("aa", v => aa = v);
            builddec("vepsilon", v => vepsilon = v);
            builddec("aepsilon", v => aepsilon = v);


            //builddec("dcoeffp", v => dcoeffp = v);
            //builddec("dcoeffm", v => dcoeffm = v);
            //builddec("dconvergence", v => dconvergence = v);
            //builddec("dconvergence0", v => dconvergence0 = v);
            //builddec("dconvergence01", v => dconvergence01 = v);
            //builddec("dconvdeltap", v => dconvdeltap = v);
            //builddec("dconvdeltam", v => dconvdeltam = v);

            //builddec("danticonvergence", v => danticonvergence = v);
            //builddec("danticonvergence0", v => danticonvergence0 = v);
            //builddec("danticonvergence01", v => danticonvergence01 = v);
            //builddec("danticonvdeltap", v => danticonvdeltap = v);
            //builddec("danticonvdeltam", v => danticonvdeltam = v);
            buildb("linkconv", v => _linkconv = v);
            buildi("serialp", v => serialp = v);
            buildi("serialm", v => serialm = v);
            buildi("serialAlt", v => serialAlt = v);
            buildi("elastique", v => serialElastique = v);
            builddec("coeffElastique1", v => coeffElastique1 = v);
            builddec("coeffElastique2", v => coeffElastique2 = v);
            buildi("serial", v => _nbSameDirection = v);
            buildi("serialBox", v => _nbSameDirectionBox = v);
            buildi("serialAltC", v => _nbAlt = v);
            buildi("serialAltH", v => _nbAltHisto = v);
            builddec("elastiqueC", v => _nbElastique = v);
            builddec("elastiqueC2", v => _nbElastique2 = v);


            builddec("coeffOld", v => coeffOld = v);
            buildb("oldAsZero", v => oldAsZero = v);
            buildb("coeffOldAuto", v => coeffOldAuto = v);
            buildi("coeffOldAutoLevel", v => coeffOldAutoLevel = v);
            builddec("epsilon", v => epsilon = v);

            buildbn("lastDelta", v => lastDelta = v);

            builddec("coeffStaticp", v => coeffStaticp = v);
            builddec("coeffStaticm", v => coeffStaticm = v);
            builddec("currentStaticp", v => currentStaticp = v);
            builddec("currentStaticm", v => currentStaticm = v);


            HistoValue last = null;
            var xhisto = XMLTool.NodeLookUp(child, "histo");
            if (xhisto != null)
            {
                foreach (XmlElement sub in xhisto.ChildNodes)
                {
                    var _nevw = new HistoValue(sub.InnerText, last);
                    histo.Add(_nevw);
                    last = _nevw;
                }
            }
            else
            {

                if (File.Exists(Path))
                {
                    foreach (var line in File.ReadAllLines(Path))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;
                        var _nevw = new HistoValue(line, last);
                        histo.Add(_nevw);
                        last = _nevw;
                    }
                    indexDiff = histo.Count;

                    //if (histo.Count >0 )
                    //    coeffVirt = getCoeff(histo[histo.Count -1]);


                }

                if (File.Exists(PathDiff))
                {
                    var histoDiff = new List<HistoValue>();

                    foreach (var line in File.ReadAllLines(PathDiff))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;

                        var _nevw = new HistoValue(line, last);
                        histoDiff.Add(_nevw);
                        last = _nevw;

                    }

                    if (mode == dbMode.full)
                    {
                        histo.AddRange(histoDiff);
                        indexDiff = histo.Count;
                    }
                    else
                    {
                        indexDiff = histo.Count - histoDiff.Count;
                    }

                }



                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);

                if (histo.Count > 0)
                {
                    int index = histo.Count - 1;
                    decimal current = histo[index].coeff;
                    //coeffVirt = getCoeff(current);
                    bool? sens = null;

                    int nbSerie = 0;
                    // decimal delta = 0m;

                    var rr = 1;
                    //if (dcoeffp > 0)
                    //    rr = dcoeffm / dcoeffp;
                    if (rr > 0)
                    {
                        while (true)
                        {
                            index--;
                            if (index < 0)
                                break;
                            var aux = histo[index].coeff;
                            var _sens = current > aux;
                            if (sens == null)
                            {
                                sens = _sens;
                                lastAutoDirection = !_sens;

                                // delta = current - aux;
                            }


                            if (sens != _sens)
                                break;
                            current = aux;
                            nbSerie++;

                        }

                        //_nbSameDirection = nbSerie;
                        //dcoeffp = Math.Abs(delta); dcoeffm = dcoeffp * rr;

                    }
                }
            }

            checkCoeffOld();
            //if (histoDiff.Count > 0)
            //    coeffVirt = getCoeff(histo[histo.Count - 1]); 

        }

        public void checkCoeffOld()
        {
            if (coeffOldAuto)
            {
                coeffOld = (decimal)Math.Pow(coeffVirt, coeffOldAutoLevel);
            }
        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("v");
            write("name", name);
            write("mode", mode);
            write("serial", _nbSameDirection);
            write("serialBox", _nbSameDirectionBox);
            write("serialAltC", _nbAlt);
            write("serialAltH", _nbAltHisto);
            write("elastiqueC", _nbElastique);
            write("elastiqueC2", _nbElastique2);
            write("lastDelta", lastDelta);

            write("serialAlt", serialAlt);
            write("elastique", serialElastique);
            write("coeffElastique1", coeffElastique1);
            write("coeffElastique2", coeffElastique2);
            write("fdata", fdata);
            write("fdiff", fdiff);
            write("fdiffTmp", fdiffTmp);

            write("coeffVirt", coeffVirt);
            write("safe", safe);

            write("virtOnlyDisabled", virtOnlyDisabled);
            write("noAddEnd", noAddEnd);
            write("noAddAll", noAddAll);
            write("virtAlignSelected", virtAlignSelected);
            write("virtAlignPrec", virtAlignPrec);
            write("coeffVirtAuto", coeffVirtAuto);
            write("coeffVirtAdjust", coeffVirtAdjust);

            write("removeEpsilon", removeEpsilon);
            write("forceCoeffVirt", forceCoeffVirt);
            write("lissage", lissage);
            write("cumul", cumul);
            write("reSort", reSort);
            write("noAdd", noAdd);
            write("auto", auto);

            write("pas", pas);
            write("v", v);
            write("dv", dv);
            write("d0", d0);
            write("a", a);
            write("aa", aa);
            write("aepsilon", aepsilon);
            write("vepsilon", vepsilon);

            //write("dcoeffp", dcoeffp);
            //write("dcoeffm", dcoeffm);
            //write("dconvergence", dconvergence);
            //write("dconvergence0", dconvergence0);
            //write("dconvergence01", dconvergence01);
            //write("dconvdeltap", dconvdeltap);
            //write("dconvdeltam", dconvdeltam);

            //write("danticonvergence", danticonvergence);
            //write("danticonvergence0", danticonvergence0);
            //write("danticonvergence01", danticonvergence01);
            //write("danticonvdeltap", danticonvdeltap);
            //write("danticonvdeltam", danticonvdeltam);
            write("linkconv", linkconv);
            write("serialp", serialp);
            write("serialm", serialm);



            write("coeffOld", coeffOld);
            write("oldAsZero", oldAsZero);
            write("coeffOldAuto", coeffOldAuto);

            write("coeffOldAutoLevel", coeffOldAutoLevel);
            write("epsilon", epsilon);

            write("coeffStaticp", coeffStaticp);
            write("coeffStaticm", coeffStaticm);
            write("currentStaticp", currentStaticp);
            write("currentStaticm", currentStaticm);



            var sb = new StringBuilder();
            var sbDiff = new StringBuilder();




            //if (modeDiff)
            //{
            //    histoDiff = null;
            //}
            //else
            //{
            //    if (histoDiff != null)
            //    {
            //        histo.AddRange(histoDiff);
            //        histoDiff = null;
            //    }

            //    if (File.Exists(PathDiff))
            //        File.Delete(PathDiff);
            //}

            int count = histo.Count;
            HistoValue last = null;
            for (int i = 0; i < count; i++)
            {
                histo[i].write(sb);
                //var v = Math.Round(histo[i].coeff, 10);
                //var sc = v.ToString();
                //var v2 = Math.Round(1000m * histo[i].delta, 10);
                //var sc2 = v2.ToString();

                //var v3 = Math.Round(1000m * histo[i].conv, 10);
                //var sc3 = v3.ToString();

                //sb.Append(sc);
                //sb.Append("|");
                //sb.Append(sc2);
                //sb.Append("|");
                //sb.AppendLine(sc3);

                if (i >= indexDiff)
                {
                    histo[i].writeDiff(sbDiff, last);
                    //sbDiff.Append(sc);
                    //sbDiff.Append("|");
                    //sbDiff.Append(sc2);
                    //sbDiff.Append("|");
                    //sbDiff.AppendLine(sc3);
                }
                last = histo[i];
            }


            if (!string.IsNullOrEmpty(fdata))
            {
                AsyncFileWriter.Instance.post(Path, sb.ToString());
                if (mode == dbMode.diff)
                    AsyncFileWriter.Instance.post(PathDiff, sbDiff.ToString());
                else
                    AsyncFileWriter.Instance.post(PathDiffTmp, sbDiff.ToString());


                if (mode == dbMode.full && File.Exists(PathDiff))
                    File.Delete(PathDiff);
            }


            writeEnd();
        }
        /// <summary>
        /// nb consecutif dans le même sens pour info
        /// </summary>
        public int Serial { get { return _nbSameDirection; } set { _nbSameDirection = value; } }
        /// <summary>
        /// nb même sens borné pour calcul
        /// </summary>
        public int SerialBox { get { return _nbSameDirectionBox; } }
        /// <summary>
        /// nb allez-retours pour calcul
        /// </summary>
        public int Alt { get { return _nbAlt; } }
        /// <summary>
        /// nb allez/retour consécutifs pour info
        /// </summary>
        public int AltHisto { get { return _nbAltHisto; } }
        /// <summary>
        /// Position de l'élastique. Positif : tend à agrandir le delta. du à plusieurs séries dans le même sens. Négatif : tend à diminuer le delta. du à plusieurs allez-retours consécutifs
        /// </summary>
        public decimal Elastique { get { return _nbElastique; } }
        public decimal Elastique2 { get { return _nbElastique2; } }
        public decimal dv = 0;
        public decimal dx = 0m;
        //  public decimal da;
        public decimal AccelerationRapport { get { return dv / epsilon; } }
        public decimal VitesseRapport { get { return dx / epsilon; } }
        public decimal danticonvergenceMin
        {
            get
            {
                // return danticonvergence01;
                return epsilon;
                //decimal ret = 1;
                //try
                //{
                //    var aux = epsilon / v;
                //    if (aux < ret)
                //        ret = aux;
                //}
                //catch
                //{
                //}
                //return ret;
            }
        }

        private void verifMaxV()
        {
            var _dxmax = (coeffVirt - 1) * d0;
            var _dx = v * pas;
            if (_dx > _dxmax)
            {
                var vv = _dxmax / pas;
                misc.log("verifMaxV {0}->{1}", v.FormatE(4), vv.FormatE(4));
                v = vv;
            }
        }

        private void verifMaxA()
        {
            var _dxmax = (coeffVirt - 1) * d0;
           var _dx = 2 * a * pas * pas;

            if (_dx > _dxmax)
            {
                var aa = _dxmax / (2 * pas * pas);
                misc.log("verifMaxA {0}->{1}", a.FormatE(4), aa.FormatE(4));
                a = aa; 
            }
        }

        //private void verifHaut()
        //{
        //    var _dxmax = (coeffVirt - 1) * d0;
        //    var _dx = v * pas;
        //    if (_dx > _dxmax)
        //    {
        //        v = _dxmax / pas;
        //    }

        //    //_dx = vv * pas;
        //    //if (_dx > _dxmax)
        //    //{
        //    //    vv = _dxmax / pas;
        //    //}

        //    _dx = 2 * a * pas * pas;

        //    if (_dx > _dxmax)
        //    {
        //        a = _dxmax / (2 * pas * pas);
        //    }

        //}

        private void verifBas()
        {
            var dx = v * pas;
            if (dx < epsilon)
            {
                //dx = epsilon;
                v = epsilon / pas;
            }

            //dx = vv * pas;
            //if (dx < epsilon)
            //{
            //    dx = epsilon;
            //    vv = epsilon / pas;
            //}

            var dv = a * pas;
            if (dv < vepsilon)
            {
                // dv = vepsilon;
                a = vepsilon / pas;
            }

            if (coeffVirt < 1)
                coeffVirt = 1;
        }

        public void calcAuto(bool selectedByCoeff)
        {
            var _c0 = coeffVirt;
            var _v0 = v;
            // vv = v;
            var dv0 = dv;
            var _a0 = a;

            if (-_nbSameDirectionBox > serialm)
                _nbSameDirectionBox = -serialm;
            if (_nbSameDirectionBox > serialp)
                _nbSameDirectionBox = serialp;

            if (-_nbElastique > serialElastique)
                _nbElastique = -serialElastique;
            if (_nbElastique > serialElastique)
                _nbElastique = serialElastique;


            if (-_nbElastique2 > serialElastique)
                _nbElastique2 = -serialElastique;
            if (_nbElastique2 > serialElastique)
                _nbElastique2 = serialElastique;


            if (_nbAlt < 0)
                _nbAlt = 0;
            if (_nbAlt > serialAlt)
                _nbAlt = serialAlt;

            var ecart0 = System.Math.Max(System.Math.Abs(_nbElastique), System.Math.Abs(_nbElastique2));

            var last = lastAutoDirection;
            var lastDelta_ = this.lastDelta;
            lastAutoDirection = selectedByCoeff;

            if (last.HasValue)
            {
                if (last != selectedByCoeff)
                {
                    _nbSameDirection = 0;
                    _nbAlt++;
                    _nbAltHisto++;
                    if (_nbAltHisto > 1)
                    {
                        _nbElastique--;
                        _nbElastique2 -= coeffElastique2;

                        currentStaticp /= coeffStaticp;
                        if (currentStaticp < 1)
                            currentStaticp = 1;

                        currentStaticm /= coeffStaticm;
                        if (currentStaticm < 1)
                            currentStaticm = 1;
                    }
                    if (_nbSameDirectionBox > 0 && selectedByCoeff)
                        _nbSameDirectionBox--;
                    if (_nbSameDirectionBox < 0 && !selectedByCoeff)
                        _nbSameDirectionBox++;

                }
                else
                {
                    _nbAlt--;
                    _nbAltHisto = 0;
                    _nbElastique += coeffElastique1;
                    _nbElastique2++;
                    if (selectedByCoeff)
                    {
                        _nbSameDirectionBox--;
                        // _nbSameDirection--;
                    }
                    else
                    {
                        _nbSameDirectionBox++;
                        // _nbSameDirection++;
                    }
                }

                if (selectedByCoeff)
                {
                    _nbSameDirection--;
                }
                else
                {
                    _nbSameDirection++;
                }
            }

            if (!auto)
                return;

            var lastProduct = linkProduct;


            var c0 = v;
            //verifHaut();
            //verifBas();


            if (last.HasValue)
            {
                var aux = a;




                lastDelta = null;
                if (_nbAltHisto > 1)
                {
                    if (_nbAlt > serialAlt || _nbElastique < -serialElastique || _nbElastique2 < -serialElastique)
                    {
                        lastDelta = false;
                    }
                }
                else
                {
                    bool applyanti = false;

                    if (Math.Abs(_nbSameDirection) > 1)
                    {
                        if (selectedByCoeff)
                            currentStaticm *= coeffStaticm;
                        else
                            currentStaticp *= coeffStaticp;

                        if (selectedByCoeff && -_nbSameDirectionBox > serialm)
                            applyanti = true;
                        else if (!selectedByCoeff && _nbSameDirectionBox > serialp)
                            applyanti = true;
                        else if (_nbElastique > serialElastique)
                            applyanti = true;
                        else if (_nbElastique2 > serialElastique)
                            applyanti = true;
                    }
                    if (applyanti)
                        lastDelta = true;
                    else
                        lastDelta = null;
                    if (_linkconv)
                        calcConv();


                }



                bool onAugmente = lastDelta.HasValue && (lastDelta_ == null || lastDelta_ == lastDelta);
                if (onAugmente)
                {
                    a *= (1 + aa);
                    //verifHaut();
                    //verifBas();
                }
                else
                {
                    var ecart1 = System.Math.Max(System.Math.Abs(_nbElastique), System.Math.Abs(_nbElastique2));
                    if (ecart1 < ecart0)
                    {
                        a /= (1 + aa);
                        if (a < aepsilon)
                            a = aepsilon;

                        //verifHaut();
                        //verifBas();

                    }
                }

                //if (c0 == v || !onAugmente)
                //{

                //    var ecart1 = System.Math.Max(System.Math.Abs(_nbElastique), System.Math.Abs(_nbElastique2));
                //    if (ecart1 < ecart0)
                //    {
                //        a /= (1 + aa);
                //        if (a < aepsilon)
                //            a = aepsilon;

                //    }
                //}
                //else
                //{
                //    a *= (1 + aa);
                //    verifHaut();
                //    verifBas();

                //}


                // vv += pas * a;
                if (lastDelta.HasValue)
                {
                    verifMaxA(); 
                    if (false == lastDelta)
                    {
                        v -= pas * a;

                        if (_linkconv)
                            calcConv();

                    }
                    else if (true == lastDelta)
                    {
                        v += a * pas;
                    }

                    verifMaxV(); 
                    //verifHaut();
                    //verifBas();
                }



                misc.log("convergence {0:0.##}->{1:0.######}", c0, v);
                misc.log("evol convergence {0:0.######}->{1:0.######}", aux, a);
            }

            string montee = selectedByCoeff ? "down" : "up";

            verifBas(); 

            if (selectedByCoeff)
                coeffVirt -= pas * v * currentStaticm;
            else
                coeffVirt += pas * v * currentStaticp;


            //verifHaut();
            //verifBas();
            dx = Math.Abs(coeffVirt - _c0);


            dv = Math.Abs(v - _v0);
            if (dv == 0)
                dv = dv0 * (a / _a0);



            // da = Math.Abs(a - _a0);
            misc.log("{0} {1:0.### ###} {2:0.### ###}->{3:0.### ###}", montee, dx, c0, coeffVirt);
            checkCoeffOld();

            histo.Add(new HistoValue(coeffVirt, dx, a, v, dv));



        }

        public decimal CoeffT { get { return (decimal)Math.Pow(coeffVirt, safe); } }
        public decimal CoeffOld
        {
            get { return coeffOld; }
            set { coeffOld = value; checkCoeffOld(); }
        }

        public bool CoeffOldAuto
        {
            get { return coeffOldAuto; }
            set { coeffOldAuto = value; checkCoeffOld(); }
        }

        private decimal getCoeff(decimal coeffT) { return Math.Pow(coeffT, (1.0m / safe)); }

        //private void makeDelta(bool sens, decimal delta)
        //{

        //    try
        //    {
        //        decimal coeffT = coeffVirt - 1; // CoeffT;
        //        while (histo.Count >= NB_HISTO)
        //            histo.RemoveAt(0);


        //        string montee = sens ? "up" : "down";


        //        var c0 = coeffT;
        //        if (sens)
        //        {
        //            var limit = coeffT + epsilon;
        //            coeffT *= (1 + delta);
        //            if (coeffT < limit)
        //                coeffT = limit;
        //        }
        //        else
        //        {
        //            var limit = coeffT - epsilon;
        //            if (delta > 1)
        //                coeffT = 0;
        //            else
        //                coeffT *= (1 - delta);
        //            if (coeffT > limit)
        //                coeffT = limit;
        //        }

        //        if (coeffT < 0)
        //            coeffT = 0;



        //        // var coeff = getCoeff(coeffT); // (decimal)Math.Pow((double)coeffT, (1.0 / (double)safe));

        //        misc.log("{0} {1:0.######} {2:0.######}->{3:0.######}", montee, delta, c0, coeffT);

        //        dx = Math.Abs(coeffT - c0);
        //        coeffVirt = coeffT + 1; // coeff;

        //        checkCoeffOld();
        //        histo.Add(new HistoValue(coeffVirt, dx, dv, dcoeffp, danticonvergence));
        //    }
        //    catch
        //    {
        //    }



        //}

        //public HistoStat calcStat(selectedCoeff motif, int nb)
        //{
        //    var stat = new HistoStat();
        //    int _nb = 0;
        //    int count = histo.Count;
        //    for (int i = count - 1; i >= 0; i--)
        //    {
        //        var h = histo[i];

        //        // min 
        //        if (h < stat.min.absolute)
        //            stat.min.absolute = h;
        //        // calcul du plus faible qui n'a pas fonctionné

        //        if (h < stat.min.relative)
        //        {
        //            if (i + 1 < count)
        //            {
        //                var suivant = histo[i + 1];
        //                if (suivant < h)
        //                    stat.min.relative = h;
        //            }
        //            else
        //            {
        //                if (motif > selectedCoeff.noCoeff || motif == selectedCoeff.none)
        //                    stat.min.relative = h;
        //            }
        //        }

        //        //max
        //        if (h > stat.max.absolute)
        //            stat.max.absolute = h;
        //        // calcul du max qui fonctionne
        //        if (h > stat.max.relative)
        //        {
        //            if (i + 1 < count)
        //            {
        //                var suivant = histo[i + 1];
        //                if (suivant > h)
        //                    stat.max.relative = h;
        //            }
        //            else
        //            {
        //                if (motif <= selectedCoeff.noCoeff)
        //                    stat.max.relative = h;
        //            }
        //        }

        //        _nb++;
        //        if (_nb >= nb)
        //            break;
        //    }

        //    return stat;
        //}

        //private decimal calcMin(int nb, bool sens)
        //{
        //    decimal min = CoeffT;
        //    int _nb = 0;
        //    int count = histo.Count;
        //    for (int i = count - 1; i >= 0; i--)
        //    {
        //        var h = histo[i];

        //        if ((sens && h > min) || (!sens && h < min))
        //        {
        //            // calcul du max qui fonctionne
        //            if (sens)
        //            {
        //                if (i + 1 < count)
        //                {
        //                    var suivant = histo[i + 1];
        //                    if (suivant > h)
        //                        min = h;
        //                }
        //            }
        //            // calcul du plus faible qui n'a pas fonctionné
        //            else
        //                if (i + 1 < count)
        //                {
        //                    var suivant = histo[i + 1];
        //                    if (suivant < h)
        //                        min = h;
        //                }
        //        }

        //        _nb++;
        //        if (_nb >= nb)
        //            break;
        //    }
        //    return min;
        //}

        //public decimal coeffTMin(int nb)
        //{
        //    return calcMin(nb, false);
        //}

        //public decimal coeffTMax(int nb)
        //{
        //    return calcMin(nb, true);
        //}



    }
    public class CalcMedianne
    {

        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        private static int index;
        public static int Index { get { return index; } }



        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }



        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10(rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var dx = medianne - index;


            // var ret = val0 + pente * dx;


            // moyenne avec calcul de log
            var log0 = Math.Log(val0 + EPSILON_LOG);
            var log1 = Math.Log(val1 + EPSILON_LOG);
            // pente = log1 - log0;
            var log = log0 + (log1 - log0) * dx;
            return Math.Exp(log) - EPSILON_LOG;


        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}]]></content>
  </file>
</db>
