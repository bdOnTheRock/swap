<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.ordo\BackGroundTaskMgr.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using pdb.ordo.conf;
using pdb.util;
using pdb.obj;
using System.IO;
using System.Globalization;
using pdb.ordo.persistance;
using Math = System.Math; 

namespace pdb.ordo
{

    public class BackGroundTaskMgr
    {
        public const int NB_PROC = 5;
        private ThreadUtil th;
        private static ThreadUtil sTh;
        private bool async = true;
        private int nb;
        private bool classAbort;
        private double ms = 1;
        private double cms = 1;
        private double[] msProc = new double[NB_PROC];
        //private double msProc = 0;
        //private double msProc2 = 0;
        private double[] msProcStop = new double[NB_PROC];
        //private double msProcStop = 0;
        //private double msProcStop2 = 0; 
        private bool used;
        private static ConfOrdo conf = new ConfOrdo();
        private DateTime lastActivity = DateTime.Now;
        private static Logger log = Logger.getLogger("Bg");
        private static Logger logOrdo = Logger.getLogger("Ordo", log);
        private static bool playing;
        public static bool Playing
        {
            set
            {
                if (playing != value)
                {
                    log.log("changement status playing:=>{0}", value);
                    playing = value;
                }
            }
            get { return playing; }
        }
        // private static bool _abortSpecial = false; 

        #region obs
        private static List<Action> observersImportant = new List<Action>();
        public static void addObserverImportant(Action obs) { observersImportant.Add(obs); }
        private static void OnImportantTask()
        {
            foreach (Action obs in observersImportant)
                obs();
        }

        private static List<Action> observersClass = new List<Action>();
        public static void addObserverClass(Action obs) { observersClass.Add(obs); }
        private static void OnClassTask()
        {
            foreach (Action obs in observersClass)
                obs();
        }
        #endregion
        public static ConfOrdo Conf
        {
            set
            {
                conf = value;
                _ordonnancement = conf.Enable;
                taskDelayError = conf.TaskDelayError;
                gcCollect = conf.GcCollect;
                gcCollectLoop = conf.GcCollectLoop;
                gcCollectElu = conf.GcCollectElu;
                gcCollectReset = conf.GcCollectReset;
                lock (_lockS)
                {
                    foreach (BackGroundTaskMgr bg in persistList)
                    {
                        bg.classAbort = conf.getClassAbort(bg.name);
                        if (bg.name.StartsWith("scan"))
                        {
                            var p = conf.getScanPriority(scanPriority.low);
                            if (p != null)
                            {
                                bg.increasePriority(p.priority);
                                bg.coeff = p.coeff;
                            }
                        }
                        else
                        {
                            var p = conf.getPriority(bg.name);
                            if (p != null)
                            {
                                bg.increasePriority(p.priority);
                                bg.coeff = p.coeff;
                            }
                        }
                    }
                }

            }
        }
        // private bool _shutdown = true;
        //private int nbTh;
        //   private List<IBgtask> tasks = new List<IBgtask>(); 

        /// <summary>
        /// Empiler sans dépiler
        /// </summary>
        private bool _pause = true;
        private string name;
        //  public string Name { get { return name; } }

        private static bool _ordonnancement;
        public static bool Ordonnancement
        {
            //set
            //{
            //    _ordonnancement = value;
            //}
            get { return _ordonnancement; }
        }
        private int priority = 0;
        private float coeff = 1f;
        private bool persistent;

        private int Priority
        {
            set
            {
                //if (value != priority)
                //{
                //    log.logNoDate("+++++++++++++++++++++++++++++++++");
                //    log.log("{0} Changement de priorité de {1} à {2}", this, priority, value);
                //if (value == 0 && name != "Classement")
                //{
                //    int toto = 0; 
                //}
                priority = value;
                //}
            }
        }


        private void increasePriority(int p)
        {
            if (p == 0)
                return;
            if (p == int.MaxValue)
                return;
            if (p > priority)
                return;
            priority = p;
        }
        public void makePersistent() { persistent = true; }


        private Logger logger;
        private static PersistMgr persistMgr;
        static BackGroundTaskMgr()
        {
            try
            {
                persistMgr = new PersistMgr("..\\ordo.txt");
                var list = persistMgr.Deserialise();
                foreach (var p in list)
                {
                    int pr = 123456;
                    if (p.ID.Equals("Classement"))
                        pr = 0;
                    var bg = getMgr(p.ID, pr, false, true);
                    bg.msProc = p.msProc;
                    bg.ms = p.ms;

                    bg.msProcStop = p.msProcStop;

                }
            }
            catch (Exception ex)
            {
                log.log("impossible de récupérer la persistance " + ex.ToString());
                throw;
            }
        }
        public static void recordMsProc()
        {
            Console.WriteLine("début recordMsProc");
            var list = new List<PersistTaskMgr>();
            double[] total = new double[NB_PROC];
            double[] totalStop = new double[NB_PROC];
            lock (_lockS)
            {

                foreach (BackGroundTaskMgr bg in persistList)
                {
                    var val = calc0(bg);
                    var p = new PersistTaskMgr(bg.name, bg.ms, bg.msProc, bg.msProcStop, bg.nb, val);
                    for (int i = 0; i < BackGroundTaskMgr.NB_PROC; i++)
                    {
                        total[i] += bg.msProc[i];
                        totalStop[i] += bg.msProcStop[i];
                    }

                    list.Add(p);
                }
            }
            PersistTaskMgr.Total = total;

            PersistTaskMgr.TotalStop = totalStop;

            persistMgr.Serialize(list);
            Console.WriteLine("fin recordMsProc");
        }
        private BackGroundTaskMgr(string name, int priority, bool large, bool fromPersist)
        {
            ms = 1;
            msProc[0] = conf.Proc.ProcIni;
            if (conf.Duration >= 0)
            {
                ms = conf.Duration;
                // msProc = ms; 
            }
            this.name = name;
            string _path = name;
            bool foundSlash = false;
            char[] chars = name.ToCharArray();
            int count = chars.GetLength(0);
            var sb = new StringBuilder();

            for (int i = 0; i < count; i++)
            {
                char c = chars[i];
                if (Path.DirectorySeparatorChar == c)
                    foundSlash = true;
                if (c == ' ' && !foundSlash)
                {
                    sb = new StringBuilder();
                }
                else
                    sb.Append(c);
            }
            _path = sb.ToString();


            this.logger = Logger.getLogger(_path, log);
            this.large = large;
            this.priority = priority;
            list.Add(this);
            if (!large)
            {
                lock (_lockS)
                {
                    persistList.Add(this);
                    if (!fromPersist)
                        ordoList.Add(this);
                }
            }

        }
        public bool large;

        public static string Display()
        {
            var sb = new StringBuilder();
            Display(sb);
            return sb.ToString();
        }

        public static void Display(ITextWriter sb)
        {
            if (sAbort)
            {
                sb.Append(" Abort");
            }

            if (sTh != null)
            {
                sb.Append(" sTh=");
                sb.Append(sTh.State.ToString());

            }

            if (elu != null)
            {
                sb.Append(" elu=");
                sb.Append(elu.name);
            }

            sb.AppendLine();

            foreach (BackGroundTaskMgr mgr in new List<BackGroundTaskMgr>(list))
            {
                mgr.display(sb);
                sb.AppendLine();
            }
        }

        public void display(ITextWriter sb)
        {
            sb.Append(name);
            sb.Append(" nb="); sb.Append(nb);
            if (_abort)
                sb.Append(" abort");
            sb.Append(" persistent="); ; sb.Append(persistent);
            sb.Append(" priority="); sb.Append(priority);
            if (th != null)
            {
                sb.Append(" th=");

                sb.Append(th.Name);
                sb.Append(",");
                sb.Append(th.State.ToString());

            }

            if (first != null)
            {
                sb.Append(" first=");
                sb.Append(first.task.Desc);
            }

            if (last != null)
            {
                sb.Append(" last=");
                sb.Append(last.task.Desc);
            }


        }

        public void displayElts(ITextWriter sb)
        {
            try
            {
                sb.Append(" nb="); sb.Append(nb);
                //var current = first;

                //while (current != null)
                //{
                //    sb.AppendLine(current.task.ToString());
                //    current = current.Next;
                //}
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        private static List<BackGroundTaskMgr> list = new List<BackGroundTaskMgr>();
        private static List<BackGroundTaskMgr> ordoList = new List<BackGroundTaskMgr>();
        private static List<BackGroundTaskMgr> persistList = new List<BackGroundTaskMgr>();
        public static int taskDelayError = 100;
        public static int TaskDelayError { set { taskDelayError = value; } }
        private static bool gcCollect;
        private static bool gcCollectLoop;
        private static bool gcCollectElu;
        private static bool gcCollectReset;
        public static void End()
        {
            List<BackGroundTaskMgr> aux = null;
            lock (_lockS)
            {
                aux = new List<BackGroundTaskMgr>(list);
                log.log(Display());
            }
            foreach (BackGroundTaskMgr mgr in aux)
            {
                while (!mgr.IsEnd)
                    Thread.Sleep(30);
            }

            lock (_lockS)
            {
                aux = new List<BackGroundTaskMgr>(list);
                log.log(Display());
            }

            foreach (BackGroundTaskMgr mgr in aux)
            {
                while (!mgr.IsEnd)
                    Thread.Sleep(30);
            }

        }

        public static void AbortSpecial()
        {

            sAbortSpecial = true;
            log.log("-----------------------------------------------");
            log.log("Abort Special");
            List<BackGroundTaskMgr> _list = null;

            lock (_lockS)
            {
                _list = new List<BackGroundTaskMgr>(ordoList);
            }

            foreach (BackGroundTaskMgr mgr in _list)
            {
                if (mgr.classAbort)
                    mgr.reset();
            }


            log.log("fin Abort Special");
            log.log("-----------------------------------------------");

        }


        public static void PauseSpecial()
        {
            log.log("-----------------------------------------------");
            log.log("Pause Special");
            List<BackGroundTaskMgr> _list = null;

            lock (_lockS)
            {
                _list = new List<BackGroundTaskMgr>(ordoList);
            }

            foreach (BackGroundTaskMgr mgr in _list)
            {
                if (mgr.classAbort)
                    mgr.pause();
            }


            log.log("fin Pause Special");
            log.log("-----------------------------------------------");

        }
        private static bool sPauseKeyBoard;
        public static void PlayPause()
        {
            lock (_lockS)
                sPauseKeyBoard = !sPauseKeyBoard;
        }
        public static bool PauseKeyBoard { get { return sPauseKeyBoard; } }

        public static void Reset()
        {
            List<BackGroundTaskMgr> _list = null;

            lock (_lockS)
            {
                _list = new List<BackGroundTaskMgr>(ordoList);


            }

            //  log.log(Display());
            autoStart = false;
            if (_ordonnancement)
                sReset();




            foreach (BackGroundTaskMgr mgr in _list)
            {

                mgr.reset();
            }

            //   log.log(Display());

            if (gcCollect && gcCollectReset)
                misc.gcCollect("Reset");

        }
        private static bool autoStart;
        public static void Start()
        {
            lock (_lockS)
            {
                sAbortSpecial = false;
                autoStart = true;
                sPause = false;
                sAbort = false;

                foreach (BackGroundTaskMgr mgr in list)
                    mgr.start();
            }
        }

        public static void Pause()
        {
            lock (_lockS)
            {
                sPause = true;
                foreach (BackGroundTaskMgr mgr in list)
                    mgr.pause();
            }
        }

        private static volatile object _lockS = new object();
        public static BackGroundTaskMgr getMgr(string name, int priority)
        {
            return getMgr(name, priority, false, false);
        }

        public static BackGroundTaskMgr getMgrlarge(string name)
        {
            return getMgr(name, 0, true, false);
        }

        public static BackGroundTaskMgr getMgr(string name, int priority, bool large, bool fromPersist)
        {
            lock (_lockS)
            {
                var found = list.Find(bg => bg.name == name);
                if (found == null)
                {
                    found = new BackGroundTaskMgr(name, priority, large, fromPersist);
                    found.classAbort = conf.getClassAbort(name);
                    if (!large && !fromPersist)
                    {
                        PriorityCoeff p = null;
                        if (!name.StartsWith("scan"))
                            p = conf.getPriority(name);
                        else
                            p = conf.getScanPriority(scanPriority.low);
                        if (p != null)
                        {
                            found.priority = p.priority;
                            found.coeff = p.coeff;
                        }
                    }
                }
                if (sAbortSpecial && found.classAbort)
                    found._abort = true;
                else if (autoStart) found._pause = false;

                return found;
            }
        }

        public static void checkScanPriority(BackGroundTaskMgr bg, scanPriority prior)
        {
            if (bg == null)
            {
                return;
                // throw new NullReferenceException("checkScanPriority"); 
            }
            var p = conf.getScanPriority(prior);
            bg.Priority = p.priority;
            bg.coeff = p.coeff;

        }

        public static void increaseScanPriority(BackGroundTaskMgr bg, scanPriority prior)
        {
            if (bg == null)
            {
                //  throw new NullReferenceException("checkScanPriority"); 
                return;
            }
            var p = conf.getScanPriority(prior);

            int newp = p.priority;
            float coeff = p.coeff;
            if (newp < bg.priority)
                bg.Priority = newp;
            if (coeff < bg.coeff)
                bg.coeff = coeff;
        }

        public static void increaseScanPriority(BackGroundTaskMgr bg, int priority)
        {
            if (bg == null)
            {
                //  throw new NullReferenceException("checkScanPriority"); 
                return;
            }
            //   var p = conf.getScanPriority(prior);
            if (priority < 0 || priority == int.MaxValue)
                return;

            if (priority < bg.priority)
                bg.priority = priority;

        }

        public static List<BackGroundTaskMgr> findMgr(string startName)
        {
            lock (_lockS)
            {
                var found = list.FindAll(bg => bg.name.ToLower().StartsWith(startName.ToLower()));

                return found;
            }
        }

        public static BackGroundTaskMgr FindMgr(string name)
        {

            var found = list.Find(bg => bg.name.Equals(name));
            return found;

        }

        public override string ToString()
        {
            return name;
        }

        public bool Async { set { async = value; } }
        private volatile object _lock = new object();

      //  private static bool _singleThread;
    //    public static bool SingleThread { set { _singleThread = value; } }
        private LinkedTask first;
        private LinkedTask last;
        private IBgTask current;

        //private bool _end;
        private bool _abort;

        public bool Stopped
        {
            get
            {
                if (_ordonnancement)
                {
                    if (sTh == null)
                    {
                        lock (_lockS)
                        {
                            if (sTh == null)
                                return true;
                        }
                    }
                    return false;
                }
                else
                    return th == null;
            }
        }

        //private bool isEnded;
        public bool IsEnd
        {
            get
            {
                if (_ordonnancement)
                {
                    if (nextTry > DateTime.MinValue)
                        return false;
                    if (first != null)
                        return false;
                    if (nb > 0)
                        return false;
                    lock (_lockS)
                    {
                        if (first == null && current == null && nextTry == DateTime.MinValue && nb == 0)
                            return true;
                        return false;
                    }

                }

                else
                    return th == null && nb == 0;
            }
        }

        public static bool ConfirmEnd(int msWait, int p)
        {
          //  int p = conf.getScanPriority(scanPriority.classement).priority;
            foreach (BackGroundTaskMgr bg in new List<BackGroundTaskMgr>(ordoList))
            {
                if (bg.priority <= p)
                {
                    if (!bg.confirmEnd(msWait))
                        return false;
                }
            }
            return true;
        }

        public static bool ConfirmEnd(int p)
        {
            var ms = (int) (1000 * conf.ConfirmEnd);
            return ConfirmEnd(ms, p); 
        }

        public bool confirmEnd(int msWait)
        {
            return IsEnd && DateTime.Now.AddMilliseconds(-msWait) > lastActivity;
        }

        //public bool Contains(string desc)
        //{
        //    var current = first;
        //    while (current != null)
        //    {
        //        if (current.task.Desc.Contains(desc))
        //            return true;
        //        current = current.Next;
        //    }
        //    return false;

        //}



        public void Abort()
        {
            if (persistent)
                return;
            log.log("{0}==> abort", this);
            _abort = true;
            reset();
        }

        public void start()
        {
            _pause = false;
            _abort = false;
            start_();
        }

        public void pause()
        {
            _pause = true;
        }

        private void start_()
        {
            try
            {
                if (_abort && !persistent)
                {
                   // log.log("start non effectué car abort");
                    return;
                }



                if (_pause && !persistent)
                    return;
                if (async && (large || !_ordonnancement))
                {
                    if (th != null)
                        return;
                    lock (_lock)
                    {
                        lastActivity = DateTime.MaxValue;
                        if (th != null)
                            return;

                        th = new ThreadUtil(loop, name);
                        _abort = false;

                        th.Start();
                    }
                }
                else if (_ordonnancement)
                {
                    if (sAbort || sPause || (sAbortSpecial && this.classAbort))
                    {
                        lock (_lockS)
                        {
                            if (sAbort || sPause || (sAbortSpecial && this.classAbort))
                            {
                              //  log.log("::::::::::::: {0} pas possible de démarrer sAbort {1} sPause {2} sAbortSpecial {3}", name, sAbort, sPause, sAbortSpecial);
                                return;
                            }
                        }
                    }

                    if (sTh != null)
                        return;
                    lock (_lockS)
                    {

                        if (sTh != null)
                            return;

                        if (sAbort || sPause || (sAbortSpecial && this.classAbort))
                            return;

                        sTh = new ThreadUtil(sLoop, "Bg");
                        sTh.Start();
                    }
                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }



        private const int NB = 1000 * 10000;
        public void add(IBgTask task)
        {
            add_(task, true);
        }

        public void addAtFirst(IBgTask task)
        {
            add_(task, true, false);
        }

        public void reset()
        {
            try
            {
                if (persistent)
                {
                    //  checkScanPriority(this, scanPriority.low);
                    return;
                }
                lock (_lock)
                {
                    log.log("reset " + name);
                    _pause = true;
                    _abort = true;
                    //_end = false;
                    //isEnded = false; 
                    if (current != null)
                        current.abort();

                    //var _current = first;

                    //while (_current != null)
                    //{
                    //    _current.task.abort();
                    //    var aux = _current.Next;
                    //    _current.Next = null;
                    //    _current = aux;
                    //}

                    first = null;
                    last = null;
                    nb = 0;

                }

                DateTime dt = DateTime.Now.AddSeconds(30);
                while (th != null && DateTime.Now < dt)
                    Thread.Sleep(30);
                if (DateTime.Now > dt)
                {
                    log.log("abort attente reset {0}", name);
                    try
                    {
                        if (th != null)
                            th.Abort();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    th = null;
                }

                lock (_lock)
                {

                    first = null;
                    last = null;
                    _abort = false;
                    _pause = false;
                    nb = 0;
                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
            if (gcCollect && gcCollectReset)
                misc.gcCollect("reset");
        }

        private static void sReset()
        {
            try
            {
                lock (_lockS)
                {
                    log.log("reset ordonnancement");
                    sPause = true;
                    sAbort = true;


                }



                DateTime dt = DateTime.Now.AddSeconds(30);
                while (sTh != null && DateTime.Now < dt)
                {
                    sAbort = true;
                    sPause = true;
                    Thread.Sleep(30);
                }
                if (DateTime.Now > dt)
                {
                    log.log("abort attente reset Bg");
                    try
                    {
                        if (sTh != null)
                            sTh.Abort();

                    }
                    catch (Exception e)
                    {
                        log.log(e.ToString());
                    }
                    sTh = null;
                }

                //lock (_lockS)
                //{

                //    sAbort = false;
                //    sPause = false;

                //}
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }



        private void add_(IBgTask task, bool withLimit)
        {
            add_(task, withLimit, true);
        }

        private void add_(IBgTask task, bool withLimit, bool atLast)
        {
            if (!used)
            {
                lock (_lockS)
                {
                    if (!ordoList.Contains(this))
                        ordoList.Add(this);
                }
                used = true;
            }

            try
            {
                //   log.log("add {0} {1} {2} {3}", name, nb, task, withLimit);  
                while (withLimit && nb > NB)
                    Thread.Sleep(30);
                object synchro = _lock;
                if (_ordonnancement && !large)
                    synchro = _lockS;


                //   log.log("add OK {0} {1} {2} {3}", name, nb, task, withLimit);  
                if (async)
                {
                    if (_abort && !persistent)
                    {
                        // log.log("tâche non ajoutée car abort " + task.Desc);
                        return;
                    }
                    if (task.Try >= NB)
                    {
                        log.log("{0} tache abandonnée après {1} essais", task, NB);
                        return;
                    }

                    lastActivity = DateTime.MaxValue;

                    var ll = new LinkedTask(task);
                    lock (synchro)
                    {
                        if (_abort && !persistent)
                        {
                            //    log.log("tâche non ajoutée car abort " + task.Desc);
                            return;
                        }

                        start_();
                        if (atLast)
                        {
                            if (last != null)
                            {
                                last.Next = ll;
                            }

                            last = ll;

                            if (first == null)
                                first = last;
                        }
                        else
                        {
                            var f = first;
                            ll.Next = first;
                            first = ll;

                            if (last == null)
                                last = first;
                        }

                        nb++;
                    }

                }
                else
                    task.exec();

            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        private DateTime lastExec;
        private void loop()
        {
            try
            {

                while (!_abort && !_pause)
                {
                    Thread.Sleep(30);

                    lock (_lock)
                    {
                        if (_abort) return;
                        if (first == null)
                        {
                            return;
                        }
                        var aux = first;
                        current = first.task;
                        first = first.Next;
                        aux.Next = null;
                        if (first == null)
                            last = null;
                        if (!large)
                            log.log("{0} {1}", nb, current);
                        nb--;

                    }

                    try
                    {
                        //if (_singleThread && !large)
                        //    Locker.Enter();

                        if (_abort) return;
                        lastExec = DateTime.Now;
                        current.exec();
                    }
                    catch (Exception ex)
                    {
                        log.log("erreur task {0} {1}", current, ex.ToString());
                    }
                    finally
                    {
                        //if (_singleThread && !large)
                        //    Locker.Release();
                    }


                    if (current.Abort)
                    {
                        log.log("{0} tâche interrompue ", name);
                        th = null;
                        return;
                    }

                    if (!current.Success)
                    {
                        lock (_lock)
                        {
                            if (_abort) return;
                        }
                        current.Try++;
                        if (taskDelayError >= 0)
                            Thread.Sleep(taskDelayError * current.Try);
                        add_(current, false, true);

                    }

                    lock (_lock)
                    {
                        current = null;
                    }



                }
            }
            catch (Exception e)
            {
                log.log(this.name + " loop " + e.ToString());
            }
            finally
            {
                lastActivity = DateTime.Now;
                th = null;
                nb = 0;
                if (gcCollectLoop)
                    misc.gcCollect("end loop");

            }
        }


        private static bool sPause;
        private static bool sAbort;
        private static bool sAbortSpecial;
        private static BackGroundTaskMgr elu = null;

        private static void decrementCms(BackGroundTaskMgr bg)
        {
            if (bg == null)
                return;
            // log.log("decrement {0} {1}", bg, bg.cms); 
            if (bg.cms <= 1) // || conf.Duration < 0)
                return;
            var nt = bg.cms / conf.Proc.Cms;
            if (nt < 1)
                nt = 1;
            bg.cms = nt;
        }

        private static void incrementCms(BackGroundTaskMgr bg)
        {
            if (bg == null)
                return;
            if (conf.Proc.Cms == 1)
                return;
            //  log.log("increment {0} {1}", bg, bg.cms); 
            bg.cms *= conf.Proc.Cms;
        }

        private static double calcP(BackGroundTaskMgr bg, double calc0)
        {
            if (conf.Duration < 0)
                return calc0;
            else
                return calc0 * bg.cms;
        }

        private static double calcVal(BackGroundTaskMgr bg)
        {
            double[] t = new double[NB_PROC];


            for (int i = 0; i < NB_PROC; i++)
            {
                if (playing)
                    t[i] = bg.msProc[i];
                else
                    t[i] = bg.msProcStop[i];
            }


            var _conf = conf.Proc;
            double duration1 = _conf.Duration[0];
            double duration2 = _conf.Duration[1];
            if (duration1 <= 0)
            {
                if (duration2 <= 0)
                {
                    return 1;
                }
                return calc1_(t[1]);
            }
            if (duration2 <= 0)
                return calc1_(t[0]);

            for (int i = 0; i < NB_PROC; i++)
            {
                t[i] = calc1_(t[i]);
            }

            var p = _conf.Proportion;
            switch (_conf.Mode)
            {
                case procMode.max:
                    double max = 0;
                    for (int i = 0; i < NB_PROC; i++)
                    {
                        if (t[i] > max)
                            max = t[i];
                    }
                    return max;
                case procMode.min:
                    double min = double.MaxValue;
                    for (int i = 0; i < NB_PROC; i++)
                    {
                        if (t[i] < min)
                            min = t[i];
                    }
                    return min;
                // case procMode.moy: return p * t[0] + (1 - p) * t[1];
                case procMode.somme:
                    double tot = 0;
                    for (int i = 0; i < NB_PROC; i++)
                        tot += p[i] * t[i];
                    return tot;
                case procMode.produit:
                    double prod = 1;
                    for (int i = 0; i < NB_PROC; i++)
                        prod *= Math.Pow(t[i], p[i]);
                    return prod;
                //case procMode.produitM:
                //    return Math.Pow(t[0], p) * Math.Pow(t[1], 1 - p);
            }

            return 1;

        }

        //public static double calcVal(BackGroundTaskMgr bg)
        //{
        //    return calc1_(calcVal_(bg)); 
        //}

        private static double calc0(BackGroundTaskMgr bg)
        {
            return bg.nb * bg.coeff * calcVal(bg);
        }


        private static double calc1(BackGroundTaskMgr bg)
        {
            return bg.nb * bg.coeff * bg.cms * calcVal(bg);
        }

        private static double calc1_(double msProc)
        {
            return -Math.Log(1 - msProc); // msProc / (1 - msProc);
        }
        private confrontationStatus confrontationState;



        private static BackGroundTaskMgr selection(DateTime now, bool withCms)
        {
            BackGroundTaskMgr _elu = BackGroundTaskMgr.elu;
            if (_elu != null && _elu.confrontationState == confrontationStatus.none)
                _elu = null;
            double elut = -1;
            //  bool compet = false;
            foreach (BackGroundTaskMgr bg in ordoList)
            {
                //  logOrdo.log(string.Format("{0} nb:{1} pr:{2} pau:{3} ca:{4} ab:{5} ", bg.name, bg.nb, bg.priority, bg.pause, bg.classAbort, bg._abort)); 
                if (bg.confrontationState == confrontationStatus.none)
                    continue;


                if (_elu == null)
                {
                    _elu = bg; continue;
                }

                if (_elu == bg)
                    continue;

                if (bg.priority < _elu.priority)
                {
                    _elu = bg;
                    elut = -1;
                    continue;
                }

                if (bg.priority > _elu.priority)
                    continue;

                bg.confrontationState = confrontationStatus.enCompet;
                double bgt = withCms ? calc1(bg) : calc0(bg);
                if (elut == -1)
                    elut = withCms ? calc1(_elu) : calc0(_elu);

                if (bgt < elut)
                {
                    _elu = bg;
                    elut = bgt;
                    continue;

                }
                if (bgt > elut)
                {
                    _elu.confrontationState = confrontationStatus.enCompet;
                    continue;
                }


                if (bg.lastExec > _elu.lastExec)
                {
                    _elu = bg;
                    elut = bgt;
                }

            }

            return _elu;
        }
        //private static void confrontation(BackGroundTaskMgr bg, BackGroundTaskMgr elu, bool withCms)
        //{
        //    if (elu == null)
        //    {
        //        elu = bg; return;
        //    }

        //    if (elu == bg)
        //        return;
        //    if (bg.priority < elu.priority)
        //    {
        //        elu = bg; return;
        //    }

        //    if (bg.priority > elu.priority)
        //        return;
        //    double bgt = withCms ? calc1(bg) : calc0(bg);
        //    double elut = withCms ? calc1(_el) : calc0(bg);

        //    var elut = calcP(elu, elut0);
        //    if (bgt < elut)
        //    {
        //        if (bgt0 >= elut0)
        //            decrementCms(elu);
        //        else
        //            incrementCms(bg);
        //        elu.cms /= conf.Cms;
        //        elu = bg;
        //        return;

        //    }
        //    if (bgt > elut)
        //    {
        //        if (bgt0 <= elut0)
        //            decrementCms(bg);
        //        else
        //            incrementCms(elu);
        //        return;
        //    }
        //    if (bg.lastExec > elu.lastExec)
        //    {
        //        elu = bg;
        //    }

        //}

        private static double calcMs(int nbStat, double ms, double ts)
        {
            return (ms * (nbStat - 1) + ts) / (double)nbStat;
        }
        const double EPSILON = 0.0000000000001;
        private static double calcMsProc(double ms, double ts, double pente, bool actif)
        {
            //pente = ts / nbstat ou si ts est grand ts / (nbStat + ts)
            // si on a rien fait : perte = ts / nbstat  (proportion)
            // ex : ms0 = 0.2 ts =300 nbstat = 1000
            //perte = 0.3 
            // ms1 =0.2 *0.7 = 0.14

            // si c'est moi qui bosse : asymptote dans l'autre sens : 
            //dalta = 0.8 augmentation = 0.8 * 0.3 = 0.24 ms1 = 0.44

            var delta = actif ? 1 - ms : -ms;

            var ret = ms + delta  * (1 - Math.Exp (-pente)); //* pente;
            if (1 - ret < EPSILON)
                ret = 1 - EPSILON;
            if (ret < 0)
                ret = 0;

            return ret;
            //  return (ms * (nbStat - 1) + ts) / (double)nbStat;

        }

        private static void sLoop()
        {
            var chrono = BgTask.chrono;
            try
            {

                while (!sAbort)
                {
                    Thread.Sleep(30);
                    //  elu = null;
                    DateTime now = DateTime.Now;
                    if (sAbort) return;
                    if (sPauseKeyBoard)
                        continue;
                    if (sPause)
                        continue; 
                    string strElu0 = "";
                    lock (_lockS)
                    {
                        if (sAbort) return;
                        //election
                        if (elu != null && elu.first == null)
                            elu = null;

                        foreach (BackGroundTaskMgr bg in ordoList)
                        {
                            bg.confrontationState = confrontationStatus.none;
                            //  logOrdo.log(string.Format("{0} nb:{1} pr:{2} pau:{3} ca:{4} ab:{5} ", bg.name, bg.nb, bg.priority, bg.pause, bg.classAbort, bg._abort)); 
                            if (bg._abort)
                                continue;
                            if (bg._pause)
                                continue; 
                            var ll = bg.first;
                            if (ll == null)
                                continue;
                            if (bg.nextTry > now)
                                continue;
                            if (bg.large)
                                continue;
                            bg.confrontationState = confrontationStatus.enCourse;


                        }

                        var elu0 = selection(now, false);
                        if (conf.Duration >= 0 && conf.Proc.Cms > 1)
                        {
                            elu = selection(now, true);

                            if (elu != null && elu.confrontationState > confrontationStatus.enCourse)
                            {

                                if (elu == elu0)
                                {
                                    // gagnerait de toutes façon  malgré le handicap 
                                    incrementCms(elu);
                                }
                                else
                                {
                                    // gagne à l'aide du handicap
                                    //if (elu0.cms > 1)
                                    decrementCms(elu0);
                                    //else
                                    //    incrementCms(elu);
                                    strElu0 = string.Format(" ({0}->{1,4:0.###}", elu0, elu0.cms);
                                }
                            }
                        }
                        else
                            elu = elu0;



                        if (elu == null)
                            continue;


                        var aux = elu.first;
                        if (aux != null)
                        {
                            elu.current = elu.first.task;
                            elu.first = elu.first.Next;
                        }
                        aux.Next = null;
                        if (elu.first == null)
                        {
                            elu.last = null;

                        }

                        if (sAbortSpecial && elu.classAbort)
                        {
                            elu.nb--;
                            continue;
                        }


                        // log.log("[{0}] {1} {2} {3}", elu.name, elu.priority, elu.nb, elu.current);
                        // var logger = elu.logger, Logger.getLogger(@"Task\" + elu.name, log);
                        //  var sb = new StringBuilder(); 
                        //  elu.logger.log("[{0}] {1} {2} {3}", elu.name, elu.priority, elu.nb, elu.current);

                        elu.nb--;
                    }

                    var current = elu.current;

                    try
                    {

                        if (sAbort) return;
                        DateTime _now = DateTime.Now;
                        chrono.reset(elu.name);
                        current.exec();
                        chrono.end();
                        var ts = chrono.Total.TotalMilliseconds;

                        lock (_lockS)
                        {
                            var ts0 = ts;

                            if (elu == null)
                                continue;
                            //   var min = conf.Duration;
                            string moy = "";
                            string cms = "";
                            string moyProc = "";
                            // string moyProc2 = ""; 
                            string valProc = "";
                            double val0 = 0;

                            double val1 = 0;
                            var confProc = conf.Proc;
                            var tsMin = confProc.TsMin;
                            if (ts < tsMin)
                                ts = tsMin;
                            var nbStat = confProc.NbDuration;
                            var nbProcDuration = confProc.Duration;
                            if (nbStat >= 0)
                            {
                                for (int i = NB_PROC - 1; i >= 0; i--)
                                    moyProc += string.Format(CultureInfo.InvariantCulture, " {0,6:##.000}", (100 * (playing ? elu.msProc[i] : elu.msProcStop[i])));
                                moyProc += string.Format(CultureInfo.InvariantCulture, " {0,6:##.000}", (100 * calcVal(elu)));
                                val0 = (elu.nb + 1) * elu.coeff * calcVal(elu);
                                double[] pente = new double[NB_PROC];

                                for (int i = 0; i < NB_PROC; i++)
                                {
                                    var _pente = nbProcDuration[i];
                                    if (_pente > 0)
                                        pente[i] = ts / _pente;
                                    else
                                        pente[i] = 0;
                                }



                                elu.ms = calcMs(nbStat, elu.ms, ts0); // (elu.ms * (nbStat - 1) + ts) / (double)nbStat;
                                moy = string.Format(" {0,4:####}", elu.ms);
                                var calcProcMin = conf.CalcProcMin;
                                if (elu.confrontationState >= calcProcMin || elu.msProc[0] < EPSILON)
                                {
                                    for (int i = 0; i < NB_PROC; i++)
                                    {
                                        if (playing)
                                        {

                                            elu.msProc[i] = calcMsProc(elu.msProc[i], ts, pente[i], true);
                                        }
                                        else
                                        {

                                            elu.msProcStop[i] = calcMsProc(elu.msProcStop[i], ts, pente[i], true);
                                        }
                                    }
                                    //  moyProc += string.Format(CultureInfo.InvariantCulture, " {0,6:##.000}", (100 * elu.msProc));
                                    val1 = calc1(elu);
                                    valProc = string.Format(CultureInfo.InvariantCulture, " {0,8:###.000} {1,8:###.000}", val0, val1);
                                }

                                int nbEnCompet = 2;
                                if (calcProcMin > confrontationStatus.none)
                                {
                                    nbEnCompet = 0;
                                    foreach (BackGroundTaskMgr bg in ordoList)
                                    {
                                        if (bg.used && bg.confrontationState >= calcProcMin)
                                            nbEnCompet++;
                                    }
                                }

                                if (nbEnCompet > 1)
                                {
                                    if (conf.CalcProcDiv)
                                    {
                                        for (int i = 0; i < NB_PROC; i++)
                                        {
                                            pente[i] /= ((double)nbEnCompet - 1);
                                        }
                                    }
                                    foreach (BackGroundTaskMgr bg in persistList)
                                    {
                                        if (bg == elu)
                                            continue;
                                        if (calcProcMin == confrontationStatus.none || (bg.used && bg.confrontationState >= calcProcMin))
                                        {
                                            for (int i = 0; i < NB_PROC; i++)
                                            {
                                                if (playing)
                                                {
                                                    bg.msProc[i] = calcMsProc(bg.msProc[i], ts, pente[i], false);
                                                }
                                                else
                                                {
                                                    bg.msProcStop[i] = calcMsProc(bg.msProcStop[i], ts, pente[i], false);
                                                }
                                            }
                                        }
                                    }
                                }



                                if (confProc.Cms != 1)
                                {
                                    cms = string.Format(" {0,4:0.###}", elu.cms);

                                }
                                //  elu.cms *= conf.Cms;
                            }
                            if (!current.Success)
                                ts0 *= -1;

                            var strMs = string.Format("{0,4:####}", ts0);
                            if (string.IsNullOrWhiteSpace(strMs))
                                strMs = string.Format("{0,4}", "-");
                            var chronoSeuil = conf.ChronoSeuil;
                            if (chronoSeuil >= 0)
                                strMs = string.Format(conf.FormatChrono, chrono.display(chronoSeuil, conf.FormatPhase)) + strMs;

                            //  elu.logger.log(string.Format("[{0}] {1} {2} {3,4:####}{4}{5}{6}{7}{8} {9}", elu.name, elu.priority, elu.nb + 1, ts, moy, moyProc, valProc, cms, strElu0, elu.current));
                            elu.logger.log(string.Format("{0} {1}{2}{3}{4}{5} {6,4:####} [{7}] {8} {9}",
                                                          strMs, moy, moyProc, valProc, cms, strElu0, (elu.nb + 1), elu.name, elu.priority, elu.current));

                        }
                    }
                    catch (Exception ex)
                    {
                        if (elu != null && elu.logger != null && elu.current != null)
                            //   var logger = Logger.getLogger(@"Task\" + elu.name, log);
                            elu.logger.log("erreur task {0} {1}", elu.current, ex.ToString());
                    }
                    finally
                    {

                    }


                    if (current.Abort)
                    {
                        elu.logger.log("{0} tâche interrompue ", elu.name);
                        continue;
                    }

                    bool collect = false;
                    lock (_lockS)
                    {
                        if (!current.Success)
                        {
                            if (sAbort) return;

                            current.Try++;
                            if (taskDelayError >= 0)
                            {
                                TimeSpan ts = TimeSpan.FromMilliseconds(taskDelayError * elu.current.Try);
                                elu.nextTry = DateTime.Now.Add(ts);

                            }

                            elu.add_(current, false, true);

                        }
                        else
                        {
                            elu.nextTry = DateTime.MinValue;
                            elu.lastExec = now;
                            elu.lastActivity = DateTime.Now;
                            if (elu.classAbort)
                                OnImportantTask();
                            if (elu.priority == 0)
                                OnClassTask(); 
                            if (elu.first == null)
                                collect = true;
                        }


                        elu.current = null;


                    }

                    if (collect && gcCollectElu)
                        misc.gcCollect("elu");



                }
            }
            catch (Exception e)
            {

                log.log("ordonnancement loop " + e.ToString());
            }
            finally
            {
                sTh = null;
                if (gcCollectLoop)
                    misc.gcCollect("end sloop");
            }
        }

        private DateTime nextTry;


        private class LinkedTask
        {
            public readonly IBgTask task;
            public LinkedTask Next;
            public LinkedTask(IBgTask task) { this.task = task; }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.ordo\conf\ConfOrdo.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.obj;
using pdb.util;

namespace pdb.ordo.conf
{
    public enum confrontationStatus
    {
        none,
        enCourse,
        enCompet,
        //lost,
        //lostByCms,
        //winByCms,
        //win
    }
    public class ConfOrdo
    {
        private static Logger log = Logger.getLogger("Ordo", Logger.getLogger("Bg"));
        private bool enable = true;
        private PriorityCoeff scanHigh = new PriorityCoeff(1);
        private PriorityCoeff scanLow = new PriorityCoeff(20);
        private PriorityCoeff scanMedium = new PriorityCoeff(12);
        private PriorityCoeff scanClassement = new PriorityCoeff(1);
        private string persistFile = "..\\ordo.txt";



        private confrontationStatus calcProcMin = confrontationStatus.none; public confrontationStatus CalcProcMin { get { return calcProcMin; } }
        private bool calcProcDiv; public bool CalcProcDiv { get { return calcProcDiv; } }
        private List<PriorityRule> rules = new List<PriorityRule>();

        //private bool singleThread;
        //public bool SingleThread { get { return singleThread; } }

        private int taskDelayError = 30;
        public int TaskDelayError { get { return taskDelayError; } }

        private bool gcCollect; public bool GcCollect { get { return gcCollect; } }
        private bool gcCollectLoop; public bool GcCollectLoop { get { return gcCollectLoop; } }
        private bool gcCollectElu; public bool GcCollectElu { get { return gcCollectElu; } }
        private bool gcCollectReset; public bool GcCollectReset { get { return gcCollectReset; } }
        private double chronoSeuil; public double ChronoSeuil { get { return chronoSeuil; } }
        private string formatChrono = "{0 ,-60}"; public string FormatChrono { get { return formatChrono; } }
        private string formatPhase = "{0,2}:{1,-3:#}"; public string FormatPhase { get { return formatPhase; } }
        private double confirmEnd = 3; public double ConfirmEnd { get { return confirmEnd; } }

        private double duration = 0; public double Duration { get { return duration; } }

        private ConfProc proc = new ConfProc(); internal ConfProc Proc { get { return proc; } }

        public ConfOrdo() { }

        public ConfOrdo(XmlElement node)
        {
            if (node == null)
                return;
            XMLTool xml = new XMLTool(node);

            enable = "true" == xml.getAttValue("enable");
            //  singleThread = xml.getBoolValue("singleThread");
            gcCollect = xml.getBoolValue("gcCollect");
            gcCollectLoop = xml.getBoolValue("gcCollectLoop");
            gcCollectElu = xml.getBoolValue("gcCollectElu");
            gcCollectReset = xml.getBoolValue("gcCollectReset");

            string str = xml.getAttValue("scan", "low");
            if (!string.IsNullOrEmpty(str))
                scanLow.priority = Convert.ToInt16(str);

            str = xml.getAttValue("scan", "high");
            if (!string.IsNullOrEmpty(str))
                scanHigh.priority = Convert.ToInt16(str);

            str = xml.getAttValue("scan", "medium");
            if (!string.IsNullOrEmpty(str))
                scanMedium.priority = Convert.ToInt16(str);

            str = xml.getAttValue("scan", "class");
            if (!string.IsNullOrEmpty(str))
                scanClassement.priority = Convert.ToInt16(str);

            str = xml.getNodeValue("taskDelayError");
            if (!string.IsNullOrEmpty(str))
                taskDelayError = Convert.ToInt32(str);

            str = xml.getNodeValue("duration");
            if (!string.IsNullOrEmpty(str))
                duration = Convert.ToDouble(str);

            str = xml.getNodeValue("chronoSeuil");
            if (!string.IsNullOrEmpty(str))
                chronoSeuil = Convert.ToDouble(str);

            str = xml.getNodeValue("calcProcMin");
            if (!string.IsNullOrEmpty(str))
                calcProcMin = (confrontationStatus)Enum.Parse(typeof(confrontationStatus), str, true);

            str = xml.getNodeValue("formatChrono");
            if (!string.IsNullOrEmpty(str))
                formatChrono = str;

            str = xml.getNodeValue("formatPhase");
            if (!string.IsNullOrEmpty(str))
                formatPhase = str;

            str = xml.getNodeValue("persistFile");
            if (!string.IsNullOrEmpty(str))
                persistFile = str;

            str = xml.getNodeValue("confirmEnd");
            if (!string.IsNullOrEmpty(str))
                confirmEnd = Convert.ToDouble(confirmEnd) ; 


            calcProcDiv = xml.getBoolValue("calcProcDiv");


            rules = new List<PriorityRule>();
            foreach (XmlNode sb in node.ChildNodes)
            {
                if (sb.Name == "bg")
                    rules.Add(new PriorityRule(sb as XmlElement));
            }

            var xProc = xml.NodeLookUp("proc");
            proc = new ConfProc(xProc);

        }

        public bool Enable { get { return enable; } }

        public PriorityCoeff getScanPriority(scanPriority _priority)
        {
            switch (_priority)
            {
                case scanPriority.low: return scanLow;
                case scanPriority.medium: return scanMedium;
                case scanPriority.high: return scanHigh;
                case scanPriority.classement: return scanClassement;
                default: throw new NotImplementedException();
            }
        }

        public bool getClassAbort(string name)
        {
            foreach (PriorityRule rule in rules)
            {
                bool? a = rule.getClassAbort(name);
                if (a == null)
                    continue;
                return a.Value;
            }
            //log.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            //log.log("getClassAbort::impossible de matcher le bg de nom {0}", name);
            //log.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"); 
            return false;

        }

        public PriorityCoeff getPriority(string name)
        {
            if (rules.Count > 0)
            {
                foreach (PriorityRule rule in rules)
                {
                    var p = rule.getPriority(name);
                    if (p == null)
                        continue;
                    return p;
                }
                log.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                log.log("getPriority::impossible de matcher le bg de nom {0}", name);
                log.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            }
            return null;

        }
        public override string ToString()
        {
            ITextWriter sb = new StringBuilder();
            sb.Append("enable=");
            sb.Append(enable);
            sb.Append(" low="); sb.Append(scanLow);
            sb.Append(" medium="); sb.Append(scanMedium);
            sb.Append(" high="); sb.Append(scanHigh);


            foreach (PriorityRule pr in rules)
            {
                sb.AppendLine(pr.ToString());
            }

            return sb.ToString();


        }
    }
}
]]></content>
  </file>
   <file path="\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Load;
using timeSpan = pdb.util.timeSpan;


namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    public class AutoBuilder : IComparable<AutoBuilder>//, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private int nbDown;
        private bool useForfait; 
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private DirConf source; public DirConf Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;
        private List<AutoBuilderItem> chooses = new List<AutoBuilderItem>();
        public const int STOP_MAX = 3;
        private int _stopLevel = STOP_MAX;
        // private bool 


        private List<LimitItemLoader> loaders = new List<LimitItemLoader>();
        public void buildLoaders()
        {
            loaders = new List<LimitItemLoader>();
            source.buildLoaders(loaders, this);

        }

        public void go()
        {
            var total = new timeSpan();
            var fd = new timeSpan();
            var d = new timeSpan();
            var date = new timeSpan();
            var nb = 0;

            var dict = new pdb.util.BgDictString0<TrackInfoItunes>();

            while (true)
            {
                var _total = timeSpan.MaxValue; 
                var _fd =  timeSpan.MaxValue; 
                var _d =  timeSpan.MaxValue; 
                var _date = timeSpan.MaxValue; 
                var _nb = int.MaxValue;

                foreach (LimitItemLoader loader in loaders)
                {
                    loader.checkV(this, nb, fd, d, date);
                    if (_total > loader._durationv)
                        _total = loader._durationv;
                    if (_fd > loader._fd)
                        _fd = loader._fd;
                    if (_date > loader._datev)
                        _date = loader._datev;
                    if (_nb > loader._nb)
                        _nb = loader._nb; 
                }
            }
        }
        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(DirConf source)
        {
            this.source = source;
            source.addBorderObs(this);
            source.Auto = this;
        }

        // private static bool loaded; 
        public static void getLoaders()
        {
            //if (loaded)
            //    return;
            //loaded = true;
            foreach (AutoBuilder auto in list)
                auto.buildLoaders();
        }

        public static void test()
        {
            //if (loaded)
            //    return;
            //loaded = true;
            foreach (AutoBuilder auto in list)
                auto.go();
        }

        private static AutoBuilder main;
        public static void build(XmlNode xAuto, DirConf source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        mem.dict.Add(key, desc);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                List<string> toRemove = new List<string>();
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        toRemove.Add(key);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }

                foreach (string key in toRemove)
                    mem.dict.Remove(key);
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    {
                        //if (!exist)
                        //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                        tw.Write(DateTime.Now); tw.Write(SEP);
                        tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                        tw.Write(d.ToString("0.###")); tw.Write(SEP);
                        tw.Write(org.ToString("0.###")); tw.Write(SEP);
                        tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(atomicMode); tw.Write(SEP);
                        tw.Write(state); tw.Write(SEP);
                        for (int i = 0; i < imax; i++)
                        {
                            if (i > 0)
                            {
                                tw.WriteLine();
                                for (int j = 0; j < 11; j++)
                                    tw.Write(SEP);
                            }
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].track);
                            tw.Write(SEP);
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].item);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].track);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].item);
                            tw.Write(SEP);
                        }
                        tw.WriteLine();
                    }
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
            _stopLevel = STOP_MAX;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            //bool firstWIthTb = first && Conf.BorderTb;
            //bool secondwithoutTb = !first && !Conf.BorderTb;
            //bool readXml = firstWIthTb || secondwithoutTb;

            bool readXml = first;
            FileInfo f = null;
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                if (first)
                    builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static void Init3()
        {
            foreach (AutoBuilder item in list)
            {
                item.init3();
            }
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check3();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                AutoBuilder builder = null;
                if (!started)
                {
                    started = true;
                    foreach (AutoBuilder b in list)
                        b.total = b.source.getTotalSize();
                }
                // application de la précédente modif
                builder = list[index];
                if (builder.state > builderstate.none)
                {
                    builder.makeEmpreinteNonSequence();
                    decrementIndex();
                }
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    builder = list[i];
                    bool cango = false;
                    bool _cont = false;
                    while (true)
                    {
                        if (i == index || _cont)
                        {
                            cango = builder.check();
                            index = i;
                            main = builder;
                            _cont = false;
                            break;
                        }
                        else
                            cango = builder.checkWithoutModify();
                        if (builder.state == builderstate.none)
                            _cont = true;
                        else
                            break;
                    }
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (i == index)
                    {
                        if (builder.newv != builder.org)
                        {
                            _modifFile = true;
                        }
                        else
                        {
                            //index--;
                            //if (index < 0)
                            //    index = list.Count - 1;
                        }
                    }
                    if (_modifFile)
                        break;
                }
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                    _cango = false;
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        private bool check()
        {
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.none)
                reset();
            else if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
                else
                {
                    mustUpdate = false;
                    canGo = true;
                    org = newv;
                    return true;
                }
            }
            if (Conf.AutoSequence || total < 0)
                total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
            if (state == builderstate.none)
                delta0 = delta;
            state = builderstate.enCours;
            lastd = d;
            d = 0;
            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return true;
            string attTarget = conf.type.ToString();
            var att = xml.Attributes[attTarget];
            if (att == null)
                return true;
            org = Convert.ToDouble(att.Value);
            newv = org;
            try
            {
                if (delta * delta0 < 0)
                {
                    if (atomicMode < 0)
                    {
                        atomicMode = 0;
                        //if (minMem == null)
                        //    minMem = new Memory(mem0);
                        //if (maxMem == null)
                        //    maxMem = new Memory(mem0);
                        //if (minMem.suppressions.Count == 0)
                        //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
                        //if (maxMem.ajouts.Count == 0)
                        //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
                    }
                }
                bool cancelSameConf = false;
                bool cancelNb = false;
                if (atomicMode >= 0)
                {
                    atomicMode++;
                    if (Math.Abs(dmin - delta) < EPSILON)
                        sameConfiguration++;
                    else if (Math.Abs(dmax - delta) < EPSILON)
                        sameConfiguration++;
                    else
                        sameConfiguration = 0;
                    if (sameConfiguration > conf.idem)
                        cancelSameConf = true;
                    if (atomicMode > conf.cloop)
                        cancelNb = true;
                }
                if (delta >= 0)
                {
                    if (mem0.suppressions.Count > 0)
                        minMem = new Memory(mem0);
                    if (delta < conf.write)
                        canGo = true;
                    //  lastGoodLevel = org;
                    //if (maxMem != null && minMem != null)
                    //{
                    if (atomicMode > 0)
                    {
                        if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
                        {
                            log("abandon recherche cartésienne cause idem");
                            state = builderstate.stable;
                            return true;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            state = builderstate.stable;
                            return true;
                        }
                        //if (Math.Abs(dmin - delta) < 0.01)
                        //    dminAlready = true;
                        //else
                        //    dminAlready = false;
                        if (maxMem != null && minMem != null)
                        {
                            if (minMem.suppressions.Count == maxMem.ajouts.Count)
                            {
                                bool identique = true;
                                for (int i = 0; i < minMem.suppressions.Count; i++)
                                {
                                    if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                    {
                                        identique = false;
                                        break;
                                    }
                                }
                                if (identique)
                                {
                                    if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
                                    {
                                        mustUpdate = false;
                                        log("abandon recherche cartésienne cause cycle");
                                        state = builderstate.stable;
                                        _empreinte = newEmpreinte;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    cmin = org;
                    dmin = delta;
                    // lastGoodDelta = (int)delta;
                    lastTotal = (int)total;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        //if (atomicMode > conf.cloop)
                        //{
                        //    mustUpdate = false;
                        //    log("abandon recherche cartésienne cause cloop");
                        //    state = builderstate.stable;
                        //    _empreinte = newEmpreinte;
                        //    return true;
                        //}
                        //if (dminAlready && dmaxAlready)
                        //{
                        //    mustUpdate = false;
                        //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
                        //    return true;
                        //}
                        d = 0.5 * (cmax - cmin);
                    }
                    else
                    {
                        double _d = int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmax - cmin;
                        double aux = int.MaxValue;
                        // double aux2 = int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - level.d) * level.inf;
                            if (aux > d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {

                            if (org > conf.max)
                                d = conf.max - org;
                            else
                            {
                                d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 < d)
                        //    d = aux2;

                        if (d > _d)
                            d = _d;
                    }
                }
                else if (delta < 0)
                {
                    if (mem0.ajouts.Count > 0)
                        maxMem = new Memory(mem0);
                    mustUpdate = true;
                    canGo = false;
                    //if (maxMem != null && minMem != null)
                    //{
                    //    if (atomicMode < 0)
                    //        atomicMode = 0;
                    //    atomicMode++;
                    //}
                    cmax = org;
                    dmax = delta;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        bool identique = false;
                        if (minMem != null && maxMem != null
                            && maxMem.ajouts.Count == minMem.suppressions.Count)
                        {
                            identique = true;
                            for (int i = 0; i < minMem.suppressions.Count; i++)
                            {
                                if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                {
                                    identique = false;
                                    break;
                                }
                            }
                        }
                        if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
                        {
                            log("retour derniere bonne valeur cause idem");
                            d = cmin - cmax;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            d = cmin - cmax;
                        }
                        else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
                        {
                            log("retour derniere bonne valeur cause cycle");
                            d = cmin - cmax;
                        }
                        //else if (atomicMode > conf.cloop)
                        //{                      
                        //    log("abandon recherche cartésienne cause cloop");
                        //    d = cmin - cmax;
                        //}
                        else
                            d = 0.5 * (cmin - cmax);
                    }
                    else
                    {

                        double _d = -int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmin - cmax;
                        double aux = -int.MaxValue;
                        // double aux2 = -int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - conf.delta + level.d) * level.sup;
                            if (aux < d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {
                            if (org < conf.min)
                                d = (conf.min - org);
                            else
                            {
                                d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 > d)
                        //    d = aux2;

                        if (d < _d)
                            d = _d;
                    }
                    //d = (delta - conf.delta) * conf.sup;
                    //if (org <= lastGoodLevel)
                    //{
                    //    lastGoodLevel = -1;
                    //    lastGoodDelta = -1;
                    //    lastTotal = -1;
                    //}
                }
                if (Math.Abs(d) < 0.00000001)
                {
                    mustUpdate = false;
                    // unCart();
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                //if (dejaVu)
                //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
                log("correction {0}", d);
                newv = org + d;
                if (newv <= 0)
                    newv = 0;
                if (conf.coeff > 0)
                {
                    if (newv > conf.max)
                        newv = conf.max;
                    else if (newv < conf.min)
                        newv = conf.min;
                }
                newv = Math.Round(newv, 8);
                log(" valeur {0} --> {1}", org, newv);
                att.Value = newv.ToString();
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
                string strDate = "";
                var attD = xml.Attributes["date"];
                if (attD != null)
                    strDate = attD.Value;
                bool exist = File.Exists(file);
                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void calcChoose(bool up, bool strict, bool checkSelect)
        {
            choose = null;
            double dt = double.MaxValue;
            double gap = double.MaxValue;
            // bool trou = false;
            foreach (AutoBuilderItem item in items)
            {
                item.after(up, strict, checkSelect);
                item.setTension(up, strict, checkSelect);
                if (item.Stop(_stopLevel))
                {
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }
                double aux = double.MaxValue;
                // var tension = item.Tension;
                if (conf.selectFix)
                {
                    var tension = item.Tension;
                    aux = up ? tension : -tension;
                }
                else
                    aux = item.Dt;

                if (conf.selectAbs && !conf.selectFix && aux < 0)
                    aux *= -1;



                if (item.getCauses().Count == 0)
                {
                    // trou = true;
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }

                //var _gap = Math.Abs(aux);
                //if (_gap < gap)
                //    gap = _gap;

                if (aux < dt)
                {
                    dt = aux;
                    newv = item.NewV;
                    choose = item;
                }
            }
            //if (trou && conf.gap && gap < double.MaxValue)
            //{
            //    foreach (AutoBuilderItem item in items)
            //    {
            //        if (item.Stop)
            //            continue;
            //        item.gap(up, conf.selectFix, gap);
            //    }
            //}
        }

        private bool check2()
        {
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


                //else if (choose != null)
                //    choose.makePertinent();
            }
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }

                total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                log("delta {0}", delta);

                if (_stopLevel < 0)
                {
                    log("arret cause stopLevel");
                    state = builderstate.stable;
                    return true;
                }
                if (delta * lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (choose != null && _stopLevel > 0)
                    {
                        log("retour arrière");
                        _stopLevel--;
                        choose.stop(_stopLevel);
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                    else
                    {
                        if (delta > 0)
                        {
                            // ok!
                            log("pas de retour arriere stoplevel=0");
                            state = builderstate.stable;
                            _empreinte = newEmpreinte;
                            return true;
                        }
                        else
                        {
                            _stopLevel--;
                            choose.stop(_stopLevel);
                            canGo = false;
                            mustUpdate = true;
                            return false;
                        }
                    }
                }
                lastDelta = delta;
                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            return true;
                        }
                    }
                }



                choose = null;
                if (_stopLevel >= 3 && conf.checkSelect && conf.checkStrict)
                    calcChoose(up, true, true);
                if (choose != null)
                    log("REEL - SELECT");
                else
                {
                    if (_stopLevel >= 2 && conf.checkSelect)
                        calcChoose(up, false, true);
                    if (choose != null)
                        log("VIRTUEL SELECT");
                    else
                    {
                        if (_stopLevel >= 1 && conf.checkStrict)
                            calcChoose(up, true, false);
                        if (choose != null)
                            log("REEL");
                        else
                        {
                            if (_stopLevel >= 0)
                            {
                                calcChoose(up, false, false);
                                if (choose != null)
                                    log("VIRTUEL");
                            }
                        }
                    }
                }


                if (choose == null)
                {
                    log("choose null");
                    _stopLevel--;
                    if (_stopLevel < 0)
                    {
                        state = builderstate.stable;
                        return true;
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                }

                org = choose.Org;



                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (conf.checkEvol)
                    {
                        // var nextTrack = choose.rejected(real).candidat;
                        var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
                        if (delta < size)
                        {
                            _stopLevel--;
                            // choose.stop();
                            if (conf.stopAll)
                            {
                                foreach (AutoBuilderItem item in items)
                                    item.stop(_stopLevel);
                                //state = builderstate.stable;
                                //return true;
                            }
                            else
                            {
                                choose.stop(_stopLevel);
                            }
                        }
                    }

                }
                else
                {
                }
                choose.save();
                Program.logAuto.log("===> " + choose.ToString());
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    bool exist = File.Exists(file);
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void init3()
        {
            _cause = null;


            foreach (AutoBuilderItem item in items)
                item.setTension();
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


            }

            setDelta();


        }

        public static void SetDelta()
        {
            foreach (AutoBuilder item in list)
            {
                item.setDelta();
            }
        }

        private void setDelta()
        {
            mustUpdate = false;
            canGo = false;

            total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
        }

        private bool check3()
        {
            // _modifFile = false; 

            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }



                if (_stopLevel < 0)
                {
                    log("arret cause stopLevel");
                    state = builderstate.stable;
                    return true;
                }
                var _lastDelta = lastDelta;
                lastDelta = delta;
                if (delta * _lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (delta > 0)
                    {
                        if (conf.forfaitNegatif > 0 && !useForfait)
                        {
                            useForfait = true;
                        }
                        else
                        {
                            // ok!
                            log("pas de retour arriere stoplevel=0");
                            state = builderstate.stable;
                            _empreinte = newEmpreinte;
                            useForfait = false; 
                            return true;
                        }
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        _stopLevel--;
                        foreach (AutoBuilderItem choose in chooses)
                        {
                            if (choose != null && _stopLevel > 0)
                            {
                                log("retour arrière");
                                choose.stop(_stopLevel);
                            }
                        }
                        return false;
                    }

                }

                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;

                if (up)
                    nbDown = 0;
                else
                    nbDown++; 
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    useForfait = false; 
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            useForfait = false; 
                            return true;
                        }
                    }
                }

                if (_cause == null)
                {
                    log("_cause NULL");
                    state = builderstate.stable;
                    useForfait = false;
                    return true;

                }
                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                }

                var cdv = _cause.causes;
                chooses.Clear();

                if (!up && conf.forfaitNegatif > 0)
                {
                    foreach (var item in items)
                    {
                        var tension = item.Tension;
                        tension -= conf.forfaitNegatif * nbDown;
                        if (tension < 0)
                            tension = 0;
                        var newv = (tension / item.Tension) * item.Org;
                        if (item.type == borderType.nb)
                            newv = Math.Round(newv, 0); 
                        item.save(newv);
                        chooses.Add(item);
                    }
                }
                else
                {
                    foreach (CauseDataValue cd in cdv.datas)
                    {
                        if (cd.Virtuel)
                            continue;
                        if (!cd.Update)
                            continue;

                        var item = items.Find(it => it.type == cd.type);
                        if (item == null)
                            continue;
                        item.save(cd.val);
                        chooses.Add(item);

                    }
                }
                if (chooses.Count == 0)
                {
                    log("pas de choose");
                    state = builderstate.stable;
                    useForfait = false; 
                    return true;

                }





            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    bool exist = File.Exists(file);
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }


        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder();
            sb.Append(string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9})", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
                sb.Append(item);
            sb.AppendLine();
            return sb.ToString();

        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************");
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            if (choose != null)
                type = choose.type.ToString();
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
            Program.logAuto.log("{0} {1} stop:{2}", name, type, _stopLevel.ToString());

            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);

            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                //   log(" valeur {0} --> {1}", org, newv);

                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log("");
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        private CauseRegister causeRegister = new CauseRegister();
        public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null) //|| data.virtuel)
                    continue;

                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].Virtuel = true;
                if (!cd.datas[i].Virtuel)
                    nb++;
            }

            //if (nb == 0)
            //    return; 

            causeRegister.signal(cd);
            if (nb > 1)
                checkCause(cd);

        }

        private CauseDatasTension _cause;
        private void checkCause(CauseDatas cause)
        {
            bool up = delta > 0;
            if (Conf.AutoSelect)
            {
                bool selected = cause.Selected;
                if (up && selected)
                    return;
                if (!up && !selected)
                    return;
            }

            if (up)
            {
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel && !cd.Ok)
                        return;
                }

                double tot = 0;
                bool _checked = false;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (cd.Ok)
                        continue;
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (cd.val <= item.torg)
                        continue;

                    _checked = true;

                    var tension = item.getTension(cd.val);
                    if (!conf.selectFix)
                    {
                        tension = item.Dt;
                    }

                    tot += (tension * tension);
                    if (_cause != null && tot >= _cause.tension)
                        return;

                    cd.Update = true;

                }
                if (tot > 0 && _checked // (tot > 0 //COMMENT on peut avoir ZERO ???? et pourtant
                    && (_cause == null || tot < _cause.tension))
                    _cause = new CauseDatasTension(cause, tot);

            }
            else
            {
                //foreach (CauseDataValue cd in cause.datas)
                //{
                //    if (cd.Virtuel && cd.Ok)
                //        return;
                //}

                double aux = 0;
                double min = int.MaxValue;
                CauseDataValue cdMin = null;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Ok)
                        continue;
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (cd.val >= item.torg)
                        continue;

                    var tension = item.getTension(cd.val);
                    if (conf.selectFix)
                    {
                        aux = -tension;
                    }

                    else
                    {
                        aux = tension - item.Tension;
                        if (conf.selectAbs && aux < 0)
                            aux = -aux;
                    }


                    if (aux < min)
                    {
                        min = aux;
                        cdMin = cd;
                    }

                }
                if (cdMin == null)
                    return;

                if (_cause == null || _cause.tension > min)
                {
                    cdMin.Update = true;
                    _cause = new CauseDatasTension(cause, min);
                }

            }

        }



    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;
using pdb.podcast.Selection;
using pdb.podcast.Report;
using Math = System.Math; 

namespace pdb.podcast.Auto
{
    class AutoBuilderItem //: IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private timeSpan tpertinentOrg;
        public TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        private double evolSize;
        public double NewV { get { return newv; } }
        internal TrackBorderItem rejected(bool real) { return real ? _rejected : _rejectedLight; }
        internal TrackBorderItem selected(bool real) { return real ? _selected : _selectedLight; }
        internal void makePertinent() { pertinentOrg = org; }

        public void checkAjout(IEnumerable<TrackInfoItunes> list)
        {
            if (pertinentOrg == org)
                return;

            var lcauses = _causes;


            foreach (Causes causes in lcauses)
            {
                foreach (TrackInfoItunes t in list)
                {
                    if (causes.candidat.Location == t.Location)
                    {
                        pertinentOrg = org;
                        return;
                    }
                }

            }


        }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlElement xml;
        public double dd;
        public double d;
        private bool lastStrict;
        private bool lastUp;
        private double lastDelta;

        private double lastOrg;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        public AutoBuilderItem(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente - conf.min;
            dd = d * d;
        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _selectedLight;
        private TrackBorderItem _rejected;
        private TrackBorderItem _rejectedLight;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }

            //    tb.status = borderStatus.rejectedXtraLight; 
            //}


            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }


        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;

                if (!tb.Virtual)
                {
                    if (_selected == null)
                        _selected = tb;
                    else if (tb.val > _selected.val)
                        _selected = tb;
                }

                if (_selectedLight == null)
                    _selectedLight = tb;
                else if (tb.val > _selectedLight.val)
                    _selectedLight = tb;

                //if (_selected == null)
                //    setSelect(tb);
                //else
                //{
                //    if (tb.status > _selected.status && !Conf.BorderIdem)
                //        setSelect(tb);
                //    else if (tb.status == _selected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val > _selected.val)
                //            setSelect(tb);
                //    }
                //}

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;

                if (!tb.Virtual)
                {
                    if (_rejected == null)
                        _rejected = tb;
                    else if (tb.val < _rejected.val)
                        _rejected = tb;
                }

                if (_rejectedLight == null)
                    _rejectedLight = tb;
                else if (tb.val < _rejectedLight.val)
                    _rejectedLight = tb;


                //if (_rejected == null)
                //    setRejec(tb);
                //else
                //{
                //    if (tb.status > _rejected.status && !Conf.BorderIdem)
                //        setRejec(tb);
                //    else if (tb.status == _rejected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val < _rejected.val)
                //            setRejec(tb);
                //    }
                //}

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
            // Program.logAuto.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];
            lastOrg = org;
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            tpertinentOrg = getValue(pertinentOrg);
            //  misc.log(ToString());
        }
        private double dt = -1; public double Dt { get { return dt; } set { dt = value; } }
        private double tension; public double Tension { get { return tension; } }
        private int _stop = AutoBuilder.STOP_MAX;
        public bool Stop(int level) { return _stop < level; }

        public void stop(int level)
        {
            newv = lastOrg;
            org = lastOrg;
            if (_stop > level)
                _stop = level;
            save();
        }
        public void reset()
        {
            _stop = AutoBuilder.STOP_MAX;
        }
        public void setTension(bool up, bool real, bool checkSelect)
        {

            dt = getDt(up, real, checkSelect);
        }

        public void setTension()
        {
            tension = _getTension(org);
        }

        private double getDt(bool up, bool real, bool checkSelect)
        {
            double t0 = _getTension(pertinentOrg);
            tension = _getTension(up, real, checkSelect);
            return (tension - t0) / conf.coeff;

        }

        private double getTension(bool up, bool real, bool selected)
        {
            return _getTension(up, real, selected) / conf.coeff;
        }

        public double getValue(TimeSpan val)
        {
            switch (type)
            {

                case borderType.d:
                case borderType.fd:
                case borderType.nb:
                case borderType.c:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                default: return -1;

            }

        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.d:
                case borderType.fd:
                case borderType.nb:
                case borderType.c:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                default: return new TimeSpan();

            }
        }
        public double EvolSize { get { return evolSize; } }

        public List<Causes> getCauses()
        {
            return _causes;
        }

        //public List<Causes> getcauses(bool up, bool strict)
        //{
        //    List<Causes> list = null;
        //    if (up)
        //    {
        //        if (strict)
        //            list = _causesRejetStrict;
        //        else
        //            list = _causesRejet;
        //    }
        //    else
        //    {
        //        if (strict)
        //            list = _causesSelectStrict;
        //        else
        //            list = _causesSelect;
        //    }
        //    return list;
        //}

        public void gap(bool up, bool fix, double _gap)
        {
            _gap = Math.Abs(_gap);
            if (fix)
            {
                newv = Math.Abs(_gap);
            }
            else
            {
                if (up)
                    newv = org + _gap;
                else
                    newv = org - _gap;
            }
            save();
        }

        private double _getTension(bool up, bool strict, bool checkSelect)
        {
            lastStrict = strict;
            lastUp = up;
            // double t0 = getTension(org, dd);
            newv = org;
            evolSize = 0;
            var list = _causes;


            if (list.Count > 0)
            {
                int ifin = 2;
                bool bselect = !up;
                if (checkSelect)
                {
                    ifin = 1;
                }

                CauseItem cause = null;

                for (int i = 0; i < ifin; i++)
                {
                    var _cause = list[0].getCause(type, strict, !up, bselect);
                    bselect = !bselect;
                    if (_cause == null)
                        continue;
                    if (cause == null)
                        cause = _cause;
                    else
                    {
                        if (up)
                        {
                            if (_cause.val < cause.val)
                                cause = _cause;
                        }
                        else
                        {
                            if (_cause.val > cause.val)
                                cause = _cause;
                        }
                    }
                }
                if (cause == null)
                    return int.MaxValue;
                newv = Math.Round(getValue(cause.val), 8);
                foreach (var c in list)
                {
                    var cand = c.candidat;
                    evolSize += Stat.getSizeinMo(cand);
                }
            }
            else
                return int.MaxValue;


            //if (false)
            //{

            //    if (up)
            //    {
            //        var _rejected = strict ? this._rejected : this._rejectedLight;
            //        if (_rejected == null)
            //            return int.MaxValue;
            //        newv = Math.Abs(Math.Round(getValue(_rejected.val), 8));
            //        evolSize = Stat.getSizeinMo(_rejected.candidat);

            //    }
            //    else
            //    {
            //        var _selected = strict ? this._selected : this._selectedLight;
            //        if (_selected == null)
            //            return int.MaxValue;
            //        newv = Math.Round(getValue(_selected.val), 8);
            //    }
            //}

            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            _toSave = true;
        }

        public void save(timeSpan val)
        {
            this.newv = Math.Round(getValue(val), 8);
            save();
        }

        public void save(double _newv)
        {
            this.newv = Math.Round(_newv, 8);
            save();
        }



        private List<Causes> _causes = new List<Causes>();
        //private List<Causes> _causesRejet = new List<Causes>();
        //private List<Causes> _causesSelect = new List<Causes>();

        //private List<Causes> _causesRejetStrict = new List<Causes>();
        //private List<Causes> _causesSelectStrict = new List<Causes>();



        //public void after()
        //{            
        //    _causesRejet = new List<Causes>();
        //    _causesSelect = new List<Causes>();
        //    _causesRejetStrict = new List<Causes>();
        //    _causesSelectStrict = new List<Causes>();
        //    after(true, true);
        //    after(true, false);
        //    after(false, true);
        //    after(false, false);
        //}
        public void after(bool up, bool strict, bool checkSelection)
        {
            _causes = new List<Causes>();
            var list = parent.CauseRegister.getList(false);
            int min = int.MaxValue;
            //  int minStrict = int.MaxValue;
            if (!up)
            {
                min = 0;
                //   minStrict = 0; 
            }
            int orgValue = torg.Value;
            foreach (Causes causes in list)
            {
                var candidat = causes.candidat;
                if (checkSelection)
                {
                    if (up && candidat.Selected)
                        continue;
                    if (!up && !candidat.Selected)
                        continue;
                }
                int ifin = 2;
                bool bselect = !up;
                if (checkSelection)
                {
                    ifin = 1;
                }

                for (int i = 0; i < ifin; i++)
                {


                    var cause = causes.getCause(type, strict, !up, bselect);
                    bselect = !bselect;
                    if (cause == null)
                        continue;
                    if (up && cause.Ok)
                        continue;
                    if (!up && !cause.Ok)
                        continue;
                    //if (value < 0)
                    //    value = -value;
                    int value = cause.val.Value;

                    if (up)
                    {

                        if (value == min)
                        {
                            _causes.Add(causes);

                        }
                        else if (value < min)
                        {
                            _causes.Clear();
                            _causes.Add(causes);
                            min = value;
                        }

                    }
                    else
                    {
                        if (value >= orgValue)
                            continue;

                        if (value == min)
                        {
                            _causes.Add(causes);
                        }
                        else if (value > min)
                        {
                            _causes.Clear();
                            _causes.Add(causes);
                            min = value;
                        }


                    }
                }

            }
        }


        private double _getTension(double org)
        {
            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }

        public double getTension(timeSpan org)
        {
           var _org = getValue(org);
            var t = _getTension(_org);
           // dt = t - _getTension(pertinentOrg); 

            return t; 
        }





        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");

            if (newv != 0 && newv != org)
            {
                sb.Append("==>");
                sb.Append(newv);
                sb.Append(" ");
            }

            sb.Append("stop="); sb.Append(_stop); sb.Append(" ");

            sb.Append("pertinent="); sb.Append(pertinentOrg); sb.Append(" ");
            sb.Append("tension="); sb.Append(tension); sb.Append(" ");
            if (dt != -1)
            {
                sb.Append("dt="); sb.Append(dt); sb.Append(" ");
            }


            if (newv != 0 && newv != org)
            {
                sb.Append("<==");
            }
            var causes = _causes; // getcauses(lastUp, lastStrict);
            foreach (Causes cause in causes)
            {
                sb.AppendLine();
                var strStrict = lastStrict ? "strict " : "light ";
                var strselect = lastUp ? "rejet " : "select ";
                sb.Append(strselect);
                sb.Append(strStrict);
                sb.Append(cause.getCause(type, lastStrict, !lastUp, !lastUp));
                sb.Append(" "); sb.Append(cause.candidat);
            }

            //if (_causesRejetStrict.Count > 0)
            //{


            //    foreach (Causes cause in _causesRejetStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet strict "); sb.Append(cause.getCause(type,true,false));                     
            //    }
            //}

            //else if (_causesRejet.Count > 0)
            //{

            //    foreach (Causes cause in _causesRejet)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet light "); sb.Append(cause.getCause(type,false, false));      
            //    }
            //}

            //if (_causesSelectStrict.Count > 0)
            //{

            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select strict "); sb.Append(cause.getCause(type,true,true));      
            //    }
            //}

            //else if (_causesSelect.Count > 0)
            //{              
            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select light "); sb.Append(cause.getCause(type,false,true));      
            //    }
            //}



            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }


        public void signal(CauseDatas cd)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning.Sort;
using pdb.util;

namespace pdb.podcast.Sort
{
    class Album
    {
        const char SEP = '|';
        private string name;
        private SortItem conf;
        private List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        //   private int indexLastRead = -1;
        timeSpan limit;

        public Album(SortItem conf, string name)
        {
            this.conf = conf;
            this.name = name;
            limit = timeSpan.FromMinutes(conf.dureeMin);
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(track);
        }

        public void build(Loader loader)
        {
            if (conf.enabled == sortMode.no)
                return;
            if (list.Count == 0)
                return; 
            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackInfoItunes next = null;

            for (int i = 0; i < list.Count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    indexLastRead = i;
                    lastPlayed = track.PlayedDate;
                }

                if (track.Selected && track.Enabled)
                {
                    next = track;
                    indexNextSelected = i;
                    break; 
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            TrackInfoItunes lastRead = list[indexLastRead];
            DateTime pub2 = lastRead.Pub;
            loader.reviveIfNecessary(lastRead);
            var comment = lastRead.Comment;
            if (comment.Contains(SEP))
            {
                try
                {
                    pub2 = Convert.ToDateTime(comment.Split(SEP)[0]);
                }
                catch
                {
                }
            }



            int nbRead = 0;
            int nbTotal = 0;
            double delta = conf.intervalle;
            if (conf.histo > 0)
            {
                DateTime limit = next.Pub.AddDays(-conf.histo);
                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit)
                        break;

                    if (t.Played)
                        nbRead++;

                    if (t.Played || t.Enabled)
                        nbTotal++;

                }


                if (nbRead > 0)
                {
                    delta = (conf.intervalle * (double)nbTotal) / (conf.ecouteMax * (double)nbRead);
                    if (delta > conf.intervalle)
                        delta = conf.intervalle;
                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);
                misc.log("{0} {1}/{2} [{3}] {4} {5} ({6}) ", delta.ToString("#.##"), nbRead, nbTotal, name, lastRead.Name, lastRead.Pub, pub2);


            }



            if (conf.extPente > 0)
            {
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = (DateTime.Now - pub2).TotalDays;
                }

                delta = dl / conf.extPente;

                var deltaDate0 = (TrackInfoItunes.Date0 - pub2).TotalDays;
                misc.log("{0} {1}", delta.ToString("#.##"), deltaDate0.ToString("#.##"));

                if (deltaDate0 > delta)
                    delta = deltaDate0;

                if (delta < 1)
                    delta = 1;
                if (delta > conf.intervalle)
                    delta = conf.intervalle;
            }

            DateTime limitFuture = pub2.AddDays(delta);
            DateTime nextDate = limitFuture;
            int nb = 0;
            int nblissage = 0;
            double deltaMinutes = TimeSpan.FromDays(delta).TotalMinutes;

            if (conf.deltaConst)
            {
                
            }

            else
            {

                for (int i = indexLastRead + 1; i < list.Count; i++)
                {
                    var t = list[i];

                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nblissage > conf.lissage)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0)
                    deltaMinutes = (nextDate - limitFuture).TotalMinutes / (double)nb;
            }

            if (deltaMinutes < 1)
                deltaMinutes = 1;


            nb = 0;
            for (int i = indexLastRead + 1; i < list.Count; i++)
            {

                var t = list[i];

                if (!t.Selected)
                    continue;
                if (!t.Enabled)
                    continue;
                var dt = limitFuture.AddMinutes(deltaMinutes * nb);
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t);
                else
                {
                    writeComment(t, limitFuture, deltaMinutes * nb);
                    nb++;
                }


            }


        }

        private void eraseSort(TrackInfoItunes track)
        {
            string comment = track.Pub.ToString("yyyy/MM/dd HH:mm");
            if (comment != track.Comment)
                track.Comment = comment;
        }

        private void writeComment(TrackInfoItunes track, DateTime limitFuture, double deltaMinutes)
        {

            var dt = limitFuture.AddMinutes(deltaMinutes);
            misc.log("\t{0} {1} -> {2}+{3}={4}", track.Name, track.Pub, limitFuture, deltaMinutes.ToString("0.#"), dt);
            string comment = string.Format("{0}|{1}", dt.ToString("yyyy/MM/dd HH:mm"), track.Pub.ToString("yyyy/MM/dd HH:mm"));
            if (comment != track.Comment)
                track.Comment = comment;

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Sort\Sorter.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using pdb.podcast.Tuning.Sort;

namespace pdb.podcast.Sort
{
    class Sorter
    {
        private List<TrackInfoItunes> tracks;
        private pdb.podcast.Tuning.Sort.Sort sort;
        private Dictionary<string, Album> dict = new Dictionary<string, Album>();

        public Sorter(pdb.podcast.Tuning.Sort.Sort sort, IEnumerable<TrackInfoItunes> _list)
        {
            this.sort = sort;
            tracks = new List<TrackInfoItunes>();
            //   timeSpan limit = timeSpan.FromMinutes(sort.dureeMin); 
            foreach (TrackInfoItunes t in _list)
            {
                // if (t.Duree >= limit)
                tracks.Add(t);
            }
            tracks.Sort(new PodCastComparer());
        }

        public void build(Loader loader)
        {
            foreach (TrackInfoItunes track in tracks)
            {
                string album = track.Album;
                //  string _feed = track.Feed;

                string key = album;
                //if (!string.IsNullOrEmpty(_feed))
                //    key = _feed;
                if (string.IsNullOrEmpty(album))
                {
                    misc.log("pas d'album pour " + track);
                    continue;
                }



                if (!dict.ContainsKey(key))
                {
                    SortItem item = sort;
                    var _surcharge = sort.getItem(key);
                    if (_surcharge != null)
                        item = _surcharge;
                    Album a = new Album(item, key);
                    dict.Add(key, a);
                }
                dict[key].check(track);
            }

            foreach (Album a in dict.Values)
            {
                a.build(loader);
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Auto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.podcast.Auto;
using pdb.util;
namespace pdb.podcast.Tuning
{
    class Auto
    {
        delegate void sets(string value);
        delegate void setd(double value);
        delegate void seti(int value);
        delegate void setb(bool value);

        private void buildd(XmlNode parent, XmlNode child, string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
        }

        private void buildi(XmlNode parent, XmlNode child, string name, seti seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }

        private void builds(XmlNode parent, XmlNode child, string name, sets sets)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                sets(att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                sets(att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                sets(elt.InnerText);
            elt = child[name];
            if (elt != null)
                sets(elt.InnerText);
        }

        private void buildb(XmlNode parent, XmlNode child, string name, setb setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setb("true" == elt.InnerText);
            elt = child[name];
            if (elt != null)
                setb("true" == elt.InnerText);
        }

        public string name = "";
        public borderType type = borderType.d;
        public double target;
        public double delta;
        public double write;
        public int cloop = 20;
        public int verif = 4;
        public int idem = 4;
        public int order = int.MaxValue;
        public double min = -int.MaxValue;
        public double max = int.MaxValue;
        public double coeff = 0;
        public bool selectFix;
        public bool selectAbs;
        public bool pertinentAll;
        public bool pertinentExclu; 
        public bool stopAll=true;
        public bool checkStrict;
        public bool checkSelect;
        public bool checkEvol; 
        public bool gap = false; 
        public double pente; 
        public List<Level> levels = new List<Level>();
        public List<Auto> items = new List<Auto>();
        public double forfaitNegatif = 0; 

        public Auto()
        {
        }
        public Auto(Auto parent, XmlElement xparent, XmlElement node)
        {
            if (node == null)
                return;
            //if (parent != null)
            //{
            //    name = parent.name; 
            //    type = parent.type; 
            //    target = parent.target; 
            //    write = parent.write; 
            //    delta = parent.delta; 
            //    write = parent.write; 
            //    cloop = parent.cloop; 
            //    verif = parent.verif; 
            //    idem = parent.idem; 
            //    order = parent.order; 
            //    min = parent.min; 
            //    max = parent.max; 
            //    coeff = parent.coeff; 
            //    levels = new List<Level>(parent.levels); 
            //}
            XMLTool xml = new XMLTool(node);

            if (node.Attributes["type"] != null)
                type = (borderType)Enum.Parse(typeof(borderType), node.Attributes["type"].Value, true);
            builds(xparent, node, "name", (v) => name = v);
            buildd(xparent, node, "target", (v) => target = v);
            buildd(xparent, node, "delta", (v) => delta = v);
            buildd(xparent, node, "write", (v) => write = v);
            buildi(xparent, node, "cloop", (v) => cloop = v);
            buildi(xparent, node, "verif", (v) => verif = v);
            buildi(xparent, node, "verif", (v) => idem = v);
            buildi(xparent, node, "order", (v) => order = v);

            buildd(xparent, node, "min", (v) => min = v);
            buildd(xparent, node, "max", (v) => max = v);
            buildd(xparent, node, "coeff", (v) => coeff = v);
            buildb(xparent, node, "selectFix", (v) => selectFix = v);
            buildb(xparent, node, "selectAbs", (v) => selectAbs = v);
            buildb(xparent, node, "pertinentAll", (v) => pertinentAll = v);
            buildb(xparent, node, "stopAll", (v) => stopAll = v);
            buildb(xparent, node, "gap", (v) => gap = v);
            buildb(xparent, node, "checkStrict", (v) => checkStrict = v);
            buildb(xparent, node, "checkSelect", (v) => checkSelect = v);
            buildb(xparent, node, "checkEvol", (v) => checkEvol = v);
            buildb(xparent, node, "pertinentExclu", (v) => pertinentExclu = v);
            buildd(xparent, node, "pente", (v) => pente = v);
            buildd(xparent, node, "forfaitNegatif", (v) => forfaitNegatif = v); 

            

            /*//  type = xml.getAttValue("type");
            //  target = xml.getDoubleAttValue("target");
             // delta = xml.getDoubleAttValue("delta");
             // write = xml.getDoubleAttValue("write");
            //  cloop = xml.getIntAttValue("cloop", 20);
            //  verif = xml.getIntAttValue("verif", 4);
             // idem = xml.getIntAttValue("idem", 4);
             // order = xml.getIntAttValue("order", int.MaxValue);
              min = xml.getDoubleAttValue("min", -int.MaxValue);
              max = xml.getDoubleAttValue("max", int.MaxValue);
              coeff = xml.getDoubleAttValue("coeff", 0);
           
              string str = "";
              if (target < 0)
              {
                  str = xml.getNodeValue("target");
                  if (!string.IsNullOrEmpty(str))
                      target = Convert.ToDouble(str);
              }
              if (delta < 0)
              {
                  str = xml.getNodeValue("delta");
                  if (!string.IsNullOrEmpty(str))
                      delta = Convert.ToDouble(str);
              }
              if (write < 0)
              {
                  str = xml.getNodeValue("write");
                  if (!string.IsNullOrEmpty(str))
                      write = Convert.ToDouble(str);
              }
              str = xml.getNodeValue("cloop");
              if (!string.IsNullOrEmpty(str))
                  cloop = Convert.ToInt16(str);
              str = xml.getNodeValue("verif");
              if (!string.IsNullOrEmpty(str))
                  verif = Convert.ToInt16(str);
              str = xml.getNodeValue("idem");
              if (!string.IsNullOrEmpty(str))
                  idem = Convert.ToInt16(str);
              str = xml.getNodeValue("order");
              if (!string.IsNullOrEmpty(str))
                  order = Convert.ToInt16(str);
              str = xml.getNodeValue("min");
              if (!string.IsNullOrEmpty(str))
                  min = Convert.ToDouble(str);
              str = xml.getNodeValue("max");
              if (!string.IsNullOrEmpty(str))
                  max = Convert.ToDouble(str);
              str = xml.getNodeValue("coeff");
              if (!string.IsNullOrEmpty(str))
                  coeff = Convert.ToDouble(str);
              levels = new List<Level>();*/

            if (parent != null)
                levels = new List<Level>(parent.levels);

            var xlevels = xml.NodeLookUp("levels");

            if (xlevels != null)
            {
                levels.Clear();
                foreach (XmlNode sub in xlevels.ChildNodes)
                {
                    if (sub is XmlElement)
                    {
                        var level = new Level(sub as XmlElement);
                        levels.Add(level);
                    }
                }
            }
            else if (levels.Count == 0)
            {
                var level = new Level(node);
                levels.Add(level);
            }
            var xitems = xml.NodeLookUp("items");
            if (xitems != null)
            {
                foreach (XmlNode sub in xitems.ChildNodes)
                {
                    if (sub is XmlElement)
                    {
                        var subAuto = new Auto(this, node, sub as XmlElement);
                        items.Add(subAuto);
                    }
                }
            }

        }
    }
    class Level
    {
        public double d;
        public double inf;
        public double sup;
        public Level()
        {
        }
        public Level(XmlElement node)
        {
            if (node == null)
                return;
            XMLTool xml = new XMLTool(node);
            d = xml.getDoubleAttValue("d");
            inf = xml.getDoubleAttValue("inf");
            sup = xml.getDoubleAttValue("sup");
            string str = xml.getAttValue("d");
            if (!string.IsNullOrEmpty(str))
                d = Convert.ToDouble(str);
            str = xml.getAttValue("inf");
            if (!string.IsNullOrEmpty(str))
                inf = Convert.ToDouble(str);
            str = xml.getAttValue("sup");
            if (!string.IsNullOrEmpty(str))
                sup = Convert.ToDouble(str);
        }
    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\LimitItemBase.cs">
    <content><![CDATA[using pdb.podcast.Auto;
using System;
using System.Xml;

namespace pdb.podcast.Tuning
{

    public class LimitItemBase
    {
        /// <summary>
        /// temps total de tous les flux associés à cette limite
        /// </summary>
        protected double duration = int.MaxValue;
        /// <summary>
        /// Temps total phase load de tous les flux associés à cette limite
        /// </summary>
        protected double loadDuration = int.MaxValue; 

        protected LimitItemBase parent;
        const double MAX = int.MaxValue;


        delegate void setf(double value);
        delegate void setI(int value);
        delegate void setd(DateTime value);
        delegate void setDouble(double value); 

        public bool isChildOf(LimitItemBase p)
        {
            if (p == null)
                return true;
            if (this == p)
                return true;
            if (parent == null)
                return false;
            return parent.isChildOf(p); 

        }

        public void setParent(LimitItemBase parent)
        {
            this.parent = parent;
        }

        /// <summary>
        /// Contribution max de cette limite
        /// </summary>
        protected double contribution = int.MaxValue;
        /// <summary>
        /// nombre d'éléments max
        /// </summary>
        protected int nb = int.MaxValue;

        protected int lNb = int.MaxValue;

        /// <summary>
        /// durée totale du flux
        /// </summary>
        protected double feedDuration = int.MaxValue;

        protected double lFd = int.MaxValue; 

        /// <summary>
        /// durée max de chaque track
        /// </summary>
        protected double td = int.MaxValue;

        /// <summary>
        /// Durée min de chaque track
        /// </summary>
        protected double tdMin = 0;

        protected DateTime dateMin;

        protected DateTime dateMax = DateTime.MaxValue;

        protected DateTime dateMax2 = DateTime.MaxValue;

        protected DateTime offset;
        public DateTime Offset { get { return offset; } }

        public bool hduration; 
        public double Duration
        {
            get
            {
                if (parent == null || duration < MAX)
                    return duration;
                return parent.Duration;
            }
        //    set { duration = value; }
        }
        public void setDuration(double value, bool hduration)
        {
            this.duration = value;
            this.hduration = hduration; 
        }
       

        public double LoadDuration
        {
            get
            {
                if (parent == null || loadDuration < MAX)
                    return loadDuration;
                return parent.LoadDuration;
            }
            set { loadDuration = value; }
        }
        public double Contribution
        {
            get
            {
                if (parent == null || contribution < MAX)
                    return contribution;
                return parent.Contribution;
            }

            set { contribution = value; }
        }
        public double FeedDuration
        {
            get
            {
                if (parent == null || feedDuration < MAX)
                    return feedDuration;
                return parent.FeedDuration;
            }
          //  set { feedDuration = value; }
        }
        public bool hfeedDuration; 
        public void setFeedDuration(double value, bool hduration)
        {
            this.feedDuration = value;
            this.hfeedDuration = hduration;
        }
       
        public double LoadFeedDuration
        {
            get
            {
                if (parent == null || lFd < MAX)
                    return lFd;
                return parent.LoadFeedDuration;
            }
            set { lFd = value; }
        }

        public int Nb
        {
            get
            {
                if (parent == null || nb < int.MaxValue)
                    return nb;
                return parent.Nb;
            }
           // set { nb = value; }
        }

        public int LoadNb
        {
            get
            {
                if (parent == null || lNb < int.MaxValue)
                    return lNb;
                return parent.LoadNb;
            }
            set { lNb = value; }
        }


        /// <summary>
        /// durée max de chaque track
        /// </summary>
        public double Td { set { td = value; } get { return td; } }
        /// <summary>
        /// Durée min de chaque track
        /// </summary>
        public double TdMin
        {
            set { tdMin = value; }
            get
            {
                if (parent == null || tdMin < MAX)
                    return tdMin;
                return parent.TdMin;
            }
        }
        public DateTime DateMin { set { dateMin = value; } get { return dateMin; } }
        public DateTime DateMax {
            //set { dateMax = value; } 
            get { return dateMax; } }
        public DateTime DateMax2 { get { return dateMax2; } set { dateMax2 = value; } }
        public bool hdateMax;
        public void setDateMax(DateTime value, bool hdateMax)
        {
            this.dateMax = value;
            this.hdateMax = hdateMax; 
        }

        public bool hNb;
        public void setNbMax(int value, bool hNb)
        {
            this.nb = value;
            this.hNb = hNb; 
        }

        public void build(XmlNode parent, XmlNode child)
        {
            buildf(parent, child, "d", (v) => duration = v);
            buildf(parent, child, "ld", (v) => loadDuration = v);
            buildf(parent, child, "c", (v) => contribution = v);
            buildf(parent, child, "fd", (v) => feedDuration = v);
            buildf(parent, child, "lfd", (v) => lFd = v);
            buildi(parent, child, "nb", (v) => nb = v);
            //double nbd = 0; 
            //buildDouble(parent, child, "nb", (v) => nbd = v);
           // nb = (int)Math.Round(nbd); 
            buildi(parent, child, "lnb", (v) => lNb = v);
            buildd(parent, child, "date", (v) => dateMin = v);
            buildd(parent, child, "maxdate", (v) => dateMax = v);
            buildd(parent, child, "maxdate2", (v) => dateMax2 = v);
            int _offset = 0;
            buildi(parent, child, "offsety", (v) => _offset = v);
            if (_offset >0)
            {
                offset = DateTime.Now.AddYears(-_offset); 
            }
        }

        private void buildf(XmlNode parent, XmlNode child, string name, setf setf)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setf(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setf(Convert.ToDouble(att.InnerText));
        }

        private void buildi(XmlNode parent, XmlNode child, string name, setI seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt16(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt16(att.InnerText));
        }

        private void buildd(XmlNode parent, XmlNode child, string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Conf.getDate(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Conf.getDate(att.InnerText));
        }

        private void buildDouble(XmlNode parent, XmlNode child, string name, setDouble setDouble)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setDouble(Convert.ToDouble (att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setDouble(Convert.ToDouble(att.InnerText));
        }

    }


}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Sort.cs">
    <content><![CDATA[using System.Xml;
using pdb.util;
using System;
using System.Collections.Generic;

namespace pdb.podcast.Tuning.Sort
{
    public enum sortMode
    {
        no,
        reset,
        once,
        all
    }
    public class SortItem : TuningBase
    {
        public string name;
        public sortMode enabled;
        /// <summary>
        /// prise en compte des longs podcasts
        /// </summary>
        public double dureeMin;
        /// <summary>
        /// intervalle max entre deux écoutes (une semaine)
        /// </summary>
        public double intervalle;
        /// <summary>
        /// écoutes maximum dans l'intervalle (typiquement 5)
        /// </summary>
        public double ecouteMax;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute
        /// </summary>
        public double histo;
        /// <summary>
        /// 
        /// </summary>
        public int lissage;
        /// <summary>
        /// écart constant entre les poscasts repoussés
        /// </summary>
        public bool deltaConst; 

        /// <summary>
        /// Date0 lors de l'écoute du dernier podcast externe
        /// </summary>
        public DateTime extLast0;
        /// <summary>
        /// Décalage entre date du podcast supplémentaire et la date0
        /// </summary>
        public double extDelta;
        /// <summary>
        /// coefficient permettant le calcul de la prochaine date en fonction du retard entre la date0 et maintenant
        /// </summary>
        public double extPente;

        public SortItem()
        {
        }

        public SortItem(XmlElement parent, XmlElement node)
            : base(parent, node)
        {

            if (node == null)
                return;
            builds("name", v => name = v);
            var str = "";
            builds("enabled", v => str = v);

            if (!string.IsNullOrEmpty(str))
                enabled = (sortMode)Enum.Parse(typeof(sortMode), str);

            buildd("dureeMin", v => dureeMin = v);
            buildd("intervalle", v => intervalle = v);
            buildd("histo", v => histo = v);
            buildd("ecouteMax", v => ecouteMax = v);

            buildDate("extLast0", v => extLast0 = v);
            buildd("extDelta", v => extDelta = v);
            buildd("extPente", v => extPente = v);

            buildi("lissage", v => lissage = v);
            buildb("deltaConst", v => deltaConst = v); 


        }


    }
    public class Sort : SortItem
    {
        private List<SortItem> items = new List<SortItem>();
        public SortItem getItem(string album)
        {
            return items.Find(a => a.name == album);
        }
        public Sort()
        {
        }

        public Sort(XmlElement node)
            : base(null, node)
        {
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement && sub.Name == "album")
                {
                    items.Add(new SortItem(node, sub as XmlElement));
                }
            }
        }


    }
}]]></content>
  </file>
</db>
