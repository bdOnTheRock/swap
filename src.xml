<db path="C:\Bernard\db1\PieceDb3Ref">
 
  <file path="\pdb.podcast\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;
using pdb.podcast.Selection;
using pdb.podcast.Report;

namespace pdb.podcast.Auto
{
    class AutoBuilderItem : IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        private double evolSize;
        public double NewV { get { return newv; } }
        internal TrackBorderItem rejected(bool real) { return real ? _rejected : _rejectedLight; }
        internal TrackBorderItem selected(bool real) { return real ? _selected : _selectedLight; }
        internal void makePertinent() { pertinentOrg = org; }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlElement xml;
        double dd;
        double d;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        public AutoBuilderItem(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente - conf.min;
            dd = d * d;
        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _selectedLight;
        private TrackBorderItem _rejected;
        private TrackBorderItem _rejectedLight;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }

            //    tb.status = borderStatus.rejectedXtraLight; 
            //}


            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }


        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;

                if (!tb.Virtual)
                {
                    if (_selected == null)
                        _selected = tb;
                    else if (tb.val > _selected.val)
                        _selected = tb;
                }

                if (_selectedLight == null)
                    _selectedLight = tb;
                else if (tb.val > _selectedLight.val)
                    _selectedLight = tb;

                //if (_selected == null)
                //    setSelect(tb);
                //else
                //{
                //    if (tb.status > _selected.status && !Conf.BorderIdem)
                //        setSelect(tb);
                //    else if (tb.status == _selected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val > _selected.val)
                //            setSelect(tb);
                //    }
                //}

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;

                if (!tb.Virtual)
                {
                    if (_rejected == null)
                        _rejected = tb;
                    else if (tb.val < _rejected.val)
                        _rejected = tb;
                }

                if (_rejectedLight == null)
                    _rejectedLight = tb;
                else if (tb.val < _rejectedLight.val)
                    _rejectedLight = tb;


                //if (_rejected == null)
                //    setRejec(tb);
                //else
                //{
                //    if (tb.status > _rejected.status && !Conf.BorderIdem)
                //        setRejec(tb);
                //    else if (tb.status == _rejected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val < _rejected.val)
                //            setRejec(tb);
                //    }
                //}

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
            misc.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            //  misc.log(ToString());
        }
        private double dt; public double Dt { get { return dt; } }
        private double tension; public double Tension { get { return tension; } }

        public void setTension(bool up, bool real)
        {
            dt = getDt(up, real);
            tension = getTension(up, real);
        }

        private double getDt(bool up, bool real)
        {
            double t0 = _getTension(pertinentOrg);
            double t1 = _getTension(up, real);
            return (t1 - t0) / conf.coeff;

        }

        private double getTension(bool up, bool real)
        {
            return _getTension(up, real) / conf.coeff;
        }

        private double getValue(TimeSpan val)
        {
            switch (type)
            {

                case borderType.d:
                case borderType.fd:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                case borderType.c:
                    break;
                default: return -1;

            }
            return -1;
        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.d:
                case borderType.fd:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                case borderType.c:
                    break;
                default: return new TimeSpan();

            }
            return new TimeSpan();
        }
        public double EvolSize { get { return evolSize; } }
        private double _getTension(bool up, bool real)
        {

            // double t0 = getTension(org, dd);
            newv = org;
            evolSize = 0;
            List<Causes> list = null;
            if (up)
            {
                if (real)
                    list = _causesRejetStrict;
                else
                    list = _causesRejet;
            }
            else
            {
                if (real)
                    list = _causesSelectStrict;
                else
                    list = _causesSelect;
            }


            if (list.Count > 0)
            {
                var cause = list[0].getCause(type);
                newv =Math.Abs( Math.Round(getValue(cause.val), 8));
                foreach (var c in list)
                {
                    var cand = c.candidat;
                    evolSize += Stat.getSizeinMo(cand);
                }
            }
            else
                return int.MaxValue;


            if (false)
            {

                if (up)
                {
                    var _rejected = real ? this._rejected : this._rejectedLight;
                    if (_rejected == null)
                        return int.MaxValue;
                    newv =Math.Abs(Math.Round(getValue(_rejected.val), 8));
                    evolSize = Stat.getSizeinMo(_rejected.candidat);

                }
                else
                {
                    var _selected = real ? this._selected : this._selectedLight;
                    if (_selected == null)
                        return int.MaxValue;
                    newv = Math.Round(getValue(_selected.val), 8);
                }
            }

            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            _toSave = true;
        }

        private List<Causes> _causesRejet = new List<Causes>();
        private List<Causes> _causesSelect = new List<Causes>();

        private List<Causes> _causesRejetStrict = new List<Causes>();
        private List<Causes> _causesSelectStrict = new List<Causes>();
        public bool isVirtual(bool up)
        {
            if (up)
                return _causesRejetStrict.Count == 0;
            else
                return _causesSelectStrict.Count == 0;
        }
        public void after()
        {
            _causesRejet = new List<Causes>();
            _causesSelect = new List<Causes>();
            _causesRejetStrict = new List<Causes>();
            _causesSelectStrict = new List<Causes>();
            after(true);
            after(false);
        }
        private void after(bool up)
        {
            var list = parent.CauseRegister.getList(false);
            int min = int.MaxValue;
            int minStrict = int.MaxValue;
            if (!up)
            {
                min = 0;
                minStrict = 0; 
            }
            int orgValue = torg.Value; 
            foreach (Causes causes in list)
            {
                var candidat = causes.candidat;
                if (up && candidat.Selected)
                    continue;
                if (!up && !candidat.Selected)
                    continue;
                var cause = causes.getCause(type);
                if (cause == null)
                    continue;
                int value = cause.val.Value;
                if (up && value < 0)
                    continue;
                if (!up && value > 0)
                    continue;
                if (value < 0)
                    value = -value;

                if (up)
                {
                    if (value == min)
                    {
                        //bool same = false; 
                        //foreach (var _c in _causesRejet)
                        //{
                        //    if (_c.candidat.Album == causes.candidat.Album && _c.getCause(type).limit == cause.limit)
                        //    {
                        //        same = true;
                        //        break; 
                        //    }
                        //}

                        //if (same)
                        //    continue;
                        _causesRejet.Add(causes);
                        // 
                    }
                    else if (value < min)
                    {
                        _causesRejet = new List<Causes>();
                        _causesRejet.Add(causes);
                        min = value;
                    }
                    // vérif strict
                    bool strict = true;
                    foreach (CauseItem ci in causes.getCauses())
                    {
                        if (ci == cause)
                            continue;
                        if (ci.val.Value > 0) // échec
                        {
                            strict = false;
                            break;
                        }
                    }
                    if (strict)
                    {
                        if (value == minStrict)
                        {
                            //bool same = false; 
                            //foreach (var _c in _causesRejetStrict)
                            //{
                            //    if (_c.candidat.Album == causes.candidat.Album && _c.getCause(type).limit == cause.limit)
                            //    {
                            //        same = true;
                            //        break; 
                            //    }

                            //}
                            //if (same)
                            //    continue;
                            _causesRejetStrict.Add(causes);
                            // 
                        }
                        else if (value < minStrict)
                        {
                            _causesRejetStrict = new List<Causes>();
                            _causesRejetStrict.Add(causes);
                            minStrict = value;
                        }
                    }
                }
                else
                {
                    if (value >= orgValue)
                        continue; 
                    if (value == min)
                    {
                        //bool same = false; 
                        //foreach (var _c in _causesSelect)
                        //{
                        //    if (_c.candidat.Album == causes.candidat.Album && _c.getCause(type).limit == cause.limit)
                        //    {
                        //        same = true;
                        //        break;
                        //    }
                        //}
                        //if (same)
                        //    continue; 
                        _causesSelect.Add(causes);
                    }
                    else if (value > min)
                    {
                        _causesSelect = new List<Causes>();
                        _causesSelect.Add(causes);
                        min = value;
                    }

                    // vérif strict
                    bool strict = true;
                    foreach (CauseItem ci in causes.getCauses())
                    {
                        if (ci == cause)
                            continue;
                        if (ci.val.Value > 0) // échec
                        {
                            strict = false;
                            break;
                        }
                    }
                    if (strict)
                    {
                        if (value == minStrict)
                        {
                            //bool same = false; 
                            //foreach (var _c in _causesSelectStrict)
                            //{
                            //    if (_c.candidat.Album == causes.candidat.Album && _c.getCause(type).limit == cause.limit)
                            //    {
                            //        same = true;
                            //        break;
                            //    }

                            //}
                            //if (same)
                            //    continue; 
                            _causesSelectStrict.Add(causes);
                            // 
                        }
                        else if (value > minStrict)
                        {
                            _causesSelectStrict = new List<Causes>();
                            _causesSelectStrict.Add(causes);
                            minStrict = value;
                        }
                    }
                }

            }
        }


        private double _getTension(double org)
        {


            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }

        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");
            sb.Append("pertinent="); sb.Append(pertinentOrg); sb.Append(" ");
            sb.Append("tension="); sb.Append(tension); sb.Append(" ");
            sb.Append("dt="); sb.Append(dt); sb.Append(" ");

            if (_causesRejetStrict.Count > 0)
            {
              
                
                foreach (Causes cause in _causesRejetStrict)
                {
                    sb.AppendLine();
                    sb.Append("rejet strict "); sb.Append(cause.getCause(type));                     
                }
            }

            else if (_causesRejet.Count > 0)
            {
              
                foreach (Causes cause in _causesRejet)
                {
                    sb.AppendLine();
                    sb.Append("rejet light "); sb.Append(cause.getCause(type));      
                }
            }

            if (_causesSelectStrict.Count > 0)
            {
               
                foreach (Causes cause in _causesSelectStrict)
                {
                    sb.AppendLine();
                    sb.Append("select strict "); sb.Append(cause.getCause(type));      
                }
            }

            else if (_causesSelect.Count > 0)
            {              
                foreach (Causes cause in _causesSelectStrict)
                {
                    sb.AppendLine();
                    sb.Append("select light "); sb.Append(cause.getCause(type));      
                }
            }

           

            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }


        public void signal(CauseData cd)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\FeedLimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using timeSpan = pdb.util.timeSpan;

namespace pdb.podcast.Load
{
    public enum loadState
    {
        loadCandidat,
        standAlone,
        selection,
        end
    }
    public enum depotType
    {
        load,
        rapporte
    }
    /// <summary>
    /// Chargeur des pistes associées à un item de limite sur un dossier
    /// </summary>
    class FeedLimitItemLoader
    {
        private loadState state;
        /// <summary>
        /// Répertoire
        /// </summary>
        private DirConf dir;
        /// <summary>
        /// Limite
        /// </summary>
        public readonly LimitItem limit;
        /// <summary>
        /// Album
        /// </summary>
        private string album;
        /// <summary>
        /// Chargeur de limite
        /// </summary>
        private LimitsLoader parent;


        /// <summary>
        /// Nombre de piste max
        /// </summary>
        int nbMax;
        int loadNbMax;
        /// <summary>
        /// Durée cumulée max
        /// </summary>
        timeSpan durationMax;
        timeSpan loadDurationMax;

        ///// <summary>
        ///// Date de publication min
        ///// </summary>
        //DateTime dateMin;

        // private Logger logger;
        private Logger logLimit;
        private Logger logItem;

        /// <summary>
        /// Durée cumulée
        /// </summary>
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtuel = new timeSpan();
        timeSpan durationStop = new timeSpan(); 

        /// <summary>
        /// Nombre total
        /// </summary>
        int nb = 0;
        int nbVirtuel = 0;
        int nbStop = 0;

        private bool? endByFd;
        public bool EndByFd { get { if (endByFd == null) return false; return endByFd.Value; } }

        private bool _okFd; public bool OkFd { get { return _okFd; } }
        private bool _okNb; public bool OkNb { get { return _okNb; } }


        public void phase2()
        {
            currentDuration = new timeSpan();
            currentDurationVirtuel = new timeSpan();
            durationStop = new timeSpan(); 
            nb = 0;
            nbVirtuel = 0;
            nbStop = 0; 
            state = loadState.selection;
            endByFd = null;
        }


        private bool loadEqSel;
        public bool LoadEqSel { get { return loadEqSel; } }

        public FeedLimitItemLoader(LimitItem limit, string album, LimitsLoader parent)
        {
            this.dir = limit.Dir;
            this.limit = limit;

            this.parent = parent;
            this.album = album;


            nbMax = limit.Nb;


            var feedDuration = limit.FeedDuration;
            int rating = limit.Rating;
            durationMax = timeSpan.FromMinutes(feedDuration);


            loadDurationMax = durationMax;
            loadNbMax = nbMax;

            loadEqSel = true;

            if (limit.Dir.Cascading)
            {
                if (limit.LoadNb > nbMax)
                    loadNbMax = limit.LoadNb;
                if (limit.LoadFeedDuration > feedDuration)
                {
                    loadDurationMax = timeSpan.FromMinutes(limit.LoadFeedDuration);
                    loadEqSel = false;
                }

            }

            logItem = Logger.getLogger(limit.ID + "\\" + album, null, false);
            logLimit = limit.Logger;
        }

        private void log(string txt)
        {
            logLimit.log(txt);
            logItem.log(txt);
        }

        private void log(string txt, params object[] other)
        {

            logLimit.log(txt, other);
            logItem.log(txt, other);
        }




        public timeSpan getCurrentDuration(bool real)
        {
            if (real)
                return currentDuration;
            return currentDurationVirtuel;
        }

        public timeSpan getDurationStop(bool real)
        {
            if (durationStop.Value == 0)
                return getCurrentDuration(real);
            return durationStop; 
        }

        public int getNb(bool real)
        {

            if (real)
                return nb;
            return nbVirtuel;
        }
        public int getNbStop(bool real)
        {
            if (nbStop == 0)
                return getNb(real);
            return nbStop; 
        }

        public int Nb { get { return nb; } }

        public bool control(TrackInfoItunes track, bool select, bool real)
        {
            //if (state == loadState.end)
            //    return false;


            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return false;



            //     string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration.TotalMinutes.ToString("0"), track.ToString());
            string phase = select ? "ctl" : "load";

            if (!Logger.CreateNullLoggers)
            {
                string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration, track.ToString());

                log("-->  {0} ok {1} ", phase, str);
            }

            var ok = checkStatus(string.Format("-->  {0}", phase), select, track, limit, real);

            if (!ok)
                return false;

            if (select && real)
            {
                var selected = selectMode.simple;
                if (dir.Histo)
                {
                    selected = selectMode.serial;
                    if (dir.HistoAll.HasValue && dir.HistoAll.Value)
                        selected = selectMode.histo;
                    if (dir.Serial)
                        selected = selectMode.serial;
                }
                else
                {
                    //if (!candidat.Serial && !candidat.Histo)
                    selected = selectMode.simple;
                }

                track.select(selected, limit);
                Feeds.Instance.recordTrack(track, limit);
            }

            //report aux niveaux inférieurs
            if (real)
                parent.recordLimitItemCandidat(track, limit);
            return true;
        }




        private bool checkStatus(string phase, bool select, TrackInfoItunes track, LimitItem itemSource, bool real)
        {
            endByFd = null;
            _okFd = true;
            _okNb = true; 
            bool ret = true;
            //        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration.TotalMinutes.ToString("0"), track.ToString());
            //nbVirtuel = nb;
            //currentDurationVirtuel = currentDuration; 
            var nbBase = real ? nb : nbVirtuel;

            var _nb = nbBase + 1;
            var durationBase = real ? currentDuration : currentDurationVirtuel;
            var dur = durationBase + track.Duree;

            int _nbMax = select ? this.nbMax : this.loadNbMax;
            var _durationMax = select ? this.durationMax : this.loadDurationMax;

            if (_nb > _nbMax)
            {
                _okNb = false; 
                if (real)
                {
                    limit.NbFeedLimit = true;
                    if (!Logger.CreateNullLoggers)
                    {
                        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
                        log("{0} stop nb {1} ", phase, str);
                    }
                    if (state != loadState.end)
                    {
                        state = loadState.end;
                        nbStop = _nb; 
                    }
                }

                endByFd = false;
                ret = false;
            }



            // vérification des valeurs cumulées
            if (dur > _durationMax)
            {
                _okFd = false; 
                if (real)
                {

                    if (!limit.DurationFeedLimit)
                    {
                        if (!Logger.CreateNullLoggers)
                        {
                            string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
                            log("{0} stop d. {1} ", phase, str);
                        }
                    }
                    limit.DurationFeedLimit = true;
                    if (state != loadState.end)
                    {
                        state = loadState.end;
                        durationStop = dur;
                    }
                    
                }

                //if (select || durationMax == loadDurationMax)
                //{
                //    if (ret)
                //    {
                //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, false);
                //        limit.signal(tb);
                //    }
                //    //limit.checkBorderFd(track, dur, false);
                //}

                if (endByFd == null)
                    endByFd = true;
                ret = false;
            }
            else
            {
                // endByFd = null;
                //if (select || durationMax == loadDurationMax)
                //{
                //    if (ret)
                //    {
                //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, true);
                //        limit.signal(tb);
                //    }
                //}
            }







            if (real)
            {
                nb+=1;
                currentDuration += track.Duree;
            }

            currentDurationVirtuel += track.Duree;
            nbVirtuel += 1; 
            return ret;

        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;
//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    class LimitItemLoader
    {
        private LimitItem limit;
        private LimitsLoader parent;
        private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();
        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        private Logger log;
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;

        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var duration = limit.Duration;
            loadEqSel = true;
            if (limit.Dir.Cascading)
            {
                var dd = limit.LoadDuration;
                if (dd > duration)
                {
                    loadEqSel = false;
                    duration = dd;
                }
            }
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                var d = candidat.Pub;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                Exporter.Record(candidat);

                bool okDate = d <= dateMax;
                //if (Conf.BorderVirtual)
                //    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, okDate, false));
                //if (!okDate)
                //    continue;
                //  var tb = new TrackBorderItem(limit, candidat, borderType.m    axdate, candidat.Pub, okDate);
                //  limit.signal(tb);

                //if (Conf.BorderVirtual)
                //{
                //     var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, border.);
                //      limit.signal(tb);
                //}

                //if (!okDate && !Conf.BorderVirtual)
                //    continue;


                var loader = getLoader(candidat.Album);
                bool _control = loader.control(candidat, false, okDate);

                //if (!_control && !Conf.BorderVirtual)
                //    continue;

                var currentDurationBase = (okDate && _control) ? currentDuration : currentDurationVirtual;
                var newDuration = currentDurationBase + candidat.Duree;
                bool okTotalDuration = newDuration <= durationMax;
                bool selected = _control && okTotalDuration; //
                bool okNb = loader.OkNb;

                //question fd
                if (loader.LoadEqSel)
                {
                    Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                        loader.OkFd, loader.getDurationStop(okDate)
                        , okNb, loader.getNbStop(okDate)
                        , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                    limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                    limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                    limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));



                    if (okDate && _control && okTotalDuration)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedStrict));
                    else if (okDate && okTotalDuration)
                    {
                        if (loader.EndByFd)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedStrict));
                    }
                    else if (Conf.BorderVirtual)
                    {
                        if (_control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                        else if (loader.EndByFd)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));
                    }


                    //if (!_control)
                    //{
                    //    if (okDate && okTotalDuration && loader.EndByFd)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                }

                if (loadEqSel)
                {
                    // question d
                    if (okDate && _control && okTotalDuration)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                    else if (okDate && _control)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                    else if (Conf.BorderVirtual)
                    {
                        if (okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                        else
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                    }
                    //if (!okTotalDuration)
                    //{
                    //    if (okDate && _control)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}

                    // question date
                    if (okDate && _control && okTotalDuration)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                    else if (_control && okTotalDuration)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                    else if (Conf.BorderVirtual)
                    {
                        if (okDate)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                        else
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                    }

                }



                //if (loadEqSel)
                //{
                //    if ((okDate && _control) || Conf.BorderVirtual)
                //    {
                //       var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okTotalDuration);
                //        limit.signal(tb);
                //    }
                //}

                //if ((okDate && _control))
                //{                   
                //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okTotalDuration,true);
                //    limit.signal(tb);
                //}

                //if (_control && okTotalDuration)
                //{
                //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate);
                //    limit.signal(tb);
                //}

                //if (okDate && okTotalDuration)
                //{
                //    if (!loader.limit.NbFeedLimit)
                //    {
                //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.CurrentDuration, _control);
                //        limit.signal(tb); 
                //    }
                //}

                // limit.checkBorderDates(candidat, selected);

                if (okDate && _control)
                    currentDuration += candidat.Duree; // newDuration; //
                currentDurationVirtual += candidat.Duree;

                // preloaded.Add(location, candidat);
                if (selected)
                {
                    standAlone.Add(location, candidat);
                    candidat.select(selectMode.standAlone, limit);

                }
                else if (okDate && _control && !okTotalDuration)
                {
                    if (!limit.LoadDurationLimitAtteinte)
                        log.log("loadCandidats duréée limite atteinte {0}", (currentDuration)); //.TotalMinutes.ToString("0"));
                    limit.LoadDurationLimitAtteinte = true;
                    if (durationStop.Value == 0)
                    {
                        durationStop = currentDuration;
                    }
                    // break; 
                }

                //if (okDate && _control)
                //    currentDuration = newDuration; // += candidat.Duree;
                //   currentDurationVirtual += candidat.Duree;

            }

        }



        private bool control(TrackInfoItunes track, bool select, bool real)
        {
            var loader = getLoader(track.Album);
            return loader.control(track, select, real);
        }

        private FeedLimitItemLoader getLoader(string album)
        {

            FeedLimitItemLoader loader = null;
            if (!loaders.ContainsKey(album))
            {
                loader = new FeedLimitItemLoader(limit, album, parent);
                loaders.Add(album, loader);
                if (parent.state == loadState.selection)
                    loader.phase2();
            }
            else
                loader = loaders[album];
            return loader;
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            currentDurationVirtual = new timeSpan();
            currentContrib = new timeSpan();
            limit.DurationLimitAtteinte = false;
            limit.ContributionLimitAtteinte = false;
            limit.DurationFeedLimit = false;
            limit.NbFeedLimit = false;
            foreach (FeedLimitItemLoader loader in loaders.Values)
                loader.phase2();
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            if (standAlone.ContainsKey(location))
                return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            if (standAlone.ContainsKey(location))
                return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }

        public void Selection()
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;

            if (histo)
                relax.Sort(new PodCastComparer());
            else
                relax.Sort(new PodCastComparerInv());
            selection(relax, false, false);

            var list = legacy.List;
            if (histo)
                list.Sort(new PodCastComparer());
            else
                list.Sort(new PodCastComparerInv());

            selection(list, false, true);



            var list2 = standAlone.List;
            if (histo)
                list2.Sort(new PodCastComparer());
            else
                list2.Sort(new PodCastComparerInv());

            selection(list2, true, true);

        }

        private void selection(ICollection<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.Duration;
            var durationMax = timeSpan.FromMinutes(duration);
            var contributionMax = timeSpan.FromMinutes(limit.Contribution);



            foreach (TrackInfoItunes candidat in list)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;
                if (selected.ContainsKey(location))
                    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Contribute;

                var d = candidat.Pub;
                bool okDate = d <= limit.DateMax;
                var loader = getLoader(candidat.Album);
                bool _control = loader.control(candidat, select, okDate);

                if (!loader.LoadEqSel && Conf.BorderVirtual)
                {

                    if (_control)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                    else if (loader.EndByFd)
                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                }

                if (!loader.LoadEqSel && !increment)
                {
                    //  if (!loader.OkNb)
                    Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                    // if (!loader.OkFd)
                    Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                    limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                }

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {



                   

                    if (okDate && _control)
                        currentDuration += candidat.Duree;
                    currentDurationVirtual += candidat.Duree;

                    var newDuration =  okDate && _control ? currentDuration : currentDurationVirtual;

                    bool okTotalDuration = newDuration <= durationMax;


                    //question fd
                    if (!loader.LoadEqSel)
                    {
                        Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                     loader.OkFd, loader.getDurationStop(okDate)
                     , loader.OkNb, loader.getNbStop(okDate)
                     , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                        limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                        limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                        limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));


                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
                        else if (okDate && okTotalDuration)
                        {
                            if (loader.EndByFd)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
                        }
                        //else if (Conf.BorderVirtual)
                        //{
                        //    if (_control)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
                        //    else if (loader.EndByFd)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
                        //}


                    }

                    if (!loadEqSel)
                    {
                        // question d
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                        else if (okDate && _control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okTotalDuration)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                        }


                        // question date
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                        else if (_control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okDate)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                        }

                    }



                    ////question duree
                    //if (okDate && _control) // || Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
                    //}

                    ////question fd

                    //if (_control)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

                    //    }
                    //}
                    //else //if (!loader.limit.NbFeedLimit)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                    ////question date
                    //if (_control && okDuration)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
                    //    limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
                    //    limit.signal(tb);
                    //}



                    //if (!_control && !Conf.BorderVirtual)
                    //    continue;
                    if (!okDate)
                        continue;

                    if (!_control)
                        continue;
                    if (!okTotalDuration)
                    {
                        if (!Logger.CreateNullLoggers)
                            log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));
                        limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                            durationStop = currentDuration;
                    }

                  

                    if (!newContribut)
                    {

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }
                        use.Add(candidat);
                    }







                    // enregistrement pour stockage et stats
                    limit.Dir.recordTrack(candidat, limit);

                    selected.Add(location, candidat);

                    if (select)
                        exclu.Add(location, candidat);





                }

            }
        }

        public LimitItem Item { get { return limit; } }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;

using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.util;
using pdb.podcast.Report;
using System.Xml;
using pdb.podcast.Selection;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public
    class LimitsLoader
    {
        private DirConf dir;
        private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
        public loadState state;
        private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
            this.limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
            log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void loadCandidats()
        {
            try
            {
                var feeds = Feeds.Instance;
                string feedName = null;
                bool histo = dir.Histo;
                bool? histoAll = dir.HistoAll;
                if (histo && false.Equals(histoAll))
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();



                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null && track.Album != feedName)
                        continue;

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    loaded.Add(track);
                }

                if (histo)
                    loaded.Sort(new PodCastComparer());
                else
                    loaded.Sort(new PodCastComparerInv());



                for (int i = 0; i < Limits.NB; i++)
                {
                    limites[i].loadCandidats(loaded);
                }
            }
            finally
            {
                state = loadState.selection;
            }
        }

        private bool recordGuests;
        public void phase2()
        {
            state = loadState.selection;
            if (dir.Cascading)
                recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        {

            if (!recordGuests)
                return;


            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordGuest(track, item);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
            }
        }


        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                var list = dir.getListe();

                var limits = dir.Limites;
                var usegenPrior = Conf.GenUsePrior;
                var exclugenPrior = Conf.GenExcluPrior;

                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    List<TrackInfoItunes> items;
                    foreach (LimitItemLoader item in limit.Items)
                    {
                        // var index = limit.index(item);
                        if (Conf.WriteItems)
                        {
                            items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                            buildList(item.Item.ID, items, "_sel");
                        }

                        if (Conf.WritePreSel)
                        {
                            items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                            buildList(item.Item.ID, items, "_sel0");
                        }
                        if (Conf.WriteUse)
                        {
                            items = item.use;
                            buildList(item.Item.ID, usegenPrior, items, "_use");
                        }
                        if (Conf.WriteExclu)
                        {
                            var limite = item.Item;
                            items = item.use.FindAll(t => t.Exclu == limite);
                            buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                        }

                    }
                }

                //if (dir.Parent == null)
                //{
                if (dir.Parent == null)
                {

                    var lfolders = dir.Folders;

                    buildListPrior("_auto", list, lfolders);

                    var lHisto = list.FindAll(t => t.Histo);
                    buildList("_histo", lHisto, lfolders);

                    var lPasHisto = list.FindAll(t => !t.Histo);
                    buildList("_pasHisto", lPasHisto, lfolders);

                    var lSerie = list.FindAll(t => t.Serial);
                    buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, folders);
        }
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0; 
            foreach (TrackInfoItunes track in list)
            {
                nb++; 
                writer.StartElement("t");
                writer.SetAttribute("date", track.Pub);
                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }
                    
                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                writer.SetAttribute("track", track.Name);
                if (nb <= nbmax)
                    WriteCause(Program.CauseRegister.Get(track));
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodCastComparer());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (false != dir.HistoAll)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;


                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    writer.StartElement("i");
                    writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());

                    writeTracks(dir, lim.Stat, null, false);

                    writer.EndElement();
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses())
            {
                writer.StartElement("cause");
                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause >0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0; 
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list =  Program.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break; 
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {

            log.log("{0} Selection", dir);

            for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            {
                var limit = limites[i];
                limit.Selection();

            }

        }

    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Selection\CauseRegister.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;

namespace pdb.podcast.Selection
{
    class CauseRegister
    {
        private BgDictString0<Causes> dict = new BgDictString0<Causes>();
        public void Clear() { dict.Clear(); }
        public Causes Get(TrackInfoItunes candidat)
        {
            Causes causes = null;
            string loc = candidat.Location;
            if (!dict.ContainsKey(loc))
            {
                causes = new Causes(candidat);
                dict.Add(loc, causes);
                return causes;
            }
            return dict[loc];
        }
        public void signal(CauseData cd)
        {
            var causes = Get(cd.candidat);
            causes.check(cd.ok, cd.type, cd.val, cd.limit); 
        }

        public List<Causes> getList(bool onlyRejected)
        {
            var list = new List<Causes>(dict.Values);
            list.Sort(new CauseComparer());
            if (!onlyRejected)
                return list;
            else
            {
                var aux = new List<Causes>();
               
                foreach (Causes causes in list)
                {
                    if (!causes.candidat.Selected)
                        aux.Add(causes);
                }
                return list;
            }
            
        }

        private class CauseComparer : IComparer<Causes>
        {
            public int Compare(Causes x, Causes y)
            {
                return x.candidat.Pub.CompareTo(y.candidat.Pub);
            }
        }
    }
}
]]></content>
  </file>
</db>
