<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;

namespace pdb.podcast.Sort
{
    class Album
    {
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        // private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbRepecheForce = 0;
        private static DateTime dateRepeche = DateTime.MaxValue; public static DateTime DateRepeche { get { return dateRepeche; } }
        private static List<TrackSort> repeches = new List<TrackSort>();
        public static int NbRepeches { get { return repeches.Count; } }
        public static int NbModif { get { return nbModif; } }
        private bool done;

        //  bool checkSelected, apply;
        DateTime date0, newDate0;
        DateTime date1;
        public static void Init()
        {
            //lastReads.Clear(); 
            //nbrepeches = 0;
            repeches.Clear();
            nbModif = 0;
            nbRepecheForce = 0;
            dateRepeche = DateTime.MaxValue;
        }

        public static void Bilan()
        {
            if (dateRepeche < DateTime.MaxValue)
                log.log("*************Date minimum:" + dateRepeche);
            repeches.Sort((x, y) => x.Pub2.CompareTo(y.Pub2));
            foreach (TrackSort t in repeches)
                log.log(string.Format("date={0} {1}", t.Pub2, t));
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;
        public static Logger logDebug;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }



        public void init()
        {
            //done = false;
        }

        //public void buildAll()
        //{
        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;

        //    checkSelected = false;
        //    apply = false;

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        var dt = track.Pub2.AddSeconds(1);
        //        date0 = dt;
        //        newDate0 = dt;
        //        build();
        //        if (dt >= Conf.Date0)
        //            break;
        //    }

        //    apply = true;
        //    date0 = Conf.Date0;
        //    newDate0 = Conf.NewDate0;
        //    // writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        writeComment(track, track.Pub2);
        //    }
        //}

        private void build0()
        {
            int count = list.Count;
            if (count == 0)
                return;
            if (album.Album.Equals("TERRE A TERRE"))
            {
            }
            if (album.Album.Equals("Mauvais genres"))
            {
            }


            TrackSort.Date0 = date0;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                            indexNextSelected = i;
                        }
                    }
                    else
                        break;
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;


            var intervalle = conf.getIntervalle(album.Rare, lastRead.DureeEnHeure);
            var intervalleMin = conf.getIntervalleMin(album.Rare, lastRead.DureeEnHeure);
            var intervalleMin0 = conf.getIntervalleMin0(album.Rare);
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = intervalle; // conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    // var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    double rapport = (double)_nbRead / (double)_nbTotal;
                  
                    var coeff = 1 / rapport;

                    if (conf.dureeBornee)
                    {
                        coeff = conf.getCoeff(album.Rare, coeff, lastRead.DureeEnHeure);
                    }

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                   

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                {
                    double _coeff = deltaLimiteEcoule / delta;
                    delta = borne(_coeff, intervalle, intervalleMin);
                }

                if (delta < 1)
                    delta = 1;




                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }





            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();

            DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * delta).truncateToMinute();
            //var cumul = (limitFuture - next.Pub).TotalDays;
            //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
            //if (dtaux > limitFutureRab)
            //    limitFutureRab = dtaux; 
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = delta;
            if (conf.extPente > 0)
                deltaAtterrissage = delta0;


            if (conf.deltaConst || conf.extPente > 0)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                for (int i = indexLastRead + 2; i < count; i++)
                {
                    var t = list[i];
                    if (conf.useVirtuel)
                    {
                        // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                        dt = dt.AddDays(intervalleMin0);
                    }
                    else
                        dt = t.Pub;


                    nb++;
                    if (dt > limitFuture)
                    {
                        nextDate = dt;
                        nblissage++;
                        if (dt <= _deltaMin)
                            continue;
                        if (dt <= _deltaRab)
                            continue;
                        if (nb <= conf.deltaNbMin)
                            continue;
                        if (nblissage <= conf.deltaNbRab)
                            continue;
                        if (dt <= limitFutureRab)
                            continue;

                        break;


                        //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                        //    break;
                    }

                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            //  nb = 0;
            // bool enRetard = limitFuture < date0;
            TrackSort last = next;
            DateTime lastPub2 = limitFuture;
            int indexDepart = indexLastRead + 1;

            bool erased = false;

            for (int i = indexDepart; i < count; i++)
            {
                var t = list[i];
                if (erased && conf.erasedDone)
                {
                    eraseSort(t);
                    continue;
                }

                DateTime dt = lastPub2;

                if (i == indexDepart && !conf.useVirtuel2)
                {
                    dt = limitFuture;
                }
                else
                {

                    //if (conf.deltaCheckSelected)
                    //{
                    //    if (!t.Selected)
                    //        continue;
                    //    if (!t.Enabled)
                    //        continue;
                    //}
                    var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                    if (conf.useVirtuel2)
                        dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                    else
                        dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
                    if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1)
                    {
                        var dt2 = dt;
                        if (conf.useVirtuel2)
                            dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                        else
                            dt2 = lastPub2.AddDays(delta).truncateToMinute();
                        //if (dt2 <= date0)
                        dt = dt2;
                        //else
                        //    dt = date0.AddMinutes(1);
                    }


                }



                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset || erased && conf.erasedDone)
                {
                    erased = true;
                    eraseSort(t);
                }
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }


                    if (dt > DateTime.Now)
                    {
                    }

                    if ((dt - t.Pub).TotalDays > 100)
                    {
                    }

                    writeComment(t, dt);
                    //nb++;
                }


                last = t;
                lastPub2 = dt;


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }

        private void build()
        {
            int count = list.Count;
            if (count == 0)
                return;
            //if (album.Album.Equals("TERRE A TERRE"))
            //{
            //}
            //if (album.Album.Equals("Mauvais genres"))
            //{
            //}


            TrackSort.Date0 = date0;

            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;

            // 1. ordre
            for (int i = 0; i < count; i++)
            {
                var track = list[i];


                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

            //2. si pas recheck on détermine ou on en est

            int index0 = 0;
            int indexCourant = 0;

            TrackSort next = null;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if (track.Selected || track.Pub2 >= date0)
                        {
                            next = track;
                        }
                    }
                    else
                        break;
                }
            }

            if (indexLastRead < 0)
                return;


            indexCourant = indexLastRead;

            if (!conf.recheck)
                index0 = indexCourant;


            while (true)
            {
                if (index0 >= count - 1)
                    break;
                indexLastRead = -1;
                lastRead = null;
                //  int indexNextSelected = -1;
                DateTime lastPlayed = DateTime.MinValue;
                //  TrackSort next = null;

                // 2. Détermination lastRead et next
                for (int i = index0; i < count; i++)
                {
                    var track = list[i];
                    if (track.Played) // && track.PlayedDate > lastPlayed)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        lastRead = track;
                        break;
                    }

                    //else
                    //{
                    //    if (next == null)
                    //    {
                    //        if ((checkSelected && track.Selected) || track.Pub2 >= date0)
                    //        {
                    //            next = track;
                    //            indexNextSelected = i;
                    //        }
                    //    }
                    //    else
                    //        break;
                    //}
                }


                if (indexLastRead < 0)
                    return;


                var intervalle = conf.getIntervalle(album.Rare, lastRead.DureeEnHeure);
                var intervalleMin = conf.getIntervalleMin(album.Rare, lastRead.DureeEnHeure);
                var intervalleMin0 = conf.getIntervalleMin0(album.Rare);
                var atterissageMin = conf.getAtterrissageMin(album.Rare);
                double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
                DateTime pub2 = lastRead.Pub2;

                double delta0Corr = deltaLastRead0;

                double cumulMin = conf.getCumulMin(album.Rare);
                double cumulMax = conf.getCumulMax(album.Rare);

                if (pub2 > lastRead.Pub && conf.extPente == 0)
                {
                    if (conf.elastique < 1)
                    {
                        delta0Corr = deltaLastRead0 * conf.elastique;
                        pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                    }


                    //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                    //{
                    //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                    //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                    //}
                }




                var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

                //int nbReads = 0;
                //int nbTotals = 0;

                int nbRead = 0;
                int nbTotal = 0;

                //int _nbRead = 0;
                int _nbTotal = 0;
                double delta = intervalle; // conf.getIntervalle(album.Rare);
                double delta0 = delta;
                var _histo = conf.getHisto(album.Rare);
                if (_histo > 0)
                {

                    double histo = _histo;




                    DateTime limit = lastRead.Pub.AddDays(-histo);
                    for (int i = indexLastRead; i >= 0; i--)
                    {
                        var t = list[i];
                        var dt = t.Pub;
                        if (dt < limit && nbTotal >= conf.totalMin)
                            break;

                        if (t.Played)
                            nbRead++;


                        nbTotal++;

                    }

                    _nbTotal = nbTotal;

                    if (nbRead > 0 && _nbTotal > 0)
                    {
                        if (_nbTotal < conf.totalMin)
                            _nbTotal = conf.totalMin;
                        //  album.Rare ? conf.intervalleR : conf.intervalle;
                        double rapport = (double)nbRead / (double)_nbTotal;
                        var recup = intervalleMin0 - atterissageMin;

                        delta = intervalleMin0 + recup * (1 - rapport) / rapport;

                        var coeff = 1 / rapport;

                        if (conf.dureeBornee)
                        {
                            coeff = conf.getCoeff(album.Rare, coeff, lastRead.DureeEnHeure);
                        }


                        //0.1 => 10
                        //0.9 => 1.11
                        //coeff -= 1; // 9  0.11
                        //var dminmax = intervalle - intervalleMin;

                        var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                        if (_delta < delta)
                            delta = _delta;
                        else
                        {
                        }

                    }

                    //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


                }



                if (conf.extPente > 0)
                {
                    var d0 = (DateTime.Now - pub2).TotalDays;
                    var dl = conf.extDelta;
                    if (dl == 0)
                    {
                        dl = d0;
                    }

                    delta0 = d0 / conf.extPente;
                    delta = delta0;
                    //01/01/2014 ->01/01/2017
                    //04/01/2017 -> 04/01/2014
                    var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                    var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                    log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                    if (deltaLimiteEcoule > delta)
                    {
                        double _coeff = deltaLimiteEcoule / delta;
                        delta = borne(_coeff, intervalle, intervalleMin);
                    }

                    if (delta < 1)
                        delta = 1;




                    //if (delta > intervalle)
                    //    delta = intervalle;
                }

                if (conf.limitRead && deltaLecture > intervalle)
                {
                    //13 /10 ->7
                    var _old = delta;

                    delta += intervalle - deltaLecture;
                    log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
                }





                if (delta < intervalleMin)
                    delta = intervalleMin;

                if (delta > intervalle)
                    delta = intervalle;



                DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
                TrackSort _next = list[indexLastRead + 1];
                double ecart = (limitFuture - _next.Pub).TotalDays;

                DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * ecart).truncateToMinute();
                //var cumul = (limitFuture - next.Pub).TotalDays;
                //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
                //if (dtaux > limitFutureRab)
                //    limitFutureRab = dtaux; 
                DateTime nextDate = limitFuture;

                int nb = 0;
                int nblissage = 0;
                double deltaAtterrissage = intervalleMin;

                if (conf.noCollision)
                    deltaAtterrissage = delta;
                if (conf.extPente > 0)
                    deltaAtterrissage = delta0;
                string causes = "";

                if (conf.deltaConst || conf.extPente > 0)
                {
                }

                else
                {
                    var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                    var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                    DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                    var sbCause = new StringBuilder();

                    for (int i = indexLastRead + 2; i < count; i++)
                    {
                        var t = list[i];
                        if (conf.useVirtuel)
                        {
                            // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                            dt = dt.AddDays(intervalleMin0);
                        }
                        else
                            dt = t.Pub;


                        nb++;
                        if (dt > limitFuture)
                        {
                            sbCause = new StringBuilder();
                            nextDate = dt;
                            nblissage++;

                            int nbCause = 0;
                            if (dt <= _deltaMin)
                            {
                                sbCause.Append(" deltaMin");
                                nbCause++;
                            }
                            if (dt <= _deltaRab)
                            {
                                sbCause.Append(" deltaRab");
                                nbCause++;
                            }
                            if (nb <= conf.deltaNbMin)
                            {
                                sbCause.Append(" deltaNbMin");
                                nbCause++;
                            }
                            if (nblissage <= conf.deltaNbRab)
                            {
                                sbCause.Append(" deltaNbRab");
                                nbCause++;
                            }
                            if (dt <= limitFutureRab)
                            {
                                sbCause.Append(" coeffRab");
                                nbCause++;
                            }

                            if (nbCause > 0)
                            {
                                causes = sbCause.ToString();
                                continue;
                            }


                            break;


                            //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                            //    break;
                        }

                    }

                    if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                    {
                        deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (deltaAtterrissage > intervalleMin)
                            deltaAtterrissage = intervalleMin;
                    }
                }

                if (deltaAtterrissage < atterissageMin)
                {
                    causes += " corrigé atterrissageMin";
                    deltaAtterrissage = atterissageMin; 

                }

                var tsatt = timeSpan.FromDays(deltaAtterrissage);
                if (tsatt.TotalMinute < 1)
                    tsatt = timeSpan.FromMinutes(1);

                string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

                var str = string.Format("{0} {1}/{2} [{3}] {4} {5} ({6}) lecture={7} causes={8}", deltas, nbRead, nbTotal, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"), causes);

                if (index0 >= indexCourant)
                    log.log(str);
                else
                    logDebug.log(str);


                //  nb = 0;
                // bool enRetard = limitFuture < date0;
                TrackSort last = lastRead;
                DateTime lastPub2 = limitFuture;
                int indexDepart = indexLastRead + 1;



                for (int i = indexDepart; i < count; i++)
                {
                    var t = list[i];


                    DateTime dt = lastPub2;

                    if (i == indexDepart && !conf.useVirtuel2)
                    {
                        dt = limitFuture;
                    }
                    else
                    {


                        var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                        if (conf.useVirtuel2)
                            dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                        else
                            dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
                        if (conf.deltaConstLate >= 0 && t.track.Selected && dt < date1)
                        {
                            var dt2 = dt;
                            if (conf.useVirtuel2)
                                dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                            else
                                dt2 = lastPub2.AddDays(delta).truncateToMinute();
                            //if (dt2 <= date0)
                            dt = dt2;
                            //else
                            //    dt = date0.AddMinutes(1);
                        }


                    }



                    var _delta = (dt - lastRead.Pub2).TotalDays;
                    if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    {

                        eraseSort(t);
                    }
                    else
                    {
                        if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                        {
                            var __delta = (dt - t.Pub).TotalDays;
                            if (__delta > cumulMin)
                            {
                                __delta = borneCumul(__delta, cumulMin, cumulMax);
                                dt = t.Pub.AddDays(__delta).truncateToMinute();
                            }
                        }


                        if (dt > DateTime.Now)
                        {
                        }

                        if ((dt - t.Pub).TotalDays > 100)
                        {
                        }

                        writeComment(t, dt);
                        //nb++;
                    }


                    last = t;
                    lastPub2 = dt;
                    index0 = i;

                    if (t.Played)
                    {
                        break;
                    }
                }
            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }


        public void Build()
        {
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            //if (conf.enabled == sortMode.histo)
            //{
            //    buildAll();
            //    return;
            //}
            //else
            //{
            //checkSelected = true;
            //apply = true;
            date0 = Conf.Date0;
            if (conf.deltaConstLate >= 0)
                date1 = date0.AddDays(conf.deltaConstLate);
            newDate0 = Conf.NewDate0;
            if (conf.extPente > 0 || conf.oldMode)
                build0();
            else
                build();
            return;
            //  }

            #region old
            /* if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true, true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, true);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, true, true, Conf.Date0, Conf.NewDate0);
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            */
            #endregion


        }



        private void eraseSort(TrackSort track)
        {
            writeComment(track, track.Pub);
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (!checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = track.Pub;
            //    return;
            //}

            ////if (!force && !track.Selected)
            ////    return;
            //if (conf.canGoBack || conf.enabled == sortMode.reset)
            //{
            //    if (!track.Played && track.Enabled)
            //    {
            //        DateTime pub = track.Pub;
            //        if (track.Pub2 >= date0 && pub <date0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //        else if (track.Pub2 >=newDate0 && pub < newDate0)
            //        {
            //            log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
            //            repeches.Add(track);
            //            // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
            //            if (pub < dateRepeche)
            //                dateRepeche = pub;
            //        }
            //    }

            //    //}
            //    //else
            //    //{
            //    if (track.Pub2 != track.Pub)
            //        nbModif++;
            //    track.Pub2 = track.Pub;
            //    //}
            //    track.track.BuildComment();
            //    // writeComment(track);
            //}
        }

        //private void applyPub(TrackSort track)
        //{
        //    writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);
        //}

        private void writeComment(TrackSort track, DateTime dt)
        {
            dt = dt.truncateToMinute();
            //bool go = apply;
            //if (!go)
            //{
            //    go = true;
            //    if (checkSelected && !track.track.Selected)
            //        go = false;
            //}
            //if (!go)
            //{
            //    track.Pub2 = dt;
            //    return;
            //}



            //if (checkSelected && !track.Selected)
            //    return;


            if (conf.canGoBack)
            {
                if (!track.Played && track.Enabled)
                {
                    if (track.pub20 >= date0 && dt < date0)
                    {
                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            repeches.Add(track);
                        }
                        if (dt < dateRepeche)
                            dateRepeche = dt;
                    }

                    else if (track.pub20 >= newDate0 && dt < newDate0)
                    {

                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.pub20, dt, newDate0);
                            repeches.Add(track);
                        }

                        if (dt < dateRepeche)
                            dateRepeche = dt;

                    }
                }
            }
            else
            {
                if (dt == track.pub20)
                {
                    logDebug.log("\t{0}\t{1} {2}", track.Pub, dt, track.Name);
                    return;
                }
                else if (dt < track.pub20)
                {
                    logDebug.log("\t{0}\t{1}<=\t{2} {3}", track.Pub, track.pub20, dt, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var strDelta = delta.ToString("0.0");

            if (track.pub20 != dt)
            {

                if (track.pub20.truncateToMinute() != dt)
                {
                    //if (track.track.Selected)
                    //{
                    nbModif++;

                    var str = string.Format("\t{0}\t{1}=>\t{2}({3}) {4}", track.Pub, track.pub20, dt, strDelta, track.Name);
                    if (track.track.Selected)
                        log.log(str);
                    else
                        logDebug.log(str);
                    //}
                }
                track.Pub2 = dt;
            }
            else if (track.pub20 > track.Pub)
            {
                // if (track.track.Selected)
                var str = string.Format("\t{0}\t{1}({2}) {3}", track.Pub, track.pub20, strDelta, track.Name);
                if (track.track.Selected)
                    log.log(str);
                else
                    logDebug.log(str);
            }
            else
            {
                var str = string.Format("\t{0} ({1}) {2}", track.Pub, strDelta, track.Name);
                logDebug.log(str);
            }


            track.track.BuildComment();
        }

        private static double borne(double coeff, double intervalle, double intervalleMin)
        {
            if (coeff <= 1)
                return coeff * intervalleMin;
            coeff -= 1; // 9  0.11
            var dminmax = intervalle - intervalleMin;

            var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

            return _delta;
        }

        private static double borneCumul(double delta, double cumulMin, double cumulMax)
        {
            if (cumulMin < 0 || cumulMax < 0)
                return delta;
            if (delta < cumulMin)
                return delta;
            var coeff = delta / cumulMin;
            return borne(coeff, cumulMax, cumulMin);
        }
    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Sort.cs">
    <content><![CDATA[using System.Xml;
using pdb.util;
using System;
using System.Collections.Generic;
using pdb.podcast.Albums;

namespace pdb.podcast.Tuning.Sort
{
    public enum sortMode
    {
        no,
        reset,
        once,
        once_all,
        all,
      //  histo
    }

    public enum histoMode
    {
        /// <summary>
        /// Démarrage de l'histo sur Date0
        /// </summary>
        fix,
        /// <summary>
        /// Démarrage de l'histo sur le premier sélectionné
        /// </summary>
        selected,
        /// <summary>
        /// Démarrage de l'histo sur le dernier lu
        /// </summary>
        read

    }
    public class SortItem : SelectParamBase
    {
        /// <summary>
        /// nom de l'album ou suite d'albums
        /// </summary>
        new public List<string> name = new List<string>();

        public sortMode enabled;
        public bool checkBefore;
        ///// <summary>
        ///// prise en compte des longs podcasts
        ///// </summary>
        //public double dureeMin;
        /// <summary>
        /// intervalle max entre deux écoutes (une semaine)
        /// </summary>
        private double intervalle = 7;
        /// <summary>
        /// intervalle min entre deux écoutes (un jour)
        /// </summary>
        private double intervalleMin = 1;
        /// <summary>
        /// intervalle standard entre deux écoutes (un jour)
        /// </summary>
        private double intervalleMin0 = 1;
        /// <summary>
        /// intervalle max entre deux écoutes pour un rare
        /// </summary>
        private double intervalleR;
        /// <summary>
        /// intervalle min entre deux écoutes pour un rare
        /// </summary>
        private double intervalleMinR = 7;
        /// <summary>
        /// intervalle standard entre deux écoutes pour un rare
        /// </summary>
        private double intervalleMinR0 = 7;
        /// <summary>
        /// coeff intervalle par heure du dernier lu
        /// </summary>
        public double rapportDuree = 0;
        /// <summary>
        /// coeff intervalle par heure du dernier lu rare
        /// </summary>
        public double rapportDureeR = 0;
        /// <summary>
        /// On ne prend en compte la durée que pour augmenter le coeff mais pas les bornes
        /// </summary>
        public bool dureeBornee;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMin; 
        /// </summary>
        public bool minUseDuree = true;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMin pour les rares
        /// </summary>
        public bool minUseDureeR = true;
        /// <summary>
        /// On utilise la durée dans le calcul d'intervalleMax 
        /// </summary>
        public bool maxUseDuree = true;
        ///  <summary>
        /// On utilise la durée dans le calcul d'intervalleMax pour les rares
        /// </summary>
        public bool maxUseDureeR = true;
        ///// <summary>
        ///// nb d'écoutes maximum dans l'intervalle (typiquement 5)
        ///// </summary>
        //private double ecouteMax;
        ///// <summary>
        ///// nb d'écoutes maximum dans l'intervalle pour un rare
        ///// </summary>
        //private double ecouteMaxR;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute
        /// </summary>
        private double histo;
        /// <summary>
        /// durée sur laquelle on fait des stats pour calculer la fréquence d'écoute pour un rare
        /// </summary>
        private double histoR;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : nombre minimum d'éléments à prendre en compte
        /// </summary>
        public int deltaNbMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'éléments à prendre en compte
        /// </summary>
        public int deltaNbRab;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : intervalle minimum à prendre en compte en jours
        /// </summary>
        public double deltaMin;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'intervalle à prendre en compte
        /// </summary>
        public double deltaRab;
        /// <summary>
        /// Dans le calcul de delta entre deux à suivre : rab d'intervalle à prendre en compte, en proportion de l'écart initial
        /// </summary>
        public double coeffRab;
        /// <summary>
        /// Ecart min entre deux podcasts non rares à l'atterrissage
        /// </summary>
        public double atterrissageMin = 0.5;
        /// <summary>
        /// Ecart min entre deux podcasts rares à l'atterrissage
        /// </summary>
        public double atterrissageMinR = 1; 

        /// <summary>
        /// pas d'empilage des tracks repoussés
        /// </summary>
        public bool noCollision;
        /// <summary>
        /// recalcul peut entrainer une date plus récente
        /// </summary>
        public bool canGoBack;
        /// <summary>
        /// recalcul peut entrainer une date plus récente, mais si ça le rend non séléctionné, on bricole pour qu'il soit quand même selectionné
        /// </summary>
        public bool canGoBackButForceSelected;
        /// <summary>
        /// écart constant entre les poscasts repoussés
        /// </summary>
        public bool deltaConst;

        /// <summary>
        /// Date0 lors de l'écoute du dernier podcast externe
        /// </summary>
        public DateTime extLast0;
        /// <summary>
        /// Décalage entre date du podcast supplémentaire et la date0
        /// </summary>
        public double extDelta;
        /// <summary>
        /// coefficient permettant le calcul de la prochaine date en fonction du retard entre la date0 et maintenant
        /// </summary>
        public double extPente;
        /// <summary>
        /// check de la date de dernière lecture
        /// </summary>
        public bool limitRead;
        ///// <summary>
        ///// Dans le calcul de delta ne pas inclure les non-selectionnés
        ///// </summary>
        //public bool deltaCheckSelected;
        /// <summary>
        /// handicap pour les nouveaux podcasts
        /// </summary>
        public int totalMin;
        /// <summary>
        /// Coefficient de rappel vers la valeur initiale 
        /// </summary>
        public double elastique = 1;

        /// <summary>
        /// Cumul max de retard pour les non-rares
        /// </summary>
        public double cumulMax = -1;

        /// <summary>
        /// Cumul max de retard pour les rares
        /// </summary>
        public double cumulMaxR = -1;

        /// <summary>
        /// Cumul min de retard pour les non-rares
        /// </summary>
        public double cumulMin = -1;

        /// <summary>
        /// Cumul min de retard pour les rares
        /// </summary>
        public double cumulMinR = -1;

        /// <summary>
        /// Pas d'amortissement pour les vieux podcasts, vieux en jours par rapport à la date0
        /// </summary>
        public int deltaConstLate=-1;

        /// <summary>
        /// Utilisation de track virtuels pour éviter accidents (tracks manquants)
        /// </summary>
        public bool useVirtuel;

        /// <summary>
        /// Utilisation de track virtuels pour affectation pub2
        /// </summary>
        public bool useVirtuel2;

        /// <summary>
        /// Dès la pub2 remise à zero, les suivants aussi
        /// </summary>
        public bool erasedDone;
        /// <summary>
        /// On recalcule tout
        /// </summary>
        public bool recheck;
        /// <summary>
        /// on fait comme avant
        /// </summary>
        public bool oldMode; 

        public histoMode histoMode;

        private ITrackSelector selector;

        public SortItem()
        {
        }

        public SortItem(XmlElement parent, XmlElement node)
            : base(parent, node)
        {

            if (node == null)
                return;
            var str = "";
            builds("name", v => str = v);

            if (!string.IsNullOrEmpty(str))
            {
                foreach (string album in str.Split('|'))
                {
                    if (!string.IsNullOrWhiteSpace(album))
                        name.Add(album.ToLowerWithoutDiacritics());
                }
            }

            builds("enabled", v => str = v);

            if (!string.IsNullOrEmpty(str))
                enabled = (sortMode)Enum.Parse(typeof(sortMode), str);

            buildd("dureeMin", v => dureeMin = v);
            buildd("intervalle", v => intervalle = v);
            buildd("intervalleMin", v => intervalleMin = v);
            buildd("intervalleMin0", v => intervalleMin0 = v);
            buildd("intervalleR", v => intervalleR = v);
            buildd("intervalleMinR", v => intervalleMinR = v);
            buildd("intervalleMinR0", v => intervalleMinR0 = v);

            buildd("atterrissageMin", v => atterrissageMin = v);
            buildd("atterrissageMinR", v => atterrissageMinR = v);
            buildd("histo", v => histo = v);
            buildd("histoR", v => histoR = v);
            //buildd("ecouteMax", v => ecouteMax = v);
            //buildd("ecouteMaxR", v => ecouteMaxR = v);

            buildDate("extLast0", v => extLast0 = v);
            buildd("extDelta", v => extDelta = v);
            buildd("extPente", v => extPente = v);




            buildb("deltaConst", v => deltaConst = v);
            buildi("deltaConstLate", v => deltaConstLate = v);
            buildb("useVirtuel", v => useVirtuel = v);
            buildb("useVirtuel2", v => useVirtuel2 = v);

            buildb("noCollision", v => noCollision = v);
            buildb("checkBefore", v => checkBefore = v);
            buildb("limitRead", v => limitRead = v);
            buildb("canGoBack", v => canGoBack = v);
            // buildb("deltaCheckSelected", v => deltaCheckSelected = v);

            #region lissage
            buildi("deltaNbMin", v => deltaNbMin = v);
            buildi("deltaNbRab", v => deltaNbRab = v);

            buildd("deltaMin", v => deltaMin = v);
            buildd("deltaRab", v => deltaRab = v);

            #endregion

            builds("histoMode", v => str = v);
            histoMode = (histoMode)Enum.Parse(typeof(histoMode), str);

            buildi("totalMin", v => totalMin = v);

            buildd("elastique", v => elastique = v);


            buildd("cumulMin", v => cumulMin = v);
            buildd("cumulMinR", v => cumulMinR = v);
            buildd("cumulMax", v => cumulMax = v);
            buildd("cumulMaxR", v => cumulMaxR = v);
            buildd("rapportDuree", v => rapportDuree = v);
            buildd("rapportDureeR", v => rapportDureeR = v);
            buildd("coeffRab", v => coeffRab = v);


            buildb("dureeBornee", v => dureeBornee = v);
            buildb("minUseDuree", v => minUseDuree = v);
            buildb("maxUseDuree", v => maxUseDuree = v);

            buildb("minUseDureeR", v => minUseDureeR = v);
            buildb("maxUseDureeR", v => maxUseDureeR = v);

            buildb("erasedDone", v => erasedDone = v);
            buildb("recheck", v => recheck = v);
            buildb("oldMode", v => oldMode = v);

            this.selector = new TrackSelector(this);
        }
        /// <summary>
        /// donne l'intervalle plafond
        /// </summary>
        /// <param name="rare">album rare</param>
        /// <param name="duree">duree du dernier track en heures</param>
        /// <returns></returns>
        public double getIntervalle(bool rare, double duree)
        {
            var ret0 = rare && intervalleR > 0 ? intervalleR : intervalle;
            if (applyDuree(false, rare))
            {
                var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
                if (coeff > 1)
                    return ret0 * coeff;
            }
            return ret0;
        }

        public double getRapport(bool rare, double duree)
        {
            var rapport0 = rare ? intervalleR / intervalleMinR0 : intervalle / intervalleMin0;
            var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
            if (coeff > 1)
                return rapport0 * coeff;
            return rapport0; 
        }

        public bool applyDuree(bool min, bool rare)
        {
            if (dureeBornee)
                return false;
            bool use = rare ? (min ? minUseDureeR : maxUseDureeR) : (min ? minUseDuree : maxUseDuree);
            return use;
        }
        public double getIntervalleMin(bool rare, double duree)
        {
            var ret0 = rare && intervalleMinR > 0 ? intervalleMinR : intervalleMin;
            if (applyDuree(true, rare))
            {
                var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
                if (coeff > 1)
                    return ret0 * coeff;
            }
            return ret0;
        }

        public double getCoeff(bool rare, double coeff0, double duree)
        {
            if (dureeBornee)
            {
                var coeff = rare ? duree * rapportDureeR : duree * rapportDuree;
                if (coeff > 1)
                    return coeff0 * coeff;
            }
            return coeff0;

        }


        public double getIntervalleMin0(bool rare)
        {
            var ret0 = rare && intervalleMinR0 > 0 ? intervalleMinR0 : intervalleMin0;
            return ret0;
        }
        public double getHisto(bool rare)
        {
            return rare && histoR > 0 ? histoR : histo;
        }
        //public double getEcouteMax(bool rare)
        //{
        //    return rare && ecouteMaxR > 0 ? ecouteMaxR : ecouteMax;
        //}
        ///// <summary>
        ///// Donne le recalage max par morceau pour atterissage: typiquement pour un non-rare :0.5, pour un rare, disons 1
        ///// </summary>
        ///// <param name="rare"></param>
        ///// <returns></returns>
        //public double getRecupMax(bool rare)
        //{
        //    double ini = getIntervalleMin0(rare);
        //    if (rare)
        //        return ini - atterrissageMinR;
        //    else
        //        return ini - atterrissageMin; 
        //}

        public double getAtterrissageMin(bool rare)
        {
            return rare ? atterrissageMinR : atterrissageMin; 
        }

        internal bool select(ISelectable album)
        {
            return selector.select(album);
        }

        public double getCumulMax(bool rare)
        {
            return rare && cumulMaxR > 0 ? cumulMaxR : cumulMax;
        }
        public double getCumulMin(bool rare)
        {
            return rare && cumulMinR > 0 ? cumulMinR : cumulMin;
        }


    }
    public class Sort : SortItem
    {
        private List<SortItem> items = new List<SortItem>();
        private List<SortItem> rules = new List<SortItem>();

        public SortItem getItem(string key)
        {
            foreach (SortItem g in items)
            {
                if (g.name.Contains(key))
                    return g;

            }
            return null;
        }

        public SortItem getRule(TrackAlbum album)
        {
            foreach (SortItem r in rules)
            {
                if (r.select(album))
                    return r;
            }

            return null;
        }
        public Sort()
        {

        }

        public Sort(XmlElement node)
            : base(null, node)
        {
            if (node == null)
                return;
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    if (sub.Name == "album")
                    {
                        items.Add(new SortItem(node, sub as XmlElement));
                    }
                    else if (sub.Name == "rule")
                    {
                        rules.Add(new SortItem(node, sub as XmlElement));
                    }
                }
            }


        }




    }
}]]></content>
  </file>
</db>
