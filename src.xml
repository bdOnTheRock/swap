<db path="C:\Bernard\db1\PieceDb3Ref">
   <file path="\pdb.podcast\Load\FeedLimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;

namespace pdb.podcast.Load
{
    public enum loadState
    {
        loadCandidat,
        standAlone,
        selection,
        end
    }
    public enum depotType
    {
        load,
        rapporte
    }
    /// <summary>
    /// Chargeur des pistes associées à un item de limite sur un dossier
    /// </summary>
    class FeedLimitItemLoader
    {
        private loadState state;
        /// <summary>
        /// Répertoire
        /// </summary>
        private DirConf dir;
        /// <summary>
        /// Limite
        /// </summary>
        public readonly LimitItem limit;
        /// <summary>
        /// Album
        /// </summary>
        private string album;
        /// <summary>
        /// Chargeur de limite
        /// </summary>
        private LimitsLoader parent;


        /// <summary>
        /// Nombre de piste max
        /// </summary>
        int nbMax;
        int loadNbMax;
        /// <summary>
        /// Durée cumulée max
        /// </summary>
        TimeSpan durationMax;
        TimeSpan loadDurationMax;

        ///// <summary>
        ///// Date de publication min
        ///// </summary>
        //DateTime dateMin;

        // private Logger logger;
        private Logger logLimit;
        private Logger logItem;

        /// <summary>
        /// Durée cumulée
        /// </summary>
        TimeSpan currentDuration = new TimeSpan();

        /// <summary>
        /// Nombre total
        /// </summary>
        int nb = 0;


        public void phase2()
        {
            currentDuration = new TimeSpan();
            nb = 0;
            state = loadState.selection;
        }




        public FeedLimitItemLoader(LimitItem limit, string album, LimitsLoader parent)
        {
            this.dir = limit.Dir;
            this.limit = limit;

            this.parent = parent;
            this.album = album;


            nbMax = limit.Nb;


            var feedDuration = limit.FeedDuration;
            int rating = limit.Rating;
            durationMax = TimeSpan.FromMinutes(feedDuration);


            loadDurationMax = durationMax;
            loadNbMax = nbMax;

            if (limit.Dir.Cascading)
            {
                if (limit.LoadNb > nbMax)
                    loadNbMax = limit.LoadNb;
                if (limit.LoadFeedDuration > feedDuration)
                    loadDurationMax = TimeSpan.FromMinutes(limit.LoadFeedDuration);

            }

            logItem = Logger.getLogger(limit.ID + "\\" + album, null, false);
            logLimit = limit.Logger;
        }

        private void log(string txt)
        {
            logLimit.log(txt);
            logItem.log(txt);
        }

        private void log(string txt, params object[] other)
        {

            logLimit.log(txt, other);
            logItem.log(txt, other);
        }




        public bool control(TrackInfoItunes track, bool select, bool real)
        {
            if (state == loadState.end)
                return false;


            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return false;



            string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration.TotalMinutes.ToString("0"), track.ToString());
            string phase = select ? "ctl" : "load";


            log("-->  {0} ok {1} ", phase, str);

            var ok = checkStatus(string.Format("-->  {0}", phase), select, track, limit, real);

            if (!ok)
                return false;

            if (select)
            {
                var selected = selectMode.simple;
                if (dir.Histo)
                {
                    selected = selectMode.serial;
                    if (dir.HistoAll.HasValue && dir.HistoAll.Value)
                        selected = selectMode.histo;
                }
                else
                {
                    //if (!candidat.Serial && !candidat.Histo)
                    selected = selectMode.simple;
                }

                track.select(selected, limit);
                Feeds.Instance.recordTrack(track, limit);
            }

            //report aux niveaux inférieurs
            if (real)
                parent.recordLimitItemCandidat(track, limit);
            return true;
        }




        private bool checkStatus(string phase, bool select, TrackInfoItunes track, LimitItem itemSource, bool real)
        {
            bool ret = true;
            string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration.TotalMinutes.ToString("0"), track.ToString());

            var _nb = nb + 1;

            var dur = currentDuration + track.Duration;

            int _nbMax = select ? this.nbMax : this.loadNbMax;
            TimeSpan _durationMax = select ? this.durationMax : this.loadDurationMax;


            // vérification des valeurs cumulées
            if (dur >= _durationMax)
            {
                ret = false;
                if (real)
                {
                    limit.DurationFeedLimit = true;
                    log("{0} stop d. {1} ", phase, str);
                    state = loadState.end;
                }

                if (select || durationMax == loadDurationMax)
                {
                    if (real)
                        limit.checkBorderFd(track, dur, false);
                }


               
            }
            else
            {
                if (select || durationMax == loadDurationMax)
                {
                    limit.checkBorderFd(track, dur, true);
                }
            }




            if (_nb > _nbMax)
            {
                if (real)
                {
                    limit.NbFeedLimit = true;
                    log("{0} stop nb {1} ", phase, str);
                    state = loadState.end;
                }


                ret = false;
            }



            if (real)
            {
                nb = _nb;
                currentDuration = dur;
            }

            return ret;

        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;

namespace pdb.podcast.Load
{
    class LimitItemLoader
    {
        private LimitItem limit;
        private LimitsLoader parent;
        private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();
        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        private Logger log;
        TimeSpan currentDuration = new TimeSpan();
        TimeSpan currentContrib = new TimeSpan();
        TimeSpan trackDurationMax;
        TimeSpan trackDurationMin;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            log = limit.Logger;

            trackDurationMax = TimeSpan.FromMinutes(limit.Td);
            trackDurationMin = TimeSpan.FromMinutes(limit.TdMin);
        }

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var duration = limit.Duration;
            if (limit.Dir.Cascading)
            {
                var dd = limit.LoadDuration;
                if (dd > duration)
                    duration = dd;
            }
            var durationMax = TimeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                bool real = limit.checkPub(candidat);


                bool _control = control(candidat, false, real);

                bool selected = real && _control && currentDuration < durationMax;

                limit.checkBorderDates(candidat, selected);

                // preloaded.Add(location, candidat);
                if (selected)
                {
                    standAlone.Add(location, candidat);
                    candidat.select(selectMode.standAlone, limit);
                    currentDuration += candidat.Duration;
                }
                else if (currentDuration >= durationMax)
                {
                    if (!limit.LoadDurationLimitAtteinte)
                        log.log("loadCandidats duréée limite atteinte {0}", (currentDuration).TotalMinutes.ToString("0"));
                    limit.LoadDurationLimitAtteinte = true;
                }







            }

        }

        private bool control(TrackInfoItunes track, bool select, bool real)
        {
            var loader = getLoader(track.Album);
            return loader.control(track, select, real);
        }

        private FeedLimitItemLoader getLoader(string album)
        {

            FeedLimitItemLoader loader = null;
            if (!loaders.ContainsKey(album))
            {
                loader = new FeedLimitItemLoader(limit, album, parent);
                loaders.Add(album, loader);
                if (parent.state == loadState.selection)
                    loader.phase2();
            }
            else
                loader = loaders[album];
            return loader;
        }

        public void phase2()
        {
            currentDuration = new TimeSpan();
            currentContrib = new TimeSpan();
            limit.DurationLimitAtteinte = false;
            limit.ContributionLimitAtteinte = false;
            limit.DurationFeedLimit = false;
            limit.NbFeedLimit = false;
            foreach (FeedLimitItemLoader loader in loaders.Values)
                loader.phase2();
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            if (standAlone.ContainsKey(location))
                return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duration <= trackDurationMax && track.Duration >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            if (standAlone.ContainsKey(location))
                return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duration <= trackDurationMax && track.Duration >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }

        public void Selection()
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;

            if (histo)
                relax.Sort(new PodCastComparer());
            else
                relax.Sort(new PodCastComparerInv());
            selection(relax, false, false);

            var list = legacy.List;
            if (histo)
                list.Sort(new PodCastComparer());
            else
                list.Sort(new PodCastComparerInv());

            selection(list, false, true);



            var list2 = standAlone.List;
            if (histo)
                list2.Sort(new PodCastComparer());
            else
                list2.Sort(new PodCastComparerInv());

            selection(list2, true, true);

        }

        private void selection(ICollection<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.Duration;
            var durationMax = TimeSpan.FromMinutes(duration);
            var contributionMax = TimeSpan.FromMinutes(limit.Contribution);



            foreach (TrackInfoItunes candidat in list)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;
                if (selected.ContainsKey(location))
                    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Contribute;


                if (!control(candidat, select, true))
                    continue;
                if (increment)
                {
                    currentDuration += candidat.Duration;
                    if (currentDuration > durationMax)
                    {
                        log.log("duration {0}", (currentDuration).TotalMinutes.ToString("0"));
                        limit.DurationLimitAtteinte = true;
                        limit.checkBorderDuration(candidat, currentDuration, false);

                        break;
                    }
                    else
                    {
                        if (!newContribut)
                        {

                            currentContrib += candidat.Duration;
                            if (currentContrib > contributionMax)
                            {
                                log.log("contribution {0}", (currentContrib).TotalMinutes.ToString("0"));
                                limit.ContributionLimitAtteinte = true;
                                break;
                            }
                            use.Add(candidat);
                        }
                        limit.checkBorderDuration(candidat, currentDuration, true);
                    }


                    // enregistrement pour stockage et stats
                    limit.Dir.recordTrack(candidat, limit);

                    selected.Add(location, candidat);

                    if (select)
                        exclu.Add(location, candidat);





                }

            }
        }

        public LimitItem Item { get { return limit; } }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.util;
using pdb.ordo.conf;
using pdb.podcast.Auto;

namespace pdb.podcast.Tuning
{
   public enum menage
   {
       none,
       read,
       name
   }
   public class Conf
   {
       //private static string CONF_FILE = @"..\conf.xml";
       #region membres
       private DirConf root;
       private bool buildLimitMulti;
       private bool single;
       private Move move;
       private bool deleteDoublon;
       private bool getDescription;
       private int volumeMin = int.MinValue;
       private bool simulation;
       private string copyAll;
       private int maxScan = 10;
       private ConfOrdo ordo = new ConfOrdo();
       private menage menage = menage.none;
       // private string zique;
       private bool writePlayLists;
       private bool writePreSel;
       private bool writeItems;
       private bool writeUse;
       private bool writeExclu;
       private bool genFeed;
       private int genFeedPrior = 11;
       private int genUsePrior = 11;
       private int genExcluPrior = 11;
       private bool transmit = true;
       private bool transmitTotal = true;
       private bool transmitTotalGuest = true;
       private bool? cascading = null;
       private bool autoBlock;

       private ConfDate dates = new ConfDate();

       private List<SelectParam> selectParams = new List<SelectParam>();
       private Journal journal;
       private string rootIt = "auto";
       private bool onlyEnabled = true;
       private bool onlyUnRead = true;

       // private Auto auto = null;
       private bool logGen = true;
       private DateTime date0;
       private Html html = new Html();

       private bool autoSequence = true;

       #endregion
       public static readonly Conf Instance = new Conf();
       private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
       public void setConfFile(string conf)
       {
           this.confFile = new FileInfo(@"..\" + conf);
       }

       #region getters
       public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
       public static bool Single { get { return Instance.single; } }
       public static DirConf DirConf { get { return Instance.root; } }
       public static Move Move { get { return Instance.move; } }
       public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
       public static bool GetDescription { get { return Instance.getDescription; } }
       public static int VolumeMin { get { return Instance.volumeMin; } }
       public static bool Simulation { get { return Instance.simulation; } }
       public static string CopyAll { get { return Instance.copyAll; } }
       public static ConfOrdo Ordo { get { return Instance.ordo; } }
       public static int MaxScan { get { return Instance.maxScan; } }
       public static menage Menage { get { return Instance.menage; } }
       public static bool WritePlayLists { get { return Instance.writePlayLists; } }
       public static bool WritePreSel { get { return Instance.writePreSel; } }
       public static bool WriteItems { get { return Instance.writeItems; } }
       public static bool WriteUse { get { return Instance.writeUse; } }
       public static bool WriteExclu { get { return Instance.writeExclu; } }
       public static bool GenFeed { get { return Instance.genFeed; } }
       public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
       public static int GenUsePrior { get { return Instance.genUsePrior; } }
       public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

       public static bool Transmit { get { return Instance.transmit; } }
       public static bool TransmitTotal { get { return Instance.transmitTotal; } }
       public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
       public static bool? Cascading { get { return Instance.cascading; } }
       public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
       public static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
       internal static Journal Journal { get { return Instance.journal; } }
       public static string RootIt { get { return Instance.rootIt; } }

       public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
       public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }

       public static bool AutoBlock { get { return Instance.autoBlock; } }
       public static bool LogGen { get { return Instance.logGen; } }
       public static DateTime Date0 { get { return Instance.date0; } }
       internal static Html Html { get { return Instance.html; } }

       public static bool AutoSequence { get { return Instance.autoSequence; } }

       //  public static string Zique { get { return Instance.zique; } }
       #endregion

       private DateTime lastModif = DateTime.MinValue;
       private FileInfo confFile;
       public FileInfo ConfFile { get { return confFile; } }
       #region load

       public XmlElement load(bool waitForModification)
       {

           while (true)
           {
               confFile.Refresh();
               if (!confFile.Exists)
                   throw new ApplicationException(confFile + " n'existe pas !!");
               DateTime dt = confFile.LastWriteTime;
               if (dt > lastModif || !waitForModification)
                   break;
               Thread.Sleep(1000);
           }

           lastModif = confFile.LastWriteTime;

           XmlDocument l_doc = new XmlDocument();
           l_doc.Load(confFile.FullName);

           XmlElement xroot = l_doc.DocumentElement;
           XMLTool l_xmlConf = new XMLTool(xroot);

           string str = l_xmlConf.getNodeValue("volumeMin");
           if (!string.IsNullOrEmpty(str))
               volumeMin = Convert.ToInt32(str);

           str = l_xmlConf.getNodeValue("maxScan");
           if (!string.IsNullOrEmpty(str))
               maxScan = Convert.ToInt32(str);

           buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
           simulation = l_xmlConf.getBoolValue("simulation");
           //   zique = l_xmlConf.getNodeValue("zique");

           deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
           getDescription = l_xmlConf.getBoolValue("getDescription");
           copyAll = l_xmlConf.getNodeValue("copyAll");

           str = l_xmlConf.getNodeValue("menage");
           if (!string.IsNullOrEmpty(str))
               menage = (menage)(Enum.Parse(typeof(menage), str, true));

           writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
           writePreSel = l_xmlConf.getBoolValue("writePreSel");
           writeItems = l_xmlConf.getBoolValue("writeItems");
           writeUse = l_xmlConf.getBoolValue("writeUse");
           writeExclu = l_xmlConf.getBoolValue("writeExclu");
           genFeed = l_xmlConf.getBoolValue("genFeed");
           str = l_xmlConf.getNodeValue("genFeedPrior");
           if (!string.IsNullOrEmpty(str))
               genFeedPrior = Convert.ToInt32(str);

           str = l_xmlConf.getNodeValue("genUsePrior");
           if (!string.IsNullOrEmpty(str))
               genUsePrior = Convert.ToInt32(str);

           str = l_xmlConf.getNodeValue("genExcluPrior");
           if (!string.IsNullOrEmpty(str))
               genExcluPrior = Convert.ToInt32(str);

           transmit = l_xmlConf.getBoolValue("transmit");
           transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
           transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
           onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
           onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
           str = l_xmlConf.getNodeValue("cascading");
           if (!string.IsNullOrEmpty(str))
               cascading = "true".Equals(str);
           //  cascading = l_xmlConf.getBoolValue("cascading");

           str = l_xmlConf.getNodeValue("date0");
           if (!string.IsNullOrEmpty(str))
               date0 = Convert.ToDateTime(str);

           var xDates = l_xmlConf.NodeLookUp("playedDates");
           dates = new ConfDate(xDates);

           logGen = l_xmlConf.getBoolValue("logGen");
           var createNullLoggerOrg = Logger.CreateNullLoggers;

           Logger.CreateNullLoggers = !logGen;
           XmlElement xDir = l_xmlConf.NodeLookUp("dir");

           var rootLimit = new Limits();
           buildLimit(xDir, rootLimit, null);

           root = new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
           buildDirChilds(xDir, root);

           XmlElement xMove = l_xmlConf.NodeLookUp("move");
           move = new Move(xMove);

           ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

           selectParams.Clear();

           var xSelect = l_xmlConf.getNode("select");
           foreach (XMLTool xsub in xSelect)
               selectParams.Add(new SelectParam(xsub));

           journal = null;
           var xJournal = XMLTool.NodeLookUp(xroot, "journal");
           if (xJournal != null)
           {
               journal = new Tuning.Journal();
               buildLimitItem(xJournal, xJournal, journal);
               var xxJournal = new XMLTool(xJournal);
               journal.NbJour = xxJournal.getIntAttValue("nbJour");
           }

           rootIt = l_xmlConf.getNodeValue("rootIt");

           autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
           //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
           //if (xAuto == null)
           //    auto = null;
           //else
           //    auto = new Auto(xAuto);

           XmlElement xHtml = l_xmlConf.NodeLookUp("html");
           html = new Html(xHtml);

           autoSequence = l_xmlConf.getBoolValue("autoSequence",true);

           Logger.CreateNullLoggers = createNullLoggerOrg;
           return xroot;

       }

       #region limites

       private void buildDirChilds(XmlNode node, DirConf parent)
       {
           foreach (XmlNode child in node.ChildNodes)
           {
               if (child.Name == "auto")
               {
                   AutoBuilder.build(child, parent);
               }
               else
                   if (child.Name == "dir")
                   {
                       string name = (child.Attributes["name"].InnerText);
                       Limits childLimite = parent.Limites.Clone() as Limits;
                       DirConf sub = new DirConf(childLimite, name, parent);
                       sub.build(node, child);
                       //if (child.Attributes["d"] != null)
                       //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);

                       buildLimit(child, childLimite, sub);

                       if (child.Attributes["all"] != null)
                       {
                           sub.HistoAll = child.Attributes["all"].Value == "true";
                       }

                       if (child.Attributes["cascading"] != null)
                           sub.Cascading = child.Attributes["cascading"].Value == "true";
                       if (child.Attributes["selectionPre"] != null)
                           sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                       if (child.Attributes["transmit"] != null)
                           sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                       if (child.Attributes["transmitTotal"] != null)
                           sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                       if (child.Attributes["transmitTotalGuest"] != null)
                           sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                       parent.addChild(sub);
                       misc.log(sub.display());
                       buildDirChilds(child, sub);

                   }
           }

       }

       private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
       {
           string strTd = child.InnerText;
           if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
               item.Td = Convert.ToInt32(strTd);

           foreach (XmlNode sub in child.ChildNodes)
           {
               if (sub.Name == "auto")
                   AutoBuilder.build(sub, item);
           }

           item.build(parent, child);

           //var dAtt0 = parent.Attributes["d"];
           //if (dAtt0 != null)
           //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

           //var dAtt = child.Attributes["d"];
           //if (dAtt != null)
           //    item.Duration = Convert.ToSingle(dAtt.InnerText);

           //var cAtt0 = parent.Attributes["c"];
           //if (cAtt0 != null)
           //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

           //var cAtt = child.Attributes["c"];
           //if (cAtt != null)
           //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

           //var fdAtt0 = parent.Attributes["fd"];
           //if (fdAtt0 != null)
           //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

           //var fdAtt = child.Attributes["fd"];
           //if (fdAtt != null)
           //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

           //var nbAtt0 = parent.Attributes["nb"];
           //if (nbAtt0 != null)
           //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
           //var nbAtt = child.Attributes["nb"];
           //if (nbAtt != null)
           //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

           //var dateAtt0 = parent.Attributes["date"];
           //if (dateAtt0 != null)
           //    item.DateMin = getDate(dateAtt0.InnerText);
           //var dateAtt = child.Attributes["date"];
           //if (dateAtt != null)
           //    item.DateMin = getDate(dateAtt.InnerText);

           //var dateAtt0Max = parent.Attributes["maxdate"];
           //if (dateAtt0Max != null)
           //    item.DateMax = getDate(dateAtt0Max.InnerText);
           //var dateAttMax = child.Attributes["maxdate"];
           //if (dateAttMax != null)
           //    item.DateMax = getDate(dateAttMax.InnerText);
       }

       public static DateTime getDate(string str)
       {
           int delta = -1;
           double d = -1;
           if (Date0 > DateTime.MinValue)
           //{
           //    if (int.TryParse(str, out delta))
           //    {
           //        int dt = delta;
           //        if (delta % 365 == 0)
           //        {
           //            dt = delta / 365;
           //            return Date0.AddYears(dt);
           //        }

           //        if (delta % 30 == 0)
           //        {
           //            dt = delta / 30;
           //            return Date0.AddMonths(dt);
           //        }
           //        return Date0.AddDays(delta);
           //    }
           //    else
               if (double.TryParse(str, out d))
               {
                   return Date0.AddDays(d);
               }
    //       }

           return Convert.ToDateTime(str);
       }

       private void buildLimit(XmlNode node, Limits limits, DirConf dir)
       {

           Limit[] tab = new Limit[Limits.NB];

           foreach (XmlNode child in node.ChildNodes)
           {
               if (child.Name == "list")
               {

                   int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                   Limit limit = new Limit(level);
                   var items = new List<LimitItem>();

                   double tdMin = 0;
                   foreach (XmlNode xItem in child.ChildNodes)
                   {
                       if (xItem.Name == "auto")
                       {
                           AutoBuilder.build(xItem, limit);
                       }
                       else if (xItem.Name == "td")
                       {
                           var item = new LimitItem(limit);
                           buildLimitItem(child, xItem, item);
                           item.TdMin = tdMin;

                           var itemTd = item.Td;
                           if (itemTd < int.MaxValue)
                               tdMin = item.Td;
                           items.Add(item);
                       }
                   }

                   if (items.Count == 0)
                   {
                       var defaultItem = new LimitItem(limit);
                       buildLimitItem(child, child, defaultItem);
                       items.Add(defaultItem);
                   }

                   limit.Items = items;

                   //var dAtt = child.Attributes["d"];
                   //if (dAtt != null)
                   //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                   //var fdAtt = child.Attributes["fd"];
                   //if (fdAtt != null)
                   //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                   //var nbAtt = child.Attributes["nb"];
                   //if (nbAtt != null)
                   //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                   tab[level] = limit;
               }

           }

           Limit current = null;
           bool oneTabAtLeast = false;
           //  LimitItem currentItem = null;

           double currentDuration = int.MaxValue;
           double lcurrentDuration = int.MaxValue;
           double currentContrib = int.MaxValue;
           double currentFeedDuration = int.MaxValue;
           double lcurrentFeedDuration = int.MaxValue;
           int currentNb = int.MaxValue;
           int lcurrentNb = int.MaxValue;
           
           double currentTd = int.MaxValue;
         
           double currentTdMin = int.MaxValue;
           DateTime currentDateMin = DateTime.MinValue;
           DateTime currentDateMax = DateTime.MaxValue;

           for (int i = 0; i < Limits.NB; i++)
           {

               //if (tab[i] != null)
               //{

               if (tab[i] != null)
               {
                   current = tab[i];
                   oneTabAtLeast = true;

               }

               if (!oneTabAtLeast)
                   current = limits[i];

               var _limit = limits[i];
               _limit.Level = i;
               limits[i].Parent = limits;

               //foreach (LimitItem currentItem in current.Items)
               //{

               if (_limit.Items.Count != current.Items.Count)
               {
                   _limit.Items.Clear();
               }

               for (int j = 0; current != null && j < current.Items.Count; j++)
               {

                   var currentItem = current.Items[j];
                   // if (currentItem.Duration < int.MaxValue)
                   currentDuration = currentItem.Duration;
                   lcurrentDuration = currentItem.LoadDuration;
                   //if (currentItem.Contribution < int.MaxValue)
                   currentContrib = currentItem.Contribution;
                   // if (currentItem.FeedDuration < int.MaxValue)
                   currentFeedDuration = currentItem.FeedDuration;
                   lcurrentFeedDuration = currentItem.LoadFeedDuration;

                   //   if (currentItem.Nb < int.MaxValue)
                   currentNb = currentItem.Nb;
                   lcurrentNb = currentItem.LoadNb;
                   //  if (currentItem.Td < int.MaxValue)
                   currentTd = currentItem.Td;
                   currentTdMin = currentItem.TdMin;

                   currentDateMin = currentItem.DateMin;
                   currentDateMax = currentItem.DateMax;
                   //}
                   //}

                   //if (current != null)
                   //{
                   LimitItem _limitItem = null;
                   if (j >= _limit.Items.Count)
                   {
                       _limitItem = currentItem.Clone() as LimitItem;
                       _limit.Items.Add(_limitItem);
                       _limitItem.Limit = _limit;

                   }
                   else
                   {
                       _limitItem = _limit.Items[j];

                   }
                   //if (currentDuration < int.MaxValue)
                   _limitItem.Duration = currentDuration;
                   _limitItem.LoadDuration = lcurrentDuration; 
                   //if (currentContrib < int.MaxValue)
                   //    _limitItem.Contribution = currentContrib;
                   // if (currentFeedDuration < int.MaxValue)
                   _limitItem.FeedDuration = currentFeedDuration;
                   _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                   // if (currentNb < int.MaxValue)
                   _limitItem.Nb = currentNb;
                   _limitItem.LoadNb = lcurrentNb;
                   //   if (currentTd < int.MaxValue)
                   _limitItem.Td = currentTd;
                   _limitItem.TdMin = currentTdMin;
                   _limitItem.DateMin = currentDateMin;
                   _limitItem.DateMax = currentDateMax;
                   _limitItem.Contribution = currentContrib;

                   if (dir != null)
                   {
                       if (_limitItem.Duration == int.MaxValue)
                           _limitItem.Duration = dir.Duration;
                       if (_limitItem.LoadDuration == int.MaxValue)
                           _limitItem.LoadDuration = dir.LoadDuration;
                       if (_limitItem.Contribution == int.MaxValue)
                           _limitItem.Contribution = dir.Contribution;
                       if (_limitItem.Td == int.MaxValue)
                           _limitItem.Td = dir.Td;
                       if (_limitItem.Nb == int.MaxValue)
                           _limitItem.Nb = dir.Nb;
                       if (_limitItem.LoadNb == int.MaxValue)
                           _limitItem.LoadNb = dir.LoadNb;
                       if (_limitItem.FeedDuration == int.MaxValue)
                           _limitItem.FeedDuration = dir.FeedDuration;
                       if (_limitItem.LoadFeedDuration == int.MaxValue)
                           _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                       if (_limitItem.DateMin == DateTime.MinValue)
                           _limitItem.DateMin = dir.DateMin;
                       if (_limitItem.DateMax == DateTime.MaxValue)
                           _limitItem.DateMax = dir.DateMax;
                   }

               }

               //}
               // }

           }

       }
       #endregion
       #endregion

   }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\LimitItem.cs">
    <content><![CDATA[using System;
using pdb.util;
using pdb.podcast.Report;
using pdb.podcast.Auto;
using System.Collections.Generic;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Item de limite concernant la durée 
    /// </summary>
    public class LimitItem : LimitItemBase, IBuilderSource
    {


        /// <summary>
        /// Détailler le rapport - à bouger
        /// </summary>
        public static bool includeDetail;


        public int Level { get { return limit.Level; } }
        public int Rating { get { return limit.Level * 20; } }



        private Limit limit;
        private TripleStat stats = new TripleStat();


        public override string ToString()
        {
            if (nb == 0 || feedDuration == 0)
                return Dir.ToString() + string.Format("\\{0}", limit.Level);
            return Dir.ToString() + string.Format("\\{0}:{1} {2} {3} {4} {5} {6} {7} {8}", limit.Level, getS("d", duration), getS("c", contribution), getS("fd", feedDuration), getS("nb", nb), getS("td", td), getS("tdMin", tdMin), getS("date", dateMin), getS("dateMax", dateMax));
        }

        private static string getS(string desc, int v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}->{1}", desc, v);
            return "";
        }

        private static string getS(string desc, double v)
        {
            if (v < int.MaxValue && v > 0)
                return string.Format("{0}->{1}", desc, v);
            return "";
        }

        private static string getS(string desc, DateTime v)
        {
            if (v > DateTime.MinValue && v < DateTime.MaxValue)
                return string.Format("{0}->{1}", desc, v);
            return "";
        }



        public void recordTrackMoy(TrackInfoItunes track, int countItems)
        {
            stats.recordTrack(track, countItems);
        }


        private bool durationLimitAtteinte;
        private bool contributionLimitAtteinte;
        private bool durationFeedLimit;
        private bool nbFeedLimit;
        public bool DurationLimitAtteinte { get { return durationLimitAtteinte; } set { durationLimitAtteinte = value; } }
        public bool ContributionLimitAtteinte { get { return contributionLimitAtteinte; } set { contributionLimitAtteinte = value; } }
        private bool loadDurationLimitAtteinte;
        public bool LoadDurationLimitAtteinte { get { return loadDurationLimitAtteinte; } set { loadDurationLimitAtteinte = value; } }

        public bool DurationFeedLimit { set { durationFeedLimit = value; } }
        public bool NbFeedLimit { set { nbFeedLimit = value; } }

        #region border
        /// <summary>
        /// track In le plus près de la limite dateMin
        /// </summary>
        TrackInfoItunes borderDateMinIn;
        /// <summary>
        /// Track rejeté le plus près de la limite dateMin
        /// </summary>
        TrackInfoItunes borderDateMinOut;

        /// <summary>
        /// track In le plus près de la limite dateMax
        /// </summary>
        TrackInfoItunes borderDateMaxIn;
        /// <summary>
        /// Track rejeté le plus près de la limite dateMax
        /// </summary>
        TrackInfoItunes borderDateMaxOut;

        /// <summary>
        /// Dernier accepté par rapport à la durée totale
        /// </summary>
        TrackInfoItunes borderDurationIn;
        /// <summary>
        /// Premier rejeté par rapport à la durée totale
        /// </summary>
        TrackInfoItunes borderDurationOut;

        TimeSpan borderDurationValueIn;
        TimeSpan borderDurationValueOut;

        /// <summary>
        /// Dernier accepté par rapport à la durée de feed
        /// </summary>
        TrackInfoItunes borderFdIn;
        /// <summary>
        /// Premier rejeté par rapport à la durée Feed
        /// </summary>
        TrackInfoItunes borderFdOut;

        TimeSpan borderFdValueIn;
        TimeSpan borderFdValueOut; 

        public void clearBorder()
        {
            borderDateMinIn = null;
            borderDateMinOut = null;
            borderDateMaxIn = null; 
            borderDateMaxOut = null;
            borderDurationIn = null;
            borderDurationOut = null;
            borderDurationValueIn = new TimeSpan();
            borderDurationValueOut = new TimeSpan();

            borderFdIn = null;
            borderFdOut = null;
            borderFdValueIn = new TimeSpan();
            borderFdValueOut = new TimeSpan(); 
        }
       

        public bool checkPub(TrackInfoItunes candidat)
        {
            var d = candidat.Pub;
            if (d < dateMin)
                return false;
            if (d > dateMax)
                return false;
            return true;
        }
        // --------vIn----limit ------vout
        public void checkBorderFd(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        {
            if (selected && duration.TotalMinutes <= this.feedDuration )
            {
                if (borderFdIn == null || duration > borderFdValueIn )
                {
                    borderFdIn = candidat;
                    borderFdValueIn = duration;
                }
            }
            else if (!selected && duration.TotalMinutes > this.feedDuration)
            {
                if (borderFdOut == null || duration < borderFdValueOut)
                {
                    borderFdOut = candidat;
                    borderFdValueOut = duration;
                }
            }
            else
            {
            }
        }

        public void checkBorderDuration(TrackInfoItunes candidat, TimeSpan duration, bool selected)
        {
            if (selected && duration.TotalMinutes <= this.duration)
            {
                borderDurationIn = candidat;
                borderDurationValueIn = duration;
            }
            else if (!selected && duration.TotalMinutes > this.duration)
            {
                if (borderDurationOut == null)
                {
                    borderDurationOut = candidat;
                    borderDurationValueOut = duration;
                }
            }
            else
            {
            }
        }

        public void checkBorderDates(TrackInfoItunes candidat, bool selected)
        {
            // ---minOut --limit ---minIn ----
            var d = candidat.Pub;
            if (d < dateMin)
            {
                if (borderDateMinOut == null ||d > borderDateMinOut.Pub )
                    borderDateMinOut = candidat;
            }
            else if (d>=dateMin && selected)
            {
                if (borderDateMinIn == null || d < borderDateMinIn.Pub)
                    borderDateMinIn = candidat;

            }
            // ---maxIn --limit ---maxOut ----
            if (d > dateMax)
            {
                if (borderDateMaxOut == null || d < borderDateMaxOut.Pub)
                    borderDateMaxOut = candidat;
            }
            else if (d <= dateMax &&selected)
            {
                if (borderDateMaxIn == null || d >borderDateMaxIn.Pub )
                    borderDateMaxIn = candidat;
            }
        }

       

        #endregion

        public void writeStat(ITextWriter sbRapport)
        {
            writeStatHeader(sbRapport);
            stats.buildValues(sbRapport);

        }

        private LimitItemStat stat;
        internal LimitItemStat Stat { set { stat = value; } get { return stat; } }

        public void writeStatHeader(ITextWriter sbRapport)
        {
            if (loadDurationLimitAtteinte)
                sbRapport.Append("d");
            else
                sbRapport.Append(" ");

            if (durationLimitAtteinte)
                sbRapport.Append("d");
            else
                sbRapport.Append(" ");

            if (contributionLimitAtteinte)
                sbRapport.Append("c");
            else
                sbRapport.Append(" ");

            if (durationFeedLimit)
                sbRapport.Append("f");
            else
                sbRapport.Append(" ");

            if (nbFeedLimit)
                sbRapport.Append("n");
            else
                sbRapport.Append(" ");
            sbRapport.Append(" ");

        }

        public void getToTaux(ITextWriter sb)
        {

        }

        public void rapport(DescBuilder sb)
        {
            sb.Append("\t");
            //sb.Append(Dir.getPath());
            //sb.Append(" ");
            sb.Append(ToString());
            sb.Append(" ");
        }

        public DirConf Dir { get { return limit.Parent.Parent; } }
        public string id = null;
        public string ID
        {
            get
            {
                if (id == null)
                {
                    int index = limit.index(this);
                    if (index >= 0)
                        id = Dir.getPath() + "\\" + Level + "\\_" + (index + 1);
                    else
                        id = Dir.getPath() + "\\_" + Level;

                }
                return id;
            }
        }
        private Logger logger;

        public LimitItem(Limit limit)
        {
            this.limit = limit;
        }
        public Logger Logger
        {
            get
            {
                if (logger == null)
                {
                    logger = Logger.getLogger(ID, false);
                }
                return logger;
            }
        }

        public object Clone()
        {
            return new LimitItem(limit) { Nb = this.nb, FeedDuration = this.feedDuration, Duration = this.duration, Td = this.td, TdMin = this.tdMin, DateMin = this.dateMin, DateMax = this.dateMax, Contribution = this.contribution, Stat = this.stat };
        }

        public Limit Limit { set { limit = value; } get { return limit; } }


        public List<TrackInfoItunes> getSelectedTracks()
        {
            if (stat == null)
                return new List<TrackInfoItunes>();
            return new List<TrackInfoItunes>(stat.Total.Use.List);
        }

        public double getTotalSize()
        {
            if (stat == null)
                return -1;
            return stat.Total.Use.getTotalSize();
        }

        public string getEmpreinte()
        {
            if (stat == null)
                return "NULL";
            return stat.Total.Use.getEmpreinte();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\LimitItemBase.cs">
    <content><![CDATA[using System;
using System.Xml;

namespace pdb.podcast.Tuning
{

    public class LimitItemBase
    {
        /// <summary>
        /// temps total de tous les flux associés à cette limite
        /// </summary>
        protected double duration = int.MaxValue;
        /// <summary>
        /// Temps total phase load de tous les flux associés à cette limite
        /// </summary>
        protected double loadDuration = int.MaxValue; 

        protected LimitItemBase parent;
        const double MAX = int.MaxValue;


        delegate void setf(double value);
        delegate void setI(int value);
        delegate void setd(DateTime value);



        public void setParent(LimitItemBase parent)
        {
            this.parent = parent;
        }

        /// <summary>
        /// Contribution max de cette limite
        /// </summary>
        protected double contribution = int.MaxValue;
        /// <summary>
        /// nombre d'éléments max
        /// </summary>
        protected int nb = int.MaxValue;

        protected int lNb = int.MaxValue;

        /// <summary>
        /// durée totale du flux
        /// </summary>
        protected double feedDuration = int.MaxValue;

        protected double lFd = int.MaxValue; 

        /// <summary>
        /// durée max de chaque track
        /// </summary>
        protected double td = int.MaxValue;

        /// <summary>
        /// Durée min de chaque track
        /// </summary>
        protected double tdMin = 0;

        protected DateTime dateMin;

        protected DateTime dateMax = DateTime.MaxValue;


        public double Duration
        {
            get
            {
                if (parent == null || duration < MAX)
                    return duration;
                return parent.Duration;
            }
            set { duration = value; }
        }

        public double LoadDuration
        {
            get
            {
                if (parent == null || loadDuration < MAX)
                    return loadDuration;
                return parent.LoadDuration;
            }
            set { loadDuration = value; }
        }
        public double Contribution
        {
            get
            {
                if (parent == null || contribution < MAX)
                    return contribution;
                return parent.Contribution;
            }

            set { contribution = value; }
        }
        public double FeedDuration
        {
            get
            {
                if (parent == null || feedDuration < MAX)
                    return feedDuration;
                return parent.FeedDuration;
            }
            set { feedDuration = value; }
        }
        public double LoadFeedDuration
        {
            get
            {
                if (parent == null || lFd < MAX)
                    return lFd;
                return parent.LoadFeedDuration;
            }
            set { lFd = value; }
        }

        public int Nb
        {
            get
            {
                if (parent == null || nb < int.MaxValue)
                    return nb;
                return parent.Nb;
            }
            set { nb = value; }
        }

        public int LoadNb
        {
            get
            {
                if (parent == null || lNb < int.MaxValue)
                    return lNb;
                return parent.LoadNb;
            }
            set { lNb = value; }
        }


        /// <summary>
        /// durée max de chaque track
        /// </summary>
        public double Td { set { td = value; } get { return td; } }
        /// <summary>
        /// Durée min de chaque track
        /// </summary>
        public double TdMin
        {
            set { tdMin = value; }
            get
            {
                if (parent == null || tdMin < MAX)
                    return tdMin;
                return parent.TdMin;
            }
        }
        public DateTime DateMin { set { dateMin = value; } get { return dateMin; } }
        public DateTime DateMax { set { dateMax = value; } get { return dateMax; } }

        public void build(XmlNode parent, XmlNode child)
        {
            buildf(parent, child, "d", (v) => duration = v);
            buildf(parent, child, "ld", (v) => loadDuration = v);
            buildf(parent, child, "c", (v) => contribution = v);
            buildf(parent, child, "fd", (v) => feedDuration = v);
            buildf(parent, child, "lfd", (v) => lFd = v);
            buildi(parent, child, "nb", (v) => nb = v);
            buildi(parent, child, "lnb", (v) => lNb = v);
            buildd(parent, child, "date", (v) => dateMin = v);
            buildd(parent, child, "maxdate", (v) => dateMax = v);
        }

        private void buildf(XmlNode parent, XmlNode child, string name, setf setf)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setf(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setf(Convert.ToDouble(att.InnerText));
        }

        private void buildi(XmlNode parent, XmlNode child, string name, setI seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt16(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt16(att.InnerText));
        }

        private void buildd(XmlNode parent, XmlNode child, string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Conf.getDate(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Conf.getDate(att.InnerText));
        }

    }


}
]]></content>
  </file>
</db>
