<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\Vue\Conf\Debug.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.Conf.Debug"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        SizeToContent="WidthAndHeight"
        Title="Debug" mc:Ignorable="d" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" d:DesignHeight="144" d:DesignWidth="287">
    <Grid>
        <Grid>
            <Grid.RowDefinitions>
                <RowDefinition />
                <RowDefinition />
                <RowDefinition />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition />
                <ColumnDefinition />
                <ColumnDefinition />
                <ColumnDefinition />
                <ColumnDefinition />

            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_rank" Width="30"  VerticalAlignment="Center" ToolTip="Correction via Rang" Margin="5" Padding="2" />
            <CheckBox Grid.Row="0" Grid.Column="1" Name="cb_coeff" Width="30"  VerticalAlignment="Center" ToolTip="Correction via Coeff" Margin="5" Padding="2" />
            <StackPanel Grid.Row="0" Grid.Column="2">          
                <CheckBox Grid.Row="0" Grid.Column="2" Name="cb_zero" Width="30"  VerticalAlignment="Center" ToolTip="Correction via Zero" Margin="2" Padding="2" />
                <TextBox Grid.Row="0" Grid.Column="2" Name="tb_zeroOptim" Width="30"  VerticalAlignment="Center" ToolTip="Correction via Zero performante" Margin="2" Padding="2" />
            </StackPanel>
            <CheckBox Grid.Row="0" Grid.Column="3" Name="cb_dontTouchMain" Width="30"  VerticalAlignment="Center" ToolTip="Pas touche aux main" Margin="5" Padding="2" />
            <CheckBox Grid.Row="1" Grid.Column="0" Name="cb_sortSt" Width="30"  VerticalAlignment="Center" ToolTip="Tri stack" Margin="5" Padding="2" />
            <CheckBox Grid.Row="1" Grid.Column="1" Name="cb_sort0" Width="30"  VerticalAlignment="Center" ToolTip="Tri avec coeff à 1" Margin="5" Padding="2" />
            <CheckBox Grid.Row="1" Grid.Column="2" Name="cb_sortSt0" Width="30"  VerticalAlignment="Center" ToolTip="Tri stack avec coeff à 1" Margin="5" Padding="2" />
            
            <CheckBox Grid.Row="2" Grid.Column="0"  Name="cb_reset" Width="30"  VerticalAlignment="Center" ToolTip="Remise à 1 du coeff" Margin="5" Padding="2" />
            <Button  Grid.Row="2" Grid.Column="1" Grid.ColumnSpan="2" Name="bt_apply"   VerticalAlignment="Center" Content="Appliquer" Click="bt_apply_Click"/>
            <CheckBox Grid.Row="2" Grid.Column="3"  Name="cb_reset_sort_done" Width="30"  VerticalAlignment="Center" ToolTip="Invalider tous les albums" Margin="5" Padding="2" />
            <TextBox Grid.Row="0" Grid.Column="4" Name="tb_optimSize" Width="40" Height="20" ToolTip="Taille pile d'optimisation" />
            <TextBox Grid.Row="1" Grid.Column="4" Name="tb_optimCheck" Width="40" Height="20" ToolTip="Vérification d'optimisation" />
        </Grid>
        
    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Conf\Debug.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using pdb.gen.Tuning;
using pdb.gen.albums;

namespace pdb.player.Vue.Conf
{
    /// <summary>
    /// Interaction logic for Debug.xaml
    /// </summary>
    public partial class Debug : Window
    {
        ConfAlbumSort conf;
        public Debug()
        {
            InitializeComponent();
        }

        public Debug(ConfAlbumSort conf)
            : this()
        {
            this.conf = conf;
            Loaded += new RoutedEventHandler(Debug_Loaded);
        }

        void Debug_Loaded(object sender, RoutedEventArgs e)
        {
            cb_coeff.IsChecked = conf.correcMainCoeff;
            cb_rank.IsChecked = conf.correcMainRank;
            cb_zero.IsChecked = conf.correcMainZero;
            tb_zeroOptim.Text = conf.correcMainZeroOptim.ToString();
            cb_reset.IsChecked = conf.reset;
            cb_dontTouchMain.IsChecked = conf.dontTouchMain; 

            cb_sort0.IsChecked = conf.sort0;
            cb_sortSt.IsChecked = conf.sortSt;
            cb_sortSt0.IsChecked = conf.sortSt0;

            tb_optimSize.Text = conf.optimSize.ToString();
            tb_optimCheck.Text = conf.optimCheck.ToString(); 
        }

        private void bt_apply_Click(object sender, RoutedEventArgs e)
        {
            lock (Albums.LockSort)
            {
                conf.correcMainCoeff = cb_coeff.IsChecked.Value;
                conf.correcMainRank = cb_rank.IsChecked.Value;
                conf.correcMainZero = cb_zero.IsChecked.Value;
                if (string.IsNullOrEmpty(tb_zeroOptim.Text))
                    conf.correcMainZeroOptim = -1;
                else
                    conf.correcMainZeroOptim = Convert.ToInt32(tb_zeroOptim.Text);
                conf.reset = cb_reset.IsChecked.Value;

                conf.sort0 = cb_sort0.IsChecked.Value;
                conf.sortSt = cb_sortSt.IsChecked.Value;
                conf.sortSt0 = cb_sortSt0.IsChecked.Value;

                conf.dontTouchMain = cb_dontTouchMain.IsChecked.Value;

                conf.optimSize = Convert.ToInt32(tb_optimSize.Text);
                conf.optimCheck = Convert.ToInt32(tb_optimCheck.Text);

                if (cb_reset_sort_done.IsChecked.Value)
                    App.gen.invalidateAlbums(); 

                App.go();
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Locker.cs">
    <content><![CDATA[using System.Threading;
using System;
using System.Diagnostics;

namespace pdb.util
{
    public class Locker
    {
        private volatile object _lock;
        private static volatile object _lockS = new object();
        //  private bool used;
        private static Locker instance = new Locker();
        private Thread currentThread;
        private StackTrace currentSt;
        private DateTime t;
        private static Logger log = Logger.getLogger("Lock");

        private static int lockWarn = 1000;
        private static int lockAbort = int.MaxValue;

        public static int LockWarn { set { if (value > 0) lockWarn = value; } }
        public static int LockAbort { set { if (value > 0) lockAbort = value; } }

        private static Mutex mutex;
        private Locker()
        {
            _lock = new object();
        }

        public static void Enter()
        {

            //while (instance.used)
            //    Thread.Sleep(30);
            // Thread.Sleep(30);

            int i = 0;
            StackTrace st = new StackTrace();
            Thread current = Thread.CurrentThread;
            try
            {
                while (!Monitor.TryEnter(instance._lock, lockWarn))
                {
                    i += lockWarn;
                    log.log("attente depuis " + st);
                    log.log(" par           (" + (DateTime.Now - instance.t) + ") " + instance.currentSt);

                    if (i >= lockAbort)
                    {
                        string instanceCurrentThreadName = "";
                        if (instance.currentThread != null && instance.currentThread.Name != null)
                            instanceCurrentThreadName = instance.currentThread.Name;
                        // throw new ApplicationException(string.Format("{0} attendu trop longtemps {1} ", Thread.CurrentThread.Name, instanceCurrentThreadName));
                        if (instance.currentThread != null)
                            instance.currentThread.Abort();
                        else
                            throw new ApplicationException(string.Format("{0} attendu trop longtemps {1} ", Thread.CurrentThread.Name, instanceCurrentThreadName));
                    }
                }
                if (i < lockAbort)
                {
                    // I GOT IT !
                    instance.t = DateTime.Now;
                    instance.currentThread = current;
                    instance.currentSt = st;
                }
            }
            finally
            {

            }



            //Monitor.Enter(instance._lock);
            //while (instance.used)
            //    Thread.Sleep(30);
            //  instance.used = true;
        }

        public static void Release()
        {

            //   if (Thread.CurrentThread == instance.currentThread)
            try
            {
                //instance.currentThread = null;
                //instance.currentSt = null;
                Monitor.Exit(instance._lock);

            }
            catch (Exception ex)
            {
                log.log(ex.ToString());

            }
            finally
            {

            }
            // instance.used = false;


        }

        public static void enter(object _lock)
        {
            while (!Monitor.TryEnter(_lock, 1000))
            {
                var st = new StackTrace();
                misc.log("attente verrou " + st); 

            }
        }

        public static void release(object _lock)
        {
            try
            {
                Monitor.Exit(_lock);
            }
            catch (Exception ex)
            {
                misc.log(ex); 
            }
        }

        //public static Mutex wait(string name)
        //{
        //    var mutex = new Mutex(true, name);
        //    while (true)
        //    {
        //        try
        //        {
        //            bool ok = mutex.WaitOne(1000);
        //            if (!ok)
        //                misc.log("Attente libération du verrou " + name);
        //            else
        //            {
        //                misc.log("mutex pris " + name);
        //                return mutex;
        //            }
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log(ex.ToString());
        //        }
        //    }
        //}

        //public static void release(Mutex mutex)
        //{
        //    try
        //    {
        //        mutex.ReleaseMutex();
        //    }
        //    catch (Exception ex)
        //    {
        //        misc.log(ex.ToString());
        //    }
        //}

        public static void waitForSingleProcess(string name)
        {
            mutex = new Mutex(true, name);
            while (true)
            {
                try
                {
                    bool ok = mutex.WaitOne(1000);
                    if (!ok)
                        misc.log("Attente finalisation du process " + name);
                    else
                    {
                        misc.log("mutex pris " + name);
                        return;
                    }
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

        }

        public static void releaseSingleProcess()
        {
            try
            {
                mutex.ReleaseMutex();
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }


    }
}
]]></content>
  </file>
  <file path="\pdb.util\ZipUtil.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Threading;

namespace pdb.util
{
    public class ZipUtil : IDisposable
    {
       // private SevenZipCompressor zip;
      //  private Stream baseStream;
      //  private string dir;

        const int BUF_SIZE = 4096;
        static string exe = @"C:\Program Files\7-Zip\7z.exe";
        public static string Exe {  set { if (string.IsNullOrEmpty(value)) return ; exe = value; } }
        private static volatile object _lock = new object();

        public static void Enter()
        {
            Locker.enter(_lock); 
        }

        public static void Release()
        {
            Locker.release(_lock);
        }

        //static ZipUtil()
        //{
        //    FileInfo dll = new FileInfo("7z.dll");
        //    //Assembly ass = Assembly.GetAssembly(typeof (ZipUtil));
        //    //Console.WriteLine(Directory.GetCurrentDirectory()); 
        //    //Console.WriteLine(ass.CodeBase); 
        //    //string toto = ass.Location; 

        //    SevenZipCompressor.SetLibraryPath(dll.FullName);
        //}

        private string zipFile, dir;
        private IEnumerable<string> files;
        private bool horodate;
       // private Mutex locker;
        private ZipUtil(string zipFile, string dir, IEnumerable<string> files, bool horodate)
        {
            this.zipFile = zipFile;
            this.dir = dir;
            this.files = files;
            this.horodate = horodate;
            
        }

        private void compress()
        {
            try
            {

                Locker.enter(_lock); 

                if (!dir.EndsWith("\\"))
                    dir += ("\\");

            
                DirectoryInfo dirr = new DirectoryInfo(dir);
                if (!dirr.Exists)
                    dirr.Create();

                foreach (string file in files)
                {
                    if (File.Exists(file))
                    {
                        var sb = new StringBuilder();
                        sb.Append(dir);
                        if (horodate)
                        {
                            sb.Append(DateTime.Now.ToString("yy-MM-dd_HH-mm-ss"));
                            sb.Append("_");
                        }
                        sb.Append(Path.GetFileName(file));
                        File.Copy(file, sb.ToString(), true);
                    }
                }

                Process p = new Process();
                ProcessStartInfo pi = new ProcessStartInfo(exe, "a -mx9 " + zipFile + " " + dir);

                p.StartInfo = pi;


                p.Start();

                while (!p.HasExited)
                {
                    Thread.Sleep(30);
                }

               

                foreach (var file in dirr.GetFiles())
                {
                    file.Delete();
                }

                dirr.Delete();

              
            }
            finally
            {
                Locker.release(_lock); 
            }
        }

        public static void CompressAsync( string zipFile, string dir, IEnumerable<string> files, bool horodate)
        {
            var compressor = new ZipUtil(zipFile, dir, files, horodate);
            new Thread(() => compressor.compress()).Start(); 
        }

        public static void CompressAsync(string zipFile, string dir, IEnumerable<string> files)
        {
            CompressAsync(zipFile, dir, files, false); 
        }

        //public static void compress(string zipFile, string dir, IEnumerable<string> files)
        //{
        //    compress(zipFile, dir, files, false); 
        //}

        //public static void compress(string zipFile, string dir, IEnumerable<string> files, bool horodate)
        //{
        //    //CompressionMode mode = CompressionMode.Create;
        //    //if (File.Exists(zipFile))
        //    //    mode = CompressionMode.Append;
        //    //var zip = new SevenZipCompressor(Path.GetTempPath());

        //    //zip.CompressionMethod = SevenZip.CompressionMethod.BZip2;

        //    //zip.CompressionMode = mode;
        //    //zip.CompressionLevel = CompressionLevel.Ultra; // Ionic.Zlib.CompressionLevel.BestCompression;
        //    //zip.ArchiveFormat = OutArchiveFormat.SevenZip;

        //    if (!dir.EndsWith("\\"))
        //        dir += ("\\");

        //    // Dictionary<string, Stream> dict = new Dictionary<string, Stream>();

        //    DirectoryInfo dirr = new DirectoryInfo(dir);
        //    if (!dirr.Exists)
        //        dirr.Create();

        //    foreach (string file in files)
        //    {
        //        if (File.Exists(file))
        //        {
        //            var sb = new StringBuilder();
        //            sb.Append(dir);
        //            if (horodate)
        //            {
        //                sb.Append(DateTime.Now.ToString("yy-MM-dd_HH-mm-ss"));
        //                sb.Append("_"); 
        //            }
        //            sb.Append(Path.GetFileName(file)); 
        //            File.Copy(file, sb.ToString(), true);
        //        }
        //    }

        //    Process p = new Process();
        //    ProcessStartInfo pi = new ProcessStartInfo(exe, "a -mx9 " + zipFile + " " + dir);

        //    p.StartInfo = pi;


        //    p.Start();

        //    while (!p.HasExited)
        //    {
        //        Thread.Sleep(30);
        //    }

        //    //foreach (string file in files)
        //    //{
        //    //    string fileInArch = dir + Path.GetFileName(file);
        //    //    Stream sr = File.OpenRead(file);
        //    //    dict.Add(fileInArch, sr);                 
        //    //}

        //    //using (FileStream baseStream = System.IO.File.OpenWrite(zipFile))
        //    //{
        //    //    zip.CompressDirectory(dir, baseStream); 
        //    //    //zip.CompressStreamDictionary(dict, baseStream); 
        //    //}

        //    foreach (var file in dirr.GetFiles())
        //    {
        //        file.Delete();
        //    }

        //    dirr.Delete();

        //    //foreach (Stream s in dict.Values)
        //    //{
        //    //    s.Dispose(); 
        //    //}

        //}

        //public ZipUtil(string zipFile, string dir)
        //{
        //    CompressionMode mode = CompressionMode.Create;
        //    if (File.Exists(zipFile))
        //        mode = CompressionMode.Append;


        //    this.baseStream = System.IO.File.Open(zipFile, FileMode.Append);

        //    this.zip = new SevenZipCompressor();
        //    zip.CompressionMode = mode;
        //    zip.CompressionLevel = CompressionLevel.Ultra; // Ionic.Zlib.CompressionLevel.BestCompression;
        //    zip.ArchiveFormat = OutArchiveFormat.SevenZip;

        //    if (!dir.EndsWith("\\"))
        //        dir += ("\\");

        //    this.dir = dir;

        //}

        //public void addFile(string file)
        //{
        //    using (FileStream fs = new FileStream(file, FileMode.Open))
        //    {
        //        zip.DefaultItemName = dir + Path.GetFileName(file);
        //        zip.CompressStream(fs, baseStream);

        //        zip.CompressStreamDictionary(
        //    }




        //    //  zip.AddFile(file, dir); 

        //    //ZipEntry entry = stream.PutNextEntry(dir + Path.GetFileName(file));




        //    //byte[] buf = new byte[BUF_SIZE];
        //    //using (Stream input = File.OpenRead(file))
        //    //{
        //    //    int nb;
        //    //    while ((nb = input.Read(buf, 0, BUF_SIZE)) > 0)
        //    //    {
        //    //        stream.Write(buf, 0, nb);
        //    //    }
        //    //}
        //}


        //public static void test()
        //{
        //    using (var zip = ZipFile.Read(nameOfExistingZip))
        //    {
        //        zip.CompressionLevel = Ionic.Zlib.CompressionLevel.BestCompression;
        //        zip.AddFile(additionalFileToAdd);
        //        zip.Save();
        //    }
        //}


        //public static void addZipToArchive(Stream zip, FileInfo file, string inDir)
        //{
        //    using (Ionic.Zip.ZipOutputStream _zip = new Ionic.Zip.ZipOutputStream(zip, false))
        //    {


        //        _zip.PutNextEntry(inDir + file.Name);


        //        byte[] buf = new byte[4096];

        //        using (Stream input = File.OpenRead(file.FullName))
        //        {
        //            int nb;
        //            while ((nb = input.Read(buf, 0, 4096)) > 0)
        //            {
        //                _zip.Write(buf, 0, nb);
        //            }
        //        }

        //        //SevenZip.SevenZipCompressor sZip = new SevenZipCompressor();
        //        //sZip.ArchiveFormat = OutArchiveFormat.SevenZip;
        //        //sZip.CompressionLevel = CompressionLevel.Ultra;

        //        //sZip.CompressFiles(zip, file.FullName); 
        //    }

        //}

        #region IDisposable Members

        public void Dispose()
        {
            //if (baseStream != null)
            //    baseStream.Dispose();
        }

        #endregion
    }

    //public class Szip
    //{
    //    public static void addZipToArchive(Stream zip, string file, string inDir)
    //    {
    //        SevenZipCompressor.SetLibraryPath(@"C:\bernard\db1\PieceDb3Ref\pdb.util\bin\7z.dll");

    //        SevenZip.SevenZipCompressor sZip = new SevenZipCompressor();
    //        sZip.CompressionMode = CompressionMode.Append;
    //        //sZip.DefaultItemName = inDir; 
    //        sZip.ArchiveFormat = OutArchiveFormat.SevenZip;
    //        sZip.CompressionLevel = CompressionLevel.Ultra;
    //        sZip.DirectoryStructure = true;

    //        using (FileStream fs = new FileStream(file, FileMode.Open))
    //        {
    //            sZip.DefaultItemName = inDir + "\\" + Path.GetFileName(file);
    //            sZip.CompressStream(fs, zip);
    //        }





    //        //  sZip.CompressFiles(zip, file); 



    //    }
    //}
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des données morceux dupliqués 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;
        private bool goCompact = true;
        private bool _firstConsolid = true;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
            albums = new Albums(this);
        }
        /// <summary>
        /// Lance le compactage à la prochaine génération
        /// </summary>
        public void GoCompact() { goCompact = true; }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public Albums Albums { get { return albums; } }
        public void invalidateAlbums() { _firstConsolid = false; albums.invalidateAll();  }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList, bool makeSort)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                DateTime now = DateTime.Now;
                DateTime debut = now;
                allClassed.Clear();
                allClassedInAlbumEnabled.Clear();
                m_listTrackClassed.Clear(); 
                if (_firstConsolid)
                {
                    listPiece.Clear();
                    listPieceInAlbum.Clear();
                    all.Clear(); 

                    // albums = new Albums(this);
                    VirtualPiece.init();
                   
                   
                 
                    //  htIds = new BgDict<int, Piece>();
                    foreach (ITrackNativeDates track in dbList)
                    {

                        if (!track.isPodcast)
                        {
                            Piece piece = null;
                            int pieceId = track.PieceId;
                            if (htIds.ContainsKey(pieceId))
                            {
                                piece = htIds[pieceId];
                                piece.initRank();
                            }
                            else
                            {
                                piece = new Piece(track);
                                htIds.Add(pieceId, piece);
                            }

                            all.Add(piece);

                        }
                    }
                    // link
                    foreach (Piece piece in all)
                    {
                        int parentId = piece.PieceParentId;
                        if (parentId > 0)
                        {
                            piece.Parent = htIds[parentId];
                        }
                    }

                    // liste FORT + albums

                    albums.checkBuild();
                    logger.log("build albums");
                    foreach (Piece piece in all)
                    {
                        if (piece.Parent == null)
                        {
                            listPiece.Add(piece);
                            foreach (Piece p in piece)
                            {
                                if (albums.check(p))
                                    listPieceInAlbum.Add(p);
                            }
                        }
                    }

                    var confGen = CConf.ConfGen;
                    var min = confGen.AlbumMin;

                    if (_albumVirtual && _firstConsolid)
                    {
                        logger.log("build albums virtuels");
                        var listCandidat = new List<Piece>();
                        var dictTmp = new BgDictString<Album>();
                        foreach (Piece piece in all)
                        {
                            if (piece.Parent == null)
                            {
                                piece.buildVirtualAlbums(listCandidat);
                            }
                        }
                        foreach (Piece p in listCandidat)
                            albums.checkVirtual(p, dictTmp);




                        min = confGen.PathVirtualMin;
                        if (min > 1)
                        {
                            // Suppression des albums virtuel par répertoire avec trop peu de morceaux
                            foreach (var key in new List<string>(dictTmp.Keys))
                            {
                                var a = dictTmp[key];
                                if (a.Virtual && !a.VirtualByArtist)
                                {
                                    if (a.Count < min)
                                        dictTmp.Remove(key);
                                }
                            }
                        }

                        if (confGen.ArtistVirtual)
                        {
                            min = confGen.AristVirtualMin;
                            if (min > 1)
                            {
                                // Suppression des albums artiste avec trop peu de morceaux
                                foreach (var key in new List<string>(dictTmp.Keys))
                                {
                                    var a = dictTmp[key];
                                    if (a.VirtualByArtist)
                                    {
                                        if (a.Count < min)
                                            dictTmp.Remove(key);

                                    }
                                }
                            }
                        }





                        var listAlbums = new List<Album>(dictTmp.Values);

                        listAlbums.Sort(new VirtualAlbumComparer());
                        albums.checkVirtuals(listAlbums, listPieceInAlbum);

                    }

                    albums.buildDone();

                    // Suppression des albums avec trop peu de morceaux
                    min = confGen.AlbumMin;
                    if (min > 1)
                    {
                        // Suppression des albums standards avec trop peu de morceaux
                        var dict = albums.Dict;
                        foreach (var key in new List<string>(dict.Keys))
                        {
                            var a = dict[key];
                            if (!a.Virtual)
                            {
                                if (a.Count < min)
                                    dict.Remove(key);
                            }
                        }
                    }

                }

                now = DateTime.Now; 

                StackAlbum.Instance.init(all);

                misc.log("StackAlbum.Instance.init(all); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                misc.log("allClassed; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 

                if (_firstConsolid)
                    albums.sortVirtual();

                misc.log("makeConsolid:init; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now; 
                Ranking(makeSort);
                misc.log("makeConsolid:fin; {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0")); now = DateTime.Now; 
            }
            finally
            {
                lock (_lock)
                {
                    _firstConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbum)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(TrackList track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort)
        {
            albums.buildStack(makeSort);
            QRanking();
            LRanking();
            QLRanking();


            var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");


            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);
            // if (makeSort)
            albums.makeSort(_firstConsolid);
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");
            DateTime now = DateTime.Now;
            DateTime debut = now; 



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }

            misc.log("piece.Rank.init(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 


            //on ordonne les morceaux top-down => sont privilégiés les plus en vue
            listPiece.Sort(l_pieceComparer);

            misc.log("listPiece.Sort(l_pieceComparer); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 

            //compactage de la liste en tenant compte des mieux notés
            m_list = new CListPiece(listPiece);


            misc.log(" m_list = new CListPiece(listPiece); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now; 
            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now; 
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }
            logger.log("fin : {0} {1} ms", m_listTrackClassed.Count, (DateTime.Now - now).TotalMilliseconds.ToString("0")); ; now = DateTime.Now; 
           // Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

            logger.log("total QRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now; 

            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }

            logger.log("total LRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualité +longueur en cas d'égalité
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            DateTime now = DateTime.Now;
            DateTime debut = now; 

            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }
#if COMPACT
            if (goCompact || CConf.ConfGen.AlbumSort.compactAny)
            {
                goCompact = false;
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();
            }
#endif

            //if (CConf.Condensation)
            //{
            //    var l = new List<Piece>(this.listPiece);
            //    l.Sort(new CPieceComparerByQualityAndLength2());
            //    new Condenseur(m_listQL).gener2();

            //}


            logger.log("total QLRanking {0} ms", (DateTime.Now - debut).TotalMilliseconds.ToString("0"));

        }


        private static volatile object _lockStat = new object();
        //   private static volatile object _lockStat2 = new object();
        private static bool buildingStat;
        const string BUILDING_STATE = @"..\building.txt";
        const string LOADING_EXCEL = @"..\busyExcel.txt";

        private void _buildStat(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 1");
                    return;
                }


                try
                {
                    if (File.Exists(LOADING_EXCEL))
                    {
                        string content = File.ReadAllText(LOADING_EXCEL);
                        misc.log(content);
                        if (content.Contains("BUSY"))
                        {
                            return;
                        }
                    }
                }
                catch (Exception ex)
                {
                    misc.logError("Impossible de lire le fichier lock excel", ex);
                    return;
                }

                buildingStat = true;
            }



            try
            {
                //bool ok = Monitor.TryEnter(_lockStat2, 60 * 1000);
                //if (!ok)
                //{
                //    misc.log("Pas pu entrer pour générer les stats !!!!!!");
                //    return;
                //}


                File.WriteAllText(BUILDING_STATE, "BUILDING");
                bool generDistrib = step % 10 == 0;

                if (_albumSortMode.createCourant)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(m_listQL).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(m_listQL) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                lock (_lockStat)
                {
                    buildingStat = false;
                    File.WriteAllText(BUILDING_STATE, "FREE");
                }
                if (rappel != null)
                    rappel();
            }
        }

        public void builStats(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 0");
                    return;
                }

            }
            new Thread(() => _buildStat(rappel)).Start();

        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table m�tier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;

namespace pdb.gen.albums
{


    public class Album : IEnumerable<Piece>
    {
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;

        private bool sortDone;
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }


            return ret; ;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
            }
        }
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero { get { return classementValueLightZero; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return _virtualByArtist; } set { _virtualByArtist = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, VirtualByArtist);
                return key;
            }
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0 { get { return Piece.getClassementEquiv(classementValueLightZero); } }

        // private string moyenne = "";
        public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return stackValue == stackSize; } }
        public bool AlmostFree1 { get { return stackValue == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            piece.PieceAlbum = this;
            if (build)
                return true;

            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                m_rank.init();
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && p.RapportClassement == 0)
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<PieceExtended> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {

                #region calcul virtuel



                DecimalPiece med = null;
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                bool combineNow = mode.combine && mode.simple;
                if (real)
                    _albumMedianne.buildVirtual(combineNow);
                else
                {
                    list.Sort(new PieceClassementComparer(false));
                }


                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.main);
                    med1 = med; med2 = med;
                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, PieceExtended.mode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }
                }



                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }









                classementValueLight = med.d;



                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, PieceExtended.mode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    if (mode.combine && !mode.simple)
                    {
                        _albumMedianne.buildVirtual(true);
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                        cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    }
                    else
                    {
                        if (true == cause.selectedMotifMin)
                            med = med2;
                        else
                            med = med1;
                    }



                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

                    foreach (var p in list)
                        p.finalyse();



                    if (cause.motifUp)
                    {
                        if (true == selectedMotifMin)
                            selectedCoeff = selectedCoeff.min;
                        else
                            selectedCoeff = selectedCoeff.main;
                    }

                    try
                    {
                        med.index.Piece.MedianneLight = true;
                        med.indexBorder.Piece.Border = true;
                        med.indexBorderEffect.Piece.BorderEffect = true;
                        med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public PieceExtended Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<PieceExtended> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;


            PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            PieceExtended nextZero1 = null;
            PieceExtended nextZero2 = null;

            PieceExtended min1 = null;
            PieceExtended min2 = null;
            PieceExtended min = null;
            decimal _min1 = int.MaxValue;
            decimal _min2 = int.MaxValue;
            decimal _minzero1 = int.MaxValue;
            decimal _minzero2 = int.MaxValue;
            bool realZero = false;
            PieceExtended Next = null;
            foreach (PieceExtended p in list)
            {
                var v1 = p.VirtualClassement;
                var v2 = p.VirtualClassement2;

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            _minzero1 = v1;
                            nextZero1 = p;
                            if (v1 == 0)
                                realZero = true;
                        }
                    }

                    if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2 == 0)
                                realZero = true;
                        }

                    }



                    if (v1 > 0 && v1 < _min1)
                    {
                        _min1 = v1;
                        min1 = p;
                    }

                    if (v2 > 0 && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }

                    if (p.Empty)
                        break;
                }
            }
            decimal _min = 0;
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;
            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }

            PieceExtended nextZero = null;
            decimal _minzero = int.MaxValue;
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }

            if (nextZero != null)
            {

                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.classementValueLightZero > classementValueLight + EPSILON) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minzero < classementValueLight)
                    {
                        classementValueLight = _minzero;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {
                        classementValueLight = _min;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            return cause;



        }




        public void makeSort(ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            if (sortDone)
                return;
            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;
            classementValueLightZeroSt = -1;
            selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;
            classementValueLight = 0;
            classementValueLightZero = 0;

            try
            {



                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return;

                atLeastOneEnabled = false;
                classed = false;

                var listE = new List<PieceExtended>(count);
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    p.eraseInfoMedianne();
                    if (p.Enabled)
                        atLeastOneEnabled = true;
                    var pp = new PieceExtended(p);
                    listE.Add(pp);
                }


                decimal offset = Album.conf.AlbumMoyOffset;



                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                classed = false;
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                }
                //misc.log("make sort Duration {0}", name); 
                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                decimal moy = 0m;

                #region init
                // misc.log("make sort calcul brut init {0}", name); 
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;

                    p.setClassementVirtuel(list[i].RapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;


                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }


                #endregion


                #region calcul virtuel
                //misc.log("make sort calcul virtuel {0}", name); 
                #region init (prise en compte coeff des enabled)
                //var coeffEnabled = conf.coeffEnabled;
                //for (int i = 0; i < count; i++)
                //{
                //    var p = list[i];
                //    var rapportClassement = p.RapportClassement;
                //    if (coeffEnabled != 1m && p.Enabled && (!conf.oldAsZero || !p.LastClassementRecent))
                //    {
                //        rapportClassement *= coeffEnabled;
                //    }
                //    p.setClassementVirtuel(rapportClassement);
                //    p.setClassementVirtuel2(rapportClassement);
                //}
                //list.Sort(new PieceClassementComparer(false));
                #endregion

                classementValueLightZero = makeSort(listE, mode0, false);
                classementValueLight = makeSort(listE, mode, true);

                #endregion

            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            sortDone = true;

        }



        public void mustRefresh()
        {
            build = false;
            sortDone = false;
            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
        }



        public decimal getTrackSortValue(int index, List<Piece> list)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            m_rank.init();
            // rankStack = -1;
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public bool isSameOf(Album o)
        {
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && _virtual == o._virtual && _virtualByArtist == o._virtualByArtist;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public DateTime AlbumAdded
        {
            get
            {
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                return min;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, bool artist)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();


                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }

            }
            return __album;

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        public BgDictString<Album> Dict { get { return dict; } }
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object();
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }


        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                foreach (Album album in dict.Values)
                {
                    album.checkBuild();
                }
            }
        }

        private string getKey(string _album, bool artist)
        {
            return Album.getKey(_album, artist);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                var confGen = CConf.ConfGen;
                var min1 = confGen.AlbumMin;
                var min2 = confGen.PathVirtualMin;
                var min3 = confGen.AristVirtualMin;
                foreach (Album album in new List<Album>(dict.Values))
                {
                    int count = album.Count;
                    bool toKeep = album.buildDone();
                    if (toKeep)
                    {

                        if (album.Virtual)
                        {
                            if (album.VirtualByArtist)
                            {
                                if (min3 > 1 && count < min3)
                                    toKeep = false;
                            }
                            else if (min2 > 1 && count < min2)
                                toKeep = false;
                        }
                        else if (min1 > 1 && count < min1)
                            toKeep = false;



                        if (!toKeep)
                        {
                            // misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
                            dict.Remove(getKey(album.Name, album.VirtualByArtist));
                        }

                    }

                }


            }
        }



        private bool check_(Piece piece, string albumOrg, bool virtualByArtist, IDictionary<string, Album> dict)
        {
            string __album = getKey(albumOrg, virtualByArtist);


            var album = dict[__album];
            if (album == null)
            {
                //  misc.log("creation album {0}", __album);
                album = new Album(albumOrg, __album);
                album.Virtual = piece.Virtual;
                album.VirtualByArtist = piece.VirtualByArtist;
                dict.Add(__album, album);
            }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualByArtist, dict);
        }

        public int Count { get { return dict.Count; } }





        public void sortVirtual()
        {
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {

            if (piece.Virtual)
                check_(piece, dict);

        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            var now = DateTime.Now;
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
            misc.log("buildStack; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
        }


        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public void makeSort(Piece piece)
        {
            if (piece == null)
                return;
            var album = piece.PieceAlbum;
            if (album == null)
                return;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            var main = confMedianne.Main;
            var coeffVirt = main.coeffVirt;
            var safe = main.safe;
            var coeffOld = main.CoeffOld;

            album.mustRefresh();
            album.makeSort(confMedianne, conf0); //listRef, reference); 

        }

        public void makeSort(bool sortAll)
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var main = confMedianne.Main;
                var coeffVirt = main.coeffVirt;
                var safe = main.safe;
                var coeffOld = main.CoeffOld;


                if (confSort.reset)
                {
                    main.coeffVirt = 1;
                    main.CoeffOld = 1;
                    main.safe = 0;
                }

                List<Album> list = new List<Album>(dict.Values);
                List<Album> listw = list;
                HashSet<Album> hs = null; 
                DateTime now = DateTime.Now;
                DateTime debut = now; 
                bool partial = !sortAll && confSort.optimSize > 0;
                int step =0; 
                while (true)
                {
                    step++; 
                   
                       
                        if (partial)
                        {
                            hs = new HashSet<Album>(); 
                            list.Sort(new AlbumClassComparer2());
                            list.Reverse(); 
                            listw = new List<Album>();
                            int nb = 0;
                            int max = step * confSort.optimSize; 
                            foreach (Album a in list)
                            {
                                if (a.AtLeastOneEnabled)
                                {
                                    nb++;
                                    listw.Add(a);
                                    hs.Add(a); 
                                    if (nb >= max)
                                        break; 
                                }
                            }
                        }


                    foreach (Album album in listw)
                    {
                        album.makeSort(confMedianne, conf0); //listRef, reference); 
                    }

                    misc.log(string.Format("makeSort : step={0}  {1} albums {2} ms",step, listw.Count,  (DateTime.Now - now).TotalMilliseconds));
                    now = DateTime.Now;
                    //if (confSort.reset)
                    //{
                    main.coeffVirt = coeffVirt;
                    main.CoeffOld = coeffOld;
                    main.safe = safe;
                    // }


                    list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                    list.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        list[i].Rank.Sort = i + 1;
                    }

                    if (!partial)
                        break;


                    list.Reverse(); 

                    int nbCheck = 0; 
                    bool? check = null; 
                    foreach (Album a in list)
                    {
                        if (!a.AtLeastOneEnabled)
                            continue;
                        if (hs.Contains(a))
                        {
                            nbCheck++;
                            if (nbCheck >= confSort.optimCheck)
                            {
                                check = true;
                                break;
                            }
                        }
                        else
                        {
                            check = false; 
                            break;
                        }


                    }

                    if (check == null || check.Value)
                        break; 

                }


                misc.log(string.Format("makeSort albums total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));

                List<Album> listSt = null;
                List<Album> list0 = null;
                List<Album> listSt0 = null;


                if (confSort.sortSt || confSort.correcMainRank || confSort.correcMainCoeff || confSort.correcMainZero)
                {
                    listSt = new List<Album>(list);

                    listSt.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                    listSt.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        listSt[i].RankSt = i + 1;
                    }
                    misc.log(string.Format("sort St : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sort0)
                {
                    now = DateTime.Now;
                    list0 = new List<Album>(list);

                    list0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                    list0.Reverse();
                    for (int i = 0; i < list0.Count; i++)
                    {
                        list0[i].RankZero = i + 1;
                    }
                    misc.log(string.Format("sort 0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sortSt0 || confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    listSt0 = new List<Album>(list);

                    listSt0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, conf0));
                    listSt0.Reverse();
                    for (int i = 0; i < listSt0.Count; i++)
                    {
                        listSt0[i].RankZeroSt = i + 1;
                    }
                    misc.log(string.Format("sort St0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    for (int i = listSt.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        Album zero = listSt0[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (un == zero)
                            un.InvalidateMain();
                    }
                    misc.log(string.Format("correcMainRank : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainCoeff)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLightSt * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLightSt;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }
                    misc.log(string.Format("correcMainCoeff : {0} ms", (DateTime.Now - now).TotalMilliseconds));

                }
                if (confSort.correcMainZero)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var unNext = un.Next;
                            if (unNext == null)
                                continue;

                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;

                                if (o.ClassementValueLightZeroSt < un.ClassementValueLightZeroSt)
                                {
                                    correc = false;
                                    break;
                                }

                                if (!unClassementRecent)
                                {
                                    if (o.ClassementValueLightZeroSt == un.ClassementValueLightZeroSt)
                                    {
                                        if (onext.LastClassementRecent)
                                        {
                                            correc = false;
                                            break;
                                        }
                                    }

                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }


                                //if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //    break;
                                // }



                                //if (o.RankSt <= un.RankSt)
                                //{
                                //    if (o.RankZeroSt > un.RankZeroSt)
                                //    {
                                //        correc = false;
                                //        break;
                                //    }

                                //    if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //        break;
                                //}

                            }

                            if (true == correc)
                                un.InvalidateMain();

                        }



                    }

                    misc.log(string.Format("correcMainZero : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }




                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}

                misc.log(string.Format("makeSort total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var now = DateTime.Now;
            var list = new List<Album>(dict.Values);

            //var confGen = CConf.ConfGen;
            //var min1 = confGen.AlbumMin;
            //var min2 = confGen.PathVirtualMin;
            //var min3 = confGen.AristVirtualMin;
            //foreach (Album album in dict.Values)
            //{
            //    int count = album.Count;
            //    bool toKeep = true;


            //    if (album.Virtual)
            //    {
            //        if (album.VirtualByArtist)
            //        {
            //            if (min3 > 1 && count < min3)
            //                toKeep = false;
            //        }
            //        else if (min2 > 1 && count < min2)
            //            toKeep = false;
            //    }
            //    else if (min1 > 1 && count < min1)
            //        toKeep = false;



            //    if (!toKeep)
            //    {
            //        misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
            //    }
            //    else
            //        list.Add(album);

            //}

            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            misc.log(string.Format("make selection : {0} ms", (DateTime.Now - now).TotalMilliseconds));
            return list;
        }

        public void changeAlbum(Piece p, string newA)
        {
            var currentAlb = dict[getKey(p.Album, false)];
            if (currentAlb != null)
                currentAlb.mustRefresh();
            check_(p, newA, false, this.dict);
            var newAlb = dict[getKey(newA, false)];
            if (newAlb != null)
                newAlb.mustRefresh();
            p.albumMustRefresh();

            //  invalidate(p); 
        }

        public void changeArtist(Piece p, string newA)
        {



            var currentAlb = dict[getKey(p.Artist, true)];
            if (currentAlb != null)
                currentAlb.mustRefresh();

            check_(p, newA, true, this.dict);
            var newAlb = dict[getKey(newA, true)];
            if (newAlb != null)
                newAlb.mustRefresh();
            p.albumMustRefresh();
        }

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                bool found = false;
                foreach (Album album in dict.Values)
                {
                    if (album.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.Clear();
                }
                else
                {
                    // on le prend.
                    dict.Add(getKey(candidat.Name, candidat.VirtualByArtist), candidat);
                    foreach (Piece p in candidat)
                    {
                        p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }




        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(TrackList track)
        {
            track.Piece.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track.Piece);
        }

        #region invalider


        public void invalidateAll()
        {
            foreach (var a in dict.Values)
                a.mustRefresh();
        }
        //public void invalidate(Piece piece)
        //{
        //    foreach (var p in piece.Master)
        //    {
        //        var key = getKey(p.Album, p.VirtualByArtist);
        //        var a = dict[key];
        //        if (a == null)
        //        {
        //        }
        //        else
        //            a.invalidate();
        //        //if (p.Virtual)
        //        //    continue; 
        //        ////1. check standard
        //        //var key = getKey(p.Album, false);
        //        //var a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 
        //        ////2. check artiste
        //        //key = getKey(p.Artist, true);
        //        //a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 

        //        ////3. check paths
        //        //foreach (string path in p.getIntermediaryPath())
        //        //{
        //        //    key = getKey(path, false);
        //        //    a = dict[key];
        //        //    if (a == null)
        //        //    {
        //        //    }
        //        //    else
        //        //        a.invalidate(); 
        //        //}
        //    }
        //}
        #endregion



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfAlbumSort.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.gen.medianne;
using pdb.util;

namespace pdb.gen.Tuning
{
    [Serializable]
    /// <summary>
    /// Configuration sort Albums
    /// </summary>
    public class ConfAlbumSort : TuningBase
    {

        private List<ConfMedianne> composants = new List<ConfMedianne>();
        private List<ConfMedianne> composantsUtiles = new List<ConfMedianne>();
        public List<ConfMedianne> Composants { get { return composants; } }
        public List<ConfMedianne> ComposantsUtiles { get { return composantsUtiles; } }
        // public decimal coeffEnabled = 1m;
        public int stackSize = 0;
        public int stackPeremption = 10;
        public decimal stackPower = 2.0m;
        public int stackBefore = 0;
        public bool checkStack = false;
        public bool stackEnabled = true;
        public bool stackOnlyNew = false;
        public DateTime lastModif;
        public DateTime newA;
        public DateTime compact;
        public bool compactAny;
        public bool createCourant = true;
        public bool createInter = true;
        public bool createAll;

        public bool reset;
        public bool correcMainRank, correcMainCoeff, correcMainZero, dontTouchMain;
        public bool sortSt, sort0, sortSt0;
        public int correcMainZeroOptim;

        public int optimSize = -1;
        public int optimCheck = 20; 

        // public bool oldAsZero; 
        public void Calcul()
        {
            composantsUtiles = new List<ConfMedianne>();
            foreach (var cmp in composants)
            {
                if (cmp.enabled)
                    composantsUtiles.Add(cmp);
            }
            if (composantsUtiles.Count == 0)
                composantsUtiles.Add(composants[0]);
        }
        public ConfAlbumSort()
        {
        }

        public ConfAlbumSort(XmlElement node)
            : base(node)
        {

            composants.Clear();
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    var cmp = new ConfMedianne(node, sub as XmlElement);
                    composants.Add(cmp);
                }
            }


            buildi("stackSize", v => stackSize = v);
            buildi("stackPeremption", v => stackPeremption = v);
            buildi("stackBefore", v => stackBefore = v);
            builddec("stackPower", v => stackPower = v);

            buildb("stackEnabled", v => stackEnabled = v);
            buildb("stackOnlyNew", v => stackOnlyNew = v);
            buildb("checkStack", v => checkStack = v);
            buildDate("lastModif", v => lastModif = v);
            buildDate("compact", v => compact = v);
            buildb("compactAny", v => compactAny = v);
            buildDate("newA", v => newA = v);
            buildb("createCourant", v => createCourant = v);
            buildb("createInter", v => createInter = v);
            buildb("createAll", v => createAll = v);

            buildb("correcMainCoeff", v => correcMainCoeff = v);
            buildb("correcMainRank", v => correcMainRank = v);
            buildb("correcMainZero", v => correcMainZero = v);
            buildi("correcMainZeroOptim", v => correcMainZeroOptim = v);
            buildb("dontTouchMain", v => dontTouchMain = v); 


            buildb("sortSt", v => sortSt = v);
            buildb("sort0", v => sort0 = v);
            buildb("sortSt0", v => sortSt0 = v);

            buildi("optimSize", v => optimSize = v);
            buildi("optimCheck", v => optimCheck = v); 




            Calcul();

        }

        public override void save(XmlWriter w)
        {
            base.save(w);
            writeStart("albumSort");

            write("stackSize", stackSize);
            write("stackPeremption", stackPeremption);
            write("stackBefore", stackBefore);
            write("stackPower", stackPower);

            write("stackEnabled", stackEnabled);
            write("stackOnlyNew", stackOnlyNew);

            write("checkStack", checkStack);
            write("lastModif", lastModif);
            write("compact", compact);
            write("compactAny", compactAny);
            write("newA", newA);
            write("createCourant", createCourant);
            write("createInter", createInter);
            write("createAll", createAll);

            write("correcMainCoeff", correcMainCoeff);
            write("correcMainRank", correcMainRank);
            write("correcMainZero", correcMainZero);
            write("correcMainZeroOptim", correcMainZeroOptim);
            write("dontTouchMain", dontTouchMain); 

            write("sortSt", sortSt);
            write("sort0", sort0);
            write("sortSt0", sortSt0);

            write("optimSize", optimSize);
            write("optimCheck", optimCheck); 




            foreach (var cmp in composants)
                cmp.save(w);
            writeEnd();
        }
        public bool Enabled
        {
            get
            {
                foreach (var cmp in composants)
                {
                    if (cmp.enabled)
                        return true;
                }
                return false;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\CDb.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using Math = System.Math;

namespace pdb.db
{
    public enum mergePriority
    {
        left = -1,
        right = 1,
        none = 0
    }
    /// <summary>
    /// g�re la persistence
    /// </summary>  
    /// <remarks></remarks>
    public class CDb
    {
        public const int CURRENT_VERSION = 3;
        // const string ZIP_KEY = "db"; 
        public static int Version;

        const string SEQ_PIECE = "seq_piece";
        const string SEQ_LIST = "seq_list";
        private static int pieceSequenceId = 0;
        private static int listSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private static int getListNextId { get { listSequenceId++; return listSequenceId; } }
        private FileInfo LOCAL_FILE;
        private FileInfo REMOTE_FILE;
        private FileInfo LastFullFile;
        private FileInfo DiffFile;
        private FileInfo SOV;
        private CListPiece m_list;
        private CListPiece lastFull; private CListPiece remoteOrg;
        private CListPiece trace;
        private DateTime now;
        private string sovRep;
        private DateTime lastSov;
        private int nbOpe;

        private bool loadRemote;
        private bool loadTrace;
        //private bool loadLastFull;
        //private bool loadDiff;



        private FileInfo remoteTrace;
        private DataConf conf;

        private dbMode mode;
        public dbMode Mode { get { return mode; } }
        public CDb(DataConf conf)
        {
            this.conf = conf;
            LOCAL_FILE = conf.dbLocal;
            REMOTE_FILE = conf.dbRemote;
            remoteTrace = conf.dbTrace;
            LastFullFile = conf.dbLastFull;
            DiffFile = conf.dbDiff;
            SOV = conf.dbSov;
            this.mode = conf.mode;

            init();
        }

        public string DefaultFolder { get { return conf.defaultFolder; } }

        private void init()
        {
            this.now = DateTime.Now;
            lastSov = now;
            sovRep = now.ToString("yy-MM-dd_HH-mm-ss");



            System.DateTime l_localDate = System.DateTime.MinValue;
            System.DateTime l_remoteDate = System.DateTime.MinValue;

            if (LOCAL_FILE.Exists)
                l_localDate = LOCAL_FILE.LastWriteTime;
            if (REMOTE_FILE.Exists)
                l_remoteDate = REMOTE_FILE.LastWriteTime;


            TimeSpan l_dif = l_localDate.Subtract(l_remoteDate);
            double l_sec = l_dif.TotalSeconds;
            if (REMOTE_FILE.Exists)
            {

                if (Math.Abs(l_sec) > 3 || (LOCAL_FILE.Exists && REMOTE_FILE.Length != LOCAL_FILE.Length))
                {
                    loadRemote = true;
                }
                else
                {
                    log("not load remote, same file");
                }
            }
            else
            {
                log("remote file does not exist");
            }

            if (remoteTrace != null && remoteTrace.Exists)
                loadTrace = true;




        }

        public void loadData()
        {
            // cas diff-> je mémorise lastFull, je r�cup�re l'instantan�
            // cas full -> je ne m�morise pas lastFull, je r�cup�re le diff et fait le merge

            // gestion des diff
            //if (mode == dbMode.diff)
            //{
            // je sauvegarde lastFull
            misc.log("mode:{0}  LastFullFile.Exists: {1} DiffFile.Exists: {2}", mode, LastFullFile.Exists, DiffFile.Exists);
            if (mode == dbMode.diff)
            {
                if (LastFullFile.Exists)
                {
                    log("load lastFull");
                    lastFull = loadData(LastFullFile);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                }

                log("load local");
                m_list = loadData(LOCAL_FILE);
            }

            else
            {

                log("load local");
                m_list = loadData(LOCAL_FILE);
                if (DiffFile.Exists)
                {


                    log("load diff");
                    var diff = loadData(DiffFile);


                    log("consolid diff and local");
                    foreach (CPiece pdiff in diff)
                    {
                        m_list.Consolid(pdiff, mergePriority.right);
                    }

                    var sov = DiffFile.FullName.Replace(".xml", ".sov.xml");
                    DiffFile.CopyTo(sov, true);
                    DiffFile.Delete();


                    write();

                    log("load local consolidé for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                    addToZip(true, LOCAL_FILE.FullName);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);

                    if (loadRemote)
                    {
                        log("load remote");
                        remoteOrg = loadData(REMOTE_FILE);
                        log("consolid remote and local");
                        m_list.Consolid(remoteOrg);
                    }
                }
            }


            if (loadTrace)
            {
                log("load trace");
                trace = loadData(remoteTrace);
            }
        }

        public void eraseClassementForEnabled()
        {

            foreach (CPiece piece in m_list)
            {
                if (piece.Enabled)
                {
                    piece.eraseClassement();
                }
            }
        }

        public List<ITrackIdentity> Files
        {
            get
            {
                return new List<ITrackIdentity>(m_list.getList());
            }
        }

        // r�cup�ration des infos externes
        public void LegacyConsolid(CListPiece list, DateTime date)
        {
            misc.log("Cdb::LegacyConsolid");

            DateTime now = DateTime.Now;
            ChronoData.refreshDate(date);

            foreach (CPiece ext in list)
            {
                m_list.legacyConsolid(ext);
            }

            m_list.bilanNatives();

            // setAlbumArtistFromFile();

        }

        public void LegacyConsolid(CPiece ext)
        {
            m_list.legacyConsolid(ext);
        }

        public void SynchroNative(DateTime date)
        {
            misc.log("Cdb::SynchroNative");
            ChronoData.refreshDate(date);
            foreach (CPiece piece in m_list)
            {
                piece.SynchroNative();
            }

        }

        //private void setAlbumArtistFromFile()
        //{
        //    foreach (ITrackMetaData piece in m_list)
        //    {
        //        setAlbumArtistFromFile(piece);
        //    }
        //}



        private void setAlbumArtistFromFile(ITrackMetaData piece)
        {

            try
            {
                string location = piece.Location;
                if (location.isNullorEmpty())
                    return;
                FileInfo file = new FileInfo(location);
                DirectoryInfo dAlbum = file.Directory;
                string dirAlbum = dAlbum.Name;
                string dirArtist = dAlbum.Parent.Name;
                string artist = piece.Artist;
                string album = piece.Album;

                string newArtist = artist;
                string newAlbum = album;




                if (artist.isNullorEmpty())
                {
                    if (!TrackIdentity.UNKNOW_ARTIST.Equals(dirArtist))
                        newArtist = dirArtist;
                    //if (!UNKNOW_ARTIST.Equals(newArtist))
                    //    piece.Artist = newArtist;
                }

                if (album.isNullorEmpty())
                {
                    if (!dirAlbum.Contains(TrackIdentity.UNKNOW_ALBUM))
                    {
                        newAlbum = dirAlbum;
                        if (newArtist.NotNullOrEmpty())
                        {
                            if (!TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                                newAlbum = newAlbum.Replace(newArtist, "");
                        }
                    }
                }

                //if (TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                //    piece.Artist = "";
                //else 
                if (newArtist != artist)
                    piece.Artist = newArtist;

                //if (TrackIdentity.UNKNOW_ALBUM.Equals(newAlbum))
                //    piece.Album = "";
                //else
                if (newAlbum != album)
                    piece.Album = newAlbum;

            }
            catch (Exception e)
            {
                misc.log(e.ToString());
            }
        }



        #region "sauvegarde"



        //public void Sov(string fileIt)
        //{
        //    if (SOV == null)
        //        return;
        //    var list = new List<string> { fileIt, LOCAL_FILE.FullName };
        //    if (loadRemote)
        //        list.Add(REMOTE_FILE.FullName);
        //    if (loadTrace)
        //        list.Add(remoteTrace.FullName);

        //    ZipUtil.compress(SOV.FullName, sovRep, list);
        //}

        public void SovIni()
        {
            ZipUtil.Enter(); 
            if (SOV == null)
                return;
            var list = new List<string> { LOCAL_FILE.FullName, LastFullFile.FullName, DiffFile.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            list.AddRange(conf.othersIni);

            ZipUtil.CompressAsync(SOV.FullName, sovRep, list);
            ZipUtil.Release(); 
        }


        #endregion

        public void removeVersions()
        {
            misc.log("Suppression des versions !!!");
            foreach (CPiece piece in m_list)
            {
                piece.removeVersions();
            }
        }

        public void Menage()
        {
            foreach (CPiece piece in m_list)
            {
                piece.Menage();
            }
        }

        public void WriteDB1()
        {

            misc.log("CDb:WriteDB1");

            lock (lockSave)
            {
                ZipUtil.Enter(); 
                write();
                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                misc.log("CDb:fin WriteDB1");
                ZipUtil.Release(); 
            }

        }
        public void saveAsync()
        {
            lock (this)
            {
                _goSave = true;
                if (thSave == null)
                {
                    thSave = new Thread(loopSave);
                    thSave.Start();
                }
            }
        }
        private Thread thSave;
        private bool _goSave;
        private volatile object lockSave = new object();

        public void export(string filename, List<CPiece> l)
        {

            var list = new List<CPiece>();
            var hs = new HashSet<int>();
            foreach (CPiece p in l)
            {
                if (hs.Add(p.PieceId))
                    list.Add(p);
                if (p.PieceParentId > 0)
                {
                    var parent = m_list.getPiece(p.PieceParentId);
                    if (hs.Add(parent.PieceId))
                        list.Add(p);
                }
            }

            m_list.Sort(list);

            var f = conf.getFilename(filename);
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(f, settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());


                writer.WriteStartElement(CListPiece.PIECES);

                foreach (CPiece l_piece in list)
                {
                    l_piece.write(writer);
                }
                writer.WriteEndElement();


                writer.WriteEndDocument();
                writer.Flush();
            }
        }

        private void write()
        {
            try
            {
                ZipUtil.Enter();
                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(REMOTE_FILE.FullName + ".tmp", settings))
                {
                    writer.WriteStartElement("db");
                    writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                    writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                    writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                    m_list.write(writer);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);



                if (lastFull != null)
                {
                    try
                    {
                        var diff = DiffFile.FullName;
                        if (mode == dbMode.full)
                            diff = diff.Replace(".xml", ".d.xml");

                        using (XmlWriter writer = XmlWriter.Create(diff + ".tmp", settings))
                        {
                            writer.WriteStartElement("db");
                            writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                            writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                            m_list.writeDiff(writer, lastFull);
                            writer.WriteEndDocument();
                            writer.Flush();
                        }

                        File.Copy(diff + ".tmp", DiffFile.FullName, true);
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }
                }



                WriteDB2();
            }
            finally
            {
                ZipUtil.Release();
            }
        }
        private void loopSave()
        {
            while (true)
            {
                Thread.Sleep(1000);
                if (!_goSave)
                    continue;
                lock (this)
                    _goSave = false;

                lock (lockSave)
                {

                    try
                    {
                        write();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        lock (this)
                            _goSave = true;
                    }
                }

            }
        }

        public void WriteDB2()
        {

            misc.log("CDb:WriteDB2");
            
            lock (lockSave)
            {
                ZipUtil.Enter(); 
                REMOTE_FILE.CopyTo(LOCAL_FILE.FullName, true);
                ZipUtil.Release(); 
            }
            misc.log("CDb:WriteDB2");

            nbOpe++;
            var now = DateTime.Now;
            var ts = now - lastSov;
            if (nbOpe >= conf.sovNb || ts > conf.sovMin)
            {
                nbOpe = 0;
                lastSov = now;
                DiffFile.Refresh();
                if (DiffFile.Exists)
                {
                    var list = new List<string> { DiffFile.FullName };
                    list.AddRange(conf.othersDiff);
                    addToZip(true, list.ToArray());
                    //var cp = DiffFile.DirectoryName + Path.DirectorySeparatorChar + now.ToString("yy-MM-dd_HH-mm-ss") + DiffFile.Name;
                    //DiffFile.CopyTo(cp);
                    //var list = new List<string> { cp };
                    //ZipUtil.compress(SOV.FullName, sovRep, list);
                    //File.Delete(cp); 
                }


            }
        }

        private void addToZip(bool withHorodate, params string[] list)
        {
            ZipUtil.CompressAsync(SOV.FullName, sovRep, list, withHorodate);
            //   ZipUtil.compress(SOV.FullName, sovRep, list, withHorodate);
        }


        public CListPiece List
        {
            get
            {
                return m_list;

            }

        }

        public CListPiece Remote
        {
            get
            {
                if (loadRemote)
                    return remoteOrg;
                return null;
            }

        }

        public CListPiece Trace
        {
            get { return trace; }
        }

        private XmlElement loadList(FileInfo file, List<CPiece> list)
        {
            XmlElement root = null;
            if (file.Exists)
            {
                XmlDocument l_doc = new XmlDocument();


                l_doc.Load(file.FullName);

                root = l_doc.DocumentElement;
                var xmlTool = new XMLTool(root);
                var version = xmlTool.getIntAttValue("version");
                if (version > 0)
                    Version = version;


                var seqPiece = xmlTool.getIntAttValue(SEQ_PIECE);
                if (seqPiece > pieceSequenceId)
                {
                    pieceSequenceId = seqPiece;
                }

                var seqList = xmlTool.getIntAttValue(SEQ_LIST);
                if (seqList > listSequenceId)
                {
                    listSequenceId = seqList;
                }

                var pieceRoot = root;
                if (version > 0)
                    pieceRoot = root.ChildNodes[0] as XmlElement;



                foreach (XmlElement l_xml in pieceRoot.ChildNodes)
                {
                    CPiece l_piece = new CPiece(l_xml);

                    list.Add(l_piece); //TODO provisoire
                    if (version > 0)
                        checkId(l_piece);
                    else
                    {
                        if (m_list != null)
                        {
                            m_list.checkId(l_piece);
                        }
                        checkId(l_piece);
                    }
                    //}
                }
                misc.log("aux list: " + list.Count);




            }
            else
            {

            }

            return root;
        }



        private CListPiece loadData(FileInfo file)
        {
            if (file.Exists)
            {

                List<CPiece> l_list = new List<CPiece>();
                var root = loadList(file, l_list);


                misc.log("aux list: " + l_list.Count);
                System.DateTime l_date = file.LastWriteTime; // File.GetLastWriteTime(a_path);

                //chasse aux doublons
                CListPiece l_ret = new CListPiece(l_list, l_date);
                misc.log(" list: " + l_ret.Count);

                var xLists = XMLTool.NodeLookUp(root, CListPiece.TOKEN_LISTS);

                l_ret.loadListes(xLists);
                return l_ret;
            }
            else
            {
                return new CListPiece();
            }

        }

        public static void checkId(CPiece l_piece)
        {
            if (l_piece.PieceId < 0)
                l_piece.setId(getPieceNextId);
            if (l_piece.PieceId > pieceSequenceId)
                pieceSequenceId = l_piece.PieceId;
        }

        public static void checkId(CPlayList pl)
        {
            if (pl.ID < 0)
                pl.ID = getListNextId;
            if (pl.ID > listSequenceId)
                listSequenceId = pl.ID;
        }
        private void log(String txt)
        {
            misc.log(txt);
        }

        public CPiece getPiece(string location)
        {
            return m_list.getPiece(location);
        }

        public CPiece getPiece(int id)
        {
            return m_list.getPiece(id);
        }
    }


}


]]></content>
  </file>
</db>
