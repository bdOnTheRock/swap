<db path="C:\bernard\db2\">
  <file path="db4\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.iit;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Albums;
using pdb.podcast.Auto;
using pdb.podcast.Delta;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Sort;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;
using PlayList = pdb.it.PlayList;
using pdb.podcast.Date0;
using pdb.podcast.Notes;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static ILoader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto;
        static int step = -1;
        static Program _instance = new Program();
        // static bool calculRoots = false;
        static List<HashSet<int>> lists = null;
        static AlbumMgr albumMgr = AlbumMgr.Instance;

        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        public static Chrono chrono = new Chrono();
        private static Logger logChrono;
        private static DB.Db db;
        static Hibernator hibernator = new Hibernator();

        //public static DB.Db Db { get { return db; } }


        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {
            Logger.init(Environment.CurrentDirectory.Replace("\\", "_") + string.Join("_", args));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono", true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true;

            FileRegister.init(new Dictionary<string, FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true;

                loader.saveIds();
                //if (db != null)
                //    db.write();

                if (db != null)
                {
                    while (db.Writing)
                    {
                        misc.log("waiting db writing");
                        Thread.Sleep(1000);
                    }
                }
                Console.WriteLine("\nFin de l'opération d'enregistrement.");

                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();

                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Memory.End();
                Exporter.Abort();



                //if (_writeDb != null)
                //{
                //    misc.log("attente writeDb");
                //    _writeDb.Wait();
                //}
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                if (db != null)
                    db.write();
                postReport(Conf.DirConf,true); 
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}

        #region Task


        private List<ITrackInfoItunes> loadTracks(bool firstStep, bool forceLoad)
        {
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
            loader.loadTracks(firstStep, forceLoad, listTrack);

            return listTrack;

        }
        #endregion


        private static void SyncDb(List<TrackInfoItunes> list, bool checkInOut)
        {
            if (db == null)
                return;
            log.log("SyncDb checkInOut= " + checkInOut);
            foreach (TrackInfoItunes t in list)
            {
                if (checkInOut)
                    t.checkInOut();
                var tdb = db.get(t);
                if (tdb == null)
                {
                    log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                    continue;
                }
                tdb.synch(t);

            }
            log.log("Fin SyncDb checkInOut= " + checkInOut);

        }

        public void go(string[] args)
        {
            //  TrackInfoItunes.AlbumMgr = albumMgr;
            //int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            //if (countArgs > 0)
            //    confFile = args[0];
            bool _fin = false;

            bool modeDownLoad = false;
            foreach (string v in args)
            {
                if ("-download".Equals(v))
                {
                    modeDownLoad = true;
                    log.log("mode download");
                }
            }

            Album.logDebug = Logger.getLogger("pubDebug", false);
            Album.log = Logger.getLogger("pub2", Album.logDebug, true);
            Album.logDebug.NoReset = true;
            Album.log.NoReset = true;

            DateRefBuilder dateRefBuilder = new DateRefBuilder();
            try
            {

                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start(60);

                // bool firstLoad = true;


                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                // TrackInfoItunes.setDate0(Conf.Date0);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                //TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                TrackInfoItunes.PlayedLevel = Conf.DateLevel;
                var itConf = new pdb.it.Conf(xelt);

                // loader = new Loader(itConf, true);
                bool import = Conf.Import.enabled || Conf.Import.merge;
                db = new DB.Db();


                if (Conf.UseMock)
                    loader = new MockLoader(itConf.DefaultFolder);
                else
                    loader = new Loader(itConf, import, db,
                        () =>
                        {
                            misc.Pre = "[Load " + step + "] ";

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.AbortSpecial();
                            //   Thread.Sleep(1000); 
                            //  BackGroundTaskMgr.Start(); 
                        }, Conf.OnlyEnabled, Conf.OnlyUnRead)

                   ;
                // loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder;

                db.load();
                //  db.write(); return; 


                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();

                List<TrackInfoItunes> listIt = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);




                bool firstlaunched = false;
                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}"));
                        chrono.reset("Program");

                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.setConf(xelt);
                        //loader.Conf = new it.Conf(xelt);
                        // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut", true);
                        List<TrackInfoItunes> list = null;
                        DirConf root = null;
                        if (step == 0 || !Conf.Simulation)
                        {
                            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();



                            listTrack = loadTracks(step == 0, AutoBuilder.MustUpdate);


                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();

                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            // listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {

                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                // loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            //    loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            listIt = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            // GroupStat trackStat = new GroupStat();

                            loader.saveIds();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location)) // || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }
                                    FileRegister.Push(location);
                                    dictLoc[t.Location] = t;
                                    listIt.Add(t);
                                    // if (!t.Played)
                                    //    trackStat.recordTrack(t, typeState.all);
                                    //trackStat.recordTrack(t, typeState.all);
                                }
                            }



                            db.recordIt(listIt);
                            chrono.bip("loadTracks", true);
                            var dedoubler = new Dedoubler();
                            dedoubler.checkDoublons(db.Tracks);
                            chrono.bip("Dedoubler", true);

                            //if (dedoubler.NbDoublons>0)
                            //{
                            //    db.write(); 
                            //}

                            Download.Downloader downloader = null;
                            if (modeDownLoad)
                            {
                                //new Thread(() => loader.updatePocasts()).Start();
                                downloader = new Download.Downloader(db);
                                downloader.go();

                                loader.loadTrackToDownload(downloader.ToDownload);
                                return;
                            }



                            // ici on peut faire la verification des doublons - track hibernés et re-téléchargés par ce con d'itunes
                            using (var albumConsolid = new AlbumConsolid())
                            {
                                foreach (TrackAlbum album in albumMgr.List)
                                {
                                    albumConsolid.consolid(album);
                                }
                            }

                            log.log("nb123={0} nb12={1} nb13={2} nb23={3} nb1={4} nb2={5} nb3={6} nb0={7}, nb3n={8}",
                                AlbumConsolid.nb123, AlbumConsolid.nb12, AlbumConsolid.nb13, AlbumConsolid.nb23,
                                AlbumConsolid.nb1, AlbumConsolid.nb2, AlbumConsolid.nb3, AlbumConsolid.nb0, AlbumConsolid.nb3n);

                            var scan = Conf.Scan;
                            if (!string.IsNullOrEmpty(scan))
                            {
                                var s = new Scanneur(scan, loader as Loader, db);
                                s.Scan();
                                db.write();
                                return;
                            }
                            root = Conf.DirConf;
                            var feeds = root.Feeds;

                            if (Conf.Freewheel)
                            {
                                PlayList.StartOpe();
                                Freewheel(root);
                                log.log("Freewheel : fin sans enregistrement DB");
                                return;
                            }



                            if (Conf.Import.enabled)
                            {
                                var listImport = new List<TrackInfoItunes>();
                                hibernator.select(Conf.Import, listImport, db.Tracks, true);

                                foreach (TrackInfoItunes tdb in listImport)
                                {
                                    loader.import(tdb);
                                }
                            }
                            else if (Conf.Import.merge)
                            {
                                foreach (TrackInfoItunes t in listIt)
                                    loader.merge(t);
                            }



                            list = db.Tracks;
                            foreach (TrackInfoItunes track in list)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds", true);


                            var loaded = feeds.Loaded;
                            loaded.Sort(new PodCastComparer());

                            bool changeDate = false;
                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            {
                                dateRefBuilder.prepare(loaded);

                            }

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);



                            if (Conf.Sort.selectionBefore)
                            {



                                //***************** Lancement "pour de vrai" ***************************************

                                LimitItemLoader.ModeSelection = true;

                                loadCandidat(root);
                                chrono.bip("loadCandidat(root)");
                                //  AutoBuilder.test(); 
                                // standAlone(root); 
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root)");
                                //**********************************************************************************


                                ////****************************************
                                //// lancement des sorties xml et html en asynchrone
                                //postReport(root, true);
                                ////****************************************


                            }



                            if (Conf.Sort.checkBefore)
                            {
                                Album.Init();
                                var sorter = new Sorter(Conf.Sort, list);
                                sorter.build();
                                chrono.bip("sorter.build();", true);


                                changeDate = dateRefBuilder.autoSafe(loaded);
                                //TrackInfoItunes.setDate0(Conf.Date0);
                                double offsetIni = dateRefBuilder.getOffset();
                                AutoBuilder.Offset = offsetIni;

                                if (Album.NbRepeches > 0 && !Conf.DateRef.auto)
                                {
                                    log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                    _fin = true;
                                }
                            }

                            dateRefBuilder.saveCurrent();
                            ContexteBuilder.Instance.init(loaded);
                            Conf.DateRef.contexte = ContexteBuilder.Instance.Debut;

                            if (Conf.Import.enabled || Conf.Import.merge)
                            {
                                _fin = true;

                            }



                            if (_fin)
                            {
                                log.log("fin sans enregistrement DB");
                                //  db.write();


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, true);
                                //****************************************
                                return;
                            }


                            if (Album.NbModif > 0)
                            {
                                resetLoad(root);

                            }
                            //bool changeDate = false;
                            //if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            //{
                            //    changeDate = dateRefBuilder.auto(loaded);
                            //    TrackInfoItunes.setDate0(Conf.Date0);
                            //    double offsetIni = dateRefBuilder.getOffset();
                            //    AutoBuilder.Offset = offsetIni;
                            //}
                            AutoBuilder.init(true);
                            if (Conf.Sort.stopOnOffset && changeDate)
                            {
                                log.log("fin cause stopOnOffset");
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                                return;
                            }

                            if (Conf.Sort.stopOnPub2 && Album.NbModifPertinent > 0)
                            {
                                log.log("fin cause stopOnPub2");
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                                return;
                            }

                            AutoBuilder.Offset = 0;
                            chrono.bip("AutoBuilder.init(true)");
                            xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            loader.setConf(xelt);

                            //ContexteBuilder.Instance.init(loaded);

                            //Conf.DateRef.contexte = ContexteBuilder.Instance.Debut;
                            //   dateRefBuilder.saveCurrent();



                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            //trackStat.report(descTrack);
                            //log.log(descTrack.ToString());

                            //var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            //var trackFile = DescBuilder.create("Tracks", sbT);
                            //trackStat.report(trackFile);
                            //sbT.Flush();

                            //asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            //chrono.bip("desc tracks", true);
                            //Logger.LogConsole = false;
                            //        loader.loadLists();
                            Logger.LogConsole = true;
                            chrono.bip("load list", true);

                        }
                        list = db.Tracks;


                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program");
                            root = Conf.DirConf;
                            var feeds = root.Feeds;
                            foreach (TrackInfoItunes track in feeds.getSelectedTracks())
                            {
                                track.clearLists();
                            }

                            feeds.clearSelectedTracks();

                            chrono.bip("track.clearLists", true);

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;




                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true;
                            AutoBuilder.init(true);
                            chrono.bip("AutoBuilder.init(true)");
                            loadCandidat(root);
                            chrono.bip("loadCandidat(root)");
                            //  AutoBuilder.test(); 
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            chrono.bip("Selection(root)");
                            //**********************************************************************************

                            Album.Init();

                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.reset ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.once ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.white ||
                                (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all && !firstlaunched))
                            {
                                if (Sorter.NbLaunch == 0 || (Conf.Sort.enabled != Tuning.Sort.sortMode.white && Conf.Sort.enabled != Tuning.Sort.sortMode.once))
                                {
                                    var sorter = new Sorter(Conf.Sort, list);
                                    sorter.build();
                                }
                                _fin = Conf.Sort.enabled == Tuning.Sort.sortMode.white || Conf.Sort.enabled == Tuning.Sort.sortMode.reset;
                                if (!_fin && Album.NbModif > 0)
                                    resetLoad(root);
                            }

                            firstlaunched = true;

                            if (Album.NbRepeches > 0)
                            {
                                log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                _fin = true;
                            }



                            if (!_fin) // && Album.NbModif == 0)
                            {

                                //***************** Lancement "pour de faux" ***************************************
                                AutoBuilder.Init3();
                                chrono.bip("AutoBuilder.Init3()");
                                LimitItemLoader.ModeSelection = false;
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root) 2");
                                LimitItemLoader.ModeSelection = true;
                                //**********************************************************************************
                            }
                            Exporter.TopCopy();
                            chrono.bip("selection");




                            // Conf.date00Consume();
                            // TrackInfoItunes.setDate0(Conf.Date0);

                            int iii = 0;
                            while (!BackGroundTaskMgr.ConfirmEnd(10))
                            {
                                iii++;
                                if (iii == 60)
                                    iii = 0;
                                if (iii == 0)
                                {
                                    log.log("Attente Classement");
                                }
                                Thread.Sleep(100);
                            }






                            if (_fin || Album.NbModif > 0)
                            {
                                log.log("{0} éléments ont la Pub2 modifiée", Album.NbModif);

                                //foreach (TrackInfoItunes t in list)
                                //{
                                //    var tdb = db.get(t);
                                //    if (tdb == null)
                                //    {
                                //        log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                //        continue;
                                //    }
                                //    tdb.synch(t);

                                //}



                                if (_fin)
                                {
                                    SyncDb(list, true);
                                    db.writeAsync();
                                    log.log("fin");
                                    return;
                                }
                                // continue;
                            }




                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    //if (count == 1)
                                    //    s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu");

                            if (Conf.GenFeed)
                            {
                                foreach (RootItItem rootItem in Conf.RootIt)
                                {
                                    var fAuto = loader.TreePlayList.getComposite(rootItem.name);
                                    var fFeeds = fAuto.getComposite("Feed");

                                    if (fFeeds != null)
                                    {
                                        scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                    }

                                }
                            }


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root, false);
                            //****************************************



                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                            //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            chrono.bip("AutoBuilder.init(false)");
                            bool cangoAuto = AutoBuilder.Check(feeds);

                            chrono.bip("AutoBuilder");
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");

                                // postReport(root, true);

                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false;
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true;
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                //  tw = new StringBuilder();
                                //feeds.rapportPreSelected(tw);
                                //asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false;
                                log.log(sb2.ToString());
                                Logger.LogConsole = true;


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false;
                                log.log(sb3.ToString());
                                Logger.LogConsole = true;
                                chrono.bip("rapport", true);
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 



                        SyncDb(list, true);
                        db.writeAsync();


                        Logger.CreateNullLoggers = false;

                        int nbH = 0;
                        _fin = false;
                        if (Conf.Hibernate.enabled)
                        {
                            nbH = hibernator.go(loader, list);
                            if (nbH > 0)
                            {
                                log.log("{0} elements hibernés", nbH);
                                _fin = true;
                            }
                        }

                        lists = null;
                        WritePlayList(root);




                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;

                            Dictionary<string, Dictionary<int, TrackInfoItunes>> depots = new Dictionary<string, Dictionary<int, TrackInfoItunes>>();
                            foreach (SelectParam p in listP)
                            {

                                listS = new List<TrackInfoItunes>();
                                if (!string.IsNullOrEmpty(p.name))
                                {
                                    // Compatibilité anciennes listes
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                    buildList("_" + p.level, listS, prior, folder);
                                }
                                else
                                {

                                    var pp = p.Clone() as SelectParam;
                                    feeds.buildFirstSelectedTrackLevel(listS, p);

                                    var l = new List<TrackInfoItunes>();

                                    pp.nb = int.MaxValue;
                                    var selector = new TrackSelector(pp);
                                    foreach (TrackInfoItunes t in listS)
                                    {
                                        if (selector.select(t))
                                            l.Add(t);
                                    }

                                    string path = p.path;
                                    if (!string.IsNullOrWhiteSpace(path))
                                        buildList(path, l, prior);

                                    string[] _depots = p.depot;
                                    if (_depots != null)
                                    {
                                        foreach (string depot in _depots)
                                        {
                                            if (!depots.ContainsKey(depot))
                                                depots.Add(depot, new Dictionary<int, TrackInfoItunes>());

                                            var dep = depots[depot];
                                            foreach (TrackInfoItunes t in l)
                                            {
                                                if (!dep.ContainsKey(t.DbId))
                                                    dep.Add(t.DbId, t);
                                            }
                                        }
                                    }
                                }
                            }

                            foreach (KeyValuePair<string, Dictionary<int, TrackInfoItunes>> kvp in depots)
                            {
                                string path = kvp.Key;

                                var l = new List<TrackInfoItunes>(kvp.Value.Values);
                                l.Sort(new PodcastComparerPubPub2());
                                buildList(path, l, prior);
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);

                        var listSelected = root.Feeds.getSelectedTracks();

                        var sorterafter = new Sorter(Conf.Sort, list);
                        //    sorter.build();

                        foreach (TrackInfoItunes s in listSelected)
                        {
                            s.updateNative();
                        }






                        //if (Conf.Hibernate.enabled)
                        //{
                        //    Hibernator hibernator = new Hibernator();
                        //    var nb = hibernator.go(loader); 
                        //    if (nb >0)
                        //    {
                        //        misc.log("{0} elements hibernés", nb);
                        //        misc.log("fin ");
                        //        return; 
                        //    }

                        //}


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                log.log("Attente Classement");
                            }
                            Thread.Sleep(100);
                        }



                        //if (Conf.Sort.enabled >= Tuning.Sort.sortMode.once_all)
                        //{
                        //    var sorter = new Sorter(Conf.Sort, list);
                        //    sorter.build();
                        //}

                        if (Conf.Hibernate.enabled)
                        {
                            hibernator.doH();
                        }

                        if (loader.NbTrackCreated > 0)
                        {
                            log.log("{0} éléments ont été recréés", loader.NbTrackCreated);
                            _fin = true;
                        }

                        if (Album.NbRepeches > 0)
                        {
                            log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                            _fin = true;
                        }

                        if (!Conf.Continue)
                        {
                            log.log("on s'arrete là");
                            _fin = true;
                        }



                        if (Conf.UseMock)
                            _fin = true;



                        if (_fin)
                        {

                            postReport(root, true);
                            log.log("fin");

                            return;
                        }





                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");
                        postReport(root, true);


                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in db.Tracks)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogAll(ex.ToString());
                        misc.log(ex.ToString());
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        //private DirConf _attenteWriteHtml;
        // private volatile object _lockReportHtml = new object();
        private bool _end;
        // ThreadUtil thReport;
        DateTime lastReport;

        private void postReport(DirConf dir, bool force)
        {
            if (force || (lastReport.AddSeconds(10) < DateTime.Now && Conf.PostReport))
            {
                try
                {
                    reportHtml(dir);
                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                lastReport = DateTime.Now;
            }
            //if (thReport == null)
            //{
            //    lock (_lockReportHtml)
            //    {
            //        if (thReport == null)
            //        {
            //            thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
            //            thReport.Start();
            //        }
            //    }
            //}

            //lock (_lockReportHtml)
            //    _attenteWriteHtml = dir;
        }

        //private void loopReportHtml()
        //{
        //    DirConf traite = null;
        //    while (!_end)
        //    {
        //        Thread.Sleep(1000);
        //        if (_attenteWriteHtml == null)
        //            continue;
        //        lock (_lockReportHtml)
        //        {
        //            if (_attenteWriteHtml == null)
        //                continue;
        //            traite = _attenteWriteHtml;
        //            _attenteWriteHtml = null;
        //        }
        //        reportHtml(traite);
        //    }
        //}


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
                //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
                //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders, false);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders, false);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders, false);
        }

        public static void buildList(string path, List<TrackInfoItunes> list_, int prior)
        {
            bool absolutePath = path.StartsWith(@"\");
            var tab = path.Split('\\');
            int count = tab.GetLength(0);
            var folder = new List<string>();

            foreach (string s in tab)
            {
                if (!string.IsNullOrWhiteSpace(s))
                    folder.Add(s);
            }

            buildList(list_, prior, folder, absolutePath);
        }



        public static void buildList(List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            var newf = new List<string>(folders);
            int count = newf.Count;

            string name = newf[count - 1];
            newf.RemoveAt(count - 1);
            buildList(name, list_, prior, newf, absolutePath);
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            try
            {
                if (Conf.Simulation)
                    return;
                //if (Conf.UseMock)
                //{
                //    var sb = new StringBuilder();
                //    foreach (string f in folders)
                //    {
                //        sb.Append(f); sb.Append(@"\");
                //    }
                //    sb.Append(name);
                //    log.logNoDate("---------------------------");
                //    log.log("liste {0}", sb.ToString());
                //    if (list_ != null)
                //    {
                //        foreach (TrackInfoItunes t in list_)
                //        {
                //            log.logNoDate(t.ToString());
                //        }
                //    }
                //    return;
                //}

                if (list_ != null && !Conf.NoRevival)
                {
                    foreach (TrackInfoItunes track in list_)
                    {
                        loader.reviveIfNecessary(track);
                    }
                }



                var rootIt = Conf.RootIt;
                RootItItem currentRoot = rootIt.roots[0];
                int count = rootIt.roots.Count;

                if (list_ != null)
                {
                    //   log.log("build list {0}",name);
                    //  var list = new List<IFile>(list_);
                    if (lists == null)
                    {
                        lists = new List<HashSet<int>>();
                        foreach (var item in rootIt.roots)
                        {
                            lists.Add(new HashSet<int>());
                        }
                        var list__ = new List<TrackInfoItunes>(list_);
                        list__.Sort(new PodcastComparerPubPub2());



                        int countTrack = list_.Count;

                        long size = 0;
                        int j = 0;
                        int indexRoot = 0;

                        //    HashSet<int> current = lists[0]; 

                        while (true)
                        {
                            if (j >= countTrack)
                                break;
                            TrackInfoItunes track = list__[j];
                            size += track.Size;
                            if (size <= currentRoot.size)
                            {
                                lists[indexRoot].Add(track.DbId);
                                // track.IndexRoot = indexRoot;
                            }
                            else
                            {

                                size = 0;
                                //  size += track.Size;
                                indexRoot++;
                                if (indexRoot >= count)
                                    break;
                                currentRoot = rootIt.roots[indexRoot];
                                continue;
                            }
                            j++;
                        }

                    }
                }


                for (int r = 0; r < count; r++)
                {
                    currentRoot = rootIt.roots[r];
                    folders = new List<string>(folders);
                    PlayListComposite folder = null;

                    if (absolutePath)
                    {
                        if (r > 0)
                            throw new Exception("un chemin absolu ne peut pas être géré dans une partition");
                        // folders[0] = folders[0].Substring(1);
                        folder = loader.TreePlayList;

                    }
                    else
                        folder = loader.TreePlayList.getComposite(currentRoot.name);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(currentRoot.name);


                    var nname = name;
                    if (name.Contains(Path.DirectorySeparatorChar.ToString()))
                    {
                        var tab = name.Split(Path.DirectorySeparatorChar);
                        string str = null;
                        for (int i = 0; i < tab.GetLength(0); i++)
                        {
                            if (str != null)
                                folders.Add(str);
                            if (!string.IsNullOrEmpty(tab[i]))
                                str = tab[i];
                        }
                        if (!string.IsNullOrEmpty(str))
                            nname = str;
                    }
                    List<IFile> l = null;

                    if (list_ != null)
                    {
                        l = new List<IFile>();
                        foreach (TrackInfoItunes t in list_)
                        {
                            if (lists[r].Contains(t.DbId))
                            {
                                if (Conf.NoRevival)
                                {
                                    if (!t.Present)
                                        continue;
                                }

                                l.Add(t);
                            }
                        }
                    }


                    for (int i = 0; i < folders.Count; i++)
                    {
                        var aux = folder;
                        folder = folder.getComposite(folders[i]);
                        if (folder == null)
                            folder = loader.getOrCreateFolder(aux, folders[i], l == null ? true : l.Count > 0);
                        if (folder == null)
                            return;
                    }

                    //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
                    var playlist = loader.getPlayList(folder, nname, l == null ? true : l.Count > 0);
                    if (playlist != null)
                    {
                        if (prior < int.MaxValue && prior >= 0)
                            playlist.setPrior(prior);
                        //if (list.Count > 0)


                        playlist.mergeList(l, hibernator.Ignore, _instance, Conf.OnlyEnabled, Conf.OnlyUnRead);
                        //  loader.mergeList(playlist, l, false, _instance, null);
                        //else
                        //    loader.removeList(folder, name);
                    }



                    //log.log("clear list {0}", name); 
                    //loader.ClearList(playlist);
                    //log.log("add items {0}", name); 
                    //foreach (TrackInfoItunes track in list)
                    //    loader.addItemToList(playlist, track); 

                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }


        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildGlobalList(string path, List<TrackInfoItunes> list_, int prior)
        {
            PlayListComposite folder = null;
            List<string> folders = new List<string>();
            string nname = "";
            //if (Conf.UseMock)
            //    return;
            try
            {

                var tab = path.Split(Path.DirectorySeparatorChar);
                string str = null;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    if (str != null)
                        folders.Add(str);
                    if (!string.IsNullOrEmpty(tab[i]))
                        str = tab[i];
                }
                if (!string.IsNullOrEmpty(str))
                    nname = str;

                folder = loader.TreePlayList;





                var l = new List<IFile>();
                foreach (TrackInfoItunes t in list_)
                {
                    if (t.Present || Conf.UseMock)
                        l.Add(t);
                }

                for (int i = 0; i < folders.Count; i++)
                {
                    var aux = folder;
                    folder = folder.getComposite(folders[i]);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(aux, folders[i], l.Count > 0);
                    if (folder == null)
                        return;
                }


                var playlist = loader.getPlayList(folder, nname, l.Count > 0);
                if (playlist != null)
                {
                    if (prior < int.MaxValue && prior >= 0)
                        playlist.setPrior(prior);


                    playlist.mergeList(l, hibernator.Ignore, _instance, false, false);

                }



            }

            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }




        }

        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            DateTime now = DateTime.Now;

            fLoader.Action(pre);
            var ts = (DateTime.Now - now).TotalMilliseconds;
            if (ts > 1 && Conf.LogDir && pre > action.none && pre < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", pre, dir.getPath(), ts.ToString("0"));
            }

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());

            now = DateTime.Now; ts = (DateTime.Now - now).TotalMilliseconds;
            fLoader.Action(post);

            if (ts > 1 && Conf.LogDir && post > action.none && post < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", post, dir.getPath(), (DateTime.Now - now).TotalMilliseconds.ToString("0"));
            }


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }

        private void resetLoad(DirConf dir)
        {
            recursif(dir, action.resort, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void Freewheel(DirConf dir)
        {
            dir.Loader.LimitsLoader.Freewheel();
        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
            List<TrackInfoItunes> list = null;
            //  var list = db.Tracks.FindAll(t => t.Present);
            //var list = db.Tracks.FindAll(t => t.isConcernedBySelection); 
            var Fin1ereJournee = ContexteBuilder.Instance.Fin1ereJournee;
            var limitContexte = ContexteBuilder.Instance.LimitWriteList;
            if (Conf.UseMock)
                list = db.Tracks.FindAll(t => t.isConcernedBySelection && t.isPodcast);
            else
                list = db.Tracks.FindAll(t => t.Present && t.isConcernedBySelection && t.isPodcast && t.Pub2 <= limitContexte);
            foreach (SelectParamBase listeGlobal in Conf.GlobalListes)
            {
                var selector = new TrackSelector(listeGlobal);
                var l = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (selector.select(t))
                        l.Add(t);
                }

                buildGlobalList(listeGlobal.path, l, 2);

            }

            //foreach (Note note in Conf.Notes)
            //{
            var builder = dir.NoteBuilder;
            if (builder == null)
                return;
            var note = builder.Note; // note.NoteBuilder; // new NoteBuilder(note);
            builder.build(list);
            builder.display();
            foreach (ListNote listNote in builder.Depot)
            {
                var path = string.Format(note.path, listNote.Note);
                var _l = listNote.List;
                if (note.histo)
                    _l.Sort(new PodCastComparer());
                else
                    _l.Sort(new PodCastComparerInv());
                buildGlobalList(path, _l, 2);

                if (!string.IsNullOrEmpty(note.single))
                {
                    var pathSingle = string.Format(note.single, listNote.Note);
                    var hs = new HashSet<string>();
                    var ls = new List<TrackInfoItunes>();
                    foreach (TrackInfoItunes t in _l)
                    {
                        if (!t.Selected)
                            continue;
                        if (!hs.Add(t.AlbumKey))
                            continue;
                        ls.Add(t);
                    }
                    buildGlobalList(pathSingle, ls, 2);
                }
            }
            // Sélection d'un unique item (preise encompte des niveaux précédents)
            if (!string.IsNullOrEmpty(note.unique))
            {
                Logger logger = Logger.getLogger("NotesU", false);
                //Dictionnaire global
                var hsGlobal = new HashSet<string>();
                var depot = new List<ListNote>(builder.Depot);
                int count = depot.Count;

                for (int i = count - 1; i >= 0; i--)
                {
                    ListNote listNote = depot[i];
                    var _l = listNote.List.FindAll(t => t.Selected && t.Pub <= Fin1ereJournee);
                    _l.Sort(new PodCastComparer());

                    var linv = _l.FindAll(t => t.Recent && ContexteBuilder.Instance.getRetard(t, note.date0Min) <= note.retardHisto);
                    linv.Sort(new PodCastComparerInv());

                    foreach (TrackInfoItunes t in _l)
                    {
                        if (linv.Contains(t))
                            continue;
                        linv.Add(t);
                    }

                    //if (note.histo)
                    //    _l.Sort(new PodCastComparer());
                    //else
                    //    _l.Sort(new PodCastComparerInv());
                    var ls = new List<TrackInfoItunes>();
                    var hs = new HashSet<string>();
                    var pathUnique = string.Format(note.unique, listNote.Note);
                    foreach (TrackInfoItunes t in linv)
                    {
                        //if (!t.Selected)
                        //    continue;
                        if (hsGlobal.Contains(t.AlbumKey))
                            continue;
                        if (hs.Contains(t.AlbumKey))
                            continue;
                        if (t.Pub <= ContexteBuilder.Instance.Zero)
                        {
                            hsGlobal.Add(t.AlbumKey);
                            hs.Add(t.AlbumKey);
                        }
                        else
                        {
                        }

                        ls.Add(t);

                        var tn = listNote.getTrackNote(t.DbId);
                        tn.log(logger);
                    }

                    buildGlobalList(pathUnique, ls, 2);
                }
            }

            //  }

            var contextB = ContexteBuilder.Instance;

            if (contextB.Enabled)
            {

                var selected = dir.getListe();
                selected.Sort(new PodCastComparer());
                var listContext = new List<TrackInfoItunes>();
                contextB.buildList(selected, listContext);

                buildList("_contexte", listContext, 2);
            }



        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                            break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Grouping = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Load;
using timeSpan = pdb.util.timeSpan;
using System.Diagnostics;


namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    public class AutoBuilder : IComparable<AutoBuilder>//, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        //private double cmin;
        //private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private int nbDown;
        private bool? useForfait;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static List<AutoBuilder> old = new List<AutoBuilder>();
        private static int index;
        private DirConf source; public DirConf Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        // private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        //  private AutoBuilderItem choose;
        private List<AutoBuilderItem> chooses = new List<AutoBuilderItem>();
        //public const int STOP_MAX = 3;
        //private int _stopLevel = STOP_MAX;
        // private bool 


        private List<LimitItemLoader> loaders = new List<LimitItemLoader>();
        //public void buildLoaders()
        //{
        //    loaders = new List<LimitItemLoader>();
        //    source.buildLoaders(loaders, this);

        //}

        //public void go()
        //{
        //    var total = new timeSpan();
        //    var fd = new timeSpan();
        //    var d = new timeSpan();
        //    var date = new timeSpan();
        //    var nb = 0;

        //    var dict = new pdb.util.BgDictString0<TrackInfoItunes>();

        //    while (true)
        //    {
        //        var _total = timeSpan.MaxValue;
        //        var _fd = timeSpan.MaxValue;
        //        var _d = timeSpan.MaxValue;
        //        var _date = timeSpan.MaxValue;
        //        var _nb = int.MaxValue;

        //        foreach (LimitItemLoader loader in loaders)
        //        {
        //            loader.checkV(this, nb, fd, d, date);
        //            if (_total > loader._durationv)
        //                _total = loader._durationv;
        //            if (_fd > loader.Fd)
        //                _fd = loader.Fd;
        //            if (_date > loader._datev)
        //                _date = loader._datev;
        //            if (_nb > loader._nb)
        //                _nb = loader._nb;
        //        }
        //    }
        //}
        private AutoBuilder(pdb.podcast.Tuning.Auto conf, AutoBuilder old)
        {
            this.conf = conf;
            this.name = conf.name;
            if (old == null)
            {
                mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
                mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            }
            else
            {
                mem0 = old.mem0;
                mem1 = old.mem1;
            }
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = AutoBuilderItem.get(this, sub); // new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(DirConf source)
        {
            this.source = source;
            source.addBorderObs(this);
            source.Auto = this;
        }

        //// private static bool loaded; 
        //public static void getLoaders()
        //{
        //    //if (loaded)
        //    //    return;
        //    //loaded = true;
        //    foreach (AutoBuilder auto in list)
        //        auto.buildLoaders();
        //}

        //public static void test()
        //{
        //    //if (loaded)
        //    //    return;
        //    //loaded = true;
        //    foreach (AutoBuilder auto in list)
        //        auto.go();
        //}

        private static AutoBuilder main;
        public static void clear() { old = list; list = new List<AutoBuilder>(); }
        public static void build(XmlNode xAuto, DirConf source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    AutoBuilder oldB = old == null ? null : old.Find(a => a.name == name);
                    builder = new AutoBuilder(conf, oldB);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                    if (old != null)
                    {
                        //  AutoBuilder oldB = old.Find(a => a.name == name);
                        if (oldB != null)
                        {
                            builder._empreinte = oldB._empreinte;
                            builder.newv = oldB.newv;
                            builder.org = oldB.org;
                            builder.state = oldB.state;
                            builder.delta = oldB.delta;
                            builder.delta0 = oldB.delta0;
                            builder.lastd = oldB.lastd;
                            builder.lastDelta = oldB.lastDelta;
                            builder.lastTotal = oldB.lastTotal;
                            builder.nbDown = oldB.nbDown;
                            builder.total = oldB.total;
                            builder.chooses = oldB.chooses;
                            builder.goBack = oldB.goBack;
                        }
                    }
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        mem.dict.Add(key, desc);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                List<string> toRemove = new List<string>();
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        toRemove.Add(key);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }

                foreach (string key in toRemove)
                    mem.dict.Remove(key);
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    //{
                    //    //if (!exist)
                    //    //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                    //    tw.Write(DateTime.Now); tw.Write(SEP);
                    //    tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(atomicMode); tw.Write(SEP);
                    //    tw.Write(state); tw.Write(SEP);
                    //    for (int i = 0; i < imax; i++)
                    //    {
                    //        if (i > 0)
                    //        {
                    //            tw.WriteLine();
                    //            for (int j = 0; j < 11; j++)
                    //                tw.Write(SEP);
                    //        }
                    //        if (i < mem.ajouts.Count)
                    //            tw.Write(mem.ajouts[i].track);
                    //        tw.Write(SEP);
                    //        if (i < mem.ajouts.Count)
                    //            tw.Write(mem.ajouts[i].item);
                    //        tw.Write(SEP);
                    //        if (i < mem.suppressions.Count)
                    //            tw.Write(mem.suppressions[i].track);
                    //        tw.Write(SEP);
                    //        if (i < mem.suppressions.Count)
                    //            tw.Write(mem.suppressions[i].item);
                    //        tw.Write(SEP);
                    //    }
                    //    tw.WriteLine();
                    //}
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            //cmin = 0;
            //cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
            // _stopLevel = STOP_MAX;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        private static double _offset = -1;
        public static double Offset { get { return _offset; } set { _offset = value; } }




        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            //bool firstWIthTb = first && Conf.BorderTb;
            //bool secondwithoutTb = !first && !Conf.BorderTb;
            //bool readXml = firstWIthTb || secondwithoutTb;

            bool readXml = first;
            FileInfo f = null;
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                //if (first)
                //    builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }
            _offset = 0;

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);

                doc.PreserveWhitespace = true;

                XmlWriterSettings set = new XmlWriterSettings();
                set.NamespaceHandling = NamespaceHandling.OmitDuplicates;
                set.Indent = true;
                //set.NewLineChars = "\n";
                //set.IndentChars = "\t";
                set.NewLineHandling = NewLineHandling.None;
                using (XmlWriter writer = XmlWriter.Create(f.FullName, set))
                    doc.Save(writer);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static void Init3()
        {
            foreach (AutoBuilder item in list)
            {
                item.init3();
            }
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check3();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                //throw new NotImplementedException(); 
                //AutoBuilder builder = null;
                //if (!started)
                //{
                //    started = true;
                //    foreach (AutoBuilder b in list)
                //        b.total = b.source.getTotalSize();
                //}
                //// application de la précédente modif
                //builder = list[index];
                //if (builder.state > builderstate.none)
                //{
                //    builder.makeEmpreinteNonSequence();
                //    decrementIndex();
                //}
                //int i = -1;
                //for (i = list.Count - 1; i >= 0; i--)
                //{
                //    builder = list[i];
                //    bool cango = false;
                //    bool _cont = false;
                //    while (true)
                //    {
                //        if (i == index || _cont)
                //        {
                //            cango = builder.check();
                //            index = i;
                //            main = builder;
                //            _cont = false;
                //            break;
                //        }
                //        else
                //            cango = builder.checkWithoutModify();
                //        if (builder.state == builderstate.none)
                //            _cont = true;
                //        else
                //            break;
                //    }
                //    if (!cango)
                //        _cango = false;
                //    if (builder.mustUpdate)
                //        MustUpdate = true;
                //    if (i == index)
                //    {
                //        if (builder.newv != builder.org)
                //        {
                //            _modifFile = true;
                //        }
                //        else
                //        {
                //            //index--;
                //            //if (index < 0)
                //            //    index = list.Count - 1;
                //        }
                //    }
                //    if (_modifFile)
                //        break;
                //}
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.PreserveWhitespace = true;
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                {
                    _cango = false;
                    break;
                }
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        //private bool check()
        //{
        //    sb = new StringBuilder();
        //    sb.AppendLine();
        //    makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
        //    mustUpdate = false;
        //    canGo = false;
        //    var newEmpreinte = source.getEmpreinte();
        //    if (state == builderstate.none)
        //        reset();
        //    else if (state == builderstate.stable)
        //    {
        //        if (newEmpreinte != _empreinte)
        //            reset();
        //        else
        //        {
        //            mustUpdate = false;
        //            canGo = true;
        //            org = newv;
        //            return true;
        //        }
        //    }
        //    if (Conf.AutoSequence || total < 0)
        //        total = source.getTotalSize();
        //    double target = conf.target;
        //    delta = target - total;
        //    log("delta {0}", delta);
        //    if (state == builderstate.none)
        //        delta0 = delta;
        //    state = builderstate.enCours;
        //    lastd = d;
        //    d = 0;
        //    xml = null;
        //    lookup(xmlRoot);
        //    if (xml == null)
        //        return true;
        //    string attTarget = conf.type.ToString();
        //    var att = xml.Attributes[attTarget];
        //    if (att == null)
        //        return true;
        //    org = Convert.ToDouble(att.Value);
        //    newv = org;
        //    try
        //    {
        //        if (delta * delta0 < 0)
        //        {
        //            if (atomicMode < 0)
        //            {
        //                atomicMode = 0;
        //                //if (minMem == null)
        //                //    minMem = new Memory(mem0);
        //                //if (maxMem == null)
        //                //    maxMem = new Memory(mem0);
        //                //if (minMem.suppressions.Count == 0)
        //                //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
        //                //if (maxMem.ajouts.Count == 0)
        //                //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
        //            }
        //        }
        //        bool cancelSameConf = false;
        //        bool cancelNb = false;
        //        if (atomicMode >= 0)
        //        {
        //            atomicMode++;
        //            if (Math.Abs(dmin - delta) < EPSILON)
        //                sameConfiguration++;
        //            else if (Math.Abs(dmax - delta) < EPSILON)
        //                sameConfiguration++;
        //            else
        //                sameConfiguration = 0;
        //            if (sameConfiguration > conf.idem)
        //                cancelSameConf = true;
        //            if (atomicMode > conf.cloop)
        //                cancelNb = true;
        //        }
        //        if (delta >= 0)
        //        {
        //            if (mem0.suppressions.Count > 0)
        //                minMem = new Memory(mem0);
        //            if (delta < conf.write)
        //                canGo = true;
        //            //  lastGoodLevel = org;
        //            //if (maxMem != null && minMem != null)
        //            //{
        //            if (atomicMode > 0)
        //            {
        //                if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
        //                {
        //                    log("abandon recherche cartésienne cause idem");
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //                else if (cancelNb)
        //                {
        //                    log("abandon recherche cartésienne cause cloop");
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //                //if (Math.Abs(dmin - delta) < 0.01)
        //                //    dminAlready = true;
        //                //else
        //                //    dminAlready = false;
        //                if (maxMem != null && minMem != null)
        //                {
        //                    if (minMem.suppressions.Count == maxMem.ajouts.Count)
        //                    {
        //                        bool identique = true;
        //                        for (int i = 0; i < minMem.suppressions.Count; i++)
        //                        {
        //                            if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
        //                            {
        //                                identique = false;
        //                                break;
        //                            }
        //                        }
        //                        if (identique)
        //                        {
        //                            if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
        //                            {
        //                                mustUpdate = false;
        //                                log("abandon recherche cartésienne cause cycle");
        //                                state = builderstate.stable;
        //                                _empreinte = newEmpreinte;
        //                                return true;
        //                            }
        //                        }
        //                    }
        //                }
        //            }
        //            cmin = org;
        //            dmin = delta;
        //            // lastGoodDelta = (int)delta;
        //            lastTotal = (int)total;
        //            if (delta < conf.delta)
        //            {
        //                state = builderstate.stable;
        //                _empreinte = newEmpreinte;
        //                return true;
        //            }
        //            mustUpdate = true;
        //            d = 0;
        //            if (atomicMode > 0)
        //            {
        //                //if (atomicMode > conf.cloop)
        //                //{
        //                //    mustUpdate = false;
        //                //    log("abandon recherche cartésienne cause cloop");
        //                //    state = builderstate.stable;
        //                //    _empreinte = newEmpreinte;
        //                //    return true;
        //                //}
        //                //if (dminAlready && dmaxAlready)
        //                //{
        //                //    mustUpdate = false;
        //                //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
        //                //    return true;
        //                //}
        //                d = 0.5 * (cmax - cmin);
        //            }
        //            else
        //            {
        //                double _d = int.MaxValue;
        //                if (cmax >= 0 && cmin >= 0)
        //                    _d = cmax - cmin;
        //                double aux = int.MaxValue;
        //                // double aux2 = int.MaxValue;
        //                foreach (Level level in conf.levels)
        //                {
        //                    aux = (delta - level.d) * level.inf;
        //                    if (aux > d)
        //                        d = aux;
        //                }
        //                if (conf.coeff > 0)
        //                {

        //                    if (org > conf.max)
        //                        d = conf.max - org;
        //                    else
        //                    {
        //                        d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
        //                    }
        //                    //else
        //                    //{
        //                    //    var de = Math.Abs(delta);
        //                    //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
        //                    //}
        //                }

        //                //if (d == 0 || aux2 < d)
        //                //    d = aux2;

        //                if (d > _d)
        //                    d = _d;
        //            }
        //        }
        //        else if (delta < 0)
        //        {
        //            if (mem0.ajouts.Count > 0)
        //                maxMem = new Memory(mem0);
        //            mustUpdate = true;
        //            canGo = false;
        //            //if (maxMem != null && minMem != null)
        //            //{
        //            //    if (atomicMode < 0)
        //            //        atomicMode = 0;
        //            //    atomicMode++;
        //            //}
        //            cmax = org;
        //            dmax = delta;
        //            d = 0;
        //            if (atomicMode > 0)
        //            {
        //                bool identique = false;
        //                if (minMem != null && maxMem != null
        //                    && maxMem.ajouts.Count == minMem.suppressions.Count)
        //                {
        //                    identique = true;
        //                    for (int i = 0; i < minMem.suppressions.Count; i++)
        //                    {
        //                        if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
        //                        {
        //                            identique = false;
        //                            break;
        //                        }
        //                    }
        //                }
        //                if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
        //                {
        //                    log("retour derniere bonne valeur cause idem");
        //                    d = cmin - cmax;
        //                }
        //                else if (cancelNb)
        //                {
        //                    log("abandon recherche cartésienne cause cloop");
        //                    d = cmin - cmax;
        //                }
        //                else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
        //                {
        //                    log("retour derniere bonne valeur cause cycle");
        //                    d = cmin - cmax;
        //                }
        //                //else if (atomicMode > conf.cloop)
        //                //{                      
        //                //    log("abandon recherche cartésienne cause cloop");
        //                //    d = cmin - cmax;
        //                //}
        //                else
        //                    d = 0.5 * (cmin - cmax);
        //            }
        //            else
        //            {

        //                double _d = -int.MaxValue;
        //                if (cmax >= 0 && cmin >= 0)
        //                    _d = cmin - cmax;
        //                double aux = -int.MaxValue;
        //                // double aux2 = -int.MaxValue;
        //                foreach (Level level in conf.levels)
        //                {
        //                    aux = (delta - conf.delta + level.d) * level.sup;
        //                    if (aux < d)
        //                        d = aux;
        //                }
        //                if (conf.coeff > 0)
        //                {
        //                    if (org < conf.min)
        //                        d = (conf.min - org);
        //                    else
        //                    {
        //                        d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
        //                    }
        //                    //else
        //                    //{
        //                    //    var de = Math.Abs(delta);
        //                    //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
        //                    //}
        //                }

        //                //if (d == 0 || aux2 > d)
        //                //    d = aux2;

        //                if (d < _d)
        //                    d = _d;
        //            }
        //            //d = (delta - conf.delta) * conf.sup;
        //            //if (org <= lastGoodLevel)
        //            //{
        //            //    lastGoodLevel = -1;
        //            //    lastGoodDelta = -1;
        //            //    lastTotal = -1;
        //            //}
        //        }
        //        if (Math.Abs(d) < 0.00000001)
        //        {
        //            mustUpdate = false;
        //            // unCart();
        //            state = builderstate.stable;
        //            _empreinte = newEmpreinte;
        //            return true;
        //        }
        //        //if (dejaVu)
        //        //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
        //        log("correction {0}", d);
        //        newv = org + d;
        //        if (newv <= 0)
        //            newv = 0;
        //        if (conf.coeff > 0)
        //        {
        //            if (newv > conf.max)
        //                newv = conf.max;
        //            else if (newv < conf.min)
        //                newv = conf.min;
        //        }
        //        newv = Math.Round(newv, 8);
        //        log(" valeur {0} --> {1}", org, newv);
        //        att.Value = newv.ToString();
        //    }
        //    finally
        //    {
        //        if (state == builderstate.stable)
        //        {
        //            mustUpdate = false;
        //            _empreinte = newEmpreinte;
        //            canGo = true;
        //        }
        //        string strDate = "";
        //        var attD = xml.Attributes["date"];
        //        if (attD != null)
        //            strDate = attD.Value;
        //        bool exist = File.Exists(file);
        //        //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
        //        //{
        //        //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
        //        //    if (!exist)
        //        //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
        //        //    tw.Write(DateTime.Now); tw.Write(SEP);
        //        //    tw.Write(target.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(atomicMode); tw.Write(SEP);
        //        //    tw.Write(state); tw.Write(SEP);
        //        //    tw.WriteLine();
        //        //}
        //        if (canGo)
        //            // makeDelta(mem1, "reel", @"..\rhisto.txt");
        //            makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
        //    }
        //    return canGo;
        //}

        //private void calcChoose(bool up, bool strict, bool checkSelect)
        //{
        //    choose = null;
        //    double dt = double.MaxValue;
        //    double gap = double.MaxValue;
        //    // bool trou = false;
        //    foreach (AutoBuilderItem item in items)
        //    {
        //        item.after(up, strict, checkSelect);
        //        item.setTension(up, strict, checkSelect);
        //        if (item.Stop(_stopLevel))
        //        {
        //            if ((strict || checkSelect) && Conf.BorderGranSlam)
        //            {
        //                choose = null;
        //                break;
        //            }
        //            continue;
        //        }
        //        double aux = double.MaxValue;
        //        // var tension = item.Tension;
        //        if (conf.selectFix)
        //        {
        //            var tension = item.Tension;
        //            aux = up ? tension : -tension;
        //        }
        //        else
        //            aux = item.Dt;

        //        if (conf.selectAbs && !conf.selectFix && aux < 0)
        //            aux *= -1;



        //        if (item.getCauses().Count == 0)
        //        {
        //            // trou = true;
        //            if ((strict || checkSelect) && Conf.BorderGranSlam)
        //            {
        //                choose = null;
        //                break;
        //            }
        //            continue;
        //        }

        //        //var _gap = Math.Abs(aux);
        //        //if (_gap < gap)
        //        //    gap = _gap;

        //        if (aux < dt)
        //        {
        //            dt = aux;
        //            newv = item.NewV;
        //            choose = item;
        //        }
        //    }
        //    //if (trou && conf.gap && gap < double.MaxValue)
        //    //{
        //    //    foreach (AutoBuilderItem item in items)
        //    //    {
        //    //        if (item.Stop)
        //    //            continue;
        //    //        item.gap(up, conf.selectFix, gap);
        //    //    }
        //    //}
        //}

        //private bool check2()
        //{
        //    // _modifFile = false; 
        //    sb = new StringBuilder();
        //    sb.AppendLine();
        //    makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




        //    if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
        //    {
        //        if (conf.pertinentExclu)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                if (item != choose)
        //                    item.makePertinent();
        //            }
        //        }
        //        else if (conf.pertinentAll)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //                item.makePertinent();
        //        }
        //        else
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                item.checkAjout(mem0.tajouts);
        //                item.checkAjout(mem0.tsuppressions);
        //            }
        //        }


        //        //else if (choose != null)
        //        //    choose.makePertinent();
        //    }
        //    mustUpdate = false;
        //    canGo = false;
        //    var newEmpreinte = source.getEmpreinte();

        //    try
        //    {
        //        if (state == builderstate.none)
        //            reset();
        //        else if (state == builderstate.stable)
        //        {
        //            if (newEmpreinte != _empreinte)
        //                reset();
        //            else
        //            {
        //                mustUpdate = false;
        //                canGo = true;
        //                org = newv;
        //                return true;
        //            }
        //        }

        //        total = source.getTotalSize();
        //        double target = conf.target;
        //        delta = target - total;
        //        log("delta {0}", delta);

        //        if (_stopLevel < 0)
        //        {
        //            log("arret cause stopLevel");
        //            state = builderstate.stable;
        //            return true;
        //        }
        //        if (delta * lastDelta < 0)
        //        {
        //            //if (delta > 0)
        //            //{
        //            //    // ok!
        //            //    state = builderstate.stable;
        //            //    _empreinte = newEmpreinte;
        //            //    return true;
        //            //}
        //            // retour arrière
        //            if (choose != null && _stopLevel > 0)
        //            {
        //                log("retour arrière");
        //                _stopLevel--;
        //                choose.stop(_stopLevel);
        //                canGo = false;
        //                mustUpdate = true;
        //                return false;
        //            }
        //            else
        //            {
        //                if (delta > 0)
        //                {
        //                    // ok!
        //                    log("pas de retour arriere stoplevel=0");
        //                    state = builderstate.stable;
        //                    _empreinte = newEmpreinte;
        //                    return true;
        //                }
        //                else
        //                {
        //                    _stopLevel--;
        //                    choose.stop(_stopLevel);
        //                    canGo = false;
        //                    mustUpdate = true;
        //                    return false;
        //                }
        //            }
        //        }
        //        lastDelta = delta;
        //        if (state == builderstate.none)
        //            delta0 = delta;
        //        state = builderstate.enCours;
        //        lastd = d;
        //        d = 0;

        //        bool up = delta > 0;
        //        if (up && delta < conf.delta)
        //        {
        //            log("delta");
        //            state = builderstate.stable;
        //            _empreinte = newEmpreinte;
        //            return true;
        //        }
        //        mustUpdate = true;
        //        //double dt = double.MaxValue;

        //        //bool real = true;
        //        //if (delta * delta0 < 0)
        //        //{
        //        //    if (choose != null)
        //        //    {
        //        //        _stopLevel--;
        //        //        choose.stop(_stopLevel);
        //        //    }
        //        //    canGo = false;
        //        //    mustUpdate = true;
        //        //    return false;
        //        //}
        //        if (conf.stopAll)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                if (item.Stop(1))
        //                {
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //            }
        //        }



        //        choose = null;
        //        if (_stopLevel >= 3 && conf.checkSelect && conf.checkStrict)
        //            calcChoose(up, true, true);
        //        if (choose != null)
        //            log("REEL - SELECT");
        //        else
        //        {
        //            if (_stopLevel >= 2 && conf.checkSelect)
        //                calcChoose(up, false, true);
        //            if (choose != null)
        //                log("VIRTUEL SELECT");
        //            else
        //            {
        //                if (_stopLevel >= 1 && conf.checkStrict)
        //                    calcChoose(up, true, false);
        //                if (choose != null)
        //                    log("REEL");
        //                else
        //                {
        //                    if (_stopLevel >= 0)
        //                    {
        //                        calcChoose(up, false, false);
        //                        if (choose != null)
        //                            log("VIRTUEL");
        //                    }
        //                }
        //            }
        //        }


        //        if (choose == null)
        //        {
        //            log("choose null");
        //            _stopLevel--;
        //            if (_stopLevel < 0)
        //            {
        //                state = builderstate.stable;
        //                return true;
        //            }
        //            else
        //            {
        //                canGo = false;
        //                mustUpdate = true;
        //                return false;
        //            }
        //        }

        //        org = choose.Org;



        //        if (up)
        //        {
        //            if (delta < conf.write)
        //                canGo = true;
        //            if (conf.checkEvol)
        //            {
        //                // var nextTrack = choose.rejected(real).candidat;
        //                var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
        //                if (delta < size)
        //                {
        //                    _stopLevel--;
        //                    // choose.stop();
        //                    if (conf.stopAll)
        //                    {
        //                        foreach (AutoBuilderItem item in items)
        //                            item.stop(_stopLevel);
        //                        //state = builderstate.stable;
        //                        //return true;
        //                    }
        //                    else
        //                    {
        //                        choose.stop(_stopLevel);
        //                    }
        //                }
        //            }

        //        }
        //        else
        //        {
        //        }
        //        choose.save();
        //        Program.logAuto.log("===> " + choose.ToString());
        //    }
        //    finally
        //    {
        //        if (state == builderstate.stable)
        //        {
        //            mustUpdate = false;
        //            _empreinte = newEmpreinte;
        //            canGo = true;
        //        }

        //        //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
        //        //{
        //        //    bool exist = File.Exists(file);
        //        //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
        //        //    if (!exist)
        //        //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
        //        //    tw.Write(DateTime.Now); tw.Write(SEP);
        //        //    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(atomicMode); tw.Write(SEP);
        //        //    tw.Write(state); tw.Write(SEP);
        //        //    tw.WriteLine();
        //        //}
        //        if (canGo)
        //            // makeDelta(mem1, "reel", @"..\rhisto.txt");
        //            makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
        //    }
        //    return canGo;
        //}

        private void init3()
        {
            _cause = null;


            foreach (AutoBuilderItem item in items)
            {
                item.Candidat = null;
                item.limit = null;
                item.setTension();
            }
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        //if (item != choose)
                        item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


            }

            setDelta();


        }

        public static void SetDelta()
        {
            foreach (AutoBuilder item in list)
            {
                item.setDelta();
            }
        }

        private void setDelta()
        {
            mustUpdate = false;
            canGo = false;

            total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            // log("delta {0}", delta);
        }

        private bool goBack;

        private bool check3()
        {
            // _modifFile = false; 

            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }






                //if (_stopLevel < 0)
                //{
                //    log("arret cause stopLevel");
                //    state = builderstate.stable;
                //    return true;
                //}
                var _lastDelta = lastDelta;
                lastDelta = delta;
                if (delta * _lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (delta > 0)
                    {
                        if (conf.forfaitNegatif > 0 && true == useForfait)
                        {
                            useForfait = false;
                        }
                        else
                        {
                            if (conf.stopAll || !goBack)
                            {
                                // ok!
                                log("pas de retour arriere");
                                state = builderstate.stable;
                                _empreinte = newEmpreinte;
                                useForfait = null;
                                return true;
                            }
                        }
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        //  _stopLevel--;
                        foreach (AutoBuilderItem choose in chooses)
                        {
                            if (choose != null)//&& _stopLevel > 0)
                            {
                                log("retour arrière");
                                choose.stop();
                            }
                        }

                        // il reste des items ?
                        goBack = items.Find(i => !i.Stopped) != null;
                        return false;
                    }

                }


                var cdv = _cause.causes;
                chooses.Clear();


                foreach (CauseDataValue cd in cdv.datas)
                {
                    if (cd == null)
                        continue;
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Update)
                        continue;

                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;
                    if (item.Stopped)
                        continue;
                    chooses.Add(item);
                    item.save(cd.val);

                    // item.Cause = cd;
                    item.Candidat = cdv.candidat;
                    item.limit = cdv.limit;

                }


                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;

                if (up)
                    nbDown = 0;
                else
                    nbDown++;
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    useForfait = null;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                //if (conf.stopAll)
                //{
                //    throw new NotImplementedException(); 
                //    //foreach (AutoBuilderItem item in items)
                //    //{
                //    //    if (item.Stop(1))
                //    //    {
                //    //        state = builderstate.stable;
                //    //        useForfait = null;
                //    //        return true;
                //    //    }
                //    //}
                //}

                if (_cause == null)
                {
                    Debugger.Launch();

                    log("_cause NULL");
                    return false;

                    //state = builderstate.stable;
                    //useForfait = null;
                    //return true;

                }
                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                }



                if (!up && conf.forfaitNegatif > 0)
                {

                    if (nbDown > conf.forfaitNegatifOffset)
                    {
                        useForfait = true;
                        foreach (var item in items)
                        {
                            var tension = item.Tension;
                            tension -= conf.forfaitNegatif * (nbDown - conf.forfaitNegatifOffset);
                            if (tension < 0)
                                tension = 0;
                            item.modif(tension);
                            chooses.Add(item);
                        }
                    }
                }

                if (chooses.Count == 0)
                {
                    log("pas de choose");
                    state = builderstate.stable;
                    useForfait = null;
                    return true;

                }





            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                //{
                //    bool exist = File.Exists(file);
                //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                //    if (!exist)
                //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                //    tw.Write(DateTime.Now); tw.Write(SEP);
                //    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(atomicMode); tw.Write(SEP);
                //    tw.Write(state); tw.Write(SEP);
                //    tw.WriteLine();
                //}
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }


        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder();
            sb.Append(string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9}) ", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.Append(nbDown);
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
            {
                sb.Append(item);
            }
            sb.AppendLine("-----------------------------------------");
            return sb.ToString();

        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************");
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            //if (choose != null)
            //    type = choose.type.ToString();
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
            //  Program.logAuto.log("{0} {1} stop:{2}", name, type, _stopLevel.ToString());

            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);

            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                //   log(" valeur {0} --> {1}", org, newv);

                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log("");
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;

        public double getMaxDateAuto()
        {
            var item = items.Find(i => i.type == borderType.maxdate);
            if (item == null)
                return 0;
            return item.Pente + item.Org;
        }
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        //private CauseRegister causeRegister = new CauseRegister();
        //public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null) //|| data.virtuel)
                    continue;

                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].Virtuel = true;
                if (!cd.datas[i].Virtuel)
                    nb++;
            }

            //if (nb == 0)
            //    return; 

            // causeRegister.signal(cd);
            //     if (nb > 1) // OUAILLE ?
            checkCause(cd);

        }

        private CauseDatasTension _cause;
        private void checkCause(CauseDatas cause)
        {
            bool up = delta > 0;
            if (Conf.AutoSelect)
            {
                bool selected = cause.Selected;
                if (up && selected)
                    return;
                if (!up && !selected)
                    return;
            }

            if (up)
            {
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd == null)
                        continue;
                    if (cd.Virtuel && !cd.Ok)
                        return;
                }

                //  double tot = 0;
                bool _checked = false;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd == null)
                        continue;
                    if (cd.Virtuel)
                        continue;
                    if (cd.Ok)
                        continue;

                    //fd et nb dépendent des deux autres
                    // on ne prend pas en compte fd s'il concerne un track trop loin dans le temps. d, fd, nb, maxdate
                    //// Mauvaise idée, il faut au contraire pénaliser en augmentant le coût
                    //if (cd.type == borderType.fd || cd.type == borderType.nb)
                    //{
                    //    var cdd = cause.datas[0];
                    //    if (!cdd.Ok)
                    //        continue;
                    //    var cdt = cause.datas[3];
                    //    if (!cdt.Ok)
                    //        continue;
                    //}
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (item.Stopped)
                        continue;

                    if (cd.val <= item.torg)
                        continue;

                    //if (cd.type == borderType.nb || cd.type == borderType.nbp)
                    //{
                    //    bool isConcernedBySelection = cause.candidat.isConcernedBySelection;
                    //    if (isConcernedBySelection && cd.type == borderType.nb)
                    //        continue;
                    //    else if (!isConcernedBySelection && cd.type == borderType.nbp)
                    //        continue;
                    //}

                    _checked = true;

                    var tension = item.getTension(cd.val);
                    if (!conf.selectFix)
                    {
                        tension = item.Dt;
                    }

                    //tot += (tension * tension);
                    //if (_cause != null && tot >= _cause.tension)
                    //    return;



                    if (tension > 0 && _checked // (tot > 0 //COMMENT on peut avoir ZERO ???? et pourtant
                  && (_cause == null || tension < _cause.tension))
                    {
                        _cause = new CauseDatasTension(cause, tension);
                        cd.Update = true;
                    }

                }
                //if (tot > 0 && _checked // (tot > 0 //COMMENT on peut avoir ZERO ???? et pourtant
                //    && (_cause == null || tot < _cause.tension))
                //    _cause = new CauseDatasTension(cause, tot);

            }
            else
            {
                //foreach (CauseDataValue cd in cause.datas)
                //{
                //    if (cd.Virtuel && cd.Ok)
                //        return;
                //}

                double aux = 0;
                double min = int.MaxValue;
                CauseDataValue cdMin = null;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd == null)
                        continue;
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Ok)
                        continue;
                    //fd et nb dépendent des deux autres
                    // on ne prend pas en compte fd s'il concerne un track trop loin dans le temps. d, fd, nb, maxdate
                    //// Mauvaise idée, il faut au contraire pénaliser en augmentant le coût
                    //if (cd.type == borderType.fd || cd.type == borderType.nb)
                    //{
                    //    var cdd = cause.datas[0];
                    //    if (!cdd.Ok)
                    //        continue;
                    //    var cdt = cause.datas[3];
                    //    if (!cdt.Ok)
                    //        continue;
                    //}



                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (item.Stopped)
                        continue;

                    if (cd.val >= item.torg)
                        continue;

                    //if (cd.type == borderType.nb || cd.type == borderType.nbp)
                    //{
                    //    bool isConcernedBySelection = cause.candidat.isConcernedBySelection;
                    //    if (isConcernedBySelection && cd.type == borderType.nb)
                    //        continue;
                    //    else if (!isConcernedBySelection && cd.type == borderType.nbp)
                    //        continue; 
                    //}

                    var tension = item.getTension(cd.val);
                    if (conf.selectFix)
                    {
                        aux = -tension;
                    }

                    else
                    {
                        aux = tension - item.Tension;
                        if (conf.selectAbs && aux < 0)
                            aux = -aux;
                    }


                    if (aux < min)
                    {
                        min = aux;
                        cdMin = cd;
                    }

                }
                if (cdMin == null)
                    return;

                if (_cause == null || _cause.tension > min)
                {
                    cdMin.Update = true;
                    _cause = new CauseDatasTension(cause, min);
                }

            }

        }



    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Delta\Memory.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using pdb.util;
using System;
using System.Threading;

namespace pdb.podcast.Delta
{
    class TrackItemdesc
    {
        public string track;
        public string item;
        public TrackItemdesc(string track, string item)
        {
            this.track = track;
            this.item = item;
        }
        public override string ToString()
        {
            return string.Format("{0} <== {1}", item, track);
        }

        public override int GetHashCode()
        {
            return track.GetHashCode(); // +item.GetHashCode(); 
        }

        public override bool Equals(object obj)
        {
            var o = obj as TrackItemdesc;
            if (o == null)
                return false;
            return track.Equals(o.track);
        }
    }
    class Memory
    {
        const char SEP = ';';
        string file;
        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        private volatile object _lock = new object();
        private ThreadUtil th;
        private static bool _end;
        public static void End()
        {
            _end = true;
        }
        public Memory(string file)
        {
            this.file = file;

        }
        public Memory(Memory org)
        {
            this.file = org.file;
            this.dict = org.dict;
            this.ajouts = new List<TrackItemdesc>(org.ajouts);
            this.suppressions = new List<TrackItemdesc>(org.suppressions);
            this.readed = org.readed;

        }
        private bool loaded;
        public bool Loaded { get { return loaded; } }
        private bool readed;
        public BgDictString<TrackItemdesc> dict = new BgDictString<TrackItemdesc>();
        public List<TrackItemdesc> ajouts = new List<TrackItemdesc>();
        public List<TrackItemdesc> suppressions = new List<TrackItemdesc>();

        public List<TrackInfoItunes> tajouts = new List<TrackInfoItunes>();
        public List<TrackInfoItunes> tsuppressions = new List<TrackInfoItunes>();

        public void load()
        {
           

            loaded = false;
          
            ajouts = new List<TrackItemdesc>();
            suppressions = new List<TrackItemdesc>();
            tajouts = new List<TrackInfoItunes>();
            tsuppressions = new List<TrackInfoItunes>();

            if (readed)
            {
                loaded = true; 
                return;
            }
            readed = true; 
            dict = new BgDictString<TrackItemdesc>();
            if (!File.Exists(file))
                return;

            try
            {
                var lines = File.ReadAllLines(file);
                foreach (string line in lines)
                {
                    if (string.IsNullOrEmpty(line))
                        continue;
                    var tab = line.Split(SEP);
                    dict[tab[0]] = new TrackItemdesc(tab[1], tab[2]);
                }
                loaded = true;
                readed = true;
            }
            catch (Exception ex)
            {
                Program.log.log(ex.ToString());
            }

        }

        public void synchronize()
        {
           
        }

        private void loopSave()
        {
            while (!_end)
            {
                Thread.Sleep(100);
                if (_toRecord == null)
                    continue;

                try
                {
                    var sw = new StringBuilder();


                    foreach (TrackInfoItunes track in _toRecord)
                    {
                        sw.Append(track.Location);
                        sw.Append(SEP);
                        sw.Append(track.ToString());
                        sw.Append(SEP);
                        sw.AppendLine(track.GetProvider());
                    }

                    asyncFw.post(file, sw.ToString());
                }
                catch (Exception ex)
                {
                    misc.log("impossible de sauvegarder " + file + " " + ex); 
                   
                }
                finally
                {
                    lock (_lock)
                        _toRecord = null;
                }

            }
        }
        private IEnumerable<TrackInfoItunes> _toRecord;
        public void save(IEnumerable<TrackInfoItunes> list)
        {
            lock (_lock)
            {
                _toRecord = list;
                if (th == null)
                {
                    th = new ThreadUtil(loopSave, file);
                    th.Start();
                }
            }





            //try
            //{
            //    if (File.Exists(file))
            //        File.Delete(file);
            //    using (StreamWriter sw = new StreamWriter(File.Open(file, FileMode.Create)))
            //    {
            //        foreach (TrackInfoItunes track in list)
            //        {
            //            sw.Write(track.Location);
            //            sw.Write(SEP);
            //            sw.Write(track.ToString());
            //            sw.Write(SEP);
            //            sw.WriteLine(track.GetProvider());
            //        }
            //    }
            //}
            //catch (Exception ex)
            //{
            //    misc.log(ex.ToString()); 
            //}
        }


    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Tuning;
using pdb.util;
using System.Collections.Generic;
using System.Xml;
using System;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public class LimitsLoader
    {
        private DirConf dir;
        //  private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
        // public loadState state;
        //  private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
            var limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
            //  log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void init(DirConf dir)
        {
            this.dir = dir;
            var limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].init(this, limit[i]);
            }
        }

        //public void getLoaders(List<LimitItemLoader> list)
        //{
        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].getLoaders(list);
        //    }
        //}

        private bool candidatLoaded;
        private bool reload;
        public void resetLoad()
        {
            reload = true;
        }

        public void loadCandidats()
        {
            if (candidatLoaded)
            {
                foreach (LimitLoader item in limites)
                {
                    item.reset();
                }
                if (!reload)
                    return;
            }
            try
            {
                List<TrackSelector> t = null;
                var _params = dir.selectParams;
                if (_params != null && _params.Count > 0)
                {
                    t = new List<TrackSelector>();
                    foreach (SelectParamBase p in _params)
                    {
                        t.Add(new TrackSelector(p));
                    }
                }
                var feeds = dir.Feeds;
                string feedName = null;
                bool histo = dir.Histo;
                bool uniqueAlbum = dir.UniqueAlbum;
                if (uniqueAlbum)
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();

                var dateMin = dir.DateMin;
                var dateMax = dir.DateMax;

                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null)
                    {
                        if (track.Album != feedName)
                            continue;
                    }

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    if (dir.OrderNote)
                    {
                        if (!track.isPodcast)
                            continue;
                        if (track.Pub < dateMin)
                            continue;
                        if (track.Pub > dateMax)
                            continue;
                        if (!track.isConcernedBySelection)
                            continue;
                    }
                    if (t != null)
                    {
                        if (t.Count == 0)
                        {
                        }
                        else
                        {
                            bool ok = true;
                            bool modeOr = t[0].Param.modeOr;

                            if (modeOr)
                            {
                                ok = false;
                                foreach (TrackSelector tt in t)
                                {
                                    if (tt.selectSimple(track))
                                    {
                                        ok = true;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                foreach (TrackSelector tt in t)
                                {
                                    //modeOr = tt.Param.modeOr;
                                    if (!tt.selectSimple(track))
                                    {
                                        ok = false;
                                        break;
                                    }
                                }
                            }
                            if (!ok)
                                continue;
                        }

                    }

                    loaded.Add(track);
                }

                if (dir.OrderNote)
                {
                    var noteBuilder = dir.NoteBuilder;
                    noteBuilder.build(loaded);
                    noteBuilder.Sort(loaded, histo);
                }

                else if (histo)
                {
                    loaded.Sort(new PodcastComparerPubPub2());
                    //if (Conf.Albums.checkPub)
                    //    loaded.Sort(new PodCastComparer());
                    //else
                    //    loaded.Sort(new PodCastComparerPub2());
                }
                else
                    loaded.Sort(new PodCastComparerInv());


                //   for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    limit.loadCandidats(loaded);

                }


            }
            finally
            {
                //state = loadState.selection;
                candidatLoaded = true;
                reload = false;
            }
        }

        //private bool recordGuests;
        public void phase2()
        {
            // state = loadState.selection;
            //if (dir.Cascading)
            //    recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        //public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        //{

        //    if (!recordGuests)
        //        return;


        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].recordGuest(track, item);
        //    }
        //}

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        //{
        //    for (int i = 0; i < Limits.NB; i++)
        //    {
        //        limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
        //    }
        //}


        public void Freewheel()
        {
            if (dir.Parent == null)
            {
                var lfolders = dir.Folders;
                buildListPrior("_auto", null, lfolders);
            }
        }

        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                //var list = dir.getListe();

                //var limits = dir.Limites;
                //var usegenPrior = Conf.GenUsePrior;
                //var exclugenPrior = Conf.GenExcluPrior;

                //for (int i = 0; i < Limits.NB; i++)
                //{
                //    var limit = limites[i];
                //    foreach (LimitItemLoader item in limit.Items)
                //    {
                //        // var index = limit.index(item);
                //        //if (Conf.WriteItems)
                //        //{
                //        //    items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                //        //    buildList(item.Item.ID, items, "_sel");
                //        //}

                //        //if (Conf.WritePreSel)
                //        //{
                //        //    items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                //        //    buildList(item.Item.ID, items, "_sel0");
                //        //}
                //        //if (Conf.WriteUse)
                //        //{
                //        //    items = item.use;
                //        //    buildList(item.Item.ID, usegenPrior, items, "_use");
                //        //}
                //        //if (Conf.WriteExclu)
                //        //{
                //        //    var limite = item.Item;
                //        //    items = item.use.FindAll(t => t.Exclu == limite);
                //        //    buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                //        //}

                //    }
                //}

                //if (dir.Parent == null)
                //{
                var list = dir.getListe();
                   var lfolders = dir.Folders;
                if (!string.IsNullOrEmpty(dir.PlayList))
                {                 
                    buildListPrior(dir.PlayList, list, lfolders);
                }
                else if (dir.Parent == null)
                {

                    var contextB = ContexteBuilder.Instance;

                    if (contextB.Enabled)
                    {

                        var selected = dir.getListe();
                        selected.Sort(new PodCastComparer());

                        contextB.checkZeroPremJournee(selected);

                    }


                    buildListPrior("_auto", list, lfolders);

                    var limitContexte = ContexteBuilder.Instance.LimitWriteList;
                    var listeEnretard = list.FindAll(t => t.Pub2 <= limitContexte && !t.isConcernedBySelection);
                    buildListPrior("_retardG", listeEnretard, lfolders);

                    var listePre = list.FindAll(t => t.Pub2 <= limitContexte && t.isConcernedBySelection);
                    buildListPrior("_autoPre", listePre, lfolders);

                    foreach (SelectParamBase listeSuppl in Conf.Listes)
                    {
                        var selector = new TrackSelector(listeSuppl);
                        var l = new List<TrackInfoItunes>();
                        foreach (TrackInfoItunes t in list)
                        {
                            if (selector.select(t))
                                l.Add(t);
                        }

                        buildListPrior(listeSuppl.name, l, lfolders);
                    }

                    //var lHisto = list.FindAll(t => t.Histo);
                    //buildList("_histo", lHisto, lfolders);

                    //var lPasHisto = list.FindAll(t => !t.Histo);
                    //buildList("_pasHisto", lPasHisto, lfolders);

                    //var lSerie = list.FindAll(t => t.Serial);
                    //buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        //private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        //{
        //    Program.buildList(name, list, folders);
        //}
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders, false);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0;
            foreach (TrackInfoItunes track in list)
            {
                nb++;
                writer.StartElement("t");
                writer.SetAttribute("dt", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));

                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }

                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                if (track.Note < int.MaxValue)
                    writer.SetAttribute("n", track.Note.ToString("0.##"));
                writer.SetAttribute("track", track.Name);

                if (track.Pub2 > track.Pub)
                {
                    writer.SetAttribute("pub", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                    writer.SetAttribute("e", (track.Pub2 - track.Pub).TotalDays.ToString("0.#"));
                }
                if (nb <= nbmax)
                {
                    WriteCause(dir.CauseRegister.Get(track), true, true);
                    WriteCause(dir.CauseRegister.Get(track), true, false);
                    WriteCause(dir.CauseRegister.Get(track), false, true);
                    WriteCause(dir.CauseRegister.Get(track), false, false);

                }
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodcastComparerPubPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion

            #region long
            writer.StartElement("longs");

            var longs = items.FindAll(t => !t.isConcernedBySelection);
            writeTrackList(longs, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (!dir.UniqueAlbum)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;


                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    try
                    {
                        writer.StartElement("i");
                        writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                        var sb = new StringBuilder();
                        lim.writeStatHeader(sb);
                        lim.Stat.Total.buildValues(sb);
                        writer.SetAttribute("stats", sb.ToString());

                        writeTracks(dir, lim.Stat, null, false);
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex);
                    }

                    finally
                    {
                        writer.EndElement();
                    }
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes, bool strict, bool ok)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses(strict, ok, ok))
            {
                string str = "cause";
                if (strict)
                    str += "strict";
                if (!ok)
                    str += "nok";
                writer.StartElement(str);


                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString());
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause > 0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0;
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list = dir.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break;
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        if (track.Pub2 > track.Pub)
                            writer.SetAttribute("pub2", track.Pub2);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes, true, true);
                        WriteCause(causes, true, false);

                        WriteCause(causes, false, true);
                        WriteCause(causes, false, false);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {

            if (dir.ResetBefore)
            {
                dir.Loader.Albums.Clear();
            }
            //log.log("{0} Selection", dir);

            //for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                limit.Selection();

            }
            if (dir.ResetAfter)
            {
                dir.Loader.Albums.Clear();
            }

        }

        public override string ToString()
        {
            return dir.ToString();
        }

    }
}]]></content>
  </file>
  <file path="db4\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.ordo.conf;
using pdb.podcast.Auto;
using pdb.util;

namespace pdb.podcast.Tuning
{
    public enum menage
    {
        none,
        read,
        name
    }
    public class Conf
    {
        string SOV = "..\\sov\\";
        //private static string CONF_FILE = @"..\conf.xml";
        #region membres
        private DirConf root;
        private XmlElement xDir;
        private bool buildLimitMulti;
        private bool single;
        private Move move;
        private bool deleteDoublon;
        private bool getDescription;
        private int volumeMin = int.MinValue;
        private bool simulation;
        private string copyAll;
        private int maxScan = 10;
        private ConfOrdo ordo = new ConfOrdo();
        private menage menage = menage.none;
        private string poubelle = "";
        // private string zique;
        private bool writePlayLists;
        private bool writePreSel;
        private bool writeItems;
        private bool writeUse;
        private bool writeExclu;
        private bool genFeed;
        private int genFeedPrior = 11;
        private int genUsePrior = 11;
        private int genExcluPrior = 11;
        //private bool transmit = true;
        //private bool transmitTotal = true;
        //private bool transmitTotalGuest = true;
        private bool? cascading = null;
        private bool autoBlock;

        private ConfDate dates = new ConfDate();

        private List<SelectParam> selectParams = new List<SelectParam>();
        private List<Note> notes = new List<Note>();
        private Journal journal;
        private RootIt rootIt = new RootIt();
        private bool onlyEnabled = true;
        private bool onlyUnRead = true;
        private bool checkExist = true;

        // private Auto auto = null;
        private bool logGen = true;
        //private DateTime date0;
        //private DateTime date00;
        private double deltaOpen = 70;
        private Html html = new Html();

        private bool autoSequence = true;
        private bool borderVirtual;
        private bool borderIdem;
        private bool borderGranSlam;
        private bool borderTb;
        private bool autoSelect;
        private bool logDir;

        private Export export = new Export();
        private Hibernate import = new Hibernate();
        private Sort.Sort sort = new Sort.Sort();
        private Hibernate hibernate = new Hibernate();
        private Db db = new Db();
        private ConfAlbums albums = new ConfAlbums();
        private Listes listes = new Listes();
        private Listes globalListes = new Listes();

        private bool checkPub = true;

        private bool useMock;
        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        private bool freewheel = false;
        /// <summary>
        /// Semi-roue libre: on calcule les liste, mais on ne résurectionne pas de nouveaux tracks
        /// </summary>
        private bool noRevival = false;

        private string scan;

        private Contexte contexte = new Contexte();
        private DateRef dateRef = new DateRef();
        private bool @continue = false;

        private bool postReport; 

        private List<string> folders = new List<string>();
        #endregion
        public static readonly Conf Instance = new Conf();
        private static bool started;
        private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
        public void setConfFile(string conf)
        {
            this.confFile = new FileInfo(@"..\" + conf);

            if (!Directory.Exists(SOV))
                Directory.CreateDirectory(SOV);

            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            File.Copy(confFile.FullName, string.Format("{0}{1}_{2}", SOV, timeStamp, confFile.Name), true);
        }

        #region getters
        public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
        public static bool Single { get { return Instance.single; } }
        public static DirConf DirConf { get { return Instance.root; } }
        public static Move Move { get { return Instance.move; } }
        public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
        public static bool GetDescription { get { return Instance.getDescription; } }
        public static int VolumeMin { get { return Instance.volumeMin; } }
        public static bool Simulation { get { return Instance.simulation; } }
        public static string CopyAll { get { return Instance.copyAll; } }
        public static ConfOrdo Ordo { get { return Instance.ordo; } }
        public static int MaxScan { get { return Instance.maxScan; } }
        public static menage Menage { get { return Instance.menage; } }
        public static string Poubelle { get { return Instance.poubelle; } }
        public static bool WritePlayLists { get { return Instance.writePlayLists; } }
        public static bool WritePreSel { get { return Instance.writePreSel; } }
        public static bool WriteItems { get { return Instance.writeItems; } }
        public static bool WriteUse { get { return Instance.writeUse; } }
        public static bool WriteExclu { get { return Instance.writeExclu; } }
        public static bool GenFeed { get { return Instance.genFeed; } }
        public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
        public static int GenUsePrior { get { return Instance.genUsePrior; } }
        public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

        //public static bool Transmit { get { return Instance.transmit; } }
        //public static bool TransmitTotal { get { return Instance.transmitTotal; } }
        //public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
        public static bool? Cascading { get { return Instance.cascading; } }
        public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
        public static DateTime DateLevel { get { return Instance.dates.Level; } }

        internal static Journal Journal { get { return Instance.journal; } }
        internal static RootIt RootIt { get { return Instance.rootIt; } }

        public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
        public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }
        public static bool CheckExist { get { return Instance.checkExist; } }

        public static bool AutoBlock { get { return Instance.autoBlock; } }
        public static bool LogGen { get { return Instance.logGen; } }

        internal static Html Html { get { return Instance.html; } }

        public static bool AutoSequence { get { return Instance.autoSequence; } }
        public static bool BorderVirtual { get { return Instance.borderVirtual; } }
        public static bool BorderIdem { get { return Instance.borderIdem; } }
        public static bool BorderGranSlam { get { return Instance.borderGranSlam; } }
        public static bool BorderTb { get { return Instance.borderTb; } }
        public static bool AutoSelect { get { return Instance.autoSelect; } }
        public static Export Export { get { return Instance.export; } }
        internal static Hibernate Import { get { return Instance.import; } }
        public static Sort.Sort Sort { get { return Instance.sort; } }
        public static ConfAlbums Albums { get { return Instance.albums; } }
        internal static Hibernate Hibernate { get { return Instance.hibernate; } }
        internal static Db Db { get { return Instance.db; } }
        /// <summary>
        /// muy important. on calcule les dates max avec pub plutôt que Pub2
        /// </summary>
        //  public static bool CheckPub { get { return Instance.checkPub; } }
        public static bool UseMock { get { return Instance.useMock; } }
        public static bool LogDir { get { return Instance.logDir; } }
        public static double DeltaOPen { get { return Instance.deltaOpen; } }
        internal static Listes Listes { get { return Instance.listes; } }
        internal static Listes GlobalListes { get { return Instance.globalListes; } }
        internal static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
        internal static List<Note> Notes { get { return Instance.notes; } }

        internal static Contexte Contexte { get { return Instance.contexte; } }
        internal static DateRef DateRef { get { return Instance.dateRef; } }

        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        public static bool Freewheel { get { return Instance.freewheel; } }

        /// <summary>
        /// Semi-roue libre: on calcule les liste, mais on ne résurectionne pas de nouveaux tracks
        /// </summary>
        public static bool NoRevival { get { return Instance.noRevival; } }

        public static string Scan { get { return Instance.scan; } }
        //  public static string Zique { get { return Instance.zique; } }
        public static bool Continue { get { return Instance.@continue; } }
          public static bool PostReport { get { return Instance.postReport; } }
        #endregion

        private DateTime lastModif = DateTime.MinValue;
        private FileInfo confFile;
        public FileInfo ConfFile { get { return confFile; } }
        public static List<string> Folders { get { return Instance.folders; } }
        #region load

        public XmlElement load(bool waitForModification)
        {

            while (true)
            {
                confFile.Refresh();
                if (!confFile.Exists)
                    throw new ApplicationException(confFile + " n'existe pas !!");
                DateTime dt = confFile.LastWriteTime;
                if (dt > lastModif || !waitForModification)
                    break;
                Thread.Sleep(1000);
            }

            lastModif = confFile.LastWriteTime;

            XmlDocument l_doc = new XmlDocument();
            l_doc.Load(confFile.FullName);

            XmlElement xroot = l_doc.DocumentElement;
            XMLTool l_xmlConf = new XMLTool(xroot);

            string str = l_xmlConf.getNodeValue("volumeMin");
            if (!string.IsNullOrEmpty(str))
                volumeMin = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("maxScan");
            if (!string.IsNullOrEmpty(str))
                maxScan = Convert.ToInt32(str);

            buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
            simulation = l_xmlConf.getBoolValue("simulation");
            //   zique = l_xmlConf.getNodeValue("zique");

            deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
            getDescription = l_xmlConf.getBoolValue("getDescription");
            copyAll = l_xmlConf.getNodeValue("copyAll");

            poubelle = l_xmlConf.getNodeValue("poubelle");

            str = l_xmlConf.getNodeValue("menage");
            if (!string.IsNullOrEmpty(str))
                menage = (menage)(Enum.Parse(typeof(menage), str, true));

            writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
            writePreSel = l_xmlConf.getBoolValue("writePreSel");
            writeItems = l_xmlConf.getBoolValue("writeItems");
            writeUse = l_xmlConf.getBoolValue("writeUse");
            writeExclu = l_xmlConf.getBoolValue("writeExclu");
            genFeed = l_xmlConf.getBoolValue("genFeed");
            str = l_xmlConf.getNodeValue("genFeedPrior");
            if (!string.IsNullOrEmpty(str))
                genFeedPrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genUsePrior");
            if (!string.IsNullOrEmpty(str))
                genUsePrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genExcluPrior");
            if (!string.IsNullOrEmpty(str))
                genExcluPrior = Convert.ToInt32(str);

            //transmit = l_xmlConf.getBoolValue("transmit");
            //transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
            //transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
            onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
            onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
            checkExist = l_xmlConf.getBoolValue("checkExist", true);
            str = l_xmlConf.getNodeValue("cascading");
            if (!string.IsNullOrEmpty(str))
                cascading = "true".Equals(str);
            //  cascading = l_xmlConf.getBoolValue("cascading");

            //str = l_xmlConf.getNodeValue("date0");
            //if (!string.IsNullOrEmpty(str))
            //    date0 = Convert.ToDateTime(str);

            //str = l_xmlConf.getNodeValue("date00");
            //if (!string.IsNullOrEmpty(str))
            //    date00 = Convert.ToDateTime(str);

            var xDateRef = l_xmlConf.NodeLookUp("dateRef");
            dateRef = new DateRef(xDateRef);

            var xDates = l_xmlConf.NodeLookUp("playedDates");
            dates = new ConfDate(xDates);

            logGen = l_xmlConf.getBoolValue("logGen");
            var createNullLoggerOrg = Logger.CreateNullLoggers;

            Logger.CreateNullLoggers = !logGen;
            xDir = l_xmlConf.NodeLookUp("dir");

            var rootLimit = new Limits();
            buildLimit(xDir, rootLimit, null);

            AutoBuilder.clear();
            root = DirConf.getDir(rootLimit, xDir.Attributes["name"].InnerText, null); //new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
            root.build(null, xDir);
            buildDirChilds(xDir, root);
            root.Init();

            // AutoBuilder.getLoaders(); 

            XmlElement xMove = l_xmlConf.NodeLookUp("move");
            move = new Move(xMove);

            ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

            selectParams.Clear();

            var xSelect = l_xmlConf.NodeLookUp("select");
            if (xSelect != null)
            {
                foreach (XmlNode xsub in xSelect)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        selectParams.Add(new SelectParam(xSelect, x));
                }
            }

            notes.Clear();
            var xNotes = l_xmlConf.NodeLookUp("notes");
            if (xNotes != null)
            {
                foreach (XmlNode xsub in xNotes)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        notes.Add(new Note(x));
                }
            }

            journal = null;
            var xJournal = XMLTool.NodeLookUp(xroot, "journal");
            if (xJournal != null)
            {
                journal = new Tuning.Journal();
                buildLimitItem(xJournal, xJournal, journal);
                var xxJournal = new XMLTool(xJournal);
                journal.NbJour = xxJournal.getIntAttValue("nbJour");
            }

            rootIt = new Tuning.RootIt(l_xmlConf.NodeLookUp("rootIt")); //  l_xmlConf.getNodeValue("rootIt");

            autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
            //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
            //if (xAuto == null)
            //    auto = null;
            //else
            //    auto = new Auto(xAuto);

            XmlElement xHtml = l_xmlConf.NodeLookUp("html");
            html = new Html(xHtml);

            autoSequence = l_xmlConf.getBoolValue("autoSequence", true);
            borderVirtual = l_xmlConf.getBoolValue("borderVirtual", false);
            borderIdem = l_xmlConf.getBoolValue("borderIdem", false);
            borderGranSlam = l_xmlConf.getBoolValue("borderGranSlam", false);
            borderTb = l_xmlConf.getBoolValue("borderTb", false);
            autoSelect = l_xmlConf.getBoolValue("autoSelect", false);
            checkPub = l_xmlConf.getBoolValue("checkPub", false);
            useMock = l_xmlConf.getBoolValue("useMock ", false);
            logDir = l_xmlConf.getBoolValue("logDir ", false);

            freewheel = l_xmlConf.getBoolValue("freewheel", false);
            noRevival = l_xmlConf.getBoolValue("noRevival", false);
            @continue = l_xmlConf.getBoolValue("continue", false);
            postReport = l_xmlConf.getBoolValue("postReport", false);


            scan = l_xmlConf.getNodeValue("scan");

            var xExport = l_xmlConf.NodeLookUp("export"); // export = l_xmlConf.getNodeValue("export");
            export = new Tuning.Export(xExport);

            var xImport = l_xmlConf.NodeLookUp("import"); // export = l_xmlConf.getNodeValue("export");
            import = new Tuning.Hibernate(xImport);

            var xSort = l_xmlConf.NodeLookUp("sort");
            sort = new Tuning.Sort.Sort(xSort);


            var xAlbums = l_xmlConf.NodeLookUp("albums");
            albums = new ConfAlbums(xAlbums);

            var xHibernate = l_xmlConf.NodeLookUp("hibernate");
            hibernate = new Hibernate(xHibernate);


            var xDb = l_xmlConf.NodeLookUp("db");
            db = new Db(xDb);


            Logger.CreateNullLoggers = createNullLoggerOrg;
            var xlistes = l_xmlConf.NodeLookUp("listes");
            listes = new Listes(xlistes);

            var xglobal = l_xmlConf.NodeLookUp("global");
            globalListes = new Listes(xglobal);


            var xContext = l_xmlConf.NodeLookUp("context");
            contexte = new Contexte(xContext);

            folders = new List<string>();
            var xFolders = l_xmlConf.NodeLookUp("folders");
            if (xFolders != null)
            {
                foreach (var xsub in xFolders.ChildNodes)
                {
                    if (xsub is XmlElement)
                    {
                        var xxsub = xsub as XmlElement;
                        if (xxsub.Name == "f")
                        {
                            var f = XMLTool.getAttValue(xxsub, "f");
                            if (!string.IsNullOrEmpty(f))
                            {
                                if (!f.EndsWith("\\"))
                                    f = f + "\\";
                                folders.Add(f);
                            }
                        }
                    }
                }
            }

            started = true;
            return xroot;

        }

        #region limites

        private void buildDirChilds(XmlNode node, DirConf parent)
        {
            AutoBuilder.setClient(parent, node);
            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "auto")
                {
                    AutoBuilder.build(child, parent);
                }
                else
                {
                    if (child.Name == "dir")
                    {
                        string name = (child.Attributes["name"].InnerText);
                        Limits childLimite = parent.Limites.Clone() as Limits;
                        DirConf sub = DirConf.getDir(childLimite, name, parent); // new DirConf(childLimite, name, parent);
                        sub.buildR(xDir, child);

                        //if (child.Attributes["d"] != null)
                        //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);



                        if (child.Attributes["uniqueAlbum"] != null)
                        {
                            sub.UniqueAlbum = child.Attributes["uniqueAlbum"].Value == "true";
                        }
                        if (child.Attributes["order"] != null)
                        {
                            sub.OrderNote = child.Attributes["order"].Value == "note";
                        }
                        if (child.Attributes["histo"] != null)
                        {
                            sub.Histo = child.Attributes["histo"].Value == "true";
                        }
                        if (child.Attributes["resetBefore"] != null)
                        {
                            sub.ResetBefore = child.Attributes["resetBefore"].Value == "true";
                        }
                        if (child.Attributes["resetAfter"] != null)
                        {
                            sub.ResetAfter = child.Attributes["resetAfter"].Value == "true";
                        }

                        if (child.Attributes["playlist"] != null)
                        {
                            sub.PlayList = child.Attributes["playlist"].Value;
                        }
                        //if (child.Attributes["serial"] != null)
                        //{
                        //    sub.Serial = child.Attributes["serial"].Value == "true";
                        //}

                        //if (child.Attributes["cascading"] != null)
                        //    sub.Cascading = child.Attributes["cascading"].Value == "true";
                        if (child.Attributes["selectionPre"] != null)
                            sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                        sub.selectParams.Clear();
                        foreach (XmlNode xsub in child.ChildNodes)
                        {
                            if (xsub is XmlElement)
                            {
                                if (xsub.Name == "select")
                                {
                                    foreach (XmlNode xp in xsub.ChildNodes)
                                    {
                                        if (xsub is XmlElement)
                                        {
                                            var _param = new SelectParamBase(xsub as XmlElement, xp as XmlElement);
                                            sub.selectParams.Add(_param);
                                        }
                                    }
                                }
                            }
                        }

                        //if (child.Attributes["transmit"] != null)
                        //    sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                        //if (child.Attributes["transmitTotal"] != null)
                        //    sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                        //if (child.Attributes["transmitTotalGuest"] != null)
                        //    sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                        buildLimit(child, childLimite, sub);
                        parent.addChild(sub);
                        if (!started)
                            misc.log(sub.display());
                        buildDirChilds(child, sub);
                        sub.Init();

                    }
                }
            }

        }

        private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
        {
            string strTd = child.InnerText;
            if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
                item.Td = Convert.ToDouble(strTd);

            AutoBuilder.setClient(item, child);

            //foreach (XmlNode sub in child.ChildNodes)
            //{
            //    if (sub.Name == "auto")
            //        AutoBuilder.build(sub, item);
            //}

            item.build(parent, child);

            //var dAtt0 = parent.Attributes["d"];
            //if (dAtt0 != null)
            //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

            //var dAtt = child.Attributes["d"];
            //if (dAtt != null)
            //    item.Duration = Convert.ToSingle(dAtt.InnerText);

            //var cAtt0 = parent.Attributes["c"];
            //if (cAtt0 != null)
            //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

            //var cAtt = child.Attributes["c"];
            //if (cAtt != null)
            //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

            //var fdAtt0 = parent.Attributes["fd"];
            //if (fdAtt0 != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

            //var fdAtt = child.Attributes["fd"];
            //if (fdAtt != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

            //var nbAtt0 = parent.Attributes["nb"];
            //if (nbAtt0 != null)
            //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
            //var nbAtt = child.Attributes["nb"];
            //if (nbAtt != null)
            //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

            //var dateAtt0 = parent.Attributes["date"];
            //if (dateAtt0 != null)
            //    item.DateMin = getDate(dateAtt0.InnerText);
            //var dateAtt = child.Attributes["date"];
            //if (dateAtt != null)
            //    item.DateMin = getDate(dateAtt.InnerText);

            //var dateAtt0Max = parent.Attributes["maxdate"];
            //if (dateAtt0Max != null)
            //    item.DateMax = getDate(dateAtt0Max.InnerText);
            //var dateAttMax = child.Attributes["maxdate"];
            //if (dateAttMax != null)
            //    item.DateMax = getDate(dateAttMax.InnerText);
        }

        //private static bool date00Consumed;
        //public static void date00Consume() { date00Consumed = true; }

        public static DateTime Date0
        {
            get
            {
                return Instance.dateRef.date0;
            }
        }

        public static DateTime DateContexte
        {
            get
            {
                return Instance.dateRef.contexte;
            }
        }


        public static DateTime getDate(string str)
        {
            if (string.IsNullOrWhiteSpace(str))
                return DateTime.MaxValue;
            double d = -1;
            var date0 = Date0;
            var dateContexte = DateContexte;
            var dateC0 = dateContexte;
            if (date0 < dateContexte)
                dateC0 = date0;

            if (str.EndsWith("c0"))
            {

                var _str = str.Remove(str.Length - 2);
                if (double.TryParse(_str, out d))
                {
                    return dateC0.AddDays(d);
                }
            }
            else if (str.EndsWith("c"))
            {

                var _str = str.Remove(str.Length - 1);
                if (double.TryParse(_str, out d))
                {
                    return dateContexte.AddDays(d);
                }
            }

            else if (double.TryParse(str, out d))
            {
                if (d >= 0)
                {
                    return date0.AddDays(d);
                }
                else
                    return DateTime.Now.Date.AddDays(d);
            }

            return Convert.ToDateTime(str);
        }

        private void buildLimit(XmlNode node, Limits limits, DirConf dir)
        {

            Limit[] tab = new Limit[Limits.NB];

            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "list")
                {

                    int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                    Limit limit = new Limit(level);
                    var items = new List<LimitItem>();

                    double tdMin = 0;
                    foreach (XmlNode xItem in child.ChildNodes)
                    {
                        //if (xItem.Name == "auto")
                        //{
                        //    AutoBuilder.build(xItem, limit);
                        //}
                        //else 
                        if (xItem.Name == "td")
                        {
                            var item = new LimitItem(limit);
                            item.TdMin = tdMin;
                            buildLimitItem(child, xItem, item);


                            var itemTd = item.Td;
                            if (itemTd < int.MaxValue)
                                tdMin = item.Td;
                            items.Add(item);
                        }
                    }

                    if (items.Count == 0)
                    {
                        var defaultItem = new LimitItem(limit);
                        buildLimitItem(child, child, defaultItem);
                        items.Add(defaultItem);
                    }

                    limit.Items = items;

                    //var dAtt = child.Attributes["d"];
                    //if (dAtt != null)
                    //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                    //var fdAtt = child.Attributes["fd"];
                    //if (fdAtt != null)
                    //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                    //var nbAtt = child.Attributes["nb"];
                    //if (nbAtt != null)
                    //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                    tab[level] = limit;
                }

            }

            Limit current = null;
            bool oneTabAtLeast = false;
            //  LimitItem currentItem = null;

            double currentDuration = int.MaxValue;
            double lcurrentDuration = int.MaxValue;
            double currentContrib = int.MaxValue;
            double currentFeedDuration = int.MaxValue;
            // double lcurrentFeedDuration = int.MaxValue;
            int currentNb = int.MaxValue;
            int currentNbp = int.MaxValue;
            int lcurrentNb = int.MaxValue;

            int currentNbMax = int.MaxValue;
            int currentNbpMax = int.MaxValue;
            double currentTd = int.MaxValue;

            double currentTdMin = int.MaxValue;
            DateTime currentDateMin = DateTime.MinValue;
            DateTime currentDateMax = DateTime.MaxValue;
            // bool currentOverwrite = false;

            for (int i = 0; i < Limits.NB; i++)
            {

                //if (tab[i] != null)
                //{

                if (tab[i] != null)
                {
                    current = tab[i];
                    oneTabAtLeast = true;

                }

                if (!oneTabAtLeast)
                    current = limits[i];

                var _limit = limits[i];
                _limit.Level = i;
                limits[i].Parent = limits;

                //foreach (LimitItem currentItem in current.Items)
                //{

                if (_limit.Items.Count != current.Items.Count)
                {
                    _limit.Items.Clear();
                }

                for (int j = 0; current != null && j < current.Items.Count; j++)
                {

                    var currentItem = current.Items[j];
                    // if (currentItem.Duration < int.MaxValue)
                    currentDuration = currentItem.Duration;
                    // currentOverwrite = currentItem.OverwriteConf;
                    lcurrentDuration = currentItem.LoadDuration;
                    //if (currentItem.Contribution < int.MaxValue)
                    currentContrib = currentItem.Contribution;
                    // if (currentItem.FeedDuration < int.MaxValue)
                    currentFeedDuration = currentItem.FeedDuration;
                    //  lcurrentFeedDuration = currentItem.LoadFeedDuration;

                    //   if (currentItem.Nb < int.MaxValue)
                    currentNb = currentItem.Nb;
                    currentNbp = currentItem.Nbp;
                    lcurrentNb = currentItem.LoadNb;

                    currentNbMax = currentItem.NbMax;
                    currentNbpMax = currentItem.NbpMax;
                    //  if (currentItem.Td < int.MaxValue)
                    currentTd = currentItem.Td;
                    currentTdMin = currentItem.TdMin;

                    currentDateMin = currentItem.DateMin;
                    currentDateMax = currentItem.DateMax;
                    //}
                    //}

                    //if (current != null)
                    //{
                    LimitItem _limitItem = null;
                    if (j >= _limit.Items.Count)
                    {
                        _limitItem = currentItem.Clone() as LimitItem;
                        _limit.Items.Add(_limitItem);
                        _limitItem.Limit = _limit;

                    }
                    else
                    {
                        _limitItem = _limit.Items[j];

                    }
                    //if (currentDuration < int.MaxValue)
                    _limitItem.setDuration(currentDuration, false); // Duration = currentDuration;
                    _limitItem.LoadDuration = lcurrentDuration;
                    //if (currentContrib < int.MaxValue)
                    //    _limitItem.Contribution = currentContrib;
                    // if (currentFeedDuration < int.MaxValue)
                    _limitItem.setFeedDuration(currentFeedDuration, false); // FeedDuration = currentFeedDuration;
                    // _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                    // if (currentNb < int.MaxValue)
                    _limitItem.setNb(currentNb, false);
                    _limitItem.setNbp(currentNbp, false);
                    _limitItem.LoadNb = lcurrentNb;

                    _limitItem.NbMax = currentNbMax;
                    _limitItem.setNbpMax(currentNbpMax, false);
                    //   if (currentTd < int.MaxValue)
                    _limitItem.Td = currentTd;
                    _limitItem.TdMin = currentTdMin;
                    _limitItem.DateMin = currentDateMin;
                    _limitItem.setDateMax(currentDateMax, false);
                    _limitItem.Contribution = currentContrib;
                    //   _limitItem.OverwriteConf = currentOverwrite;



                    if (dir != null)
                    {
                        if (_limitItem.Duration == int.MaxValue)
                            _limitItem.setDuration(dir.Duration, true); // Duration = dir.Duration;
                        if (_limitItem.LoadDuration == int.MaxValue)
                            _limitItem.LoadDuration = dir.LoadDuration;
                        if (_limitItem.Contribution == int.MaxValue)
                            _limitItem.Contribution = dir.Contribution;
                        if (_limitItem.Td == int.MaxValue)
                            _limitItem.Td = dir.Td;
                        if (_limitItem.Nb == int.MaxValue)
                            _limitItem.setNb(dir.Nb, true);
                        if (_limitItem.Nbp == int.MaxValue)
                            _limitItem.setNbp(dir.Nbp, true);
                        if (_limitItem.NbMax == int.MaxValue)
                            _limitItem.NbMax = dir.NbMax;
                        if (_limitItem.NbpMax == int.MaxValue)
                            _limitItem.setNbpMax(dir.NbpMax, true);
                        if (_limitItem.LoadNb == int.MaxValue)
                            _limitItem.LoadNb = dir.LoadNb;
                        if (_limitItem.FeedDuration == int.MaxValue)
                            _limitItem.setFeedDuration(dir.FeedDuration, true);
                        //if (_limitItem.LoadFeedDuration == int.MaxValue)
                        //    _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                        if (_limitItem.DateMin == DateTime.MinValue)
                            _limitItem.DateMin = dir.DateMin;
                        if (_limitItem.DateMax == DateTime.MaxValue)
                            _limitItem.setDateMax(dir.DateMax, true);
                    }

                    _limitItem.setParent(dir);

                }

                //}
                // }

            }

        }
        #endregion
        #endregion

    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Tuning\DirConf.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.podcast.Report;
using pdb.util;
using pdb.podcast.Load;
using pdb.podcast.Auto;
using pdb.podcast.Selection;
using System;
using pdb.podcast.Notes;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Répertoire de pistes
    /// </summary>
    public class DirConf : LimitItemBase, IEnumerable<DirConf>//, IBuilderSource, IBorder
    {
        /// <summary>
        /// logger
        /// </summary>
        // private Logger log;
        /// <summary>
        /// Limites associées au noeud
        /// </summary>
        private Limits limites;
        /// <summary>
        /// Nom du répertoire
        /// </summary>
        private string name = "";

        /// <summary>
        /// Sous-répertoires
        /// </summary>
        private List<DirConf> childs = new List<DirConf>();

        /// <summary>
        /// Répertoire parent
        /// </summary>
        new private DirConf parent;

        /// <summary>
        /// Stats
        /// </summary>
        private DirStat stat;
        internal DirStat Stat { set { stat = value; } get { return stat; } }
        internal TrackConteneur Conteneur { get { return conteneur; } }

        private CauseRegister _causeRegister;
        internal CauseRegister CauseRegister
        {
            get
            {
                if (_causeRegister != null)
                    return _causeRegister;
                if (parent == null)
                    return null;
                return parent.CauseRegister;
            }
        }

        private Feeds feeds;
        internal Feeds Feeds
        {
            get
            {
                if (feeds != null)
                    return feeds;
                if (parent == null)
                    return null;
                return parent.Feeds;
            }
        }

        private NoteBuilder noteBuilder;
        internal NoteBuilder NoteBuilder
        {
            get
            {
                if (noteBuilder != null)
                    return noteBuilder;
                if (parent == null)
                {

                    foreach (Note _note in Conf.Notes)
                    {
                        if (_note.dir == name)
                        {
                            this.noteBuilder = new NoteBuilder(_note);
                            break;
                        }
                    }

                    if (noteBuilder != null)
                        return noteBuilder;
                    return null; 
                }


                return parent.NoteBuilder;
            }
        }


        /// <summary>
        /// Ajout d'un sous-répertoire
        /// </summary>
        /// <param name="dir"></param>
        public void addChild(DirConf dir)
        {
            if (childs.Contains(dir))
                return;
            childs.Add(dir);

        }
        public DirConf Parent
        {
            get { return parent; }
        }

        public bool isChildOf(DirConf dir)
        {
            if (dir == this)
                return true;
            if (parent == null)
                return false;
            return parent.isChildOf(dir);
        }

        /// <summary>
        /// Conteneur des pistes
        /// </summary>
        private TrackConteneur conteneur;

        private FeedsLoader loader;
        internal FeedsLoader Loader
        {
            get
            {
                if (loader == null)
                    loader = new FeedsLoader(this);
                return loader;
            }

        }



        //public void buildLoaders(List<LimitItemLoader> list, AutoBuilder auto)
        //{
        //    if (auto != Auto)
        //        return;
        //    var loader = Loader;
        //    var fl = loader.LimitsLoader;
        //    fl.getLoaders(list);
        //    foreach (DirConf sub in childs)
        //    {
        //        sub.buildLoaders(list, auto);
        //    }
        //}

        /// <summary>
        /// Enregistrement d'une piste
        /// </summary>
        /// <param name="track">piste</param>
        /// <param name="provider">item de limite</param>
        public void recordTrack(TrackInfoItunes track, LimitItem limit)
        {
            if (offset > DateTime.MinValue)
            {
                track.Offset = offset;
                offset = offset.AddDays(1);
            }
            conteneur.recordTrack(track, limit);
            //if (parent != null)
            //    parent.recordTrackFromChild(track, limit, this);
        }

        //public void recordTrackStandAlone(TrackInfoItunes track, LimitItem limit)
        //{
        //    conteneur.recordTrackStandAlone(track, limit);
        //}

        /// <summary>
        /// Récupération de la liste des pistes
        /// </summary>
        /// <returns></returns>
        public List<TrackInfoItunes> getListe()
        {
            var list = conteneur.getListe();
            if (Histo)
                list.Sort(new PodcastComparerPubPub2());
            else
                list.Sort(new PodCastComparerInv());
            //log.log("");
            //log.log(getPath() + " getListe " + list.Count + " elt.");
            //foreach (TrackInfoItunes track in list)
            //{
            //    log.log(track.ToString());
            //}
            return list;
        }

        //public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, DirConf dirSource)
        //{
        //    if (dirSource.transmitToParent)
        //        Loader.recordTrackFromChild(track, itemSource, dirSource.transmitTotal);
        //    if (parent != null)
        //        parent.recordTrackFromChild(track, itemSource, this);
        //}

        ///// <summary>
        ///// Abandonné
        ///// </summary>
        //public void TransmissionListToParent(TrackInfoItunes track)
        //{
        //}


        //public void recordTrackForStats(TrackInfoItunes track, LimitItem provider)
        //{
        //    conteneur.recordTrackForStats(track, provider);
        //}






        public List<SelectParamBase> selectParams = new List<SelectParamBase>();

        public Limits Limites { get { return limites; } set { limites = value; } }


        private static Dict<string, DirConf> dict = new Dict<string, DirConf>();
        public static DirConf getDir(Limits limites, string name, DirConf parent)
        {
            // return new DirConf(limites, name, parent); 
            string path = getPath(parent, name);


            var d = dict[path];
            if (d == null)
            {
                d = new DirConf(limites, name, parent);
                dict[path] = d;
                return d;
            }
            else
            {
                //  var nd = new DirConf(limites, name, parent);
                dict[path] = d;
                d.recup = true;
                d.init(limites, name, parent);
                // nd.loader = d.loader; 
            }

            return d;

        }


        private DirConf(Limits limites, string name, DirConf parent)
            : base()
        {
            init(limites, name, parent);
        }
        private bool recup = false;

        public void Init()
        {
            if (recup && loader != null)
            {
                loader.init(this);
            }
        }
        private void init(Limits limites, string name, DirConf parent)
        {
            this.name = name;
            this.limites = limites;
            limites.Parent = this;
            this.parent = parent;
            this.setParent(parent);
            //  this.log = Logger.getLogger(getPath() + "\\dir", false);
            if (parent == null)
            {
                conteneur = new TrackConteneur(this, null);
                if (feeds == null)
                    feeds = new Feeds();
                if (this.NoteBuilder == null)
                {
                    foreach (Note _note in Conf.Notes)
                    {
                        if (_note.dir == name)
                        {
                            this.noteBuilder = new NoteBuilder(_note);
                            break;
                        }
                    }
                }
                if (Conf.Html.writeCause <= 0)
                {
                    _causeRegister = new NullRegister();
                }
                else
                    _causeRegister = new CauseRegister();
            }
            else
                conteneur = new TrackConteneur(this, parent.conteneur);
            //transmitToParent = Conf.Transmit;
            //transmitTotal = Conf.TransmitTotal;
            //transmitTotalGuest = Conf.TransmitTotalGuest;
            //   cascading = Conf.Cascading;
            if (loader != null)
            {
                if (parent != null)
                    loader.Albums.Clear();


            }

            this.borderObs.Clear();

        }

        ///// <summary>
        ///// durée max de chaque item
        ///// </summary>
        //public float Duration
        //{
        //    set { duration = value; }
        //    get
        //    {
        //        if (parent == null || duration < int.MaxValue)
        //        {
        //            return duration;
        //        }
        //        return parent.Duration;

        //    }
        //}

        /// <summary>
        /// Répertoire de type Info
        /// </summary>
        public bool? Info
        {
            get
            {
                if (name == "info")
                    return true;
                if (name == "PAS Info")
                    return false;
                if (parent == null)
                    return null;
                return parent.Info;
            }
        }

        /// <summary>
        /// Répertoire de type rare
        /// </summary>
        public bool? Rare
        {
            get
            {
                if (name == "RARE")
                    return true;
                if (name == "PAS RARE")
                    return false;
                if (parent == null)
                    return null;
                return parent.Rare;
            }
        }
        private bool? histo;
        /// <summary>
        /// Répertoire de type historique
        /// </summary>
        public bool Histo
        {
            get
            {
                if (histo.HasValue)
                    return histo.Value;
                if (name == "Histo")
                    return true;
                if (parent == null)
                    return false;
                return parent.Histo;
            }
            set
            {
                histo = value;
            }
        }

        private string playlist; 
        public string PlayList
        {
            get
            {
                return playlist;
            }
            set
            {
                playlist = value; 
            }
        }

        public bool ResetBefore;
        public bool ResetAfter;

        private bool orderNote;
        public bool OrderNote { get { return orderNote; } set { orderNote = value; } }

        //private bool serial;
        //public bool Serial { get { return serial; } set { serial = value; } }

        /// <summary>
        /// Simple sélection nominative(par album)
        /// </summary>
        private bool uniqueAlbum;
        public bool UniqueAlbum
        {
            get
            {
                return uniqueAlbum;
            }
            set
            {
                uniqueAlbum = value;
            }
        }

        //private bool? cascading;
        //public bool Cascading
        //{
        //    get
        //    {
        //        if (cascading.HasValue)
        //            return cascading != false;
        //        if (false == histoAll)
        //            return false;
        //        if (parent == null)
        //            return true;
        //        return parent.Cascading;
        //    }
        //    set
        //    {
        //        cascading = value;
        //    }
        //}

        private bool? selectionPre;
        public bool SelectionPre
        {
            get
            {
                if (selectionPre.HasValue)
                    return selectionPre != false;
                if (false == selectionPre)
                    return false;
                if (parent == null)
                    return false;
                return parent.SelectionPre;
            }
            set
            {
                selectionPre = value;
            }
        }

        //private bool transmitToParent = true;
        //public bool TransmitToParent { get { return transmitToParent; } set { transmitToParent = value; } }

        //private bool transmitTotal = true;
        //public bool TransmitTotal { get { return transmitTotal; } set { transmitTotal = value; } }

        //private bool transmitTotalGuest = true;
        //public bool TransmitTotalGuest { get { return transmitTotalGuest; } set { transmitTotalGuest = value; } }



        /// <summary>
        /// Arbre généalogique du répertoire permettant de situer les listes à modifier
        /// </summary>
        public List<string> Folders
        {
            get
            {

                if (parent == null)
                    return new List<string> { name };
                var list = parent.Folders;
                list.Add(name);
                return list;

            }

        }
        public string Name { get { return name; } }

        /// <summary>
        /// Représentation du chemin depuis le root
        /// </summary>
        /// <returns></returns>
        public string getPath()
        {
            return getPath(parent, name);
        }

        public static string getPath(DirConf parent, string name)
        {
            if (parent == null)
                return name;
            string path = parent.getPath();
            if (string.IsNullOrEmpty(path))
                return name;
            return path + "\\" + name;
        }



        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            //sb.Append(" ");
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            //sb.Append(limites.ToString());
            return sb.ToString();
            // return getPath() + " " + Environment.NewLine + limites.ToString();
        }

        public string display()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            sb.AppendLine();
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            sb.Append(limites.ToString());
            return sb.ToString();
        }



        public IEnumerator<DirConf> GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        public List<LimitItem> getAllListItems()
        {
            var list = new List<LimitItem>();
            buildListLimitItems(list);
            return list;
        }

        protected void buildListLimitItems(ICollection<LimitItem> depot)
        {
            foreach (DirConf sub in this)
                sub.buildListLimitItems(depot);
            foreach (Limit limit in limites)
            {
                foreach (LimitItem item in limit.Items)
                    depot.Add(item);
            }
        }

        #region ITrackReport Members

        /// <summary>
        /// Rapport
        /// </summary>
        /// <param name="sb"></param>
        public void rapport(DescBuilder sb)
        {
            sb.beginLine();

            conteneur.rapport(sb);
            sb.AppendLine();


            if (!LimitItem.includeDetail)
                return;
            foreach (DirConf sub in childs)
            {
                var descBuilder = sb.createChild(sub.getPath());
                sub.rapport(descBuilder);
            }

        }
        public double getTotalSize()
        {
            return conteneur.getTotalSize();
        }





        #endregion

        #region IBuilderSource
        public List<TrackInfoItunes> getSelectedTracks()
        {
            var items = new List<TrackInfoItunes>(conteneur.Tracks.Total.Use.List);
            if (Histo)
                items.Sort(new PodcastComparerPubPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;
        }

        public IDictionary<string, TrackInfoItunes> getAllTracks()
        {
            return Feeds.LoadedTracks;
        }


        public string getEmpreinte()
        {
            return conteneur.Tracks.Total.Use.getEmpreinte();
        }


        private AutoBuilder auto;
        public AutoBuilder Auto
        {
            get
            {
                if (auto != null)
                    return auto;
                if (parent != null)
                    return parent.Auto;
                return null;
            }
            set
            {
                auto = value;
            }
        }
        #region IBorder
        private List<AutoBuilder> borderObs = new List<AutoBuilder>();
        public void addBorderObs(AutoBuilder auto)
        {
            borderObs.Add(auto);
        }
        #endregion
        #endregion

        public void signal(TrackBorderItem tb)
        {
            //if (uniqueAlbum)
            //    return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(tb);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(tb);
        }


        public bool canSignal()
        {
            return true;
            //if (false == HistoAll || serial) //OUAILLE?
            //    return false;
            //return true; 
        }

        public void signal(CauseDatas cd)
        {
            //if (false == HistoAll || serial) //OUAILLE?
            //    return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(cd);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(cd);
        }

        public double getMaxDateAuto()
        {
            foreach (AutoBuilder border in borderObs)
            {
                return border.getMaxDateAuto();
            }
            if (parent != null)
                return parent.getMaxDateAuto();
            return 0;
        }
    }
}
]]></content>
  </file>
</db>
