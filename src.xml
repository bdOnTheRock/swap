<db path="C:\bernard\db2\">
  <file path="db4\pdb.player\ViewModel\PlayListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Threading;
using pdb.db.obj;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;


namespace pdb.player.ViewModel
{
    public class PlayListViewModel : BibViewModelTreelBase, INotifyCollectionChanged, IEnumerable<PlayListViewModel>
    {
        protected Logger log;
        private object _lock = new object();
        private PlayList pl;
        private List<BibViewModelBase> _childs = new List<BibViewModelBase>();
        protected List<PlayListViewModel> _playlists = new List<PlayListViewModel>();
        //  private List<PlayListViewModel> __playlists = new List<PlayListViewModel>(); 
        private List<TrackListViewModel> _tracks = new List<TrackListViewModel>();

        //private static List<IRedraw> gui = new List<IRedraw>();
        //internal static void addDrow(IRedraw _gui) { gui.Add(_gui); }
        private static bool _log;
        public static bool Log { set { _log = value; } }
#if EXPORT
        #region export
        private List<TrackListViewModel> exportTracks = new List<TrackListViewModel>();
        public List<TrackListViewModel> ExportTracks { get { return exportTracks; } set { exportTracks = value; } }
        #endregion
#endif
        private bool _main = true;
        public void setSecondary() { _main = false; }


        private static void redraw()
        {
            // foreach (IRedraw _gui in gui)  _gui.redraw();
        }

        #region optim recherche
        //private static BgDictString<PlayListViewModel> dictPl = new BgDictString<PlayListViewModel>();
        //private static BgDictString<TrackListViewModel> dictT = new BgDictString<TrackListViewModel>();
        //protected static void recordPl(PlayListViewModel pl)
        //{
        //    dictPl.Add(pl.pl.getPath(), pl);
        //}

        //protected static string getKey(PlayListViewModel pl, int id)
        //{
        //    return pl.pl.getPath() + "|" + id;
        //}

        private HashSet<int> hs = new HashSet<int>();

        protected void recordTrack(TrackListViewModel t)
        {
            hs.Add(t.PieceId);
        }

        public bool contains(int id)
        {
            return hs.Contains(id);
        }

        //public static bool containsTrack(TrackListViewModel t, PlayListViewModel pl)
        //{
        //    return dictT.ContainsKey(getKey(pl, t.PieceId));
        //}

        protected void removeTrack(TrackListViewModel t)
        {
            hs.Remove(t.PieceId); // dictT.Remove(getKey(pl, t.PieceId));
        }

        //public static TrackListViewModel findTrack(PlayListViewModel pl, int id)
        //{
        //    var key = getKey(pl, id);
        //    if (dictT.ContainsKey(key))
        //        return dictT[key];
        //    return null;
        //}

        //public TrackListViewModel FindTrack(int id)
        //{
        //    return findTrack(this, id);
        //}

        public static void resetExport(exportState state)
        {
            misc.log("resetExport {0}", state);
            try
            {
                foreach (var t in TrackListViewModel.Dict.Values)
                    t.ExportStatus = state;
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public static void setExport(Piece p, exportState state)
        {
            if (_selectedPl != null)
            {

                try
                {
                    var t = TrackListViewModel.getOrCreate(p); // findTrack(_selectedPl, id);
                    if (t != null)
                    {
                        t.ExportStatus = state;
                    }

                    //foreach (TrackListViewModel t in _selectedPl._tracks)
                    //{
                    //    if (t.PieceId == id)
                    //        t.refresh();
                    //}
                }
                //foreach (TrackListViewModel t in dictT.Values)
                //{
                //    if (t.PieceId == id)
                //        t.ExportStatus = state;
                //}

                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }


        }

        //protected bool contains( int id)
        //{
        //    //return hs.Contains(id); 
        //    //var key = getKey(pl, id);
        //    //if (dictT.ContainsKey(key))
        //    //    return true;
        //    //return false;
        //}


        #endregion


        static PlayListViewModel()
        {
            //  App.refresh += new EventHandler(App_refresh);
        }

        static void App_refresh(object sender, EventArgs e)
        {
            //var pl = _selectedPl;
            //if (pl != null)
            //    pl.refresh(); 
        }

        public bool isSubList(string name)
        {
            return pl.isSubList(name);
        }

        public bool isSubList(PlayListViewModel pl)
        {
            return this.pl.isSubList(pl.PlayList);
        }

        public void init()
        {
            _childs.Clear();
            _playlists.Clear();
            _tracks.Clear();

            foreach (PlayList sublist in pl.PlayLists)
            {
                var _pl = new PlayListViewModel(sublist, this);
                _childs.Add(_pl);
                _playlists.Add(_pl);
                //  recordPl(_pl);
            }
            foreach (Piece track in pl.Items)
            {
                if (track.Virtual && !PlayerViewModel.Instance.WithVirtualAlbum)
                    continue;
                TrackListViewModel _t = null;
                if (_main)
                    _t = TrackListViewModel.getOrCreate(track); // new TrackListViewModel(track, this);
                else
                    _t = TrackListViewModel.getOrCreateA(track);
                _childs.Add(_t);
                _tracks.Add(_t);
                recordTrack(_t);
            }



            allTracks = new AllTracksViewModel(this, false, false);
        }


        public void Synch()
        {
            var hsnew = new HashSet<int>();
            foreach (Piece track in pl.Items)
            {
                hsnew.Add(track.PieceId);
                if (!hs.Contains(track.PieceId))
                {
                    log.log("Sync {0} ajout {1}", this, track);
                    TrackListViewModel _t = null;
                    if (_main)
                        _t = TrackListViewModel.getOrCreate(track); // new TrackListViewModel(track, this);
                    else
                        _t = TrackListViewModel.getOrCreateA(track);
                    _childs.Add(_t);
                    _tracks.Add(_t);
                }
            }

            foreach (int oldId in hs)
            {
                if (!hsnew.Contains(oldId))
                {
                    TrackListViewModel _t = null;
                    if (_main)
                        _t = TrackListViewModel.get(oldId); // new TrackListViewModel(track, this);
                    else
                        _t = TrackListViewModel.getA(oldId);
                    string desc = oldId.ToString();
                    if (_t != null)
                        desc = _t.ToString();
                    log.log("Sync {0} suppression {1}", this, desc);
                    if (_t != null)
                    {
                        _childs.Remove(_t);
                        _tracks.Remove(_t);
                    }
                }
            }

            hs = hsnew;
        }


        public PlayListViewModel get(string name)
        {
            return get(name, false);
        }

        public PlayListViewModel get(string name, bool create)
        {
            foreach (var pl in _playlists)
                if (pl.Name == name)
                    return pl;
            if (!create)
                return null;
            var _pl = new PlayList(name, this.pl);
            var _new = new PlayListViewModel(_pl, this);
            _playlists.Add(_new);
            _childs.Add(_new);
            // recordPl(_new);
            //_new.PropertyChanged += _pl_PropertyChanged;
            //_new.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, _new));

            //  redraw(); 
            return _new;
        }


        private PlayListViewModel _getFromPath(string[] tab, int index)
        {
            for (; index < tab.GetLength(0); index++)
            {
                string dir = tab[index];
                if (string.IsNullOrEmpty(dir))
                    continue;
                if (dir.Equals(Name))
                    continue;
                var sub = get(dir, false);
                if (sub == null)
                    return null;
                return sub._getFromPath(tab, index + 1);
            }

            return this;

        }

        public PlayListViewModel getFromPath(string path)
        {
            var tab = path.Split(PlayListComposite.SEP);
            return _getFromPath(tab, 0);
        }

        public List<TrackListViewModel> Tracks { get { return _tracks; } }
        private AllTracksViewModel allTracks;
        public AllTracksViewModel AlltracksVm { get { return allTracks; } }

        //private AllTracksViewModel alltracksVmd;
        //public AllTracksViewModel AlltracksVmd
        //{
        //    get
        //    {
        //        if (alltracksVmd == null)
        //            alltracksVmd = new AllTracksViewModel(this, true, false);
        //        return alltracksVmd;

        //    }
        //}

        //private AllTracksViewModel alltracksFather;
        //public AllTracksViewModel AllTrackFather
        //{
        //    get
        //    {
        //        if (alltracksFather == null)
        //            alltracksFather = new AllTracksViewModel(this,null, true);
        //        return alltracksFather;
        //    }
        //}


        //private AllTracksViewModel alltracksFatherDisabled;
        //public AllTracksViewModel AllTrackFatherDisabled
        //{
        //    get
        //    {
        //        if (alltracksFatherDisabled == null)
        //            alltracksFatherDisabled = new AllTracksViewModel(this, true, true);
        //        return alltracksFatherDisabled;
        //    }
        //}

        public PlayListViewModel(PlayList pl)
            : this(pl, null)
        {
        }

        private PlayListViewModel(PlayList pl, PlayListViewModel parent)
            : base(pl, parent)
        {
            this.pl = pl;
            log = Logger.getLogger(pl.getPath());
            init();

        }
        public PlayList PlayList { get { return pl; } }

        public string Name
        {
            get
            {
                return pl.Name;
            }
            set
            {
                if (value != Name)
                {
                    pl.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        #region selected

        /// <summary>
        /// element sélectionné. Répercuté jusqu'à la racine de l'arbre
        /// </summary>
        private static PlayListViewModel _selectedPl;
        public static PlayListViewModel SelectedPlayList
        {
            get
            {
                return _selectedPl;
            }
            private set
            {
                if (_selectedPl == value)
                    return;
                var _oldpl = _selectedPl;
                _selectedPl = value;
                if (_selectedPl != null)
                {
                    _selectedPl.IsSelected = true;
                    _selectedPl.IsExpanded = true;
                }
                OnSelectedPlayListChange(_oldpl);
            }
        }

        public static void initSelected(string strPl)
        {
            if (!string.IsNullOrEmpty(strPl))
            {
                var selected = App.bib.Root.getFromPath(strPl);

                if (selected != null)
                    PlayListViewModel.SelectedPlayList = selected;

            }
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;

                if (_isSelected)
                {
                    SelectedPlayList = this;
                }

            }
        }

        #endregion

        public static event EventHandler selectedPlaylistChange;
        private static void OnSelectedPlayListChange(PlayListViewModel oldPl)
        {
            if (selectedPlaylistChange != null)
                selectedPlaylistChange(oldPl, EventArgs.Empty);
        }


        #region INotifyCollectionChanged Members

        public event NotifyCollectionChangedEventHandler CollectionChanged;

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            var client = new SimpleClient("PlayListViewModel::OnCollectionChange", log);
            // Be nice - use BlockReentrancy like MSDN said
            lock (_lock)
            {
                client.log("_lock");
                var eventHandler = CollectionChanged;
                if (eventHandler != null)
                {
                    Delegate[] delegates = eventHandler.GetInvocationList();
                    // Walk thru invocation list

                    foreach (NotifyCollectionChangedEventHandler handler in delegates)
                    {

                        App.Dispatch(() => { handler(this, e); client.log("handler"); }, client);
                        //try
                        //{
                        //    var dispatcherObject = handler.Target as DispatcherObject;
                        //    // If the subscriber is a DispatcherObject and different thread
                        //    if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        //    // Invoke handler in the target dispatcher's thread
                        //    {
                        //        var ope =
                        //        dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                        //                           handler, this, e);
                        //        ope.Completed += ope_Completed;
                        //    }
                        //    else // Execute handler as is
                        //        handler(this, e);
                        //}
                        //catch (Exception ex)
                        //{
                        //    App.log.log(ex.ToString());
                        //}
                    }
                }
            }
            client.End();

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (this.CollectionChanged == null)
            //    {
            //        int toto = 0;
            //    }
            //    else
            //        this.CollectionChanged(this, e);               
            //}
            //else
            //    dispatcher.Invoke(new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e); 

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("PlayListViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
        }

        #endregion

        public PlayListViewModel getOrCreatePlayList(string name)
        {

            var found = _playlists.Find(pl => pl.Name == name);
            if (found == null)
            {
                found = AddPlayList(name);
            }

            return found;
        }

        public PlayListViewModel AddPlayList(string name)
        {
            var subModel = new PlayList(name, pl);
            var sub = new PlayListViewModel(subModel, this);
            _childs.Add(sub);
            _playlists.Add(sub);
            //recordPl(sub);
            //   __playlists.Add(sub);
            //sub.PropertyChanged += _pl_PropertyChanged;
            //sub.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, sub));
            // PLayLists.Add(sub); 
            // redraw(); 
            return sub;
        }

        public TrackListViewModel AddTrack(IFile file, bool signal)
        {
            // var piece = App.Db.getPiece(location);
            return AddTrack(file as Piece, signal);

        }

        private TrackListViewModel Get(IFile file)
        {
            var t = TrackListViewModel.get(file.PieceId);
            if (t == null)
                t = AddTrack(file as Piece, false);
            return t;
        }

        private TrackListViewModel Get(Piece file)
        {
            var t = TrackListViewModel.get(file.PieceId);
            if (t == null)
                t = AddTrack(file, false);
            return t;
        }

        public TrackListViewModel AddTrack(Piece piece, bool signal)
        {
            if (_log) log.log("{0} AddTrack {1}", pl.getPath(), piece.ToString());
            if (hs.Contains(piece.PieceId))
            {
                App.Instance.InfoIHm(string.Format("le morceau {0} est déjà présent dans la liste {1}", piece, this), "Ajout dans la playlist");
                return null;
            }
            //var tl = new TrackList(piece);
            pl.add(piece);
            //var p = piece.Track;
            //CPiece cPiece = null;
            //if (p is CPiece)
            //    cPiece = p as CPiece;

            //else if (p is TrackListViewModel)
            //{
            //    var pp = ((TrackListViewModel)p).Piece;
            //    cPiece = pp as CPiece;
            //}


            //if (cPiece != null)
            //    pl.addPiece(cPiece);
            var vm = TrackListViewModel.getOrCreate(piece); // new TrackListViewModel(tl, this);
            _childs.Add(vm);
            _tracks.Add(vm);
            recordTrack(vm);
            //  vm.PropertyChanged += _pl_PropertyChanged;
            if (signal)
            {
                //OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, vm));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }

            return vm;
        }

        public void RemoveTrack(TrackListViewModel tl, bool signal)
        {
            if (_log) log.log("{0} RemoveTrack {1}", pl.getPath(), tl.Piece);
            _childs.Remove(tl);
            _tracks.Remove(tl);
            removeTrack(tl);


            tl.remove();
            //TODO faire la suppression de l'item de liste org

            if (signal)
            {
                // OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, tl));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }
        }

        private void insert(TrackListViewModel k, List<IFile> newElements)
        {
            int indexInsert = k.Index - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k);
        }

        private void insert2(TrackListViewModel k, List<Piece> newElements)
        {
            int indexInsert = k.Index2 - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k.PieceGen);
        }
        //  private bool filterNext; 
        public void mergeList(ICollection<IFile> newElements_, IAbortTask writer)
        {
            lock (Consolid.Lock)
            {
                lock (Albums.Lock)
                {
                    var tt = TrackListViewModel.HumanSelected;
                    if (tt != null)
                    {
                        tt.refresh();
                        //var g = tt.Grouping; 
                        // tt.Grouping = tt.PieceGen.RankAlbumReverse.ToString();
                    }

                    bool isMe = PlayListViewModel.SelectedPlayList == null || PlayListViewModel.SelectedPlayList == this;
                    bool isAlbum = this.isSubList("album");
                    bool isGen = this.isSubList("gen");


                    var confalbum = App.gen.SortAlbumMode;
                    int stackBefore = 4;
                    if (confalbum != null && confalbum.stackBefore > 0)
                        stackBefore = confalbum.stackBefore;

                    // bool checkStack = (PlayListViewModel.SelectedPlayList == null || PlayListViewModel.SelectedPlayList == this) && isGen && !isAlbum && confalbum.stackEnabled;

                    int _indexAlbumRead = -1;
                    int _indexTrackRead = -1;
                    Album _currentAlbum = null;
                    TrackListViewModel current = TrackListViewModel.CurrentPlaying;
                    Album currentAlbum = null;
                    if (current != null)
                        currentAlbum = current.album;
                    var conf = CConf.ConfGen;
                    List<TrackListViewModel> toDelete = new List<TrackListViewModel>();
                    List<TrackListViewModel> toKeep = new List<TrackListViewModel>();

                    var newElements = new HashList<IFile>(newElements_);


                    BgDict<int, bool?> newElt = new BgDict<int, bool?>();
                    foreach (IFile elt in newElements_)
                    {
                        newElt[elt.PieceId] = false;
                    }

                    int indexAlbumOrg = -1;
                    int indexTrackOrg = -1;

                    int indexAlbumOrg2 = -1;
                    int indexTrackOrg2 = -1;
                    var tracks = _tracks;
                    //if (isMe)
                    //{
                    tracks = new List<TrackListViewModel>(_tracks);
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
                    // }

                    int count0 = _tracks.Count;
                    //  var limitList = CConf.ConfGen.LimitList;

                    foreach (TrackListViewModel tl in tracks)
                    {
                        if (tl.album != _currentAlbum)
                        {
                            _currentAlbum = tl.album;
                            _indexAlbumRead++;
                            _indexTrackRead = 0;
                        }
                        else
                            _indexTrackRead++;
                        var found = newElt[tl.PieceId] != null;
                        bool keep = false;
                        //if (isMe)
                        //{
                        if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                        {
                            keep = true;
                        }
                        else if (current != null && current.PieceId == tl.PieceId)
                        {
                            keep = true;
                            indexAlbumOrg = _indexAlbumRead;
                            indexTrackOrg = _indexTrackRead;
                        }
                        //}

                        newElt[tl.PieceId] = keep;


                        //if (current != null && !keep && tl.Location == current.Location)
                        //{
                        //    App.log.log("bizarre");
                        //}
                        if (!found)
                        {
                            if (keep)
                                toKeep.Add(tl);
                            else
                                toDelete.Add(tl);
                        }
                    }

                    //if (checkStack)
                    //{
                    _indexAlbumRead = -1;
                    _indexTrackRead = -1;
                    tracks.Sort((x, y) => x.Index2.CompareTo(y.Index2));
                    // }

                    foreach (TrackListViewModel tl in tracks)
                    {
                        if (tl.album != _currentAlbum)
                        {
                            _currentAlbum = tl.album;
                            _indexAlbumRead++;
                            _indexTrackRead = 0;
                        }
                        else
                            _indexTrackRead++;
                        var found = newElt[tl.PieceId] != null;


                        if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                        {

                        }
                        else if (current != null && current.PieceId == tl.PieceId)
                        {

                            indexAlbumOrg2 = _indexAlbumRead;
                            indexTrackOrg2 = _indexTrackRead;
                        }

                    }
                    //  }



                    //Addition
                    List<IFile> toAdd = new List<IFile>();
                    //if (limitList <= 0 || !_log)
                    //{
                    foreach (IFile elt in newElements)
                    {
                        if (writer.Aborted)
                            return;

                        bool found = hs.Contains(elt.PieceId); // contains(this, elt.PieceId);


                        if (!found)
                            toAdd.Add(elt);

                    }
                    //  log.log("mergeList::fin determination toAdd");

                    if (toAdd.Count > 0 && _log)
                        log.log("{0} {1} elt to add", this, toAdd.Count);

                    if (tracks.Count > 0 && toAdd.Count > 100) //&& filterNext == PlayerViewModel.Instance.FilterNext)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt to add c'est trop!", this, toAdd.Count);
                        try { toAdd.RemoveRange(100, toAdd.Count - 100); }
                        catch { toAdd.Clear(); }

                        //return;
                        //var l = new List<IFile>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toAdd[i]);
                        //toAdd = l;
                    }

                    if (tracks.Count > 0 && toDelete.Count > 0 && _log)
                        log.log("{0} {1} elt to delete", this, toDelete.Count);

                    if (toDelete.Count > 100) //&& filterNext == PlayerViewModel.Instance.FilterNext)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt toDelete c'est trop!", this, toDelete.Count);

                        try { toDelete.RemoveRange(100, toDelete.Count - 100); }
                        catch { toDelete.Clear(); }

                        // toDelete.Clear();
                        //var l = new List<TrackListViewModel>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toDelete[i]);
                        //toDelete = l;
                    }


                    int count = toAdd.Count;
                    for (int i = 0; i < count; i++)
                    {
                        if (writer.Aborted) return;

                        AddTrack(toAdd[i], false);
                    }

                    foreach (TrackListViewModel vm in toDelete)
                    {
                        if (writer.Aborted) return;
                        RemoveTrack(vm, false);
                    }
                    //  }


                    var newElements3 = newElements;

                    if (isGen)
                    {
                        Album.clearMove();
                        HashSet<int> moved = new HashSet<int>();
                        HashSet<int> empeached = new HashSet<int>();
                        HashSet<int> unavailable = new HashSet<int>();
                        newElements3 = new HashList<IFile>();
                        // chercher le premier album non quarantaine
                        decimal min = int.MaxValue;
                        Piece pMin = null;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            var t = newElements[i] as Piece;
                            if (t.InStackPeremption)
                                continue;
                            var aux = t.PieceAlbum.ClassementValueLightSt;
                            if (aux < min)
                            {
                                min = aux;
                                pMin = t;
                            }
                            if (!t.InStackSize && t.PieceAlbum != null)
                            {
                                break;
                            }
                        }


                        // int ifirst = 0;
                        bool b = false;
                        Album courant = null;
                        int nbOk = 0;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            var t = newElements[i] as Piece;
                            if (t.PieceAlbum == courant)
                                continue;
                            courant = t.PieceAlbum;

                            if (courant.Absent)
                            {
                                unavailable.Add(t.PieceAlbum.Next.MasterId);
                            }
                            else
                            {
                                if (t == pMin)
                                {
                                    // newElements3.Add(t);
                                    continue;
                                }

                                if (courant.InStackPeremption ||
                                    (courant.InStackSize && courant.ClassementValueLight < min
                                        && courant.ClassementValueLightSt > min)) //  checkStack && courant.ClassementValueLightSt >= min)
                                {
                                    if (!b)
                                    {
                                        courant.Empeached1 = true;
                                        b = true;
                                    }
                                    //if (courant.InStackPeremption)
                                    //{
                                    empeached.Add(t.PieceAlbum.Next.MasterId);
                                    courant.Empeached = true;
                                    // }

                                    moved.Add(t.PieceAlbum.Next.MasterId);
                                    courant.Moved = true;

                                    newElements3.Add(t);



                                }
                                else
                                    nbOk++;
                                if (nbOk > stackBefore)
                                    break;
                            }


                        }

                        if (0 < newElements.Count) // && checkStack)
                        {

                            HashSet<Album> albs = new HashSet<Album>();
                            count = newElements.Count;
                            courant = null;

                            for (int i = 0; i < count; i++)
                            {

                                var t = newElements[i] as Piece;
                                if (t.PieceAlbum.Moved)
                                    continue;
                                if (t.PieceAlbum.Empeached)
                                    continue;
                                if (t != pMin && t.InStackSize && t.ClassementValueLight < min && t.ClassementValueLightSt > min)
                                {
                                    moved.Add(t.PieceAlbum.Next.MasterId);
                                    t.Moved = true;
                                    if (t.isEmpeached())
                                    {
                                        empeached.Add(t.PieceAlbum.Next.MasterId);
                                    }

                                }
                                else if (t.AlbumAbsent)
                                { }// moved.Add(t.Album); 
                                else
                                {
                                    var _alb = t.PieceAlbum;
                                    if (courant != _alb)
                                    {
                                        courant = _alb;

                                        if (!albs.Contains(courant))
                                        {
                                            if (albs.Count < stackBefore)
                                            {
                                                albs.Add(courant);
                                            }
                                            else
                                                break;
                                        }
                                    }

                                    newElements3.Add(t);
                                }
                            }
                            var listAux = new List<Piece>();
                            foreach (var p in newElements3)
                            {
                                listAux.Add(p as Piece);
                            }

                            listAux.Sort(new PieceStackCmp());

                            var aux2 = new List<Piece>(listAux);
                            int nbMove = 0;
                            for (int i = 0; i < aux2.Count; i++)
                            {
                                var p = aux2[i];
                                if (p.InStackPeremption && i < stackBefore)
                                {
                                    var indexN = stackBefore + nbMove;
                                    listAux.Remove(p);
                                    if (indexN < listAux.Count)
                                        listAux.Insert(indexN, p);
                                    else
                                        listAux.Add(p);
                                    nbMove++;
                                }
                            }

                            newElements3 = new HashList<IFile>();
                            albs.Clear();
                            foreach (Piece p in listAux)
                            {
                                newElements3.Add(p);
                                if (p.PieceAlbum != null)
                                    albs.Add(p.PieceAlbum);
                            }


                            for (int i = 0; i < count; i++)
                            {
                                var t = newElements[i] as Piece;
                                var alb_ = t.PieceAlbum;
                                if (alb_ == null)
                                    continue;

                                if (!albs.Contains(alb_))
                                    newElements3.Add(t);
                                //if (alb_ != alb && alb_ != alb2 && alb_ != alb3 && alb_ != alb4)
                                //    newElements3.Add(t);
                            }
                        }
                        else
                            newElements3 = newElements;

                        allTracks.setNbAlbum(unavailable.Count, empeached.Count, moved.Count);



                    }
                    else
                    {
                        allTracks.setNbAlbum(-1, -1, -1);
                    }




                    var newElements2 = new List<IFile>(newElements3);
                    List<Piece> stackSorted = null;
                    //if (checkStack)
                    //{
                    stackSorted = new List<Piece>();
                    foreach (IFile iFile in newElements2)
                    {
                        //var t = Get(iFile); // TrackListViewModel.get(iFile.PieceId);// findTrack(this, iFile.PieceId);
                        //if (t != null)
                        //{
                        stackSorted.Add(iFile as Piece);
                        // }
                    }

                    stackSorted.Sort(new PieceStackCmp());

                    //}
                    foreach (IFile iFile in newElements3)
                    {
                        var keep = newElt[iFile.PieceId];
                        var t = Get(iFile); // TrackListViewModel.get(iFile.PieceId);// findTrack(this, iFile.PieceId);
                        if (t != null)
                        {
                            if (true == keep)
                            {
                                int index0 = t.Index - 1;
                                int index1 = newElements2.IndexOf(iFile);
                                if (index1 > index0)
                                {
                                    newElements2.Remove(iFile);
                                    insert(t, newElements2);
                                }

                                //if (checkStack)
                                //{
                                int index20 = t.Index2 - 1;
                                int index21 = stackSorted.IndexOf(t.PieceGen);
                                if (index21 > index20)
                                {
                                    stackSorted.Remove(t.PieceGen);
                                    insert2(t, stackSorted);
                                }
                                // }
                            }

                        }
                    }

                    foreach (TrackListViewModel k in toKeep)
                    {
                        insert(k, newElements2);
                    }

                    //if (checkStack)
                    //{
                    foreach (TrackListViewModel k in toKeep)
                    {
                        insert2(k, stackSorted);
                    }
                    // }

                    if (indexAlbumOrg >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;

                        bool dontTouch = false;

                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            var ifile = newElements2[i] as Piece;
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = newElements2.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {

                                newElements2.Remove(currentFile);
                                newElements2.Insert(newIndex, currentFile);
                            }
                        }
                    }



                    if (indexAlbumOrg2 >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;

                        bool dontTouch = false;

                        for (int i = 0; i < stackSorted.Count; i++)
                        {
                            var ifile = stackSorted[i];
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg2)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = stackSorted.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {
                                stackSorted.Remove(currentFile);
                                stackSorted.Insert(newIndex, currentFile);
                            }
                        }

                    }




                    int index = 1;
                    var rankMax = 0;
                    for (int i = 0; i < newElements3.Count; i++)
                    {
                        var ifile = newElements2[i];

                        var t = Get(ifile); // TrackListViewModel.get(ifile.PieceId); // findTrack(this, ifile.PieceId);
                        if (t == null)
                        {
                            App.log.log("file ID {0} non trouvé dans {1} {2}", ifile.PieceId, this, ifile.Location);

                        }
                        else
                        {
                            if (isMe)
                            {
                                var rank = t.RankAlbum;
                                if (rank > rankMax)
                                    rankMax = rank;


                                //var keep = newElt[ifile.PieceId];
                                //if (true != keep)
                                t.Index = index;

                                // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                                if (i == 0)
                                {
                                    t.refresh();
                                    // var g = t.Grouping; 
                                }
                            }
                        }
                        index++;
                    }

                    if (isMe)
                        Albums.RankZero = rankMax + 1;

                    //if (checkStack)
                    //{
                    index = 1;
                    for (int i = 0; i < stackSorted.Count; i++)
                    {
                        var t = Get(stackSorted[i]); // TrackListViewModel.get(stackSorted[i].PieceId); // findTrack(this, stackSorted[i].PieceId);
                        if (t == null)
                            continue;

                        //var keep = newElt[ifile.PieceId];
                        //if (true != keep)
                        t.Index2 = index;
                        // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                        if (i == 0)
                        {
                            t.refresh();
                            // var g = t.Grouping; 
                        }

                        index++;
                    }
                    // }

                    if (current != null && current.Index > 1)
                    {
                        App.log.log("le courant a l'index {0} {1}", current.Index, current);

                        int index1 = -1;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            if (newElements[i].PieceId == current.PieceId) { index1 = i; break; }
                        }

                        int index2 = -1;
                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            if (newElements2[i].PieceId == current.PieceId) { index2 = i; break; }
                        }

                        int index3 = -1;
                        for (int i = 0; i < newElements3.Count; i++)
                        {
                            if (newElements3[i].PieceId == current.PieceId) { index3 = i; break; }
                        }
                        App.log.log("indexes {0} {1} {2}", index1, index2, index3);

                    }

                    #region c'est bien mais un peu luxueux et ça casse le dont touch

                    /*
                    var hsf = new HashSet<int>();
                    var lf = new List<TrackListViewModel>();


                    var max = 0m;
                    for (int i = 0; i < newElements2.Count && i < stackBefore; i++)
                    {
                        var ifile = newElements2[i];
                        var t = Get(ifile);
                        if (t == null)
                            continue;
                        if (t.PieceGen == null || t.PieceGen.InStackPeremption)
                            continue;
                        if (hsf.Add(t.PieceId))
                        {
                            lf.Add(t);
                            max = t.ClassementValueLight;
                        }
                    }


                    for (int i = 0; i < stackSorted.Count && i < stackBefore; i++)
                    {
                        var t = Get(stackSorted[i]); // TrackListViewModel.get(stackSorted[i].PieceId); // findTrack(this, stackSorted[i].PieceId);
                        if (t == null)
                            continue;
                        if (!hsf.Contains(t.PieceId))
                        {
                            if (t.PieceGen == null || t.PieceGen.InStackPeremption)
                                continue;
                            if (t.ClassementValueLightSt > max)
                                continue;
                            hsf.Add(t.PieceId);
                            lf.Add(t);
                        }
                    }

                    lf.Sort((x, y) =>
                    {
                        var xx = x.ClassementValueLightSt > max ? x.ClassementValueLight : x.ClassementValueLightSt;
                        var yy = y.ClassementValueLightSt > max ? y.ClassementValueLight : y.ClassementValueLightSt;
                        return xx.CompareTo(yy);
                    });

                    for (int i = 0; i < lf.Count; i++)
                    {
                        lf[i].Index = i + 1;
                    }
                    */
                    #endregion




                    //if (limitList > 0)
                    //{
                    //    toAdd.Clear();
                    //    toDelete.Clear();
                    //    bool onlyNext = App.gen.FilterNext;
                    //    var list = new List<TrackListViewModel>();
                    //    foreach (IFile p in newElements3)
                    //    {
                    //        var t = Get(p); // TrackListViewModel.get(p.PieceId);
                    //        if (onlyNext && !t.PieceGen.IsNext)
                    //            continue;
                    //        list.Add(t);
                    //    }
                    //    list.Sort((x, y) => x.Index.CompareTo(y.Index));
                    //    if (list.Count > limitList)
                    //    {
                    //        list = list.GetRange(0, limitList);
                    //    }

                    //    var hs = new HashSet<int>();
                    //    foreach (TrackListViewModel t in _tracks)
                    //    {
                    //        hs.Add(t.PieceId);
                    //    }

                    //    var hsNew = new HashSet<int>();
                    //    foreach (TrackListViewModel t in list)
                    //    {
                    //        hsNew.Add(t.PieceId);
                    //        if (!hs.Contains(t.PieceId))
                    //        {
                    //            toAdd.Add(t);
                    //        }
                    //    }

                    //    foreach (TrackListViewModel t in _tracks)
                    //    {
                    //        if (!hsNew.Contains(t.PieceId))
                    //        {
                    //            toDelete.Add(t);
                    //        }
                    //    }


                    //    foreach (TrackListViewModel vm in toAdd)
                    //    {
                    //        if (writer.Aborted) return;

                    //        AddTrack(vm, false);
                    //    }

                    //    foreach (TrackListViewModel vm in toDelete)
                    //    {
                    //        if (writer.Aborted) return;
                    //        RemoveTrack(vm, false);
                    //    }
                    //}
                }

                //if (toAdd.Count > 0 || toDelete.Count > 0)
                //{
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                //if (alltracksFather != null)
                //    alltracksFather.refresh();
                //if (alltracksFatherDisabled != null)
                //    alltracksFatherDisabled.refresh();

                //}
                //filterNext = PlayerViewModel.Instance.FilterNext; 
            }
        }

        //private class StackCmp : IComparer<TrackListViewModel>
        //{
        //    public int Compare(TrackListViewModel x, TrackListViewModel y)
        //    {
        //        int cmp = x.ClassementValueLightSt.CompareTo(y.ClassementValueLightSt);
        //        //if (x.StackValue > 0 && y.StackValue > 0)
        //        //    cmp = 
        //        //else
        //        //    cmp = x.Index.CompareTo(y.Index);
        //        if (cmp != 0)
        //            return cmp;
        //        return x.Index.CompareTo(y.Index);
        //    }
        //}

        public IEnumerator<PlayListViewModel> GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        private SortDescriptionCollection sort;
        public SortDescriptionCollection Sort { get { return sort; } set { sort = value; } }

#if EXPORT
        public string getEmpreinte()
        {
            var sb = new StringBuilder();
            sb.Append(exportTracks.Count);
            sb.Append(" éléments:");
            long hash = 0;
            foreach (TrackListViewModel t in exportTracks)
            {
                hash += t.PieceId.GetHashCode();
            }
            sb.Append(hash);

            return sb.ToString();

        }
#endif
    }
}
]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\CPieceComparer.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.IO;
namespace pdb.gen
{
    public class PieceDeepClassementComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.DeepClassement.CompareTo(y.DeepClassement);
        }
    }

    public class CPieceComparerByGoodness : IComparer<Piece>
    {
        /// <summary>
        /// compareur de listes
        /// </summary>
        private static CPlayListComparer c_comparer = new CPlayListComparer();
        public static bool modeBatch = true;
        public int Compare(Piece x, Piece y)
        {
            return -x.Classement.CompareTo(y.Classement);
            //return -x.RapportClassement(false).CompareTo(y.RapportClassement(false));
            ////var cmp =  x.RapportClassement.CompareTo(y.RapportClassement);
            ////if (cmp != 0)
            ////    return -cmp;
            ////cmp = x.Duration.CompareTo(y.Duration);
            ////if (cmp != 0)
            ////    return -cmp;
            ////return x.PieceId.CompareTo(y.PieceId); 
            ////if (!modeBatch)
            ////{
            ////    if (x.ClassPlayList == null)
            ////    {
            ////        if (y.ClassPlayList == null)
            ////        {
            ////            return -(x.RatingCmp.CompareTo(y.RatingCmp));
            ////        }
            ////        else
            ////        {
            ////            return 1;
            ////        }
            ////    }
            ////    if (y.ClassPlayList == null)
            ////    {
            ////        return -1;
            ////    }
            ////}

            //// gérer le cas ou les deux listes sont imbriquées
            //// 3.4 > 33.5 et 3.2 < 33.0

            ////if (x.isClassListNumeric && y.isClassListNumeric)
            ////{
            //String strX = x.ClassNameAndRating(false);
            //String strY = y.ClassNameAndRating(false);
            //var cmpnameRat = compareClassNameAndRating(strX, strY);
            //if (cmpnameRat != 0) return cmpnameRat;
            ////}
            ////if (!modeBatch)
            ////{

            ////    CPlayList plX = x.ClassPlayList;
            ////    CPlayList plY = y.ClassPlayList;

            ////    //if( plX.isSubList(plY) || plY.isSubList(plX))
            ////    //{
            ////    //    string xName = plX.Name;
            ////    //    string yName = plY.Name; 

            ////    //}


            ////    int l_plCmp = c_comparer.Compare(plX, plY);
            ////    if (l_plCmp == 0)
            ////    {
            ////        return -(x.RatingCmp.CompareTo(y.RatingCmp));
            ////    }
            ////    else
            ////    {
            ////        return l_plCmp;
            ////    }
            ////}
            ////else
            //    return -(x.RatingCmp.CompareTo(y.RatingCmp));


        }

        public static int compareClassNameAndRating(string strX, string strY)
        {
            int max = strX.Length > strY.Length ? strX.Length : strY.Length;
            for (int i = 0; i < max; i++)
            {
                int iX = strX.getInt(i); // CUtil.getInt(strX, i);
                int iY = strY.getInt(i);//CUtil.getInt(strY, i);
                if (iX != iY)
                    return -iX.CompareTo(iY);
            }
            return 0;
        }

    }

    public class CPieceComparerByGoodness2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return x.Rank.Quality.CompareTo(y.Rank.Quality);
        }
    }

    public class CPieceComparerByQualityAndLength : IComparer<Piece>
    {

        private static IComparer<Piece> c_comparer = new CPieceComparerByGoodness2();
        public virtual int Compare(Piece x, Piece y)
        {
            int l_cmp = c_comparer.Compare(x, y);
            if (l_cmp == 0)
                return -x.Duration.CompareTo(y.Duration);
            return l_cmp;
        }
    }

    //public class CPieceComparerByQualityAndLength2 : IComparer<Piece>
    //{
    //    int IComparer<Piece>.Compare(Piece x, Piece y)
    //    {
    //        return x.Rank.Twice.CompareTo(y.Rank.Twice);
    //    }
    //}

    //public class CPieceComparerByQualityAndLengthInv : IComparer<Piece>
    //{

    //    private static IComparer<Piece> c_comparer = new CPieceComparerByGoodness2();
    //    public virtual int Compare(Piece x, Piece y)
    //    {
    //        int l_cmp = c_comparer.Compare(x, y);
    //        if (l_cmp == 0)
    //            return x.Rank.Lenght.CompareTo(y.Rank.Lenght);
    //        return l_cmp;
    //    }
    //}

    //public class CPieceComparerByQualityAndLengthInv2 : IComparer<Piece>
    //{
    //    int IComparer<Piece>.Compare(Piece x, Piece y)
    //    {
    //        return x.Rank.TwiceInv.CompareTo(y.Rank.TwiceInv);
    //    }
    //}

    /// <summary>
    /// tri pour la copie : En premier : les plus bas et les activés
    /// </summary>
    public class CPieceComparerByQualityLengthAndEnable : CPieceComparerByQualityAndLength
    {
        public override int Compare(Piece x, Piece y)
        {
            if (x.Enabled == y.Enabled)
            {
                return -base.Compare(x, y);
            }
            if (x.Enabled)
                return -1;
            return 1;
        }
    }


    public class CPieceComparerByLenght : IComparer<Piece>
    {

        public int Compare(Piece x, Piece y)
        {
            return x.Duration.CompareTo(y.Duration);
        }
    }

    //public class CPieceComparerByLenght2 : IComparer<Piece>
    //{

    //    public int Compare(Piece x, Piece y)
    //    {
    //        return x.Rank.Lenght.CompareTo(y.Rank.Lenght);
    //    }
    //}

    public class CPieceInListComparer : IComparer<Piece>
    {

        //Public Function Compare(ByVal x As CPiece, ByVal y As CPiece) As Integer Implements System.Collections.Generic.IComparer(Of CPiece).Compare
        //    Dim val1 As Double = x.Rapport * Math.Pow(x.Duration, CDb.SortTimeProp)
        //    Dim val2 As Double = y.Rapport * Math.Pow(y.Duration, CDb.SortTimeProp)

        //    Dim l_cmp As Integer = val1.CompareTo(val2)
        //    If l_cmp <> 0 Then
        //        Return l_cmp
        //    Else
        //        Return x.Duration.CompareTo(y.Duration)
        //    End If
        //End Function
        /// <summary>
        /// Comparaison de deux fichiers en fonction du cumul des deux paramètre qualité et longueur
        /// 
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        /// <remarks>En gros on ajoute le log des classements qualité et longueur, pondérés par le coefficient sortimeProp
        /// 0 --> que la longueur prise en compte
        /// 1 --> que la qualité</remarks>
        public int Compare(Piece x, Piece y)
        {
            var val1 = CTuning.Calc(x.Rank, CConf.Sort);
            var val2 = CTuning.Calc(y.Rank, CConf.Sort);

            int l_cmp = val1.CompareTo(val2);
            if (l_cmp != 0)
            {
                return l_cmp;
            }
            else
            {
                return x.Duration.CompareTo(y.Duration);
            }

        }


    }

    public class PieceMaxClassementComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.MaxClassement.CompareTo(y.MaxClassement);
        }
    }

    public class PieceRestComparer : IComparer<Piece>
    {
        static IComparer<Piece> qual = new CPieceComparerByQualityAndLength();
        public int Compare(Piece x, Piece y)
        {
            //if ((x.Album == "A Lovaggkiraly" && x.Name == "Piste 04" && y.Album == "Only Built 4 Cuban Linx" && y.Name == "Shark Niggas (Biters)")
            //    || (y.Album == "A Lovaggkiraly" && y.Name == "Piste 04" && x.Album == "Only Built 4 Cuban Linx" && x.Name == "Shark Niggas (Biters)"))
            //{
            //    int toto = 0; 
            //}

            int cmp = x.Rank.TimeRest.CompareTo(y.Rank.TimeRest);
            if (cmp != 0)
                return cmp;

            return qual.Compare(x, y);
            //cmp = x.QRank.CompareTo(y.QRank);
            //if (cmp != 0)
            //    return cmp; 

            //return - x.LRank.CompareTo(y.LRank);

        }
    }

    public class PieceRestComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            throw new NotImplementedException();
        }
    }



    //public class PieceDeltaComparer : IComparer<Piece>
    //{

    //    public int Compare(Piece x, Piece y)
    //    {
    //        int cmp = x.Rank.Delta.CompareTo(y.Rank.Delta);
    //        if (cmp != 0)
    //            return cmp;
    //        return x.QLRank.CompareTo(y.QLRank);

    //    }
    //}

    //public class PieceSortComparer : IComparer<Piece>
    //{
    //    private static IComparer<Piece> qual = new CPieceComparerByQualityAndLength(); 
    //    public int Compare(Piece x, Piece y)
    //    {
    //        int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
    //        if (cmp != 0)
    //            return cmp;
    //        return -qual.Compare(x,y); 

    //    }
    //}


    //public class PieceClassementDisplayComparer : IComparer<Piece>
    //{
    //    private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
    //    public int Compare(Piece x, Piece y)
    //    {
    //        var xv = x.RapportClassement;
    //        var yv = y.RapportClassement;
    //        int cmp = 0;
    //        if (xv == 0m || yv == 0m)
    //            cmp = x.RapportClassement.CompareTo(y.RapportClassement);
    //        if (cmp != 0) return -cmp;
    //        cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
    //        if (cmp != 0) return -cmp;
    //        return tn.Compare(x, y);
    //        //  return -x.RapportClassement.CompareTo(y.RapportClassement);
    //    }
    //}

    public class PieceVirtualClassementComparer : IComparer<Piece>
    {
        private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {

            int cmp = x.Classement.CompareTo(y.Classement);


            if (cmp != 0) return -cmp;
            //cmp = x.RapportClassement.CompareTo(y.RapportClassement);
            //if (cmp != 0) return -cmp;
            return tn.Compare(x, y);
            //  return -x.RapportClassement.CompareTo(y.RapportClassement);
        }
    }

    public class PieceClassementComparer : IComparer<IPieceAlbum>
    {
        private bool oldAsZero;
        private pieceExtendedMode mode = pieceExtendedMode.main;
        public PieceClassementComparer(bool oldAsZero)
            : this(oldAsZero, pieceExtendedMode.main)
        {

        }

        public PieceClassementComparer(bool oldAsZero, pieceExtendedMode mode)
        {
            this.oldAsZero = oldAsZero;
            this.mode = mode;
        }
        private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
        public int Compare(IPieceAlbum x, IPieceAlbum y)
        {

            if (oldAsZero)
            {
                bool xRecent = x.LastClassementRecent;
                bool yRecent = y.LastClassementRecent;
                if (xRecent != yRecent)
                {
                    if (xRecent)
                        return -1;
                    return 1;
                }
            }
            int cmp = 0;

#if GEN2
            if (mode == pieceExtendedMode.main)
                cmp = x.Classement.CompareTo(y.Classement);
            else if (mode == pieceExtendedMode.min)
                cmp = x.Classement2.CompareTo(y.Classement2);
            else
                cmp = x.ClassementCumul.CompareTo(y.ClassementCumul);
#else

            cmp = x.Classement.CompareTo(y.Classement);
#endif

            if (cmp != 0) return -cmp;


            var xpd = x.Piece.DeepClassement;
            var ypd = y.Piece.DeepClassement;
            //1.CompareTo(3) = -1 1<3 => 1-3
            if (xpd.isPositive())
            {
                if (ypd.isPositive())
                {
                    cmp = xpd.CompareTo(ypd);
                    if (cmp != 0) return cmp;
                }
                else
                    /// dans l'ordre 0002(x) puis 0(y)
                    return -1;

            }
            else
            {
                if (ypd.isPositive())
                    /// dans l'ordre 0002(y) puis 0(x)
                    return 1;
            }

            return tn.Compare(x, y);

        }
    }

    public class PieceStackCmp : IComparer<Piece>
    {
        private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {
            int cmp = x.RankAlbumSt.CompareTo(y.RankAlbumSt);
            if (cmp != 0) return -cmp;
            return tn.Compare(x, y);
        }

    }

   
    ///// <summary>
    ///// Donne l'ordre de copie si on s'intéresse aux morceaux les moins notés
    ///// </summary>
    //public class PieceClassementComparerInv : IComparer<Piece>
    //{
    //    public int Compare(Piece x, Piece y)
    //    {
    //        //if (x.Enabled != y.Enabled)
    //        //{
    //        //    return x.Enabled ? -1 : 1;
    //        //}

    //        if (x.IsNext != y.IsNext)
    //        {
    //            if (x.IsNext)
    //                return -1;
    //            return 1; 
    //        }
    //        var xv = x.RapportClassement;
    //        var yv = y.RapportClassement;

    //        int cmp = 0;
    //        if (xv > 0 && yv > 0)
    //        {
    //            cmp = xv.CompareTo(yv);
    //            if (cmp != 0) return cmp;
    //            cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
    //            if (cmp != 0) return cmp;
    //        }

    //        cmp = x.TrackNumber.CompareTo(y.TrackNumber);
    //        if (cmp != 0)
    //            return cmp;
    //        return x.Location.CompareTo(y.Location);
    //        //  return -x.RapportClassement.CompareTo(y.RapportClassement);
    //    }
    //}

    ///// <summary>
    ///// Donne l'ordre de copie si on s'intéresse aux morceaux les moins notés et si on veut optimiser autour du Next
    ///// </summary>
    //public class PieceClassementComparerExport : IComparer<Piece>
    //{
    //    public PieceClassementComparerExport(HashList<Piece> source)
    //    {
    //        this.source = source; 
    //    }
    //    private readonly HashList<Piece> source;
    //    public int Compare(Piece x, Piece y)
    //    {
    //        return source.IndexOf(x).CompareTo(source.IndexOf(y)); 
    //    }
    //}

    public class PieceDurationValueComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.Duration.CompareTo(y.Duration);
        }
    }

    //public class PieceSortComparerList : IComparer<Piece>
    //{

    //    public int Compare(Piece x, Piece y)
    //    {
    //        return x.Rank.Sort.CompareTo(y.Rank.Sort);
    //        //int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
    //        //if (cmp != 0)
    //        //    return cmp;
    //        //return x.QLRank.CompareTo(y.QLRank);

    //    }
    //}

    public class PieceTrackNumberComparer : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            var cmp = x.TrackNumber.CompareTo(y.TrackNumber);
            if (cmp != 0)
                return cmp;
            var xpath = x.getLocation();
            var ypath = y.getLocation();
            if (x.TrackNumber <= 0)
            {
                try
                {
                    var xf = Path.GetFileNameWithoutExtension(xpath);
                    var yf = Path.GetFileNameWithoutExtension(xpath);
                    cmp = xf.CompareTo(yf);
                    if (cmp != 0)
                        return cmp;
                }
                catch
                {
                }
            }
            return xpath.CompareTo(ypath);
            //  return x.TrackNumber.CompareTo(y.TrackNumber);
        }
    }

    internal class PieceTrackNumberComparerE : IComparer<IPieceAlbum>
    {
        public int Compare(IPieceAlbum x, IPieceAlbum y)
        {
            var xx = x.Piece;
            var yy = y.Piece;
            var cmp = xx.TrackNumber.CompareTo(yy.TrackNumber);
            if (cmp != 0)
                return cmp;

            cmp = xx.MasterTrackNumber.CompareTo(yy.MasterTrackNumber);
            if (cmp != 0)
                return cmp;
            return xx.Location.CompareTo(yy.Location);

            //var xpath = xx.getLocation();
            //var ypath = yy.getLocation();
            //if (xx.TrackNumber <= 0)
            //{
            //    try
            //    {
            //        var xf = Path.GetFileNameWithoutExtension(xpath);
            //        var yf = Path.GetFileNameWithoutExtension(xpath);
            //        cmp = xf.CompareTo(yf);
            //        if (cmp != 0)
            //            return cmp;
            //    }
            //    catch
            //    {
            //    }
            //}
            //return xpath.CompareTo(ypath);


            //  return x.TrackNumber.CompareTo(y.TrackNumber);
        }
    }

    class LastModifClassementComparer : IComparer<Piece>
    {
        PieceTrackNumberComparer trackCmp = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {


            var dtx = x.UpdateClassement;
            var dty = y.UpdateClassement;
            int cmp = 0;
            if (dtx == null)
            {
                if (dty == null)
                {
                }
                else
                    cmp = -1;
            }
            else if (dty == null)
                cmp = 1;
            else
                cmp = dtx.Value.CompareTo(dty.Value);


            if (cmp != 0)
                return cmp;
            return trackCmp.Compare(x, y);
        }
    }

    class ClassementValueDecimal0Comparer : IComparer<Piece>
    {
        static PieceTrackNumberComparer trackCmp = new PieceTrackNumberComparer();
        public int Compare(Piece x, Piece y)
        {
            var cmp = x.Classement.CompareTo(y.Classement);
            if (cmp != 0)
                return cmp;
            return trackCmp.Compare(x, y);
        }
    }


}
]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using pdb.gen.conf;
using System.Xml;
using System.Text;
using System.IO;
using System.Threading;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        private const string FILE_ALBUMS = "_albums.xml";
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
            new Thread(loop) { Priority = ThreadPriority.Lowest, Name = "scan albums" }.Start();
        }

        Logger logScan = Logger.getLogger("scan albums", true);

        /// <summary>
        /// référence constante des albums
        /// </summary>
        //   private BgDictString<Album> dict0 = new BgDictString<Album>();
        /// <summary>
        /// Albums réels ou virtuels
        /// </summary>
        private BgDictString<Album> dict = new BgDictString<Album>();
        public BgDictString<Album> Dict { get { return dict; } }
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object();
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }
        private volatile object _lockSort2 = new object();
        private Album currentSorted;



        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                //foreach (Album album in dict0.Values)
                //{
                //    album.checkBuild();
                //}
                dict.Clear();
            }
        }

        private string getKey(string _album, virtualMode mode)
        {
            return Album.getKey(_album, mode);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                var confGen = CConf.ConfGen;
                var min1 = confGen.AlbumMin;
                var min2 = confGen.PathVirtualMin;
                var min3 = confGen.ArtistVirtualMin;
                foreach (Album album in new List<Album>(dict.Values))
                {
                    int count = album.Count;
                    bool toKeep = album.buildDone();
                    if (toKeep)
                    {

                        if (album.Virtual)
                        {
                            if (album.VirtualByArtist)
                            {
                                if (min3 > 1 && count < min3)
                                    toKeep = false;
                            }
                            else if (min2 > 1 && count < min2)
                                toKeep = false;
                        }
                        else if (min1 > 1 && count < min1)
                            toKeep = false;



                        if (!toKeep)
                        {
                            //album.Clear(); 
                            // misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }

                    }

                }


            }
        }



        private bool check_(Piece piece, string albumOrg, virtualMode mode, IDictionary<string, Album> dict)
        {
            string key = getKey(albumOrg, mode);


            var album = dict[key];
            if (album == null)
            {
                //album = dict0[key];
                //if (album == null)
                //{
                //  misc.log("creation album {0}", __album);
                album = new Album(albumOrg, key);
                album.setVirtual(mode);
                dict.Add(key, album);
                // dict0.Add(key, album);

            }

            //  }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualMode, dict);
        }

        public int Count { get { return dict.Count; } }
        public static int RankZero { get; set; }



        const char SEP = ';';
        const char SEP_TRACK = ',';


        public string getSortedAlbumFile()
        {
            var sb = new pdb.util.StringBuilder();
            sb.Append(TuningBase.DIR_CONF);
            var gen = CConf.ConfGen;
            if (gen.PathVirtual)
                sb.Append("Path");
            if (gen.PathVirtualE)
                sb.Append("PathE");
            if (gen.PathVirtualEW)
                sb.Append("PathEW");
            if (gen.ArtistVirtual)
                sb.Append("Artist");

            if (gen.YearVirtual)
                sb.Append("Year");
            if (gen.AddedVirtual)
                sb.Append("Added");
            if (gen.AddedVirtualSimu)
                sb.Append("AddedSimu");
            if (gen.WordVirtual)
                sb.Append("Word");
            if (gen.ListVirtual)
                sb.Append("List");
            if (gen.VirtualRoot)
                sb.Append("Root");
            sb.Append(FILE_ALBUMS);
            return sb.ToString();
        }

        public void sortVirtual()
        {
            if (!CConf.ConfGen.AlbumVirtual)
                return;
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }


            var listAlbums = new List<Album>(dict.Values);
            listAlbums.Sort(new VirtualAlbumComparerForWrite());

            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;

            //using (StreamWriter sw = new StreamWriter(FILE_ALBUMS + ".tmp"))
            //{
            //    foreach (Album album in listAlbums)
            //    {
            //        if (!album.Virtual)
            //            continue;

            //        sw.Write(album.VirtualMode);
            //        sw.Write(SEP);

            //        sw.Write(album.Name);
            //        sw.Write(SEP);

            //        var list = album.RawList;
            //        list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //        bool begin = false;
            //        foreach (Piece p in list)
            //        {
            //            if (begin)
            //                sw.Write(SEP_TRACK);
            //            else
            //                begin = true;
            //            sw.Write(p.MasterId);
            //        }
            //        sw.WriteLine();

            //    }

            //}
            var fileAlbum = getSortedAlbumFile();
            using (XmlWriter writer = XmlWriter.Create(fileAlbum + ".tmp", settings))
            {
                writer.WriteStartElement("albums");
                foreach (Album album in listAlbums)
                {
                    if (!album.Virtual)
                        continue;
                    writer.WriteStartElement("a");
                    writer.WriteAttributeString("mode", album.VirtualMode.ToString());
                    writer.WriteAttributeString("name", album.Name);
                    writer.WriteAttributeString("nb", album.Count.ToString());
                    var list = album.RawList;
                    list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
                    bool begin = false;
                    var sb = new System.Text.StringBuilder();
                    foreach (Piece p in list)
                    {
                        if (begin)
                            sb.Append(SEP_TRACK);
                        else
                            begin = true;
                        sb.Append(p.MasterId);
                    }

                    writer.WriteString(sb.ToString());

                    //foreach (Piece p in list)
                    //{
                    //    writer.WriteElementString("t", p.MasterId.ToString());
                    //}
                    writer.WriteEndElement();
                }


                writer.WriteEndDocument();
                writer.Flush();
            }

            System.IO.File.Copy(fileAlbum + ".tmp", fileAlbum, true);
            System.IO.File.Delete(fileAlbum + ".tmp");

        }

        public int load(IDictionary<int, Piece> dict)
        {

            //using (StreamReader sr = new StreamReader(FILE_ALBUMS))
            //{

            //    var line = sr.ReadLine();
            //    var tabs = line.Split(SEP);
            //    int count = tabs.GetLength(0); 

            //    var name = tabs[1];
            //    var mode = (virtualMode)Enum.Parse(typeof(virtualMode), tabs[0], true);
            //    Album current = new Album(name, mode);
            //    this.dict.Add(current.Key, current);
            //    int tn = 0;
            //    var tracks = tabs[2].Split(SEP_TRACK);
            //    foreach (string sid in tracks)
            //    {
            //        tn++;
            //        var id = Convert.ToInt32(sid);
            //        Piece track = dict[id];
            //        VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
            //        virt.TrackNumber = tn;
            //        current.add(virt);
            //    }


            //}
            int nbLoad = 0;
            var fileAlbum = getSortedAlbumFile();
            using (XmlReader reader = XmlReader.Create(fileAlbum))
            {
                Album current = null;

                while (reader.Read())
                {
                    if (reader.NodeType == XmlNodeType.Element)
                    {

                        if (reader.Name == "a")
                        {
                            var name = reader.GetAttribute("name");
                            var mode = (virtualMode)Enum.Parse(typeof(virtualMode), reader.GetAttribute("mode"), true);
                            current = new Album(name, mode);
                            int tn = 0;
                            this.dict.Add(current.Key, current);


                            var line = reader.ReadElementString();
                            foreach (string sid in line.Split(SEP_TRACK))
                            {
                                tn++;
                                var id = Convert.ToInt32(sid);
                                Piece track = dict[id];
                                var virt = new VirtualAlbumPieceLight(track.Track, track);
                                // VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
                                virt.TrackNumber = tn;
                                current.add(virt);
                            }

                            nbLoad++;

                        }



                        //else if (reader.Name == "t")
                        //{
                        //    tn++;
                        //    var id = reader.ReadElementContentAsInt();
                        //    Piece track = dict[id];
                        //    VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
                        //    virt.TrackNumber = tn;
                        //    current.add(virt);

                        //}

                    }
                }

            }
            return nbLoad;
        }

        //public void consolidChilds()
        //{
        //    misc.log("consolidChilds");
        //    foreach (Album album in dict.Values)
        //    {
        //        album.ConsolidChilds();
        //    }
        //}

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {
            if (piece.Virtual)
            {
                if (!check_(piece, dict))
                {
                }
                // piece.setParent(null);
            }

        }

        public Album getAlbum(Piece piece)
        {
            return piece.PieceAlbum;
            //string __album = "-";
            //var _album = piece.Album;
            //if (!string.IsNullOrEmpty(_album))
            //{
            //    __album = _album.Trim();
            //    return dict[__album];
            //}
            //return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            var now = DateTime.Now;
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
            misc.log("buildStack; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
        }

        // private Dictionary<string, Album> invalidated;
        public IDictionary<string, Album> GetAndInvalidateAlbums(Piece piece)
        {
            var invalidated = new Dictionary<string, Album>();
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;

                album.refreshLight();
                if (invalidated.ContainsKey(album.Key))
                { }
                else
                    invalidated.Add(album.Key, album);
            }
            return invalidated;
        }

        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public int makeSort(Piece piece, ILogger logger)
        {
            if (piece == null)
                return 0;
            int nb = 0;
            //var album = piece.PieceAlbum;
            //if (album == null)
            //    return;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;
                goParallel = false;
                while (currentSorted == album)
                    Thread.Sleep(30);
                lock (album)
                {
                    album.refreshLight();
                    album.makeSort(confMedianne, conf0, logger, 0); //listRef, reference);                
                    nb++;
                    //  album.mustRefresh();
                    // pour futures mises au point avec la MAJ des classements( resetOneCl et Compact )
                    album.refreshLight();
                }
            }

            return nb;

        }

        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public int makeSort(IEnumerable<Album> _albums, ILogger logger)
        {
            int nb = 0;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Album album in _albums)
            {
                if (album == null)
                    continue;

                goParallel = false;
                while (currentSorted == album)
                    Thread.Sleep(30);
                lock (album)
                {
                    album.refreshLight();

                    album.makeSort(confMedianne, conf0, logger, 0); //listRef, reference); 
                }

                nb++;
                //  album.mustRefresh();
                // pour futures mises au point avec la MAJ des classements( resetOneCl et Compact )
                // album.refreshLight();
            }

            foreach (Album album in _albums)
            {
                if (album == null)
                    continue;
                album.refreshLight();
            }

            return nb;

        }

        // private int nbSort=1;
        //private bool urgence;
        //public void setUrgence() { urgence = true; }
        //public bool Urgence { get { return urgence; } } 
        public void makeSort(bool sortAll, IClient client, ILogger logger)
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var main = confMedianne.Main;
                var min = confMedianne.Min;
                var mainCoeffVirt = main.coeffVirt;
                var mainCoeffOld = main.CoeffOld;

                var minCoeffVirt = min.coeffVirt;
                var minCoeffOld = min.CoeffOld;




                if (confSort.reset)
                {
                    main.coeffVirt = 1;
                    main.CoeffOld = 1;
                    min.coeffVirt = 1;
                    min.CoeffOld = 1;
                }

                List<Album> list = new List<Album>(dict.Values);
                List<Album> listw = list;
                HashSet<Album> hs = null;
                DateTime now = DateTime.Now;
                DateTime debut = now;

                bool partial = false;
#if GEN2
                partial = !sortAll && confSort.optimSize > 0 && consolid.Urgence;
#endif

                int step = 0;
                Album last = null;
                // int coeffSort = 1;

                while (true)
                {
                    step++;

                    if (partial)
                    {
                        //nbSort++;
                        //coeffSort = 1; 

                        //int _nbSort = nbSort;
                        //while (_nbSort >=2 && _nbSort % 2 == 0)
                        //{
                        //    coeffSort *= 2;
                        //    _nbSort /= 2; 
                        //}
                        hs = new HashSet<Album>();
                        list.Sort(new AlbumClassComparer2());
                        list.Reverse();
                        listw = new List<Album>();
                        decimal equivLightMax = 0;
                        decimal equivLightZeroMax = 0;
                        int nb = 0;
                        int max = step * confSort.optimSize; // *coeffSort;

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                nb++;
                                listw.Add(a);
                                hs.Add(a);

                                var _classementValueLight = a.ClassementValueLight;
                                if (_classementValueLight > equivLightMax)
                                {
                                    equivLightMax = _classementValueLight;
                                    last = a;
                                }

                                var _classementValueLightZero = a.ClassementValueLightZero;

                                if (_classementValueLightZero > equivLightZeroMax)
                                {
                                    equivLightZeroMax = _classementValueLightZero;
                                    last = a;
                                }

                                if (nb >= max)
                                    break;
                            }
                        }


                        var equivZeroVerif = equivLightZeroMax * pdb.util.Math.Pow(main.coeffVirt, main.safe) * pdb.util.Math.Pow(min.coeffVirt, min.safe) * main.CoeffOld * min.CoeffOld;
                        var dxMin = min.dcoeff;
                        var dxMain = pdb.util.Math.Pow(main.dcoeff, main.safe);
                        var equivVerif = equivLightMax * (dxMain * dxMin);

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                var _classementValueLight = a.ClassementValueLight;


                                if (_classementValueLight < equivVerif && _classementValueLight < equivZeroVerif)
                                {
                                    if (hs.Add(a))
                                    {
                                        listw.Add(a);
                                        if (_classementValueLight > equivLightMax)
                                        {
                                            equivLightMax = _classementValueLight;
                                            last = a;
                                        }

                                    }
                                }

                            }
                        }

                    }
                    if (!consolid.Urgence)
                    {
                        int nbSorted = 0;
                        //if (invalidated != null && invalidated.Count > 0)
                        //{
                        //    listw = new List<Album>(invalidated.Values);
                        //    invalidated = null;
                        //}
                        listw.Sort((x, y) => x.Count.CompareTo(y.Count));
                        foreach (Album album in listw)
                        {
                            if (client.Cancel)
                                return;

                            goParallel = false;
                            while (currentSorted == album)
                                Thread.Sleep(30);

                            if (album.makeSort(confMedianne, conf0, logger, 100)) //listRef, reference); 
                                nbSorted++;

                        }

                        string infoAlbum = "";
                        if (last != null)
                        {
                            infoAlbum = string.Format("last={0} {1} {2} {3}", last.Tracks[0].RankAlbumReverse, last.EquivLight0, last.EquivLight, last);
                        }
                        //   misc.log(string.Format("makeSort : nbSort={0} coeffSort={1} step={2}  {3} albums {4} ms {5}", nbSort, coeffSort, step, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        misc.log(string.Format("makeSort : step={0}  {1}/{2} albums {3} ms {4}", step, nbSorted, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        client.log(string.Format("album.makeSort {0} elt", nbSorted));
                    }
                    now = DateTime.Now;
                    //if (confSort.reset)
                    //{
                    main.coeffVirt = mainCoeffVirt;
                    main.CoeffOld = mainCoeffOld;
                    min.coeffVirt = minCoeffVirt;
                    min.CoeffOld = minCoeffOld;

                    // }


                    list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                    misc.log("list.Sort(new AlbumClassComparer {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


                    list.Reverse();
                    misc.log("list.Reverse(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    client.log("AlbumClassComparer");

                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (album.AtLeastOneEnabled)
                            RankZero = i + 2;
                        album.Quality = i + 1;
                    }
                    client.log("album.Quality");
                    misc.log("album.Quality {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    if (!partial)
                        break;


                    list.Reverse();

                    int nbCheck = 0;
                    bool? check = null;
                    foreach (Album a in list)
                    {
                        if (!a.AtLeastOneEnabled)
                            continue;
                        if (hs.Contains(a))
                        {
                            nbCheck++;
                            if (nbCheck >= confSort.optimCheck) // * coeffSort)
                            {
                                check = true;
                                break;
                            }
                        }
                        else
                        {
                            check = false;
                            break;
                        }


                    }

                    if (check == null || check.Value)
                        break;

                }


                misc.log(string.Format("makeSort albums total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));

                List<Album> listSt = null;
                List<Album> list0 = null;
                List<Album> listSt0 = null;


                if (confSort.sortSt || confSort.correcMainRank || confSort.correcMainCoeff || confSort.correcMainZero)
                {
                    listSt = new List<Album>(list);

                    listSt.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                    listSt.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        listSt[i].RankSt = i + 1;
                    }
                    misc.log(string.Format("sort St : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sort0)
                {
                    now = DateTime.Now;
                    list0 = new List<Album>(list);

                    list0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                    list0.Reverse();
                    for (int i = 0; i < list0.Count; i++)
                    {
                        list0[i].RankZero = i + 1;
                    }
                    misc.log(string.Format("sort 0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sortSt0 || confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    listSt0 = new List<Album>(list);

                    listSt0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, conf0));
                    listSt0.Reverse();
                    for (int i = 0; i < listSt0.Count; i++)
                    {
                        listSt0[i].RankZeroSt = i + 1;
                    }
                    misc.log(string.Format("sort St0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                client.log("tri pour faire joli");
#if GEN2
                if (confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;

                                if (o.RankZero > un.RankZero)
                                {
                                    correc = false;
                                    break;
                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }
                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }



                    //now = DateTime.Now;
                    //for (int i = listSt.Count - 1; i >= 0; i--)
                    //{
                    //    Album un = listSt[i];
                    //    Album zero = listSt0[i];
                    //    if (un.DontTouchSelectedCoeff)
                    //        continue;
                    //    if (un == zero)
                    //        un.InvalidateMain();
                    //}
                    misc.log(string.Format("correcMainRank : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainCoeff)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLightSt * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLightSt;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }
                    misc.log(string.Format("correcMainCoeff : {0} ms", (DateTime.Now - now).TotalMilliseconds));

                }
                if (confSort.correcMainZero)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {




                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                if (o.Name == "Ill Communication")
                                {
                                }
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;


                                if (o.ClassementValueLightZeroSt < un.ClassementValueLightZeroSt)
                                {
                                    if (o.RankZero > un.RankZero)
                                    {
                                        correc = false;
                                        break;
                                    }
                                }

                                if (!unClassementRecent)
                                {
                                    if (o.ClassementValueLightZeroSt == un.ClassementValueLightZeroSt)
                                    {
                                        if (confSort.correcMainZeroCheckEquality)
                                        {
                                            if (onext.LastClassementRecent)
                                            {
                                                if (o.RankZero > un.RankZero)
                                                {
                                                    correc = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }


                                //if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //    break;
                                // }



                                //if (o.RankSt <= un.RankSt)
                                //{
                                //    if (o.RankZeroSt > un.RankZeroSt)
                                //    {
                                //        correc = false;
                                //        break;
                                //    }

                                //    if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //        break;
                                //}

                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }


                    misc.log(string.Format("correcMainZero : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

#endif


                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}
                var limit = CConf.ConfGen.LimitAlbums;
                if (limit > 0)
                {
                    var l = new List<Album>();
                    list.Sort(new AlbumClassComparer2());
                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (i < limit)
                        {
                            l.Add(album);
                            album.ConsolidChilds();
                            album.sortVirtual();
                        }
                        else
                        {
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }
                    }
                    list = l;

                }

                misc.log(string.Format("makeSort total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var now = DateTime.Now;
            var list = new List<Album>(dict.Values);

            //var confGen = CConf.ConfGen;
            //var min1 = confGen.AlbumMin;
            //var min2 = confGen.PathVirtualMin;
            //var min3 = confGen.AristVirtualMin;
            //foreach (Album album in dict.Values)
            //{
            //    int count = album.Count;
            //    bool toKeep = true;


            //    if (album.Virtual)
            //    {
            //        if (album.VirtualByArtist)
            //        {
            //            if (min3 > 1 && count < min3)
            //                toKeep = false;
            //        }
            //        else if (min2 > 1 && count < min2)
            //            toKeep = false;
            //    }
            //    else if (min1 > 1 && count < min1)
            //        toKeep = false;



            //    if (!toKeep)
            //    {
            //        misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
            //    }
            //    else
            //        list.Add(album);

            //}

            foreach (Album album in list)
            {
                album.makeSelection();
            }
            //list.Sort(new AlbumRestComparer());
            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankRest = i + 1;
            //}

            misc.log(string.Format("make selection : {0} ms", (DateTime.Now - now).TotalMilliseconds));
            return list;
        }

        //public void changeAlbum(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Album, false)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();
        //    check_(p, newA, false, this.dict);
        //    var newAlb = dict[getKey(newA, false)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();

        //    //  invalidate(p); 
        //}

        //public void changeArtist(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Artist, true)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();

        //    check_(p, newA, true, this.dict);
        //    var newAlb = dict[getKey(newA, true)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();
        //}

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                //if (candidat.VirtualMode == virtualMode.added)
                //{
                //    if (candidat.Name=="09/1012")
                //    {

                //    }
                //    if (candidat.Name =="22/09/2012")
                //    {

                //    }
                //}
                bool found = false;

                foreach (Piece p in candidat)
                {
                    var master = p.Master.PieceAlbum;
                    if (master.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    foreach (Album album in dict.Values)
                    {
                        if (album.isSameOf(candidat))
                        {
                            found = true;
                            break;
                        }
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.ClearAndMenage();
                }
                else
                {
                    // on le prend.
                    string key = getKey(candidat.Name, candidat.VirtualMode);
                    //if (!dict0.ContainsKey(key))
                    //    dict0.Add(key, candidat);
                    dict.Add(key, candidat);
                    foreach (Piece p in candidat)
                    {
                        //   p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }


        public List<Album> RawList
        {
            get
            {
                return new List<Album>(dict.Values);
            }
        }

        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(Piece track)
        {
            track.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track);

        }


        private bool goParallel;
        public void parallelSort()
        {
            goParallel = true;
        }
        public void endParallelSort()
        {
            goParallel = false;
        }
        private void loop()
        {
            while (true)
            {

                currentSorted = null;
                Thread.Sleep(3000);
                if (!goParallel)
                    continue;
                var list = new List<Album>(dict.Values);
                if (!goParallel)
                {
                    logScan.log("arret list = new List<Album>(dict.Values) ");
                    continue;
                }
                list.Sort((x, y) => (x.MajDate.CompareTo(y.MajDate)));
                if (!goParallel)
                {
                    logScan.log("arret list.Sort((x, y) => (x.MajDate.CompareTo(y.MajDate)));");
                    continue;
                }
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }
                var conf0 = new ConfMedianne(confMedianne, true);
                if (!goParallel)
                {
                    logScan.log("arret confMedianne;");
                    continue;
                }


                foreach (Album album in list)
                {
                    if (!goParallel)
                    {
                        logScan.log("arret avant album " + album);
                        break;
                    }

                    lock (album)
                    {
                        if (!goParallel)
                        {
                            logScan.log("arret sur lock album " + album);
                            break;
                        }
                        currentSorted = album;
                        album.mustRefresh();
                        album.makeSort(confMedianne, conf0, logScan, 100);
                    }
                }
                if (goParallel)
                {
                    logScan.log("fin sans interruption");
                    goParallel = false;
                }
            }
        }

        #region invalider


        public void invalidateAll(bool total)
        {
            foreach (var a in dict.Values)
            {
                if (total)
                    a.mustRefresh();
                else
                    a.refreshLight();
            }
        }
        //public void invalidate(Piece piece)
        //{
        //    foreach (var p in piece.Master)
        //    {
        //        var key = getKey(p.Album, p.VirtualByArtist);
        //        var a = dict[key];
        //        if (a == null)
        //        {
        //        }
        //        else
        //            a.invalidate();
        //        //if (p.Virtual)
        //        //    continue; 
        //        ////1. check standard
        //        //var key = getKey(p.Album, false);
        //        //var a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 
        //        ////2. check artiste
        //        //key = getKey(p.Artist, true);
        //        //a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 

        //        ////3. check paths
        //        //foreach (string path in p.getIntermediaryPath())
        //        //{
        //        //    key = getKey(path, false);
        //        //    a = dict[key];
        //        //    if (a == null)
        //        //    {
        //        //    }
        //        //    else
        //        //        a.invalidate(); 
        //        //}
        //    }
        //}
        #endregion





    }
}
]]></content>
  </file>
</db>
