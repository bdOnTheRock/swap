<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\pdb.player.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{4166FA60-B33F-4496-9352-EDD8F3214021}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.player</RootNamespace>
    <AssemblyName>pdb.player</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;NONI</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>pdb.player.App</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.AXVLC, Version=1.0.0.0, Culture=neutral, processorArchitecture=x86">
      <SpecificVersion>False</SpecificVersion>
      <EmbedInteropTypes>False</EmbedInteropTypes>
      <HintPath>bin\Interop.AXVLC.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="Xceed.Wpf.Toolkit">
      <HintPath>libs\Extended WPF Toolkit Binaries\Xceed.Wpf.Toolkit.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="model\Equalization.cs" />
    <Compile Include="ViewModel\AllTracksViewModel.cs" />
    <Compile Include="ViewModel\BibViewModel.cs" />
    <Compile Include="ViewModel\BibViewModelBase.cs" />
    <Compile Include="ViewModel\Colors\ColorViewModel.cs" />
    <Compile Include="ViewModel\Colors\Couleurs.cs" />
    <Compile Include="ViewModel\Colors\MementoColor.cs" />
    <Compile Include="ViewModel\Commande\CommandeBase.cs" />
    <Compile Include="ViewModel\Commande\CoulHistoryBack.cs" />
    <Compile Include="ViewModel\Commande\CreateListCmd.cs" />
    <Compile Include="ViewModel\Commande\DeleteCmd.cs" />
    <Compile Include="ViewModel\Commande\ImportCmd.cs" />
    <Compile Include="ViewModel\Commande\InfoCmd.cs" />
    <Compile Include="ViewModel\Commande\Link\LinkRegister.cs" />
    <Compile Include="ViewModel\Commande\Link\RecordFather.cs" />
    <Compile Include="ViewModel\Commande\Play.cs" />
    <Compile Include="ViewModel\Commande\PlayList\AddToList.cs" />
    <Compile Include="ViewModel\Commande\PlayList\CheckCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastClassement.cs" />
    <Compile Include="ViewModel\Commande\PlayList\DbDeleteLastRead.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCompress.cs" />
    <Compile Include="ViewModel\Commande\PlayList\PlayListCommande.cs" />
    <Compile Include="ViewModel\Commande\RecordClassement.cs" />
    <Compile Include="ViewModel\DetailAlbumViewModel.cs" />
    <Compile Include="ViewModel\DetailClassementViewModel.cs" />
    <Compile Include="ViewModel\gen\ListWriter.cs" />
    <Compile Include="ViewModel\InfoViewModel.cs" />
    <Compile Include="ViewModel\Interfaces.cs" />
    <Compile Include="ViewModel\PieceViewModel.cs" />
    <Compile Include="ViewModel\PlayerViewModel.cs" />
    <Compile Include="ViewModel\StatItemViewModel.cs" />
    <Compile Include="ViewModel\TrackListViewModel.cs" />
    <Compile Include="ViewModel\PlayListViewModel.cs" />
    <Compile Include="ViewModel\ViewModelBase.cs" />
    <Compile Include="Vue\Adorn\AdornedControl.cs" />
    <Compile Include="Vue\Adorn\AdornerPlacement.cs" />
    <Compile Include="Vue\Adorn\FrameworkElementAdorner.cs" />
    <Compile Include="Vue\AlbumCtl.xaml.cs">
      <DependentUpon>AlbumCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BarAdorner.cs" />
    <Compile Include="Vue\BibCtl.xaml.cs">
      <DependentUpon>BibCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BrowsePlayList.xaml.cs">
      <DependentUpon>BrowsePlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ClassementCtl.xaml.cs">
      <DependentUpon>ClassementCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfAlbumSortW.xaml.cs">
      <DependentUpon>ConfAlbumSortW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfExport.xaml.cs">
      <DependentUpon>ConfExport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfFilterW.xaml.cs">
      <DependentUpon>ConfFilterW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfImport.xaml.cs">
      <DependentUpon>ConfImport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfMedianneW.xaml.cs">
      <DependentUpon>ConfMedianneW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Conf\ConfVirt.xaml.cs">
      <DependentUpon>ConfVirt.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfCouleurs.xaml.cs">
      <DependentUpon>ConfCouleurs.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\DataGridPlayList.xaml.cs">
      <DependentUpon>DataGridPlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\EnhancedDataGrid.cs" />
    <Compile Include="Vue\FolderBrowserDialog.xaml.cs">
      <DependentUpon>FolderBrowserDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialogW.xaml.cs">
      <DependentUpon>FolderBrowserDialogW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\getNb.xaml.cs">
      <DependentUpon>getNb.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Info.xaml.cs">
      <DependentUpon>Info.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Memento.cs" />
    <Compile Include="Vue\PlayerControler.xaml.cs">
      <DependentUpon>PlayerControler.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\RoutedCommandWrapper.cs" />
    <Compile Include="Vue\StatCtl.xaml.cs">
      <DependentUpon>StatCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StateBar.xaml.cs">
      <DependentUpon>StateBar.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StringDialog.xaml.cs">
      <DependentUpon>StringDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Util\BaseConverter.cs" />
    <Compile Include="Vue\Util\GradiantBuilder.cs" />
    <Compile Include="Vue\Util\StringFormatConverter.cs" />
    <Compile Include="Vue\Util\Utils.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Player.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Player.xaml.cs">
      <DependentUpon>Player.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="Vue\AlbumCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BibCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BrowsePlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ClassementCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfAlbumSortW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfExport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfFilterW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfImport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfMedianneW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\Conf\ConfVirt.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfCouleurs.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\DataGridPlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialogW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\getNb.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Vue\Info.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\PlayerControler.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StatCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StateBar.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StringDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="app.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <AppDesigner Include="Properties\" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\engine\pdb.player.engine.build\pdb.player.engine.build.csproj">
      <Project>{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}</Project>
      <Name>pdb.player.engine.build</Name>
    </ProjectReference>
    <ProjectReference Include="..\engine\pdb.player.engine\pdb.player.engine.csproj">
      <Project>{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}</Project>
      <Name>pdb.player.engine</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823d1d-851c-456b-ac4c-b0beec173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{c2b34ca9-3bb2-464f-8691-5f5b7cb2b997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Consolid\pdb.gen.csproj">
      <Project>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</Project>
      <Name>pdb.gen</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Db\pdb.db.csproj">
      <Project>{43D27B47-E615-451D-AD25-67C5B8447C4A}</Project>
      <Name>pdb.db</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\Toolbar-MP3-Forward-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Pause-icon.png" />
    <Resource Include="Vue\images\Toolbar-MP3-Play-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Rewind-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Stop-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel.Commande;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Data;
using System.Windows.Input;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.util;
using System.Collections;
using pdb.gen.conf;
using pdb.gen.albums;
using pdb.gen.Tuning;
using pdb.gen;
using System.Windows.Threading;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg;
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg;
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(int index)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }



    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object();
        private ConfAlbumSort confAlbumSort;
        public ConfAlbumSort ConfAlbumSort { get { return confAlbumSort; } set { confAlbumSort = value; } }
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel();
                    }
                }
                return _instance;
            }
        }

        public ConfFilter ConfFilter { get { return FilterTask.conf; } }
        private IPlayerEngine player = PlayerBuilder.create("vlcplugin");

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        public static event EventHandler autoChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        // private bool sortByAlbum = true;
        private bool withVirtualAlbum = CConf.ConfGen.AlbumVirtual;
        private bool withArtistVirtual = CConf.ConfGen.ArtistVirtual;
        private bool navAuto = CConf.ConfGen.NavAuto;
        public bool NavAuto
        {
            get { return navAuto; }
            set
            {
                if (value != navAuto)
                {
                    navAuto = value;
                    OnPropertyChanged("NavAuto");
                }
            }
        }
        ItrackProvider _real;
        private Logger log;
        public static IPlayerEngine Player { get { return Instance.player; } }


        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }
        private bool createRot = true;
        public bool CreateRot
        {
            get
            {
                return createRot;
            }
            set
            {
                if (value != createRot)
                {
                    createRot = value;
                    OnPropertyChanged("CreateRot");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return confAlbumSort.Enabled;
            }
        }
        //private albumSortMode sortAlbumMode;
        //public albumSortMode SortAlbumMode
        //{
        //    get { return sortAlbumMode; }
        //    set
        //    {
        //        if (value != sortAlbumMode)
        //        {
        //            sortAlbumMode = value;
        //            OnPropertyChanged("SortAlbumMode");
        //            App.go();
        //        }
        //    }
        //}

        public bool WithVirtualAlbum
        {
            get { return withVirtualAlbum; }
            set
            {
                if (value != withVirtualAlbum)
                {
                    withVirtualAlbum = value;
                    OnPropertyChanged("WithVirtualAlbum");
                    App.go();
                }
            }
        }

        public bool WithVirtualArtist
        {
            get { return withArtistVirtual; }
            set
            {
                if (value != withArtistVirtual)
                {
                    withArtistVirtual = value;
                    OnPropertyChanged("WithVirtualArtist");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            player.mediaEndReached += player_mediaEndReached;
            player.Volume = volume;
            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume();
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }

        public void checkNavIni()
        {
            if (!navAuto)
                return;

            var tracks = PresentationTracks;
            bool foundFirst = false;
            TrackListViewModel f = null;

            foreach (TrackListViewModel t in tracks)
            {
                if (t.Index == 1)
                {
                    foundFirst = true;
                }
                if (foundFirst && t.PieceGen.IsNext)
                {
                    f = t;
                    break;
                }
            }

            if (f == null)
                return;

            tracks.MoveCurrentTo(f);
            focus(tracks.CurrentPosition);

        }

        public void forward()
        {
            if (!navAuto)
                movetoNext(true);
            else
            {
                var t = TrackListViewModel.HumanSelected;
                if (t != null)
                {
                    t.refresh();
                    //  var g = t.Grouping; 
                }

                var pl = PlayListViewModel.SelectedPlayList;
                if (pl == null)
                {
                    movetoNext(true);
                    return;
                }

                string _album = "";
                if (currentTrack != null)
                    _album = currentTrack.Album;
                movetoNext(true); // des fois le morceaux affiché n'est pas celui joué. Dommage...
                if (currentTrack != null && currentTrack.Album == _album)
                {
                    if (state == playerstate.play)
                        play(false, true);
                    return;
                }

                if (currentTrack == null)
                    return;
                var album = App.gen.Albums.getAlbum(CurrentTrack.Track);
                var tracks = album.Tracks;
                //    tracks.Sort(new PieceClassementComparer());
                //  decimal val = int.MaxValue;
                int i = 0;
                TrackListViewModel choose = null;
                if (confAlbumSort.ComposantsUtiles[0].cmpMin > modeMin.non)
                {
                    var next = album.Next;
                    if (next != null)
                        choose = pl.FindTrack(next.PieceId);
                }
                else
                {
                    for (i = 0; i < tracks.Count; i++)
                    {
                        var item = tracks[i];
                        if (item != null && (!onlyEnabled || item.Enabled))
                        {
                            var tl = pl.FindTrack(item.PieceId);
                            if (!tl.Exists)
                                continue;
                            choose = tl;

                            //val = v;
                            // choose = tl;
                            if (item.VirtualClassement == 0m)
                            {
                                break;
                                //if (confAlbumSort.ComposantsUtiles[0].cmpMin != modeMin.toujours)
                                //    choose = tl;
                                //break;
                            }
                            // choose = tl;
                        }
                    }
                }

                if (choose != null)
                {
                    //var p = choose.PieceGen;
                    //if (p != null)
                    //   confAlbumSort.auto(p.AutoCoeff1, p.AutoCoeff2); 
                    reset(provider, choose, state == playerstate.play);

                }

            }
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext(bool autoPlay)
        {
            move(true, autoPlay);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext, bool autoPlay)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {


                if (currentTrack != null)
                    tracks.MoveCurrentTo(currentTrack);
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    focus(tracks.CurrentPosition);
                    if (playing && autoPlay)
                    {
                        player.play(item.Location, true);
                    }
                }

            }
        }


        private void movetoPrevious()
        {
            move(false, true);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                                break;
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

                focus(tracks.CurrentPosition);

                State = playerstate.play;
                //item.Playing = true;
                player.play(currentTrack.Location, reload);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            player.stop();

        }

        private void next()
        {
            if (navAuto)
                forward();
            else
                movetoNext(true);
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }
        private void focus(int index)
        {
            if (provider == null)
                return;
            provider.Focus(index);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = player.Elapsed;
                this.Length = player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    var sb = new System.Text.StringBuilder();
                    sb.Append(currentTrack.Artist);
                    sb.Append(" - ");
                    sb.Append(currentTrack.Album);
                    if (currentTrack.PieceGen != null)
                    {
                        if (currentTrack.PieceGen.Virtual)
                        {
                            sb.Append(" (");
                            sb.Append(currentTrack.PieceGen.Master.Album);
                            sb.Append(")");
                        }
                    }
                    CurrentAuthorAlbum = sb.ToString();
                    if (currentTrack.Exists)
                        currentTrack.Duration = length;

                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            reset(provider, track, true);
        }

        public static void makeauto(TrackListViewModel current)
        {
            if (current != null)
            {
                var p = current.PieceGen;
                if (p != null)
                {
                    Instance.confAlbumSort.auto(p);
                    if (autoChange != null)
                        autoChange(current, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track, bool autoPlay)
        {
            if (provider != null)
            {
                Instance.provider = provider;
                Instance.currentPl = provider.PlayList;
                Instance.provider = provider;
                Instance.tracks = provider.PresentationTracks;

            }
            Instance._positionstate = positionstate.free;






            Instance.CurrentTrack = track;
            if (autoPlay)
                Instance.play(true, true);
            Instance.makeResume();
            App.go();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            tracks.MoveCurrentTo(TrackListViewModel.CurrentPlaying);
                            provider.Focus(tracks.CurrentPosition);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
        //  private class filterTask
        //  {
        //      public filterTask()
        //      {
        //      }
        //      public string filter;
        //      //public string waitingFilter; 
        //      //private bool cancel; 
        //      //private Thread th;
        //      public Predicate<object> Filter;
        //      //public ICollectionView coll;
        //      //private bool busy;

        //      public void go()
        //      {

        //          if (!string.IsNullOrEmpty(filter))
        //              filter = filter.Trim().ToLower().removeAccent();

        //          var tab = filter.Split(' ');
        //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
        //          lock (this)
        //              busy = true;
        //          coll.Filter = item =>
        //          {
        //              TrackListViewModel vitem = item as TrackListViewModel;
        //              if (vitem == null) return false;

        //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //              //    return vitem.Classement.StartsWith(filter);
        //              bool ok = true;
        //              var name = vitem.Name.Trim().ToLower().removeAccent();
        //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //              var album = vitem.Album.Trim().ToLower().removeAccent();
        //              var classement = vitem.Classement;
        //              foreach (string str in tab)
        //              {
        //                  if (!ok)
        //                      return false;
        //                  if (string.IsNullOrEmpty(str))
        //                      continue;
        //                  var str_ = str.Trim();
        //                  if (str_ == string.Empty)
        //                      continue;

        //                  ok = name.Contains(str_)
        //                      || artist.Contains(str_)
        //                      || album.Contains(str_)
        //                      || classement.StartsWith(str_);

        //              }

        //              return ok;

        //          };

        //          lock (this)
        //              busy = true;

        //      }
        //      private void getItems()
        //      {
        //          try
        //          {
        //              if (!string.IsNullOrEmpty(filter))
        //                  filter = filter.Trim().ToLower().removeAccent();
        //              if (cancel)
        //                  return;
        //              var tab = filter.Split(' ');
        //              if (cancel)
        //                  return;
        //              Filter = item =>
        //              {
        //                  TrackListViewModel vitem = item as TrackListViewModel;
        //                  if (vitem == null) return false;

        //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //                  //    return vitem.Classement.StartsWith(filter);
        //                  bool ok = true;
        //                  var name = vitem.Name.Trim().ToLower().removeAccent();
        //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //                  var album = vitem.Album.Trim().ToLower().removeAccent();
        //                  var classement = vitem.Classement;
        //                  foreach (string str in tab)
        //                  {
        //                      if (!ok)
        //                          return false;
        //                      if (string.IsNullOrEmpty(str))
        //                          continue;
        //                      var str_ = str.Trim();
        //                      if (str_ == string.Empty)
        //                          continue;

        //                      ok = name.Contains(str_)
        //                          || artist.Contains(str_)
        //                          || album.Contains(str_)
        //                          || classement.StartsWith(str_);

        //                  }

        //                  return ok;

        //              };
        //          }
        //          catch (Exception ex)
        //          {
        //              App.log.log(ex.ToString()); 
        //          }
        //      }
        //  }
        ////  private static filterTask filtertask = new filterTask(); 
        private static IDisposable work;
        private static FilterTask filterTask = null;

        private static bool cancel;
        public static void doFilter0(ICollectionView coll, string filter)
        {

            ILogger log = App.log;
            log.log("filter=>{0}", filter);
            lock (_lock)
            {
                if (work == null)
                {
                    log.log("filter=>{0} verrou libre", filter);
                    work = coll.DeferRefresh();
                }
                else
                {
                    log.log("filter=>{0} verrou pris, abandon tâche en cours", filter);
                    cancel = true;
                }
            }

            var _cancel = cancel;
            if (_cancel)
                log.log("filter=>{0} verrou pris, attente fin tâche en cours", filter);
            while (cancel)
                Thread.Sleep(30);

            if (_cancel)
                log.log("filter=>{0} verrou pris, fin d'attente fin tâche en cours", filter);

            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 


            _cancel = cancel;
            if (!_cancel)
            {
                lock (_lock)
                    _cancel = cancel;
            }

            if (!_cancel)
            {
                log.log("filter=>{0} lancement filtre", filter);
                coll.Filter = item =>
                {
                    if (cancel)
                        return false;
                    TrackListViewModel vitem = item as TrackListViewModel;
                    if (vitem == null) return false;



                    //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                    //    return vitem.Classement.StartsWith(filter);
                    bool ok = true;
                    var name = vitem.Name.Trim().ToLower().removeAccent();
                    var artist = vitem.Artist.Trim().ToLower().removeAccent();
                    var album = vitem.Album.Trim().ToLower().removeAccent();
                    var classement = vitem.Classement;
                    foreach (string str in tab)
                    {
                        if (!ok)
                            return false;
                        if (string.IsNullOrEmpty(str))
                            continue;
                        var str_ = str.Trim();
                        if (str_ == string.Empty)
                            continue;

                        ok = name.Contains(str_)
                            || artist.Contains(str_)
                            || album.Contains(str_)
                            || classement.StartsWith(str_);

                    }

                    return ok;

                };

                if (cancel)
                    log.log("filter=>{0} la tâche a été interrompue", filter);
            }
            else
            {
                log.log("filter=>{0} finalement pas de lancement", filter);
            }
            lock (_lock)
            {
                if (!cancel)
                {
                    if (work != null)
                    {
                        log.log("filter=>{0} application du filtre", filter);
                        work.Dispose();
                    }
                    else
                    {
                        log.log("filter=>{0} ben pourquoa le work était null ????", filter);
                    }
                    work = null;

                }
            }

            lock (_lock)
                cancel = false;

            log.log("filter=>{0} fin", filter);
        }




        private class FilterTask
        {
            public static ConfFilter conf = new ConfFilter();
            private ICollectionView coll;
            public readonly string filter0;

            private string filter;
            private bool _cancel;
            private bool end;
            private Thread th;
            SimpleChrono log;
            public string step;
            private HashSet<int> l = new HashSet<int>();
            public FilterTask(string filter, ICollectionView coll, SimpleChrono log)
            {
                this.filter0 = filter;
                this.filter = filter;


                this.coll = coll;
                this.log = log;
                step = "ini";
                th = new Thread(calc);
                th.Start();
            }

            public void cancel()
            {
                lock (_lock)
                    _cancel = true;
            }

            public bool End { get { return end; } }
            public bool Cancel { get { return _cancel; } }

            private void calc()
            {
                step = "calc";
                try
                {
                    if (!string.IsNullOrEmpty(filter))
                        filter = filter.Trim().ToLower().removeAccent();
                    if (string.IsNullOrWhiteSpace(filter))
                    {
                        apply();
                        return;
                    }

                    var tab = filter.Split(' ');

                    int nb = 0;
                    int nbOk = 0;

                    foreach (TrackListViewModel vitem in coll.SourceCollection)
                    {
                        if (_cancel)
                            return;

                        if (vitem.PieceGen.Virtual && !conf.includeVirtual)
                            continue;
                        if (vitem.PieceGen.VirtualByArtist && !conf.includeVirtualArtist)
                            continue;



                        bool ok = true;

                        if (conf.onlyId)
                        {
                            ok = filter == vitem.PieceId.ToString();
                        }
                        else
                        {

                            var name = vitem.Name.Trim().ToLower().removeAccent();
                            var artist = vitem.Artist.Trim().ToLower().removeAccent();
                            var album = vitem.Album.Trim().ToLower().removeAccent();
                            var classement = vitem.Classement;
                            foreach (string str in tab)
                            {
                                if (ok)
                                {
                                    if (string.IsNullOrEmpty(str))
                                        continue;
                                    var str_ = str.Trim();
                                    if (str_ == string.Empty)
                                        continue;

                                    ok = name.Contains(str_)
                                        || artist.Contains(str_)
                                        || album.Contains(str_)
                                        || classement.StartsWith(str_)
                                        || (conf.includeId && str == vitem.PieceId.ToString())
                                        ;
                                }
                                else
                                    break;

                            }
                        }


                        nb++;
                        if (ok)
                        {
                            if (conf.family)
                            {
                                foreach (Piece p in vitem.PieceGen.Master)
                                {
                                    if (p.Virtual && !conf.includeVirtual)
                                        continue;
                                    if (p.VirtualByArtist && !conf.includeVirtualArtist)
                                        continue;
                                    l.Add(p.PieceId);
                                }
                            }
                            else
                                l.Add(vitem.PieceId);

                            nbOk++;
                        }
                    }

                    log.log(string.Format("{0}/{1}", nbOk, nb));
                    // log.log(string.Format("calc:{0} item{1} {2} sélectionné{3}", nb, (nb > 1 ? "s" : ""), nbOk, (nbOk > 1 ? "s" : "")));   

                    lock (_lock)
                    {
                        if (_cancel)
                            return;
                    }


                    apply();


                }
                finally
                {
                    if (_cancel)
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par cancel");
                    }
                }





            }

            public void apply()
            {
                step = "apply";

                bool __cancel = _cancel;

                if (!__cancel)
                {
                    lock (_lock)
                        __cancel = _cancel;
                }
                if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
                {
                    if (string.IsNullOrWhiteSpace(filter))
                    {
                        coll.Filter = null;
                        return;
                    }

                    if (__cancel)
                        return;
                    step = "applyAppDispatcher";
                    try
                    {



                        if (work == null)
                        {
                            log.log("creation du tempo");
                            work = coll.DeferRefresh();
                        }
                        else
                        {
                            log.log("tempo déjà créé ");

                        }


                        coll.Filter = item =>
                        {
                            if (_cancel)
                                return false;

                            var t = item as TrackListViewModel;
                            if (t == null)
                                return false;
                            if (!l.Contains(t.PieceId))
                                return false;
                            return true;
                        };




                        if (!__cancel)
                        {
                            log.log("application");
                            work.Dispose();
                            work = null;
                            log.log("fin application");
                        }
                        else
                        {
                            log.log("abandon application");
                        }
                    }
                    finally
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par application");
                    }
                }
                else
                {
                    App.Current.Dispatcher.BeginInvoke(new Action(apply), DispatcherPriority.Background);
                }
            }

            public override string ToString()
            {
                return string.Format("en cours:{0} step:{1} end:{2} cancel:{3}", filter0, step, End, Cancel);
            }

        }


        public static void doFilter(ICollectionView coll, string filter)
        {
            SimpleChrono log = new SimpleChrono(string.Format("\tfilter=>{0}\t", filter), App.log);

            log.log("");
            lock (_lock)
            {
                bool _cancelCurrent = false;
                bool _same = false;

                if (filterTask != null)
                {
                    log.log(filterTask.ToString());
                }

                _cancelCurrent = filterTask != null && !filterTask.End;
                _same = _cancelCurrent && filterTask.filter0.Equals(filter);
                if (_same)
                {
                    log.log("identique");
                    return;
                }
                else if (_cancelCurrent)
                {
                    log.log("abandon tâche en cours");
                    filterTask.cancel();
                }

                else
                {
                    log.log("verrou libre");
                }

                filterTask = new FilterTask(filter, coll, log);

            }





        }



        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}


        public void doFilter(String filter)
        {
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);
            makeResume();
        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            string newResume = resume;
            try
            {

                IEnumerable items = null;
                var provider = DisplayProvider;
                if (provider == null)
                    return;
                var tracks = provider.PresentationTracks;
                int nbOrg = -1;
                items = tracks;
                if (items == null)
                    return;

                var selected = provider.SelectedTracks;
                if (selected.Count > 1)
                {
                    items = selected;
                    nbOrg = 0;
                    foreach (TrackListViewModel t in tracks)
                        nbOrg++;
                }
                int nb = 0, nbSelected = 0, nbPresent = 0;
                TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationPresent = new TimeSpan();
                HashSet<int> h = new HashSet<int>();

                foreach (TrackListViewModel track in items)
                {
                    if (!h.Add(track.PieceGen.MasterId))
                        continue;
                    nb++;
                    duration += track.Duration;
                    if (track.Enabled)
                    {
                        nbSelected++;
                        durationSelected += track.Duration;
                    }
                    if (track.Exists)
                    {
                        nbPresent++;
                        durationPresent += track.Duration;
                    }
                }

                ITextWriter sb = new pdb.util.StringBuilder();
                sb.Append(nb);
                sb.Append(" ");
                sb.Append("elt");
                if (nb > 1)
                    sb.Append("s");
                if (nbOrg >= 0)
                {
                    sb.Append(" sur ");
                    sb.Append(nbOrg);
                    sb.Append(",");
                }
                sb.Append(" ");
                humanDuration(sb, duration);
                sb.Append(" ( ");
                sb.Append(nbSelected);
                sb.Append(" ");
                sb.Append("elt");
                if (nbSelected > 1)
                    sb.Append("s");
                sb.Append(" ");
                humanDuration(sb, durationSelected);

                sb.Append(" )");

                if (nbPresent > 0)
                {
                    sb.Append(" presents: ");
                    sb.Append(nbPresent);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationPresent);
                }
                sb.Append("\t");

                var currentTrack = TrackListViewModel.HumanSelected;
                if (currentTrack != null)
                {
                    humanSize(sb, currentTrack.Size);
                    sb.Append(" ");
                    sb.Append(currentTrack.Location);
                }

                newResume = sb.ToString();
            }
            catch (Exception e0)
            {
                App.log.log(e0.ToString());
            }
            finally
            {
                if (newResume != resume)
                {
                    resume = newResume;
                    if (resumeChange != null)
                    {
                        try
                        {
                            resumeChange(this, EventArgs.Empty);
                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString());
                        }
                    }
                }
            }
        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append(size.HumanReadableSize(-1));
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append("j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append("m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append("m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append("s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\DeleteCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.db.obj;
using pdb.gen;

namespace pdb.player.ViewModel.Commande
{
    class DeleteCmd : CommandeBase
    {
        public override bool CanExecute(object parameter)
        {
            var track = TrackListViewModel.HumanSelected;
            return track != null;
        }

        public override void Execute(object parameter)
        {
            var track = TrackListViewModel.HumanSelected;

            bool? byAlbum = App.Instance.TriChoix(string.Format("supprimer l'abum entier {0} {1} ?", track.Album, track), "Suppression");
            if (byAlbum == null)
                return;
            if (byAlbum == true)
            {
                int nb = 0;
                var album = App.gen.getTracksAlbumByNumber(track.Track);
                foreach (var p in album)
                {
                    bool? go = deleteP(p); // App.Instance.TriChoix("suppression de " + p + " (track n°" + p.TrackNumber + ")?", "Suppression");
                    if (go == null)
                        break;
                    if (go == false)
                        continue;

                    nb++;
                }
                App.Instance.InfoIHm(nb + " éléments supprimés", "Suppression");
            }
            else
                deleteP(track.PieceGen); 

            App.go();
        }

        private bool? deleteP(Piece p)
        {
            bool? go = null; 
            if (p.PieceParentId < 0)
            {
                var sb = new StringBuilder();
                var list = new List<Piece>(p);

                foreach (Piece sub in list)
                {
                    sb.Append("ID=");
                    sb.Append(sub.PieceId);
                    sb.Append(" ");
                    sb.AppendLine(sub.Album);
                }

                go = App.Instance.TriChoix(String.Format("Attention ! Morceau maitre! Suppression en cascade du track ID={0} {1} {2}  \n{3}", p.PieceId, p.Name, p.Album, sb.ToString()), "Suppression en Cascade");
                if (go == null)
                    return null;
                if (go == false)
                {
                    // récupération des données pour les enfants
                    foreach (Piece c in p.Childs)
                    {
                        (c.Track as CPiece).Parent = null;
                    }
                    App.Db.List.delete(p.Track as CPiece);

                    return true; 
                }
                else
                {
                    foreach (Piece c in p.Childs)
                    {
                        App.Db.List.delete(c.Track as CPiece);
                    }
                    App.Db.List.delete(p.Track as CPiece);

                    return true; 
                }
            }
            else
            {
                go= App.Instance.TriChoix(String.Format("Suppression du track ID={0} {1} {2}", p.PieceId, p.Name, p.Album), "Suppression");
                if (go == null)
                    return null;
                if (go == false)
                    return false;
                App.Db.List.delete(p.Track as CPiece);
               
            }

            return go; 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" 
                       x:Name="dg" x:Uid="93A5ABB5-8716-49B8-B2CF-25D5B852114D"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="false" 
                                        
                       SelectedItem="{Binding SelectedTrackInAlbumView}">



            <!--<DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>-->

            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <!--<DataGridCheckBoxColumn Header=""  Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                <DataGridTextColumn Header="" Binding="{Binding Index,Mode=OneWay}"/>
                <DataGridTextColumn Header="p" Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="" Binding="{Binding MedianneStatus,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Virtuel" Binding="{Binding ClassementVirtuel,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimal},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Virtuel2" Binding="{Binding ClassementVirtuel2,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2,Mode=OneWay, Converter={StaticResource decimal},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Comment" Binding="{Binding Comment,Mode=OneWay}"/>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>
                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>


                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />


            </DataGrid.Columns>


            <DataGrid.ItemContainerStyle>

                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="BorderThickness" Value="0" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exis
                    ts}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},ConverterParameter=album,   UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />
                   
                    
                    
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />




                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected"  Value="True">-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Foreground"  Value="White" />-->
                    <!--<Setter Property="BorderThickness" Value="1" />-->
                    <!--</Trigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <!--<Setter Property="Height"  Value="20" />-->
                  
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Padding" Value="10,10,10,10" />
                </Style>
            </DataGrid.RowStyle>

            <DataGrid.ContextMenu>
                <ContextMenu>
            
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />                 
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
        </l:EnhancedDataGrid>
        
        <Grid Grid.Row="1">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="Auto" />                
            </Grid.ColumnDefinitions>
            <TextBlock Grid.Row="0" Grid.Column="0"  FontSize="11" Text="{Binding Name}" TextTrimming="CharacterEllipsis" />
            <TextBlock Grid.Row="0" Grid.Column="1"  FontSize="11" Text="{Binding Grouping}" />
            <ComboBox Grid.Row="0" Grid.Column="2" Width="100" Name="cbx_mode" DockPanel.Dock="Right"  SelectionChanged="cbx_mode_SelectionChanged" >
                <ComboBoxItem ToolTip="album du morceau sélectionné" >identique</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre" >origine</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre si virtuel" >origine si virtuel</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus long entre le maitre et le virtuel" >le plus long</ComboBoxItem>
            </ComboBox>

            <TextBlock Grid.Row="1" Grid.Column="0"  FontSize="11" Text="{Binding NameAlt}"  Visibility="{Binding WithVirtualAlbum, Converter={StaticResource boolVis}}" TextTrimming="CharacterEllipsis" />
            <TextBlock Grid.Row="1" Grid.Column="1"  FontSize="11" Text="{Binding GroupingAlt}"  Grid.ColumnSpan="2" Visibility="{Binding WithVirtualAlbum, Converter={StaticResource boolVis}}" />

        </Grid>

       
    </Grid>
</UserControl>  
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfFilterW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfFilterW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Paramètres de filtre" Height="207" Width="323">
    <Grid Height="162" Width="278">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>


        <CheckBox VerticalAlignment="Center" Grid.Row="0" Grid.Column="0" Name="includeVirtual" ToolTip="Inclure les éléments virtuels" />
        <CheckBox VerticalAlignment="Center" Grid.Row="1" Grid.Column="0" Name="includeVirtualAlbum" ToolTip="Inclure les albums virtuels par artiste" />
        <CheckBox VerticalAlignment="Center" Grid.Row="2" Grid.Column="0" Name="includeId" ToolTip="Inclure la recherche par ID" />
        <CheckBox VerticalAlignment="Center" Grid.Row="3" Grid.Column="0" Name="onlyId" ToolTip="Recherche exclusivement par ID" />
        <CheckBox VerticalAlignment="Center" Grid.Row="4" Grid.Column="0" Name="family" ToolTip="Recherche étendue aux éléments apparentés" />



        <Label Grid.Row="0" Grid.Column="1" Content="Inclure les éléments virtuels" />
        <Label Grid.Row="1" Grid.Column="1" Content="Inclure les albums virtuels par artiste" />
        <Label Grid.Row="2" Grid.Column="1" Content="Inclure la recherche par ID" />
        <Label Grid.Row="3" Grid.Column="1" Content="Recherche exclusivement par ID" />
        <Label Grid.Row="4" Grid.Column="1" Content="Recherche étendue aux éléments apparentés" />

        <StackPanel Grid.Row="5" Grid.Column="1" Orientation ="Horizontal" HorizontalAlignment="Right"  Height="30" Width="150">
            <Button Name="Cancel" Content="Cancel" Click="Cancel_Click"></Button>
            <Button Name="Ok" Content="Ok" Click="Ok_Click"></Button>
        </StackPanel>
    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfFilterW.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using pdb.gen.Tuning;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfFilterW.xaml
    /// </summary>
    public partial class ConfFilterW : Window
    {
        private ConfFilter conf; 
        public ConfFilterW()
        {
            InitializeComponent();
            Loaded += new RoutedEventHandler(ConfFilterW_Loaded);
            
        }

        public ConfFilterW(ConfFilter conf)
            : this()
        {
            this.conf = conf; 
        }

        private void display()
        {
            includeVirtual.IsChecked = conf.includeVirtual;
            includeVirtualAlbum.IsChecked = conf.includeVirtualArtist;
            includeId.IsChecked = conf.includeId;
            family.IsChecked = conf.family;
            onlyId.IsChecked = conf.onlyId; 
        }

        private void record()
        {
            conf.includeId = includeId.IsChecked.Value;
            conf.includeVirtual = includeVirtual.IsChecked.Value;
            conf.includeVirtualArtist = includeVirtualAlbum.IsChecked.Value;
            conf.onlyId = onlyId.IsChecked.Value;
            conf.family = family.IsChecked.Value; 

        }

        void ConfFilterW_Loaded(object sender, RoutedEventArgs e)
        {
            Ok.IsDefault = true;
            display(); 
        }



        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            Close(); 
        }

        private void Ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close(); 
        }

       
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="2D638B20-D34A-48B9-88E8-9F00F1BAA78D" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
            
          
            <DataGrid.Columns>
                

                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                      
                    </DataGridTemplateColumn.CellTemplate>
                    
                    
                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                  
                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Comment" Binding="{Binding Comment,Mode=OneWay}"/>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                
               
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                         </Style>
                    </DataGridTextColumn.CellStyle>
                  
                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />
               
                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />





            </DataGrid.Columns>
           
            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />
                 
                    
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->                    
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>               
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />
                   
                   

                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    
                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <DockPanel Grid.Row="1" >
            <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
            <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMovedUnavailable,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
            <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0" FontSize="11"/>
            <TextBlock DockPanel.Dock="Left"  Text="{Binding AutoResume,UpdateSourceTrigger=PropertyChanged}" FontWeight="DemiBold" FontSize="11" Margin="0,0,10,0"/>



            <TextBlock DockPanel.Dock="Bottom" FontSize="11" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
        </DockPanel>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using pdb.gen.Tuning;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.util;
using pdb.player.Vue.Util;
using System.Windows.Threading;
using System.Windows.Media;
using Math = System.Math;
using System.Linq;
using System.Linq.Expressions;

namespace pdb.player.Vue
{



    public partial class DataGridPlayList : UserControl, ItrackProvider, IRedraw, IExportTracks
    {
        private static int nb;
        private int ID;
        private Logger log;
        public static event EventHandler refreshOk;
        // private BgColorFormatConverter colorConvert = new BgColorFormatConverter();

        //  private BgDict<int, DataGridRow> dict = new BgDict<int, DataGridRow>(); 
        private TrackListViewModel currentTrack;

        public DataGridPlayList()
        {
            ID = nb;
            log = Logger.getLogger("DataGridPlayList" + ID);
            nb++;
            InitializeComponent();
            this.Loaded += DataGridPlayList_Loaded;
            App.refresh += new EventHandler(App_refresh);
            PlayListCommande.Provider = this;
        }

        void DataGridPlayList_Loaded(object sender, RoutedEventArgs e)
        {
            init(null);
            PlayListViewModel.selectedPlaylistChange += PlayListViewModel_selectedPlaylistChange;
            PlayListViewModel.addDrow(this);
            dg.PreviewKeyUp += new KeyEventHandler(dg_preview);
            TrackListViewModel.CurrentHumanSelectedChanged += new EventHandler(TrackListViewModel_CurrentHumanSelectedChanged);

            PlayerViewModel.Instance.checkNavIni(); 

            ExportCmd.Ihm = this;

        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            //if (currentTrack != null)
            //    currentTrack.refresh();
            ICollectionView view = CollectionViewSource.GetDefaultView(dg.ItemsSource);

            var hs = TrackListViewModel.HumanSelected;
            if (hs == null)
                return;
            var pl = PlayListViewModel.SelectedPlayList;
            bool reset = pl != sender;

            TrackListViewModel t = null;
            try
            {
                checkItems(true);

                t = PlayListViewModel.findTrack(pl, hs.PieceId);
                if (t == null)
                    return;
                t.IsSelected = true;

            }
            finally
            {
                currentTrack = t;
                //if (currentTrack != null)
                //    currentTrack.refresh();
                //TrackListViewModel.setHumanSelected(PlayList, TrackListViewModel.CurrentSelected); 

            }


            PlayerViewModel.Instance.makeResume();
        }

        Key key;
        void dg_preview(object sender, KeyEventArgs e)
        {
            // e.Handled = false; 
            key = e.Key;
            bool nav = false;

            switch (key)
            {
                case Key.Up:
                case Key.Down:
                case Key.PageDown:
                case Key.PageUp: nav = true; break;
                //case Key.LeftCtrl: case Key.RightCtrl : // TODO ajouter un élément
            }



            if (!nav)
                return;
            TrackListViewModel.setHumanSelected(PlayList, TrackListViewModel.CurrentSelected); //    .HumanSelected = TrackListViewModel.CurrentSelected;
        }


        void App_refresh(object sender, EventArgs e)
        {
            log.log("dg::App_refresh");
            redraw();
        }




        void PlayListViewModel_selectedPlaylistChange(object sender, EventArgs e)
        {
            if (ID == 0)
            {
                init(sender as PlayListViewModel);
            }
        }

        private void init(PlayListViewModel old)
        {
            if (!Dispatcher.CheckAccess())
            {
                Dispatcher.Invoke(new Action<PlayListViewModel>(init));
                return;
            }
            log.log("dg::init");
            SortDescriptionCollection sort = null;
            ICollectionView view = null;
            if (old != null)
            {
                view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                if (view != null)
                    sort = view.SortDescriptions;
                if (sort != null)
                    old.Sort = sort;
            }


            var pl = PlayListViewModel.SelectedPlayList;
            var currentPlaying = TrackListViewModel.CurrentPlaying;
            if (pl == null)
                return;
            base.DataContext = null;

            var source = dg.ItemsSource;

            dg.ItemsSource = null;
            var items = pl.AlltracksVm;
            view = CollectionViewSource.GetDefaultView(items);
            using (var w = view.DeferRefresh())
            {
                // items.refresh();

                base.DataContext = items;
                int i = 0;
                if (pl.isSubList("gen"))
                {
                }
                else
                {
                    //foreach (TrackListViewModel track in items)
                    //{
                    //    i++;
                    //    track.Index = i;
                    //}
                }
                sort = pl.Sort;
                List<SortDescription> _sort = null;
                if (sort != null)
                    _sort = new List<SortDescription>(sort);
                dg.ItemsSource = items;

                TrackListViewModel.CurrentPlaying = currentPlaying;

                dg.ApplySort(_sort, w);
            }
            PlayerViewModel.Instance.set(this);

            //if (_sort != null && _sort.Count > 0)
            //{
            //    view.SortDescriptions.Clear();
            //    foreach (var _s in _sort)
            //    {
            //        view.SortDescriptions.Add(_s);
            //        foreach (DataGridColumn _c in dg.Columns)
            //        {
            //            if (_s.PropertyName == _c.SortMemberPath)
            //            {
            //                _c.SortDirection = _s.Direction;
            //                break;
            //            }
            //        }
            //        break;

            //    }
            //}

            //foreach (TrackListViewModel tv in items)
            //    tv.PropertyChanged += new PropertyChangedEventHandler(tv_PropertyChanged);

            if (currentTrack != null)
                currentTrack.refresh();

            putExportTracks(pl, CollectionViewSource.GetDefaultView(dg.ItemsSource));
            OnRefresh();


        }
        private void OnRefresh()
        {
            if (refreshOk != null)
                refreshOk(this, EventArgs.Empty);
        }

        private void dg_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            try
            {
                var r = sender as DataGridRow;
                var t = r.Item as TrackListViewModel;
                PlayerViewModel.reset(this, t);
            }
            catch
            {
            }
        }

        private void checkItems(bool reset)
        {
            var l = new List<TrackListViewModel>();
           

            ICollectionView view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
            var selectedTracks = new List<TrackListViewModel>(dg.SelectedItems.Count);
            foreach (TrackListViewModel t in dg.SelectedItems)
                selectedTracks.Add(t);
            var tracks = dg.Items;



            //    IDisposable w = view.DeferRefresh();
            try
            {


                if (reset)
                {
                    TrackListViewModel selected = null;
                    if (TrackListViewModel.HumanSelected != null)
                    {
                        selected = PlayListViewModel.findTrack(PlayList, TrackListViewModel.HumanSelected.PieceId);
                    }

                    foreach (TrackListViewModel track in view)
                    {
                        if (track == selected)
                            track.IsSelected = true;
                        else
                            track.IsSelected = false;

                        //track.refresh();
                    }
                    // dg.SelectedItems.Clear();
                    //  w.Dispose(); w = null;


                    if (selected != null)
                    {
                        l.Add(selected);
                        if (!dg.SelectedItems.Contains(selected))
                            dg.SelectedItems.Add(selected);
                    }
                    foreach (TrackListViewModel track in selectedTracks)
                    {
                        if (track != selected)
                        {
                            dg.SelectedItems.Remove(track);
                            track.IsSelected = false;
                            //track.refresh();
                        }
                    }
                }
                else
                {
                    foreach (TrackListViewModel track in selectedTracks)
                    {
                        l.Add(track);
                        track.IsSelected = true;

                        TrackListViewModel trackMusique = PlayListViewModel.findTrack(App.bib.Musique, track.PieceId);
                        if (trackMusique != null)
                            trackMusique.IsSelected = true;
                        //track.refresh();
                    }
                }
                //lock (this)
                //   this.selectedTracks = l;
            }
            finally
            {
                //if (w != null)
                //    w.Dispose();
            }

        }

        private void dg_MouseClick(object sender, MouseButtonEventArgs e)
        {
            //  e.Handled = true; 
            //var r = sender as DataGridRow;
            //var t = r.Item as TrackListViewModel;
            //TrackListViewModel.setHumanSelected(PlayList, t); //   .HumanSelected = t;
            //startPoint = e.GetPosition(null);

            checkItems(false);

            PlayerViewModel.Instance.makeResume();
        }



        // private List<TrackListViewModel> selectedTracks = new List<TrackListViewModel>();

        private List<TrackListViewModel> SelectedTracks
        {
            get
            {
                lock (this)
                {
                    var l = new List<TrackListViewModel>();
                    foreach (TrackListViewModel t in dg.ItemsSource)
                    {
                        if (t.IsSelected)
                            l.Add(t);
                    }
                    return l;
                }
            }
        }
        ICollectionView ItrackProvider.PresentationTracks
        {
            get { return CollectionViewSource.GetDefaultView(dg.ItemsSource); }
        }
        void ItrackProvider.Focus(int index)
        {

            // dg.SelectedIndex = index;
            //var indexbas = Math.Min(index + 100, dg.Items.Count - 1);
            //scrol(indexbas);
            scrol(index);
        }

        List<TrackListViewModel> ISelectedTracks.SelectedTracks
        {
            get
            {
                return SelectedTracks;
            }
        }
        void scrol(int index)
        {
            if (!CheckAccess())
            {
                Dispatcher.Invoke(new Action<int>(this.scrol), index);
            }
            else
            {
                if (dg.Items.Count == 0)
                    return;
                if (index < 0)
                    index = 0;
                if (index >= dg.Items.Count)
                    index = dg.Items.Count - 1;

                dg.ScrollIntoView(dg.Items[index]);
            }
        }
        public PlayListViewModel PlayList
        {
            get { return PlayListViewModel.SelectedPlayList; }
        }
        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter((this as ItrackProvider).PresentationTracks, filter);
        }
        private bool IsUserVisible(FrameworkElement element, FrameworkElement container)
        {
            if (!element.IsVisible)
                return false;
            Rect bounds = element.TransformToAncestor(container).TransformBounds(new Rect(0.0, 0.0, element.ActualWidth, element.ActualHeight));
            Rect rect = new Rect(0.0, 0.0, container.ActualWidth, container.ActualHeight);
            return rect.Contains(bounds.TopLeft) || rect.Contains(bounds.BottomRight);
        }

        private static T FindVisualParent<T>(UIElement element) where T : UIElement
        {
            var parent = element;
            while (parent != null)
            {
                var correctlyTyped = parent as T;
                if (correctlyTyped != null)
                {
                    return correctlyTyped;
                }

                parent = VisualTreeHelper.GetParent(parent) as UIElement;
            }
            return null;
        }

        public void redraw()
        {
            if (!CheckAccess())
            {
                Dispatcher.BeginInvoke(new Action(this.redraw), DispatcherPriority.DataBind);
                return;
            }
            try
            {
                var pl = PlayListViewModel.SelectedPlayList;

                bool isgen = false;
                if (pl != null && pl.isSubList("gen"))
                    isgen = true;

                var items = dg.ItemsSource as AllTracksViewModel;

                if (items == null)
                {
                    dg.Items.Refresh();
                }
                else
                {
                    ICollectionView view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                    using (var w = view.DeferRefresh())
                    {
                        SortDescriptionCollection sort = view.SortDescriptions;

                        List<SortDescription> _sort = null;
                        if (sort != null)
                            _sort = new List<SortDescription>(sort);

                        int i = 0;
                        foreach (TrackListViewModel track in items)
                        {
                            i++;
                            if (!isgen)
                                track.Index = i;
                            //  track.refresh();
                        }

                        dg.ApplySort(_sort, w);
                        //if (_sort != null && _sort.Count > 0 && view.SortDescriptions.Count > 0)
                        //{
                        //    view.SortDescriptions.Clear();
                        //    foreach (var _s in _sort)
                        //    {
                        //        view.SortDescriptions.Add(_s);
                        //    }
                        //}
                        items.refresh();
                    }
                    putExportTracks(pl, view);

                }
                return;


                try
                {
                    isgen = false;

                    if (isgen)
                    {
                        log.log("dg::redraw::init");
                        init(pl);
                    }
                    else
                    {
                        log.log("dg::redraw::Refresh");
                        dg.Items.Refresh();
                    }
                }
                catch
                {
                    try
                    {
                        init(pl);
                    }
                    catch
                    {
                    }
                }
            }
            finally
            {
                OnRefresh();
            }

        }

        private void MenuItem_Click(object sender, RoutedEventArgs e)
        {
            var items = dg.SelectedItems;
            MessageBox.Show(items.Count.ToString());
        }

        public string folderDialog()
        {
            return App.Instance.folderDialog();
        }


        public System.ComponentModel.ICollectionView PresentationTracks
        {
            get
            {
                return ((ItrackProvider)this).PresentationTracks;
            }
        }






        public bool ModeAlbum
        {
            get { return MessageBox.Show("par albums complets", "export", MessageBoxButton.YesNo) == MessageBoxResult.Yes; }
        }

        public bool Continue
        {
            get { return MessageBox.Show("continuer le marché ?", "export", MessageBoxButton.YesNo) == MessageBoxResult.Yes; }
        }




        public void InfoIHm(string message, string caption)
        {
            App.Instance.InfoIHm(message, caption);
        }

        public bool Confirm(string question, string caption)
        {
            return App.Instance.Confirm(question, caption);
        }

        public bool? TriChoix(string question, string caption)
        {
            return App.Instance.TriChoix(question, caption);
        }

        public Export getConfExport(string question)
        {
            return App.Instance.getConfExport(question);
        }

        public Import getConfImport(string question)
        {
            return App.Instance.getConfImport(question);
        }

        public int getNb(string question)
        {
            return App.Instance.getNb(question);
        }

        public bool changeName(string title, IName data)
        {
            return App.Instance.changeName(title, data);
        }

        public PlayListViewModel selectPlayList(string title)
        {
            return App.Instance.selectPlayList(title);
        }



        //  private List<TrackListViewModel> list = new List<TrackListViewModel>(); 
        public List<TrackListViewModel> ListTrack
        {
            get { return null; }
        }

        private void putExportTracks(PlayListViewModel pl, ICollectionView view)
        {
            var list = new List<TrackListViewModel>();
            foreach (TrackListViewModel track in view)
                list.Add(track);
            pl.ExportTracks = list;
            //visibleItems = new List<TrackListViewModel>();

            //foreach (var item in view)
            //{
            //    var row = dg.ItemContainerGenerator.ContainerFromItem(item) as DataGridRow;
            //    if (row != null)
            //    {
            //        visibleItems.Add(item as TrackListViewModel); 
            //    }
            //}


        }
        //private List<TrackListViewModel> visibleItems = new List<TrackListViewModel>();
        //public List<TrackListViewModel> VisibleItems { get { return new List<TrackListViewModel>(visibleItems); } }

        Point startPoint;
        private void dg_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            startPoint = e.GetPosition(null);
        }

        private void dg_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            var mousePos = e.GetPosition(null);
            var diff = startPoint - mousePos;

            if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance
                || Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
            {
                var treeView = sender as DataGrid;
                var treeViewItem = //(e.OriginalSource as DependencyObject).
                    Util.Util<DataGridRow>.FindAnchestor((DependencyObject)e.OriginalSource);
                //   FindAnchestor<TreeViewItem>((DependencyObject)e.OriginalSource);

                if (treeView == null || treeViewItem == null)
                    return;

                var folderViewModel = treeView.SelectedItem as TrackListViewModel;
                if (folderViewModel == null)
                    return;

                var dragData = new DataObject(folderViewModel);
                DragDrop.DoDragDrop(treeViewItem, dragData, DragDropEffects.Copy);
            }
        }
    }
}]]></content>
  </file>
  <file path="\pdb.player\Vue\PlayerControler.xaml.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Threading;
using System.Windows.Controls.Primitives;
using System.Windows.Automation.Peers;
using pdb.player.Vue.Util;
using pdb.player.ViewModel.Colors;
using System.Threading;

namespace pdb.player.Vue
{
    /// <summary>
    /// Logique d'interaction pour PlayerControler.xaml
    /// </summary>
    public partial class PlayerControler : UserControl, IRecordClassmentObserver, IGradiant
    {
        private Gradient confGradiant;
        public PlayerControler()
        {
            InitializeComponent();


            GradiantBuilder.Instance.Add(this);
            this.Loaded += PlayerControler_Loaded;
        }

        void PlayerControler_Loaded(object sender, RoutedEventArgs e)
        {
            DataContext = PlayerViewModel.Instance;
            DataGridPlayList.refreshOk += new EventHandler(DataGridPlayList_refreshOk);
            DetailClassementViewModel.RecordObserver = this;
            txtFilter.MouseDoubleClick += new MouseButtonEventHandler(txtFilter_MouseDoubleClick);

        }

        void txtFilter_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            new ConfFilterW(PlayerViewModel.Instance.ConfFilter).Show(); 
        }

        void DataGridPlayList_refreshOk(object sender, EventArgs e)
        {
            if (_currentPaying != null)
            {
                if (TrackListViewModel.CurrentPlaying == _currentPaying)
                    automateNextTrack();
                _currentPaying = null;
            }
        }

        void DetailClassementViewModel_classementChanged(object sender, EventArgs e)
        {
            focus();
        }

        private void focus()
        {
            if (!CheckAccess())
                Dispatcher.BeginInvoke(new Action(this.focus), DispatcherPriority.DataBind);
            else
            {
                b_play.Focus();
            }
        }

        private void automateNextTrack()
        {
            if (!CheckAccess())
                Dispatcher.BeginInvoke(new Action(this.automateNextTrack), DispatcherPriority.DataBind);
            else
            {
                ICommand forward = PlayerViewModel.Instance.Forward;
                if (forward.CanExecute(this))
                {
                    forward.Execute(this);
                }


            }
        }

        private void txtFilter_KeyUp(object sender, KeyEventArgs e)
        {
            String filter = txtFilter.Text;
            doFilter(filter);
        }

        private void doFilter(String filter)
        {
            PlayerViewModel.Instance.doFilter(filter);
        }

        private void btSort_Click(object sender, RoutedEventArgs e)
        {
            var conf = PlayerViewModel.Instance.ConfAlbumSort;
            var dialog = new ConfAlbumSortW(conf);
            dialog.Show();
        }



        public void signalClassementChange()
        {
            focus();
        }

        private TrackListViewModel _currentPaying;
        public void autoNextTrack(TrackListViewModel track)
        {
            _currentPaying = track;
        }



        ViewModel.Colors.Gradient IGradiant.Conf
        {
            get { return Couleurs.Instance.player.gradient; }
        }

        bool IGradiant.sensGradient
        {
            get { return false; }
        }

        void IBackGround.setBackground(Brush brush)
        {
            gmain.Background = brush;
        }

        
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des données morceux dupliqués 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
            albums = new Albums(this);
        }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }
        private bool _fisrtConsolid = true;
        public Albums Albums { get { return albums; } }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                all = new List<Piece>(); 
              
                // albums = new Albums(this);
                VirtualPiece.init();
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>();
                //  htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        Piece piece = null;
                        int pieceId = track.PieceId;
                        if (htIds.ContainsKey(pieceId))
                        {
                            piece = htIds[pieceId];
                            piece.initRank();
                        }
                        else
                        {
                            piece = new Piece(track);
                            htIds.Add(pieceId, piece);
                        }

                        all.Add(piece);

                    }
                }
                // link
                foreach (Piece piece in all)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                albums.checkBuild();
                logger.log("build albums");
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        foreach (Piece p in piece)
                        {
                            if (albums.check(p))
                                listPieceInAlbum.Add(p); 
                        }
                    }
                }

                if (_albumVirtual && _fisrtConsolid)
                {
                    logger.log("build albums virtuels");
                    var listCandidat = new List<Piece>();
                    var dictTmp = new BgDictString<Album>();
                    foreach (Piece piece in all)
                    {
                        if (piece.Parent == null)
                        {
                            piece.buildVirtualAlbums(listCandidat);
                        }
                    }
                    foreach (Piece p in listCandidat)
                        albums.checkVirtual(p, dictTmp);
                    var listAlbums = new List<Album>(dictTmp.Values);
                    listAlbums.Sort(new VirtualAlbumComparer());
                    albums.checkVirtuals(listAlbums, listPieceInAlbum);

                }

                albums.buildDone();



                StackAlbum.Instance.init(all);



                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                if (_fisrtConsolid)
                    albums.sortVirtual();
                Ranking();
            }
            finally
            {
                lock (_lock)
                {
                    _fisrtConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            foreach (Piece piece in all)
            {
                musique.addObj(piece);
            }

#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(TrackList track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPieceInAlbum);
                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking()
        {
            QRanking();
            LRanking();
            QLRanking();

            logger.log("setTuningDateValues");
            var list = new List<Piece>(listPiece);

            foreach (Piece piece in list)
            {
                piece.Rank.TimeRest = -1;
            }
            foreach (Piece piece in list)
            {
                piece.FirstClass = false;
                CRank rank = piece.Rank;
                var sortValue = CTuning.Calc(rank, CConf.Sort);
                rank.SortValue = sortValue;

                ListSelection.setTuningDateValues(piece);
            }

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);

            albums.makeSort();
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit� +longueur en cas d'�galit�
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }

            if (CConf.Condensation)
            {
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();

            }

        }

        public void builStats(Action rappel)
        {
            try
            {
                bool generDistrib = step % 10 == 0;

                if (_albumSortMode.createCourant)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(m_listQL).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(m_listQL) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                if (rappel != null)
                    rappel();
            }
        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        public void timeRanking()
        {
            logger.log("timeRanking");
            foreach (var piece in allClassed)
                piece.Rank.TimeRest = -1;
            foreach (var piece in allClassed)
                ListSelection.setTuningDateValues(piece);


        }

        /// <summary>
        /// redirection des index metier de la table m�tier vers la table locale
        /// Copie des valeurs pertinentes(classlist)
        /// </summary>
        /// <remarks></remarks>
        public void eraseGrouping()
        {
            thCommentGo = false;
            thGroupingGo = false;
            logger.log("eraseGrouping");
            foreach (Piece piece in listPieceInAlbum)
            {
                piece.setGrouping("", false);
                piece.Comment = "";
            }
        }
        public void writeGrouping()
        {
            logger.log("writeGrouping");
            var list = new List<Piece>(listPieceInAlbum);
            // list.Sort(new CPieceComparerByQualityAndLength());
            list.Sort(new AllPieceComparer2());

            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    logger.log("writeGrouping::" + ex.ToString());
                }

            }
        }


        private bool thGroupingGo;
        private bool thCommentGo;

        public bool GroupinGO
        {
            set
            {
                thGroupingGo = value;
                if (value)
                {
                }
            }
        }
        public bool CommentGo
        {
            set
            {
                thCommentGo = value;
                if (value)
                {
                }
            }
        }



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        public void writeGrouping(Piece piece)
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            piece.writeGrouping(writeGrouping);

        }
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        public void writeComment()
        {
            logger.log("writeComment");
            var list = new List<Piece>(listPiece);
            list.Sort(new CPieceComparerByQualityAndLength());

            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    logger.log("writeComment::" + ex.ToString());
                }
            }




        }

        public void writeComment(Piece piece)
        {
            var writeComment = CConf.ConfGen.WriteComment;
            try
            {
                piece.writeComment(writeComment);
            }
            catch (Exception ex)
            {
                logger.log("writeComment::" + ex.ToString());
            }
        }



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\pdb.gen.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.gen</RootNamespace>
    <AssemblyName>pdb.gen</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="albums\Album.cs" />
    <Compile Include="albums\AlbumComparer.cs" />
    <Compile Include="albums\AlbumMedianne.cs" />
    <Compile Include="albums\Albums.cs" />
    <Compile Include="albums\StackAlbum.cs" />
    <Compile Include="albums\VirtualAlbumPiece.cs" />
    <Compile Include="CalcEquiv.cs" />
    <Compile Include="Consolid.cs" />
    <Compile Include="CLegacyListWriter.cs" />
    <Compile Include="CRank.cs" />
    <Compile Include="IListWriter.cs" />
    <Compile Include="ListPiece.cs" />
    <Compile Include="CPieceComparer.cs" />
    <Compile Include="ListSelection.cs" />
    <Compile Include="ListWriterMgr.cs" />
    <Compile Include="pertinence\TrackBuilder.cs" />
    <Compile Include="Piece.cs" />
    <Compile Include="CalcDate.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="stat\ClassStruct.cs" />
    <Compile Include="stat\Condenseur.cs" />
    <Compile Include="stat\DynamicStatBuilder.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="stat\MedianneValue.cs" />
    <Compile Include="stat\NewClassement.cs" />
    <Compile Include="stat\StatBuilder.cs" />
    <Compile Include="stat\StatConteneur.cs" />
    <Compile Include="TrackList.cs" />
    <Compile Include="Tuning\CConf.cs" />
    <Compile Include="Tuning\CConfQL.cs" />
    <Compile Include="Tuning\CConfSort.cs" />
    <Compile Include="Tuning\ConfAlbumSort.cs" />
    <Compile Include="Tuning\ConfFilter.cs" />
    <Compile Include="Tuning\ConfGen.cs" />
    <Compile Include="Tuning\CTuning.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\GroupingDisplay.cs" />
    <Compile Include="Tuning\Import.cs" />
    <Compile Include="Virtuel\VirtualPiece.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfFilter.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Xml;

namespace pdb.gen.Tuning
{
    public class ConfFilter : TuningBase
    {
        public bool includeVirtual = true;
        public bool includeVirtualArtist = true;
        public bool includeId;
        public bool onlyId;
        public bool family;

        public ConfFilter()
            : base()
        {
        }

        public ConfFilter(XmlElement node)
            : base(node)
        {
            buildb("includeVirtual", v => includeVirtual = v);
            buildb("includeVirtualArtist", v => includeVirtualArtist = v);
            buildb("includeId", v => includeId = v);
            buildb("onlyId", v => onlyId = v);
            buildb("family", v => family = v); 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CPiece.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.type;
using pdb.obj;
using pdb.util;
using pdb.db.piece;
using System.Diagnostics;


namespace pdb.db.obj
{

    /// <summary>
    /// Métadonnées d'un fichier
    /// </summary>
    /// <remarks>On veut pouvoir merger les modifications venant de deux sources
    /// exemeple : un modifie le classement, l'autre l'année
    /// Pour cela, il est envisagé d'enregistrer pour chaque modification effectué par le client
    /// tout simplement la date de cette modification
    /// le merge se baserait ainsi sur la comparaison entre les dates de modification
    /// source 1 date modif d1' pour classement > d1
    /// source 2 date modif d2' pour année > d2
    /// 
    /// On pourrait aussi se baser sur un flag => mettre à jour
    /// ainsi on gagnerait de la place, mais on perdrait la date de derniere mise à jour
    /// et se poserait aussi la question de quand retirer le flaf "mettre à jour"
    /// 
    /// On peut aussi établir un historique
    ///
    ///</remarks>
    /// 

    public enum Bool
    {
        not_defined = 0,
        False = 1,
        True = 2
    }

    public class CPiece : IData, ITrackMetaData, ITrackNativeDates, ITrackPlayListRecorder, ITrackPlayListReport, IDataObserver, ITrackInfoItunes
    {
        private static Logger logTrack = Logger.getLogger("Track");
        //  private static NullTrack NullTrack = new NullTrack();
        private const string TOKEN_PIECE = "piece";

        private const string TOKEN_DISABLED = "disabled";
        private const string TOKEN_ARTWORK = "artWork";
        private const string TOKEN_DURATION = "duration";

        #region "Composants"
        private CListDate m_dates;
        private CListFile m_files;
        private CPieceReference m_ref;
        private CPieceInfo m_infos;
        private CPieceClassement m_classement;
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private CPieceChecked m_Enabled = new CPieceChecked();


        //private String m_comment = "";
        //private string grouping = ""; 
        private string artWork = "";
        #endregion

        //private class StringEventArgs : EventArgs
        //{
        //    public StringEventArgs(String value) { this.Value = value; }
        //    readonly public String Value;
        //}


        private void checkNative()
        {
            //if (native == null)
            //{
            //    StackTrace st = new StackTrace();
            //    logTrack.logNoDate("native null " + this + " " + st.ToString());
            //}
        }
        //   public void makeFirstClass() { if (native == null) return; native.makeFirstClass(); }
        public bool FirstClass
        {
            get
            {
                if (native == null) return false;
                return native.FirstClass;
            }
            set { if (native == null) return; native.FirstClass = value; }
        }
        public bool HasNoNative { get { return native == null; } }
        private void OnCommentChange(String value)
        {
            checkNative();
            if (native == null)
                return;
            native.Comment = value;
        }
        private void OnGroupingChange(String value, bool prior)
        {
            checkNative();
            if (native == null)
                return;
            native.setGrouping(value, prior);
        }
        private void OnNameChange(string value) { if (native == null) return; native.Name = value; }
        private void OnAlbumChanged(String value) { if (native == null) return; native.Album = value; }
        private void OnArtistChanged(String value) { if (native == null) return; native.Artist = value; }
        private void OnUncheck() { if (native == null) return; native.Enabled = false; }



        //private EventHandler<StringEventArgs> commentChanged;
        //private EventHandler<StringEventArgs> groupingChanged;
        //private EventHandler<StringEventArgs> albumChanged;
        //private EventHandler<StringEventArgs> artistChanged;


        private List<IReference> referenceObs = new List<IReference>();
        public void addReferenceObs(IReference obs) { if (!referenceObs.Contains(obs)) referenceObs.Add(obs); }
        public void removeReferenceObs(IReference obs) { referenceObs.Remove(obs); }
        private void OnReferenceChanged() { for (int i = 0; i < referenceObs.Count; i++) { referenceObs[i].referenceChange(this); } }


        #region logs
        private void valueChangedHandler()
        {

            //m_ref.AlbumData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Album", args); };
            //m_ref.ArtistData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Artist", args); };
            //m_ref.NameData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Name", args); };
            //m_infos.YearData.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Year", args); };
            //Classement.changeLocalValueByRemote += (o, args) => { logChangeByRemote("Classement", args); };

            //m_ref.AlbumData.changeLocalValueByNative += (o, args) => { langChangeByNative("Album", args); };
            //m_ref.ArtistData.changeLocalValueByNative += (o, args) => { langChangeByNative("Artist", args); };
            //m_ref.NameData.changeLocalValueByNative += (o, args) => { langChangeByNative("Name", args); };
            //m_infos.YearData.changeLocalValueByNative += (o, args) => { langChangeByNative("Year", args); };
            //Classement.changeLocalValueByNative += (o, args) => { langChangeByNative("Classement", args); };

            //m_ref.AlbumData.change += new EventHandler(Ref_change);
            //m_ref.NameData.change += new EventHandler(Ref_change);
            //m_ref.ArtistData.change += new EventHandler(Ref_change);
            //m_ref.TrackData.change += new EventHandler(Ref_change);
            Files.Observer = this;
            m_ref.Observer = this;
            m_infos.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
        }


        private void logChange(String typeChange, String typeData, object Old, object New)
        {
            logTrack.log("{0}:{1} from '{2}' to '{3}' {4}", typeChange, typeData, Old, New, this);
        }
        //private void logChangeByRemote(String typeData, object Old, object New)
        //{
        //    logChange("change by remote", typeData, Old, New);
        //}
        //private void langChangeByNative(String typeData, object Old, object New)
        //{
        //    logChange("change by native", typeData, Old, New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}
        //private void logChangeByRemote(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    logChangeByRemote(typeData, args.Old, args.New);
        //}

        //private void langChangeByNative(String typeData, CPieceData<String>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<int>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}
        //private void langChangeByNative(String typeData, CPieceData<Classement>.PieceDataChangeLocalEventArgs args)
        //{
        //    langChangeByNative(typeData, args.Old, args.New);
        //}

        #endregion


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        public void keyGener()
        {
            try
            {
                key = new TrackIdentity(this);
            }
            catch
            {
                logTrack.log("pb de clé " + this);
                throw;
            }
        }

        #endregion

        #region constructeurs





        /// <summary>
        /// création d'un morceau vide
        /// </summary>
        /// <remarks></remarks>
        public CPiece()
        {

            m_dates = new CListDate();
            m_files = new CListFile();
            m_ref = new CPieceReference();
            m_infos = new CPieceInfo();
            m_classement = new CPieceClassement();
            valueChangedHandler();
        }

        public CPiece(string location, string baseClassement)
            : this()
        {
            m_files.add(new CFile(location));
            m_classement = new CPieceClassement(baseClassement);
            valueChangedHandler();
        }

        public CPiece(string location)
            : this()
        {
            m_files.add(new CFile(location));
            valueChangedHandler();
        }

        public void initClassementIfEmpty(string classement)
        {
            m_classement.initClassementIfEmpty(classement);
        }


        public void eraseClassement()
        {
            m_classement.eraseClassement();
        }


        private ITrackInfoItunes native = null;

        public void recordJustReadTrack()
        {
            ListDates.check(DateTime.Now);
        }

        public CPiece(ITrackInfoItunes ext)
        {
            native = ext;
            //  ext.registerDependency(this); 

            m_classPlayLists = ext.ClassPlayLists;
            //m_playList = ext.PLayLists;

            string className = ext.ClassName; // getClassName(ext); 

            m_dates = new CListDate();
            ListDates.check(ext.PlayedDate);

            m_files = new CListFile();
            Files.add(new CFile(ext.Location));
            m_ref = new CPieceReference(ext.Artist, ext.Album, ext.Name, ext.TrackNumber);
#if VOL
            m_infos = new CPieceInfo(ext.Year, ext.Volume);
#else
            m_infos = new CPieceInfo(ext.Year);
#endif
            this.artWork = ext.ArtWork;

            m_classement = new CPieceClassement(className, ext.Rating);
            //m_comment = ext.Comment;
            //grouping = ext.Grouping; 

            m_duration = ext.Duration;
            bool enabled = ext.Enabled;
            if (enabled)
                Checked.Enable();
            else
                Checked.Disable();

            //m_ref.AlbumData.changeNativeValue += (o, args) =>  { if (native == null) return; native.Album = args.Value; };
            //m_ref.ArtistData.changeNativeValue += (o, args) => { if (native == null) return; native.Artist = args.Value; };
            //m_ref.NameData.changeNativeValue += (o, args) => { if (native == null) return; native.Name = args.Value; };
            //m_ref.TrackData.changeNativeValue += (o, args) => { if (native == null) return; native.TrackNumber = args.Value; };
            //m_infos.YearData.changeNativeValue += (o, args) => { if (native == null) return; native.Year = args.Value; };
            //Classement.changeNativeValue += (o, args) => { if (native == null) return; native.Rating = args.Value.Rating; native.ClassName = args.Value.ClassList; };

            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            //  m_Enabled.checkedChanged += (o, args) => { if (native == null) return; native.Enabled = false; };





            valueChangedHandler();


        }

        ///// <summary>
        ///// Tri des listes classement et détermination de la liste classement pertinente
        ///// </summary>
        //public void setClassPlayList(ITrackNative track)
        //{
        //    List<CPlayList> classLists = track.ClassPlayLists;
        //    if (classLists.Count > 0)
        //    {
        //        classLists.Sort(new CPlayListComparer());
        //        className = classLists[0].Name;
        //    }
        //}

        /// <summary>
        /// construction à partir de la base maison 
        /// </summary>
        /// <param name="a_xml"></param>
        /// <remarks></remarks>
        public CPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);
            m_id = xmlTool.getIntAttValue("id");
            deleted = xmlTool.getBoolAttValue("deleted");
            m_ref = new CPieceReference(a_xml);
            m_infos = new CPieceInfo(a_xml);

            parentID = xmlTool.getIntAttValue("parent");
            if (parentID < 0)
            {
                m_dates = new CListDate(a_xml);
                m_files = new CListFile(a_xml);
                m_classement = new CPieceClassement(a_xml);
                var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);
                {
                    if (xDisabled != null)
                    {
                        if (xDisabled.InnerText == "false")
                            Checked.Enable();
                        else
                            Checked.Disable(); 
                    }
                }
            }
            else
            {
                m_dates = new CListDate();
                m_files = new CListFile();
                m_classement = new CPieceClassement();

            }





            var xtool = new XMLTool(a_xml);
            artWork = xtool.getNodeValue(TOKEN_ARTWORK);
            //Comment = xtool.getNodeValue("classement");
            //_grouping = xtool.getNodeValue("grouping");
            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xtool.getNodeValue(TOKEN_DURATION);


            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }

            m_ref.Observer = this;
            Classement.Observer = this;
            Checked.Observer = this;
            valueChangedHandler();

        }


        ///// <summary>
        ///// construction à partir de la base propriétaire
        ///// </summary>
        ///// <param name="a_ref"></param>
        ///// <param name="a_file"></param>
        ///// <param name="a_info"></param>
        ///// <param name="a_rating"></param>
        ///// <param name="a_date"></param>
        ///// <remarks></remarks>
        //public CPiece(CPieceReference a_ref, string a_file, CPieceInfo a_info, int a_rating, System.DateTime a_date, TimeSpan a_duration, bool a_bEnabled)
        //{

        //    m_dates = new CListDate();
        //    ListDates.check(a_date);

        //    m_files = new CListFile();
        //    Files.@add(new CFile(a_file));

        //    m_ref = a_ref;
        //    m_infos = a_info;

        //    m_classement = new CPieceClassement(a_rating);
        //    m_duration = a_duration;
        //    if (a_bEnabled)
        //    {
        //        m_Enabled.True();
        //    }
        //    else
        //    {
        //        m_Enabled.False();
        //    }
        //    valueChangedHandler();

        //}

        #endregion


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(ITrackMetaData other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.Location) || m_ref.DefinedEquals(other.Artist, other.Album, other.Name, other.TrackNumber));
        //}


        /// <summary>
        /// vérifie si les deux pieces n'en sont qu'une
        /// </summary>
        /// <param name="other"></param>
        /// <returns>True si doublon</returns>
        /// <remarks></remarks>
        //public bool checkIdentity(CPiece other)
        //{
        //    return (Files.HasOnePathInCommonWith(other.m_files) || m_ref.DefinedEquals(other.m_ref));
        //}

        public bool checkFile(CPiece other)
        {
            return Files.HasOnePathInCommonWith(other.Files);
        }



        private void raiseChangeRefEvent()
        {
            if (isRefchanged)
            {
                isRefchanged = false;
                OnReferenceChanged();
            }
        }

        /// <summary>
        /// rapatrie les info d'une piece vers l'autre
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>cas d'égalité enre les deux : doublons de la même liste</remarks>

        public void merge(CPiece other)
        {

            if (!m_ref.AlbumData.choose(other.m_ref.AlbumData))
            {
                log("merge album between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.AlbumData.mergeManual(other.m_ref.AlbumData);
            }

            if (!m_ref.ArtistData.choose(other.m_ref.ArtistData))
            {
                log("merge artist between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.ArtistData.mergeManual(other.m_ref.ArtistData);
            }
            if (!m_ref.NameData.choose(other.m_ref.NameData))
            {
                log("merge name between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.NameData.mergeManual(other.m_ref.NameData);
            }
            if (!m_ref.TrackData.choose(other.m_ref.TrackData))
            {
                log("merge trackNumber between " + this.PathAndRef + " and " + other.PathAndRef);
                m_ref.TrackData.mergeManual(other.m_ref.TrackData);
            }




            if (!m_infos.YearData.choose(other.m_infos.YearData))
            {
                log("merge infos between " + this.ToString() + "[" + this.Year + "]" + " and " + other.ToString() + "[" + other.Year + "]");
                m_infos.YearData.mergeManual(other.m_infos.YearData);
            }

            if (!Classement.choose(other.Classement))
            {
                log("merge classement between " + this.ToString() + "[" + this.ClassList + ":" + this.Rating + "]" + " and " + other.ToString() + "[" + other.ClassList + ":" + other.Rating + "]");
                Classement.mergeManual(other.Classement);
            }

            addData(other);
            raiseChangeRefEvent();
        }


        /// <summary>
        /// Simple ajout de données venant du doublon
        /// </summary>
        /// <param name="other"></param>
        /// <remarks>Utilisé par legacy pour génération d'une liste propre à partir de la liste native
        /// Les fichiers auront préalablement été triés par classement</remarks>
        public void mergeDataFrom(CPiece other)
        {
            try
            {
                m_ref.mergeDataFrom(other.m_ref);
                m_infos.YearData.mergeAll(other.m_infos.YearData, mergePriority.none);
                Classement.mergeAll(other.Classement, mergePriority.none);

                addData(other);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + @"\r\n" + other.ToString() + @"\r\n" + e.ToString());
            }
        }


        // <summary>
        // addition sans collision des dates et fichiers
        // </summary>

        // <remarks></remarks>

        public void addData(CPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);
        }


        private void addDataLink(CPiece other)
        {
            m_dates.merge(other.m_dates);
            other.m_dates.merge(m_dates);

            m_files.merge(other.m_files);
            other.m_files.merge(m_files);
        }




        public void consolid(CPiece remote, mergePriority a_priority)
        {

            try
            {
                m_ref.consolid(remote.m_ref, a_priority);
                Classement.Consolid(remote.Classement, a_priority);
                m_infos.consolid(remote.m_infos, a_priority);

                Checked.Consolid(remote.Checked, a_priority);

                if (m_duration.TotalMilliseconds < 2)
                    this.m_duration = remote.m_duration;
                else if (remote.m_duration.TotalMilliseconds < 2)
                    remote.m_duration = this.m_duration;
                else if (a_priority == mergePriority.right)
                    m_duration = remote.m_duration;

                addData(remote);
                raiseChangeRefEvent();
            }
            catch (Exception e)
            {
                log("unable to merge " + this.ToString() + "\r\n" + remote.ToString() + "\r\n" + e.ToString());
            }
        }


        public mergePriority checklegacyModifString(CPieceData<String> data, String native)
        {

            mergePriority l_consistencyComp = data.Value.compareByConsistency(native);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (data.Imported) return mergePriority.right;
            return mergePriority.left;
        }


        /// <summary>
        /// piece de la liste native consolidée ou mise à jour 
        /// suivant le cas par le fichier maison
        /// </summary>
        /// <param name="native"></param>
        /// <remarks></remarks>
        public void legacyConsolid(CPiece l_native)
        {



            //TODO éviter de créer un objet juste pour la comparaison
            //en fait très complexe de casser le modèle. A la place, on abonne le track natif aux modifications éventuelles de la DB



            //this.grouping = l_native.Grouping;
            //this.m_comment = l_native.Comment; 







            l_native.m_ref.legacyConsolid(this.m_ref);
            l_native.m_infos.legacyConsolid(this.m_infos);

            l_native.setClassPlayList(this);
            l_native.Classement.LegacyConsolid(this.Classement);
            l_native.Checked.LegacyConsolid(this.Checked);

            //   native.synchroLegacy(this);  //plus besoin de synchro dans l'autre sens, on n'utilise pas l'objet créé ==> en fait si : on modifie directement le track

            addData(l_native);

            this.m_playList = l_native.PLayLists;
            this.m_classPlayLists = l_native.ClassPlayLists;
            this.m_duration = l_native.Duration;
            raiseChangeRefEvent();

            //On court-circuite la liste intermédiaire pour toujours pointer directement vers le trackInfoItunes
            this.native = l_native.native;

            checkNative();
        }

        /// <summary>
        /// Synchro directe entre la Db et le track Itunes (mode daemon)
        /// </summary>
        public void SynchroNative()
        {
            checkNative();
            if (native == null)
                return;

            m_ref.SynchroNative(native);
#if VOL
            m_infos.SynchroNative(native.Year, native.Volume);
#else
            m_infos.SynchroNative(native.Year);
#endif
            var newClassList = getClassName(native);
            Classement newCl = new Classement(newClassList, native.Rating);
            Classement.SynchroNative(newCl);
            Checked.SynchroNative(native.Enabled);

            this.ListDates.merge(native.PlayedDate);



            //  this.m_playList = native.PLayLists;
            this.m_classPlayLists = native.ClassPlayLists;
            if (native.Duration.TotalMilliseconds > 1)
                this.m_duration = native.Duration;
            raiseChangeRefEvent();
        }

        public void removeVersions()
        {
            m_ref.removeVersions();
            Classement.removeVersions();
        }

      

        public void Menage()
        {
            //  misc.log("ménage {0}", this); 
            Classement.Menage(this);
        }




        //public void synchroLegacy(CPiece native)
        //{
        //    this.m_classPlayLists = native.m_classPlayLists;

        //    this.ID = native.ID;
        //}

        private List<CPlayList> m_classPlayLists = new List<CPlayList>();
        private List<CPlayList> m_playList = new List<CPlayList>();
        public void AddPlayList(CPlayList a_playList)
        {
            if (a_playList.isClassSubList())
            {
                m_classPlayLists.Add(a_playList);
            }
            m_playList.Add(a_playList);
        }
        public void removePlayList(CPlayList list)
        {
            if (list.isClassSubList())
                m_classPlayLists.Remove(list);
            m_playList.Remove(list);
        }

        public bool belongsTo(string a_list)
        {
            foreach (CPlayList l_pl in m_playList)
            {
                if (l_pl.isSubList(a_list))
                    return true;
            }
            return false;
        }

        ////définit la liste qui le classe
        //public void setClassPlayList()
        //{
        //    int count =  m_classPlayLists.Count; 
        //    if (count > 0)
        //    {
        //        if (count > 1)
        //        {
        //            m_classPlayLists.Sort(new CPlayListComparer());
        //        }
        //        Classement.ClassList = m_classPlayLists[0].Name;
        //    }
        //}


        private void setClassPlayList(ITrackNative pieceDb)
        {
            string dbClasslist = pieceDb.ClassName;
            int count = m_classPlayLists.Count;
            if (count > 0)
            {
                string className = m_classPlayLists[0].Name;
                if (count > 1)
                {
                    m_classPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in m_classPlayLists)
                    {
                        className = list.Name;
                        if (className == dbClasslist)
                            continue;
                        break;
                    }
                }

                if (!className.Equals(Classement.Value.ClassList) && className.Equals(Classement.LastValue.ClassList))
                {
                    misc.log("Classement:setClassPlayList {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                    return;
                }

                Classement.ClassList = className;

            }
        }

        public string getClassName(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            var firstStep = getClassName_(native);
            if (!firstStep.Equals(Classement.Value.ClassList) && firstStep.Equals(Classement.LastValue.ClassList))
            {
                misc.log("Classement:getClassName {0} / {1} interdiction de revenir en arrière {2}", dbClasslist, Classement.LastValue.ClassList, this);
                return dbClasslist;
            }
            else
                return firstStep;
        }

        public string getClassName_(ITrackNative native)
        {
            string dbClasslist = this.ClassName;
            string className = dbClasslist;
            int count = native.ClassPlayLists.Count;
            if (count > 0)
            {
                className = native.ClassPlayLists[0].Name;
                if (count > 1)
                {
                    native.ClassPlayLists.Sort(new CPlayListComparer());
                    foreach (var list in native.ClassPlayLists)
                    {
                        className = list.Name;
                        if (className.Equals(dbClasslist))
                            continue;
                        break;
                    }
                }
            }
            return className;
        }

        //utilisé par le player maison
        public void setClassPlayList(String name)
        {
            Classement.ClassList = name;
            // TODO Gérer l'absence de classList
        }

        private CPlayList ClassPlayList
        {
            get
            {
                if (m_classPlayLists.Count > 0)
                    return m_classPlayLists[0];
                return null;
            }
        }

        public List<CPlayList> PLayLists { get { return m_playList; } }

        public String ClassName { get { return Classement.ClassList; } set { } }

        public List<CPlayList> ClassPlayLists
        {
            get
            {
                return m_classPlayLists;
            }
        }



        /// <summary>
        /// 
        /// </summary>
        /// <param name="a_sw"></param>
        /// <remarks></remarks>
        /// 
        #region IData Members
        public void write(ITextWriter a_sw)
        {
            XMLTool.openBalise(a_sw, TOKEN_PIECE);

            m_ref.write(a_sw);
            m_infos.write(a_sw);

            Classement.write(a_sw);

            Files.write(a_sw);
            ListDates.write(a_sw);

            if (!Checked.Enabled)
                XMLTool.writeValue(a_sw, TOKEN_DISABLED, true.ToString());
            if (artWork.NotNullOrEmpty())
                XMLTool.writeValue(a_sw, TOKEN_ARTWORK, artWork);
            if (m_duration.TotalMilliseconds > 1)
                XMLTool.writeValue(a_sw, TOKEN_DURATION, (int)m_duration.TotalMilliseconds);

            XMLTool.closeBalise(a_sw, TOKEN_PIECE);
        }




        public void write(XmlWriter w)
        {
            if (Location == @"E:\zique\The Beatles\09 The Beatles White Album 1\01 - Back In The U.S.S.R..mp3")
            {
            }
            try
            {
                w.WriteStartElement(TOKEN_PIECE);
                if (PieceId > 0)
                    w.WriteAttributeString("id", PieceId.ToString());
                if (parent != null)
                    w.WriteAttributeString("parent", parent.PieceId.ToString());
                if (parent == null)
                {
                    if (m_duration.TotalMilliseconds > 1)
                        w.WriteAttributeString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
                }

                m_ref.write(w);
                m_infos.write(w);

                if (parent == null)
                {
                    Classement.write(w);
                    Files.write(w);
                    ListDates.write(w);

                    if (!Checked.Enabled)
                        w.WriteElementString(TOKEN_DISABLED, "");
                }

             

                if (artWork.NotNullOrEmpty())
                    w.WriteElementString(TOKEN_ARTWORK, artWork);



                w.WriteEndElement();
            }
            catch (Exception ex)
            {
                misc.log("immpossible de sérialiser {0}", this);
                throw;
            }
        }

    
        public void writeDeleted(XmlWriter w)
        {
            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            w.WriteAttributeString("deleted", "true");
            w.WriteEndElement();

        }

        public void writeDiff(XmlWriter w, CPiece lastFull)
        {
            if (lastFull == null)
            {
                write(w);
                return;
            }

            if (!HasChange(lastFull))
                return;

            w.WriteStartElement(TOKEN_PIECE);
            if (PieceId > 0)
                w.WriteAttributeString("id", PieceId.ToString());
            if (parent != null)
                w.WriteAttributeString("parent", parent.PieceId.ToString());

            m_ref.writeDiff(w, lastFull.m_ref);
            m_infos.writeDiff(w, lastFull.m_infos);

            if (parent == null)
            {
                Classement.writeDiff(w, lastFull.Classement);
                Files.writeDiff(w, lastFull.Files);
                ListDates.writeDiff(w, lastFull.ListDates);

                if (!Checked.Enabled && lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "");

                if (Checked.Enabled && !lastFull.Checked.Enabled)
                    w.WriteElementString(TOKEN_DISABLED, "false");

                if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                    w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
            }

            


          

            w.WriteEndElement();
        }

        public bool HasChange(CPiece lastFull)
        {
            if (lastFull == null)
            {
                return true;
            }
            if (PieceParentId != lastFull.PieceParentId)
                return true;

            if (m_ref.HasChanged(lastFull.m_ref))
                return true;
            if (m_infos.HasChange(lastFull.m_infos))
                return true;

            if (parent == null)
            {
                if (Classement.HasChange(lastFull.Classement))
                    return true;
                if (Files.HasChange(lastFull.Files))
                    return true;
                if (ListDates.HasChange(lastFull.ListDates))
                    return true;
            }

            if (Checked.Enabled != lastFull.Checked.Enabled)
                return true;


            if (m_duration.TotalMilliseconds > 1 && (int)lastFull.m_duration.TotalMilliseconds != (int)m_duration.TotalMilliseconds)
                return true;

            return false;
        }

        #endregion

        public void setClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);
            if (cl.Equals(Classement.Value))
                return;
            Classement.Value = cl;

        }

        


        public CListFile Files
        {
            get { if (parent == null)return m_files; return parent.m_files; }
        }


        public IList<DateTime> Dates
        {
            get { return ListDates.Dates; }
        }

        public DateTime PlayedDate
        {
            get { return ListDates.LastModif; }
        }

        public string ClassList
        {
            get { return Classement.ClassList; }
        }

        public int Rating
        {
            get { return Classement.Rating; }
            set { Classement.Rating = value; }
        }

        public int RatingCmp
        {
            get
            {
                if (Rating < 0)
                    return 0;
                return Rating;
            }
        }
        public CPieceReference Reference
        {
            get { return m_ref; }
        }
        public string Name
        {
            get { return m_ref.Name; }
            set { m_ref.Name = value; }
        }
        public string Album
        {
            get { return m_ref.Album; }
            set
            {
                if (!m_ref.Album.Equals(value))
                {
                    m_ref.Album = value;
                    OnAlbumChanged(value);
                }
            }
        }
        public string Artist
        {
            get { return m_ref.Artist; }
            set
            {
                if (!m_ref.Artist.Equals(value))
                {
                    m_ref.Artist = value;
                    OnArtistChanged(value);
                }
            }
        }
        public int TrackNumber { get { return m_ref.TrackNumber; } set { m_ref.TrackNumber = value; } }
        public int DurationInSec
        {
            get { return Convert.ToInt32(Duration.TotalSeconds); }
        }
        //public TimeSpan Duration
        //{
        //    get { return m_duration; }
        //    set
        //    {
        //        if (value.TotalMilliseconds > 1)
        //            m_duration = value;
        //    }
        //}
        public int Year
        {
            get { return m_infos.Year; }
            set { m_infos.Year = value; }
        }
#if VOL
        public int Volume { get { return m_infos.Volume; } set { m_infos.Volume = value; } }
#endif
        public bool Enabled
        {
            get { return Checked.Enabled; }
            set
            {
                if (value)
                    Checked.Enable();
                else
                    Checked.Disable();
            }
        }
        public CPieceInfo Infos
        {
            get { return m_infos; }
        }

        public string ArtWork { get { return artWork; } set { artWork = value; } }


        /// <summary>
        /// ID interne
        /// </summary>
        /// <remarks></remarks>
        private int m_id = -1;
        private int parentID = -1;
        public int PieceId
        {
            get { return m_id; }
        }

        public int PieceParentId
        {
            get { return parentID; }
            set { parentID = value; }
        }

        public int MasterId
        {
            get
            {
                if (parentID < 0)
                    return m_id;
                return parentID;
            }
        }

        public CPiece Master
        {
            get
            {
                if (parent == null)
                    return this; 
                return parent;
            }
        }


        public void setId(int value)
        {
            if (m_id < 0)
            {
                m_id = value;
            }
        }

        public CPieceClassement Classement { get { if (parent == null) return m_classement; return parent.m_classement; } }
        public TimeSpan Duration
        {
            get { if (parent == null) return m_duration; return parent.m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    if (parent == null)
                        m_duration = value;
                    else
                        parent.m_duration = value; 
                }
            }
        }
        public CListDate ListDates { get { if (parent == null) return m_dates; return parent.m_dates; } }
        private CPieceChecked Checked { get { if (parent == null) return m_Enabled; return parent.m_Enabled; } }
        //  private CListFile Files { get { if (parent == null) return m_files; return parent.m_files; } }
        public Classement getClassement() { return Classement.Value; }


        public string getUri()
        {
            return Files.getUri();

            //string l_file = File;
            //if (l_file.Contains("file://"))
            //{
            //    return l_file;
            //}
            //else
            //{
            //    return CLegacy.DefaultFolder + File;
            //}

        }


        //Sub synchroClassFrom(ByVal a_list As CListPiece)
        //    Dim l_piece As CPiece = a_list.getPiece(Me)
        //    m_classement = l_piece.m_classement
        //End Sub

        public override string ToString()
        {
            return string.Format("{0} {1} {2} {3} {4} {5}", Classement.Value, PieceId, PieceParentId, Name, Album, Files.File); 
            String location = Location;
            return location == "" ? Files.File : location;
        }
        //public string File
        //{
        //    get { return Files.File; }
        //}
        public string PathAndRef
        {
            get { return Location + " " + m_ref.ToString(); }
        }
        private string _location;
        public string Location
        {

            get
            {
                if (_location == null)
                _location =  Files.Path;
                return _location; 


            }
        }
        public bool Exists { get { return Files.Exists; } }

        //public bool classListToUpdate()
        //{
        //    string l_strList = "";
        //    if (ClassPlayList != null)
        //        l_strList = ClassPlayList.Name;

        //    //if (Classement.Imported)
        //    //{
        //    if (l_strList != ClassList)
        //    {
        //        return true;
        //    }
        //    //}
        //    return false;
        //}

        private string _comment;
        public string Comment
        {
            get
            {
                if (parent != null)
                    return "";
                if (_comment == null)
                {
                    if (native != null)
                        _comment = native.Comment;
                }
                return _comment;

                //string l_pref = "";
                //string l_str = "";

                //string l_strList = "";
                //if (ClassPlayList != null)
                //    l_strList = ClassPlayList.Name;

                //if (Classement.Imported)
                //{
                //    if (l_strList != ClassList)
                //    {
                //        l_pref = "m (" + ClassList + ") ";
                //    }
                //}
                //int l_rank = m_rank.Twice;
                //if (l_rank > 0)
                //{
                //    if (l_rank < 1000)
                //    {
                //        if (CTuning.Total > 1000)
                //        {
                //            l_str += "0";
                //        }
                //        if (l_rank < 100)
                //        {
                //            l_str += "0";
                //            if (l_rank < 10)
                //            {
                //                l_str += "0";
                //            }
                //        }
                //    }

                //    double l_tx = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Goodness, CConf.Sort.Quality));
                //    double l_tx2 = Convert.ToInt32(100 * CTuning.RapportNorm(m_rank.Lenght, CConf.Sort.Length));
                //    //CInt(100 * CDbl(1 + CTuning.Total - m_rank.Lenght) / CTuning.Total)
                //    //getTx(m_rank.Lenght)
                //    l_str += l_rank.ToString() + "  " + l_tx.ToString() + " " + l_tx2.ToString() + "  " + l_strList + "." + (RatingCmp / 20).ToString();
                //}

                //return l_pref + l_str + getClassementEvol();

            }
            set
            {
                if (parent != null)
                    return;
                if (value != _comment)
                {
                    _comment = value;
                    //if (value != Comment)
                    //{
                    // m_comment = value;
                    OnCommentChange(value);
                }
                // }
            }
        }
        private string _grouping;
        public string Grouping
        {
            get
            {
                if (_grouping == null)
                {
                    if (native != null)

                        _grouping = native.Grouping;
                }
                return _grouping;
            }
            //set
            //{
            //    //if (value != Grouping)
            //    //{
            //    //  grouping = value;
            //    OnGroupingChange(value);
            //    //}
            //}
        }

        public void setGrouping(string value, bool prior)
        {
            if (value != _grouping)
            {
                _grouping = value;
                OnGroupingChange(value, prior);
            }
        }

        //private static double getTx(int rank)
        //{
        //    if (rank <= 0)
        //        return 0;
        //    return (Math.Log(Convert.ToDouble(CTuning.Total) / Convert.ToDouble(rank)) / Math.Log(2));
        //}

        //public int QRank
        //{
        //    get { return m_rank.Goodness; }
        //    set { m_rank.Goodness = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}




        /// <summary>
        /// la classList est-elle numérique?
        /// </summary>
        public bool isClassListNumeric
        {
            get
            {
                return Classement.isClassListNumeric;
            }
        }

        //  public String ClassNameAndRating { get { return Classement.ClassNameAndRating; } }



        #region "calcul liste dynamiques"
        // Private m_bCanPlay As Boolean = True
        public delegate bool canPlayDel(int a_base);
        //public bool canPlay(int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    if (a_base <= 0)
        //        return true;
        //    DateTime now = DateTime.Now;
        //    bool l_bRet = ListDates.canPlay(now, Delta, a_base);
        //    if (!l_bRet)
        //    {
        //        Console.WriteLine(" " + Comment + " " + Location);
        //    }

        //    return l_bRet;
        //}

        // private CListDate m_datesModifClassement = null;
        private CListDate DatesClassement_
        {
            get
            {
                //if (m_datesModifClassement == null)
                //    m_datesModifClassement = Classement.Dates;
                return Classement.Dates;
            }
        }

        //public bool mustPlayToPreciseClassement(DateTime now, int a_base)
        //{
        //    if (m_rank.Goodness < 1)
        //        return false;

        //    bool bRet = !DatesClassement.canPlay(now, Delta, a_base);
        //    bool bLastModif = DatesClassement.LastModif > DatesPlayed.LastModif;


        //    if (CConf.CheckModifStrict)
        //        // on ne retient que s'i n'a pas été lu depuis la dernière modif.
        //        // encore en cours : j'écoute puis je modifie
        //        bRet = bRet && bLastModif;

        //    if (a_base == 0)
        //        return bLastModif;
        //    return bRet;
        //}

        public String getClassementEvol()
        {
            DateTime playedCorr = ListDates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= m_duration;
            }
            catch (Exception)
            {
                logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, m_duration);
            }
            if (DatesClassement_.LastModif > playedCorr)
            {
                return Classement.Evol;
            }
            return "";

        }

        public static double LogBase = 2.0;
        public static double Scale = 0.1;
        //private TimeSpan Delta
        //{

        //    get
        //    {
        //        if (m_rank.Goodness < 0)
        //            return TimeSpan.MaxValue;
        //        long l_ticks = Convert.ToInt64(new TimeSpan(1, 0, 0, 0).Ticks * Scale);

        //        double r = CPieceInListComparer.Calc(this, CConf.Select);
        //        //     Rapport(m_rank.Goodness, CConf.Sort.Quality)
        //        if (r == -1)
        //            return TimeSpan.MaxValue;

        //        long l_nt = long.MaxValue;
        //        try
        //        {
        //            l_nt = Convert.ToInt64(l_ticks / r);
        //        }
        //        catch (Exception ex)
        //        {
        //        }

        //        return new TimeSpan(l_nt);
        //    }
        //}



        //Sub reinitCanPlay()
        //    m_bCanPlay = True
        //End Sub

        #endregion

        #region "COM"

        //public void checkComRating(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        if (Rating < 0)
        //            return;
        //        //if (!Classement.Imported)
        //        //    return;

        //        int l_trackRating = a_track.Rating;
        //        if (l_trackRating != Rating)
        //        {
        //            log("change rating from " + l_trackRating + " to " + Rating + " " + Location);
        //            a_track.Rating = Rating;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Rating {0} for {1}", Rating, this);
        //    }

        //}


        //public void checkComInfo(ITrackMetaData a_track)
        //{
        //    try
        //    {
        //        //if (!m_infos.YearData.Imported)
        //        //    return;
        //        if (Year <= 0) return;
        //        if (a_track.Year != Year)
        //        {
        //            log("change year from " + a_track.Year + " to " + Year + " " + Location);
        //            a_track.Year = Year;
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Year {0} for {1}", Year, this);
        //    }

        //}

        //public void checkComRef(ITrackMetaData a_track)
        //{

        //    if (m_ref == null)
        //        return;


        //    string l_trackArtist = a_track.Artist.TrimSafe();
        //    string l_trackAlbum = a_track.Album.TrimSafe();
        //    string l_trackName = a_track.Name.TrimSafe();
        //    int l_trackNumber = a_track.TrackNumber;

        //    if (l_trackArtist != m_ref.Artist)// && m_ref.ArtistData.Imported)
        //    {
        //        log("change Artist from " + l_trackArtist + " to " + m_ref.Artist + " " + Location);
        //        try { a_track.Artist = m_ref.Artist.TrimSafe(); }
        //        catch { misc.log("unable to change Artist {0} for {1}", Artist, this); }
        //    }
        //    if (l_trackAlbum != m_ref.Album) // && m_ref.AlbumData.Imported)
        //    {
        //        log("change Album from " + l_trackAlbum + " to " + m_ref.Album + " " + Location);
        //        try { a_track.Album = m_ref.Album; }
        //        catch { misc.log("unable to change Album {0} for {1}", Album, this); }
        //    }
        //    if (l_trackName != m_ref.Name) // && m_ref.NameData.Imported)
        //    {
        //        log("change Name from " + l_trackName + " to " + m_ref.Name + " " + Location);
        //        try
        //        {
        //            a_track.Name = m_ref.Name.TrimSafe();
        //        }
        //        catch { misc.log("unable to change Name {0} for {1}", Name, this); }
        //    }
        //    if (l_trackNumber != m_ref.TrackNumber && TrackNumber >= 0)//&& m_ref.TrackData.Imported)
        //    {
        //        log("change Track from " + l_trackNumber + " to " + m_ref.TrackNumber + " " + Location);
        //        try { a_track.TrackNumber = TrackNumber; }
        //        catch { misc.log("unable to change TrackNumber {0} for {1}", TrackNumber, this); }
        //    }


        //}


        //public void checkComComment(ITrackMetaData a_track)
        //{
        //    try
        //    {

        //        string l_pieceComment = Comment.Trim();
        //        String l_trackComment = a_track.Comment;
        //        if (l_trackComment == null) l_trackComment = "";
        //        l_trackComment = l_trackComment.Trim();
        //        if (l_trackComment != l_pieceComment)
        //        {
        //            misc.logNoDate("write comment from " + a_track.Comment + " to " + l_pieceComment + " " + Location);
        //            // If l_pieceComment.Trim = "" Then Throw New ApplicationException(Me.ToString() & " set comment to null")
        //            a_track.Comment = l_pieceComment;
        //        }

        //    }
        //    catch (Exception e)
        //    {
        //        misc.log("unable to change Comments {0} for {1}", Comment, this);
        //    }
        //}

        //public void checkComEnabled(ITrackMetaData a_track)
        //{
        //    if (m_Enabled.isFalse && a_track.Enabled)
        //    {
        //        misc.log("disable {0}", this);
        //        a_track.Enabled = false;
        //    }
        //}

        //public void checkComDate(ITrackInfo a_track)
        //{
        //    //Dim l_date As String = a_track.EQ

        //}
        #endregion


        public bool isPodcast
        {
            get { return Files.isPodcast; }
        }
        private void log(String txt)
        {
            logTrack.log(txt);
        }



        List<DateTime> ITrackPlayedDates.Dates
        {
            get { return new List<DateTime>(ListDates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return new List<DateTime>(DatesClassement_.Dates); }
        }

        public DateTime LastModifClass { get { return m_classement.LastModif; } }

        public string ClassEvol
        {
            get { return getClassementEvol(); }
        }





        public void changeNativeValueAlbum(string value)
        {
            if (native == null)
                return;
            native.Album = value;
        }

        public void changeNativeValueArtist(string value)
        {
            if (native == null) return; native.Artist = value;
        }

        public void changeNativeValueName(string value)
        {
            if (native == null) return; native.Name = value;
        }

        public void changeNativeValueTrack(int value)
        {
            if (native == null) return; native.TrackNumber = value;
        }

        public void changeNativeValueYear(int value)
        {
            if (native == null) return; native.Year = value;
        }

        public void changeNativeValueClassement(Classement value)
        {
            if (native == null)
                return;
            native.Rating = value.Rating; native.ClassName = value.ClassList;
        }
#if VOL
        public void changeNativeValueVolume(int value)
        {
            if (native == null) return;
            native.Volume = value;
        }
#endif

        public void changeByRemote(string type, object Old, object New)
        {
            logChange("change by remote", type, Old, New);
        }

        public void changeByNative(string type, object Old, object New)
        {
            logChange("change by native", type, Old, New);
        }

        private bool isRefchanged;
        public void RefChange()
        {
            isRefchanged = true;
        }

        public void unCheck()
        {
            if (native == null) return; native.Enabled = false;
        }

        public void changeLocalValueByRemoteAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByRemoteClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void changeLocalValueByNativeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeAlbum(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeArtist(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeName(string Old, string New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeTrack(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeYear(int Old, int New)
        {
            throw new NotImplementedException();
        }

        public void cannotMergeClassement(Classement Okd, Classement New)
        {
            throw new NotImplementedException();
        }

        public void change()
        {
            throw new NotImplementedException();
        }

        public void setClassement(string className, int rating)
        {
            Classement.setClassement(className, rating);
        }

        public string StrClassement
        {
            get
            {
                return Classement.ToString();
            }
            set
            {
                setClassement(value);
            }
        }

        public long Size
        {
            get
            {
                var ret = Files.Size;
                if (ret <= 0)
                    return 0;
                return ret;
            }
        }

        public string DirAndFileName
        {
            get
            {
                return Files.DirAndFileName;
            }
        }
        private CPiece parent;
        public CPiece Parent
        {
            get { return parent; }
            set
            {
                var _oldParent = parent;

                if (value == null)
                {
                    parent = null;
                    PieceParentId = -1;
                    if (_oldParent != null)
                    {
                        addDataLink(_oldParent);
                    }
                    return;
                }
                else
                {
                    parent = value.Master; 
                }
                parent.addDataLink(this);
                PieceParentId = parent.PieceId;

            }
        }

        private bool deleted;
        public bool Deleted
        {
            get { return deleted; }
            set
            {
                if (value != deleted)
                {
                    if (value)
                        misc.log("Suppression de {0}", this);
                    deleted = value;
                }
            }
        }

        private List<string> _RelativesPath;
        public List<string> RelativesPath
        {
            get
            {
                if (_RelativesPath == null)
                {
                    _RelativesPath = new List<string>();
                    foreach (CFile f in m_files)
                    {
                        _RelativesPath.Add(f.File);
                    }
                }
                return _RelativesPath;
            }
        }


        private exportState _exportState; 
        public exportState ExportStatus
        {
            get
            {
                return _exportState; 
            }
            set
            {
                _exportState = value; 
            }
        }
    }
}






]]></content>
  </file>
</db>
