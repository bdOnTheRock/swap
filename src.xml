<db path="C:\bernard\db2\">
  <file path="buro\buroSimple\Program.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;

namespace buroSimple
{
    class Program
    {
        static List<string> getList(string arg)
        {
            List<string> l = new List<string>();

            var tab = arg.Split(';');
            foreach (string s in tab)
            {
                if (!string.IsNullOrEmpty(s))
                    l.Add(s.ToLower());
            }
            return l;
        }

        static void Main(string[] args)
        {
            int countArgs = args.GetLength(0);
            double delay = 20.0;
            double delayFast = 1.0;
            double abortScan = -1;
            bool unique = false;
            bool sortBySize = false;
            bool uniqueName = false;
            bool reverse = false;
            bool fullscreen = false;
            bool highResolution = false;
            bool combine = false;
            bool oneScreen = false;
            bool checkScreen = false;
            bool displayImgError = false;
            bool scanImgError = false;

            bool modul = false;
            bool useMem = false;

            List<string> include = null;
            List<string> exclude = null;

            for (int i = 0; i < countArgs; i++)
            {
                var arg = args[i];

                switch (arg)
                {
                    case "-t":
                    if (i + 1 < countArgs)
                    {
                        delay = Convert.ToDouble(args[i + 1]);
                    }
                    break;
                    case "-tt":
                    if (i + 1 < countArgs)
                    {
                        delayFast = Convert.ToDouble(args[i + 1]);
                    }
                    break;

                    case "-i":
                    if (i + 1 < countArgs)
                    {
                        include = getList(args[i + 1]);
                    }
                    break;

                    case "-e":
                    if (i + 1 < countArgs)
                    {
                        exclude = getList(args[i + 1]);
                    }
                    break;

                    case "-a":
                    if (i + 1 < countArgs)
                    {
                        abortScan = Convert.ToDouble(args[i + 1]);
                    }
                    break;




                    case "/u": unique = true; break;
                    case "/s": sortBySize = true; break;
                    case "/c": combine = true; break;
                    case "/un": uniqueName = true; break;
                    case "/r": reverse = true; break;
                    case "/fs": fullscreen = true; break;
                    case "/hr": highResolution = true; break;
                    case "/os": oneScreen = true; break;
                    case "/cs": checkScreen = true; break;
                    case "/de": displayImgError = true; break;
                    case "/se": scanImgError = true; break;                  
                    case "/m": modul = true; break;
                    case "/mem": useMem = true; break;

                }
            }

            //var test = buroSimpleLib.ImageUtil.Scale(@"C:\temp\pochette.jpg", 2); 
            //test.Save(@"C:\temp\pochetteScaled.bmp", System.Drawing.Imaging.ImageFormat.Bmp); 
            var wp = new Walpaper()
            {
                delay = delay,
                delayFast = delayFast,
                unique = unique,
                sortBySize = sortBySize,
                uniqueName = uniqueName,
                reverse = reverse,
                fullscreen = fullscreen,
                highResolution = highResolution,
                combine = combine,
                oneScreen = oneScreen,
                checkScreen = checkScreen,
                include = include,
                exclude = exclude,
                displayImgError = displayImgError,
                scanImgError = scanImgError,
                abortScan = abortScan,
                modul = modul,
                useMem = useMem
            };
            wp.go();
        }
    }

}
]]></content>
  </file>
  <file path="buro\buroSimple\Walpaper.cs">
    <content><![CDATA[using buroSimpleLib;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Threading;
using pdb.util;
using Math = System.Math;

namespace buroSimple
{
    class Walpaper
    {
        int HAUTEUR;
        int LARGEUR;
        readonly string TMP_FILE; // = @"C:\Temp\wp.bmp";
        readonly string TMP_FILE1; //= @"C:\Temp\wp1.bmp";
        readonly string TMP_FILE2; // = @"C:\Temp\wp2.bmp";
        readonly string TMP_PREPAR; //= @"C:\Temp\wpp.bmp";
        readonly string INDEX_FILE; //= @"C:\Temp\wp.index.txt";
        readonly string TMP_LOADED; //= @"C:\Temp\Loaded";
        readonly string TMP_LOADED_MINI; //= @"C:\Temp\Loaded\Mini";
        readonly string HISTO;// @"C:\Temp\WP_HISTO\";
        readonly string DB;

        /// <summary>
        /// delai en secondes entre deux refreh
        /// </summary>
        public double delay = 30;
        /// <summary>
        /// On ne prend qu'un exemplaire pour une taille donnée
        /// </summary>
        public bool unique = false;
        /// <summary>
        /// Try par taille
        /// </summary>
        public bool sortBySize = false;
        /// <summary>
        /// On considère suex fichiers de même taille et de même nom comme identiques
        /// </summary>
        public bool uniqueName = false;
        /// <summary>
        /// tri inversé
        /// </summary>
        public bool reverse = false;
        /// <summary>
        /// On tente de recreer une image à la taille de l'écran
        /// </summary>
        public bool fullscreen = false;
        /// <summary>
        /// On tente d'utiliser les valeurs &
        /// </summary>
        public bool highResolution = false;
        /// <summary>
        /// tri par pixel et taille
        /// </summary>
        public bool combine = false;
        /// <summary>
        /// Un seul grand écran 
        /// </summary>
        public bool oneScreen = false;
        /// <summary>
        /// Vérification recouvrement 
        /// </summary>
        public bool checkScreen = false;
        /// <summary>
        /// delai après une image floue;
        /// </summary>
        public double delayFast = 1.0;

        /// <summary>
        /// répertoires permis
        /// </summary>
        public List<string> include;
        /// <summary>
        /// Répertoires défendus
        /// </summary>
        public List<string> exclude;

        /// <summary>
        /// En mode fs affiche les images floues
        /// </summary>
        public bool displayImgError = false;
        /// <summary>
        /// en mode fs, vérifie les doublons
        /// </summary>
        public bool scanImgError = false;
        /// <summary>
        /// En cas de vérification trop longue, on interrompt la verif d'identité
        /// </summary>
        public double abortScan = -1;
        /// <summary>
        /// Modulation du délai: on privilégie les carrés
        /// </summary>
        public bool modul;

        /// <summary>
        /// Pour les disques lents: on met les fichiers en mémoire
        /// </summary>
        public bool useMem;

        private bool GO;

        private void checkSession()
        {
            while (currentSwitchSessionStatus != SessionSwitchReason.SessionLogon
                 && currentSwitchSessionStatus != SessionSwitchReason.SessionUnlock)
            {
                Console.WriteLine("Pause reason " + currentSwitchSessionStatus);
                Thread.Sleep(1000);
            }
        }

        public Walpaper()
        {

            var strDir = DirUtil.GetAppDir();
            TMP_FILE = strDir + "wp.bmp";
            TMP_FILE1 = strDir + "wp1.bmp";
            TMP_FILE2 = strDir + "wp2.bmp";
            TMP_PREPAR = strDir + "wpp.bmp";
            INDEX_FILE = strDir + "wp.index.txt";
            TMP_LOADED = strDir + "Loaded";
            TMP_LOADED_MINI = strDir + @"Loaded\Mini";
            HISTO = strDir + @"WP_HISTO\";
            DB = strDir + "buro1.txt";
        }

        public void go()
        {
            if (!Directory.Exists(HISTO))
                Directory.CreateDirectory(HISTO);
            GO = true;
            DirectoryInfo loaded = new DirectoryInfo(TMP_LOADED);
            if (!loaded.Exists)
                loaded.Create();

            DirectoryInfo loadedMini = new DirectoryInfo(TMP_LOADED_MINI);
            if (!loadedMini.Exists)
                loadedMini.Create();


            SystemEvents.PowerModeChanged += new PowerModeChangedEventHandler(SystemEvents_PowerModeChanged);
            SystemEvents.SessionSwitch += SystemEvents_SessionSwitch;


            DateTime nextFlash = DateTime.Now;
            DateTime nextAbort = DateTime.Now;

            ImageUtil.UseMem = useMem;
            bool first = true;



            HAUTEUR = ScreenUtil.Hauteur;
            LARGEUR = ScreenUtil.Largeur;
            var list = new List<FileDto>();
            using (StreamReader sr = new StreamReader(DB))
            {
                string line = "";
                while ((line = sr.ReadLine()) != null)
                {
                    if (string.IsNullOrEmpty(line))
                        continue;

                    try
                    {
                        FileDto fd = FileDto.FromLine(line); //  new FileDto() { Path = tab[0], Size = Convert.ToInt64(tab[1]) };
                        if (fd != null)
                        {
                            bool go = true;
                            string path = fd.Path.ToLower();
                            if (exclude != null)
                            {
                                foreach (string ex in exclude)
                                {
                                    if (path.StartsWith(ex))
                                    {
                                        go = false;
                                        break;
                                    }
                                }
                            }
                            if (!go)
                                continue;
                            if (include != null)
                            {
                                go = false;
                                foreach (string str in include)
                                {
                                    if (path.StartsWith(str))
                                    {
                                        go = true;
                                        break;
                                    };
                                }
                            }
                            if (!go)
                                continue;
                            list.Add(fd);
                        }
                    }
                    catch
                    {
                    }

                }
            }

            list.Sort((x, y) =>
            {
                int cmp = 0;
                if (sortBySize)
                {
                    cmp = x.Size.CompareTo(y.Size);
                    if (cmp != 0)
                        return cmp;
                    if (combine)
                        cmp = x.Pixels().CompareTo(y.Pixels());
                    if (cmp != 0)
                        return cmp;
                    cmp = x.Width.CompareTo(y.Width);
                }
                else
                {
                    cmp = x.Pixels().CompareTo(y.Pixels());
                    if (cmp != 0)
                        return cmp;
                    cmp = x.Width.CompareTo(y.Width);
                    if (cmp != 0)
                        return cmp;
                    if (combine)
                        cmp = x.Size.CompareTo(y.Size);
                }

                if (cmp != 0)
                    return cmp;
                return x.Path.CompareTo(y.Path);
            });

            if (reverse)
                list.Reverse();

            int count = list.Count;

            string path0 = "";
            int index0 = -1;
            if (File.Exists(INDEX_FILE))
            {
                path0 = File.ReadAllText(INDEX_FILE).Trim();
            }

            if (!string.IsNullOrEmpty(path0))
            {
                for (int i = 0; i < count; i++)
                {
                    if (list[i].Path == path0)
                    {
                        index0 = i;
                        break;
                    }
                }
            }

            HashSet<string> hs = new HashSet<string>();
            int pixels = -1;
            int width = -1;
            long size = -1;
            int nbLoaded = 0;
            bool checkScreen = this.checkScreen;
            bool errorFs = false;

            DateTime last = DateTime.Now;
            FileDto lastF = null;
            if (File.Exists(TMP_FILE))
                File.Delete(TMP_FILE);
            for (int i = index0 + 1; i < count; i++)
            {
                while (!GO)
                {
                    Thread.Sleep(1000);
                }

                checkSession();



                FileDto f = list[i];
                Console.WriteLine("candidat " + f);
                var fpixels = f.Pixels();
                var fwidth = f.Width;
                bool change = false;
                bool sizeChanged = f.Size > size;
                bool pixelChanged = fpixels > pixels || fwidth != width;

                if (combine)
                    change = sizeChanged || pixelChanged;
                else if (sortBySize)
                    change = sizeChanged;
                else
                    change = pixelChanged;
                if (change)
                {
                    hs.Clear();
                    size = f.Size;
                    width = f.Width;
                    if (fpixels > pixels)
                    {
                        if (pixels > 0)
                            File.Copy(INDEX_FILE, HISTO + pixels + "_wp.index.txt", true);

                    }
                    if (fwidth != width)
                        width = fwidth;
                    if (pixels > 0)
                    {
                        ImageUtil.ClearMem();
                        foreach (FileInfo fl in loaded.GetFiles())
                        {
                            fl.Delete();
                        }
                        foreach (FileInfo fl in loadedMini.GetFiles())
                        {
                            fl.Delete();
                        }

                    }
                    pixels = fpixels;
                    nbLoaded = 0;
                }
                else
                {
                    if (unique)
                        continue;
                }
                string fileName = Path.GetFileName(f.Path);
                if (hs.Contains(fileName))
                    continue;
                //  bool abortScan = this.abortScan && errorFs;
                errorFs = false;
                try
                {
                    Image img = null;
                    if (fullscreen)
                    {
                        try
                        {
                            img = createFileFs(f);
                        }
                        catch (Exception ex)
                        {
                            errorFs = true;
                            Console.WriteLine(ex.Message);
                        }
                    }
                    if ((errorFs && displayImgError) || !fullscreen)
                        img = createFile(f);
                    if (img != null)
                    {
                        bool ok = true;
                        DirectoryInfo d = loaded;
                        if (errorFs)
                            d = loadedMini;
                        bool scanAborted = false;
                        var files = d.GetFiles().ToList();
                        files.Sort((x, y) => -x.LastWriteTime.CompareTo(y.LastWriteTime));
                        var next = nextAbort;
                        if (first)
                        {
                            first = false;
                            next = next.AddSeconds(abortScan);
                        }
                        foreach (FileInfo fl in files)
                        {
                            if (abortScan >0 && DateTime.Now > next)
                            {
                                Console.WriteLine(">>>>>>>>>>>>>>>>>scan aborted");
                                scanAborted = true;
                                break;
                            }
                            if (ImageUtil.AreIdentical(img, fl.FullName))
                            {
                                ok = false;
                                break;
                            }
                        }
                        img.Dispose();

                        if (ok)
                        {
                            Console.WriteLine();
                            Console.WriteLine("----------------------------------------------------------");
                            if (lastF != null)
                                Console.WriteLine("courant:{0}", lastF);
                            Console.WriteLine("à venir:{0}", f);
                            Console.WriteLine("Attente:{0} Traitement:{1}", (nextFlash - DateTime.Now).toString(), (DateTime.Now - last).toString());

                            checkSession();
                            while (DateTime.Now < nextFlash)
                            {
                                Thread.Sleep(30);
                                checkSession();
                            }
                            Console.WriteLine("----------------------------------------------------------");
                            if (checkScreen)
                            {
                                if (File.Exists(TMP_FILE))
                                {
                                    while (ScreenUtil.isRecovered(TMP_FILE, oneScreen))
                                    {
                                        Console.WriteLine("Pause reason Recovered");
                                        Thread.Sleep((int)(1000 * System.Math.Max(1, delay)));
                                    }
                                }
                            }
                            last = DateTime.Now;
                            File.Copy(TMP_PREPAR, TMP_FILE, true);
                            WinAPI.BmpLoad(TMP_FILE);
                            lastF = f;
                            nbLoaded++;
                            if (!scanAborted && (!errorFs || scanImgError))
                                File.Copy(TMP_FILE, d.FullName + "\\" + Path.GetFileName(f.Path) + "_" + nbLoaded + ".bmp", true);
                            File.WriteAllText(INDEX_FILE, f.Path);
                            double delta = errorFs ? delayFast : delay;
                            if (modul)
                            {
                                var dimMin = Math.Min(f.Width, f.Height);
                                var coeff = Math.Sqrt(f.Pixels()) / dimMin;
                                delta /= coeff;
                            }
                            nextFlash = DateTime.Now.AddSeconds(delta);
                            nextAbort = DateTime.Now.AddSeconds(abortScan);

                            if (uniqueName)
                                hs.Add(fileName);

                            checkScreen = this.checkScreen && !errorFs;

                        }
                        else
                        {
                            Console.WriteLine("Identique " + f);
                            continue;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Blank " + f);
                        continue;
                    }

                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            }
        }
        private SessionSwitchReason currentSwitchSessionStatus = SessionSwitchReason.SessionLogon;
        private void SystemEvents_SessionSwitch(object sender, SessionSwitchEventArgs e)
        {
            Console.WriteLine("SystemEvents_SessionSwitch:" + e.Reason);
            currentSwitchSessionStatus = e.Reason;

        }

        void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)
        {
            Console.WriteLine("SystemEvents_PowerModeChanged:" + e.Mode.ToString());
            if (e.Mode == PowerModes.Resume)
                GO = true;
            else GO = false;
        }

        private void paramGr(Graphics graphics)
        {
            graphics.CompositingMode = CompositingMode.SourceCopy;
            graphics.CompositingQuality = CompositingQuality.AssumeLinear;
            graphics.InterpolationMode = InterpolationMode.NearestNeighbor;
            graphics.SmoothingMode = SmoothingMode.None;
            graphics.PixelOffsetMode = PixelOffsetMode.None;
        }

        private Image createFileFs(FileDto f)
        {
            Image img = Image.FromFile(f.Path);
            Bitmap bmp = new Bitmap(img.Width, img.Height);
            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.DrawImage(img, 0, 0);
            }

            img.Dispose();
            img = bmp;

            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}={1}x{2} {3} {4}", largeur0 * hauteur0, largeur0, hauteur0, f.HumanReadableSize, img.PixelFormat);

            double r0 = (double)HAUTEUR / (double)LARGEUR;
            double r = (double)hauteur0 / (double)largeur0;

            //facteur d'augmentation
            int scale = 1;

            //1. on teste blank
            int largeurTrame;
            int hauteurTrame;

            Bitmap trame;
            img.Save(TMP_FILE1, ImageFormat.Bmp);
            var imgVerif = ImageUtil.Scan(TMP_FILE1);
            if (imgVerif == null)
            {
                return null;
            }


            imgVerif.Dispose();

            int l = largeur0;
            int h = hauteur0;
            //int l0 = l;
            //int h0 = h;
            ////Image currentImage = img;
            //while (true)
            //{
            //    l *= 2;
            //    if (l > LARGEUR)
            //        break;
            //    h *= 2;
            //    if (h > HAUTEUR)
            //        break;
            //    l0 = l;
            //    h0 = h;
            //}

            if (r > r0)
                scale = HAUTEUR / hauteur0;
            else
                scale = LARGEUR / largeur0;

            l *= scale;
            h *= scale;

            //l=l0; 
            //h=h0; 

            //var trameInter = new Bitmap(l, h, img.PixelFormat);
            //using (Graphics g = Graphics.FromImage(trameInter))
            //{
            //    paramGr(g);
            //    //int _xrec = (int)((LARGEUR - l) / 2.0);
            //    //int _yrec = (int)((HAUTEUR - h) / 2.0);
            //    //Rectangle _centré = new Rectangle(_xrec, _yrec, l, h);
            //    Rectangle rect = new Rectangle(0, 0, l, h);
            //    // g.DrawImageUnscaledAndClipped(img, _centré);
            //   // g.DrawImageUnscaledAndClipped(img, rect);
            // g.DrawImage(img, rect, 0,0, l,h, GraphicsUnit.Pixel); 
            // //    g.DrawImage(img, rect); 

            //  //  trameInter.Dispose();
            //    // img.Dispose();


            //   // return Image.FromFile(TMP_FILE);
            //}
            var trameInter = img;
            if (scale > 1)
            {
                trameInter = ImageUtil.Scale(img, scale);
            }

            img.Dispose();
            trameInter.Save(TMP_FILE2, ImageFormat.Bmp);


            imgVerif = ImageUtil.Scan(TMP_FILE2);
            imgVerif.Dispose();


            if (imgVerif == null)
            {
                return null;
            }


            if (r > r0)
            {
                // image pas assez large --> ajout largeur



                hauteurTrame = HAUTEUR;
                largeurTrame = Convert.ToInt32(LARGEUR * r0 / r); //   Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = LARGEUR;
                hauteurTrame = Convert.ToInt32(HAUTEUR * r / r0);
            }

            trame = new Bitmap(LARGEUR, HAUTEUR);
            Graphics graphics = Graphics.FromImage(trame);
            paramGr(graphics);
            int xrec = (int)((LARGEUR - largeurTrame) / 2.0);
            int yrec = (int)((HAUTEUR - hauteurTrame) / 2.0);



            // var abort = new Image.GetThumbnailImageAbort(ThumbnailCallback);
            //var thumbnail = img.GetThumbnailImage(largeurTrame , hauteurTrame, abort, IntPtr.Zero);

            Rectangle centré = new Rectangle(xrec, yrec, largeurTrame, hauteurTrame);
            // graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);
            // Rectangle all = new Rectangle(0,0,LARGEUR, HAUTEUR); 
            //graphics.DrawImage(img, centré);
            graphics.DrawImageUnscaledAndClipped(trameInter, centré);
            trameInter.Dispose();
            //thumbnail.Save(TMP_FILE, ImageFormat.Bmp);

            //thumbnail.Dispose();
            // image.Dispose();

            trame.Save(TMP_PREPAR, ImageFormat.Bmp);


            trame.Dispose();
            // img.Dispose();
            graphics.Dispose();

            return Image.FromFile(TMP_PREPAR);

        }

        public bool ThumbnailCallback()
        {
            return false;
        }

        private Image createFile(FileDto f)
        {
            Image img = Image.FromFile(f.Path);

            int largeur0 = img.Width;
            int hauteur0 = img.Height;

            Console.WriteLine("{0}={1}x{2} {3}", largeur0 * hauteur0, largeur0, hauteur0, f.HumanReadableSize);

            double r0 = (double)HAUTEUR / (double)LARGEUR;

            int largeurTrame;
            int hauteurTrame;

            double r = (double)hauteur0 / (double)largeur0;





            if (r > r0)
            {
                // image pas assez large --> ajout largeur

                hauteurTrame = hauteur0;
                largeurTrame = Convert.ToInt32((double)hauteur0 / (double)r0);

            }
            else
            {
                // image trop large --> bandes en haut et en bas

                largeurTrame = largeur0;
                hauteurTrame = Convert.ToInt32((double)largeur0 * (double)r0);
            }
            Graphics graphics = null;
            Bitmap trame = null;
            if (highResolution)
                try
                {
                    trame = new Bitmap(largeurTrame, hauteurTrame, img.PixelFormat);
                    graphics = Graphics.FromImage(trame);
                }
                catch
                {
                    if (trame != null)
                        trame.Dispose();
                }
            if (graphics == null)
            {
                trame = new Bitmap(largeurTrame, hauteurTrame);
                graphics = Graphics.FromImage(trame);
            }

            paramGr(graphics);


            int xrec = (largeurTrame - largeur0) / 2;
            int yrec = (hauteurTrame - hauteur0) / 2;
            Rectangle centré = new Rectangle(xrec, yrec, largeur0, hauteur0);
            graphics.DrawImage(img, centré, 0, 0, largeur0, hauteur0, GraphicsUnit.Pixel);


            trame.Save(TMP_PREPAR, ImageFormat.Bmp);
            trame.Dispose();
            img.Dispose();
            graphics.Dispose();

            // verif
            var imgVerif = ImageUtil.Scan(TMP_PREPAR);
            return imgVerif;

            //using (Bitmap fs = new Bitmap(LARGEUR, HAUTEUR))
            //{
            //    Image i0 = null;
            //    Image i1 = null;
            //    using (var g = Graphics.FromImage(fs))
            //    {

            //        if (File.Exists(TMP_FILE))
            //        {
            //            i0 = Image.FromFile(TMP_FILE);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }

            //        if (File.Exists(TMP_FILE1))
            //        {
            //            i1 = Image.FromFile(TMP_FILE1);
            //            gr.DrawImage(i0, new Rectangle(0, 0, LARGEUR, HAUTEUR), 0, 0, LARGEUR, HAUTEUR, GraphicsUnit.Pixel);
            //        }
            //    }
            //    fs.Save(TMP_FILE, ImageFormat.Bmp);
            //    if (i0 != null)
            //        i0.Dispose();
            //    if (i1 != null)
            //        i1.Dispose();
            //}
        }
    }
}
]]></content>
  </file>
  <file path="buro\buroSimpleLib\ImageUtil.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;

namespace buroSimpleLib
{
    public class ImageUtil
    {
        public static bool UseMem { get; set; }
        private static Dict<string, Bitmap> mem = new Dict<string, Bitmap>();
        public static void ClearMem()
        {
            foreach (Bitmap b in mem.Values)
            {
                try
                {
                    b.Dispose();
                }
                catch { }

            }
            mem.Clear();
        }
        /// <summary>
        /// Scan d'une image pour déterminer si elle est vide
        /// </summary>
        /// <param name="file"></param>
        /// <returns>null=> image noire</returns>
        public static unsafe Image Scan(string file)
        {
            int LEVEL_MIN = 0;
            Bitmap b = null;
            DateTime debut = DateTime.Now;
            try
            {
                b = new Bitmap(file);//note this has several overloads, including a path to an image
            }

            catch
            {
                ConsoleLogger.log("Impossible de créer un Bitmap {0}", file);
                try
                {
                    Image i = Image.FromFile(file);
                    return i;
                }
                catch
                {
                    return null;
                }
            }
            DateTime debutScan = DateTime.Now;
            BitmapData bData = b.LockBits(new Rectangle(0, 0, b.Width, b.Height), ImageLockMode.ReadOnly, b.PixelFormat);

            var Depth = Bitmap.GetPixelFormatSize(b.PixelFormat);

            //  byte bitsPerPixel = Bitmap.GetBitsPerPixel(bData.PixelFormat);

            /*This time we convert the IntPtr to a ptr*/
            byte* scan0 = (byte*)bData.Scan0.ToPointer();
            bool ok = false;
            for (int i = 0; i < bData.Height; ++i)
            {
                if (ok)
                    break;
                for (int j = 0; j < bData.Width; ++j)
                {
                    byte* data = scan0 + i * bData.Stride + j * Depth / 8;

                    //data is a pointer to the first byte of the 3-byte color data
                    //data[0] = blueComponent;
                    //data[1] = greenComponent;
                    //data[2] = redComponent;
                    if (data[0] > LEVEL_MIN || data[1] > LEVEL_MIN || data[2] > LEVEL_MIN)
                    {
                        //if (data[3] > 0)
                        ok = true;
                        break;
                    }
                }
            }

            b.UnlockBits(bData);

            var ts = (DateTime.Now - debut).TotalMilliseconds.ToString("0");
            var tsLoad = (debutScan - debut).TotalMilliseconds.ToString("0");

            var tsScan = (DateTime.Now - debutScan).TotalMilliseconds.ToString("0");
            if (!ok)
            {
                ConsoleLogger.log("Blank {0} {1} ms", file, tsScan);
                b.Dispose();
                return null;
            }
            else if (ts.Length >= 3)
                ConsoleLogger.log("{0} load:{1}ms scan:{2}ms total:{3} ms", file, tsLoad, tsScan, ts);
            return b;
        }

        public static bool AreIdentical(Image b1, string file2)
        {
            return !AreDifferent(b1, file2);
        }

        /// <summary>
        /// Détermine si deux images sont différentes ( au moins un pixel différent ) 
        /// </summary>
        /// <param name="img"></param>
        /// <param name="file2"></param>
        /// <returns></returns>
        public static unsafe bool AreDifferent(Image img, string file2)
        {
            //  ConsoleLogger.log("checkDif {0}", file2); 

            Bitmap b2 = null;
            Bitmap b1 = null;


            DateTime debut = DateTime.Now;
            DateTime debutScan = DateTime.Now;
            bool dif = false;
            try
            {
                try
                {
                    //b1 = new Bitmap(file1);//note this has several overloads, including a path to an image
                    b2 = mem[file2];
                    if (b2 == null)
                    {
                        b2 = new Bitmap(file2);
                        if (UseMem)
                            mem[file2] = b2;
                    }
                    debutScan = DateTime.Now;
                    if (img is Bitmap)
                        b1 = img as Bitmap;
                    else
                        b1 = new Bitmap(img);
                    if (b1.Width != b2.Width)
                        dif = true;
                    else if (b1.Height != b2.Height)
                        dif = true;
                }

                catch
                {
                    dif = true;
                }
                if (!dif)
                {

                    BitmapData bData1 = b1.LockBits(new Rectangle(0, 0, b1.Width, b1.Height), ImageLockMode.ReadOnly, b1.PixelFormat);
                    BitmapData bData2 = b2.LockBits(new Rectangle(0, 0, b2.Width, b2.Height), ImageLockMode.ReadOnly, b2.PixelFormat);

                    var Depth = Bitmap.GetPixelFormatSize(b1.PixelFormat);

                    //  byte bitsPerPixel = Bitmap.GetBitsPerPixel(bData.PixelFormat);

                    /*This time we convert the IntPtr to a ptr*/
                    byte* scan01 = (byte*)bData1.Scan0.ToPointer();
                    byte* scan02 = (byte*)bData2.Scan0.ToPointer();

                    for (int i = 0; i < bData1.Height; ++i)
                    {
                        if (dif)
                            break;
                        for (int j = 0; j < bData1.Width; ++j)
                        {
                            if (dif)
                                break;
                            byte* data1 = scan01 + i * bData1.Stride + j * Depth / 8;
                            byte* data2 = scan02 + i * bData2.Stride + j * Depth / 8;

                            //data is a pointer to the first byte of the 3-byte color data
                            //data[0] = blueComponent;
                            //data[1] = greenComponent;
                            //data[2] = redComponent;

                            for (int c = 0; c < 3; c++)
                            {
                                if (data1[c] != data2[c])
                                {
                                    dif = true;
                                    break;
                                }
                            }

                        }
                    }

                    b1.UnlockBits(bData1);
                    b2.UnlockBits(bData2);
                }
            }
            finally
            {
                if (b2 != null && !UseMem)
                    b2.Dispose();
            }

            var ts = (DateTime.Now - debut);  //  TotalMilliseconds.ToString("0");
            var tsLoad = (debutScan - debut);//TotalMilliseconds.ToString("0");

            var tsScan = (DateTime.Now - debutScan).toString(); //TotalMilliseconds.ToString("0");
            if (!dif)
            {
                ConsoleLogger.log("equal {0} {1} ms", file2, tsScan);
            }
            else if (ts.TotalMilliseconds >= 100)
                ConsoleLogger.log("{0} load:{1}ms checkDif:{2}ms total:{3} ms", file2, tsLoad.toString(), tsScan, ts.toString());


            return dif;
        }

        public static Image Scale(string source, int scale)
        {
            return Scale(Image.FromFile(source), scale);
        }

        public static Image Scale2(Image source, int scale)
        {


            scale = 1;

            Bitmap src = null;
            if (source is Bitmap)
                src = source as Bitmap;
            else
                src = new Bitmap(source);

            var scaled = new DirectBitmap(source.Width * scale, source.Height * scale);

            var srcb = new DirectBitmap(src);


            int width = source.Width;
            int height = source.Height;

            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < height; j++)
                {
                    Color c = srcb.GetPixel(i, j);
                    int x0 = scale * i;
                    int x1 = x0 + scale;
                    int y0 = scale * j;
                    int y1 = y0 + scale;
                    for (int x = x0; x < x1; x++)
                    {
                        for (int y = y0; y < y1; y++)
                        {
                            scaled.SetPixel(x, y, c);
                        }
                    }
                }
            }
            return scaled.Bitmap;

        }

        public static unsafe Image Scale1(Image source, int scale)
        {


            if (scale == 1)
                return source;

            Bitmap scaled = new Bitmap(source.Width * scale, source.Height * scale);
            Bitmap src = null;
            if (source is Bitmap)
                src = source as Bitmap;
            else
                src = new Bitmap(source);

            DateTime debut = DateTime.Now;
            DateTime debutScan = DateTime.Now;
            bool dif = false;
            try
            {

                BitmapData bData1 = src.LockBits(new Rectangle(0, 0, src.Width, src.Height), ImageLockMode.ReadOnly, src.PixelFormat);
                BitmapData bData2 = scaled.LockBits(new Rectangle(0, 0, scaled.Width, scaled.Height), ImageLockMode.ReadOnly, scaled.PixelFormat);

                var Depth = Bitmap.GetPixelFormatSize(src.PixelFormat);

                //  byte bitsPerPixel = Bitmap.GetBitsPerPixel(bData.PixelFormat);

                /*This time we convert the IntPtr to a ptr*/
                byte* scan01 = (byte*)bData1.Scan0.ToPointer();
                byte* scan02 = (byte*)bData2.Scan0.ToPointer();

                for (int i = 0; i < bData1.Height; ++i)
                {
                    if (dif)
                        break;
                    for (int j = 0; j < bData1.Width; ++j)
                    {
                        if (dif)
                            break;
                        byte* data1 = scan01 + i * bData1.Stride + j * Depth / 8;
                        byte* data2 = scan02 + i * bData2.Stride + j * Depth / 8;

                        //data is a pointer to the first byte of the 3-byte color data
                        //data[0] = blueComponent;
                        //data[1] = greenComponent;
                        //data[2] = redComponent;


                        int x0 = scale * i;
                        int x1 = x0 + scale;
                        int y0 = scale * j;
                        int y1 = y0 + scale;
                        for (int x = x0; x < x1; x++)
                        {
                            for (int y = y0; y < y1; y++)
                            {
                                data2 = scan02 + x * bData2.Stride + y * Depth / 8;
                                for (int c = 0; c < 3; c++)
                                {
                                    data2[c] = data1[c];
                                }
                                data2[3] = 255;
                            }
                        }
                    }
                }


                src.UnlockBits(bData1);
                scaled.UnlockBits(bData2);

            }
            finally
            {

            }

            var ts = (DateTime.Now - debut); 
            if (ts.TotalMilliseconds >= 100)
                ConsoleLogger.log("copie:{0}", ts);
            return scaled;
        }


        public static Image Scale(Image source, int scale)
        {
            //    if (scale == 1)
            //        return source;

            Bitmap scaled = new Bitmap(source.Width * scale, source.Height * scale);
            Bitmap src = null;
            //if (source is Bitmap)
            //    src = source as Bitmap;
            //else
            src = new Bitmap(source);
            LockBitmap org = new LockBitmap(src);
            LockBitmap modif = new LockBitmap(scaled);
            org.LockBits(ImageLockMode.ReadOnly);
            modif.LockBits(ImageLockMode.WriteOnly);

            int width = org.Width;
            int height = org.Height;

            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < height; j++)
                {
                    Color c = org.GetPixel(i, j);
                    int x0 = scale * i;
                    int x1 = x0 + scale;
                    int y0 = scale * j;
                    int y1 = y0 + scale;
                    for (int x = x0; x < x1; x++)
                    {
                        for (int y = y0; y < y1; y++)
                        {
                            modif.SetPixel(x, y, c);
                        }
                    }
                }
            }
            org.UnlockBits();
            modif.UnlockBits();
            return scaled;
        }




    }


}
]]></content>
  </file>
 </db>
