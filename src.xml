<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
using pdb.podcast.Load;
using timeSpan = pdb.util.timeSpan;


namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    public class AutoBuilder : IComparable<AutoBuilder>//, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private int nbDown;
        private bool ? useForfait;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private DirConf source; public DirConf Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;
        private List<AutoBuilderItem> chooses = new List<AutoBuilderItem>();
        public const int STOP_MAX = 3;
        private int _stopLevel = STOP_MAX;
        // private bool 


        private List<LimitItemLoader> loaders = new List<LimitItemLoader>();
        public void buildLoaders()
        {
            loaders = new List<LimitItemLoader>();
            source.buildLoaders(loaders, this);

        }

        public void go()
        {
            var total = new timeSpan();
            var fd = new timeSpan();
            var d = new timeSpan();
            var date = new timeSpan();
            var nb = 0;

            var dict = new pdb.util.BgDictString0<TrackInfoItunes>();

            while (true)
            {
                var _total = timeSpan.MaxValue;
                var _fd = timeSpan.MaxValue;
                var _d = timeSpan.MaxValue;
                var _date = timeSpan.MaxValue;
                var _nb = int.MaxValue;

                foreach (LimitItemLoader loader in loaders)
                {
                    loader.checkV(this, nb, fd, d, date);
                    if (_total > loader._durationv)
                        _total = loader._durationv;
                    if (_fd > loader._fd)
                        _fd = loader._fd;
                    if (_date > loader._datev)
                        _date = loader._datev;
                    if (_nb > loader._nb)
                        _nb = loader._nb;
                }
            }
        }
        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(DirConf source)
        {
            this.source = source;
            source.addBorderObs(this);
            source.Auto = this;
        }

        // private static bool loaded; 
        public static void getLoaders()
        {
            //if (loaded)
            //    return;
            //loaded = true;
            foreach (AutoBuilder auto in list)
                auto.buildLoaders();
        }

        //public static void test()
        //{
        //    //if (loaded)
        //    //    return;
        //    //loaded = true;
        //    foreach (AutoBuilder auto in list)
        //        auto.go();
        //}

        private static AutoBuilder main;
        public static void build(XmlNode xAuto, DirConf source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        mem.dict.Add(key, desc);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                List<string> toRemove = new List<string>();
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        toRemove.Add(key);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }

                foreach (string key in toRemove)
                    mem.dict.Remove(key);
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    //{
                    //    //if (!exist)
                    //    //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                    //    tw.Write(DateTime.Now); tw.Write(SEP);
                    //    tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    //    tw.Write(atomicMode); tw.Write(SEP);
                    //    tw.Write(state); tw.Write(SEP);
                    //    for (int i = 0; i < imax; i++)
                    //    {
                    //        if (i > 0)
                    //        {
                    //            tw.WriteLine();
                    //            for (int j = 0; j < 11; j++)
                    //                tw.Write(SEP);
                    //        }
                    //        if (i < mem.ajouts.Count)
                    //            tw.Write(mem.ajouts[i].track);
                    //        tw.Write(SEP);
                    //        if (i < mem.ajouts.Count)
                    //            tw.Write(mem.ajouts[i].item);
                    //        tw.Write(SEP);
                    //        if (i < mem.suppressions.Count)
                    //            tw.Write(mem.suppressions[i].track);
                    //        tw.Write(SEP);
                    //        if (i < mem.suppressions.Count)
                    //            tw.Write(mem.suppressions[i].item);
                    //        tw.Write(SEP);
                    //    }
                    //    tw.WriteLine();
                    //}
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
            _stopLevel = STOP_MAX;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            //bool firstWIthTb = first && Conf.BorderTb;
            //bool secondwithoutTb = !first && !Conf.BorderTb;
            //bool readXml = firstWIthTb || secondwithoutTb;

            bool readXml = first;
            FileInfo f = null;
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                //if (first)
                //    builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static void Init3()
        {
            foreach (AutoBuilder item in list)
            {
                item.init3();
            }
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check3();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                //throw new NotImplementedException(); 
                //AutoBuilder builder = null;
                //if (!started)
                //{
                //    started = true;
                //    foreach (AutoBuilder b in list)
                //        b.total = b.source.getTotalSize();
                //}
                //// application de la précédente modif
                //builder = list[index];
                //if (builder.state > builderstate.none)
                //{
                //    builder.makeEmpreinteNonSequence();
                //    decrementIndex();
                //}
                //int i = -1;
                //for (i = list.Count - 1; i >= 0; i--)
                //{
                //    builder = list[i];
                //    bool cango = false;
                //    bool _cont = false;
                //    while (true)
                //    {
                //        if (i == index || _cont)
                //        {
                //            cango = builder.check();
                //            index = i;
                //            main = builder;
                //            _cont = false;
                //            break;
                //        }
                //        else
                //            cango = builder.checkWithoutModify();
                //        if (builder.state == builderstate.none)
                //            _cont = true;
                //        else
                //            break;
                //    }
                //    if (!cango)
                //        _cango = false;
                //    if (builder.mustUpdate)
                //        MustUpdate = true;
                //    if (i == index)
                //    {
                //        if (builder.newv != builder.org)
                //        {
                //            _modifFile = true;
                //        }
                //        else
                //        {
                //            //index--;
                //            //if (index < 0)
                //            //    index = list.Count - 1;
                //        }
                //    }
                //    if (_modifFile)
                //        break;
                //}
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                    _cango = false;
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        //private bool check()
        //{
        //    sb = new StringBuilder();
        //    sb.AppendLine();
        //    makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
        //    mustUpdate = false;
        //    canGo = false;
        //    var newEmpreinte = source.getEmpreinte();
        //    if (state == builderstate.none)
        //        reset();
        //    else if (state == builderstate.stable)
        //    {
        //        if (newEmpreinte != _empreinte)
        //            reset();
        //        else
        //        {
        //            mustUpdate = false;
        //            canGo = true;
        //            org = newv;
        //            return true;
        //        }
        //    }
        //    if (Conf.AutoSequence || total < 0)
        //        total = source.getTotalSize();
        //    double target = conf.target;
        //    delta = target - total;
        //    log("delta {0}", delta);
        //    if (state == builderstate.none)
        //        delta0 = delta;
        //    state = builderstate.enCours;
        //    lastd = d;
        //    d = 0;
        //    xml = null;
        //    lookup(xmlRoot);
        //    if (xml == null)
        //        return true;
        //    string attTarget = conf.type.ToString();
        //    var att = xml.Attributes[attTarget];
        //    if (att == null)
        //        return true;
        //    org = Convert.ToDouble(att.Value);
        //    newv = org;
        //    try
        //    {
        //        if (delta * delta0 < 0)
        //        {
        //            if (atomicMode < 0)
        //            {
        //                atomicMode = 0;
        //                //if (minMem == null)
        //                //    minMem = new Memory(mem0);
        //                //if (maxMem == null)
        //                //    maxMem = new Memory(mem0);
        //                //if (minMem.suppressions.Count == 0)
        //                //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
        //                //if (maxMem.ajouts.Count == 0)
        //                //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
        //            }
        //        }
        //        bool cancelSameConf = false;
        //        bool cancelNb = false;
        //        if (atomicMode >= 0)
        //        {
        //            atomicMode++;
        //            if (Math.Abs(dmin - delta) < EPSILON)
        //                sameConfiguration++;
        //            else if (Math.Abs(dmax - delta) < EPSILON)
        //                sameConfiguration++;
        //            else
        //                sameConfiguration = 0;
        //            if (sameConfiguration > conf.idem)
        //                cancelSameConf = true;
        //            if (atomicMode > conf.cloop)
        //                cancelNb = true;
        //        }
        //        if (delta >= 0)
        //        {
        //            if (mem0.suppressions.Count > 0)
        //                minMem = new Memory(mem0);
        //            if (delta < conf.write)
        //                canGo = true;
        //            //  lastGoodLevel = org;
        //            //if (maxMem != null && minMem != null)
        //            //{
        //            if (atomicMode > 0)
        //            {
        //                if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
        //                {
        //                    log("abandon recherche cartésienne cause idem");
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //                else if (cancelNb)
        //                {
        //                    log("abandon recherche cartésienne cause cloop");
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //                //if (Math.Abs(dmin - delta) < 0.01)
        //                //    dminAlready = true;
        //                //else
        //                //    dminAlready = false;
        //                if (maxMem != null && minMem != null)
        //                {
        //                    if (minMem.suppressions.Count == maxMem.ajouts.Count)
        //                    {
        //                        bool identique = true;
        //                        for (int i = 0; i < minMem.suppressions.Count; i++)
        //                        {
        //                            if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
        //                            {
        //                                identique = false;
        //                                break;
        //                            }
        //                        }
        //                        if (identique)
        //                        {
        //                            if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
        //                            {
        //                                mustUpdate = false;
        //                                log("abandon recherche cartésienne cause cycle");
        //                                state = builderstate.stable;
        //                                _empreinte = newEmpreinte;
        //                                return true;
        //                            }
        //                        }
        //                    }
        //                }
        //            }
        //            cmin = org;
        //            dmin = delta;
        //            // lastGoodDelta = (int)delta;
        //            lastTotal = (int)total;
        //            if (delta < conf.delta)
        //            {
        //                state = builderstate.stable;
        //                _empreinte = newEmpreinte;
        //                return true;
        //            }
        //            mustUpdate = true;
        //            d = 0;
        //            if (atomicMode > 0)
        //            {
        //                //if (atomicMode > conf.cloop)
        //                //{
        //                //    mustUpdate = false;
        //                //    log("abandon recherche cartésienne cause cloop");
        //                //    state = builderstate.stable;
        //                //    _empreinte = newEmpreinte;
        //                //    return true;
        //                //}
        //                //if (dminAlready && dmaxAlready)
        //                //{
        //                //    mustUpdate = false;
        //                //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
        //                //    return true;
        //                //}
        //                d = 0.5 * (cmax - cmin);
        //            }
        //            else
        //            {
        //                double _d = int.MaxValue;
        //                if (cmax >= 0 && cmin >= 0)
        //                    _d = cmax - cmin;
        //                double aux = int.MaxValue;
        //                // double aux2 = int.MaxValue;
        //                foreach (Level level in conf.levels)
        //                {
        //                    aux = (delta - level.d) * level.inf;
        //                    if (aux > d)
        //                        d = aux;
        //                }
        //                if (conf.coeff > 0)
        //                {

        //                    if (org > conf.max)
        //                        d = conf.max - org;
        //                    else
        //                    {
        //                        d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
        //                    }
        //                    //else
        //                    //{
        //                    //    var de = Math.Abs(delta);
        //                    //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
        //                    //}
        //                }

        //                //if (d == 0 || aux2 < d)
        //                //    d = aux2;

        //                if (d > _d)
        //                    d = _d;
        //            }
        //        }
        //        else if (delta < 0)
        //        {
        //            if (mem0.ajouts.Count > 0)
        //                maxMem = new Memory(mem0);
        //            mustUpdate = true;
        //            canGo = false;
        //            //if (maxMem != null && minMem != null)
        //            //{
        //            //    if (atomicMode < 0)
        //            //        atomicMode = 0;
        //            //    atomicMode++;
        //            //}
        //            cmax = org;
        //            dmax = delta;
        //            d = 0;
        //            if (atomicMode > 0)
        //            {
        //                bool identique = false;
        //                if (minMem != null && maxMem != null
        //                    && maxMem.ajouts.Count == minMem.suppressions.Count)
        //                {
        //                    identique = true;
        //                    for (int i = 0; i < minMem.suppressions.Count; i++)
        //                    {
        //                        if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
        //                        {
        //                            identique = false;
        //                            break;
        //                        }
        //                    }
        //                }
        //                if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
        //                {
        //                    log("retour derniere bonne valeur cause idem");
        //                    d = cmin - cmax;
        //                }
        //                else if (cancelNb)
        //                {
        //                    log("abandon recherche cartésienne cause cloop");
        //                    d = cmin - cmax;
        //                }
        //                else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
        //                {
        //                    log("retour derniere bonne valeur cause cycle");
        //                    d = cmin - cmax;
        //                }
        //                //else if (atomicMode > conf.cloop)
        //                //{                      
        //                //    log("abandon recherche cartésienne cause cloop");
        //                //    d = cmin - cmax;
        //                //}
        //                else
        //                    d = 0.5 * (cmin - cmax);
        //            }
        //            else
        //            {

        //                double _d = -int.MaxValue;
        //                if (cmax >= 0 && cmin >= 0)
        //                    _d = cmin - cmax;
        //                double aux = -int.MaxValue;
        //                // double aux2 = -int.MaxValue;
        //                foreach (Level level in conf.levels)
        //                {
        //                    aux = (delta - conf.delta + level.d) * level.sup;
        //                    if (aux < d)
        //                        d = aux;
        //                }
        //                if (conf.coeff > 0)
        //                {
        //                    if (org < conf.min)
        //                        d = (conf.min - org);
        //                    else
        //                    {
        //                        d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
        //                    }
        //                    //else
        //                    //{
        //                    //    var de = Math.Abs(delta);
        //                    //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
        //                    //}
        //                }

        //                //if (d == 0 || aux2 > d)
        //                //    d = aux2;

        //                if (d < _d)
        //                    d = _d;
        //            }
        //            //d = (delta - conf.delta) * conf.sup;
        //            //if (org <= lastGoodLevel)
        //            //{
        //            //    lastGoodLevel = -1;
        //            //    lastGoodDelta = -1;
        //            //    lastTotal = -1;
        //            //}
        //        }
        //        if (Math.Abs(d) < 0.00000001)
        //        {
        //            mustUpdate = false;
        //            // unCart();
        //            state = builderstate.stable;
        //            _empreinte = newEmpreinte;
        //            return true;
        //        }
        //        //if (dejaVu)
        //        //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
        //        log("correction {0}", d);
        //        newv = org + d;
        //        if (newv <= 0)
        //            newv = 0;
        //        if (conf.coeff > 0)
        //        {
        //            if (newv > conf.max)
        //                newv = conf.max;
        //            else if (newv < conf.min)
        //                newv = conf.min;
        //        }
        //        newv = Math.Round(newv, 8);
        //        log(" valeur {0} --> {1}", org, newv);
        //        att.Value = newv.ToString();
        //    }
        //    finally
        //    {
        //        if (state == builderstate.stable)
        //        {
        //            mustUpdate = false;
        //            _empreinte = newEmpreinte;
        //            canGo = true;
        //        }
        //        string strDate = "";
        //        var attD = xml.Attributes["date"];
        //        if (attD != null)
        //            strDate = attD.Value;
        //        bool exist = File.Exists(file);
        //        //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
        //        //{
        //        //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
        //        //    if (!exist)
        //        //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
        //        //    tw.Write(DateTime.Now); tw.Write(SEP);
        //        //    tw.Write(target.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(atomicMode); tw.Write(SEP);
        //        //    tw.Write(state); tw.Write(SEP);
        //        //    tw.WriteLine();
        //        //}
        //        if (canGo)
        //            // makeDelta(mem1, "reel", @"..\rhisto.txt");
        //            makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
        //    }
        //    return canGo;
        //}

        //private void calcChoose(bool up, bool strict, bool checkSelect)
        //{
        //    choose = null;
        //    double dt = double.MaxValue;
        //    double gap = double.MaxValue;
        //    // bool trou = false;
        //    foreach (AutoBuilderItem item in items)
        //    {
        //        item.after(up, strict, checkSelect);
        //        item.setTension(up, strict, checkSelect);
        //        if (item.Stop(_stopLevel))
        //        {
        //            if ((strict || checkSelect) && Conf.BorderGranSlam)
        //            {
        //                choose = null;
        //                break;
        //            }
        //            continue;
        //        }
        //        double aux = double.MaxValue;
        //        // var tension = item.Tension;
        //        if (conf.selectFix)
        //        {
        //            var tension = item.Tension;
        //            aux = up ? tension : -tension;
        //        }
        //        else
        //            aux = item.Dt;

        //        if (conf.selectAbs && !conf.selectFix && aux < 0)
        //            aux *= -1;



        //        if (item.getCauses().Count == 0)
        //        {
        //            // trou = true;
        //            if ((strict || checkSelect) && Conf.BorderGranSlam)
        //            {
        //                choose = null;
        //                break;
        //            }
        //            continue;
        //        }

        //        //var _gap = Math.Abs(aux);
        //        //if (_gap < gap)
        //        //    gap = _gap;

        //        if (aux < dt)
        //        {
        //            dt = aux;
        //            newv = item.NewV;
        //            choose = item;
        //        }
        //    }
        //    //if (trou && conf.gap && gap < double.MaxValue)
        //    //{
        //    //    foreach (AutoBuilderItem item in items)
        //    //    {
        //    //        if (item.Stop)
        //    //            continue;
        //    //        item.gap(up, conf.selectFix, gap);
        //    //    }
        //    //}
        //}

        //private bool check2()
        //{
        //    // _modifFile = false; 
        //    sb = new StringBuilder();
        //    sb.AppendLine();
        //    makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




        //    if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
        //    {
        //        if (conf.pertinentExclu)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                if (item != choose)
        //                    item.makePertinent();
        //            }
        //        }
        //        else if (conf.pertinentAll)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //                item.makePertinent();
        //        }
        //        else
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                item.checkAjout(mem0.tajouts);
        //                item.checkAjout(mem0.tsuppressions);
        //            }
        //        }


        //        //else if (choose != null)
        //        //    choose.makePertinent();
        //    }
        //    mustUpdate = false;
        //    canGo = false;
        //    var newEmpreinte = source.getEmpreinte();

        //    try
        //    {
        //        if (state == builderstate.none)
        //            reset();
        //        else if (state == builderstate.stable)
        //        {
        //            if (newEmpreinte != _empreinte)
        //                reset();
        //            else
        //            {
        //                mustUpdate = false;
        //                canGo = true;
        //                org = newv;
        //                return true;
        //            }
        //        }

        //        total = source.getTotalSize();
        //        double target = conf.target;
        //        delta = target - total;
        //        log("delta {0}", delta);

        //        if (_stopLevel < 0)
        //        {
        //            log("arret cause stopLevel");
        //            state = builderstate.stable;
        //            return true;
        //        }
        //        if (delta * lastDelta < 0)
        //        {
        //            //if (delta > 0)
        //            //{
        //            //    // ok!
        //            //    state = builderstate.stable;
        //            //    _empreinte = newEmpreinte;
        //            //    return true;
        //            //}
        //            // retour arrière
        //            if (choose != null && _stopLevel > 0)
        //            {
        //                log("retour arrière");
        //                _stopLevel--;
        //                choose.stop(_stopLevel);
        //                canGo = false;
        //                mustUpdate = true;
        //                return false;
        //            }
        //            else
        //            {
        //                if (delta > 0)
        //                {
        //                    // ok!
        //                    log("pas de retour arriere stoplevel=0");
        //                    state = builderstate.stable;
        //                    _empreinte = newEmpreinte;
        //                    return true;
        //                }
        //                else
        //                {
        //                    _stopLevel--;
        //                    choose.stop(_stopLevel);
        //                    canGo = false;
        //                    mustUpdate = true;
        //                    return false;
        //                }
        //            }
        //        }
        //        lastDelta = delta;
        //        if (state == builderstate.none)
        //            delta0 = delta;
        //        state = builderstate.enCours;
        //        lastd = d;
        //        d = 0;

        //        bool up = delta > 0;
        //        if (up && delta < conf.delta)
        //        {
        //            log("delta");
        //            state = builderstate.stable;
        //            _empreinte = newEmpreinte;
        //            return true;
        //        }
        //        mustUpdate = true;
        //        //double dt = double.MaxValue;

        //        //bool real = true;
        //        //if (delta * delta0 < 0)
        //        //{
        //        //    if (choose != null)
        //        //    {
        //        //        _stopLevel--;
        //        //        choose.stop(_stopLevel);
        //        //    }
        //        //    canGo = false;
        //        //    mustUpdate = true;
        //        //    return false;
        //        //}
        //        if (conf.stopAll)
        //        {
        //            foreach (AutoBuilderItem item in items)
        //            {
        //                if (item.Stop(1))
        //                {
        //                    state = builderstate.stable;
        //                    return true;
        //                }
        //            }
        //        }



        //        choose = null;
        //        if (_stopLevel >= 3 && conf.checkSelect && conf.checkStrict)
        //            calcChoose(up, true, true);
        //        if (choose != null)
        //            log("REEL - SELECT");
        //        else
        //        {
        //            if (_stopLevel >= 2 && conf.checkSelect)
        //                calcChoose(up, false, true);
        //            if (choose != null)
        //                log("VIRTUEL SELECT");
        //            else
        //            {
        //                if (_stopLevel >= 1 && conf.checkStrict)
        //                    calcChoose(up, true, false);
        //                if (choose != null)
        //                    log("REEL");
        //                else
        //                {
        //                    if (_stopLevel >= 0)
        //                    {
        //                        calcChoose(up, false, false);
        //                        if (choose != null)
        //                            log("VIRTUEL");
        //                    }
        //                }
        //            }
        //        }


        //        if (choose == null)
        //        {
        //            log("choose null");
        //            _stopLevel--;
        //            if (_stopLevel < 0)
        //            {
        //                state = builderstate.stable;
        //                return true;
        //            }
        //            else
        //            {
        //                canGo = false;
        //                mustUpdate = true;
        //                return false;
        //            }
        //        }

        //        org = choose.Org;



        //        if (up)
        //        {
        //            if (delta < conf.write)
        //                canGo = true;
        //            if (conf.checkEvol)
        //            {
        //                // var nextTrack = choose.rejected(real).candidat;
        //                var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
        //                if (delta < size)
        //                {
        //                    _stopLevel--;
        //                    // choose.stop();
        //                    if (conf.stopAll)
        //                    {
        //                        foreach (AutoBuilderItem item in items)
        //                            item.stop(_stopLevel);
        //                        //state = builderstate.stable;
        //                        //return true;
        //                    }
        //                    else
        //                    {
        //                        choose.stop(_stopLevel);
        //                    }
        //                }
        //            }

        //        }
        //        else
        //        {
        //        }
        //        choose.save();
        //        Program.logAuto.log("===> " + choose.ToString());
        //    }
        //    finally
        //    {
        //        if (state == builderstate.stable)
        //        {
        //            mustUpdate = false;
        //            _empreinte = newEmpreinte;
        //            canGo = true;
        //        }

        //        //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
        //        //{
        //        //    bool exist = File.Exists(file);
        //        //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
        //        //    if (!exist)
        //        //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
        //        //    tw.Write(DateTime.Now); tw.Write(SEP);
        //        //    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
        //        //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
        //        //    tw.Write(atomicMode); tw.Write(SEP);
        //        //    tw.Write(state); tw.Write(SEP);
        //        //    tw.WriteLine();
        //        //}
        //        if (canGo)
        //            // makeDelta(mem1, "reel", @"..\rhisto.txt");
        //            makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
        //    }
        //    return canGo;
        //}

        private void init3()
        {
            _cause = null;


            foreach (AutoBuilderItem item in items)
            {
                item.Candidat = null;
                item.limit = null; 
                item.setTension();
            }
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


            }

            setDelta();


        }

        public static void SetDelta()
        {
            foreach (AutoBuilder item in list)
            {
                item.setDelta();
            }
        }

        private void setDelta()
        {
            mustUpdate = false;
            canGo = false;

            total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
           // log("delta {0}", delta);
        }

        private bool check3()
        {
            // _modifFile = false; 

            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }



                if (_stopLevel < 0)
                {
                    log("arret cause stopLevel");
                    state = builderstate.stable;
                    return true;
                }
                var _lastDelta = lastDelta;
                lastDelta = delta;
                if (delta * _lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (delta > 0)
                    {
                        if (conf.forfaitNegatif > 0 && true ==  useForfait)
                        {                         
                            useForfait = false;
                        }
                        else
                        {
                            // ok!
                            log("pas de retour arriere stoplevel=0");
                            state = builderstate.stable;
                            _empreinte = newEmpreinte;
                            useForfait = null;
                            return true;
                        }
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        _stopLevel--;
                        foreach (AutoBuilderItem choose in chooses)
                        {
                            if (choose != null && _stopLevel > 0)
                            {
                                log("retour arrière");
                                choose.stop(_stopLevel);
                            }
                        }
                        return false;
                    }

                }

                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;

                if (up)
                    nbDown = 0;
                else
                    nbDown++;
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    useForfait = null;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            useForfait = null;
                            return true;
                        }
                    }
                }

                if (_cause == null)
                {
                    log("_cause NULL");
                    state = builderstate.stable;
                    useForfait = null;
                    return true;

                }
                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                }

                var cdv = _cause.causes;
                chooses.Clear();


                foreach (CauseDataValue cd in cdv.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Update)
                        continue;

                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;
                    item.save(cd.val);
                    chooses.Add(item);
                   // item.Cause = cd;
                    item.Candidat = cdv.candidat;
                    item.limit = cdv.limit; 

                }

                if (!up && conf.forfaitNegatif > 0)
                {
                
                    if (nbDown > conf.forfaitNegatifOffset)
                    {
                        useForfait = true;
                        foreach (var item in items)
                        {
                            var tension = item.Tension;
                            tension -= conf.forfaitNegatif * (nbDown-conf.forfaitNegatifOffset);
                            if (tension < 0)
                                tension = 0;
                            item.modif(tension);
                            chooses.Add(item);
                        }
                    }
                }

                if (chooses.Count == 0)
                {
                    log("pas de choose");
                    state = builderstate.stable;
                    useForfait = null;
                    return true;

                }





            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                //using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                //{
                //    bool exist = File.Exists(file);
                //    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                //    if (!exist)
                //        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                //    tw.Write(DateTime.Now); tw.Write(SEP);
                //    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                //    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                //    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                //    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                //    tw.Write(atomicMode); tw.Write(SEP);
                //    tw.Write(state); tw.Write(SEP);
                //    tw.WriteLine();
                //}
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }


        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder();
            sb.Append(string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9}) ", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.Append(nbDown); 
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
            {

                sb.Append(item);
            }
           // sb.AppendLine();
            return sb.ToString();

        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************");
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            if (choose != null)
                type = choose.type.ToString();
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
            Program.logAuto.log("{0} {1} stop:{2}", name, type, _stopLevel.ToString());

            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);

            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                //   log(" valeur {0} --> {1}", org, newv);

                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log("");
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        //private CauseRegister causeRegister = new CauseRegister();
        //public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null) //|| data.virtuel)
                    continue;

                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].Virtuel = true;
                if (!cd.datas[i].Virtuel)
                    nb++;
            }

            //if (nb == 0)
            //    return; 

           // causeRegister.signal(cd);
       //     if (nb > 1) // OUAILLE ?
                checkCause(cd);

        }

        private CauseDatasTension _cause;
        private void checkCause(CauseDatas cause)
        {
            bool up = delta > 0;
            if (Conf.AutoSelect)
            {
                bool selected = cause.Selected;
                if (up && selected)
                    return;
                if (!up && !selected)
                    return;
            }

            if (up)
            {
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel && !cd.Ok)
                        return;
                }

                double tot = 0;
                bool _checked = false;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (cd.Ok)
                        continue;
                    //fd et nb dépendent des deux autres
                    // on ne prend pas en compte fd s'il concerne un track trop loin dans le temps. d, fd, nb, maxdate
                    //// Mauvaise idée, il faut au contraire pénaliser en augmentant le coût
                    //if (cd.type == borderType.fd || cd.type == borderType.nb)
                    //{
                    //    var cdd = cause.datas[0];
                    //    if (!cdd.Ok)
                    //        continue;
                    //    var cdt = cause.datas[3];
                    //    if (!cdt.Ok)
                    //        continue;
                    //}
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (cd.val <= item.torg)
                        continue;

                    _checked = true;

                    var tension = item.getTension(cd.val);
                    if (!conf.selectFix)
                    {
                        tension = item.Dt;
                    }

                    tot += (tension * tension);
                    if (_cause != null && tot >= _cause.tension)
                        return;

                    cd.Update = true;

                }
                if (tot > 0 && _checked // (tot > 0 //COMMENT on peut avoir ZERO ???? et pourtant
                    && (_cause == null || tot < _cause.tension))
                    _cause = new CauseDatasTension(cause, tot);

            }
            else
            {
                //foreach (CauseDataValue cd in cause.datas)
                //{
                //    if (cd.Virtuel && cd.Ok)
                //        return;
                //}

                double aux = 0;
                double min = int.MaxValue;
                CauseDataValue cdMin = null;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Ok)
                        continue;
                    //fd et nb dépendent des deux autres
                    // on ne prend pas en compte fd s'il concerne un track trop loin dans le temps. d, fd, nb, maxdate
                    //// Mauvaise idée, il faut au contraire pénaliser en augmentant le coût
                    //if (cd.type == borderType.fd || cd.type == borderType.nb)
                    //{
                    //    var cdd = cause.datas[0];
                    //    if (!cdd.Ok)
                    //        continue;
                    //    var cdt = cause.datas[3];
                    //    if (!cdt.Ok)
                    //        continue;
                    //}



                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (cd.val >= item.torg)
                        continue;

                    var tension = item.getTension(cd.val);
                    if (conf.selectFix)
                    {
                        aux = -tension;
                    }

                    else
                    {
                        aux = tension - item.Tension;
                        if (conf.selectAbs && aux < 0)
                            aux = -aux;
                    }


                    if (aux < min)
                    {
                        min = aux;
                        cdMin = cd;
                    }

                }
                if (cdMin == null)
                    return;

                if (_cause == null || _cause.tension > min)
                {
                    cdMin.Update = true;
                    _cause = new CauseDatasTension(cause, min);
                }

            }

        }



    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;
using pdb.podcast.Selection;
using pdb.podcast.Report;
using Math = System.Math;

namespace pdb.podcast.Auto
{
    class AutoBuilderItem //: IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private timeSpan tpertinentOrg;
        public TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        private double evolSize;
        public double NewV { get { return newv; } }
        internal TrackBorderItem rejected(bool real) { return real ? _rejected : _rejectedLight; }
        internal TrackBorderItem selected(bool real) { return real ? _selected : _selectedLight; }
        internal void makePertinent() { pertinentOrg = org; }

        public void checkAjout(IEnumerable<TrackInfoItunes> list)
        {
            if (pertinentOrg == org)
                return;

            var lcauses = _causes;


            foreach (Causes causes in lcauses)
            {
                foreach (TrackInfoItunes t in list)
                {
                    if (causes.candidat.Location == t.Location)
                    {
                        pertinentOrg = org;
                        return;
                    }
                }

            }


        }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlElement xml;
        public double dd;
        public double d;
        private bool lastStrict;
        private bool lastUp;
        private double lastDelta;

        private double lastOrg;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        public AutoBuilderItem(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente - conf.min;
            dd = d * d;
        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _selectedLight;
        private TrackBorderItem _rejected;
        private TrackBorderItem _rejectedLight;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }

            //    tb.status = borderStatus.rejectedXtraLight; 
            //}


            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }


        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;

                if (!tb.Virtual)
                {
                    if (_selected == null)
                        _selected = tb;
                    else if (tb.val > _selected.val)
                        _selected = tb;
                }

                if (_selectedLight == null)
                    _selectedLight = tb;
                else if (tb.val > _selectedLight.val)
                    _selectedLight = tb;

                //if (_selected == null)
                //    setSelect(tb);
                //else
                //{
                //    if (tb.status > _selected.status && !Conf.BorderIdem)
                //        setSelect(tb);
                //    else if (tb.status == _selected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val > _selected.val)
                //            setSelect(tb);
                //    }
                //}

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;

                if (!tb.Virtual)
                {
                    if (_rejected == null)
                        _rejected = tb;
                    else if (tb.val < _rejected.val)
                        _rejected = tb;
                }

                if (_rejectedLight == null)
                    _rejectedLight = tb;
                else if (tb.val < _rejectedLight.val)
                    _rejectedLight = tb;


                //if (_rejected == null)
                //    setRejec(tb);
                //else
                //{
                //    if (tb.status > _rejected.status && !Conf.BorderIdem)
                //        setRejec(tb);
                //    else if (tb.status == _rejected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val < _rejected.val)
                //            setRejec(tb);
                //    }
                //}

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
            // Program.logAuto.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];
            lastOrg = org;
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            tpertinentOrg = getValue(pertinentOrg);
            //  misc.log(ToString());
        }
        private double dt = -1; public double Dt { get { return dt; } set { dt = value; } }
        private double tension; public double Tension { get { return tension; } }
        private int _stop = AutoBuilder.STOP_MAX;
        public bool Stop(int level) { return _stop < level; }

        public void stop(int level)
        {
            newv = lastOrg;
            org = lastOrg;
            if (_stop > level)
                _stop = level;
            save();
        }
        public void reset()
        {
            _stop = AutoBuilder.STOP_MAX;
        }
        public void setTension(bool up, bool real, bool checkSelect)
        {

            dt = getDt(up, real, checkSelect);
        }

        public void setTension()
        {
            tension = _getTension(org);
        }

        private double getDt(bool up, bool real, bool checkSelect)
        {
            double t0 = _getTension(pertinentOrg);
            tension = _getTension(up, real, checkSelect);
            return (tension - t0) / conf.coeff;

        }

        private double getTension(bool up, bool real, bool selected)
        {
            return _getTension(up, real, selected) / conf.coeff;
        }

        public double getValue(TimeSpan val)
        {
            switch (type)
            {

                case borderType.d:
                case borderType.fd:
                case borderType.nb:
                case borderType.c:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                default: return -1;

            }

        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.d:
                case borderType.fd:
                case borderType.nb:
                case borderType.c:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                default: return new TimeSpan();

            }
        }
        public double EvolSize { get { return evolSize; } }

        public List<Causes> getCauses()
        {
            return _causes;
        }

        //public List<Causes> getcauses(bool up, bool strict)
        //{
        //    List<Causes> list = null;
        //    if (up)
        //    {
        //        if (strict)
        //            list = _causesRejetStrict;
        //        else
        //            list = _causesRejet;
        //    }
        //    else
        //    {
        //        if (strict)
        //            list = _causesSelectStrict;
        //        else
        //            list = _causesSelect;
        //    }
        //    return list;
        //}

        public void gap(bool up, bool fix, double _gap)
        {
            _gap = Math.Abs(_gap);
            if (fix)
            {
                newv = Math.Abs(_gap);
            }
            else
            {
                if (up)
                    newv = org + _gap;
                else
                    newv = org - _gap;
            }
            save();
        }

        private double _getTension(bool up, bool strict, bool checkSelect)
        {
            lastStrict = strict;
            lastUp = up;
            // double t0 = getTension(org, dd);
            newv = org;
            evolSize = 0;
            var list = _causes;


            if (list.Count > 0)
            {
                int ifin = 2;
                bool bselect = !up;
                if (checkSelect)
                {
                    ifin = 1;
                }

                CauseItem cause = null;

                for (int i = 0; i < ifin; i++)
                {
                    var _cause = list[0].getCause(type, strict, !up, bselect);
                    bselect = !bselect;
                    if (_cause == null)
                        continue;
                    if (cause == null)
                        cause = _cause;
                    else
                    {
                        if (up)
                        {
                            if (_cause.val < cause.val)
                                cause = _cause;
                        }
                        else
                        {
                            if (_cause.val > cause.val)
                                cause = _cause;
                        }
                    }
                }
                if (cause == null)
                    return int.MaxValue;
                newv = Math.Round(getValue(cause.val), 8);
                foreach (var c in list)
                {
                    var cand = c.candidat;
                    evolSize += Stat.getSizeinMo(cand);
                }
            }
            else
                return int.MaxValue;


            //if (false)
            //{

            //    if (up)
            //    {
            //        var _rejected = strict ? this._rejected : this._rejectedLight;
            //        if (_rejected == null)
            //            return int.MaxValue;
            //        newv = Math.Abs(Math.Round(getValue(_rejected.val), 8));
            //        evolSize = Stat.getSizeinMo(_rejected.candidat);

            //    }
            //    else
            //    {
            //        var _selected = strict ? this._selected : this._selectedLight;
            //        if (_selected == null)
            //            return int.MaxValue;
            //        newv = Math.Round(getValue(_selected.val), 8);
            //    }
            //}

            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            _toSave = true;
        }

        public void save(timeSpan val)
        {
            this.newv = Math.Round(getValue(val), 8);
            save();
        }

        //public void save(double _newv)
        //{
        //    this.newv = Math.Round(_newv, 8);
        //    save();
        //}

        public void modif(double tension)
        {
            var val = this.newv == 0 ? org : this.newv;
            val = (tension / Tension) * val;
            if (type == borderType.nb)
                val = Math.Round(val, 0);
            this.newv = Math.Round(val, 8);
            save();
        }




        private List<Causes> _causes = new List<Causes>();

        public TrackInfoItunes Candidat { get; set; }
        // public CauseDataValue Cause { get; set; }
        public LimitItemBase limit { get; set; }


        //private List<Causes> _causesRejet = new List<Causes>();
        //private List<Causes> _causesSelect = new List<Causes>();

        //private List<Causes> _causesRejetStrict = new List<Causes>();
        //private List<Causes> _causesSelectStrict = new List<Causes>();



        //public void after()
        //{            
        //    _causesRejet = new List<Causes>();
        //    _causesSelect = new List<Causes>();
        //    _causesRejetStrict = new List<Causes>();
        //    _causesSelectStrict = new List<Causes>();
        //    after(true, true);
        //    after(true, false);
        //    after(false, true);
        //    after(false, false);
        //}
        //public void after(bool up, bool strict, bool checkSelection)
        //{
        //    _causes = new List<Causes>();
        //    var list = parent.CauseRegister.getList(false);
        //    int min = int.MaxValue;
        //    //  int minStrict = int.MaxValue;
        //    if (!up)
        //    {
        //        min = 0;
        //        //   minStrict = 0; 
        //    }
        //    int orgValue = torg.Value;
        //    foreach (Causes causes in list)
        //    {
        //        var candidat = causes.candidat;
        //        if (checkSelection)
        //        {
        //            if (up && candidat.Selected)
        //                continue;
        //            if (!up && !candidat.Selected)
        //                continue;
        //        }
        //        int ifin = 2;
        //        bool bselect = !up;
        //        if (checkSelection)
        //        {
        //            ifin = 1;
        //        }

        //        for (int i = 0; i < ifin; i++)
        //        {


        //            var cause = causes.getCause(type, strict, !up, bselect);
        //            bselect = !bselect;
        //            if (cause == null)
        //                continue;
        //            if (up && cause.Ok)
        //                continue;
        //            if (!up && !cause.Ok)
        //                continue;
        //            //if (value < 0)
        //            //    value = -value;
        //            int value = cause.val.Value;

        //            if (up)
        //            {

        //                if (value == min)
        //                {
        //                    _causes.Add(causes);

        //                }
        //                else if (value < min)
        //                {
        //                    _causes.Clear();
        //                    _causes.Add(causes);
        //                    min = value;
        //                }

        //            }
        //            else
        //            {
        //                if (value >= orgValue)
        //                    continue;

        //                if (value == min)
        //                {
        //                    _causes.Add(causes);
        //                }
        //                else if (value > min)
        //                {
        //                    _causes.Clear();
        //                    _causes.Add(causes);
        //                    min = value;
        //                }


        //            }
        //        }

        //    }
        //}


        private double _getTension(double org)
        {
            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }

        public double getTension(timeSpan org)
        {
            var _org = getValue(org);
            var t = _getTension(_org);
            // dt = t - _getTension(pertinentOrg); 

            return t;
        }





        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");

            if (newv != 0 && newv != org)
            {
                sb.Append("==>");
                sb.Append(newv);
                sb.Append(" ");
            }

            sb.Append("stop="); sb.Append(_stop); sb.Append(" ");

            sb.Append("pertinent="); sb.Append(pertinentOrg); sb.Append(" ");
            sb.Append("tension="); sb.Append(tension); sb.Append(" ");
            if (dt != -1)
            {
                sb.Append("dt="); sb.Append(dt); sb.Append(" ");
            }


            if (newv != 0 && newv != org)
            {
                sb.Append("<== ");
            }
            var causes = _causes; // getcauses(lastUp, lastStrict);

            //  sb.AppendLine(); 

            if (Candidat != null)
            {
                sb.AppendLine();
                sb.Append(Candidat); sb.Append(" ");
            }
            if (limit != null)
            {
                // sb.AppendLine(); 
                sb.Append(limit);
            }



            foreach (Causes cause in causes)
            {
                sb.AppendLine();
                var strStrict = lastStrict ? "strict " : "light ";
                var strselect = lastUp ? "rejet " : "select ";
                sb.Append(strselect);
                sb.Append(strStrict);
                sb.Append(cause.getCause(type, lastStrict, !lastUp, !lastUp));
                sb.Append(" "); sb.Append(cause.candidat);
            }

            //if (_causesRejetStrict.Count > 0)
            //{


            //    foreach (Causes cause in _causesRejetStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet strict "); sb.Append(cause.getCause(type,true,false));                     
            //    }
            //}

            //else if (_causesRejet.Count > 0)
            //{

            //    foreach (Causes cause in _causesRejet)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet light "); sb.Append(cause.getCause(type,false, false));      
            //    }
            //}

            //if (_causesSelectStrict.Count > 0)
            //{

            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select strict "); sb.Append(cause.getCause(type,true,true));      
            //    }
            //}

            //else if (_causesSelect.Count > 0)
            //{              
            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select light "); sb.Append(cause.getCause(type,false,true));      
            //    }
            //}



            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }


        public void signal(CauseDatas cd)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;

//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    public class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();

        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        // private Logger log;
        timeSpan currentDuration = new timeSpan();
        // timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;



        // List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> selectedByFd = new BgDictString0<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> manageByFd = new BgDictString0<TrackInfoItunes>();
        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            //log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }


        public timeSpan _durationv;
        public timeSpan _datev;
        public timeSpan _fd;

        public int _nb;

        public void checkV(AutoBuilder auto, int nb, timeSpan fd, timeSpan d, timeSpan date)
        {
            BgDictString0<TrackInfoItunes> dict = new BgDictString0<TrackInfoItunes>();

            int nbMin = int.MaxValue;
            timeSpan fdMin = timeSpan.MaxValue;
            timeSpan dMin = timeSpan.MaxValue;
            timeSpan dateMin = timeSpan.MaxValue;
            foreach (FeedLimitItemLoader loader in loaders.Values)
            {
                loader.checkV(nb, fd);
                var _nb = loader.NbV;
                var _fd = loader.FdV;
                if (_nb > nb && _nb < nbMin)
                    nbMin = _nb;
                if (_fd > fd && fd < fdMin)
                    fdMin = _fd;
                for (int i = 0; i <= loader.IndexV; i++)
                {
                    var track = loader.Candidats[i];
                    if (dict.ContainsKey(track.Location))
                        continue;
                    var _d = currentDuration + track.Duree;
                    if (_d > d && d < dMin)
                        dMin = _d;
                    var _date = track.Ts;
                    if (_date > date && _date < dateMin)
                        dateMin = _date;
                    break;
                }



            }

            this._durationv = dMin;
            this._datev = dateMin;
            this._nb = nbMin;
            this._fd = fdMin;
        }

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            //if (limit.Dir.Cascading)
            //{
            var dd = limit.LoadDuration;
            if (dd > duration)
            {
                loadEqSel = false;
                duration = dd;
            }
            //}

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                var d = candidat.Pub2;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                standAlone.Add(location, candidat);
                Exporter.Record(candidat);

                var loader = getLoader(candidat.Album);
                loader.AddCandidat(candidat);
                continue;



            }

        }




        private FeedLimitItemLoader getLoader(string album)
        {

            FeedLimitItemLoader loader = null;
            if (!loaders.ContainsKey(album))
            {
                loader = new FeedLimitItemLoader(limit, album, parent);
                loaders.Add(album, loader);
                if (parent.state == loadState.selection)
                    loader.phase2();
            }
            else
                loader = loaders[album];
            return loader;
        }

        /// <summary>
        /// On supprime tout sauf les standalone
        /// </summary>
        public void reset()
        {
            loaders = new BgDictString0<FeedLimitItemLoader>();
            //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
            // public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
            legacy = new SequentialDictString<TrackInfoItunes>();
            legacyRelax = new SequentialDictString<TrackInfoItunes>();
            selected = new SequentialDictString<TrackInfoItunes>();
            exclu = new SequentialDictString<TrackInfoItunes>();

            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();
            use = new List<TrackInfoItunes>();


            currentDuration = new timeSpan();
            // timeSpan currentDurationVirtual = new timeSpan();
            durationStop = new timeSpan();
            currentContrib = new timeSpan();
            trackDurationMax = new timeSpan();
            trackDurationMin = new timeSpan();
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            //  currentDurationVirtual = new timeSpan();
            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in loaders.Values)
                loader.phase2();
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }



        //private timeSpan getDuration(int nb, timeSpan minfd)
        //{
        //    timeSpan tot = new timeSpan();
        //    foreach (FeedLimitItemLoader feed in loaders.Values)
        //    {
        //        tot += feed.getTotalDurationFor(nb, minfd);
        //    }
        //    return tot;
        //}

        public void Selection()
        {

            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;
            if (relax.Count > 0)
            {
                if (histo)
                    relax.Sort(new PodCastComparer());
                else
                    relax.Sort(new PodCastComparerInv());
                selection(relax, false, false);
            }

            var list = legacy.List;
            if (list.Count > 0)
            {
                if (histo)
                    list.Sort(new PodCastComparer());
                else
                    list.Sort(new PodCastComparerInv());
                selection(list, false, true);
            }





            var list2 = standAlone.List;
            if (list2.Count > 0)
            {
                if (histo)
                    list2.Sort(new PodCastComparer());
                else
                    list2.Sort(new PodCastComparerInv());

                selection(list2, true, true);
            }

        }




        private void selection(List<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.Duration;
            var durationMax = timeSpan.FromMinutes(duration);
            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {
                TrackInfoItunes candidat = list[index];
                //foreach (TrackInfoItunes candidat in list)
                //{

                //if (candidat.Album == "Géopolitique")
                //{
                //}

                //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
                //{
                //}
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
                bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
                var loader = getLoader(candidat.Album);
                bool okTotalDuration = false;
                bool _control = false;

                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                okTotalDuration = currentDuration <= durationMax;

                bool okprovi = okDate && okTotalDuration;
                // bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                if (!increment) // données venant de sous-dossier (histo, voisins....)
                {
                    _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                }



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {
                    var newDuration = currentDuration + candidat.Duree;
                    okTotalDuration = newDuration <= durationMax;
                    if (manageByFd.ContainsKey(location))
                    {
                        _control = false;
                        if (selectedByFd.ContainsKey(location))
                            _control = true;
                    }
                    else
                    {
                        _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

                    }

                    if (_control)
                    {
                        //currentDurationVirtual += candidat.Duree;
                        if (okDate)
                            currentDuration += candidat.Duree;
                    }


                    // newDuration = currentDuration;
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                    //  okTotalDuration = newDuration <= durationMax;



                    //okTotalDuration = newDuration <= durationMax;
                    //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

                    //if (okDate && _control)
                    //    currentDuration += candidat.Duree;
                    //currentDurationVirtual = currentDuration; // += candidat.Duree;

                    //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

                    //  bool okTotalDuration = newDuration <= durationMax;

                    if (!_selection)
                    {


                        var _fd = loader.getCurrentDuration(false);

                        if (_fd > newDuration)
                        {
                            newDuration = _fd;
                            okTotalDuration = newDuration <= durationMax;
                        }
                        if (_control)
                        {
                        }
                        else
                        {
                            //var fd = loader.getCurrentDuration(true);
                            //var nb = loader.getNb(true);

                            //newDuration = new timeSpan();
                            //foreach (FeedLimitItemLoader l in loaders.Values)
                            //    l.phaseTest();
                            //for (int j = 0; j <= index; j++)
                            //{
                            //    TrackInfoItunes t = list[j];
                            //    var subloader = getLoader(t.Album);
                            //    var subok = subloader.test(nb, fd, t);
                            //    if (j >= subloader.IndexBase)
                            //    {
                            //        if (subok || selectedByFd.ContainsKey(location))
                            //            newDuration += t.Duree;
                            //    }

                            //}
                            //// newDuration += getDuration(nb, fd);

                            //if (newDuration < currentDuration)
                            //{
                            //}
                            //else if (newDuration > currentDurationVirtual)
                            //{
                            //}
                            //okTotalDuration = newDuration <= durationMax;
                        }


                        //question fd
                        //if (!loader.LoadEqSel)
                        //{

                        var causeReg0 = limit.Dir.CauseRegister;
                        if (!causeReg0.IsNull)
                        {
                            var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                          loader.OkFd, loader.getDurationStop(okDate)
                          , loader.OkNb, loader.getNbStop(okDate)
                          , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

                            causeReg0.signal(dataRoot);
                        }

                        if (limit.canSignal())
                        {

                            var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                                //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                                //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                                //, okTotalDuration, newDuration, candidat, limit);
                                    loader.OkFd, _fd// loader.getCurrentDuration (false)
                            , loader.OkNb, loader.getNb(false)
                            , okTotalDuration, newDuration, candidat, limit);

                            limit.signal(dataAuto);
                        }
                    }




                    //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                    //loader.OkFd, loader.getDurationStop(okDate)
                    //, loader.OkNb, loader.getNbStop(okDate)
                    //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                    //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                    //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                    //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

                    if (Conf.BorderTb)
                    {
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
                        else if (okDate && okTotalDuration)
                        {
                            if (loader.EndByFd)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
                        }
                        //else if (Conf.BorderVirtual)
                        //{
                        //    if (_control)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
                        //    else if (loader.EndByFd)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
                        //}


                        //}

                        //if (!loadEqSel)
                        //{
                        // question d
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                        else if (okDate && _control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okTotalDuration)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                        }


                        // question date
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                        else if (_control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okDate)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                        }

                        //}

                    }


                    ////question duree
                    //if (okDate && _control) // || Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
                    //}

                    ////question fd

                    //if (_control)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

                    //    }
                    //}
                    //else //if (!loader.limit.NbFeedLimit)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                    ////question date
                    //if (_control && okDuration)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
                    //    limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
                    //    limit.signal(tb);
                    //}



                    //if (!_control && !Conf.BorderVirtual)
                    //    continue;
                    if (!okDate)
                        continue;

                    if (!_control)
                        continue;
                    newDuration = currentDuration;
                    okTotalDuration = newDuration <= durationMax;
                    if (!okTotalDuration)
                    {
                        //if (!Logger.CreateNullLoggers)
                        //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                        {
                            // currentDuration = newDuration;
                            durationStop = currentDuration;
                        }

                    }

                    if (!okTotalDuration)
                        continue;


                    if (_selection && !newContribut)
                    {
                        // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            // log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }

                    //   currentDuration = newDuration;




                    if (_selection)
                    {
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        limit.Dir.recordTrack(candidat, limit);
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        //  limit.Dir.recordTrack(candidat, limit);

                        selected.Add(location, candidat);

                        if (select)
                            exclu.Add(location, candidat);
                    }





                }

            }
        }


        //private void selection0(List<TrackInfoItunes> list, bool select, bool increment)
        //{
        //    var duration = limit.Duration;
        //    var durationMax = timeSpan.FromMinutes(duration);
        //    var contributionMax = timeSpan.FromMinutes(limit.Contribution);

        //    int count = list.Count;
        //    for (int index = 0; index < count; index++)
        //    {
        //        TrackInfoItunes candidat = list[index];
        //        //foreach (TrackInfoItunes candidat in list)
        //        //{

        //        //if (candidat.Album == "Géopolitique")
        //        //{
        //        //}

        //        //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
        //        //{
        //        //}
        //        var location = candidat.Location;
        //        if (string.IsNullOrEmpty(location))
        //            continue;

        //        //if (_selection && selected.ContainsKey(location))
        //        //    continue;
        //        // vérification à postériori par rapports aux différents niveaux
        //        bool newContribut = candidat.Selected;

        //        DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
        //        bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
        //        var loader = getLoader(candidat.Album);
        //        bool okTotalDuration = false;
        //        bool _control = false;

        //        //tester uniquement fd et nb
        //        // _control = loader.control(candidat, select, false, false);

        //        // var _newDuration = currentDuration;
        //        //if (increment)
        //        //    _newDuration = currentDuration + candidat.Duree;

        //        // savoir si ça passe uniquement avec le critère d
        //        okTotalDuration = currentDuration <= durationMax;

        //        bool okprovi = okDate && okTotalDuration;
        //        bool ok = okDate && okTotalDuration && _control;

        //        // rejouer le controle pour incrémenter nb et fd      
        //        if (!increment) // données venant de sous-dossier (histo, voisins....)
        //        {
        //            _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //        }



        //        //if (!loader.LoadEqSel)
        //        //{

        //        //    if (_control)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
        //        //    else if (loader.EndByFd)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

        //        //}

        //        //if (!increment && !_selection) //!loader.LoadEqSel &&
        //        //{
        //        //    //  if (!loader.OkNb)
        //        //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
        //        //    // if (!loader.OkFd)
        //        //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

        //        //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //        //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //        //}

        //        //if (!control(candidat, select, okDuration))
        //        //    continue;

        //        if (increment)
        //        {
        //            var newDuration = currentDuration + candidat.Duree;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (manageByFd.ContainsKey(location))
        //            {
        //                _control = false;
        //                if (selectedByFd.ContainsKey(location))
        //                    _control = true;
        //            }
        //            else
        //            {
        //                _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

        //            }

        //            if (_control)
        //            {
        //                //currentDurationVirtual += candidat.Duree;
        //                if (okDate)
        //                    currentDuration += candidat.Duree;
        //            }


        //            // newDuration = currentDuration;
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //            //  okTotalDuration = newDuration <= durationMax;



        //            //okTotalDuration = newDuration <= durationMax;
        //            //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

        //            //if (okDate && _control)
        //            //    currentDuration += candidat.Duree;
        //            //currentDurationVirtual = currentDuration; // += candidat.Duree;

        //            //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

        //            //  bool okTotalDuration = newDuration <= durationMax;

        //            if (!_selection)
        //            {


        //                var _fd = loader.getCurrentDuration(false);

        //                if (_fd > newDuration)
        //                {
        //                    newDuration = _fd;
        //                    okTotalDuration = newDuration <= durationMax;
        //                }
        //                if (_control)
        //                {
        //                }
        //                else
        //                {
        //                    //var fd = loader.getCurrentDuration(true);
        //                    //var nb = loader.getNb(true);

        //                    //newDuration = new timeSpan();
        //                    //foreach (FeedLimitItemLoader l in loaders.Values)
        //                    //    l.phaseTest();
        //                    //for (int j = 0; j <= index; j++)
        //                    //{
        //                    //    TrackInfoItunes t = list[j];
        //                    //    var subloader = getLoader(t.Album);
        //                    //    var subok = subloader.test(nb, fd, t);
        //                    //    if (j >= subloader.IndexBase)
        //                    //    {
        //                    //        if (subok || selectedByFd.ContainsKey(location))
        //                    //            newDuration += t.Duree;
        //                    //    }

        //                    //}
        //                    //// newDuration += getDuration(nb, fd);

        //                    //if (newDuration < currentDuration)
        //                    //{
        //                    //}
        //                    //else if (newDuration > currentDurationVirtual)
        //                    //{
        //                    //}
        //                    //okTotalDuration = newDuration <= durationMax;
        //                }


        //                //question fd
        //                //if (!loader.LoadEqSel)
        //                //{
        //                var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //              loader.OkFd, loader.getDurationStop(okDate)
        //              , loader.OkNb, loader.getNbStop(okDate)
        //              , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

        //                limit.Dir.CauseRegister.signal(dataRoot);

        //                var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //                    //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
        //                    //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
        //                    //, okTotalDuration, newDuration, candidat, limit);
        //                        loader.OkFd, _fd// loader.getCurrentDuration (false)
        //                , loader.OkNb, loader.getNb(false)
        //                , okTotalDuration, newDuration, candidat, limit);

        //                limit.signal(dataAuto);
        //            }




        //            //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
        //            //loader.OkFd, loader.getDurationStop(okDate)
        //            //, loader.OkNb, loader.getNbStop(okDate)
        //            //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

        //            //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //            //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //            //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

        //            if (Conf.BorderTb)
        //            {
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
        //                else if (okDate && okTotalDuration)
        //                {
        //                    if (loader.EndByFd)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
        //                }
        //                //else if (Conf.BorderVirtual)
        //                //{
        //                //    if (_control)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
        //                //    else if (loader.EndByFd)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
        //                //}


        //                //}

        //                //if (!loadEqSel)
        //                //{
        //                // question d
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
        //                else if (okDate && _control)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okTotalDuration)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
        //                }


        //                // question date
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
        //                else if (_control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okDate)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
        //                }

        //                //}

        //            }


        //            ////question duree
        //            //if (okDate && _control) // || Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
        //            //}

        //            ////question fd

        //            //if (_control)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

        //            //    }
        //            //}
        //            //else //if (!loader.limit.NbFeedLimit)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
        //            //        limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
        //            //        limit.signal(tb);
        //            //    }
        //            //}
        //            ////question date
        //            //if (_control && okDuration)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
        //            //    limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
        //            //    limit.signal(tb);
        //            //}



        //            //if (!_control && !Conf.BorderVirtual)
        //            //    continue;
        //            if (!okDate)
        //                continue;

        //            if (!_control)
        //                continue;
        //            newDuration = currentDuration;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (!okTotalDuration)
        //            {
        //                //if (!Logger.CreateNullLoggers)
        //                //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

        //                if (_selection)
        //                    limit.DurationLimitAtteinte = true;
        //                if (durationStop.Value == 0)
        //                {
        //                    // currentDuration = newDuration;
        //                    durationStop = currentDuration;
        //                }

        //            }

        //            if (!okTotalDuration)
        //                continue;


        //            if (_selection && !newContribut)
        //            {
        //                // pour l'instant ? on ne gère pas la contribtion en mode rejeu

        //                currentContrib += candidat.Duree;
        //                if (currentContrib > contributionMax)
        //                {
        //                    //  log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
        //                    limit.ContributionLimitAtteinte = true;
        //                    break;
        //                }

        //                use.Add(candidat);
        //            }

        //            //   currentDuration = newDuration;




        //            if (_selection)
        //            {
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                limit.Dir.recordTrack(candidat, limit);
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                //  limit.Dir.recordTrack(candidat, limit);

        //                selected.Add(location, candidat);

        //                if (select)
        //                    exclu.Add(location, candidat);
        //            }





        //        }

        //    }
        //}

        public LimitItem Item { get { return limit; } }
        public override string ToString()
        {
            return limit.ToString();
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Selection\Conv.cs">
    <content><![CDATA[using System;

namespace pdb.podcast.Selection
{
    public static class Conv
    {
        public static bool Success(this byte mode) { return (int)mode % 2 == 1; }
        public static bool Selected(this byte mode)  { return mode >= 2; }
        public static bool Update(this byte mode) { return (int)mode % 4 == 1; }

        public static byte getMode(this bool succes, bool selected)
        {
            return (byte)(2 * Convert.ToInt16(selected) + Convert.ToInt16(succes));
        }
        public static causeMode update(this causeMode mode)
        {
            return mode | causeMode.virtuel; 
        }
        public static causeMode createMode(this bool success, bool selected)
        {
            return (causeMode)(2 * Convert.ToInt16(selected) + Convert.ToInt16(success));
        }
        public static bool Success(this causeMode mode) { return mode.HasFlag(causeMode.success); }
       // public static bool Selected(this causeMode mode) { return mode.HasFlag(causeMode.selected); }
        public static bool Update(this causeMode mode) { return mode.HasFlag(causeMode.update); }
        public static bool Virtuel(this causeMode mode) { return mode.HasFlag(causeMode.virtuel); }


    }
    [Flags]
    public enum causeMode : byte
    {
        success = 1,
        selected =2,
        virtuel =4,
        update =8
    }
    //1=>ok
    //2=>selected nok =>n'arrive pas
    //3 ok,selected
    // 4=> virtuel
    // 5=> virtuel ok
    // 6 virtuel selected nok => n'arrive pas
    // 7 virtuel selected ok
    // update
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Auto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.podcast.Auto;
using pdb.util;
namespace pdb.podcast.Tuning
{
    class Auto
    {
        delegate void sets(string value);
        delegate void setd(double value);
        delegate void seti(int value);
        delegate void setb(bool value);

        private void buildd(XmlNode parent, XmlNode child, string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
        }

        private void buildi(XmlNode parent, XmlNode child, string name, seti seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }

        private void builds(XmlNode parent, XmlNode child, string name, sets sets)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                sets(att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                sets(att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                sets(elt.InnerText);
            elt = child[name];
            if (elt != null)
                sets(elt.InnerText);
        }

        private void buildb(XmlNode parent, XmlNode child, string name, setb setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setb("true" == elt.InnerText);
            elt = child[name];
            if (elt != null)
                setb("true" == elt.InnerText);
        }

        public string name = "";
        public borderType type = borderType.d;
        public double target;
        public double delta;
        public double write;
        public int cloop = 20;
        public int verif = 4;
        public int idem = 4;
        public int order = int.MaxValue;
        public double min = -int.MaxValue;
        public double max = int.MaxValue;
        public double coeff = 0;
        public bool selectFix;
        public bool selectAbs;
        public bool pertinentAll;
        public bool pertinentExclu; 
        public bool stopAll=true;
       // public bool checkStrict;
       // public bool checkSelect;
        public bool checkEvol; 
        public bool gap = false; 
        public double pente; 
        public List<Level> levels = new List<Level>();
        public List<Auto> items = new List<Auto>();
        public double forfaitNegatif = 0;
        public int forfaitNegatifOffset = 20; 

        public Auto()
        {
        }
        public Auto(Auto parent, XmlElement xparent, XmlElement node)
        {
            if (node == null)
                return;
            //if (parent != null)
            //{
            //    name = parent.name; 
            //    type = parent.type; 
            //    target = parent.target; 
            //    write = parent.write; 
            //    delta = parent.delta; 
            //    write = parent.write; 
            //    cloop = parent.cloop; 
            //    verif = parent.verif; 
            //    idem = parent.idem; 
            //    order = parent.order; 
            //    min = parent.min; 
            //    max = parent.max; 
            //    coeff = parent.coeff; 
            //    levels = new List<Level>(parent.levels); 
            //}
            XMLTool xml = new XMLTool(node);

            if (node.Attributes["type"] != null)
                type = (borderType)Enum.Parse(typeof(borderType), node.Attributes["type"].Value, true);
            builds(xparent, node, "name", (v) => name = v);
            buildd(xparent, node, "target", (v) => target = v);
            buildd(xparent, node, "delta", (v) => delta = v);
            buildd(xparent, node, "write", (v) => write = v);
            buildi(xparent, node, "cloop", (v) => cloop = v);
            buildi(xparent, node, "verif", (v) => verif = v);
            buildi(xparent, node, "verif", (v) => idem = v);
            buildi(xparent, node, "order", (v) => order = v);

            buildd(xparent, node, "min", (v) => min = v);
            buildd(xparent, node, "max", (v) => max = v);
            buildd(xparent, node, "coeff", (v) => coeff = v);
            buildb(xparent, node, "selectFix", (v) => selectFix = v);
            buildb(xparent, node, "selectAbs", (v) => selectAbs = v);
            buildb(xparent, node, "pertinentAll", (v) => pertinentAll = v);
            buildb(xparent, node, "stopAll", (v) => stopAll = v);
            buildb(xparent, node, "gap", (v) => gap = v);
           // buildb(xparent, node, "checkStrict", (v) => checkStrict = v);
           // buildb(xparent, node, "checkSelect", (v) => checkSelect = v);
            buildb(xparent, node, "checkEvol", (v) => checkEvol = v);
            buildb(xparent, node, "pertinentExclu", (v) => pertinentExclu = v);
            buildd(xparent, node, "pente", (v) => pente = v);
            buildd(xparent, node, "forfaitNegatif", (v) => forfaitNegatif = v);
            buildi(xparent, node, "forfaitNegatifOffset", (v) => forfaitNegatifOffset = v); 

            

            /*//  type = xml.getAttValue("type");
            //  target = xml.getDoubleAttValue("target");
             // delta = xml.getDoubleAttValue("delta");
             // write = xml.getDoubleAttValue("write");
            //  cloop = xml.getIntAttValue("cloop", 20);
            //  verif = xml.getIntAttValue("verif", 4);
             // idem = xml.getIntAttValue("idem", 4);
             // order = xml.getIntAttValue("order", int.MaxValue);
              min = xml.getDoubleAttValue("min", -int.MaxValue);
              max = xml.getDoubleAttValue("max", int.MaxValue);
              coeff = xml.getDoubleAttValue("coeff", 0);
           
              string str = "";
              if (target < 0)
              {
                  str = xml.getNodeValue("target");
                  if (!string.IsNullOrEmpty(str))
                      target = Convert.ToDouble(str);
              }
              if (delta < 0)
              {
                  str = xml.getNodeValue("delta");
                  if (!string.IsNullOrEmpty(str))
                      delta = Convert.ToDouble(str);
              }
              if (write < 0)
              {
                  str = xml.getNodeValue("write");
                  if (!string.IsNullOrEmpty(str))
                      write = Convert.ToDouble(str);
              }
              str = xml.getNodeValue("cloop");
              if (!string.IsNullOrEmpty(str))
                  cloop = Convert.ToInt16(str);
              str = xml.getNodeValue("verif");
              if (!string.IsNullOrEmpty(str))
                  verif = Convert.ToInt16(str);
              str = xml.getNodeValue("idem");
              if (!string.IsNullOrEmpty(str))
                  idem = Convert.ToInt16(str);
              str = xml.getNodeValue("order");
              if (!string.IsNullOrEmpty(str))
                  order = Convert.ToInt16(str);
              str = xml.getNodeValue("min");
              if (!string.IsNullOrEmpty(str))
                  min = Convert.ToDouble(str);
              str = xml.getNodeValue("max");
              if (!string.IsNullOrEmpty(str))
                  max = Convert.ToDouble(str);
              str = xml.getNodeValue("coeff");
              if (!string.IsNullOrEmpty(str))
                  coeff = Convert.ToDouble(str);
              levels = new List<Level>();*/

            if (parent != null)
                levels = new List<Level>(parent.levels);

            var xlevels = xml.NodeLookUp("levels");

            if (xlevels != null)
            {
                levels.Clear();
                foreach (XmlNode sub in xlevels.ChildNodes)
                {
                    if (sub is XmlElement)
                    {
                        var level = new Level(sub as XmlElement);
                        levels.Add(level);
                    }
                }
            }
            else if (levels.Count == 0)
            {
                var level = new Level(node);
                levels.Add(level);
            }
            var xitems = xml.NodeLookUp("items");
            if (xitems != null)
            {
                foreach (XmlNode sub in xitems.ChildNodes)
                {
                    if (sub is XmlElement)
                    {
                        var subAuto = new Auto(this, node, sub as XmlElement);
                        items.Add(subAuto);
                    }
                }
            }

        }
    }
    class Level
    {
        public double d;
        public double inf;
        public double sup;
        public Level()
        {
        }
        public Level(XmlElement node)
        {
            if (node == null)
                return;
            XMLTool xml = new XMLTool(node);
            d = xml.getDoubleAttValue("d");
            inf = xml.getDoubleAttValue("inf");
            sup = xml.getDoubleAttValue("sup");
            string str = xml.getAttValue("d");
            if (!string.IsNullOrEmpty(str))
                d = Convert.ToDouble(str);
            str = xml.getAttValue("inf");
            if (!string.IsNullOrEmpty(str))
                inf = Convert.ToDouble(str);
            str = xml.getAttValue("sup");
            if (!string.IsNullOrEmpty(str))
                sup = Convert.ToDouble(str);
        }
    }
}]]></content>
  </file>
</db>
