<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.podcast\Sort\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Albums;
using pdb.podcast.Tuning;
using pdb.podcast.Tuning.Sort;
using pdb.util;
using pdb.iit;

namespace pdb.podcast.Sort
{
    class Album
    {
        const char SEP = '|';
        private TrackAlbum album;
        private SortItem conf;
        private List<TrackSort> list = new List<TrackSort>();
        //  private static HashSet<int> lastReads = new HashSet<int>();
        //   private int indexLastRead = -1;
        timeSpan limit;
        // private static int nbrepeches = 0;
        private static int nbModif = 0;
        private static int nbRepecheForce = 0;
        private static DateTime dateRepeche = DateTime.MaxValue; public static DateTime DateRepeche { get { return dateRepeche; } }
        private static List<TrackSort> repeches = new List<TrackSort>();
        public static int NbRepeches { get { return repeches.Count; } }
        public static int NbModif { get { return nbModif; } }
        private bool done;
        public static void Init()
        {
            //lastReads.Clear(); 
            //nbrepeches = 0;
            repeches.Clear();
            nbModif = 0;
            nbRepecheForce = 0;
            dateRepeche = DateTime.MaxValue;
        }

        public static void Bilan()
        {
            if (dateRepeche < DateTime.MaxValue)
                log.log("*************Date minimum:" + dateRepeche);
            repeches.Sort((x, y) => x.Pub2.CompareTo(y.Pub2)); 
            foreach (TrackSort t in repeches)
            log.log(string.Format("date={0} {1}", t.Pub2, t)); 
        }
        // public static HashSet<int> LastRead { get { return lastReads; } }
        public static Logger log;

        public Album(SortItem conf, TrackAlbum album)
        {
            this.conf = conf;
            this.album = album;
            limit = timeSpan.FromMinutes(conf.dureeMin);

        }

        public override string ToString()
        {
            return album.ToString();
        }

        public void check(TrackInfoItunes track)
        {
            if (track.Duree >= limit)
                list.Add(new TrackSort(track));
        }

        //public void Build(Loader loader)
        //{

        //    if (conf.enabled == sortMode.no)
        //        return;
        //    int count = list.Count;
        //    if (count == 0)
        //        return;
        //    int indexLastRead = -1;
        //    int indexNextSelected = -1;
        //    DateTime lastPlayed = DateTime.MinValue;
        //    TrackSort next = null;
        //    TrackSort reallyLastRead = null;
        //    DateTime currentPub = DateTime.MinValue;
        //    DateTime currentPub2 = DateTime.MinValue;
        //    TrackSort lastRead = null;



        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        if (track.Selected)
        //        {
        //            next = track;
        //            indexNextSelected = i;
        //            break;
        //        }
        //    }

        //    if (next == null)
        //        return;

        //    int nbRead = 0;
        //    int nbTotal = 0;

        //    var histo = conf.getHisto(album.Rare);

        //    DateTime limit = next.Pub.AddDays(-histo);
        //    for (int i = indexNextSelected - 1; i >= 0; i--)
        //    {
        //        var t = list[i];
        //        var dt = t.Pub;
        //        if (dt < limit)
        //            break;

        //        if (t.Played)
        //            nbRead++;

        //        if (t.Played || t.track.Enabled)
        //            nbTotal++;

        //    }
        //    double delta = conf.getIntervalle(album.Rare);
        //    var intervalle = conf.getIntervalle(album.Rare);
        //    var intervalleMin = conf.getIntervalleMin(album.Rare);
        //    if (nbRead > 0 && nbTotal > 0)
        //    {
        //        //  album.Rare ? conf.intervalleR : conf.intervalle;
        //        var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

        //        delta = (intervalle * (double)nbTotal) / (ecouteMax * (double)nbRead);
        //        var coeff = (double)nbTotal / (double)nbRead;

        //        //0.1 => 10
        //        //0.9 => 1.11
        //        coeff -= 1; // 9  0.11
        //        var dminmax = intervalle - intervalleMin;

        //        var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

        //        if (_delta < delta)
        //            delta = _delta;
        //        else
        //        {
        //        }
        //    }


        //    var deltaLecture = (DateTime.Now - reallyLastRead.PlayedDate).TotalDays;



        //    for (int j = 0; j < indexNextSelected; j++)
        //    {
        //        for (int i = j; i < indexNextSelected; i++)
        //        {
        //            var track = list[i];
        //            if (track.Played)
        //            {
        //                reallyLastRead = track;
        //                lastRead = track;
        //                indexLastRead = i;
        //                lastPlayed = track.PlayedDate;
        //                j = i;
        //                break;
        //            }
        //        }
        //        var pub2 = lastRead.Pub2;

        //        if (conf.extPente > 0)
        //        {
        //            var d0 = (DateTime.Now - pub2).TotalDays;
        //            var dl = conf.extDelta;
        //            if (dl == 0)
        //            {
        //                dl = d0;
        //            }

        //            delta = d0 / conf.extPente;
        //            //01/01/2014 ->01/01/2017
        //            //04/01/2017 -> 04/01/2014
        //            var dateLimitEcoule = DateTime.Now.AddDays(-dl);

        //            var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
        //            log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

        //            if (deltaLimiteEcoule > delta)
        //                delta = deltaLimiteEcoule;

        //            if (delta < 1)
        //                delta = 1;



        //        }

        //        if (conf.limitRead && deltaLecture > intervalle)
        //        {
        //            //13 /10 ->7
        //            var _old = delta;

        //            delta += intervalle - deltaLecture;
        //            log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
        //        }

        //        if (delta < intervalleMin)
        //            delta = intervalleMin;

        //        if (delta > intervalle)
        //            delta = intervalle;


        //        DateTime limitFuture = pub2.AddDays(delta);

        //        if (limitFuture.Second > 0)
        //        {
        //            limitFuture = new DateTime(limitFuture.Ticks - limitFuture.Ticks % TimeSpan.TicksPerMinute + TimeSpan.TicksPerMinute);
        //        }


        //        DateTime nextDate = limitFuture;
        //        int nb = 0;
        //        int nblissage = 0;
        //        double deltaMinute = 1;

        //        if (conf.noCollision)
        //            deltaMinute = TimeSpan.FromDays(delta).TotalMinutes;

        //        if (conf.deltaConst)
        //        {

        //        }

        //        else
        //        {
        //            var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
        //            var _deltaRab = limitFuture.AddDays(conf.deltaRab);

        //            for (int i = indexLastRead + 1; i < list.Count; i++)
        //            {
        //                var t = list[i];
        //                if (t.Pub >= limitFuture)
        //                {
        //                    nextDate = t.Pub;
        //                    nblissage++;
        //                    if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
        //                        break;
        //                }
        //                nb++;
        //            }

        //            if (nextDate > limitFuture && nb > 0 && conf.noCollision)
        //                deltaMinute = (nextDate - limitFuture).TotalMinutes / (double)nb;
        //        }

        //        if (deltaMinute < 1)
        //            deltaMinute = 1;



        //        nb = 0;
        //        for (int i = indexLastRead + 1; i < count; i++)
        //        {

        //            var t = list[i];

        //            if (!t.Selected && conf.enabled != sortMode.reset)
        //                continue;
        //            if (!t.track.Enabled)
        //                continue;
        //            var dt = limitFuture.AddMinutes(deltaMinute * nb);
        //            var _delta = (dt - lastRead.Pub2).TotalDays;

        //            if (t.Pub >= dt || conf.enabled == sortMode.reset)
        //                t.increasePub(t.Pub);
        //            else
        //            {
        //                t.increasePub(dt);
        //                nb++;
        //            }


        //        }
        //    }

        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = list[i];
        //        if (!track.Selected)
        //            continue;
        //        var pub2 = track.Pub2;
        //        var newPub = track.getPub();

        //        if (newPub != pub2)
        //        {
        //            writeComment(track, newPub);
        //        }
        //    }









        //    //  log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", delta.ToString("#.##"), nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));









        //    for (int i = 0; i < list.Count; i++)
        //    {
        //        var track = list[i].track;

        //        if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
        //        {
        //            var aux = currentPub2.AddMinutes(1);
        //            log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
        //            track.Pub2 = aux;
        //        }

        //        currentPub = track.Pub;
        //        currentPub2 = track.Pub2;
        //    }


        //}


        public void init()
        {
            done = false;
        }

        public void buildAll()
        {
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;



            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                var dt = track.Pub2.AddSeconds(1);
                build(false, false, dt, dt);
                if (dt >= Conf.Date0)
                    break;
            }

            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                applyPub(track);
            }
        }

        private void build(bool checkSelected, bool apply, DateTime date0, DateTime newDate0)
        {
            int count = list.Count;
            if (count == 0)
                return;
            if (album.Album.Equals("L'ELOGE DU SAVOIR"))
            {
            }
            if (album.Album.Equals("Mauvais genres"))
            {
            }
           

            TrackSort.Date0 = date0;
            int indexLastRead = -1;
            TrackSort lastRead = null;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    //// ok mais quid du cas au fil de l'histoire : date dans le futur
                    //if (track.Pub2 <= date0 || conf.extPente > 0)
                    //{
                    if (next == null)
                    {
                        indexLastRead = i;
                        lastPlayed = track.PlayedDate;
                        lastRead = track;
                    }
                    else
                        break;
                    //}
                }

                else
                {
                    if (next == null)
                    {
                        if ((checkSelected && track.Selected) || track.Pub2 >= date0)
                        {
                            next = track;
                            indexNextSelected = i;
                        }
                    }
                    else
                        break;
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;


            var intervalle = conf.getIntervalle(album.Rare, lastRead.DureeEnHeure);
            var intervalleMin = conf.getIntervalleMin(album.Rare, lastRead.DureeEnHeure);
            var intervalleMin0 = conf.getIntervalleMin0(album.Rare);
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = intervalle; // conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    if (conf.dureeBornee)
                    {
                        coeff = conf.getCoeff(album.Rare, coeff, lastRead.DureeEnHeure);
                    }

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                {
                    double _coeff = deltaLimiteEcoule / delta;
                    delta = borne(_coeff, intervalle, intervalleMin);
                }

                if (delta < 1)
                    delta = 1;




                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }





            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();

            DateTime limitFutureRab = pub2.AddDays(conf.coeffRab * delta).truncateToMinute();
            //var cumul = (limitFuture - next.Pub).TotalDays;
            //var dtaux = next.Pub.AddDays(conf.coeffRab * cumul).truncateToMinute();
            //if (dtaux > limitFutureRab)
            //    limitFutureRab = dtaux; 
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = delta;
            if (conf.extPente > 0)
                deltaAtterrissage = delta0;


            if (conf.deltaConst || conf.extPente > 0)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);

                DateTime dt = lastRead.Pub.AddDays(intervalleMin0);

                for (int i = indexLastRead + 2; i < count; i++)
                {
                    var t = list[i];
                    if (conf.useVirtuel)
                    {
                        // on utilise des tracks virtuels pour pallier aux absences (week end, track manquant...)
                        dt = dt.AddDays(intervalleMin0);
                    }
                    else
                        dt = t.Pub;


                    nb++;
                    if (dt > limitFuture)
                    {
                        nextDate = dt;
                        nblissage++;
                        if (dt <= _deltaMin)
                            continue;
                        if (dt <= _deltaRab)
                            continue;
                        if (nb <= conf.deltaNbMin)
                            continue;
                        if (nblissage <= conf.deltaNbRab)
                            continue;
                        if (dt <= limitFutureRab)
                            continue;

                        break;


                        //if (dt > _deltaMin && dt > _deltaRab && nb > conf.deltaNbMin && nblissage > conf.deltaNbRab && dt > limitFutureRab)
                        //    break;
                    }

                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    deltaAtterrissage = (nextDate - limitFuture).TotalDays / (double)nb;
                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2} {3}->{4}", intervalle.ToString("0.##"), deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            //  nb = 0;
            // bool enRetard = limitFuture < date0;
            TrackSort last = next;
            DateTime lastPub2 = limitFuture;
            int indexDepart = indexLastRead + 1;

            bool erased = false;

            for (int i = indexDepart; i < count; i++)
            {
                var t = list[i];
                if (erased && conf.erasedDone)
                {
                    eraseSort(t, checkSelected, apply, date0, newDate0);
                    continue; 
                }
              
                DateTime dt = lastPub2;

                if (i == indexDepart && !conf.useVirtuel2)
                {
                    dt = limitFuture;
                }
                else
                {

                    //if (conf.deltaCheckSelected)
                    //{
                    //    if (!t.Selected)
                    //        continue;
                    //    if (!t.Enabled)
                    //        continue;
                    //}
                    var d = (t.Pub - last.Pub).TotalDays / intervalleMin0;


                    if (conf.useVirtuel2)
                        dt = lastPub2.AddDays(d * deltaAtterrissage).truncateToMinute();  //  (int)(tsatt.TotalMinute * nb)).truncateToMinute();
                    else
                        dt = lastPub2.AddDays(deltaAtterrissage).truncateToMinute();
                    if (dt < date0 && conf.deltaConstLate)
                    {
                        var dt2 = dt;
                        if (conf.useVirtuel2)
                            dt2 = lastPub2.AddDays(d * delta).truncateToMinute();
                        else
                            dt2 = lastPub2.AddDays(delta).truncateToMinute();
                        //if (dt2 <= date0)
                        dt = dt2;
                        //else
                        //    dt = date0.AddMinutes(1);
                    }


                }

              

                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset || erased && conf.erasedDone)
                {
                    erased = true; 
                    eraseSort(t, checkSelected, apply, date0, newDate0);
                }
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }


                    if (dt > DateTime.Now)
                    {
                    }

                    if ((dt - t.Pub).TotalDays > 100)
                    {
                    }

                    writeComment(t, dt, checkSelected, apply, date0, newDate0);
                    //nb++;
                }


                last = t;
                lastPub2 = dt;


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }

        }

        public void build()
        {
            if (done)
                return;
            done = true;
            if (conf.enabled == sortMode.no)
                return;
            int count = list.Count;
            if (count == 0)
                return;

            if (conf.enabled == sortMode.histo)
            {
                buildAll();
                return;
            }
            else
            {
                build(true, true, Conf.Date0, Conf.NewDate0);
                return;
            }

            #region old
            /* if (conf.enabled == sortMode.reset)
            {
                foreach (var t in list)
                {
                    eraseSort(t, true, true);
                }

                return;
            }

            int indexLastRead = -1;
            int indexNextSelected = -1;
            DateTime lastPlayed = DateTime.MinValue;
            TrackSort next = null;
            //  TrackSort reallyLastRead = null;
            DateTime currentPub = DateTime.MinValue;
            DateTime currentPub2 = DateTime.MinValue;
            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                //if (conf.extPente > 0)
                //{
                //    if (!track.Played && track.Pub == track.Pub2)
                //        track.Pub2 = Conf.Date0; 
                //}

                if (track.Pub > currentPub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;


                if (track.Played) // && track.PlayedDate > lastPlayed)
                {
                    // ok mais quid du cas au fil de l'histoire : date dans le futur
                    if (track.Pub2 <= Conf.Date0 || conf.extPente > 0)
                    {
                        if (next == null)
                        {
                            indexLastRead = i;
                            lastPlayed = track.PlayedDate;
                        }
                    }
                }

                else if (next == null)
                {
                    if (track.Selected)
                    {
                        next = track;
                        indexNextSelected = i;
                        // break;
                    }
                }
            }


            if (indexLastRead < 0)
                return;
            if (next == null)
                return;
            var intervalle = conf.getIntervalle(album.Rare);
            var intervalleMin = conf.getIntervalleMin(album.Rare);
            var lastRead = list[indexLastRead];
            double deltaLastRead0 = (lastRead.Pub2 - lastRead.Pub).TotalDays;
            DateTime pub2 = lastRead.Pub2;

            double delta0Corr = deltaLastRead0;

            double cumulMin = conf.getCumulMin(album.Rare);
            double cumulMax = conf.getCumulMax(album.Rare);

            if (pub2 > lastRead.Pub && conf.extPente == 0)
            {
                if (conf.elastique < 1)
                {
                    delta0Corr = deltaLastRead0 * conf.elastique;
                    pub2 = lastRead.Pub.AddDays(delta0Corr).truncateToMinute();
                }


                //if (cumulMin > 0 && cumulMax > 0 && delta0Corr > cumulMin)
                //{
                //    delta0Corr = borneCumul(delta0Corr, cumulMin, cumulMax);
                //    pub2 = lastRead.Pub.AddDays(delta0Corr);
                //}
            }




            var deltaLecture = (DateTime.Now - lastPlayed).TotalDays;

            int nbReads = 0;
            int nbTotals = 0;

            int nbRead = 0;
            int nbTotal = 0;

            int _nbRead = 0;
            int _nbTotal = 0;
            double delta = conf.getIntervalle(album.Rare);
            double delta0 = delta;
            var _histo = conf.getHisto(album.Rare);
            if (_histo > 0)
            {
                double histo = _histo;

                DateTime histo0 = next.Pub;
                if (conf.histoMode == histoMode.fix)
                    histo0 = Conf.Date0;
                DateTime limit = histo0.AddDays(-histo);

                for (int i = indexNextSelected - 1; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotals >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbReads++;


                    nbTotals++;

                }



                limit = lastRead.Pub.AddDays(-histo);
                for (int i = indexLastRead; i >= 0; i--)
                {
                    var t = list[i];
                    var dt = t.Pub;
                    if (dt < limit && nbTotal >= conf.totalMin)
                        break;

                    if (t.Played)
                        nbRead++;


                    nbTotal++;

                }


                if (conf.histoMode == histoMode.read)
                {
                    _nbRead = nbRead;
                    _nbTotal = nbTotal;
                }
                else
                {
                    _nbRead = nbReads;
                    _nbTotal = nbTotals;
                }


                if (_nbRead > 0 && _nbTotal > 0)
                {
                    if (_nbTotal < conf.totalMin)
                        _nbTotal = conf.totalMin;
                    //  album.Rare ? conf.intervalleR : conf.intervalle;
                    var ecouteMax = conf.getEcouteMax(album.Rare); // album.Rare ? conf.ecouteMaxR : conf.ecouteMax;

                    delta = (intervalle * (double)_nbTotal) / (ecouteMax * (double)_nbRead);
                    var coeff = (double)_nbTotal / (double)_nbRead;

                    //0.1 => 10
                    //0.9 => 1.11
                    //coeff -= 1; // 9  0.11
                    //var dminmax = intervalle - intervalleMin;

                    var _delta = borne(coeff, intervalle, intervalleMin); // intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

                    if (_delta < delta)
                        delta = _delta;
                    else
                    {
                    }

                }

                //misc.log("{3} {4}/{5} [{0}] {1} {2} ", name, lastRead.Name, lastRead.Pub, delta.ToString("#.##"), nbRead, nbTotal, name);


            }



            if (conf.extPente > 0)
            {
                var d0 = (DateTime.Now - pub2).TotalDays;
                var dl = conf.extDelta;
                if (dl == 0)
                {
                    dl = d0;
                }

                delta0 = d0 / conf.extPente;
                delta = delta0;
                //01/01/2014 ->01/01/2017
                //04/01/2017 -> 04/01/2014
                var dateLimitEcoule = DateTime.Now.AddDays(-dl);

                var deltaLimiteEcoule = (dateLimitEcoule - pub2).TotalDays;
                log.log("{0} {1}", delta.ToString("0.##"), deltaLimiteEcoule.ToString("0.##"));

                if (deltaLimiteEcoule > delta)
                    delta = deltaLimiteEcoule;

                if (delta < 1)
                    delta = 1;

                //if (delta > intervalle)
                //    delta = intervalle;
            }

            if (conf.limitRead && deltaLecture > intervalle)
            {
                //13 /10 ->7
                var _old = delta;

                delta += intervalle - deltaLecture;
                log.log("limitation par lecture {0} -> {1}", _old.ToString("0.##"), delta.ToString("0.##"));
            }




            if (delta < intervalleMin)
                delta = intervalleMin;

            if (delta > intervalle)
                delta = intervalle;



            DateTime limitFuture = pub2.AddDays(delta).truncateToMinute();
            DateTime nextDate = limitFuture;

            int nb = 0;
            int nblissage = 0;
            double deltaAtterrissage = intervalleMin;

            if (conf.noCollision)
                deltaAtterrissage = TimeSpan.FromDays(delta).TotalDays;
            if (conf.extPente > 0)
                deltaAtterrissage = TimeSpan.FromDays(delta0).TotalDays;

            if (conf.deltaConst)
            {
            }

            else
            {
                var _deltaMin = lastRead.Pub.AddDays(conf.deltaMin);
                var _deltaRab = limitFuture.AddDays(conf.deltaRab);
                double deltaattAux = 0;
                for (int i = indexLastRead + 1; i < count; i++)
                {
                    var t = list[i];

                    if (conf.deltaCheckSelected)
                    {
                        if (!t.Selected)
                            continue;
                        if (!t.Enabled)
                            continue;
                    }

                    if (t.Pub >= limitFuture)
                    {
                        nextDate = t.Pub;
                        nblissage++;
                        if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                        {
                            var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                            if (_deltaAtt < deltaAtterrissage)
                            {
                                if (_deltaAtt > deltaattAux)
                                    deltaattAux = _deltaAtt;
                            }
                        }
                        if (t.Pub >= _deltaMin && t.Pub >= _deltaRab && nb >= conf.deltaNbMin && nblissage > conf.deltaNbRab)
                            break;
                    }
                    nb++;
                }

                if (nextDate > limitFuture && nb > 0 && conf.noCollision)
                {
                    if (deltaattAux > 0)
                        deltaAtterrissage = deltaattAux;
                    else
                    {
                        var _deltaAtt = (nextDate - limitFuture).TotalDays / (double)nb;
                        if (_deltaAtt < deltaAtterrissage)
                            deltaAtterrissage = _deltaAtt;
                    }

                    if (deltaAtterrissage > intervalleMin)
                        deltaAtterrissage = intervalleMin;
                }
            }

            var tsatt = timeSpan.FromDays(deltaAtterrissage);
            if (tsatt.TotalMinute < 1)
                tsatt = timeSpan.FromMinutes(1);

            string deltas = string.Format("{0} {1} {2}->{3}", deltaLastRead0.ToString("0.##"), delta0Corr.ToString("0.##"), delta.ToString("0.##"), tsatt.TotalDay.ToString("0.##"));

            log.log("{0} {1}/{2} ({3}/{4}) [{5}] {6} {7} ({8}) lecture={9} ", deltas, nbRead, nbTotal, nbReads, nbTotals, album.Album, lastRead.track.Name, lastRead.Pub, pub2, deltaLecture.ToString("#.##"));


            nb = 0;
            for (int i = indexLastRead + 1; i < count; i++)
            {

                var t = list[i];

                if (conf.deltaCheckSelected)
                {
                    if (!t.Selected)
                        continue;
                    if (!t.Enabled)
                        continue;
                }
                var dt = limitFuture.AddMinutes((int)(tsatt.TotalMinute * nb)).truncateToMinute();


                var _delta = (dt - lastRead.Pub2).TotalDays;
                if (t.Pub >= dt || conf.enabled == sortMode.reset)
                    eraseSort(t, false, true);
                else
                {
                    if (cumulMin > 0 && cumulMax > 0 && conf.extPente == 0)
                    {
                        var __delta = (dt - t.Pub).TotalDays;
                        if (__delta > cumulMin)
                        {
                            __delta = borneCumul(__delta, cumulMin, cumulMax);
                            dt = t.Pub.AddDays(__delta).truncateToMinute();
                        }
                    }

                    writeComment(t, dt, true, true, Conf.Date0, Conf.NewDate0);
                    nb++;
                }


            }


            for (int i = 0; i < count; i++)
            {
                var track = list[i];
                if (track.Pub > currentPub && track.Pub2 > track.Pub && track.Pub2 <= currentPub2)
                {
                    var aux = currentPub2.AddMinutes(1);
                    log.log("correction2 pub2 pour respect ordre {0} -> {1} {2}", track.Pub2, aux, track);
                    track.Pub2 = aux;
                }

                currentPub = track.Pub;
                currentPub2 = track.Pub2;
            }
            */
            #endregion


        }

        //private void writeComment(TrackInfoItunes track)
        //{
        //    string comment = track.Pub.ToString("yyyy/MM/dd HH:mm");
        //    if (track.Pub2 > track.Pub)
        //        comment = string.Format("{0}|{1}", track.Pub2.ToString("yyyy/MM/dd HH:mm"), track.Pub.ToString("yyyy/MM/dd HH:mm"));

        //    if (comment != track.Comment)
        //        track.Comment = comment;
        //}

        private void eraseSort(TrackSort track, bool force, bool apply, DateTime date0, DateTime newDate0)
        {
          
            bool go = apply;
            if (!go)
            {
                go = true;
                if (!force && !track.track.Selected)
                    go = false;
            }
            if (!go)
            {
                track.Pub2 = track.Pub;
                return;
            }

            //if (!force && !track.Selected)
            //    return;
            if (conf.canGoBack || conf.enabled == sortMode.reset)
            {
                if (!track.Played && track.Enabled)
                {
                    DateTime pub = track.Pub;
                    if (track.Pub2 >= date0 && pub <date0)
                    {
                        log.log("**********{0} pub2 erase passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.Date0);
                        repeches.Add(track);
                        // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                        if (pub < dateRepeche)
                            dateRepeche = pub;
                    }
                    else if (track.Pub2 >=newDate0 && pub < newDate0)
                    {
                        log.log("**********{0} pub2 erase passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.Pub2, track.Pub, Conf.NewDate0);
                        repeches.Add(track);
                        // track.Pub2 = TrackInfoItunes.Date0.AddSeconds(nbrepeches);
                        if (pub < dateRepeche)
                            dateRepeche = pub;
                    }
                }

                //}
                //else
                //{
                if (track.Pub2 != track.Pub)
                    nbModif++;
                track.Pub2 = track.Pub;
                //}
                track.track.BuildComment();
                // writeComment(track);
            }
        }

        private void applyPub(TrackSort track)
        {
            writeComment(track, track.Pub2, false, true, Conf.Date0, Conf.NewDate0);
        }

        private void writeComment(TrackSort track, DateTime dt, bool checkSelected, bool apply, DateTime date0, DateTime newDate0)
        {
            dt = dt.truncateToMinute();
            bool go = apply;
            if (!go)
            {
                go = true;
                if (checkSelected && !track.track.Selected)
                    go = false;
            }
            if (!go)
            {
                track.Pub2 = dt;
                return;
            }

        

            //if (checkSelected && !track.Selected)
            //    return;


            if (conf.canGoBack)
            {
                if (!track.Played && track.Enabled)
                {
                    if (track.pub20 >= date0 && dt < date0)
                    {
                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de Date0 {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            repeches.Add(track); 
                        }
                        if (dt < dateRepeche)
                            dateRepeche = dt;
                    }

                    else if (track.pub20 >= newDate0 && dt < newDate0)
                    {

                        if (conf.canGoBackButForceSelected)
                        {
                            log.log("**********{0} pub2 set passe en dessous de NewDate0 MAIS repéché {1}->{2} ({3})", track.Name, track.pub20, dt, date0);
                            nbRepecheForce++;
                            dt = date0.AddMinutes(nbRepecheForce);
                        }
                        else
                        {
                            log.log("**********{0} pub2 set passe en dessous de NewDate0 {1}->{2} ({3})", track.Name, track.pub20, dt, newDate0);
                            repeches.Add(track); 
                        }

                        if (dt < dateRepeche)
                            dateRepeche = dt;

                    }
                }
            }
            else
            {
                if (dt == track.pub20)
                {
                    log.log("\t{0}\t{1} {2}", track.Pub, dt, track.Name);
                    return;
                }
                else if (dt < track.pub20)
                {
                    log.log("\t{0}\t{1}<=\t{2} {3}", track.Pub, track.pub20, dt, track.Name);
                    return;
                }
            }
            var delta = (dt - track.Pub).TotalDays;
            var strDelta = delta.ToString("0.0");

            if (track.pub20 != dt)
            {
                if (track.track.Selected)
                {
                    nbModif++;
                    log.log("\t{0}\t{1}=>\t{2}({3}) {4}", track.Pub, track.pub20, dt, strDelta, track.Name);
                }
                track.Pub2 = dt;
            }
            else if (track.pub20 > track.Pub)
            {
                if (track.track.Selected)
                    log.log("\t{0}\t{1}({2}) {3}", track.Pub, track.pub20, strDelta, track.Name);
            }


            track.track.BuildComment();
        }

        private static double borne(double coeff, double intervalle, double intervalleMin)
        {
            if (coeff <= 1)
                return coeff * intervalleMin;
            coeff -= 1; // 9  0.11
            var dminmax = intervalle - intervalleMin;

            var _delta = intervalle - dminmax / (1 + (intervalleMin / dminmax) * coeff);

            return _delta;
        }

        private static double borneCumul(double delta, double cumulMin, double cumulMax)
        {
            if (cumulMin < 0 || cumulMax < 0)
                return delta;
            if (delta < cumulMin)
                return delta;
            var coeff = delta / cumulMin;
            return borne(coeff, cumulMax, cumulMin);
        }
    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.ordo.conf;
using pdb.podcast.Auto;
using pdb.util;

namespace pdb.podcast.Tuning
{
    public enum menage
    {
        none,
        read,
        name
    }
    public class Conf
    {
        string SOV = "..\\sov\\";
        //private static string CONF_FILE = @"..\conf.xml";
        #region membres
        private DirConf root;
        private bool buildLimitMulti;
        private bool single;
        private Move move;
        private bool deleteDoublon;
        private bool getDescription;
        private int volumeMin = int.MinValue;
        private bool simulation;
        private string copyAll;
        private int maxScan = 10;
        private ConfOrdo ordo = new ConfOrdo();
        private menage menage = menage.none;
        private string poubelle = "";
        // private string zique;
        private bool writePlayLists;
        private bool writePreSel;
        private bool writeItems;
        private bool writeUse;
        private bool writeExclu;
        private bool genFeed;
        private int genFeedPrior = 11;
        private int genUsePrior = 11;
        private int genExcluPrior = 11;
        //private bool transmit = true;
        //private bool transmitTotal = true;
        //private bool transmitTotalGuest = true;
        private bool? cascading = null;
        private bool autoBlock;

        private ConfDate dates = new ConfDate();

        private List<SelectParam> selectParams = new List<SelectParam>();
        private Journal journal;
        private RootIt rootIt = new RootIt();
        private bool onlyEnabled = true;
        private bool onlyUnRead = true;
        private bool checkExist = true;

        // private Auto auto = null;
        private bool logGen = true;
        private DateTime date0;
        private DateTime date00;
        private double deltaOpen = 60; 
        private Html html = new Html();

        private bool autoSequence = true;
        private bool borderVirtual;
        private bool borderIdem;
        private bool borderGranSlam;
        private bool borderTb;
        private bool autoSelect;
        private bool logDir;

        private Export export = new Export();
        private Hibernate import = new Hibernate();
        private Sort.Sort sort = new Sort.Sort();
        private Hibernate hibernate = new Hibernate();
        private Db db = new Db();
        private ConfAlbums albums = new ConfAlbums();
        private Listes listes = new Listes();
        private Listes globalListes = new Listes();

        private bool checkPub = true;

        private bool useMock;


        #endregion
        public static readonly Conf Instance = new Conf();
        private static bool started;
        private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
        public void setConfFile(string conf)
        {
            this.confFile = new FileInfo(@"..\" + conf);

            if (!Directory.Exists(SOV))
                Directory.CreateDirectory(SOV);

            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");          
            File.Copy(confFile.FullName, string.Format("{0}{1}_{2}", SOV, timeStamp, confFile.Name), true);
        }

        #region getters
        public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
        public static bool Single { get { return Instance.single; } }
        public static DirConf DirConf { get { return Instance.root; } }
        public static Move Move { get { return Instance.move; } }
        public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
        public static bool GetDescription { get { return Instance.getDescription; } }
        public static int VolumeMin { get { return Instance.volumeMin; } }
        public static bool Simulation { get { return Instance.simulation; } }
        public static string CopyAll { get { return Instance.copyAll; } }
        public static ConfOrdo Ordo { get { return Instance.ordo; } }
        public static int MaxScan { get { return Instance.maxScan; } }
        public static menage Menage { get { return Instance.menage; } }
        public static string Poubelle { get { return Instance.poubelle; } }
        public static bool WritePlayLists { get { return Instance.writePlayLists; } }
        public static bool WritePreSel { get { return Instance.writePreSel; } }
        public static bool WriteItems { get { return Instance.writeItems; } }
        public static bool WriteUse { get { return Instance.writeUse; } }
        public static bool WriteExclu { get { return Instance.writeExclu; } }
        public static bool GenFeed { get { return Instance.genFeed; } }
        public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
        public static int GenUsePrior { get { return Instance.genUsePrior; } }
        public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

        //public static bool Transmit { get { return Instance.transmit; } }
        //public static bool TransmitTotal { get { return Instance.transmitTotal; } }
        //public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
        public static bool? Cascading { get { return Instance.cascading; } }
        public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
        public static DateTime DateLevel { get { return Instance.dates.Level; } }
        internal static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
        internal static Journal Journal { get { return Instance.journal; } }
        internal static RootIt RootIt { get { return Instance.rootIt; } }

        public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
        public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }
        public static bool CheckExist { get { return Instance.checkExist; } }

        public static bool AutoBlock { get { return Instance.autoBlock; } }
        public static bool LogGen { get { return Instance.logGen; } }

        internal static Html Html { get { return Instance.html; } }

        public static bool AutoSequence { get { return Instance.autoSequence; } }
        public static bool BorderVirtual { get { return Instance.borderVirtual; } }
        public static bool BorderIdem { get { return Instance.borderIdem; } }
        public static bool BorderGranSlam { get { return Instance.borderGranSlam; } }
        public static bool BorderTb { get { return Instance.borderTb; } }
        public static bool AutoSelect { get { return Instance.autoSelect; } }
        public static Export Export { get { return Instance.export; } }
        internal static Hibernate Import { get { return Instance.import; } }
        public static Sort.Sort Sort { get { return Instance.sort; } }
        public static ConfAlbums Albums { get { return Instance.albums; } }
        internal static Hibernate Hibernate { get { return Instance.hibernate; } }
        internal static Db Db { get { return Instance.db; } }
        /// <summary>
        /// muy important. on calcule les dates max avec pub plutôt que Pub2
        /// </summary>
      //  public static bool CheckPub { get { return Instance.checkPub; } }
        public static bool UseMock { get { return Instance.useMock; } }
        public static bool LogDir { get { return Instance.logDir; } }
        public static double DeltaOPen { get { return Instance.deltaOpen; } }
        internal static Listes Listes { get { return Instance.listes; } }
        internal static Listes GlobalListes { get { return Instance.globalListes; } }



        //  public static string Zique { get { return Instance.zique; } }
        #endregion

        private DateTime lastModif = DateTime.MinValue;
        private FileInfo confFile;
        public FileInfo ConfFile { get { return confFile; } }
        #region load

        public XmlElement load(bool waitForModification)
        {

            while (true)
            {
                confFile.Refresh();
                if (!confFile.Exists)
                    throw new ApplicationException(confFile + " n'existe pas !!");
                DateTime dt = confFile.LastWriteTime;
                if (dt > lastModif || !waitForModification)
                    break;
                Thread.Sleep(1000);
            }

            lastModif = confFile.LastWriteTime;

            XmlDocument l_doc = new XmlDocument();
            l_doc.Load(confFile.FullName);

            XmlElement xroot = l_doc.DocumentElement;
            XMLTool l_xmlConf = new XMLTool(xroot);

            string str = l_xmlConf.getNodeValue("volumeMin");
            if (!string.IsNullOrEmpty(str))
                volumeMin = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("maxScan");
            if (!string.IsNullOrEmpty(str))
                maxScan = Convert.ToInt32(str);

            buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
            simulation = l_xmlConf.getBoolValue("simulation");
            //   zique = l_xmlConf.getNodeValue("zique");

            deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
            getDescription = l_xmlConf.getBoolValue("getDescription");
            copyAll = l_xmlConf.getNodeValue("copyAll");

            poubelle = l_xmlConf.getNodeValue("poubelle");

            str = l_xmlConf.getNodeValue("menage");
            if (!string.IsNullOrEmpty(str))
                menage = (menage)(Enum.Parse(typeof(menage), str, true));

            writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
            writePreSel = l_xmlConf.getBoolValue("writePreSel");
            writeItems = l_xmlConf.getBoolValue("writeItems");
            writeUse = l_xmlConf.getBoolValue("writeUse");
            writeExclu = l_xmlConf.getBoolValue("writeExclu");
            genFeed = l_xmlConf.getBoolValue("genFeed");
            str = l_xmlConf.getNodeValue("genFeedPrior");
            if (!string.IsNullOrEmpty(str))
                genFeedPrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genUsePrior");
            if (!string.IsNullOrEmpty(str))
                genUsePrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genExcluPrior");
            if (!string.IsNullOrEmpty(str))
                genExcluPrior = Convert.ToInt32(str);

            //transmit = l_xmlConf.getBoolValue("transmit");
            //transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
            //transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
            onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
            onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
            checkExist = l_xmlConf.getBoolValue("checkExist", true);
            str = l_xmlConf.getNodeValue("cascading");
            if (!string.IsNullOrEmpty(str))
                cascading = "true".Equals(str);
            //  cascading = l_xmlConf.getBoolValue("cascading");

            str = l_xmlConf.getNodeValue("date0");
            if (!string.IsNullOrEmpty(str))
                date0 = Convert.ToDateTime(str);

            str = l_xmlConf.getNodeValue("date00");
            if (!string.IsNullOrEmpty(str))
                date00 = Convert.ToDateTime(str);

            var xDates = l_xmlConf.NodeLookUp("playedDates");
            dates = new ConfDate(xDates);

            logGen = l_xmlConf.getBoolValue("logGen");
            var createNullLoggerOrg = Logger.CreateNullLoggers;

            Logger.CreateNullLoggers = !logGen;
            XmlElement xDir = l_xmlConf.NodeLookUp("dir");

            var rootLimit = new Limits();
            buildLimit(xDir, rootLimit, null);

            AutoBuilder.clear(); 
            root = DirConf.getDir(rootLimit, xDir.Attributes["name"].InnerText, null); //new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
            root.build(null, xDir);
            buildDirChilds(xDir, root);
            root.Init(); 

            // AutoBuilder.getLoaders(); 

            XmlElement xMove = l_xmlConf.NodeLookUp("move");
            move = new Move(xMove);

            ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

            selectParams.Clear();

            var xSelect = l_xmlConf.NodeLookUp("select");
            if (xSelect != null)
            {
                foreach (XmlNode xsub in xSelect)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        selectParams.Add(new SelectParam (xSelect, x));
                }
            }

            journal = null;
            var xJournal = XMLTool.NodeLookUp(xroot, "journal");
            if (xJournal != null)
            {
                journal = new Tuning.Journal();
                buildLimitItem(xJournal, xJournal, journal);
                var xxJournal = new XMLTool(xJournal);
                journal.NbJour = xxJournal.getIntAttValue("nbJour");
            }

            rootIt = new Tuning.RootIt(l_xmlConf.NodeLookUp("rootIt")); //  l_xmlConf.getNodeValue("rootIt");

            autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
            //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
            //if (xAuto == null)
            //    auto = null;
            //else
            //    auto = new Auto(xAuto);

            XmlElement xHtml = l_xmlConf.NodeLookUp("html");
            html = new Html(xHtml);

            autoSequence = l_xmlConf.getBoolValue("autoSequence", true);
            borderVirtual = l_xmlConf.getBoolValue("borderVirtual", false);
            borderIdem = l_xmlConf.getBoolValue("borderIdem", false);
            borderGranSlam = l_xmlConf.getBoolValue("borderGranSlam", false);
            borderTb = l_xmlConf.getBoolValue("borderTb", false);
            autoSelect = l_xmlConf.getBoolValue("autoSelect", false);
            checkPub = l_xmlConf.getBoolValue("checkPub", false);
            useMock = l_xmlConf.getBoolValue("useMock ", false);
            logDir = l_xmlConf.getBoolValue("logDir ", false);

            var xExport = l_xmlConf.NodeLookUp("export"); // export = l_xmlConf.getNodeValue("export");
            export = new Tuning.Export(xExport);

            var xImport = l_xmlConf.NodeLookUp("import"); // export = l_xmlConf.getNodeValue("export");
            import = new Tuning.Hibernate(xImport);

            var xSort = l_xmlConf.NodeLookUp("sort");
            sort = new Tuning.Sort.Sort(xSort);


            var xAlbums = l_xmlConf.NodeLookUp("albums");
            albums = new ConfAlbums(xAlbums);

            var xHibernate = l_xmlConf.NodeLookUp("hibernate");
            hibernate = new Hibernate(xHibernate);


            var xDb = l_xmlConf.NodeLookUp("db");
            db = new Db(xDb);


            Logger.CreateNullLoggers = createNullLoggerOrg;
            var xlistes = l_xmlConf.NodeLookUp("listes");
            listes = new Listes(xlistes);

            var xglobal = l_xmlConf.NodeLookUp("global");
            globalListes = new Listes(xglobal);

            started = true;
            return xroot;

        }

        #region limites

        private void buildDirChilds(XmlNode node, DirConf parent)
        {
            AutoBuilder.setClient(parent, node);
            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "auto")
                {
                    AutoBuilder.build(child, parent);
                }
                else
                {
                    if (child.Name == "dir")
                    {
                        string name = (child.Attributes["name"].InnerText);
                        Limits childLimite = parent.Limites.Clone() as Limits;
                        DirConf sub = DirConf.getDir(childLimite, name, parent); // new DirConf(childLimite, name, parent);
                        sub.build(node, child);
                       
                        //if (child.Attributes["d"] != null)
                        //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);



                        if (child.Attributes["all"] != null)
                        {
                            sub.HistoAll = child.Attributes["all"].Value == "true";
                        }
                        if (child.Attributes["serial"] != null)
                        {
                            sub.Serial = child.Attributes["serial"].Value == "true";
                        }

                        if (child.Attributes["cascading"] != null)
                            sub.Cascading = child.Attributes["cascading"].Value == "true";
                        if (child.Attributes["selectionPre"] != null)
                            sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                        //if (child.Attributes["transmit"] != null)
                        //    sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                        //if (child.Attributes["transmitTotal"] != null)
                        //    sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                        //if (child.Attributes["transmitTotalGuest"] != null)
                        //    sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                        buildLimit(child, childLimite, sub);
                        parent.addChild(sub);
                        if (!started)
                            misc.log(sub.display());
                        buildDirChilds(child, sub);
                        sub.Init(); 

                    }
                }
            }

        }

        private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
        {
            string strTd = child.InnerText;
            if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
                item.Td = Convert.ToInt32(strTd);

            AutoBuilder.setClient(item, child);

            //foreach (XmlNode sub in child.ChildNodes)
            //{
            //    if (sub.Name == "auto")
            //        AutoBuilder.build(sub, item);
            //}

            item.build(parent, child);

            //var dAtt0 = parent.Attributes["d"];
            //if (dAtt0 != null)
            //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

            //var dAtt = child.Attributes["d"];
            //if (dAtt != null)
            //    item.Duration = Convert.ToSingle(dAtt.InnerText);

            //var cAtt0 = parent.Attributes["c"];
            //if (cAtt0 != null)
            //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

            //var cAtt = child.Attributes["c"];
            //if (cAtt != null)
            //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

            //var fdAtt0 = parent.Attributes["fd"];
            //if (fdAtt0 != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

            //var fdAtt = child.Attributes["fd"];
            //if (fdAtt != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

            //var nbAtt0 = parent.Attributes["nb"];
            //if (nbAtt0 != null)
            //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
            //var nbAtt = child.Attributes["nb"];
            //if (nbAtt != null)
            //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

            //var dateAtt0 = parent.Attributes["date"];
            //if (dateAtt0 != null)
            //    item.DateMin = getDate(dateAtt0.InnerText);
            //var dateAtt = child.Attributes["date"];
            //if (dateAtt != null)
            //    item.DateMin = getDate(dateAtt.InnerText);

            //var dateAtt0Max = parent.Attributes["maxdate"];
            //if (dateAtt0Max != null)
            //    item.DateMax = getDate(dateAtt0Max.InnerText);
            //var dateAttMax = child.Attributes["maxdate"];
            //if (dateAttMax != null)
            //    item.DateMax = getDate(dateAttMax.InnerText);
        }

        private static bool date00Consumed;
        public static void date00Consume() { date00Consumed = true; }

        public static DateTime Date0
        {
            get
            {
                if (Instance.date00 == DateTime.MinValue || date00Consumed)
                    return Instance.date0;
                return Instance.date00;
            }
        }

        public static DateTime NewDate0
        {
            get
            {
                return Instance.date0;
            }
        }

        public static DateTime getDate(string str)
        {
            //int delta = -1;
            double d = -1;
            if (Date0 > DateTime.MinValue)
                //{
                //    if (int.TryParse(str, out delta))
                //    {
                //        int dt = delta;
                //        if (delta % 365 == 0)
                //        {
                //            dt = delta / 365;
                //            return Date0.AddYears(dt);
                //        }

                //        if (delta % 30 == 0)
                //        {
                //            dt = delta / 30;
                //            return Date0.AddMonths(dt);
                //        }
                //        return Date0.AddDays(delta);
                //    }
                //    else
                if (double.TryParse(str, out d))
                {
                    return Date0.AddDays(d);
                }
            //       }

            return Convert.ToDateTime(str);
        }

        private void buildLimit(XmlNode node, Limits limits, DirConf dir)
        {

            Limit[] tab = new Limit[Limits.NB];

            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "list")
                {

                    int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                    Limit limit = new Limit(level);
                    var items = new List<LimitItem>();

                    double tdMin = 0;
                    foreach (XmlNode xItem in child.ChildNodes)
                    {
                        //if (xItem.Name == "auto")
                        //{
                        //    AutoBuilder.build(xItem, limit);
                        //}
                        //else 
                        if (xItem.Name == "td")
                        {
                            var item = new LimitItem(limit);
                            item.TdMin = tdMin;
                            buildLimitItem(child, xItem, item);
                           

                            var itemTd = item.Td;
                            if (itemTd < int.MaxValue)
                                tdMin = item.Td;
                            items.Add(item);
                        }
                    }

                    if (items.Count == 0)
                    {
                        var defaultItem = new LimitItem(limit);
                        buildLimitItem(child, child, defaultItem);
                        items.Add(defaultItem);
                    }

                    limit.Items = items;

                    //var dAtt = child.Attributes["d"];
                    //if (dAtt != null)
                    //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                    //var fdAtt = child.Attributes["fd"];
                    //if (fdAtt != null)
                    //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                    //var nbAtt = child.Attributes["nb"];
                    //if (nbAtt != null)
                    //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                    tab[level] = limit;
                }

            }

            Limit current = null;
            bool oneTabAtLeast = false;
            //  LimitItem currentItem = null;

            double currentDuration = int.MaxValue;
            double lcurrentDuration = int.MaxValue;
            double currentContrib = int.MaxValue;
            double currentFeedDuration = int.MaxValue;
           // double lcurrentFeedDuration = int.MaxValue;
            int currentNb = int.MaxValue;
            int lcurrentNb = int.MaxValue;

            double currentTd = int.MaxValue;

            double currentTdMin = int.MaxValue;
            DateTime currentDateMin = DateTime.MinValue;
            DateTime currentDateMax = DateTime.MaxValue;
           bool currentOverwrite = false; 

            for (int i = 0; i < Limits.NB; i++)
            {

                //if (tab[i] != null)
                //{

                if (tab[i] != null)
                {
                    current = tab[i];
                    oneTabAtLeast = true;

                }

                if (!oneTabAtLeast)
                    current = limits[i];

                var _limit = limits[i];
                _limit.Level = i;
                limits[i].Parent = limits;

                //foreach (LimitItem currentItem in current.Items)
                //{

                if (_limit.Items.Count != current.Items.Count)
                {
                    _limit.Items.Clear();
                }

                for (int j = 0; current != null && j < current.Items.Count; j++)
                {

                    var currentItem = current.Items[j];
                    // if (currentItem.Duration < int.MaxValue)
                    currentDuration = currentItem.Duration;
                    currentOverwrite = currentItem.OverwriteConf; 
                    lcurrentDuration = currentItem.LoadDuration;
                    //if (currentItem.Contribution < int.MaxValue)
                    currentContrib = currentItem.Contribution;
                    // if (currentItem.FeedDuration < int.MaxValue)
                    currentFeedDuration = currentItem.FeedDuration;
                  //  lcurrentFeedDuration = currentItem.LoadFeedDuration;

                    //   if (currentItem.Nb < int.MaxValue)
                    currentNb = currentItem.Nb;
                    lcurrentNb = currentItem.LoadNb;
                    //  if (currentItem.Td < int.MaxValue)
                    currentTd = currentItem.Td;
                    currentTdMin = currentItem.TdMin;

                    currentDateMin = currentItem.DateMin;
                    currentDateMax = currentItem.DateMax;
                    //}
                    //}

                    //if (current != null)
                    //{
                    LimitItem _limitItem = null;
                    if (j >= _limit.Items.Count)
                    {
                        _limitItem = currentItem.Clone() as LimitItem;
                        _limit.Items.Add(_limitItem);
                        _limitItem.Limit = _limit;

                    }
                    else
                    {
                        _limitItem = _limit.Items[j];

                    }
                    //if (currentDuration < int.MaxValue)
                    _limitItem.setDuration(currentDuration, false); // Duration = currentDuration;
                    _limitItem.LoadDuration = lcurrentDuration;
                    //if (currentContrib < int.MaxValue)
                    //    _limitItem.Contribution = currentContrib;
                    // if (currentFeedDuration < int.MaxValue)
                    _limitItem.setFeedDuration(currentFeedDuration, false); // FeedDuration = currentFeedDuration;
                   // _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                    // if (currentNb < int.MaxValue)
                    _limitItem.setNbMax(currentNb, false);
                    _limitItem.LoadNb = lcurrentNb;
                    //   if (currentTd < int.MaxValue)
                    _limitItem.Td = currentTd;
                    _limitItem.TdMin = currentTdMin;
                    _limitItem.DateMin = currentDateMin;
                    _limitItem.setDateMax(currentDateMax, false);
                    _limitItem.Contribution = currentContrib;
                  _limitItem.OverwriteConf = currentOverwrite; 



                    if (dir != null)
                    {
                        if (_limitItem.Duration == int.MaxValue)
                            _limitItem.setDuration(dir.Duration, true); // Duration = dir.Duration;
                        if (_limitItem.LoadDuration == int.MaxValue)
                            _limitItem.LoadDuration = dir.LoadDuration;
                        if (_limitItem.Contribution == int.MaxValue)
                            _limitItem.Contribution = dir.Contribution;
                        if (_limitItem.Td == int.MaxValue)
                            _limitItem.Td = dir.Td;
                        if (_limitItem.Nb == int.MaxValue)
                            _limitItem.setNbMax(dir.Nb, true);
                        if (_limitItem.LoadNb == int.MaxValue)
                            _limitItem.LoadNb = dir.LoadNb;
                        if (_limitItem.FeedDuration == int.MaxValue)
                            _limitItem.setFeedDuration(dir.FeedDuration, true);
                        //if (_limitItem.LoadFeedDuration == int.MaxValue)
                        //    _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                        if (_limitItem.DateMin == DateTime.MinValue)
                            _limitItem.DateMin = dir.DateMin;
                        if (_limitItem.DateMax == DateTime.MaxValue)
                            _limitItem.setDateMax(dir.DateMax, true);
                    }

                    _limitItem.setParent(dir);

                }

                //}
                // }

            }

        }
        #endregion
        #endregion

    }
}
]]></content>
  </file>
</db>
