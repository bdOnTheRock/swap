<db path="C:\Bernard\db1\PieceDb3Ref">
   <file path="\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ConfAlbumSortW" Height="178" Width="544">
    <Grid Height="118" Width="492">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="182*" />
            <ColumnDefinition Width="201*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="7*" />
        </Grid.RowDefinitions>
        <Grid Grid.ColumnSpan="2">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="4" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="4" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="5" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="0" Grid.Column="6" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="4" />
            <TextBox  Grid.Row="0" Grid.Column="7" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="0" Grid.Column="8" Name="tb_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="9" Name="cb_removeFirst" ToolTip="removeFirst" Margin="5" Padding="4" />
            <ComboBox ToolTip="removelast" Grid.Row="0" Grid.Column="10" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="0" Grid.Column="11" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="4" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="4" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="4" Name="cb2_lissage" ToolTip="lissage" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="5" Name="cb2_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="4" />
            <CheckBox  Grid.Row="1" Grid.Column="6" Name="cb2_reSort" ToolTip="reSort" Margin="5" Padding="4" />
            <TextBox  Grid.Row="1" Grid.Column="7" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="8" Name="tb2_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="9" Name="cb2_removeFirst" ToolTip="removeFirst" Margin="5" Padding="4" />
            <ComboBox ToolTip="removelast" Grid.Row="1" Grid.Column="10" Name="cbx2_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="1" Grid.Column="11" Name="cb2_cumul" ToolTip="cumul" Margin="5" Padding="4" />

        </Grid>
        
        <StackPanel Grid.Row="2"  Orientation="Horizontal"  HorizontalAlignment="Right" Margin="0,5,5,5" Grid.Column="1">
            <Button Grid.Row="2" Name="bt_cancel" Height="25" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" />
            <Button Grid.Row="2" Name="bt_ok" Height="25" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" />
        </StackPanel>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml.cs">
    <content><![CDATA[using System;
using System.Windows;
using pdb.gen.Tuning;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfAlbumSortW.xaml
    /// </summary>
    public partial class ConfAlbumSortW : Window
    {
        private ConfAlbumSort conf;
        public ConfAlbumSortW()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(ConfAlbumSortW_Loaded);
        }

        void ConfAlbumSortW_Loaded(object sender, RoutedEventArgs e)
        {
            display(); 
        }

        public ConfAlbumSortW(ConfAlbumSort conf)
            : this()
        {
            this.conf = conf;
        }

        void display()
        {
            var list = conf.Composants;
            var item1 = list[0];
            cb_enabled.IsChecked = item1.enabled;
            cbxSort.SelectedIndex = (int)item1.type;
            tb_medianne.Text = item1.medianne.ToString();
            cb_quasi.IsChecked = item1.quasi;
            cb_lissage.IsChecked = item1.lissage;
            cb_removeEpsilon.IsChecked = item1.removeEpsilon;
            cb_reSort.IsChecked = item1.reSort;
            cb_removeFirst.IsChecked = item1.removeFirst;
            cbx1_removeLast.SelectedIndex = (int)item1.removeLast; 
            cb_cumul.IsChecked = item1.cumul; 
            tb_safe.Text = item1.safe.ToString();
            tb_coeff.Text = item1.coeffVirt.ToString();

            if (list.Count > 1)
            {
                item1 = list[1];
                cb2_enabled.IsChecked = item1.enabled;
                cbx2Sort.SelectedIndex = (int)item1.type;
                tb2_medianne.Text = item1.medianne.ToString();
                cb2_quasi.IsChecked = item1.quasi;
                cb2_lissage.IsChecked = item1.lissage;
                cb2_removeEpsilon.IsChecked = item1.removeEpsilon;
                cb2_reSort.IsChecked = item1.reSort;
                cb2_removeFirst.IsChecked = item1.removeFirst;
                cbx2_removeLast.SelectedIndex = (int)item1.removeLast; 
                cb2_cumul.IsChecked = item1.cumul; 
                tb2_safe.Text = item1.safe.ToString();
                tb2_coeff.Text = item1.coeffVirt.ToString();
            }
        }
        void record()
        {
            var list = conf.Composants;
            var item1 = list[0];
            item1.enabled = cb_enabled.IsChecked.Value;
            item1.type = (util.medianneMode)cbxSort.SelectedIndex;
            item1.medianne = Convert.ToDecimal(tb_medianne.Text);
            item1.quasi = cb_quasi.IsChecked.Value;
            item1.lissage = cb_lissage.IsChecked.Value;
            item1.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            item1.reSort = cb_reSort.IsChecked.Value;
            item1.removeFirst = cb_removeFirst.IsChecked.Value;
            item1.removeLast = (util.removeLast)cbx1_removeLast.SelectedIndex; 
            item1.cumul = cb_cumul.IsChecked.Value; 
            item1.safe = Convert.ToInt32(tb_safe.Text);
            item1.coeffVirt = Convert.ToDecimal(tb_coeff.Text);

            if (list.Count > 1)
            {
                if (cbx2Sort.SelectedIndex == 0)
                {
                    list.RemoveAt(1);
                    return;
                }
            }
            else
            {
                if (cbx2Sort.SelectedIndex > 0)
                {
                    item1 = new util.ConfMedianne();
                    list.Add(item1); 
                }
            }

            if (list.Count > 1)
            {
                item1 = list[1];

                item1.enabled = cb2_enabled.IsChecked.Value;
                item1.type = (util.medianneMode)cbx2Sort.SelectedIndex;
                item1.medianne = Convert.ToDecimal(tb2_medianne.Text);
                item1.quasi = cb2_quasi.IsChecked.Value;
                item1.lissage = cb2_lissage.IsChecked.Value;
                item1.removeEpsilon = cb2_removeEpsilon.IsChecked.Value;
                item1.reSort = cb2_reSort.IsChecked.Value;
                item1.removeFirst = cb2_removeFirst.IsChecked.Value;
                item1.removeLast = (util.removeLast)cbx2_removeLast.SelectedIndex; 
                item1.cumul = cb2_cumul.IsChecked.Value; 
                item1.safe = Convert.ToInt32(tb2_safe.Text);
                item1.coeffVirt = Convert.ToDecimal(tb2_coeff.Text);
            }
        }

        private void bt_cancel_Click(object sender, RoutedEventArgs e)
        {
            Close(); 
        }

        private void bt_ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close();
            conf.Calcul(); 
            App.go(); 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;

namespace pdb.util
{
    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        virtuel = 1,
        tous = 2
    }
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;
        public int safe;
        public decimal coeffVirt = 10m;
        public bool enabled;
        public bool lissage;
        public bool removeEpsilon;
        public bool reSort;
        public bool removeFirst;
        public removeLast removeLast; 
        public bool cumul; 
        public ConfMedianne()
        {
        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildb("quasi", v => quasi = v);
            buildi("safe", v => safe = v);
            buildb("enabled", v => enabled = v);
            buildb("lissage", v => lissage = v);
            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("reSort", v => reSort = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("cumul", v => cumul = v);
            bool? _removeLast = null; 
            buildbn("removeLast", v => _removeLast = v);
            switch (_removeLast)
            {
                case true: removeLast = util.removeLast.tous; break; 
                case false: removeLast = util.removeLast.non; break;
                default: removeLast = util.removeLast.virtuel; break; 
            }
        }
    }
    public class CalcMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        public static DecimalIndex getMedianneLight(IList<decimal> list, ConfMedianne mode)
        {

            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, mode.medianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int indexV = 0;

            int count = list.Count;

            if (mode.safe > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                List<decimal> _list = new List<decimal>(list);
                //for (int i = i00; i < count; i++)
                //    _list[i] = 0m;
                //liste partielle originale
                //  List<decimal> _list0 = new List<decimal>(_list);
                int _count = Math.Min(count, i0 + mode.safe);
                decimal[] virt = new decimal[_count];
                for (int i = 0; i < i0; i++)
                {
                    decimal _coeff = 1m;
                    decimal _base = _list[i];
                    for (int j = i + 1; j < _count; j++)
                    {
                        _coeff /= mode.coeffVirt;
                        virt[j] += _base * _coeff;
                    }
                }

                decimal value = int.MaxValue;
                int ii = 0;
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = _list[ii];
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (mode.lissage || value == 0m)
                        {
                            value = calc;
                            _list[ii] = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (mode.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= mode.safe)
                            continue;
                        _list[i] = 0m;
                    }

                }

                if (mode.reSort)
                {
                    _list.Sort();
                    _list.Reverse();
                }

                //for (int i = 0; i < nbAdd; i++)
                //    _list.RemoveAt(0); 


                var retAux = calcmedianneVirt(_list, mode.medianne, mode.quasi);
                //retAux.d *= coeff;
                if (retAux > ret)
                {
                    ret = retAux;
                    //  ret.index += nbAdd; 
                }
                //}


            }
            else
                ret = calcmedianneVirt(list, mode.medianne, mode.quasi);

            //  ret = getRapport(ret);


            return ret;
        }


        public static DecimalIndex getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt)
        {
            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, coeffMedianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int count = list.Count;


            // decimal ret = medianne; //int.MinValue;

            if (nbVirt > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                for (int i00 = 1; i00 <= i0; i00++)
                {
                    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>(list);
                    for (int i = i00; i < count; i++)
                        _list[i] = 0m;
                    int _count = Math.Min(count, i00 + nbVirt);
                    decimal[] virt = new decimal[_count];
                    for (int i = 0; i < i00; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= 10m;
                            virt[j] += _base * _coeff;
                        }
                    }
                    // decimal prec = -1m;  
                    int _nbVirt = 0;
                    decimal value = int.MaxValue;
                    int ii = 0;
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        //   prec = value;
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (_nbVirt >= nbVirt)
                                break;
                            _nbVirt++;
                            value = calc;  //Math.Min(prec, calc);
                            _list[ii] = value;

                        }
                        else
                            _nbVirt = 0;
                    }
                    for (int i = ii; i < count && i < _count; i++)
                    {
                        _list[i] = 0m;
                    }
                    //_list.Sort();
                    //_list.Reverse(); 



                    var retAux = calcmedianneVirt(_list, coeffMedianne, quasi);
                    retAux.d *= coeff;
                    if (retAux > ret)
                        ret = retAux;
                }


            }
            else
                ret = calcmedianneVirt(list, coeffMedianne, quasi);

            //  ret = getRapport(ret);

            //if (ret < medianne)
            //    ret = medianne;
            return ret;
        }

        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10((double)rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, (double)ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\pdb.util\TuningBase.cs">
    <content><![CDATA[using System;
using System.Xml;

namespace pdb.util
{

    public class TuningBase
    {
        public delegate void sets(string value);
        public delegate void setd(double value);
        public delegate void setdec(decimal value);
        public delegate void seti(int value);
        public delegate void setb(bool value);
        public delegate void setbn(bool? value);

        protected XmlElement parent;
        protected XmlElement child;

        public TuningBase() : this(null,null)
        {
        }

        public TuningBase(XmlElement node) : this(null, node) { }

        public TuningBase(XmlElement parent, XmlElement child)
        {
            this.parent = parent;
            this.child = child; 
        }

     

        protected void buildd(string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
        }

        protected void builddec(string name, setdec setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDecimal(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDecimal(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDecimal(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDecimal(elt.InnerText));
        }
      
        protected void buildi( string name, seti seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }
      
        protected void builds(string name, sets sets)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                sets(att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                sets(att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                sets(elt.InnerText);
            elt = child[name];
            if (elt != null)
                sets(elt.InnerText);
        }
       
        protected void buildb(string name, setb setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setb("true" == elt.InnerText);
            elt = child[name];
            if (elt != null)
                setb("true" == elt.InnerText);
        }

        private void _buildbn(string str, setbn setb)
        {
            if ("true".Equals(str))
                setb(true);
            else if ("false".Equals(str))
                setb(false);
            else setb(null); 
        }
        protected void buildbn(string name, setbn setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                _buildbn(att.InnerText, setb); 
           
            att = child.Attributes[name];
            if (att != null)           
                _buildbn(att.InnerText, setb); 
          

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                _buildbn(elt.InnerText, setb); 
            elt = child[name];
            if (elt != null)
                _buildbn(elt.InnerText, setb); 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Collections;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        public static DecimalIndex getMedianneLight(IList<decimal> list, List<Piece> pieces, ConfMedianne mode)
        {
            for (int i = 0; i < pieces.Count; i++)
                pieces[i].setClassementVirtuel(-1);

            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, mode.medianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int indexV = 0;
            int nbAdd = 0;

            int count = list.Count;

            if (mode.safe > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                List<decimal> _list = new List<decimal>(list);
                //for (int i = i00; i < count; i++)
                //    _list[i] = 0m;
                //liste partielle originale
                //  List<decimal> _list0 = new List<decimal>(_list);
                int _count = System.Math.Min(count, i0 + mode.safe);
                decimal[] virt = new decimal[_count];
                if (mode.lissage || mode.removeEpsilon || mode.cumul)
                {
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= mode.coeffVirt;
                            virt[j] += _base * _coeff;
                        }
                    }
                }
                else
                {
                    decimal courant = _list[0];
                    for (int i = 1; i < _count; i++)
                    {
                        if (_list[i] == 0m)
                        {
                            courant /= mode.coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = _list[i];
                    }
                }

                decimal value = int.MaxValue;
                int ii = 0;
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = _list[ii];
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (mode.lissage || value == 0m)
                        {
                            if (value == 0m)
                                nbAdd++;
                            value = calc;
                            _list[ii] = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (mode.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= mode.safe)
                            continue;
                        _list[i] = 0m;
                    }

                }
                if (mode.removeFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        _list[i] = 0m;
                    }
                }

                for (int i = 0; i < pieces.Count; i++)
                    pieces[i].setClassementVirtuel(_list[i]);

                if (mode.reSort || mode.removeFirst)
                {
                    _list.Sort();
                    _list.Reverse();
                    pieces.Sort(new PieceCmp());
                }





                var retAux = calcmedianneVirt(_list, mode, nbAdd);

                if (retAux > ret)
                {
                    ret = retAux;
                }
            }
            else
                ret = calcmedianneVirt(list, mode,0);



            try { pieces[ret.index].MedianneLight = true; }
            catch { }

            return ret;
        }

        private class PieceCmp : IComparer<Piece>
        {
            public int Compare(Piece x, Piece y)
            {
                return -x.VirtualClassement.CompareTo(y.VirtualClassement);
            }
        }




        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, ConfMedianne conf, int nbAdd)
        {

            int count = _list.Count;
          
            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {

                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                {
                    
                    if (conf.removeLast == removeLast.non)
                        break;
                    _nbSupp++;
                    if (conf.removeLast == removeLast.virtuel && _nbSupp > nbAdd)
                        break; 
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
</db>
