<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.player.ViewModel.Commande.PlayList;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log;
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";
              
                //   app = new LegacyApp(); 
                Logger.init("pdb.player");
                log = Logger.getLogger("Program");

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                gen = new Consolid();
                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);
                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.loadData();

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();
               
                thLoop = new Thread(loop);
                thLoop.Start();
                MemUtil.Start();
              //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        public static void go()
        {
            lock (_lock)
            {
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList());
            gen.buildMusique();
            gen.buildClassTree();
            gen.buildLists(Db.List.Listes); 
       
            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");
          


            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            gen.timeRanking();
            gen.eraseGrouping();
           // gen.writeComment();
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true; 
         //   gen.builStats();
            gen.CommentGo = true;
            gen.GroupinGO = true;
            PlayerViewModel.Instance.SortAlbumStrict = gen.SortAlbumStrict; 
        }

        private static void _go()
        {
            bool _refresh = false; 
            try
            {
                gen.CommentGo = false;
                gen.GroupinGO = false; 
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                if (__end || __go) return;

                gen.SortAlbumStrict = PlayerViewModel.Instance.SortAlbumStrict; 
                gen.MakeConsolid(Db.List.getList()); //   bib.Musique.Tracks);
                if (__end || __go) return;

                gen.timeRanking();
                if (__end || __go) return;


              
                if (__end || __go) return;
                ChronoData.DateAuto = true;

                //if (refresh != null)
                //    refresh(PHASE1, EventArgs.Empty);

                if (__end || __go) return;
                bib.Aborted = false;
                ListWriterMgr.Async = false;
                //listWriter = new ListWriter(root);
                try
                {
                    CConf.loadConf();
                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }
                gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum; 
                gen.createRot(CConf.ListBase, App.bib);
                if (refresh != null)
                    refresh(PHASE1, EventArgs.Empty);

                if (__end || __go) return;
                gen.writeComment();
                if (__end || __go) return;
                gen.writeGrouping();
                if (refresh != null)
                    refresh(PHASE2, EventArgs.Empty);

                if (__end || __go) return;

                gen.CommentGo = true;
                gen.GroupinGO = true; 

              
                gen.CommentGo = true;
                gen.GroupinGO = true;
                //if (refresh != null)
                //    refresh(PHASE2, EventArgs.Empty);
                _refresh = true;
                gen.builStats();
                //bib = new BibViewModel(Db.Root); 
                //gen.createRot(CConf.ListBase, bib);
                //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                gen.CommentGo = true;
                gen.GroupinGO = true; 




            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally 
            {
             //   gen.eraseGrouping(); 
                if (refresh != null)
                    refresh(PHASE2, EventArgs.Empty);
                ExportCmd.CalculExport(); 
            }


        }

        public static event EventHandler refresh;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            App.bib.Aborted = true;
            Db.WriteDB1();
            Db.WriteDB2();
            App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track);
            if (l == null)
                return null;
            foreach (ITrackMetaData p in l)
            {

                TrackListViewModel trackList = PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }

        public string folderDialog()
        {
            var dialog = new System.Windows.Forms.FolderBrowserDialog();

            dialog.SelectedPath = Db.DefaultFolder;
            System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            string dir = null;
            if (result == System.Windows.Forms.DialogResult.OK)
            {
                dir = dialog.SelectedPath;
            }

            return dir;
        }


        public bool changeName(string title,IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok; 
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected; 
            }

            return null; 
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList); 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel.Commande;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Data;
using System.Windows.Input;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.util;
using System.Collections;
using pdb.gen.conf;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg; 
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg; 
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(int index)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }

    class PlayerViewModel : ViewModelBase
    {
        public static PlayerViewModel Instance = new PlayerViewModel();
        private IPlayerEngine player = PlayerBuilder.create("vlcplugin");

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        private bool sortByAlbum = true; 
        ItrackProvider _real;
        private Logger log;
        public static IPlayerEngine Player { get { return Instance.player; } }
        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return sortByAlbum;
            }
            set
            {
                if (value != sortByAlbum)
                {
                    sortByAlbum = value;
                    OnPropertyChanged("SortByAlbum");
                    App.go(); 
                }
            }
        }
        private bool sortAlbumStrict; 
        public bool SortAlbumStrict
        {
            get { return sortAlbumStrict;}
            set
            {
                if (value != sortAlbumStrict)
                {
                    sortAlbumStrict = value;                   
                    OnPropertyChanged("SortAlbumStrict");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            player.mediaEndReached += player_mediaEndReached;
            player.Volume = volume;
            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume(); 
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }


        public void forward()
        {
            movetoNext();
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext()
        {
            move(true);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {


                if (currentTrack != null)
                    tracks.MoveCurrentTo(currentTrack);
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    focus(tracks.CurrentPosition);
                    if (playing)
                    {
                        player.play(item.Location, true);
                    }
                }

            }
        }


        private void movetoPrevious()
        {
            move(false);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                                break;
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

                focus(tracks.CurrentPosition);

                State = playerstate.play;
                //item.Playing = true;
                player.play(currentTrack.Location, reload);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            player.stop();

        }

        private void next()
        {
            movetoNext();
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }
        private void focus(int index)
        {
            if (provider == null)
                return;
            provider.Focus(index);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = player.Elapsed;
                this.Length = player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    CurrentAuthorAlbum = String.Format("{0} - {1}", currentTrack.Artist, currentTrack.Album);
                    if (currentTrack.Exists)
                        currentTrack.Duration = length;
                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }



        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            Instance.provider = provider;
            Instance._positionstate = positionstate.free;
            Instance.CurrentTrack = track;
            Instance.currentPl = provider.PlayList;
            Instance.provider = provider;
            Instance.tracks = provider.PresentationTracks;
            Instance.play(true, true);
            Instance.makeResume();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            tracks.MoveCurrentTo(TrackListViewModel.CurrentPlaying);
                            provider.Focus(tracks.CurrentPosition);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
        private class filterTask
        {
            public filterTask()
            {
            }
            public string filter;
            public string waitingFilter; 
            private bool cancel; 
            private Thread th;
            public Predicate<object> Filter;
            public ICollectionView coll;
            private bool busy;

            public void go()
            {
             
                if (!string.IsNullOrEmpty(filter))
                    filter = filter.Trim().ToLower().removeAccent();

                var tab = filter.Split(' ');
                // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
                lock (this)
                    busy = true;
                coll.Filter = item =>
                {
                    TrackListViewModel vitem = item as TrackListViewModel;
                    if (vitem == null) return false;

                    //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                    //    return vitem.Classement.StartsWith(filter);
                    bool ok = true;
                    var name = vitem.Name.Trim().ToLower().removeAccent();
                    var artist = vitem.Artist.Trim().ToLower().removeAccent();
                    var album = vitem.Album.Trim().ToLower().removeAccent();
                    var classement = vitem.Classement;
                    foreach (string str in tab)
                    {
                        if (!ok)
                            return false;
                        if (string.IsNullOrEmpty(str))
                            continue;
                        var str_ = str.Trim();
                        if (str_ == string.Empty)
                            continue;

                        ok = name.Contains(str_)
                            || artist.Contains(str_)
                            || album.Contains(str_)
                            || classement.StartsWith(str_);

                    }

                    return ok;

                };

                lock (this)
                    busy = true;

            }
            private void getItems()
            {
                try
                {
                    if (!string.IsNullOrEmpty(filter))
                        filter = filter.Trim().ToLower().removeAccent();
                    if (cancel)
                        return;
                    var tab = filter.Split(' ');
                    if (cancel)
                        return;
                    Filter = item =>
                    {
                        TrackListViewModel vitem = item as TrackListViewModel;
                        if (vitem == null) return false;

                        //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                        //    return vitem.Classement.StartsWith(filter);
                        bool ok = true;
                        var name = vitem.Name.Trim().ToLower().removeAccent();
                        var artist = vitem.Artist.Trim().ToLower().removeAccent();
                        var album = vitem.Album.Trim().ToLower().removeAccent();
                        var classement = vitem.Classement;
                        foreach (string str in tab)
                        {
                            if (!ok)
                                return false;
                            if (string.IsNullOrEmpty(str))
                                continue;
                            var str_ = str.Trim();
                            if (str_ == string.Empty)
                                continue;

                            ok = name.Contains(str_)
                                || artist.Contains(str_)
                                || album.Contains(str_)
                                || classement.StartsWith(str_);

                        }

                        return ok;

                    };
                }
                catch (Exception ex)
                {
                    App.log.log(ex.ToString()); 
                }
            }
        }
        private static filterTask filtertask = new filterTask(); 
        public static void doFilter(ICollectionView coll, string filter)
        {
           
            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
          
            coll.Filter = item =>
            {
                TrackListViewModel vitem = item as TrackListViewModel;
                if (vitem == null) return false;

                //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                //    return vitem.Classement.StartsWith(filter);
                bool ok = true;
                var name = vitem.Name.Trim().ToLower().removeAccent();
                var artist = vitem.Artist.Trim().ToLower().removeAccent();
                var album = vitem.Album.Trim().ToLower().removeAccent();
                var classement = vitem.Classement;
                foreach (string str in tab)
                {
                    if (!ok)
                        return false;
                    if (string.IsNullOrEmpty(str))
                        continue;
                    var str_ = str.Trim();
                    if (str_ == string.Empty)
                        continue;

                    ok = name.Contains(str_)
                        || artist.Contains(str_)
                        || album.Contains(str_)
                        || classement.StartsWith(str_);

                }

                return ok;

            };
        }




        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}


        public void doFilter(String filter)
        {
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);
            makeResume();
        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            string newResume = resume;
            try
            {

                IEnumerable items = null;
                var provider = DisplayProvider;
                if (provider == null)
                    return;
                var tracks = provider.PresentationTracks;
                int nbOrg = -1;
                items = tracks;
                if (items == null)
                    return;

                var selected = provider.SelectedTracks;
                if (selected.Count > 1)
                {
                    items = selected;
                    nbOrg = 0;
                    foreach (TrackListViewModel t in tracks)
                        nbOrg++;
                }
                int nb = 0, nbSelected = 0, nbAbsent = 0;
                TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationAbsent = new TimeSpan();

                foreach (TrackListViewModel track in items)
                {
                    nb++;
                    duration += track.Duration;
                    if (track.Enabled)
                    {
                        nbSelected++;
                        durationSelected += track.Duration;
                    }
                    if (!track.Exists)
                    {
                        nbAbsent++;
                        durationAbsent += track.Duration;
                    }
                }

                ITextWriter sb = new pdb.util.StringBuilder();
                sb.Append(nb);
                sb.Append(" ");
                sb.Append("elt");
                if (nb > 1)
                    sb.Append("s");
                if (nbOrg >= 0)
                {
                    sb.Append(" sur ");
                    sb.Append(nbOrg);
                    sb.Append(",");
                }
                sb.Append(" ");
                humanDuration(sb, duration);
                sb.Append(" ( ");
                sb.Append(nbSelected);
                sb.Append(" ");
                sb.Append("elt");
                if (nbSelected > 1)
                    sb.Append("s");
                sb.Append(" ");
                humanDuration(sb, durationSelected);

                sb.Append(" )");

                if (nbAbsent > 0)
                {
                    sb.Append(" absents:");
                    sb.Append(nbAbsent);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationAbsent);
                }
                sb.Append("\t");

                var currentTrack = TrackListViewModel.HumanSelected;
                if (currentTrack != null)
                {
                    humanSize(sb, currentTrack.Size);
                    sb.Append(" ");
                    sb.Append(currentTrack.Location);
                }

                newResume = sb.ToString();
            }
            catch (Exception e0)
            {
                App.log.log(e0.ToString()); 
            }
            finally
            {
                if (newResume != resume)
                {
                    resume = newResume;
                    if (resumeChange != null)
                    {
                        try
                        {
                            resumeChange(this, EventArgs.Empty);
                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString()); 
                        }
                    }
                }
            }
        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append( size.HumanReadableSize(-1)); 
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append(" j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append(" h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append(" h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append(" m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append(" m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append(" s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\BibCtl.xaml.cs">
    <content><![CDATA[using System;
using System.Windows;
using System.Windows.Controls;
using pdb.player.ViewModel;
using pdb.util;

namespace pdb.player.Vue
{
    public partial class BibCtl : UserControl, IRedraw
    {
        private BibViewModel bib;
        private Logger log;

        public BibCtl()
        {
            log = Logger.getLogger("BibCtl");
            InitializeComponent();
            Loaded += Bib_Loaded;
            App.refresh += new EventHandler(App_refresh);
        }

        void App_refresh(object sender, EventArgs e)
        {
            if (!App.PHASE2.Equals(sender))
                return;
            log.log("BibCtl::App_refresh");
            if (Dispatcher.CheckAccess())
                AppRefresh();
            else
                Dispatcher.Invoke(new Action(AppRefresh));
        }

        void AppRefresh()
        {
            return;
            log.log("BibCtl::AppRefresh");
            try
            {
                tv_bib.Items.Refresh();
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        internal BibViewModel BibRoot
        {
            set
            {
                bib = value;
                base.DataContext = bib;
                if (tv_bib != null)
                    tv_bib.ItemsSource = bib.Root;
            }
        }

        void Bib_Loaded(object sender, RoutedEventArgs e)
        {
            if (bib == null)
                bib = App.bib;
            PlayListViewModel.addDrow(this);
            base.DataContext = bib;
            if (bib != null)
                tv_bib.ItemsSource = bib.Root;
        }




        public void redraw()
        {
            if (Dispatcher.CheckAccess())
                AppRefresh();
            else
                Dispatcher.Invoke(new Action(AppRefresh));
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\PlayerControler.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.PlayerControler"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
              xmlns:local="clr-namespace:pdb.player"
              xmlns:util="clr-namespace:pdb.player.Vue.Util"
             mc:Ignorable="d" 
             d:DesignHeight="167" d:DesignWidth="777">
    <UserControl.Resources>
        <util:StringFormatConverter x:Key="StringFormater" />
        <util:TimeFormatConverter x:Key="TimeSpan" />
        <util:IntFormatConverter x:Key="Int" />
        <Style x:Key="EmptyButtonStyle" TargetType="{x:Type Button}">
            <Setter Property="Background" Value="#00000000"/>
            <Setter Property="BorderBrush" Value="#00000000"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Foreground" Value="{DynamicResource {x:Static SystemColors.ControlTextBrushKey}}"/>
            <Setter Property="HorizontalContentAlignment" Value="Center"/>
            <Setter Property="VerticalContentAlignment" Value="Center"/>
            <Setter Property="Padding" Value="0"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <ContentPresenter 
                        HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" 
                        Margin="{TemplateBinding Margin}" 
                        RecognizesAccessKey="True" 
                        SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" 
                        VerticalAlignment="{TemplateBinding VerticalContentAlignment}"
                           
                            />
                        
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </UserControl.Resources>
    <Grid Margin="0" >
        <Grid.Background>
            <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                <GradientStop Color="#fff" Offset="0" />
                <GradientStop Color="#dfdfdf" Offset="1" />
               
            </LinearGradientBrush>

        </Grid.Background>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Name="defNav" Width="Auto" />
            <ColumnDefinition Name="defInfo" Width="*" />
            <ColumnDefinition Name="defFilter" Width="Auto" />
        </Grid.ColumnDefinitions>
        <Grid Margin="10" Grid.Column="0" >
            <StackPanel Orientation="Horizontal" VerticalAlignment="Bottom">

                <Button Name="b_rewind" Height="40" Width="40" Command="{Binding BackWard}" Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Rewind-icon.png"  Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_play" Height="40" Width="40"  Command="{Binding Play,UpdateSourceTrigger=PropertyChanged}"  Style="{DynamicResource EmptyButtonStyle}">
                    <!--<Image Name="I_Play" Source="images\Toolbar-MP3-Play-icon.png"   Height="30" Width="30"></Image>-->
                    <Image Name="I_Play" Source="{Binding SrcPlayPause, UpdateSourceTrigger=PropertyChanged}"   Height="30" Width="30"></Image>
                </Button>
                <Button Name="b_forward" Height="40" Width="40" Command="{Binding Forward}"  Style="{DynamicResource EmptyButtonStyle}">
                    <Image Source="images\Toolbar-MP3-Forward-icon.png"    Height="30" Width="30" ></Image>
                </Button>
                <Grid Margin="10">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition />
                        <ColumnDefinition />
                        <ColumnDefinition />
                    </Grid.ColumnDefinitions>
                    <TextBlock Text="&lt;)" Grid.Column="0"  VerticalAlignment="Center" Margin="0,0,5,0"/>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="SliderVolume" Width="150" VerticalAlignment="Center" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Volume, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <TextBlock Text="&lt;)))" Grid.Column="2"  VerticalAlignment="Center"  Margin="5,0,00,0"/>
                </Grid>
            </StackPanel>
        </Grid>
       
        <Grid Grid.Column="1">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Name="defName" MaxHeight="50" Height="Auto" />
                    <RowDefinition Name="defPosition" Height="Auto" />
                </Grid.RowDefinitions>

                <StackPanel Grid.Row="0" Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,15,0,0">
                    <Label Name="l_TrackName"  HorizontalAlignment="Center" Content="{Binding Path=CurrentName,  UpdateSourceTrigger=PropertyChanged}"  FontWeight="Bold" Padding="0" Margin="0"></Label>
                    <Label Grid.Row="1" Name="l_trackAuthorAlbum" HorizontalAlignment="Center" Content="{Binding Path=CurrentAuthorAlbum,  UpdateSourceTrigger=PropertyChanged}"  Padding="0" Margin="0"/>
                </StackPanel>
                <Grid Grid.Row="2"  HorizontalAlignment="Stretch" Margin="5">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                        <ColumnDefinition Width="Auto" />
                    </Grid.ColumnDefinitions>
                    <StackPanel Grid.Column="0" Orientation="Horizontal">
                        <CheckBox Name="cbEnabled" DockPanel.Dock="Left" ToolTip="Jouer seulement les morceaux cochés" IsChecked="{Binding OnlyEnabled,UpdateSourceTrigger=PropertyChanged}" />
                        <CheckBox Name="cbSortAlbum" DockPanel.Dock="Left" ToolTip="Tri par album" IsChecked="{Binding SortByAlbum,UpdateSourceTrigger=PropertyChanged}" />
                        <CheckBox Name="cbSortStrict" DockPanel.Dock="Left" ToolTip="Tri strict" IsChecked="{Binding SortAlbumStrict,UpdateSourceTrigger=PropertyChanged}" />
                        <Label Name="Duration" DockPanel.Dock="Left" VerticalAlignment="Bottom" Content="{Binding Path=ElapsedTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />

                    </StackPanel>
                    <Slider Grid.Column="1"  Margin="5,0,0,0" Name="PBar"  VerticalAlignment="Bottom" HorizontalAlignment="Stretch"  Minimum="0" Maximum="1" Value="{Binding Path=Position, UpdateSourceTrigger=PropertyChanged, Mode=TwoWay}" IsMoveToPointEnabled="True" />
                    <StackPanel Grid.Column="2" Orientation="Horizontal">
                        <Label Name="RemainingTime"   VerticalAlignment="Bottom" Content="{Binding Path=RemainingTime, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"  />
                        <Label Content="/" />
                        <Label Name="Length"  VerticalAlignment="Bottom" Content="{Binding Path=Length, UpdateSourceTrigger=PropertyChanged, Converter={StaticResource TimeSpan}}"/>
                    </StackPanel>
                </Grid>
            </Grid>

        </Grid>
        <DockPanel Grid.Column="2" HorizontalAlignment="Stretch" VerticalAlignment="Top" Margin="0,15,0,0">
            <GroupBox Header="Filtre" HorizontalAlignment="Right" DockPanel.Dock="Right">
                <StackPanel Orientation="Horizontal" >
                    <TextBox x:Name="txtFilter" MinWidth="150"  KeyUp="txtFilter_KeyUp" />
                </StackPanel>
            </GroupBox>
        </DockPanel>


    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    class AutoBuilder : IComparable<AutoBuilder>, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private IBuilderSource source; public IBuilderSource Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;



        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(IBuilderSource source)
        {
            this.source = source;
            source.addBorderObs(this);
        }
        private static AutoBuilder main;
        public static void build(XmlNode xAuto, IBuilderSource source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    {
                        //if (!exist)
                        //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                        tw.Write(DateTime.Now); tw.Write(SEP);
                        tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                        tw.Write(d.ToString("0.###")); tw.Write(SEP);
                        tw.Write(org.ToString("0.###")); tw.Write(SEP);
                        tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(atomicMode); tw.Write(SEP);
                        tw.Write(state); tw.Write(SEP);
                        for (int i = 0; i < imax; i++)
                        {
                            if (i > 0)
                            {
                                tw.WriteLine();
                                for (int j = 0; j < 11; j++)
                                    tw.Write(SEP);
                            }
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].track);
                            tw.Write(SEP);
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].item);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].track);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].item);
                            tw.Write(SEP);
                        }
                        tw.WriteLine();
                    }
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            bool firstWIthTb = first && Conf.BorderTb;
            bool secondwithoutTb = !first && !Conf.BorderTb;
            bool readXml = firstWIthTb || secondwithoutTb;
            FileInfo f = null; 
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                if (first)
                builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check2();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                AutoBuilder builder = null;
                if (!started)
                {
                    started = true;
                    foreach (AutoBuilder b in list)
                        b.total = b.source.getTotalSize();
                }
                // application de la précédente modif
                builder = list[index];
                if (builder.state > builderstate.none)
                {
                    builder.makeEmpreinteNonSequence();
                    decrementIndex();
                }
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    builder = list[i];
                    bool cango = false;
                    bool _cont = false;
                    while (true)
                    {
                        if (i == index || _cont)
                        {
                            cango = builder.check();
                            index = i;
                            main = builder;
                            _cont = false;
                            break;
                        }
                        else
                            cango = builder.checkWithoutModify();
                        if (builder.state == builderstate.none)
                            _cont = true;
                        else
                            break;
                    }
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (i == index)
                    {
                        if (builder.newv != builder.org)
                        {
                            _modifFile = true;
                        }
                        else
                        {
                            //index--;
                            //if (index < 0)
                            //    index = list.Count - 1;
                        }
                    }
                    if (_modifFile)
                        break;
                }
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                    _cango = false;
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        private bool check()
        {
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.none)
                reset();
            else if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
                else
                {
                    mustUpdate = false;
                    canGo = true;
                    org = newv;
                    return true;
                }
            }
            if (Conf.AutoSequence || total < 0)
                total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
            if (state == builderstate.none)
                delta0 = delta;
            state = builderstate.enCours;
            lastd = d;
            d = 0;
            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return true;
            string attTarget = conf.type.ToString();
            var att = xml.Attributes[attTarget];
            if (att == null)
                return true;
            org = Convert.ToDouble(att.Value);
            newv = org;
            try
            {
                if (delta * delta0 < 0)
                {
                    if (atomicMode < 0)
                    {
                        atomicMode = 0;
                        //if (minMem == null)
                        //    minMem = new Memory(mem0);
                        //if (maxMem == null)
                        //    maxMem = new Memory(mem0);
                        //if (minMem.suppressions.Count == 0)
                        //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
                        //if (maxMem.ajouts.Count == 0)
                        //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
                    }
                }
                bool cancelSameConf = false;
                bool cancelNb = false;
                if (atomicMode >= 0)
                {
                    atomicMode++;
                    if (Math.Abs(dmin - delta) < EPSILON)
                        sameConfiguration++;
                    else if (Math.Abs(dmax - delta) < EPSILON)
                        sameConfiguration++;
                    else
                        sameConfiguration = 0;
                    if (sameConfiguration > conf.idem)
                        cancelSameConf = true;
                    if (atomicMode > conf.cloop)
                        cancelNb = true;
                }
                if (delta >= 0)
                {
                    if (mem0.suppressions.Count > 0)
                        minMem = new Memory(mem0);
                    if (delta < conf.write)
                        canGo = true;
                    //  lastGoodLevel = org;
                    //if (maxMem != null && minMem != null)
                    //{
                    if (atomicMode > 0)
                    {
                        if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
                        {
                            log("abandon recherche cartésienne cause idem");
                            state = builderstate.stable;
                            return true;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            state = builderstate.stable;
                            return true;
                        }
                        //if (Math.Abs(dmin - delta) < 0.01)
                        //    dminAlready = true;
                        //else
                        //    dminAlready = false;
                        if (maxMem != null && minMem != null)
                        {
                            if (minMem.suppressions.Count == maxMem.ajouts.Count)
                            {
                                bool identique = true;
                                for (int i = 0; i < minMem.suppressions.Count; i++)
                                {
                                    if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                    {
                                        identique = false;
                                        break;
                                    }
                                }
                                if (identique)
                                {
                                    if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
                                    {
                                        mustUpdate = false;
                                        log("abandon recherche cartésienne cause cycle");
                                        state = builderstate.stable;
                                        _empreinte = newEmpreinte;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    cmin = org;
                    dmin = delta;
                    // lastGoodDelta = (int)delta;
                    lastTotal = (int)total;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        //if (atomicMode > conf.cloop)
                        //{
                        //    mustUpdate = false;
                        //    log("abandon recherche cartésienne cause cloop");
                        //    state = builderstate.stable;
                        //    _empreinte = newEmpreinte;
                        //    return true;
                        //}
                        //if (dminAlready && dmaxAlready)
                        //{
                        //    mustUpdate = false;
                        //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
                        //    return true;
                        //}
                        d = 0.5 * (cmax - cmin);
                    }
                    else
                    {
                        double _d = int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmax - cmin;
                        double aux = int.MaxValue;
                        // double aux2 = int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - level.d) * level.inf;
                            if (aux > d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {

                            if (org > conf.max)
                                d = conf.max - org;
                            else
                            {
                                d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 < d)
                        //    d = aux2;

                        if (d > _d)
                            d = _d;
                    }
                }
                else if (delta < 0)
                {
                    if (mem0.ajouts.Count > 0)
                        maxMem = new Memory(mem0);
                    mustUpdate = true;
                    canGo = false;
                    //if (maxMem != null && minMem != null)
                    //{
                    //    if (atomicMode < 0)
                    //        atomicMode = 0;
                    //    atomicMode++;
                    //}
                    cmax = org;
                    dmax = delta;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        bool identique = false;
                        if (minMem != null && maxMem != null
                            && maxMem.ajouts.Count == minMem.suppressions.Count)
                        {
                            identique = true;
                            for (int i = 0; i < minMem.suppressions.Count; i++)
                            {
                                if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                {
                                    identique = false;
                                    break;
                                }
                            }
                        }
                        if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
                        {
                            log("retour derniere bonne valeur cause idem");
                            d = cmin - cmax;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            d = cmin - cmax;
                        }
                        else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
                        {
                            log("retour derniere bonne valeur cause cycle");
                            d = cmin - cmax;
                        }
                        //else if (atomicMode > conf.cloop)
                        //{                      
                        //    log("abandon recherche cartésienne cause cloop");
                        //    d = cmin - cmax;
                        //}
                        else
                            d = 0.5 * (cmin - cmax);
                    }
                    else
                    {

                        double _d = -int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmin - cmax;
                        double aux = -int.MaxValue;
                        // double aux2 = -int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - conf.delta + level.d) * level.sup;
                            if (aux < d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {
                            if (org < conf.min)
                                d = (conf.min - org);
                            else
                            {
                                d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 > d)
                        //    d = aux2;

                        if (d < _d)
                            d = _d;
                    }
                    //d = (delta - conf.delta) * conf.sup;
                    //if (org <= lastGoodLevel)
                    //{
                    //    lastGoodLevel = -1;
                    //    lastGoodDelta = -1;
                    //    lastTotal = -1;
                    //}
                }
                if (Math.Abs(d) < 0.00000001)
                {
                    mustUpdate = false;
                    // unCart();
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                //if (dejaVu)
                //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
                log("correction {0}", d);
                newv = org + d;
                if (newv <= 0)
                    newv = 0;
                if (conf.coeff > 0)
                {
                    if (newv > conf.max)
                        newv = conf.max;
                    else if (newv < conf.min)
                        newv = conf.min;
                }
                newv = Math.Round(newv, 8);
                log(" valeur {0} --> {1}", org, newv);
                att.Value = newv.ToString();
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
                string strDate = "";
                var attD = xml.Attributes["date"];
                if (attD != null)
                    strDate = attD.Value;
                bool exist = File.Exists(file);
                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void calcChoose(bool up, bool strict, bool checkSelect)
        {
            double dt = double.MaxValue;
            double gap = double.MaxValue;
            bool trou = false; 
            foreach (AutoBuilderItem item in items)
            {
                item.after(up, strict, checkSelect); 
                item.setTension(up, strict);
                if (item.Stop)
                {
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }
                double aux = double.MaxValue;
                // var tension = item.Tension;
                if (conf.selectFix)
                {
                    var tension = item.Tension;
                    aux = up ? tension : -tension;
                }
                else
                    aux = item.Dt;

                if (conf.selectAbs && !conf.selectFix && aux < 0)
                    aux *= -1;



                if (item.getCauses().Count == 0)
                {
                    trou = true;
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }

                var _gap = Math.Abs(aux);
                if (_gap < gap)
                    gap = _gap; 

                if (aux < dt)
                {
                    dt = aux;
                    newv = item.NewV;
                    choose = item;
                }
            }
            if (trou && conf.gap && gap < double.MaxValue)
            {
                foreach (AutoBuilderItem item in items)
                {
                    if (item.Stop)
                        continue;
                    item.gap(up, conf.selectFix, gap); 
                }
            }
        }

        private bool check2()
        {
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


                //else if (choose != null)
                //    choose.makePertinent();
            }
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }

                total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                log("delta {0}", delta);
                if (delta * lastDelta < 0)
                {
                    if (delta > 0)
                    {
                        // ok!
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    // retour arrière
                    if (choose != null)
                    {
                        choose.stop();
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                }
                lastDelta = delta;
                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;
                if (up && delta < conf.delta)
                {
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                if (delta * delta0 < 0)
                {
                    if (choose != null)
                        choose.stop();
                    canGo = false;
                    mustUpdate = true;
                    return false;
                }
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop)
                        {
                            state = builderstate.stable;
                            return true;
                        }
                    }
                }

                //foreach (AutoBuilderItem item in items)
                //    item.after();



                if (!Conf.BorderIdem)
                {
                    calcChoose(up, true,true);
                    if (choose != null)
                        log("REEL - SELECT");
                    else
                    {
                        calcChoose(up, true, false);
                        if (choose != null)
                            log("REEL");
                        else
                        {
                            calcChoose(up, false, true);
                            if (choose != null)
                                log("SELECT");
                            else
                            {
                                calcChoose(up, false, true);
                            }
                        }
                    }
                    //foreach (AutoBuilderItem item in items)
                    //{
                    //    if (!item.Stop)
                    //        item.setTension(up, real);
                    //}
                    //choose = null;
                    //foreach (AutoBuilderItem item in items)
                    //{
                    //    if (item.Stop)
                    //        continue;
                    //    double aux = double.MaxValue;
                    //    // var tension = item.Tension;
                    //    if (conf.selectFix)
                    //    {
                    //        var tension = item.Tension;
                    //        aux = up ? tension : -tension;
                    //    }
                    //    else
                    //        aux = item.Dt;

                    //    if (conf.selectAbs && !conf.selectFix && aux < 0)
                    //        aux *= -1;

                    //    // TrackBorderItem tb = up ? item.rejected(real) : item.selected(real);
                    //    if (item.getcauses(up, true).Count == 0)
                    //    {
                    //        if (Conf.BorderGranSlam)
                    //        {
                    //            choose = null;
                    //            break;
                    //        }
                    //        if (!Conf.BorderIdem)
                    //            continue;
                    //    }

                    //    if (aux < dt)
                    //    {
                    //        dt = aux;
                    //        newv = item.NewV;
                    //        choose = item;
                    //    }
                    //}
                }
                //if (choose == null)
                //{
                //    // real = false;
                //    calcChoose(up, false);
                //    //dt = double.MaxValue;
                //    //foreach (AutoBuilderItem item in items)
                //    //{
                //    //    if (item.Stop)
                //    //        continue;

                //    //    item.setTension(up, real);
                //    //}
                //    //foreach (AutoBuilderItem item in items)
                //    //{
                //    //    if (item.Stop)
                //    //        continue;
                //    //    if (item.getcauses(up, false).Count == 0)
                //    //        continue;
                //    //    double aux = double.MaxValue;
                //    //    // var tension = item.Tension;
                //    //    if (conf.selectFix)
                //    //    {
                //    //        var tension = item.Tension;
                //    //        aux = up ? tension : -tension;
                //    //    }
                //    //    else
                //    //        aux = item.Dt;
                //    //    if (conf.selectAbs && !conf.selectFix && aux < 0)
                //    //        aux *= -1;


                //    //    if (aux < dt)
                //    //    {
                //    //        dt = aux;
                //    //        newv = item.NewV;
                //    //        choose = item;
                //    //    }
                //    //}
                //}
                //else
                //    log("REEL!!!!");

                if (choose == null)
                {
                    log("choose null");
                    state = builderstate.stable;
                    return true;
                }

                org = choose.Org;



                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                    // var nextTrack = choose.rejected(real).candidat;
                    var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
                    if (delta < size)
                    {
                        // choose.stop();
                        if (conf.stopAll)
                        {
                            state = builderstate.stable;
                            return true;
                        }
                        else
                            choose.stop();
                    }

                }
                else
                {
                }
                choose.save();
                Program.logAuto.log("===> " + choose.ToString());
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    bool exist = File.Exists(file);
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder(); 
            sb.Append( string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9})", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
                sb.Append(item);
            sb.AppendLine();
            return sb.ToString(); 
        
        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************"); 
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            if (choose != null)
                type = choose.type.ToString(); 
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
        
            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);
         
            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                log(" valeur {0} --> {1}", org, newv);
                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log(""); 
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        private CauseRegister causeRegister = new CauseRegister();
        public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB; i++)
            {
                var data = cd.datas[i];
                if (data == null || data.virtuel)
                    continue;
                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].virtuel = true;
                else
                    nb++;
            }

            //if (nb == 0)
            //    return; 

            causeRegister.signal(cd);

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;
using pdb.podcast.Selection;
using pdb.podcast.Report;

namespace pdb.podcast.Auto
{
    class AutoBuilderItem : IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private timeSpan tpertinentOrg;
        private TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        private double evolSize;
        public double NewV { get { return newv; } }
        internal TrackBorderItem rejected(bool real) { return real ? _rejected : _rejectedLight; }
        internal TrackBorderItem selected(bool real) { return real ? _selected : _selectedLight; }
        internal void makePertinent() { pertinentOrg = org; }

        public void checkAjout(IEnumerable<TrackInfoItunes> list)
        {
            if (pertinentOrg == org)
                return;

            var lcauses = _causes; 


            foreach (Causes causes in lcauses)
            {
                foreach (TrackInfoItunes t in list)
                {
                    if (causes.candidat.Location == t.Location)
                    {
                        pertinentOrg = org;
                        return;
                    }
                }

            }


        }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlElement xml;
        double dd;
        double d;
        private bool lastStrict;
        private bool lastUp;
        private double lastDelta;
      
        private double lastOrg;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        public AutoBuilderItem(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente - conf.min;
            dd = d * d;
        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _selectedLight;
        private TrackBorderItem _rejected;
        private TrackBorderItem _rejectedLight;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }

            //    tb.status = borderStatus.rejectedXtraLight; 
            //}


            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }


        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;

                if (!tb.Virtual)
                {
                    if (_selected == null)
                        _selected = tb;
                    else if (tb.val > _selected.val)
                        _selected = tb;
                }

                if (_selectedLight == null)
                    _selectedLight = tb;
                else if (tb.val > _selectedLight.val)
                    _selectedLight = tb;

                //if (_selected == null)
                //    setSelect(tb);
                //else
                //{
                //    if (tb.status > _selected.status && !Conf.BorderIdem)
                //        setSelect(tb);
                //    else if (tb.status == _selected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val > _selected.val)
                //            setSelect(tb);
                //    }
                //}

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;

                if (!tb.Virtual)
                {
                    if (_rejected == null)
                        _rejected = tb;
                    else if (tb.val < _rejected.val)
                        _rejected = tb;
                }

                if (_rejectedLight == null)
                    _rejectedLight = tb;
                else if (tb.val < _rejectedLight.val)
                    _rejectedLight = tb;


                //if (_rejected == null)
                //    setRejec(tb);
                //else
                //{
                //    if (tb.status > _rejected.status && !Conf.BorderIdem)
                //        setRejec(tb);
                //    else if (tb.status == _rejected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val < _rejected.val)
                //            setRejec(tb);
                //    }
                //}

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
           // Program.logAuto.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];
            lastOrg = org;
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            tpertinentOrg = getValue(pertinentOrg);
            //  misc.log(ToString());
        }
        private double dt; public double Dt { get { return dt; } }
        private double tension; public double Tension { get { return tension; } }
        private bool _stop = false;
        public bool Stop { get { return _stop; } }
        public void reset()
        {
            _stop = false;
        }
        public void setTension(bool up, bool real)
        {

            dt = getDt(up, real);
        }

        private double getDt(bool up, bool real)
        {
            double t0 = _getTension(pertinentOrg);
            tension = _getTension(up, real);
            return (tension - t0) / conf.coeff;

        }

        private double getTension(bool up, bool real)
        {
            return _getTension(up, real) / conf.coeff;
        }

        private double getValue(TimeSpan val)
        {
            switch (type)
            {

                case borderType.d:
                case borderType.fd:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                case borderType.c:
                    break;
                default: return -1;

            }
            return -1;
        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.d:
                case borderType.fd:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                case borderType.c:
                    break;
                default: return new TimeSpan();

            }
            return new TimeSpan();
        }
        public double EvolSize { get { return evolSize; } }

        public List<Causes> getCauses()
        {
            return _causes;
        }

        //public List<Causes> getcauses(bool up, bool strict)
        //{
        //    List<Causes> list = null;
        //    if (up)
        //    {
        //        if (strict)
        //            list = _causesRejetStrict;
        //        else
        //            list = _causesRejet;
        //    }
        //    else
        //    {
        //        if (strict)
        //            list = _causesSelectStrict;
        //        else
        //            list = _causesSelect;
        //    }
        //    return list;
        //}

        public void gap(bool up, bool fix, double _gap)
        {
            _gap = Math.Abs(_gap); 
            if (fix)
            {
                newv = Math.Abs(_gap);
            }
            else
            {
                if (up)
                    newv = org + _gap;
                else
                    newv = org - _gap; 
            }
            save(); 
        }

        private double _getTension(bool up, bool strict)
        {
            lastStrict = strict;
            lastUp = up;
            // double t0 = getTension(org, dd);
            newv = org;
            evolSize = 0;
            var list = _causes; 


            if (list.Count > 0)
            {
                var cause = list[0].getCause(type, strict, !up);
                newv = Math.Round(getValue(cause.val), 8);
                foreach (var c in list)
                {
                    var cand = c.candidat;
                    evolSize += Stat.getSizeinMo(cand);
                }
            }
            else
                return int.MaxValue;


            //if (false)
            //{

            //    if (up)
            //    {
            //        var _rejected = strict ? this._rejected : this._rejectedLight;
            //        if (_rejected == null)
            //            return int.MaxValue;
            //        newv = Math.Abs(Math.Round(getValue(_rejected.val), 8));
            //        evolSize = Stat.getSizeinMo(_rejected.candidat);

            //    }
            //    else
            //    {
            //        var _selected = strict ? this._selected : this._selectedLight;
            //        if (_selected == null)
            //            return int.MaxValue;
            //        newv = Math.Round(getValue(_selected.val), 8);
            //    }
            //}

            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            _toSave = true;
        }

        private List<Causes> _causes = new List<Causes>(); 
        //private List<Causes> _causesRejet = new List<Causes>();
        //private List<Causes> _causesSelect = new List<Causes>();

        //private List<Causes> _causesRejetStrict = new List<Causes>();
        //private List<Causes> _causesSelectStrict = new List<Causes>();
       

        public void stop()
        {
            newv = lastOrg;
            org = lastOrg; 
            _stop = true;
            save();
        }
        //public void after()
        //{            
        //    _causesRejet = new List<Causes>();
        //    _causesSelect = new List<Causes>();
        //    _causesRejetStrict = new List<Causes>();
        //    _causesSelectStrict = new List<Causes>();
        //    after(true, true);
        //    after(true, false);
        //    after(false, true);
        //    after(false, false);
        //}
        public void after(bool up, bool strict, bool checkSelection)
        {
            _causes = new List<Causes>(); 
            var list = parent.CauseRegister.getList(false);
            int min = int.MaxValue;
            //  int minStrict = int.MaxValue;
            if (!up)
            {
                min = 0;
                //   minStrict = 0; 
            }
            int orgValue = torg.Value;
            foreach (Causes causes in list)
            {
                var candidat = causes.candidat;
                if (checkSelection)
                {
                    if (up && candidat.Selected)
                        continue;
                    if (!up && !candidat.Selected)
                        continue;
                }
                var cause = causes.getCause(type, strict, !up);
                if (cause == null)
                    continue;
                if (up && cause.success)
                    continue;
                if (!up && !cause.success)
                    continue;
                //if (value < 0)
                //    value = -value;
                int value = cause.val.Value;

                if (up)
                {
                    //var _causes = strict ? this._causesRejetStrict : this._causesRejet;
                    if (value == min)
                    {
                        //bool same = false; 
                        //foreach (var _c in _causesRejet)
                        //{
                        //    if (_c.candidat.Album == causes.candidat.Album && _c.getCause(type).limit == cause.limit)
                        //    {
                        //        same = true;
                        //        break; 
                        //    }
                        //}

                        //if (same)
                        //    continue;
                        _causes.Add(causes);
                        // 
                    }
                    else if (value < min)
                    {
                        _causes.Clear();
                        _causes.Add(causes);
                        min = value;
                    }
                    // vérif strict
                    //bool strict = true;
                    //foreach (CauseItem ci in causes.getCauses())
                    //{
                    //    if (ci == cause)
                    //        continue;
                    //    if (ci.val.Value > 0) // échec
                    //    {
                    //        strict = false;
                    //        break;
                    //    }
                    //}
                    //if (strict)
                    //{
                    //    if (value == minStrict)
                    //    {
                    //        //bool same = false; 
                    //        //foreach (var _c in _causesRejetStrict)
                    //        //{
                    //        //    if (_c.candidat.Album == causes.candidat.Album && _c.getCause(type).limit == cause.limit)
                    //        //    {
                    //        //        same = true;
                    //        //        break; 
                    //        //    }

                    //        //}
                    //        //if (same)
                    //        //    continue;
                    //        _causesRejetStrict.Add(causes);
                    //        // 
                    //    }
                    //    else if (value < minStrict)
                    //    {
                    //        _causesRejetStrict = new List<Causes>();
                    //        _causesRejetStrict.Add(causes);
                    //        minStrict = value;
                    //    }
                    //}
                }
                else
                {
                    if (value >= orgValue)
                        continue;
                 //   var _causes = strict ? this._causesSelectStrict : this._causesSelect;
                    if (value == min)
                    {
                        //bool same = false; 
                        //foreach (var _c in _causesSelect)
                        //{
                        //    if (_c.candidat.Album == causes.candidat.Album && _c.getCause(type).limit == cause.limit)
                        //    {
                        //        same = true;
                        //        break;
                        //    }
                        //}
                        //if (same)
                        //    continue; 
                        _causes.Add(causes);
                    }
                    else if (value > min)
                    {
                        _causes.Clear();
                        _causes.Add(causes);
                        min = value;
                    }

                    //// vérif strict
                    //bool strict = true;
                    //foreach (CauseItem ci in causes.getCauses())
                    //{
                    //    if (ci == cause)
                    //        continue;
                    //    if (ci.val.Value > 0) // échec
                    //    {
                    //        strict = false;
                    //        break;
                    //    }
                    //}
                    //if (strict)
                    //{
                    //    if (value == minStrict)
                    //    {
                    //        //bool same = false; 
                    //        //foreach (var _c in _causesSelectStrict)
                    //        //{
                    //        //    if (_c.candidat.Album == causes.candidat.Album && _c.getCause(type).limit == cause.limit)
                    //        //    {
                    //        //        same = true;
                    //        //        break;
                    //        //    }

                    //        //}
                    //        //if (same)
                    //        //    continue; 
                    //        _causesSelectStrict.Add(causes);
                    //        // 
                    //    }
                    //    else if (value > minStrict)
                    //    {
                    //        _causesSelectStrict = new List<Causes>();
                    //        _causesSelectStrict.Add(causes);
                    //        minStrict = value;
                    //    }
                    //}
                }

            }
        }


        private double _getTension(double org)
        {


            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }

       

        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");
            if (_stop)
            {
                sb.Append("STOP! "); 
            }
            sb.Append("pertinent="); sb.Append(pertinentOrg); sb.Append(" ");
            sb.Append("tension="); sb.Append(tension); sb.Append(" ");
            sb.Append("dt="); sb.Append(dt); sb.Append(" ");

            var causes = _causes; // getcauses(lastUp, lastStrict);
            foreach (Causes cause in causes)
            {
                sb.AppendLine();
                var strStrict = lastStrict ? "strict " : "light ";
                var strselect = lastUp ? "rejet " : "select ";
                sb.Append(strselect);
                sb.Append(strStrict);
                sb.Append(cause.getCause(type, lastStrict, !lastUp));
                sb.Append(" "); sb.Append(cause.candidat);
            }

            //if (_causesRejetStrict.Count > 0)
            //{


            //    foreach (Causes cause in _causesRejetStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet strict "); sb.Append(cause.getCause(type,true,false));                     
            //    }
            //}

            //else if (_causesRejet.Count > 0)
            //{

            //    foreach (Causes cause in _causesRejet)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet light "); sb.Append(cause.getCause(type,false, false));      
            //    }
            //}

            //if (_causesSelectStrict.Count > 0)
            //{

            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select strict "); sb.Append(cause.getCause(type,true,true));      
            //    }
            //}

            //else if (_causesSelect.Count > 0)
            //{              
            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select light "); sb.Append(cause.getCause(type,false,true));      
            //    }
            //}



            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }


        public void signal(CauseDatas cd)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Selection\Causes.cs">
    <content><![CDATA[using pdb.podcast.Auto;
using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;

namespace pdb.podcast.Selection
{
    class Causes
    {
        public Causes(TrackInfoItunes candidat)
        {
            this.candidat = candidat;
        }
        public readonly TrackInfoItunes candidat;
        public const int NB = 4;
        private CauseItem[,] causes = new CauseItem[4, NB];
        //private CauseItem[] causesStrict = new CauseItem[NB];

        //private CauseItem[] causesRejet = new CauseItem[NB];
        //private CauseItem[] causesRejetStrict = new CauseItem[NB];
        private bool selected;

        //public void check(bool okDate, timeSpan vdate,
        //                  bool okFd, timeSpan vfd,
        //                  bool okNb, int nb,
        //                  bool okD, timeSpan vd,
        //                  LimitItemBase limit)
        //{

        //    check(okDate, borderType.maxdate, vdate, limit);

        //    check(okFd, borderType.fd, vfd, limit);

        //    check(okNb, borderType.nb, timeSpan.FromMinutes(nb), limit);

        //    check(okD, borderType.d, vd, limit);

        //}

        public void check(CauseDatas cd)
        {
            if (cd.candidat.Name == "Littérature chinoise en ligne 14.11.12")
            {
            }
            int nb = 0;
            int nbSuccess = 0;
            foreach (CauseDataValue cdv in cd.datas)
            {
                if (cdv == null)
                    continue;
                nb++;
                if (cdv.ok)
                    nbSuccess++;
                if (!cdv.virtuel)
                    check(cdv.ok, cdv.type, cdv.val, cd.limit, false);
            }
            if (nb < 2)
                return;
            if (nbSuccess < nb - 1)
                return;
            bool thisSuccess = nbSuccess == nb;
            foreach (CauseDataValue cdv in cd.datas)
            {
                if (cdv == null)
                    continue;
                if (cdv.virtuel)
                    continue;
                if (thisSuccess)
                    check(cdv.ok, cdv.type, cdv.val, cd.limit, true);
                else
                {
                    if (cdv.ok)
                        continue;
                    check(cdv.ok, cdv.type, cdv.val, cd.limit, true);
                }
            }

            //if (!selected && thisSuccess)
            //{
            //    int mode = getMode(true, true);
            //    selected = true;
            //    for (int i = 0; i < NB; i++)
            //        causes[mode,i] = null;
            //}

            //if (selected)
            //{
            //    if (thisSuccess)
            //    {
            //        foreach (CauseDataValue cdv in cd.datas)
            //        {
            //            if (cdv == null)
            //                continue;
            //            if (cdv.virtuel)
            //                continue;
            //            check(cdv.ok, cdv.type, cdv.val, cd.limit, true);
            //        }
            //    }
            //}
            //else
            //{
            //    foreach (CauseDataValue cdv in cd.datas)
            //    {
            //        if (cdv == null)
            //            continue;
            //        if (cdv.ok)
            //            continue;
            //        if (cdv.virtuel)
            //            continue;
            //        check(cdv.ok, cdv.type, cdv.val, cd.limit, true);
            //    }
            //}
        }

        private int getMode(bool strict, bool ok)
        {
            return 2 * Convert.ToInt32(strict) + Convert.ToInt32(ok);
        }

        private void check(bool ok, borderType type, timeSpan val, LimitItemBase limit, bool strict)
        {
            int index = (int)type;
            int mode = getMode(strict, ok);

            // virtuel nok -> 0
            // virtuel ok -> 1
            // strict nok -> 2
            //strict ok -->3

            CauseItem cause = causes[mode, index];


            if (cause == null)
            {
                causes[mode, index] = new CauseItem(type, ok, val, limit);
            }
            else
            {
                bool record = false;
                if (ok && val.Value > cause.val.Value)
                    record = true;
                else if (!ok && val.Value < cause.val.Value)
                    record = true;
                if (record)
                    causes[mode, index] = new CauseItem(type, ok, val, limit);
            }

        }

        public List<CauseItem> getCauses(bool strict, bool ok)
        {
            int mode = getMode(strict, ok);
            var list = new List<CauseItem>();
            // var causes = strict ? this.causesStrict : this.causes;
            for (int i = 0; i < NB; i++)
            {
                var cause = causes[mode, i];
                if (cause != null) // && cause.val.Value >0)
                    list.Add(cause);
            }

            return list;
        }

        public CauseItem getCause(borderType type, bool strict, bool ok)
        {
            //var causes = strict ? this.causesStrict : this.causes;
            return causes[getMode(strict, ok), (int)type];
        }

        public override string ToString()
        {
            var sb = new pdb.util.StringBuilder();
            sb.Append(candidat);
            sb.AppendLine();
            foreach (CauseItem item in causes)
            {
                if (item != null)
                    sb.AppendLine(item.ToString());
            }
            return sb.ToString();

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Auto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.util;
using pdb.podcast.Auto;
namespace pdb.podcast.Tuning
{
    class Auto
    {
        delegate void sets(string value);
        delegate void setd(double value);
        delegate void seti(int value);
        delegate void setb(bool value);

        private void buildd(XmlNode parent, XmlNode child, string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
        }

        private void buildi(XmlNode parent, XmlNode child, string name, seti seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }

        private void builds(XmlNode parent, XmlNode child, string name, sets sets)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                sets(att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                sets(att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                sets(elt.InnerText);
            elt = child[name];
            if (elt != null)
                sets(elt.InnerText);
        }

        private void buildb(XmlNode parent, XmlNode child, string name, setb setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setb("true" == elt.InnerText);
            elt = child[name];
            if (elt != null)
                setb("true" == elt.InnerText);
        }

        public string name = "";
        public borderType type = borderType.d;
        public double target;
        public double delta;
        public double write;
        public int cloop = 20;
        public int verif = 4;
        public int idem = 4;
        public int order = int.MaxValue;
        public double min = -int.MaxValue;
        public double max = int.MaxValue;
        public double coeff = 0;
        public bool selectFix;
        public bool selectAbs;
        public bool pertinentAll;
        public bool stopAll=true;
        public bool gap = false; 
        public double pente; 
        public List<Level> levels = new List<Level>();
        public List<Auto> items = new List<Auto>();

        public Auto()
        {
        }
        public Auto(Auto parent, XmlElement xparent, XmlElement node)
        {
            if (node == null)
                return;
            //if (parent != null)
            //{
            //    name = parent.name; 
            //    type = parent.type; 
            //    target = parent.target; 
            //    write = parent.write; 
            //    delta = parent.delta; 
            //    write = parent.write; 
            //    cloop = parent.cloop; 
            //    verif = parent.verif; 
            //    idem = parent.idem; 
            //    order = parent.order; 
            //    min = parent.min; 
            //    max = parent.max; 
            //    coeff = parent.coeff; 
            //    levels = new List<Level>(parent.levels); 
            //}
            XMLTool xml = new XMLTool(node);

            if (node.Attributes["type"] != null)
                type = (borderType)Enum.Parse(typeof(borderType), node.Attributes["type"].Value, true);
            builds(xparent, node, "name", (v) => name = v);
            buildd(xparent, node, "target", (v) => target = v);
            buildd(xparent, node, "delta", (v) => delta = v);
            buildd(xparent, node, "write", (v) => write = v);
            buildi(xparent, node, "cloop", (v) => cloop = v);
            buildi(xparent, node, "verif", (v) => verif = v);
            buildi(xparent, node, "verif", (v) => idem = v);
            buildi(xparent, node, "order", (v) => order = v);

            buildd(xparent, node, "min", (v) => min = v);
            buildd(xparent, node, "max", (v) => max = v);
            buildd(xparent, node, "coeff", (v) => coeff = v);
            buildb(xparent, node, "selectFix", (v) => selectFix = v);
            buildb(xparent, node, "selectAbs", (v) => selectAbs = v);
            buildb(xparent, node, "pertinentAll", (v) => pertinentAll = v);
            buildb(xparent, node, "stopAll", (v) => stopAll = v);
            buildb(xparent, node, "gap", (v) => gap = v);
            buildd(xparent, node, "pente", (v) => pente = v); 

            

            /*//  type = xml.getAttValue("type");
            //  target = xml.getDoubleAttValue("target");
             // delta = xml.getDoubleAttValue("delta");
             // write = xml.getDoubleAttValue("write");
            //  cloop = xml.getIntAttValue("cloop", 20);
            //  verif = xml.getIntAttValue("verif", 4);
             // idem = xml.getIntAttValue("idem", 4);
             // order = xml.getIntAttValue("order", int.MaxValue);
              min = xml.getDoubleAttValue("min", -int.MaxValue);
              max = xml.getDoubleAttValue("max", int.MaxValue);
              coeff = xml.getDoubleAttValue("coeff", 0);
           
              string str = "";
              if (target < 0)
              {
                  str = xml.getNodeValue("target");
                  if (!string.IsNullOrEmpty(str))
                      target = Convert.ToDouble(str);
              }
              if (delta < 0)
              {
                  str = xml.getNodeValue("delta");
                  if (!string.IsNullOrEmpty(str))
                      delta = Convert.ToDouble(str);
              }
              if (write < 0)
              {
                  str = xml.getNodeValue("write");
                  if (!string.IsNullOrEmpty(str))
                      write = Convert.ToDouble(str);
              }
              str = xml.getNodeValue("cloop");
              if (!string.IsNullOrEmpty(str))
                  cloop = Convert.ToInt16(str);
              str = xml.getNodeValue("verif");
              if (!string.IsNullOrEmpty(str))
                  verif = Convert.ToInt16(str);
              str = xml.getNodeValue("idem");
              if (!string.IsNullOrEmpty(str))
                  idem = Convert.ToInt16(str);
              str = xml.getNodeValue("order");
              if (!string.IsNullOrEmpty(str))
                  order = Convert.ToInt16(str);
              str = xml.getNodeValue("min");
              if (!string.IsNullOrEmpty(str))
                  min = Convert.ToDouble(str);
              str = xml.getNodeValue("max");
              if (!string.IsNullOrEmpty(str))
                  max = Convert.ToDouble(str);
              str = xml.getNodeValue("coeff");
              if (!string.IsNullOrEmpty(str))
                  coeff = Convert.ToDouble(str);
              levels = new List<Level>();*/

            if (parent != null)
                levels = new List<Level>(parent.levels);

            var xlevels = xml.NodeLookUp("levels");

            if (xlevels != null)
            {
                levels.Clear();
                foreach (XmlNode sub in xlevels.ChildNodes)
                {
                    if (sub is XmlElement)
                    {
                        var level = new Level(sub as XmlElement);
                        levels.Add(level);
                    }
                }
            }
            else if (levels.Count == 0)
            {
                var level = new Level(node);
                levels.Add(level);
            }
            var xitems = xml.NodeLookUp("items");
            if (xitems != null)
            {
                foreach (XmlNode sub in xitems.ChildNodes)
                {
                    if (sub is XmlElement)
                    {
                        var subAuto = new Auto(this, node, sub as XmlElement);
                        items.Add(subAuto);
                    }
                }
            }

        }
    }
    class Level
    {
        public double d;
        public double inf;
        public double sup;
        public Level()
        {
        }
        public Level(XmlElement node)
        {
            if (node == null)
                return;
            XMLTool xml = new XMLTool(node);
            d = xml.getDoubleAttValue("d");
            inf = xml.getDoubleAttValue("inf");
            sup = xml.getDoubleAttValue("sup");
            string str = xml.getAttValue("d");
            if (!string.IsNullOrEmpty(str))
                d = Convert.ToDouble(str);
            str = xml.getAttValue("inf");
            if (!string.IsNullOrEmpty(str))
                inf = Convert.ToDouble(str);
            str = xml.getAttValue("sup");
            if (!string.IsNullOrEmpty(str))
                sup = Convert.ToDouble(str);
        }
    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des donn�es consolid�es morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        /// <summary>
        /// Liste des donn�es morceux dupliqu�s 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private volatile object _lock = new object();
        private bool _consolidEnCours;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
        }

        public void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList)
        {
            try
            {
                waitForConsolid();
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                var auxlistPieceInAlbum = new List<Piece>();
                albums = new Albums(_albumSortStrict);
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        var piece = new Piece(track);
                        auxlistPieceInAlbum.Add(piece);
                        htIds.Add(piece.PieceId, piece);
                    }
                }
                // link
                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        listPieceInAlbum.Add(piece);
                        foreach (Piece child in piece.Childs)
                            listPieceInAlbum.Add(child);
                        albums.check(piece);
                    }
                }

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                        allClassed.Add(piece);
                }
                Ranking();
            }
            finally
            {
                lock (_lock)
                    _consolidEnCours = false;
            }

        }

        public void buildMusique()
        {
            foreach (Piece piece in listPieceInAlbum)
            {
                musique.addObj(piece);
            }

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.Tracks;
                tracks.Sort(new PieceTrackNumberComparer());
                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(ITrackMetaData track)
        {
            return albums.getAlbum(track);
        }

        public List<Piece> getTracksAlbum(ITrackMetaData track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.Tracks;
        }

        public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        {
            var album = getAlbum(track);
            if (album == null)
                return;
            foreach (var p in album.Tracks)
            {
                container.Add(p);
            }
        }

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPieceInAlbum);
                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking()
        {
            QRanking();
            LRanking();
            QLRanking();

            misc.log("setTuningDateValues");
            var list = new List<Piece>(listPiece);
            foreach (Piece piece in list)
            {
                piece.FirstClass = false;
                CRank rank = piece.Rank;
                var sortValue = CTuning.Calc(rank, CConf.Sort);
                rank.SortValue = sortValue;

                ListSelection.setTuningDateValues(piece);
            }

            misc.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            misc.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            misc.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);

            albums.makeSort();
            misc.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                misc.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                misc.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        misc.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                misc.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    misc.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    misc.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    misc.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    misc.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                misc.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    misc.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            misc.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            misc.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            misc.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            misc.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit� +longueur en cas d'�galit�
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            misc.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }

            if (CConf.Condensation)
            {
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();

            }

        }

        public void builStats()
        {
            try
            {
                new StatBuilder(m_listQL).gener3(step % 10 == 0);
                var unselected = m_listQL.FindAll(t => !t.Enabled);
                new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            return new DynamicStatBuilder(list).gener(className);
        }



        public void timeRanking()
        {
            misc.log("timeRanking");
            foreach (var piece in allClassed)
                ListSelection.setTuningDateValues(piece);


        }

        /// <summary>
        /// redirection des index metier de la table m�tier vers la table locale
        /// Copie des valeurs pertinentes(classlist)
        /// </summary>
        /// <remarks></remarks>
        public void eraseGrouping()
        {
            thCommentGo = false;
            thGroupingGo = false;
            misc.log("eraseGrouping");
            foreach (Piece piece in listPieceInAlbum)
            {
                piece.setGrouping("", false);
                piece.Comment = "";
            }
        }
        public void writeGrouping()
        {
            misc.log("writeGrouping");
            var list = new List<Piece>(listPieceInAlbum);
            // list.Sort(new CPieceComparerByQualityAndLength());
            list.Sort(new AllPieceComparer2());

            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }


        private bool thGroupingGo;
        private bool thCommentGo;

        public bool GroupinGO
        {
            set
            {
                thGroupingGo = value;
                if (value)
                {
                }
            }
        }
        public bool CommentGo
        {
            set
            {
                thCommentGo = value;
                if (value)
                {
                }
            }
        }



        private void writeGroupingAsync()
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in listPieceInAlbum)
            {
                try
                {
                    if (!thGroupingGo)
                        return;
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }

        private void writeCommentAsync()
        {
            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in listPiece)
            {
                try
                {
                    if (!thCommentGo)
                        return;
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }
        }

        public void writeGrouping(Piece piece)
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            piece.writeGrouping(writeGrouping);

        }
        private bool _sortByAlbum = true;
        public bool SortByAlbum { set { _sortByAlbum = value; } }

        private bool _albumSortStrict = CConf.ConfGen.AlbumSortStrict;
        public bool SortAlbumStrict { set { _albumSortStrict = value; } get { return _albumSortStrict; } }

        public void writeComment()
        {
            misc.log("writeComment");
            var list = new List<Piece>(listPiece);
            list.Sort(new CPieceComparerByQualityAndLength());

            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }




        }

        public void writeComment(Piece piece)
        {
            var writeComment = CConf.ConfGen.WriteComment;
            try
            {
                piece.writeComment(writeComment);
            }
            catch (Exception ex)
            {
                misc.log("writeComment::" + ex.ToString());
            }
        }



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            var conf = CConf.ConfGen;

            misc.log("Clegacy:createRot {0}", a_baseName);
            List<Piece> l_list = new List<Piece>();
            List<Piece> source = null;
            if (_sortByAlbum)
                source = allClassed;
            else
                source = m_listTrackClassed;
            foreach (Piece l_piece in source)
            {
                //if (l_piece.belongsTo(a_baseName))
                //{
                l_list.Add(l_piece);
                // }
            }
            m_listWriter = new CLegacyListWriter(l_list, _sortByAlbum);

            l_list = new List<Piece>();
            foreach (Piece piece in listPieceInAlbum)
                l_list.Add(piece);

            listWriterAll = new CLegacyListWriter(l_list, _sortByAlbum);


            foreach (IListWriter writer in writers)
                m_listWriter.addWriter(writer);

            foreach (IListWriter writer in writers)
                listWriterAll.addWriter(writer);

            //      m_listWriter.reset();
            foreach (var duration in conf.Listes)
            {


                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(mode, duration, "g", false);
                    m_listWriter.writeGen(mode, duration, "e", true);
                }
            }

            if (conf.GenCheck)
                m_listWriter.writeCheckClassement(0);

            for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
            {
                m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
            }


            foreach (var duration in conf.Listes)
            {

                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(albums, mode, duration, "g", false);
                }
            }

            listWriterAll.writeGen(albums, null, null, "all", false);

            return;

            writeRot(1);

            m_listWriter.writeCheckClassement(1);

            m_listWriter.reset();
            writeRotMin(-1);
            writeRotMin(10);
            writeRotMin(1);
        }
        private void writeRotMin(int a_nbHour)
        {
            misc.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumComparer.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using System;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    class AlbumClassComparer : IComparer<Album>
    {
        private bool albumSortStrict;
        public AlbumClassComparer(bool albumSortStrict)
        {
            this.albumSortStrict = albumSortStrict; 
        }
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            //if (x.Name == "Alien Lanes" || y.Name == "Alien Lanes")
            //{
            //    int toto = 0; 
            //}
            //si classement == 0 mais que l'autre est tellement nul que m�me ma moyenne est sup�rieure � sa moyenne
            int cmp = 0;
            if (!albumSortStrict)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
                    if (cmp != 0)
                        return cmp;
                }
            }


            cmp = x.ClassementValue.CompareTo(y.ClassementValue);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            if (cmp != 0)
                return cmp;

            int i = 0;
            var t1 = -2m;
            var t2 = -2m;
            while (true)
            {
                t1 = x.getTrackSortValue(i);
                t2 = y.getTrackSortValue(i);

                cmp = t1.CompareTo(t2);
                if (cmp != 0)
                    return cmp;



                if (t1 == 0)
                    break; 
                    
                i++;

            }
            cmp = x.DurationValue.CompareTo(y.DurationValue);
            if (cmp != 0)
                return cmp; 
            return -x.Name.CompareTo(y.Name); 

        }
    }

    class AlbumClassComparer2 : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            return x.Rank.Sort.CompareTo(y.Rank.Sort); 
        }
    }


    class AlbumSortComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;

            if (x.Rank.SortValue == 0)
            {

            }

            var xx = x.getFirstTrackSortValue();
            var yy = y.getFirstTrackSortValue();

            return xx.CompareTo(yy);

        }
    }

    class AlbumRestComparer : IComparer<Album>
    {
        static AlbumSortComparer subCmp = new AlbumSortComparer();
        const decimal EPSILON = 0.00001m;
        public int Compare(Album x, Album y)
        {
            var xx = x.Rank.TimeRest;
            var yy = y.Rank.TimeRest;
            int cmp = 0;
            if (Math.Abs(xx - yy) >= EPSILON)
                cmp = xx.CompareTo(yy);
            if (cmp == 0)
                return subCmp.Compare(x, y);
            return cmp;
        }
    }

    class PieceInAlbumComparer : IComparer<Piece>
    {
        private bool debile(int trackNumber)
        {
            return trackNumber <= 0 || trackNumber > 100;
        }

        private bool debile(Piece piece)
        {
            return debile(piece.TrackNumber);
        }
        public int Compare(Piece x, Piece y)
        {
            if (debile(x))
            {
                if (debile(y))
                {
                    var f1 = Path.GetFileName(x.Location);
                    var f2 = Path.GetFileName(y.Location);
                    return f1.CompareTo(f2);
                }
                return -1;
            }
            if (debile(y))
                return 1;
            return x.TrackNumber.CompareTo(y.TrackNumber);
        }
    }

    class AllPieceComparer : IComparer<Piece>
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public int Compare(Piece x, Piece y)
        {
            int cmp = albumcomp.Compare(x.PieceAlbum, y.PieceAlbum);
            if (cmp != 0)
                return cmp;
            return -pieceComp.Compare(x, y);
        }
    }

    class AllPieceComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.RankAllAlbum.CompareTo(y.RankAllAlbum); 
        }
    }

    class AlbumNameComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            return x.Name.CompareTo(y.Name); 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;

namespace pdb.gen.albums
{
    class Albums
    {
        public Albums(bool sortStrict)
        {
            this._sortStrict = sortStrict; 
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private bool _sortStrict; 
        private void check_(Piece piece)
        {
            string __album = "-"; 
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                var album = dict[__album];
                if (album == null)
                {
                    album = new Album(__album);
                    dict.Add(__album, album); 
                }
                album.add(piece);
               
            }
          

        }

        public void check(Piece piece)
        {
            check_(piece);
            foreach (Piece child in piece.Childs)
                check_(child); 
        }

        public Album getAlbum(ITrackMetaData piece)
        {
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null; 
        }

        public void makeSort()
        {
            var listRef = new List<double>();
            //foreach (Piece piece in reference)
            //    listRef.Add(piece.RapportClassement); // piece.Rank.SortValue); 
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(_sortStrict));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
        }

        public List<Album> makeSelection()
        {
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list; 
        }


        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list; 
            }
        }


      
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfGen.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.gen.conf;
using pdb.util;
using System.Collections.Generic;

namespace pdb.gen.Tuning
{
    public enum writeGrouping
    {
        none = 0,
        selected = 1,
        mix = 2,
        all = 3,

    }

    public enum datesMode
    {
        play = 1,
        @class = 2,
        classMin = 3,
        mix = 4,
        mixMin = 5

    }

    public class ExtendToNative<T>
    {
        public readonly T item;
        public readonly bool extend;
        public readonly bool extendTimeOrder;
        public readonly bool level;

        public ExtendToNative(T item, bool extend, bool extendTimeOrder, bool level)
        {
            this.item = item;
            this.extend = extend;
            this.extendTimeOrder = extendTimeOrder;
            this.level = level;
        }

        public override string ToString()
        {
            return item.ToString();
        }
    }
    public class ConfGen
    {

        private CConfQL confCourbe = new CConfQL();

        private TimeSpan vie = TimeSpan.FromDays(365);
        datesMode dates;
        private List<ExtendToNative<double>> listes = new List<ExtendToNative<double>>();
        private decimal exp = 1;
        private bool withOrder;
        private bool orderZero;
        private bool orderLarge;
        private bool genE;
        private bool genLarge;
        private bool writeGroupingZero;
        private bool genCheck;
        bool albumOrdo;
        bool onlyEnabled;
        /// <summary>
        /// Simuler la conso du premier élément
        /// </summary>
        private bool anticipation;

        //private double equivDelta = 0.00001;
        //private int equivStep = 100000; 
        private writeGrouping writeGrouping = writeGrouping.selected;
        private writeGrouping writeComment = writeGrouping.all;

        private GroupingDisplay groupingDisplay = new GroupingDisplay(null);

        private DateTime minPlayDate = DateTime.MinValue;
        private DateTime minClassDate = DateTime.MinValue;
        private int offsetPlayDate = 0;
        private int offsetClassDate = 0;
        private int offsetClassMin = 1;
        private int listLimit = int.MaxValue;
        private int listReaderAfter = 0;
        private int listReaderBefore = 0;
        private decimal medianne = 0.5m;
        private decimal albumMoyOffset = 0m;

        private List<ExtendToNative<datesMode>> cat = new List<ExtendToNative<datesMode>>();
        private ExtendToNative<int> precisionMin = new ExtendToNative<int>(-1, false, false, false);
        private ExtendToNative<int> precisionMax = new ExtendToNative<int>(-1, false, false, false);

        private bool albumSortStrict = true;

        public ConfGen()
        {
        }
        public ConfGen(XmlElement a_xml)
        {
            if (a_xml == null)
                return;
            XMLTool l_xml = new XMLTool(a_xml);
            XmlElement xmlQuality = l_xml.NodeLookUp("courbe");

            confCourbe = new CConfQL(xmlQuality);

            var str = l_xml.getNodeValue("dates");
            if (!string.IsNullOrEmpty(str))
                dates = (datesMode)Enum.Parse(typeof(datesMode), str, true);
            var xTime = l_xml.NodeLookUp("time");
            if (xTime != null)
            {
                var _xtime = new XMLTool(xTime);
                string l_str = _xtime.getNodeValue("vie").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    vie = TimeSpan.FromDays(Convert.ToDouble(l_str));

                l_str = _xtime.getNodeValue("exp").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    exp = Convert.ToDecimal(l_str);
            }

            var xLists = l_xml.NodeLookUp("lists");
            if (xLists != null)
            {
                foreach (XmlNode xList in xLists.ChildNodes)
                {
                    if (xList is XmlElement)
                    {

                        double iList = Convert.ToDouble(xList.InnerText);
                        bool extend = false;
                        var att = xList.Attributes["nat"];
                        if (att != null && att.Value == "true")
                            extend = true;

                        bool extendtimeOrder = false;
                        att = xList.Attributes["timeOrder"];
                        if (att != null && att.Value == "true")
                            extendtimeOrder = true;

                        bool _level = false;
                        att = xList.Attributes["level"];
                        if (att != null && att.Value == "true")
                            _level = true;

                        ExtendToNative<double> e = new ExtendToNative<double>(iList, extend, extendtimeOrder, _level);
                        listes.Add(e);
                    }
                }
            }

            str = l_xml.getNodeValue("writeGrouping");
            if (!string.IsNullOrEmpty(str))
                writeGrouping = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("writeComment");
            if (!string.IsNullOrEmpty(str))
                writeComment = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("equivDelta");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.coeffDelta = Convert.ToDecimal(str);

            str = l_xml.getNodeValue("equivStep");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.MAX_STEP = Convert.ToInt32(str);

            var l_display = l_xml.NodeLookUp("display");
            groupingDisplay = new GroupingDisplay(l_display);

            withOrder = l_xml.getBoolValue("withOrder");
            orderLarge = l_xml.getBoolValue("orderLarge");
            orderZero = l_xml.getBoolValue("orderZero");
            genE = l_xml.getBoolValue("genE");
            genLarge = l_xml.getBoolValue("genLarge");
            writeGroupingZero = l_xml.getBoolValue("writeGroupingZero");
            genCheck = l_xml.getBoolValue("genCheck");
            anticipation = l_xml.getBoolValue("anticipation");
            albumOrdo = l_xml.getBoolValue("albumOrdo");
            onlyEnabled = l_xml.getBoolValue("onlyEnabled");
            albumSortStrict = l_xml.getBoolValue("albumSortStrict", albumSortStrict);

            str = l_xml.getNodeValue("minPlayDate");
            if (!string.IsNullOrEmpty(str))
                minPlayDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("minClassDate");
            if (!string.IsNullOrEmpty(str))
                minClassDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("offsetPlayDate");
            if (!string.IsNullOrEmpty(str))
                offsetPlayDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassDate");
            if (!string.IsNullOrEmpty(str))
                offsetClassDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassMin");
            if (!string.IsNullOrEmpty(str))
                offsetClassMin = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listLimit");
            if (!string.IsNullOrEmpty(str))
                listLimit = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderAfter");
            if (!string.IsNullOrEmpty(str))
                listReaderAfter = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderBefore");
            if (!string.IsNullOrEmpty(str))
                listReaderBefore = Convert.ToInt32(str);

            str = l_xml.getNodeValue("medianne");
            if (!string.IsNullOrEmpty(str))
                medianne = Convert.ToDecimal(str);


            str = l_xml.getNodeValue("albumMoyOffset");
            if (!string.IsNullOrEmpty(str))
                albumMoyOffset = Convert.ToDecimal(str);



            var xDir = l_xml.NodeLookUp("dir");
            if (xDir != null)
            {
                foreach (XmlNode xSub in xDir.ChildNodes)
                {
                    if (xSub is XmlElement)
                    {
                        if (xSub.Name == "precision")
                        {
                            var _precisionMin = Convert.ToInt32(xSub.Attributes["min"].Value);
                            bool _extend = false;

                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                _extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;
                            var _precisionMax = Convert.ToInt32(xSub.Attributes["max"].Value);

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;


                            precisionMin = new ExtendToNative<int>(_precisionMin, _extend, _extendtimeOrder, _level);
                            precisionMax = new ExtendToNative<int>(_precisionMax, _extend, _extendtimeOrder, _level);
                        }
                        else
                        {
                            datesMode item = (datesMode)(Enum.Parse(typeof(datesMode), xSub.Name, true));
                            bool extend = false;
                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;

                            cat.Add(new ExtendToNative<datesMode>(item, extend, _extendtimeOrder, _level));

                        }
                    }

                }
            }

        }

        public CConfQL Courbe { get { return confCourbe; } }

        public decimal Exp { get { return exp; } }
        public TimeSpan Vie { get { return vie; } }
        public datesMode Dates { get { return dates; } }
        public IEnumerable<ExtendToNative<double>> Listes { get { return listes; } }

        public writeGrouping WriteGrouping { get { return writeGrouping; } }
        public writeGrouping WriteComment { get { return writeComment; } }

        //  public GroupingDisplay Display { get { return groupingDisplay; } }
        public timeMode TimeMode { get { return groupingDisplay.TimeMode; } }
        public List<DisplayGrouping> DisplayCategories
        {
            get
            {
                var list = groupingDisplay.Categories;
                var found = list.Find(c => c.category == displayCategory.timeValue);

                int indexCurrentTimeValue = -1; //list.IndexOf(displayCategory.timeValue);
                if (found != null)
                    indexCurrentTimeValue = list.IndexOf(found);
                if (indexCurrentTimeValue >= 0)
                {
                    list[indexCurrentTimeValue].category = (displayCategory)dates;
                }

                return list;
            }
        }
        public bool WithOrder { get { return withOrder; } }
        public bool OrderLarge { get { return orderLarge; } }
        public bool OrderZero { get { return orderZero; } }
        public bool GenE { get { return genE; } }
        public bool GenLarge { get { return genLarge; } }
        public bool GenCheck { get { return genCheck; } }
        public bool Anticipation { get { return anticipation; } }
        public bool WriteGroupingZero { get { return writeGroupingZero; } }
        public bool AlbumOrdo { get { return albumOrdo; } }
        public bool OnlyEnabled { get { return onlyEnabled; } }


        public DateTime MinPlayDate { get { return minPlayDate; } }
        public DateTime MinClassDate { get { return minClassDate; } }

        public int OffsetPlayDate { get { return offsetPlayDate; } }
        public int OffsetClassDate { get { return offsetClassDate; } }
        public int OffsetClassMin { get { return offsetClassMin; } }
        public override string ToString()
        {
            return string.Format(" vie:{0} exp:{1} quality:{2} onlyPlayed:{3} writeGrouping:{4} display:{5}", vie, exp, confCourbe, dates, writeGrouping, groupingDisplay);
        }

        public List<ExtendToNative<datesMode>> Modes { get { return cat; } }
        public ExtendToNative<int> PrecisionMin { get { return precisionMin; } }
        public ExtendToNative<int> PrecisionMax { get { return precisionMax; } }
        public int ListLimit { get { return listLimit; } }
        public int ListReaderAfter { get { return listReaderAfter; } }
        public int ListReaderBefore { get { return listReaderBefore; } }
        public decimal Medianne { get { return medianne; } }
        public decimal AlbumMoyOffset { get { return albumMoyOffset; } }
        public bool AlbumSortStrict { get { return albumSortStrict; } } //set { albumSortStrict = value; } }
    }
}
]]></content>
  </file>
</db>
