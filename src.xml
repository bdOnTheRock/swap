<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.podcast\Exporter.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.podcast.Tuning;
using pdb.util;

namespace pdb.podcast
{
    class Exporter
    {
        enum state
        {
            none,
            record,
            copy,
            abort,
            end

        }
        private Exporter()
        {
        }
        static Exporter Instance = new Exporter();
        private volatile object _lock = new object();
        BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        private state status;

        DirectoryInfo dirDest = null;
        string dirDestPath = "";
        public const string PODCASTS = "podcasts";
        public const string ZIQUE = "zique";
        const string EXPORTE = @"..\exporte.txt";

        public static void TopRecord() { Instance.topRecord(); }
        public static void TopCopy() { Instance.topCopy(); }
        public static void Record(TrackInfoItunes track) { Instance.record(track); }
        public static void Abort() { Instance.abort(); }
        // public static void RecordTracks(IEnumerable<TrackInfoItunes> list, ITextWriter sb) { Instance.recordTracks(list, sb); }


        //void recordTracks(IEnumerable<TrackInfoItunes> list, ITextWriter sb)
        //{
        //    foreach (TrackInfoItunes t in list)
        //        sb.AppendLine(getShortPath(t.Location)); 
        //}

        private string getShortPath(string loc)
        {
            return loc.getShortPath(PODCASTS, ZIQUE);
        }

        void abort()
        {
            lock (_lock)
            {
                if (status != state.none && status != state.end)
                    status = state.abort;
            }
            while (status == state.abort)
            {
                Thread.Sleep(30);
                if (status == state.abort)
                {
                    lock (_lock)
                    {
                        if (status != state.abort)
                            return;
                    }
                }
            }
        }

        void topRecord()
        {
            lock (_lock)
            {
                var conf = Conf.Export;
                if (!conf.enabled)
                {
                    if (status < state.end)
                        status = state.none;
                    return;
                }
                var dest = Conf.Export.dir;
                if (string.IsNullOrEmpty(dest))
                {
                    status = state.end;
                    return;
                }
                try
                {
                    this.dirDest = new DirectoryInfo(dest);
                }
                catch
                {
                    status = state.end;
                    return;
                }

                if (!dirDest.Exists)
                {
                    status = state.end;
                    return;
                }
                this.dirDestPath = dirDest.FullName;
                if (!dirDestPath.EndsWith("\\"))
                    dirDestPath += Path.DirectorySeparatorChar;
                if (status == state.none)
                {
                    dict = new BgDictString<TrackInfoItunes>();
                    status = state.record;
                }
            }
        }

        void record(TrackInfoItunes track)
        {
            if (status != state.record)
                return;
            dict[track.Location] = track;
        }
        void topCopy()
        {
            lock (_lock)
            {
                if (status != state.record)
                    return;
                status = state.copy;
                list = new List<TrackInfoItunes>(dict.Values);
                list.Sort(new PodCastComparerPub2());
                new Thread(loop).Start();
            }

        }

        //private void checkDir(BgDictString<bool> dict, DirectoryInfo dir)
        //{
        //    if (status != state.copy)
        //        return;
        //    foreach (FileInfo f in dir.GetFiles())
        //    {
        //        if (status != state.copy)
        //            return;
        //        dict.Add(f.FullName.getShortPath(PODCASTS, ZIQUE), false);
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //    {
        //        if (status != state.copy)
        //            return;
        //        checkDir(dict, sub);
        //    }
        //}

        private void loop()
        {
            int i = 0;
            int count = list.Count;
            try
            {
                var d = new BgDictString<bool>();
                //checkDir(d, dirDest);

                //foreach (TrackInfoItunes t0 in list)
                //{
                //    if (status != state.copy)
                //        return;
                //    var shortPath = t0.Location.getShortPath(PODCASTS, ZIQUE);
                //    d[shortPath] = true;
                //}

                var refeDistant = Conf.Export.fIn;
                if (File.Exists(refeDistant))
                {
                    foreach (string line in File.ReadAllLines(refeDistant))
                    {
                        if (string.IsNullOrEmpty(line))
                            continue;
                        d[line] = true;
                    }
                }

                //foreach (KeyValuePair<string, bool> kvp in d.getKeyValuePairs())
                //{
                //    if (status != state.copy)
                //        return;
                //    if (!kvp.Value)
                //    {
                //        string fdest = dirDestPath + kvp.Key;
                //        misc.log("suppression de {0}", fdest);
                //        File.Delete(fdest);
                //    }
                //}
                while (i < count && status == state.copy)
                {
                    try
                    {
                        TrackInfoItunes t = list[i];
                        FileInfo f = new FileInfo(t.Location);
                        var shortPath = getShortPath(f.FullName); //(  f.FullName.getShortPath(PODCASTS, ZIQUE);

                        if (!d[t.DbId.ToString()])
                        {
                            string fdest = dirDestPath + shortPath;
                            if (!File.Exists(fdest))
                            {
                                misc.log("copie de {0}", t);

                                f.copyTree(fdest, null);
                                File.AppendAllText(refeDistant, t.DbId.ToString() + "\r\n");
                            }
                        }

                        i++;
                    }
                    catch (System.IO.IOException ioe)
                    {
                        misc.log(ioe.ToString());
                        if (ioe.Message.Contains("space"))
                        {
                            lock (_lock)
                                status = state.end;
                        }
                    }

                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }

                }
            }

            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
            finally
            {
                lock (_lock)
                {
                    if (status != state.end)
                        status = state.none;
                }
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Feed.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.util;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using Math = System.Math;

namespace pdb.podcast
{
    /// <summary>
    /// Un flux podcast (Un album)
    /// </summary>
    public class Feed
    {
        /// <summary>
        /// Liste des morceaux d'un album de podcasts
        /// </summary>
        private List<TrackInfoItunes> tracks = new List<TrackInfoItunes>();

        /// <summary>
        /// Nom de l'album
        /// </summary>
        private string name;

        /// <summary>
        /// Album de type info
        /// </summary>
        private bool info;
        public bool Info { get { return info; } }

        /// <summary>
        /// Album rare
        /// </summary>
        private bool rare;
        public bool Rare { get { return rare; } }
        public Feed(string name)
        {
            this.name = name;
        }

        public string Name { get { return name; } }
        public int Count { get { return tracks.Count; } }

        /// <summary>
        /// D�finition du plus r�cent
        /// </summary>
        /// <param name="otrack"></param>
        public bool check(TrackInfoItunes otrack)
        {
            //if (otrack.Pub.DayOfYear !=1)
            //{
            //var found tracks.Find(t=>t.Pub == otrack.Pub))
            //{
            //}
            //}
            info = otrack.Info;
            rare = otrack.Rare;
            tracks.Add(otrack);
            return true;
        }




        public List<TrackInfoItunes> Tracks
        {
            get
            {
                var list = new List<TrackInfoItunes>(tracks);
                return list;
            }
        }


        //public ICollection<TrackInfoItunes> getTracks(int level, int nbMax, float feedDuration, bool histo)
        //{
        //    TimeSpan currentDuration = new TimeSpan();
        //    var DurationMax = TimeSpan.FromMinutes(feedDuration);
        //    int rating = level * 20;
        //    if (histo)
        //        tracks.Sort(new PodCastComparer());
        //    else
        //        tracks.Sort(new PodCastComparerInv());
        //    int count = tracks.Count;

        //    List<TrackInfoItunes> aux = new List<TrackInfoItunes>();
        //    int nb = 0;
        //    for (int i = 0; i < count; i++)
        //    {
        //        var track = tracks[i];
        //        if (track.Rating >= rating)
        //        {
        //            var auxD = currentDuration;
        //            currentDuration += track.Duration;
        //            if (currentDuration > DurationMax)
        //            {
        //                misc.log("{0} level:{1} nbMax:{2} feedDuration:{3} histo:{4} duration:{5}  -->  stop duration {6}", this, level, nbMax, feedDuration, histo, auxD.TotalMinutes.ToString("0"), feedDuration);
        //                break;
        //            }
        //            aux.Add(track);
        //            nb++;
        //            if (nb >= nbMax)
        //            {
        //                //  misc.log("{0} level:{1} nbMax:{2} feedDuration:{3} histo:{4} duration{5}   -->  stop nb {6}", this, level, nbMax, feedDuration, histo, currentDuration.TotalMinutes.ToString("0"), nb); 
        //                break;
        //            }
        //        }
        //    }


        //    return aux;
        //}

        public List<TrackInfoItunes> getSelectedTracks
        {
            get
            {
                var list = tracks.FindAll(t => t.Selected);
                list.Sort(new PodCastComparerPub2());
                return list;

            }
        }

        //public List<TrackInfoItunes> getPreSelectedTracks
        //{
        //    get
        //    {
        //        var list = tracks.FindAll(t => t.isPreselected); // Providers1.Count > 0);
        //        list.Sort(new PodCastComparer());
        //        return list;

        //    }
        //}

        public List<TrackInfoItunes> getSelectedTracksLevel(int level)
        {
            int rating = level * 20;

            var list = tracks.FindAll(t => t.Selected && t.Rating == rating);
            list.Sort(new PodCastComparerPub2());
            return list;

        }

        public void buildLastSelectedTrack(List<TrackInfoItunes> depot)
        {
            var list = tracks.FindAll(t => t.Selected);
            if (list.Count > 0)
            {
                list.Sort(new PodCastComparerInv());
                var t = list[0];
                if (!depot.Contains(t))
                    depot.Add(t);
            }

        }

        /// <summary>
        /// Ajout les tracks pour le jour j du journal
        /// </summary>
        /// <param name="depot"></param>
        /// <param name="journal"></param>
        internal void getSelecTrackJournal(List<TrackInfoItunes> depot, Journal journal)
        {
            var list = tracks.FindAll(t => t.FreeInJournal);
            list.Sort(new PodCastComparerPub2());
            timeSpan totalDurationMax = timeSpan.FromMinutes(journal.FeedDuration);
            timeSpan duration = new timeSpan();

            int nbMax = journal.Nb;
            int nb = 0;

            foreach (TrackInfoItunes track in list)
            {
                depot.Add(track);
                nb++;
                if (nb >= nbMax)
                    return;
                duration += track.Duree;
                if (duration >= totalDurationMax)
                    return;
            }
        }

        // const int SEMAINE = 7;
        private void getSelectedTrack(List<TrackInfoItunes> depot, List<TrackInfoItunes> list, IComparer<TrackInfoItunes> comparer, SelectParam param)
        {

            if (list == null)
                list = tracks.FindAll(t => t.Selected);
            if (list.Count > 0)
            {
                list.Sort(comparer);

                var selector = new TrackSelector(param);

                foreach (TrackInfoItunes track in list)
                {
                    bool check = selector.select(track);

                    if (check && !depot.Contains(track))
                        depot.Add(track);
                }

            }   
        }

        public void buildFirstSelectedTrackLevel(List<TrackInfoItunes> depot, SelectParam param)
        {
            IComparer<TrackInfoItunes> comparer = null;

            int rating = 20 * param.level;

            var list = tracks.FindAll(t => t.Selected && t.Rating >= rating);
            if (list.Count == 0)
                return;

            if (param.dateCroissante)
                comparer = new PodCastComparerPub2();
            else
                comparer = new PodCastComparerInv();

            getSelectedTrack(depot, list, comparer, param);

        }

        public void buildFirstSelectedTrack(List<TrackInfoItunes> depot, SelectParam param)
        {
            IComparer<TrackInfoItunes> comparer = null;

            if (param.dateCroissante)
                comparer = new FeedPodCastComparerHisto();
            else
                comparer = new FeedPodCastComparer();

            getSelectedTrack(depot, null, comparer, param);

        }

        public override string ToString()
        {
            return name + " " + tracks.Count;
        }

        //  private ITextWriter sb = new StringBuilder();

        private Stat stats = new Stat();
        public void recordTrack(TrackInfoItunes track, LimitItem provider)
        {
            stats.recordTrack(track);
            //sb.Append(provider.Dir.getPath());
            //sb.Append(" ");
            //sb.Append(provider.ToString());
            //sb.Append(" ");
            //sb.Append(track);

            //  sb.AppendLine();
        }

        public void rapport(ITextWriter sb)
        {
            sb.AppendLine();
            sb.AppendLine("feed -------------");
            sb.AppendLine(name);
            stats.rapport(sb);


            foreach (TrackInfoItunes track in getSelectedTracks) //  getPreSelectedTracks)
            {
                sb.AppendLine();
                sb.AppendLine(track.ToString());
                //sb.AppendLine("pre-selection");
                //foreach (LimitItem provider in track.Providers1)
                //{
                //    sb.Append("\t");
                //    //sb.Append(provider.Dir.getPath());
                //    //sb.Append(" ");
                //    sb.AppendLine(provider.ToString());
                //}

                //sb.AppendLine("selection");
                foreach (LimitItem provider in track.Providers)
                {
                    sb.Append("\t");
                    //sb.Append(provider.Dir.getPath());
                    //sb.Append(" ");
                    sb.AppendLine(provider.ToString());
                }
            }
        }


    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Feeds.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Report;

namespace pdb.podcast
{
    /// <summary>
    /// ensemble des albums de podcast
    /// </summary>
    public class Feeds : IEnumerable<Feed>
    {
        private Dictionary<string, Feed> dict = new Dictionary<string, Feed>();
        private IDictionary<string, TrackInfoItunes> loaded = new BgDictString0<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        // private SequentialDictString<TrackInfoItunes> preSelected = new SequentialDictString<TrackInfoItunes>();
        private Stat stat = new Stat();

        private bool ignoretrackDisabled = true;
        private bool ignoreTrackRead = true;
        private bool checkExist = true;
        public Feeds()
        {
            ignoretrackDisabled = Conf.OnlyEnabled;
            ignoreTrackRead = Conf.OnlyUnRead;
            checkExist = Conf.CheckExist;

        }
        private static Feeds _instance = new Feeds();

        //public static Feeds Instance { get { return _instance; } }
        //public static Feeds createInstance()
        //{
        //    _instance = new Feeds();          
        //    return _instance;
        //}
        public IDictionary<string, TrackInfoItunes> LoadedTracks { get { return loaded; } }
        public void check(TrackInfoItunes track)
        {

            if (!track.Enabled && ignoretrackDisabled) return;
            if (track.Played && ignoreTrackRead) return;
            if (checkExist && !FileRegister.Exist(track.Location)) return;
            checkAll(track);
        }

        public void check(string album)
        {
            string key = album;
            if (!dict.ContainsKey(key))
            {
                Feed feed = new Feed(key);
                dict.Add(key, feed);
            }

        }

        public bool checkAll(TrackInfoItunes track)
        {

           // string album = track.Album;
            //  string _feed = track.Feed;

            string key = track.AlbumKey;
            //if (!string.IsNullOrEmpty(_feed))
            //    key = _feed;
            if (string.IsNullOrEmpty(key))
            {
                misc.log("pas d'album pour " + track);
                return false;
            }

            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return false;

            if (loaded.ContainsKey(location))
                return false;

            stat.recordTrack(track);

            loaded.Add(location, track);

            if (!dict.ContainsKey(key))
            {
                Feed feed = new Feed(key);
                dict.Add(key, feed);
            }
            return dict[key].check(track);
        }
        private List<TrackInfoItunes> _loaded;
        public List<TrackInfoItunes> Loaded
        {
            get
            {
                if (_loaded == null)
                    _loaded = new List<TrackInfoItunes>(loaded.Values);
                return _loaded;
            }
        }
        public Stat Stat { get { return stat; } }
        public List<Feed> List { get { return new List<Feed>(dict.Values); } }
        //public List<TrackInfoItunes> ListTracks {
        //    get
        //    {
        //        var list = new List<TrackInfoItunes>(dict.Count);
        //        foreach (var feed in dict.Values)
        //        {
        //            list.AddRange(feed.TracksForMulti); 
        //        }
        //        list.Sort(new PodCastComparerInv()); 
        //        return list; 
        //    }

        //}

        //public List<TrackInfoItunes> ListTrackSingle
        //{
        //    get
        //    {
        //        var list = new List<TrackInfoItunes>(dict.Count);
        //        foreach (var feed in dict.Values)
        //        {
        //            list.Add(feed.Track);
        //        }
        //        list.Sort(new PodCastComparerInv()); 
        //        return list;
        //    }

        //}

        //public List<TrackInfoItunes> getLastTracks(int levelMin, int duration, bool? info, bool? rare, int nbMaxByFeed)
        //{
        //    return getTracks(levelMin, duration, info, rare, nbMaxByFeed, false); 
        //    //TimeSpan currentDuration = new TimeSpan();
        //    //var DurationMax = TimeSpan.FromMinutes(duration); 
        //    //int ratingMin = levelMin*20; 
        //    //var aux = new List<TrackInfoItunes>();
        //    //foreach (var feed in dict.Values)
        //    //{
        //    //   aux.AddRange(feed.getLastTracks(nbMaxByFeed,levelMin)); 
        //    //}
        //    //aux.Sort(new PodCastComparerInv());

        //    //var list = new List<TrackInfoItunes>();


        //    //foreach (TrackInfoItunes candidat in aux)
        //    //{
        //    //    if (candidat.Rating < ratingMin) continue;
        //    //    if (info.HasValue)
        //    //    {
        //    //        bool bInfo = info.Value;
        //    //        if (candidat.Info != bInfo) continue; 
        //    //    }

        //    //    if (rare.HasValue)
        //    //    {
        //    //        bool bRare = rare.Value;
        //    //        if (candidat.Rare != bRare) continue; 
        //    //    }


        //    //    if (currentDuration + candidat.Duration > DurationMax)
        //    //        continue;
        //    //    currentDuration += candidat.Duration;
        //    //    list.Add(candidat);
        //    //    candidat.Selected = true; 

        //    //}

        //    //return list; 
        //}


        //public List<TrackInfoItunes> getTracks(Limit limit, DirConf dir, DescBuilder sbDir)
        //{
        //    var aux = new List<TrackInfoItunes>();

        //    foreach (LimitItem item in limit.Items)
        //    {
        //        aux.AddRange(getTracks(item, dir, sbDir)); 
        //    }
        //    return aux; 

        // //   TimeSpan currentDuration = new TimeSpan();
        // // //  int duration = limit.Duration;
        // //   var DurationMax = TimeSpan.FromMinutes(duration);
        // //   int levelMin = limit.Level;
        // //   int ratingMin = levelMin * 20;


        // //   string feedName = null;
        // //   bool histo = dir.Histo;
        // //   bool? histoAll = dir.HistoAll; 
        // //   if (histo)
        // //       feedName = dir.Name;

        // //   if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
        // //       return aux; 

        // //   foreach (var feed in dict.Values)
        // //   {
        // //       if (true.Equals(histoAll) || !histo || (histo && false.Equals(histoAll) && feed.Name.Equals(feedName)))             
        // //           aux.AddRange(feed.getTracks(limit, dir)); 
        // //   }
        // //   if (histo)
        // //       aux.Sort(new PodCastComparer());
        // //   else
        // //       aux.Sort(new PodCastComparerInv());

        // //   var list = new List<TrackInfoItunes>();

        // //   bool? info = dir.Info;
        // //   bool? rare = dir.Rare;

        // //   bool durationLimitAtteinte = false; 


        // //   foreach (TrackInfoItunes candidat in aux)
        // //   {
        // //       if (candidat.Rating < ratingMin) 
        // //           continue;
        // //       if (info.HasValue)
        // //       {
        // //           bool bInfo = info.Value;
        // //           if (candidat.Info != bInfo)
        // //               continue;
        // //       }

        // //       if (rare.HasValue)
        // //       {
        // //           bool bRare = rare.Value;
        // //           if (candidat.Rare != bRare) 
        // //               continue;
        // //       }


        // //       if (currentDuration + candidat.Duration > DurationMax)
        // //       {
        // //           durationLimitAtteinte = true; 
        // //           continue;
        // //       }
        // //       currentDuration += candidat.Duration;
        // //       list.Add(candidat);
        // //       candidat.Selected = true;

        // //   }
        // //   //limit.Append(dir.ToString()); 
        // //   //limit.Append(" "); 
        // //   if (durationLimitAtteinte)
        // //   {
        // //       limit.Append(">>> ");
        // //       //limit.Append(limit.Duration); 
        // //   }

        // //   limit.Append(list.Count); 
        // //   limit.Append(" elts "); 
        // //   limit.Append(currentDuration.TotalMinutes.ToString("0"));
        // //   limit.Append(" min. ");

        // //   var desc = DescBuilder.create();

        // //   limit.rapport(desc);

        // //   foreach (TrackInfoItunes track in list)
        // //   {
        // //       desc.AppendLine();
        // //       desc.Append(track.Pub.ToShortDateString());
        // //       desc.Append(" ");
        // //       desc.Append(track.Album);
        // //       desc.Append(" ");
        // //       desc.Append(track.Name);
        // //       desc.Append(" ");
        // //       desc.Append(track.Rating / 20);
        // //       desc.Append(" info:");
        // //       desc.Append(track.Info);
        // //       desc.Append(" rare:");
        // //       desc.Append(track.Rare); 
        // //   }

        // //   misc.log(desc.ToString()); 



        // //   //for (int i = 0; i < Limits.NB; i++)
        // //   //{
        // //   //    var listLevel = list.FindAll(t => t.Rating == 20 * i);
        // //   //    if (listLevel.Count == 0)
        // //   //        continue;
        // //   //    var contributeurLevel = new Contributeur();
        // //   //    var sb = sbDir.createChild("level " + i); 
        // //   //    contributeurLevel.recordList(null, listLevel);
        // //   //    //sb.AppendLine(); 
        // //   //    //sb.Append("\t"); sb.Append("\t");
        // //   //    //sb.Append("level ");
        // //   //    //sb.Append(i);
        // //   //    //sb.Append(":");
        // //   //    contributeurLevel.rapport(sb);
        // //   //    limit.Append(sb.ToString()); 

        // //   //}


        // //  // misc.log("getTracks {0} {1} ==> {2} {3}", dir, limit, list.Count, currentDuration.TotalMinutes.ToString("0"));

        // ////   misc.log("getTracks levelMin:{0}, duration:{1}, feedDuration:{2}, nbMaxByFeed:{3}, info:{4}, rare:{5}, feedName:{6} ==> {7} {8}", levelMin, duration, feedDuration, nbMaxByFeed, info, rare, feedName, list.Count, currentDuration.TotalMinutes.ToString("0"));

        // //   return list;
        //}


        //public void getTracks(LimitItem limit, DirConf dir)
        //{
        //    TimeSpan currentDuration = new TimeSpan();
        //    int duration = limit.Duration;
        //    var DurationMax = TimeSpan.FromMinutes(duration);
        //    int levelMin = limit.Level;
        //    int ratingMin = levelMin * 20;

        //    var aux = new List<TrackInfoItunes>();

        //    string feedName = null;
        //    bool histo = dir.Histo;
        //    bool? histoAll = dir.HistoAll;
        //    if (histo)
        //        feedName = dir.Name;

        //    var logList = new List<TrackInfoItunes>();

        //    if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
        //        return;


        //    foreach (var feed in dict.Values)
        //    {
        //        if (true.Equals(histoAll) || !histo || (histo && false.Equals(histoAll) && feed.Name.Equals(feedName)))
        //            feed.getTracks(limit, dir);
        //    }
        //    if (histo)
        //        aux.Sort(new PodCastComparer());
        //    else
        //        aux.Sort(new PodCastComparerInv());



        //    bool? info = dir.Info;
        //    bool? rare = dir.Rare;

        //    bool durationLimitAtteinte = false;


        //    foreach (TrackInfoItunes candidat in aux)
        //    {
        //        if (candidat.Rating < ratingMin)
        //            continue;
        //        if (info.HasValue)
        //        {
        //            bool bInfo = info.Value;
        //            if (candidat.Info != bInfo)
        //                continue;
        //        }

        //        if (rare.HasValue)
        //        {
        //            bool bRare = rare.Value;
        //            if (candidat.Rare != bRare)
        //                continue;
        //        }


        //        if (currentDuration + candidat.Duration > DurationMax)
        //        {
        //            durationLimitAtteinte = true;
        //            continue;
        //        }
        //        currentDuration += candidat.Duration;
        //        //if (!dir.List.Contains(candidat))
        //        //{
        //        //    dir.List.Add(candidat);

        //        //}

        //        if (!logList.Contains(candidat))
        //            logList.Add(candidat);
        //        candidat.Selected = true;

        //    }
        //    //limit.Append(dir.ToString()); 
        //    //limit.Append(" "); 
        //    limit.DurationLimitAtteinte = durationLimitAtteinte;
        //    //if (durationLimitAtteinte)
        //    //{
        //    //    limit.Append(">>> ");
        //    //    //limit.Append(limit.Duration); 
        //    //}
        //    //limit.Elt = list.Count;
        //    //limit.DurationFact = currentDuration; 
        //    //limit.Append(list.Count);
        //    //limit.Append(" elts ");
        //    //limit.Append(currentDuration.TotalMinutes.ToString("0"));
        //    //limit.Append(" min. ");
        //    // limit.buildValues(); 

        //    var desc = DescBuilder.create();


        //    //limit.recordList(null, dir.List);
        //    limit.rapport(desc);



        //    foreach (TrackInfoItunes track in logList)
        //    {
        //        desc.AppendLine();
        //        desc.Append(track.Pub.ToShortDateString());
        //        desc.Append(" ");
        //        desc.Append(track.Album);
        //        desc.Append(" ");
        //        desc.Append(track.Name);
        //        desc.Append(" ");
        //        desc.Append(track.Rating / 20);
        //        if (track.Info)
        //            desc.Append(" info ");
        //        // desc.Append(track.Info);
        //        if (track.Rare)
        //            desc.Append(" rare");
        //        // desc.Append(track.Rare);
        //    }

        //    misc.log(desc.ToString());



        //    //for (int i = 0; i < Limits.NB; i++)
        //    //{
        //    //    var listLevel = list.FindAll(t => t.Rating == 20 * i);
        //    //    if (listLevel.Count == 0)
        //    //        continue;
        //    //    var contributeurLevel = new Contributeur();
        //    //    var sb = sbDir.createChild("level " + i); 
        //    //    contributeurLevel.recordList(null, listLevel);
        //    //    //sb.AppendLine(); 
        //    //    //sb.Append("\t"); sb.Append("\t");
        //    //    //sb.Append("level ");
        //    //    //sb.Append(i);
        //    //    //sb.Append(":");
        //    //    contributeurLevel.rapport(sb);
        //    //    limit.Append(sb.ToString()); 

        //    //}


        //    // misc.log("getTracks {0} {1} ==> {2} {3}", dir, limit, list.Count, currentDuration.TotalMinutes.ToString("0"));

        //    //   misc.log("getTracks levelMin:{0}, duration:{1}, feedDuration:{2}, nbMaxByFeed:{3}, info:{4}, rare:{5}, feedName:{6} ==> {7} {8}", levelMin, duration, feedDuration, nbMaxByFeed, info, rare, feedName, list.Count, currentDuration.TotalMinutes.ToString("0"));

        //    return; // logList;

        //}

        Dict<string, TrackInfoItunes> tracks = new Dict<string, TrackInfoItunes>();

        public void recordTrack(TrackInfoItunes track, LimitItem provider)
        {
            string location = track.Location;
            if (string.IsNullOrEmpty(location)) return;

            if (!selected.ContainsKey(location))
                selected.Add(location, track);
            if (tracks.ContainsKey(location)) return;
            tracks[location] = track;

            Feed feed = dict[track.AlbumKey];
            feed.recordTrack(track, provider);
        }

        //public void recordPreselectedTrack(TrackInfoItunes track, LimitItem provider)
        //{
        //    string location = track.Location;
        //    if (string.IsNullOrEmpty(location)) return;

        //    if (!preSelected.ContainsKey(location))
        //        preSelected.Add(location, track);
        //}

        private void rapportSelected(ITextWriter sb, string name, IEnumerable<LimitItem> providers)
        {
            sb.AppendLine(name);
            foreach (LimitItem provider in providers)
            {
                sb.Append("\t");
                //sb.Append(provider.Dir.getPath());
                //sb.Append(" ");
                sb.AppendLine(provider.ToString());
            }
            sb.AppendLine();
        }


        public List<TrackInfoItunes> getSelectedTracks()
        {
            return new List<TrackInfoItunes>(selected.Values);
        }

        public bool existSelected(string location)
        {
            return selected.ContainsKey(location);
        }


        public void rapportSelected(ITextWriter sb)
        {
            foreach (TrackInfoItunes track in selected.Values)
            {
                sb.AppendLine();
                sb.AppendLine("==================================");
                sb.AppendLine(track.ToString());
                // sb.AppendLine("==================================");

                //rapportSelected(sb, "phase 1", track.Providers1);
                //// rapportSelected(sb, "guests", track.ProvidersGuest);
                //// rapportSelected(sb, "recursif", track.ProvidersRecursif);
                rapportSelected(sb, "selected", track.Providers);
                sb.AppendLine();

            }
        }

        //public void rapportPreSelected(ITextWriter sb)
        //{
        //    foreach (TrackInfoItunes track in preSelected.Values)
        //    {
        //        sb.AppendLine();
        //        sb.AppendLine("==================================");
        //        sb.AppendLine(track.ToString());
        //        // sb.AppendLine("==================================");

        //        //rapportSelected(sb, "phase 1", track.Providers1);
        //        ////  rapportSelected(sb, "guests", track.ProvidersGuest);
        //        //// rapportSelected(sb, "recursif", track.ProvidersRecursif);
        //        //rapportSelected(sb, "selected", track.Providers);
        //        sb.AppendLine();

        //    }
        //}

        public void rapport(ITextWriter sb)
        {
            sb.AppendLine("==================================");
            sb.AppendLine("Feeds");
            sb.AppendLine("==================================");
            foreach (Feed feed in dict.Values)
            {
                feed.rapport(sb);
            }
        }

        //public List<TrackInfoItunes> getTracks(int levelMin, float duration, float feedDuration, bool? info, bool? rare, int nbMaxByFeed, string feedName)
        //{
        //    TimeSpan currentDuration = new TimeSpan();
        //    var DurationMax = TimeSpan.FromMinutes(duration);
        //    int ratingMin = levelMin * 20;
        //    var aux = new List<TrackInfoItunes>();
        //    bool histo = feedName != null;
        //    foreach (var feed in dict.Values)
        //    {
        //        if (feed.Name.Equals(feedName) || !histo)
        //            aux.AddRange(feed.getTracks(levelMin, nbMaxByFeed, feedDuration, histo));
        //    }
        //    if (histo)
        //        aux.Sort(new PodCastComparer());
        //    else
        //        aux.Sort(new PodCastComparerInv());

        //    var list = new List<TrackInfoItunes>();


        //    foreach (TrackInfoItunes candidat in aux)
        //    {
        //        if (candidat.Rating < ratingMin) continue;
        //        if (info.HasValue)
        //        {
        //            bool bInfo = info.Value;
        //            if (candidat.Info != bInfo) continue;
        //        }

        //        if (rare.HasValue)
        //        {
        //            bool bRare = rare.Value;
        //            if (candidat.Rare != bRare) continue;
        //        }


        //        if (currentDuration + candidat.Duration > DurationMax)
        //            continue;
        //        currentDuration += candidat.Duration;
        //        list.Add(candidat);

        //        //if (!candidat.Selected)
        //        //    candidat.SelectMode = selectMode.simple; 
        //        //candidat.Selected = true;

        //    }

        //    misc.log("getTracks levelMin:{0}, duration:{1}, feedDuration:{2}, nbMaxByFeed:{3}, info:{4}, rare:{5}, feedName:{6} ==> {7} {8}", levelMin, duration, feedDuration, nbMaxByFeed, info, rare, feedName, list.Count, currentDuration.TotalMinutes.ToString("0"));

        //    return list;
        //}

        public List<TrackInfoItunes> getSingleSelectedTracks(int levelMin)
        {
            List<TrackInfoItunes> list = new List<TrackInfoItunes>();
            int ratingMin = levelMin * 20;
            foreach (var feed in dict.Values)
            {
                var listFeed = feed.getSelectedTracks;
                listFeed.Sort(new PodCastComparerInv());
                foreach (var track in listFeed)
                {
                    if (track.Rating >= ratingMin)
                    {
                        list.Add(track);
                        break;
                    }
                }

            }
            list.Sort(new PodCastComparerInv());
            return list;
        }


        //public void getSingleSelectedTracks(List<TrackInfoItunes> depot)
        //{
        //    foreach (var feed in dict.Values)
        //    {
        //        feed.buildLastSelectedTrack(depot);
        //    }

        //}

        public void getFirstSelectedTracks(List<TrackInfoItunes> depot, SelectParam param)
        {
            foreach (var feed in dict.Values)
            {
                feed.buildFirstSelectedTrack(depot, param);
            }

        }

        public void buildFirstSelectedTrackLevel(List<TrackInfoItunes> depot, SelectParam param)
        {
            foreach (var feed in dict.Values)
            {
                feed.buildFirstSelectedTrackLevel(depot, param);
            }


            if (param.dateCroissante)
                depot.Sort(new PodCastComparerPub2());
            else
                depot.Sort(new PodCastComparerInv());
        }

        internal List<TrackInfoItunes> buildJournal(Journal journal)
        {
            var depot = new List<TrackInfoItunes>();
            foreach (var feed in dict.Values)
            {
                feed.getSelecTrackJournal(depot, journal);
            }
            depot.Sort(new PodCastComparerPub2());

            TimeSpan totalDurationMax = TimeSpan.FromMinutes(journal.Duration);
            TimeSpan duration = new TimeSpan();
            var list = new List<TrackInfoItunes>();

            foreach (TrackInfoItunes track in depot)
            {
                list.Add(track);
                track.markInJournal();
                duration += track.Duration;
                if (duration > totalDurationMax)
                    break;
            }
            return list;
        }




        public IEnumerator<Feed> GetEnumerator()
        {
            return dict.Values.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return dict.Values.GetEnumerator();
        }

        public Feed this[string album] { get { return dict[album]; } }
        // public List<TrackInfoItunes> PreSel { get { return new List<TrackInfoItunes>(preSelected); } }
    }





}
]]></content>
  </file>
  <file path="\pdb.podcast\Hibernator.cs">
    <content><![CDATA[using pdb.it;
using pdb.util;
using System.IO;
using System;
using System.Collections.Generic;
using pdb.iit;

namespace pdb.podcast
{
    class Hibernator
    {
        public int go(ILoader loader, List<TrackInfoItunes> tracks)
        {

            var conf = pdb.podcast.Tuning.Conf.Hibernate;
            if (!conf.enabled)
                return 0;
            var toH = new List<TrackInfoItunes>();
            var dirH = conf.dir;
            var list = conf.list;
            if (!string.IsNullOrEmpty(list))
            {

                var auto = loader.TreePlayList.getComposite("auto");
                if (auto != null)
                {
                    var itl = auto.getComposite(list);
                    if (itl != null)
                    {
                        foreach (var plc in itl)
                        {
                            if (plc is TrackInList)
                            {
                                var t = plc as TrackInList;
                                var piece = t.Piece as TrackInfoItunes;
                                if (piece == null)
                                {
                                    misc.log("plc pas un TrackInfoItunes {0}", plc);
                                    continue;
                                }
                                if (piece.Selected)
                                {
                                    misc.log("non hiberné car selected {0}", piece);
                                    continue;
                                }
                                Program.log.log("hibernation de {0} par liste", piece);
                                toH.Add(piece);
                            }
                        }
                    }
                }
            }

            select(conf, toH, tracks, false);


            int nb = 0;
            DateTime limit = DateTime.Now.AddDays(-conf.delay);
            DateTime limitAdd = DateTime.Now.AddDays(-conf.delayAdd); 
            foreach (TrackInfoItunes track in toH)
            {
                var fv = FileRegister.Check(track.Location);
                if (fv.Exists)
                {
                    //if (pdb.podcast.Sort.Album.LastRead.Contains(track.DbId))
                    //    continue;
                    if (track.Selected)
                        continue; 
                    if (track.GlobalSelected)
                        continue;
                    if (track.Gout > limit)
                        continue;
                    if (track.Added > limitAdd)
                        continue; 
                    nb++;
                    track.hibernate(fv, dirH);
                }
            }


            return nb;
        }

        public void select(pdb.podcast.Tuning.Hibernate conf, List<TrackInfoItunes> toCheck, List<TrackInfoItunes> tracks, bool import)
        {
            bool critereDate = conf.dateMin > DateTime.MinValue && conf.dateMax < DateTime.MaxValue;
            bool critereAlbum = !string.IsNullOrEmpty(conf.album);
            bool critereLast = conf.nblast > 0;


            if (import || critereAlbum || critereDate || critereLast)
            {

                if (!critereLast)
                {
                    foreach (TrackInfoItunes t in tracks)
                    {
                        if (import)
                        {
                            //if (t.Present)
                            //    continue;
                        }
                        else
                        {
                            if (!t.Present)
                                continue;
                            if (t.Selected)
                                continue;
                        }


                        if (!critereDate || t.Pub2 >= conf.dateMin && t.Pub2 <= conf.dateMax)
                        {
                            if (!critereAlbum || t.Album.ToLower().Contains(conf.album.ToLower()))
                            {
                                toCheck.Add(t);
                            }
                        }
                    }
                }
                else
                {
                    Dictionary<string, Album> dict = new Dictionary<string, Album>();
                    tracks.Sort(new PodCastComparerPub2());
                    foreach (TrackInfoItunes track in tracks)
                    {
                        string album = track.Album;
                        string key = album;
                        if (string.IsNullOrEmpty(album))
                        {
                            misc.log("pas d'album pour " + track.Location);
                            if (import)
                                toCheck.Add(track);
                            continue;

                        }

                        if (!dict.ContainsKey(key))
                        {
                            Album a = new Album(key);
                            dict.Add(key, a);
                        }
                        dict[key].add(track);
                    }

                    foreach (Album album in dict.Values)
                    {
                        if (critereAlbum)
                        {
                            if (album.Name.ToLower().Contains(conf.album.ToLower()))
                            {
                            }
                            else continue;
                        }

                        var list = album.List;
                        int count = list.Count;
                        int nb = 0;

                        for (int i = count - 1; i >= 0; i--)
                        {
                            var t = list[i];
                            if (!import)
                            {
                                if (t.Selected)
                                    continue;
                                if (!t.Present)
                                    continue;
                            }
                            if (!critereDate || t.Pub2 >= conf.dateMin && t.Pub2 <= conf.dateMax)
                            {
                                if (import)
                                {
                                    nb++;
                                    toCheck.Add(t);
                                    if (nb >= conf.nblast)
                                        break;
                                    continue;
                                }


                                if (t.Pub2 > conf.dateLast)
                                {
                                    nb++;
                                    if (nb <= conf.nblast)
                                        continue;
                                }

                                toCheck.Add(t);
                            }
                        }
                    }
                }



            }
        }

        private class Album
        {
            private string name;
            private List<TrackInfoItunes> list = new List<TrackInfoItunes>();
            public Album(string name)
            {
                this.name = name;
            }
            public void add(TrackInfoItunes track)
            {
                list.Add(track);
            }
            public List<TrackInfoItunes> List { get { return list; } }
            public string Name { get { return name; } }
        }
    }
}
]]></content>
  </file>
   <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;

//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    public class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        //  private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();

        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        // private Logger log;
        timeSpan currentDuration = new timeSpan();
        // timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;



        // List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> selectedByFd = new BgDictString0<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> manageByFd = new BgDictString0<TrackInfoItunes>();
        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            //log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }


        //public timeSpan _durationv;
        //public timeSpan _datev;
        //private timeSpan _fd;
        //public timeSpan Fd { get { return _fd; } }

        public int _nb;

        //public void checkV(AutoBuilder auto, int nb, timeSpan fd, timeSpan d, timeSpan date)
        //{
        //    BgDictString0<TrackInfoItunes> dict = new BgDictString0<TrackInfoItunes>();

        //    int nbMin = int.MaxValue;
        //    timeSpan fdMin = timeSpan.MaxValue;
        //    timeSpan dMin = timeSpan.MaxValue;
        //    timeSpan dateMin = timeSpan.MaxValue;
        //    foreach (FeedLimitItemLoader loader in loaders.Values)
        //    {
        //        loader.checkV(nb, fd);
        //        var _nb = loader.NbV;
        //        var _fd = loader.FdV;
        //        if (_nb > nb && _nb < nbMin)
        //            nbMin = _nb;
        //        if (_fd > fd && fd < fdMin)
        //            fdMin = _fd;
        //        for (int i = 0; i <= loader.IndexV; i++)
        //        {
        //            var track = loader.Candidats[i];
        //            if (dict.ContainsKey(track.Location))
        //                continue;
        //            var _d = currentDuration + track.Duree;
        //            if (_d > d && d < dMin)
        //                dMin = _d;
        //            var _date = track.Ts;
        //            if (_date > date && _date < dateMin)
        //                dateMin = _date;
        //            break;
        //        }



        //    }

        //    this._durationv = dMin;
        //    this._datev = dateMin;
        //    this._nb = nbMin;
        //    this._fd = fdMin;
        //}

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0)
                return;

            if (!limit.OverwriteConf && limit.Nb2 == 0)
                return;

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            //if (limit.Dir.Cascading)
            //{
            var dd = limit.LoadDuration;
            if (dd > duration)
            {
                loadEqSel = false;
                duration = dd;
            }
            //}

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                var d = candidat.Pub2;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                standAlone.Add(location, candidat);
                Exporter.Record(candidat);

                //var loader = getLoader(candidat);
                //loader.AddCandidat(candidat);
                continue;



            }

        }




        private FeedLimitItemLoader getLoader(TrackInfoItunes candidat)
        {
            return limit.Dir.Loader.Albums.Get(candidat);
        }

        /// <summary>
        /// On supprime tout sauf les standalone
        /// </summary>
        public void reset()
        {
            //loaders = new BgDictString0<FeedLimitItemLoader>();
            //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
            // public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
            legacy = new SequentialDictString<TrackInfoItunes>();
            legacyRelax = new SequentialDictString<TrackInfoItunes>();
            selected = new SequentialDictString<TrackInfoItunes>();
            exclu = new SequentialDictString<TrackInfoItunes>();

            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();
            use = new List<TrackInfoItunes>();


            currentDuration = new timeSpan();
            // timeSpan currentDurationVirtual = new timeSpan();
            durationStop = new timeSpan();
            currentContrib = new timeSpan();
            trackDurationMax = new timeSpan();
            trackDurationMin = new timeSpan();
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            //  currentDurationVirtual = new timeSpan();
            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in limit.Dir.Loader.Albums)
                loader.phase2();
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }



        //private timeSpan getDuration(int nb, timeSpan minfd)
        //{
        //    timeSpan tot = new timeSpan();
        //    foreach (FeedLimitItemLoader feed in loaders.Values)
        //    {
        //        tot += feed.getTotalDurationFor(nb, minfd);
        //    }
        //    return tot;
        //}

        public void Selection()
        {

            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;
            if (relax.Count > 0)
            {
                if (histo)
                    relax.Sort(new PodCastComparerPub2());
                else
                    relax.Sort(new PodCastComparerInv());
                selection(relax, false, false);
            }

            var list = legacy.List;
            if (list.Count > 0)
            {
                if (histo)
                    list.Sort(new PodCastComparerPub2());
                else
                    list.Sort(new PodCastComparerInv());
                selection(list, false, true);
            }





            var list2 = standAlone.List;
            if (list2.Count > 0)
            {
                if (histo)
                    list2.Sort(new PodCastComparerPub2());
                else
                    list2.Sort(new PodCastComparerInv());

                selection(list2, true, true);
            }

        }


        private class FdResponse
        {
            public int nb;
            public timeSpan duree;
            public bool okFd;
            public bool okNb;
            public bool Result { get { return okFd && okNb; } }


        }

        FdResponse check(FeedLimitItemLoader loader, TrackInfoItunes candidat, LimitItem limit)
        {
            if (loader.isSelected(candidat))
            {
                return null;
            }
            var response = new FdResponse();

            var _nb = loader.Nb + 1;
            response.nb = _nb;

            response.duree = loader.fd;

            var conf = loader.album.ConfAlbum;

            int _nbMax = limit.getNb(conf); //    load ? limit.LoadNb : (int)(System.Math.Min(limit.Nb, limit.Nb2));
            var __durationMax = limit.getFd(conf); //  load ? limit.LoadDuration : System.Math.Min(limit.FeedDuration, limit.Fd2);
            var _durationMax = timeSpan.FromMinutes(__durationMax);

            response.okNb = _nb <= _nbMax;
            response.okFd = response.duree < _durationMax;

            return response;

        }

        private void selection(List<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.getDuration();

            var durationMax = timeSpan.FromMinutes(duration);

            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {
                TrackInfoItunes candidat = list[index];
                //foreach (TrackInfoItunes candidat in list)
                //{

                //if (candidat.Album == "Géopolitique")
                //{
                //}

                //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
                //{
                //}
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                DateTime d = candidat.TrackAlbum.ConfAlbum.checkPub ? candidat.Pub : candidat.Pub2;
                
                bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
                var loader = getLoader(candidat);
                bool okTotalDuration = false;
                bool _control = false;

                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                okTotalDuration = currentDuration <= durationMax;

                //  bool okprovi = okDate && okTotalDuration;
                // bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                FdResponse response = null;
                if (!increment) // données venant de sous-dossier (histo, voisins....)
                {
                    response = check(loader, candidat, limit);
                    _control = response == null || response.Result;
                    //  _control = loader.control(false, limit, candidat); // loader.control(parent, limit, candidat, select, false, okDate && okTotalDuration, true);
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                }



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {
                    var newDuration = currentDuration; // +candidat.Duree;
                    okTotalDuration = newDuration <= durationMax;
                    if (manageByFd.ContainsKey(location))
                    {
                        _control = false;
                        if (selectedByFd.ContainsKey(location))
                            _control = true;
                    }
                    else
                    {
                        response = check(loader, candidat, limit);
                        _control = response == null || response.Result;
                        //_control = loader.control(false, limit, candidat); // loader.control(parent, limit, candidat, select, false, okDate && okTotalDuration, true);

                    }

                    if (_control)
                    {
                        //currentDurationVirtual += candidat.Duree;
                        if (okDate)
                            currentDuration += candidat.Duree;
                    }


                    // newDuration = currentDuration;
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                    //  okTotalDuration = newDuration <= durationMax;




                 

                    bool go = okDate && _control && okTotalDuration;
                    if (go)
                    {
                        loader.record(candidat);
                        if (select && LimitItemLoader.ModeSelection)
                        {
                            candidat.select(selectMode.simple, limit);
                            limit.Dir.Feeds.recordTrack(candidat, limit);
                        }

                        //report aux niveaux inférieurs
                        // if (real)
                        parent.recordLimitItemCandidat(candidat, limit);
                        // return true;

                    }

                    if (!_selection)
                    {

                        if (limit.canSignal() && response != null)
                        {



                            var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                                //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                                //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                                //, okTotalDuration, newDuration, candidat, limit);
                                    response.okFd, response.duree
                            , response.okNb, response.nb
                            , okTotalDuration, newDuration, candidat, limit);

                            limit.signal(dataAuto);
                        }

                    }



                  
                    //newDuration = currentDuration;
                    //okTotalDuration = newDuration <= durationMax;
                    if (!okTotalDuration)
                    {
                        //if (!Logger.CreateNullLoggers)
                        //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                        {
                            // currentDuration = newDuration;
                            durationStop = currentDuration;
                        }
                        break; 

                    }

                    if (!okDate)
                        break;

                    if (!_control)
                        continue;

                


                    if (_selection && !newContribut)
                    {
                        // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            // log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }

                    //   currentDuration = newDuration;




                    if (_selection)
                    {
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        limit.Dir.recordTrack(candidat, limit);
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        //  limit.Dir.recordTrack(candidat, limit);

                        selected.Add(location, candidat);

                        if (select)
                            exclu.Add(location, candidat);
                    }





                }

            }
        }


        //private void selection0(List<TrackInfoItunes> list, bool select, bool increment)
        //{
        //    var duration = limit.Duration;
        //    var durationMax = timeSpan.FromMinutes(duration);
        //    var contributionMax = timeSpan.FromMinutes(limit.Contribution);

        //    int count = list.Count;
        //    for (int index = 0; index < count; index++)
        //    {
        //        TrackInfoItunes candidat = list[index];
        //        //foreach (TrackInfoItunes candidat in list)
        //        //{

        //        //if (candidat.Album == "Géopolitique")
        //        //{
        //        //}

        //        //if (candidat.Name == "Le monde selon Etienne Klein 17.01.13")
        //        //{
        //        //}
        //        var location = candidat.Location;
        //        if (string.IsNullOrEmpty(location))
        //            continue;

        //        //if (_selection && selected.ContainsKey(location))
        //        //    continue;
        //        // vérification à postériori par rapports aux différents niveaux
        //        bool newContribut = candidat.Selected;

        //        DateTime d = candidat.TrackAlbum.CheckPub ? candidat.Pub : candidat.Pub2;
        //        bool okDate = d <= limit.DateMax && d <= limit.DateMax2;
        //        var loader = getLoader(candidat.Album);
        //        bool okTotalDuration = false;
        //        bool _control = false;

        //        //tester uniquement fd et nb
        //        // _control = loader.control(candidat, select, false, false);

        //        // var _newDuration = currentDuration;
        //        //if (increment)
        //        //    _newDuration = currentDuration + candidat.Duree;

        //        // savoir si ça passe uniquement avec le critère d
        //        okTotalDuration = currentDuration <= durationMax;

        //        bool okprovi = okDate && okTotalDuration;
        //        bool ok = okDate && okTotalDuration && _control;

        //        // rejouer le controle pour incrémenter nb et fd      
        //        if (!increment) // données venant de sous-dossier (histo, voisins....)
        //        {
        //            _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //        }



        //        //if (!loader.LoadEqSel)
        //        //{

        //        //    if (_control)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
        //        //    else if (loader.EndByFd)
        //        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

        //        //}

        //        //if (!increment && !_selection) //!loader.LoadEqSel &&
        //        //{
        //        //    //  if (!loader.OkNb)
        //        //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
        //        //    // if (!loader.OkFd)
        //        //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
        //        //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

        //        //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //        //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //        //}

        //        //if (!control(candidat, select, okDuration))
        //        //    continue;

        //        if (increment)
        //        {
        //            var newDuration = currentDuration + candidat.Duree;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (manageByFd.ContainsKey(location))
        //            {
        //                _control = false;
        //                if (selectedByFd.ContainsKey(location))
        //                    _control = true;
        //            }
        //            else
        //            {
        //                _control = loader.control(candidat, select, false, okDate && okTotalDuration, true);

        //            }

        //            if (_control)
        //            {
        //                //currentDurationVirtual += candidat.Duree;
        //                if (okDate)
        //                    currentDuration += candidat.Duree;
        //            }


        //            // newDuration = currentDuration;
        //            if (_control && !selectedByFd.ContainsKey(location))
        //                selectedByFd.Add(location, candidat);
        //            if (!manageByFd.ContainsKey(location))
        //                manageByFd.Add(location, candidat);
        //            //  okTotalDuration = newDuration <= durationMax;



        //            //okTotalDuration = newDuration <= durationMax;
        //            //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

        //            //if (okDate && _control)
        //            //    currentDuration += candidat.Duree;
        //            //currentDurationVirtual = currentDuration; // += candidat.Duree;

        //            //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

        //            //  bool okTotalDuration = newDuration <= durationMax;

        //            if (!_selection)
        //            {


        //                var _fd = loader.getCurrentDuration(false);

        //                if (_fd > newDuration)
        //                {
        //                    newDuration = _fd;
        //                    okTotalDuration = newDuration <= durationMax;
        //                }
        //                if (_control)
        //                {
        //                }
        //                else
        //                {
        //                    //var fd = loader.getCurrentDuration(true);
        //                    //var nb = loader.getNb(true);

        //                    //newDuration = new timeSpan();
        //                    //foreach (FeedLimitItemLoader l in loaders.Values)
        //                    //    l.phaseTest();
        //                    //for (int j = 0; j <= index; j++)
        //                    //{
        //                    //    TrackInfoItunes t = list[j];
        //                    //    var subloader = getLoader(t.Album);
        //                    //    var subok = subloader.test(nb, fd, t);
        //                    //    if (j >= subloader.IndexBase)
        //                    //    {
        //                    //        if (subok || selectedByFd.ContainsKey(location))
        //                    //            newDuration += t.Duree;
        //                    //    }

        //                    //}
        //                    //// newDuration += getDuration(nb, fd);

        //                    //if (newDuration < currentDuration)
        //                    //{
        //                    //}
        //                    //else if (newDuration > currentDurationVirtual)
        //                    //{
        //                    //}
        //                    //okTotalDuration = newDuration <= durationMax;
        //                }


        //                //question fd
        //                //if (!loader.LoadEqSel)
        //                //{
        //                var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //              loader.OkFd, loader.getDurationStop(okDate)
        //              , loader.OkNb, loader.getNbStop(okDate)
        //              , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

        //                limit.Dir.CauseRegister.signal(dataRoot);

        //                var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
        //                    //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
        //                    //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
        //                    //, okTotalDuration, newDuration, candidat, limit);
        //                        loader.OkFd, _fd// loader.getCurrentDuration (false)
        //                , loader.OkNb, loader.getNb(false)
        //                , okTotalDuration, newDuration, candidat, limit);

        //                limit.signal(dataAuto);
        //            }




        //            //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
        //            //loader.OkFd, loader.getDurationStop(okDate)
        //            //, loader.OkNb, loader.getNbStop(okDate)
        //            //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

        //            //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
        //            //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
        //            //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

        //            if (Conf.BorderTb)
        //            {
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
        //                else if (okDate && okTotalDuration)
        //                {
        //                    if (loader.EndByFd)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
        //                }
        //                //else if (Conf.BorderVirtual)
        //                //{
        //                //    if (_control)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
        //                //    else if (loader.EndByFd)
        //                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
        //                //}


        //                //}

        //                //if (!loadEqSel)
        //                //{
        //                // question d
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
        //                else if (okDate && _control)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okTotalDuration)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
        //                }


        //                // question date
        //                if (okDate && _control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
        //                else if (_control && okTotalDuration)
        //                    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
        //                else if (Conf.BorderVirtual)
        //                {
        //                    if (okDate)
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
        //                    else
        //                        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
        //                }

        //                //}

        //            }


        //            ////question duree
        //            //if (okDate && _control) // || Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
        //            //}

        //            ////question fd

        //            //if (_control)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

        //            //    }
        //            //}
        //            //else //if (!loader.limit.NbFeedLimit)
        //            //{
        //            //    if (okDate && okDuration)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
        //            //        limit.signal(tb);
        //            //    }
        //            //    else if (Conf.BorderVirtual)
        //            //    {
        //            //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
        //            //        limit.signal(tb);
        //            //    }
        //            //}
        //            ////question date
        //            //if (_control && okDuration)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
        //            //    limit.signal(tb);
        //            //}
        //            //else if (Conf.BorderVirtual)
        //            //{
        //            //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
        //            //    limit.signal(tb);
        //            //}



        //            //if (!_control && !Conf.BorderVirtual)
        //            //    continue;
        //            if (!okDate)
        //                continue;

        //            if (!_control)
        //                continue;
        //            newDuration = currentDuration;
        //            okTotalDuration = newDuration <= durationMax;
        //            if (!okTotalDuration)
        //            {
        //                //if (!Logger.CreateNullLoggers)
        //                //    log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

        //                if (_selection)
        //                    limit.DurationLimitAtteinte = true;
        //                if (durationStop.Value == 0)
        //                {
        //                    // currentDuration = newDuration;
        //                    durationStop = currentDuration;
        //                }

        //            }

        //            if (!okTotalDuration)
        //                continue;


        //            if (_selection && !newContribut)
        //            {
        //                // pour l'instant ? on ne gère pas la contribtion en mode rejeu

        //                currentContrib += candidat.Duree;
        //                if (currentContrib > contributionMax)
        //                {
        //                    //  log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
        //                    limit.ContributionLimitAtteinte = true;
        //                    break;
        //                }

        //                use.Add(candidat);
        //            }

        //            //   currentDuration = newDuration;




        //            if (_selection)
        //            {
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                limit.Dir.recordTrack(candidat, limit);
        //                // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
        //                //  limit.Dir.recordTrack(candidat, limit);

        //                selected.Add(location, candidat);

        //                if (select)
        //                    exclu.Add(location, candidat);
        //            }





        //        }

        //    }
        //}

        public LimitItem Item { get { return limit; } }
        public override string ToString()
        {
            return limit.ToString();
        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitsLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;

using pdb.podcast.Tuning;
using pdb.util.list;
using pdb.util;
using pdb.podcast.Report;
using System.Xml;
using pdb.podcast.Selection;

namespace pdb.podcast.Load
{
    public interface IWriter
    {
        void StartElement(string elt);
        void SetAttribute(string name, object value);
        void EndElement();
    }
    public class WriterXml : IWriter
    {
        private XmlWriter writer;
        public WriterXml(XmlWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            writer.WriteStartElement(elt);
        }

        public void SetAttribute(string name, object value)
        {
            writer.WriteAttributeString(name, value.ToString());
        }

        public void EndElement()
        {
            writer.WriteEndElement();
        }
    }

    public class WriterHtml : IWriter
    {
        private ITextWriter writer;
        int level;
        void beginLine()
        {
            writer.AppendLine();
            for (int i = 0; i < level; i++)
                writer.Append("\t");
        }
        public WriterHtml(ITextWriter writer)
        {
            this.writer = writer;
        }
        public void StartElement(string elt)
        {
            StartElement(elt, null);
        }

        private void StartElement(string elt, string class_)
        {
            beginLine();
            if (string.IsNullOrEmpty(class_))
                writer.Append("<div>");
            else
            {
                writer.Append("<div class='");
                writer.Append(class_);
                writer.Append("'>");
            }
            if (elt.Length > 1)
            {
                writer.Append(elt);
                writer.Append("&nbsp;");
            }
            level++;
        }


        public void Start(string elt)
        {
            StartElement(elt, "tree");
        }

        public void SetAttribute(string name, object value)
        {
            if (name == "track")
            {
                writer.Append("<span class='track'>");
                writer.Append(value);
                writer.Append("</span>");

            }
            else if (name == "album")
            {
                writer.Append("<span class='album'>");
                writer.Append(value);
                writer.Append("</span>");
            }
            else
            {
                writer.Append(name);
                writer.Append("=");
                writer.Append(value);
            }
            writer.Append("&nbsp");

        }

        public void EndElement()
        {
            level--;
            beginLine();
            writer.Append("</div>");
        }
    }

    public class LimitsLoader
    {
        private DirConf dir;
        private Limits limit;
        // private IDictionary<string, TrackInfoItunes> loaded;
        private LimitLoader[] limites = new LimitLoader[Limits.NB];
        public loadState state;
      //  private Logger log;
        private static IWriter writer;
        public LimitsLoader(DirConf dir)
        {
            this.dir = dir;
            this.limit = dir.Limites;
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i] = new LimitLoader(this, limit[i]);
            }
          //  log = Logger.getLogger(dir.getPath() + "\\dir", null, false);
        }

        public void getLoaders(List<LimitItemLoader> list)
        {
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].getLoaders(list);
            }
        }

        private bool candidatLoaded;
        public void loadCandidats()
        {
            if (candidatLoaded)
            {
                foreach (LimitLoader item in limites)
                {
                    item.reset();
                }
                return; 
            }
            try
            {
                var feeds = dir.Feeds;
                string feedName = null;
                bool histo = dir.Histo;
                bool? histoAll = dir.HistoAll;
                if (histo && false.Equals(histoAll))
                    feedName = dir.Name;

                bool? dirInfo = dir.Info;
                bool? dirRare = dir.Rare;

                var _loaded = feeds.Loaded;
                List<TrackInfoItunes> loaded = new List<TrackInfoItunes>();



                foreach (TrackInfoItunes track in _loaded)
                {

                    if (feedName != null)
                    {
                        if (track.Album != feedName)
                            continue;
                    }

                    if (dirInfo.HasValue && dirInfo.Value != track.Info)
                        continue;

                    if (dirRare.HasValue && dirRare.Value != track.Rare)
                        continue;
                    loaded.Add(track);
                }

                if (histo)
                    loaded.Sort(new PodCastComparerPub2());
                else
                    loaded.Sort(new PodCastComparerInv());


                for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
                {
                    var limit = limites[i];
                    limit.loadCandidats(loaded);

                }


            }
            finally
            {
                state = loadState.selection;
                candidatLoaded = true;
            }
        }

        private bool recordGuests;
        public void phase2()
        {
            state = loadState.selection;
            if (dir.Cascading)
                recordGuests = true;
            foreach (LimitLoader item in limites)
            {
                item.phase2();
            }
        }

        public void recordLimitItemCandidat(TrackInfoItunes track, LimitItem item)
        {

            if (!recordGuests)
                return;


            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordGuest(track, item);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            for (int i = 0; i < Limits.NB; i++)
            {
                limites[i].recordTrackFromChild(track, itemSource, transmitTotal);
            }
        }


        public void WriteLists()
        {
            if (dir.Parent == null || Conf.WritePlayLists)
            {
                // var preSel = feeds.PreSel;
                var list = dir.getListe();

                var limits = dir.Limites;
                var usegenPrior = Conf.GenUsePrior;
                var exclugenPrior = Conf.GenExcluPrior;

                for (int i = 0; i < Limits.NB; i++)
                {
                    var limit = limites[i];
                    List<TrackInfoItunes> items;
                    foreach (LimitItemLoader item in limit.Items)
                    {
                        // var index = limit.index(item);
                        if (Conf.WriteItems)
                        {
                            items = item.exclu.List; // list.FindAll(t => t.containsSelect(item));
                            buildList(item.Item.ID, items, "_sel");
                        }

                        if (Conf.WritePreSel)
                        {
                            items = item.standAlone.List; // preSel.FindAll(t => t.containsStandAlone(item));
                            buildList(item.Item.ID, items, "_sel0");
                        }
                        if (Conf.WriteUse)
                        {
                            items = item.use;
                            buildList(item.Item.ID, usegenPrior, items, "_use");
                        }
                        if (Conf.WriteExclu)
                        {
                            var limite = item.Item;
                            items = item.use.FindAll(t => t.Exclu == limite);
                            buildList(item.Item.ID, exclugenPrior, items, "_exclu");
                        }

                    }
                }

                //if (dir.Parent == null)
                //{
                if (dir.Parent == null)
                {

                    var lfolders = dir.Folders;

                    buildListPrior("_auto", list, lfolders);

                 

                    foreach (SelectParamBase listeSuppl in Conf.Listes)
                    {
                        var selector = new TrackSelector(listeSuppl);
                        var l = new List<TrackInfoItunes>();
                        foreach (TrackInfoItunes t in list)
                        {
                            if (selector.select(t))
                                l.Add(t); 
                        }
                       // var l = selector.getList(list,listeSuppl); // new List<TrackInfoItunes>();
                        //foreach (TrackInfoItunes t in list)
                        //{
                        //    if (t.Actu != listeSuppl.actu && listeSuppl.actu != null)                            
                        //        continue;
                        //    if (t.Info != listeSuppl.info && listeSuppl.info != null)
                        //        continue;
                        //    if (t.Rare != listeSuppl.rare && listeSuppl.rare != null)
                        //        continue;

                        //    l.Add(t); 
                        //}
                        buildListPrior(listeSuppl.name, l, lfolders);
                    }

                    //var lHisto = list.FindAll(t => t.Histo);
                    //buildList("_histo", lHisto, lfolders);

                    //var lPasHisto = list.FindAll(t => !t.Histo);
                    //buildList("_pasHisto", lPasHisto, lfolders);

                    //var lSerie = list.FindAll(t => t.Serial);
                    //buildList("_serie", lSerie, lfolders);
                }
                // }
            }
        }



        private static void buildList(string name, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, int.MaxValue, folder);
        }

        private static void buildList(string name, int prior, List<TrackInfoItunes> list, string folder)
        {
            Program.buildList(name, list, prior, folder);
        }

        private static void buildList(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, folders);
        }
        private static void buildListPrior(string name, List<TrackInfoItunes> list, List<string> folders)
        {
            Program.buildList(name, list, 0, folders,false);
        }



        private void writeStat(GroupStat stat, bool? onlyUse)
        {
            writeStat(stat.Total, onlyUse);
        }

        private void writeStat(DoubleStat stat, bool? onlyUse)
        {
            if (onlyUse == null)
                return;
            string strStat = "";
            if (true == onlyUse)
                strStat = stat.getUseValues();
            else
                strStat = stat.getStats();
            writer.SetAttribute("stats", strStat);
        }

        private void writeTrackList(List<TrackInfoItunes> list, bool includeAlbum, bool includeLevel, bool includeItem)
        {
            var conf = Conf.Html;
            int nbmax = conf.trackCause;
            int nb = 0;
            foreach (TrackInfoItunes track in list)
            {
                nb++;
                writer.StartElement("t");
                writer.SetAttribute("date", track.Pub.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));

                if (includeItem)
                {
                    writer.SetAttribute("i", track.GetProvider());
                    if (conf.trackItemDetail)
                    {
                        var lim = track.Provider;
                        if (lim != null)
                        {
                            var sb = new StringBuilder();
                            lim.writeStatHeader(sb);
                            lim.Stat.Total.buildValues(sb);
                            writer.SetAttribute("stats", sb.ToString());
                        }
                    }

                }

                if (includeAlbum)
                    writer.SetAttribute("album", track.Album);
                if (includeLevel)
                    writer.SetAttribute("l", (track.Rating / 20).ToString());
                writer.SetAttribute("track", track.Name);

                if (track.Pub2 > track.Pub)
                    writer.SetAttribute("pub2", track.Pub2.ToString(TrackInfoItunes.PUB_DATE_FORMAT_DB));
                if (nb <= nbmax)
                {
                    WriteCause(dir.CauseRegister.Get(track), true, true);
                    WriteCause(dir.CauseRegister.Get(track), true, false);
                    WriteCause(dir.CauseRegister.Get(track), false, true);
                    WriteCause(dir.CauseRegister.Get(track), false, false);

                }
                writer.EndElement();
            }
        }

        private List<TrackInfoItunes> getItems(DirConf dir, DoubleStat stat)
        {
            var items = new List<TrackInfoItunes>(stat.Use.List);
            if (dir.Histo)
                items.Sort(new PodCastComparerPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;

        }

        internal void writeTracks(DirConf dir, GroupStat stat, bool? onlyUseStat, bool includeTrackItem)
        {
            writeStat(stat, onlyUseStat);

            var items = getItems(dir, stat.Total);
            if (items.Count == 0)
                return;

            int nbLevel = 0;



            #region tracks
            writer.StartElement("tracks");

            for (int i = 0; i < Limits.NB; i++)
            {
                var soutot = stat.SousTotaux[i];
                if (soutot.Empty)
                    continue;
                nbLevel++;
                if (nbLevel > 1)
                    break;
            }
            if (nbLevel > 1)
            {
                #region levels
                writer.StartElement("levels");
                for (int i = 0; i < Limits.NB; i++)
                {
                    var soutot = stat.SousTotaux[i];
                    if (soutot.Empty)
                        continue;
                    #region level
                    writer.StartElement("level");
                    writer.SetAttribute("level", i.ToString());
                    writeStat(soutot, true);
                    var subItems = getItems(dir, soutot);
                    #region subItems
                    writeTrackList(subItems, true, false, includeTrackItem);

                    #endregion

                    writer.EndElement();
                    #endregion

                }
                writer.EndElement();
                #endregion
            }

            writeTrackList(items, true, true, includeTrackItem);

            writer.EndElement();
            #endregion


            if (false != dir.HistoAll)
            {
                int nbAlbum = 0;
                foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                {
                    var listInAlbum = items.FindAll(t => t.Album == f.Album);
                    if (listInAlbum.Count == 0)
                        continue;
                    nbAlbum++;
                    if (nbAlbum > 1)
                        break;
                }
                if (nbAlbum > 1)
                {
                    #region albums
                    writer.StartElement("albums");
                    foreach (FeedLimitItemStat f in stat.Feed.getFeeds())
                    {
                        var listInAlbum = items.FindAll(t => t.Album == f.Album);
                        if (listInAlbum.Count == 0)
                            continue;
                        #region album
                        writer.StartElement("album");
                        writer.SetAttribute("name", f.Album);

                        writeStat(f.Totaux, true);
                        writeTrackList(listInAlbum, false, true, includeTrackItem);

                        writer.EndElement();
                        #endregion

                    }
                    writer.EndElement();
                    #endregion
                }
            }
        }
        public static IWriter Writer { set { writer = value; } }
        public void WriteTracksPre()
        {
            if (writer is WriterHtml && dir.Parent == null)
            {
                (writer as WriterHtml).Start("dir");
            }
            else
                writer.StartElement("dir");
            writer.SetAttribute("name", this.dir.Name);




            var dirStat = dir.Stat;
            if (dirStat == null)
                return;

            writeTracks(dir, dir.Conteneur.Tracks, true, true);

            var limits = dir.Limites;


            bool hasLimit = false;
            #region limites
            for (int i = 0; i < Limits.NB; i++)
            {
                var limit = limites[i];
                bool hasLimitItem = false;

                var limite = limit.Limit;
                var limitStat = limite.Stat;
                if (limitStat == null)
                    continue;
                if (limitStat.Total.Empty)
                    continue;


                if (!hasLimit)
                {
                    writer.StartElement("limites");
                    writeTracks(dir, dir.Stat, true, true);
                }
                hasLimit = true;

                #region limite
                writer.StartElement("limite");
                writer.SetAttribute("level", i.ToString());

                writeTracks(dir, limitStat, true, true);


                #region items
                foreach (LimitItemLoader item in limit.Items)
                {
                    var lim = item.Item;
                    var items = item.use;
                    if (items.Count == 0)
                        continue;
                    if (!hasLimitItem)
                        writer.StartElement("items");
                    hasLimitItem = true;

                    #region item
                    writer.StartElement("i");
                    writer.SetAttribute("name", lim.ToString().Replace(dir.getPath(), ""));
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());

                    writeTracks(dir, lim.Stat, null, false);

                    writer.EndElement();
                    #endregion
                }
                if (hasLimitItem)
                    writer.EndElement();
                #endregion
                writer.EndElement();
                #endregion

            }
            if (hasLimit)
                writer.EndElement();
            #endregion


        }

        private void WriteCause(Causes causes, bool strict, bool ok)
        {
            //  writer.StartElement("causes");
            foreach (CauseItem cause in causes.getCauses(strict, ok, ok))
            {
                string str = "cause";
                if (strict)
                    str += "strict";
                if (!ok)
                    str += "nok";
                writer.StartElement(str);


                writer.SetAttribute("type", cause.type);
                writer.SetAttribute("val", cause.val);


                var lim = cause.limit as LimitItem;


                #region item
                //  writer.StartElement("i");
                writer.SetAttribute("name", lim.ToString());
                if (Conf.Html.trackCauseItemDetail)
                {
                    var sb = new StringBuilder();
                    lim.writeStatHeader(sb);
                    lim.Stat.Total.buildValues(sb);
                    writer.SetAttribute("stats", sb.ToString());
                }

                //   writer.EndElement();
                #endregion


                writer.EndElement();
            }
            //     writer.EndElement();
        }
        public void WriteTracksPost()
        {
            if (Conf.Html.writeCause > 0)
            {
                if (dir.Parent == null)
                {
                    int nbMax = Conf.Html.writeCause;
                    int nb = 0;
                    #region nonretenus
                    writer.StartElement("exclus");
                    var list = dir.CauseRegister.getList(true);
                    foreach (Causes causes in list)
                    {
                        nb++;
                        if (nb > nbMax)
                            break;
                        var track = causes.candidat;
                        writer.StartElement("t");
                        writer.SetAttribute("date", track.Pub);
                        if (track.Pub2 > track.Pub)
                            writer.SetAttribute("pub2", track.Pub2);
                        writer.SetAttribute("album", track.Album);
                        writer.SetAttribute("l", (track.Rating / 20).ToString());
                        writer.SetAttribute("track", track.Name);

                        WriteCause(causes, true, true);
                        WriteCause(causes, true, false);

                        WriteCause(causes, false, true);
                        WriteCause(causes, false, false);
                        writer.EndElement();
                    }
                    writer.EndElement();
                    #endregion
                }
            }
            writer.EndElement();

        }

        public void SelectionPre()
        {
            if (dir.SelectionPre)
                selection();
        }

        public void SelectionPost()
        {
            if (!dir.SelectionPre)
                selection();
        }

        private void selection()
        {

            //log.log("{0} Selection", dir);

            for (int i = dir.Cascading ? Limits.NB - 1 : 0; ((i >= 0 && dir.Cascading) || (i < Limits.NB && !dir.Cascading)); i = dir.Cascading ? i - 1 : i + 1)
            {
                var limit = limites[i];
                limit.Selection();

            }

        }

        public override string ToString()
        {
            return dir.ToString();
        }

    }
}]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\DirConf.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.podcast.Report;
using pdb.util;
using pdb.podcast.Load;
using pdb.podcast.Auto;
using pdb.podcast.Selection;
using System;

namespace pdb.podcast.Tuning
{
    /// <summary>
    /// Répertoire de pistes
    /// </summary>
    public class DirConf : LimitItemBase, IEnumerable<DirConf>//, IBuilderSource, IBorder
    {
        /// <summary>
        /// logger
        /// </summary>
        private Logger log;
        /// <summary>
        /// Limites associées au noeud
        /// </summary>
        private Limits limites;
        /// <summary>
        /// Nom du répertoire
        /// </summary>
        private string name = "";

        /// <summary>
        /// Sous-répertoires
        /// </summary>
        private List<DirConf> childs = new List<DirConf>();

        /// <summary>
        /// Répertoire parent
        /// </summary>
      new  private DirConf parent;

        /// <summary>
        /// Stats
        /// </summary>
        private DirStat stat;
        internal DirStat Stat { set { stat = value; } get { return stat; } }
        internal TrackConteneur Conteneur { get { return conteneur; } }

        private CauseRegister _causeRegister;
        internal CauseRegister CauseRegister
        {
            get
            {
                if (_causeRegister != null)
                    return _causeRegister;
                if (parent == null)
                    return null;
                return parent.CauseRegister;
            }
        }

        private Feeds feeds;
        internal Feeds Feeds
        {
            get
            {
                if (feeds != null)
                    return feeds;
                if (parent == null)
                    return null;
                return parent.Feeds;
            }
        }


        /// <summary>
        /// Ajout d'un sous-répertoire
        /// </summary>
        /// <param name="dir"></param>
        public void addChild(DirConf dir)
        {
            if (childs.Contains(dir))
                return;
            childs.Add(dir);

        }
        public DirConf Parent
        {
            get { return parent; }
        }

        public bool isChildOf(DirConf dir)
        {
            if (dir == this)
                return true;
            if (parent == null)
                return false;
            return parent.isChildOf(dir);
        }

        /// <summary>
        /// Conteneur des pistes
        /// </summary>
        private TrackConteneur conteneur;

        private FeedsLoader loader;
        internal FeedsLoader Loader
        {
            get
            {
                if (loader == null)
                    loader = new FeedsLoader(this);
                return loader;
            }

        }

      

        public void buildLoaders(List<LimitItemLoader> list, AutoBuilder auto)
        {
            if (auto != Auto)
                return;
            var loader = Loader;
            var fl = loader.LimitsLoader;
            fl.getLoaders(list);
            foreach (DirConf sub in childs)
            {
                sub.buildLoaders(list, auto);
            }
        }

        /// <summary>
        /// Enregistrement d'une piste
        /// </summary>
        /// <param name="track">piste</param>
        /// <param name="provider">item de limite</param>
        public void recordTrack(TrackInfoItunes track, LimitItem limit)
        {
            if (offset > DateTime.MinValue)
            {
                track.Offset = offset;
                offset = offset.AddDays(1);
            }
            conteneur.recordTrack(track, limit);
            if (parent != null)
                parent.recordTrackFromChild(track, limit, this);
        }

        //public void recordTrackStandAlone(TrackInfoItunes track, LimitItem limit)
        //{
        //    conteneur.recordTrackStandAlone(track, limit);
        //}

        /// <summary>
        /// Récupération de la liste des pistes
        /// </summary>
        /// <returns></returns>
        public List<TrackInfoItunes> getListe()
        {
            var list = conteneur.getListe();
            if (Histo)
                list.Sort(new PodCastComparerPub2());
            else
                list.Sort(new PodCastComparerInv());
            log.log("");
            log.log(getPath() + " getListe " + list.Count + " elt.");
            foreach (TrackInfoItunes track in list)
            {
                log.log(track.ToString());
            }
            return list;
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, DirConf dirSource)
        {
            if (dirSource.transmitToParent)
                Loader.recordTrackFromChild(track, itemSource, dirSource.transmitTotal);
            if (parent != null)
                parent.recordTrackFromChild(track, itemSource, this);
        }

        /// <summary>
        /// Abandonné
        /// </summary>
        public void TransmissionListToParent(TrackInfoItunes track)
        {
        }


        //public void recordTrackForStats(TrackInfoItunes track, LimitItem provider)
        //{
        //    conteneur.recordTrackForStats(track, provider);
        //}








        public Limits Limites { get { return limites; } set { limites = value; } }


        private static Dict<string, DirConf> dict = new Dict<string, DirConf>();
        public static DirConf getDir(Limits limites, string name, DirConf parent)
        {
           return new DirConf(limites, name, parent); 
            //string path = getPath(parent, name);


            //var d = dict[path];
            //if (d == null)
            //{
            //    d = new DirConf(limites, name, parent);
            //    dict[path] = d;
            //}
            //else
            //{
            //    d.init(limites, name, parent);
            //}

            //return d;

        }


        private DirConf(Limits limites, string name, DirConf parent)
            : base()
        {
            init(limites, name, parent);
        }

        private void init(Limits limites, string name, DirConf parent)
        {
            this.name = name;
            this.limites = limites;
            limites.Parent = this;
            this.parent = parent;
            this.setParent(parent);
            this.log = Logger.getLogger(getPath() + "\\dir", false);
            if (parent == null)
            {
                conteneur = new TrackConteneur(this, null, log);
                feeds = new Feeds();
                if (Conf.Html.writeCause <= 0)
                {
                    _causeRegister = new NullRegister();
                }
                else
                    _causeRegister = new CauseRegister();
            }
            else
                conteneur = new TrackConteneur(this, parent.conteneur, log);
            transmitToParent = Conf.Transmit;
            transmitTotal = Conf.TransmitTotal;
            transmitTotalGuest = Conf.TransmitTotalGuest;
            cascading = Conf.Cascading;
        }

        ///// <summary>
        ///// durée max de chaque item
        ///// </summary>
        //public float Duration
        //{
        //    set { duration = value; }
        //    get
        //    {
        //        if (parent == null || duration < int.MaxValue)
        //        {
        //            return duration;
        //        }
        //        return parent.Duration;

        //    }
        //}

        /// <summary>
        /// Répertoire de type Info
        /// </summary>
        public bool? Info
        {
            get
            {
                if (name == "info")
                    return true;
                if (name == "PAS Info")
                    return false;
                if (parent == null)
                    return null;
                return parent.Info;
            }
        }

        /// <summary>
        /// Répertoire de type rare
        /// </summary>
        public bool? Rare
        {
            get
            {
                if (name == "RARE")
                    return true;
                if (name == "PAS RARE")
                    return false;
                if (parent == null)
                    return null;
                return parent.Rare;
            }
        }

        /// <summary>
        /// Répertoire de type historique
        /// </summary>
        public bool Histo
        {
            get
            {
                if (name == "Histo")
                    return true;
                if (parent == null)
                    return false;
                return parent.Histo;
            }
        }

        private bool serial;
        public bool Serial { get { return serial; } set { serial = value; } }

        /// <summary>
        /// Généralisation de l'historique à tous les noeuds enfant ou simple sélection nominative(par album)
        /// </summary>
        private bool? histoAll;
        public bool? HistoAll
        {
            get
            {
                if (histoAll.HasValue)
                    return histoAll;
                if (parent == null)
                    return null;
                return parent.HistoAll;
            }
            set
            {
                histoAll = value;
            }
        }

        private bool? cascading;
        public bool Cascading
        {
            get
            {
                if (cascading.HasValue)
                    return cascading != false;
                if (false == histoAll)
                    return false;
                if (parent == null)
                    return true;
                return parent.Cascading;
            }
            set
            {
                cascading = value;
            }
        }

        private bool? selectionPre;
        public bool SelectionPre
        {
            get
            {
                if (selectionPre.HasValue)
                    return selectionPre != false;
                if (false == selectionPre)
                    return false;
                if (parent == null)
                    return false;
                return parent.SelectionPre;
            }
            set
            {
                selectionPre = value;
            }
        }

        private bool transmitToParent = true;
        public bool TransmitToParent { get { return transmitToParent; } set { transmitToParent = value; } }

        private bool transmitTotal = true;
        public bool TransmitTotal { get { return transmitTotal; } set { transmitTotal = value; } }

        private bool transmitTotalGuest = true;
        public bool TransmitTotalGuest { get { return transmitTotalGuest; } set { transmitTotalGuest = value; } }



        /// <summary>
        /// Arbre généalogique du répertoire permettant de situer les listes à modifier
        /// </summary>
        public List<string> Folders
        {
            get
            {

                if (parent == null)
                    return new List<string> { name };
                var list = parent.Folders;
                list.Add(name);
                return list;

            }

        }
        public string Name { get { return name; } }

        /// <summary>
        /// Représentation du chemin depuis le root
        /// </summary>
        /// <returns></returns>
        public string getPath()
        {
            return getPath(parent, name);
        }

        public static string getPath(DirConf parent, string name)
        {
            if (parent == null)
                return name;
            string path = parent.getPath();
            if (string.IsNullOrEmpty(path))
                return name;
            return path + "\\" + name;
        }



        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            //sb.Append(" ");
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            //sb.Append(limites.ToString());
            return sb.ToString();
            // return getPath() + " " + Environment.NewLine + limites.ToString();
        }

        public string display()
        {
            var sb = new StringBuilder();
            sb.Append(getPath());
            sb.AppendLine();
            ////double size = total / (1024.0 * 1024.0);
            ////sb.Append(size.ToString("0.##")); 
            ////sb.AppendLine();
            sb.Append(limites.ToString());
            return sb.ToString();
        }



        public IEnumerator<DirConf> GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return childs.GetEnumerator();
        }

        public List<LimitItem> getAllListItems()
        {
            var list = new List<LimitItem>();
            buildListLimitItems(list);
            return list;
        }

        protected void buildListLimitItems(ICollection<LimitItem> depot)
        {
            foreach (DirConf sub in this)
                sub.buildListLimitItems(depot);
            foreach (Limit limit in limites)
            {
                foreach (LimitItem item in limit.Items)
                    depot.Add(item);
            }
        }

        #region ITrackReport Members

        /// <summary>
        /// Rapport
        /// </summary>
        /// <param name="sb"></param>
        public void rapport(DescBuilder sb)
        {
            sb.beginLine();

            conteneur.rapport(sb);
            sb.AppendLine();


            if (!LimitItem.includeDetail)
                return;
            foreach (DirConf sub in childs)
            {
                var descBuilder = sb.createChild(sub.getPath());
                sub.rapport(descBuilder);
            }

        }
        public double getTotalSize()
        {
            return conteneur.getTotalSize();
        }





        #endregion

        #region IBuilderSource
        public List<TrackInfoItunes> getSelectedTracks()
        {
            var items = new List<TrackInfoItunes>(conteneur.Tracks.Total.Use.List);
            if (Histo)
                items.Sort(new PodCastComparerPub2());
            else
                items.Sort(new PodCastComparerInv());
            return items;
        }

        public IDictionary<string, TrackInfoItunes> getAllTracks()
        {
            return Feeds.LoadedTracks;
        }


        public string getEmpreinte()
        {
            return conteneur.Tracks.Total.Use.getEmpreinte();
        }


        private AutoBuilder auto;
        public AutoBuilder Auto
        {
            get
            {
                if (auto != null)
                    return auto;
                if (parent != null)
                    return parent.Auto;
                return null;
            }
            set
            {
                auto = value;
            }
        }
        #region IBorder
        private List<AutoBuilder> borderObs = new List<AutoBuilder>();
        public void addBorderObs(AutoBuilder auto)
        {
            borderObs.Add(auto);
        }
        #endregion
        #endregion

        public void signal(TrackBorderItem tb)
        {
            if (false == HistoAll)
                return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(tb);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(tb);
        }


        public bool canSignal()
        {
            return true; 
            //if (false == HistoAll || serial) //OUAILLE?
            //    return false;
            //return true; 
        }

        public void signal(CauseDatas cd)
        {
            //if (false == HistoAll || serial) //OUAILLE?
            //    return;
            bool _checked = false;
            foreach (AutoBuilder border in borderObs)
            {
                border.signal(cd);
                if (border.Checked)
                    _checked = true;
            }

            if (_checked)
                return;
            if (parent != null)
                parent.signal(cd);
        }
    }
}
]]></content>
  </file>
</db>
