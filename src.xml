<db path="C:\Bernard\db1\PieceDb3Ref">
   <file path="\engine\vlc\pdb.player.engine.vlc.pluginI\VlcWrapper.cs">
    <content><![CDATA[using AXVLC;
using pdb.util;
using System;
using pdb.obj;
using System.Threading;
using System.Text.RegularExpressions;
using System.IO;
using System.Globalization;

namespace pdb.player.engine.vlc.pluginI
{
    public class VlcWrapper : IPlayerEngine
    {

        private Logger logger;
#if NONI
        private VLCPlugin2Class vlc;
        Equalization eq = Equalization.Instance; 
#else
        private VLCPlugin2 vlc;
#endif
        public event EventHandler mediaEndReached;
        // public static VlcWrapper Instance = new VlcWrapper();
        public VlcWrapper()
        {
            logger = Logger.getLogger("vlc");
            try
            {
#if NONI
          vlc = new VLCPlugin2Class();
     //     vlc.setVariable(Equalization.VARGAIN, eq.getVarGain());
     //     vlc.setVariable(Equalization.VARFREQ, eq.getVarFreq()); 
                
#else
                vlc = new VLCPlugin2();


#endif
            }
            catch (Exception e)
            {
                logger.log("impossible de récupérer vlc " + e.ToString());
            }

            catch
            {
            }

#if NONI
            vlc.DVLCEvents_Event_pause += vlc_DVLCEvents_Event_pause;
            vlc.DVLCEvents_Event_play += vlc_DVLCEvents_Event_play;
            vlc.DVLCEvents_Event_stop += vlc_DVLCEvents_Event_stop;
            
#else
            vlc.MediaPlayerEncounteredError += vlc_MediaPlayerEncounteredError;
            vlc.MediaPlayerEndReached += vlc_MediaPlayerEndReached;
            vlc.pause += new DVLCEvents_pauseEventHandler(vlc_pause);
            vlc.AutoLoop = false;
            vlc.AutoPlay = false;

#endif
        }

        void vlc_pause()
        {
            log("vlc_pause");
        }

        #region event
        void vlc_MediaPlayerEndReached()
        {
            vlc.playlist.stop();
            log("vlc_MediaPlayerEndReached");
            if (mediaEndReached != null)
                mediaEndReached(this, EventArgs.Empty);
        }

        void vlc_MediaPlayerEncounteredError()
        {
            log("vlc_DVLCEvents_Event_stop");
        }

        void vlc_DVLCEvents_Event_stop()
        {
            log("vlc_DVLCEvents_Event_stop");
        }

        void vlc_DVLCEvents_Event_play()
        {
            log("vlc_DVLCEvents_Event_play");
        }

        void vlc_DVLCEvents_Event_pause()
        {
            log("vlc_DVLCEvents_Event_pause");
        }

        private void log(string txt)
        {
            logger.log(txt);
        }
        #endregion

        #region commande
        string location;
        public void play(string location, bool reload)
        {
            if (reload || location != this.location)
            {
                this.location = location;
#if NONI
                vlc.playlistClear();
                vlc.addTarget(new Uri(location).AbsoluteUri, null, VLCPlaylistMode.VLCPlayListReplaceAndGo, 0);
#else
                vlc.playlist.items.clear();
                vlc.playlist.add(new Uri(location).AbsoluteUri);
#endif
            }
#if NONI
            vlc.play();
#else
            vlc.playlist.play();
#endif
        }

        public void pause()
        {
#if NONI
            vlc.pause();
#else
            vlc.playlist.pause();
#endif
        }

        public void stop()
        {
#if NONI
            vlc.stop();
#else
            vlc.playlist.stop();
#endif
        }

        public TimeSpan Duration
        {
            get
            {
                var input = vlc.input;
                if (input == null)
                    return new TimeSpan();
                return TimeSpan.FromMilliseconds(input.Length);
            }
        }

        public TimeSpan Elapsed
        {
            get
            {
                var input = vlc.input;
                if (input == null)
                    return new TimeSpan();
                return TimeSpan.FromMilliseconds(input.Time);
            }
        }

        public double Position
        {
            get
            {

                var input = vlc.input;
                if (input == null)
                    return 0;
                return input.Position;
            }

            set
            {
                var input = vlc.input;
                if (input == null)
                    return;
                input.Position = value;
            }
        }

        public double Volume
        {
            set
            {

                vlc.Volume = (int)(200 * value);
            }

            get
            {
                return 200 * vlc.Volume;
            }
        }

        #endregion

        #region equalizer
        #endregion





        private playerstate state = playerstate.stop;
        public playerstate State
        {
            get { return state; }
        }

        private void insist(string phase, Action action)
        {
            int nb = 0;
            while (true)
            {
                vlc.Volume = 0;
                vlc.playlist.play();
                try
                {
                    action();
                    if (nb > 0)
                        misc.log(phase + " " + nb.ToString());
                    nb = 0;
                    return;
                }
                catch (Exception ex)
                {
                    nb++;
                    Thread.Sleep(1000);
                    if (nb >= 4)
                    {
                        misc.log("abandon " + phase + " " + nb.ToString());
                        return;
                    }
                }
            }
        }

        public void load(ITrackMetaData track)
        {
            vlc.playlist.items.clear();
            vlc.playlist.add(new Uri(track.Location).AbsoluteUri);
            vlc.Volume = 0;
            vlc.playlist.play();

            while (!vlc.playlist.isPlaying)
                Thread.Sleep(100);
            // vlc.playlist.pause();


            vlc.playlist.play();
            vlc.Volume = 0;
            if (string.IsNullOrEmpty(track.Album))
            {
                insist("Album", () =>
                    {
                        var album = vlc.mediaDescription.album;
                        if (album != null)
                        {
                            track.Album = album;

                        }

                    });
            }
            if (string.IsNullOrEmpty(track.Artist))
                insist("Artist", () => track.Artist = vlc.mediaDescription.artist);
            insist("Duration", () => track.Duration = Duration);
            if (string.IsNullOrEmpty(track.Name))
                insist("Name", () => track.Name = vlc.mediaDescription.title);
            if (track.TrackNumber <= 0)
            {
                insist("TrackNumber", () =>
                {
                    string tn = vlc.mediaDescription.trackNumber;

                    if (!string.IsNullOrEmpty(tn))
                    {
                        try
                        {
                            track.TrackNumber = Convert.ToInt32(tn);
                        }
                        catch
                        {
                        }
                    }
                });
            }
            if (track.Year <= 0)
            {
                insist("Year", () =>
                {

                    string date = vlc.mediaDescription.date;
                    DateTime dateC = DateTime.MinValue;
                    if (!string.IsNullOrEmpty(date))
                    {
                        try
                        {
                            track.Year = Convert.ToInt32(date);
                        }
                        catch
                        {
                        }
                    }
                });
            }







        }



    }
}
]]></content>
  </file>
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log;
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init("pdb.player");
                log = Logger.getLogger("Program");

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                export = CConf.Export;
                import = CConf.Import; 
                gen = new Consolid();
                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);
                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni(); 
                Db.loadData();

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                thLoop = new Thread(loop);
                thLoop.Start();
                MemUtil.Start();
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        public static void go()
        {
            lock (_lock)
            {
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList());
            gen.buildMusique();
            gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            gen.timeRanking();
            gen.eraseGrouping();
            // gen.writeComment();
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            gen.CommentGo = true;
            gen.GroupinGO = true;
            PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual; 
        }

        private static void _go()
        {           
            try
            {
                gen.CommentGo = false;
                gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                if (__end || __go) return;

                gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
            //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                gen.MakeConsolid(Db.List.getList()); //   bib.Musique.Tracks);
                if (__end || __go) return;

                gen.timeRanking();
                if (__end || __go) return;



                if (__end || __go) return;
                ChronoData.DateAuto = true;

                //if (refresh != null)
                //    refresh(PHASE1, EventArgs.Empty);

                if (__end || __go) return;
                bib.Aborted = false;
                ListWriterMgr.Async = false;
                //listWriter = new ListWriter(root);
                try
                {
                    CConf.loadConf();
                }
                catch (Exception ex)
                {
                    log.log(ex.ToString());
                }
                gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                gen.createRot(CConf.ListBase, App.bib);
                if (refresh != null)
                    refresh(PHASE1, EventArgs.Empty);

                if (__end || __go) return;
                gen.writeComment();
                if (__end || __go) return;
                gen.writeGrouping();
                if (refresh != null)
                    refresh(PHASE2, EventArgs.Empty);

                if (__end || __go) return;

                gen.CommentGo = true;
                gen.GroupinGO = true;


                gen.CommentGo = true;
                gen.GroupinGO = true;
                //if (refresh != null)
                //    refresh(PHASE2, EventArgs.Empty);
               // _refresh = true;
                gen.builStats();
                //bib = new BibViewModel(Db.Root); 
                //gen.createRot(CConf.ListBase, bib);
                //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                gen.CommentGo = true;
                gen.GroupinGO = true;




            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                if (refresh != null)
                    refresh(PHASE2, EventArgs.Empty);
                ExportCmd.CalculExport();
            }


        }

        public static event EventHandler refresh;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            App.bib.Aborted = true;
            Db.WriteDB1();
            Db.WriteDB2();
            App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.Track);
            if (l == null)
                return null;
            foreach (ITrackMetaData p in l)
            {

                TrackListViewModel trackList = PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export; 
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog(); 
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir; 
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\pdb.player.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{4166FA60-B33F-4496-9352-EDD8F3214021}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.player</RootNamespace>
    <AssemblyName>pdb.player</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <TargetFrameworkProfile>
    </TargetFrameworkProfile>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE;DEBUG;NONI</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.player.exe.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>pdb.player.App</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Interop.AXVLC, Version=1.0.0.0, Culture=neutral, processorArchitecture=x86">
      <SpecificVersion>False</SpecificVersion>
      <EmbedInteropTypes>False</EmbedInteropTypes>
      <HintPath>bin\Interop.AXVLC.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
    </Compile>
    <Compile Include="model\Equalization.cs" />
    <Compile Include="ViewModel\AllTracksViewModel.cs" />
    <Compile Include="ViewModel\BibViewModel.cs" />
    <Compile Include="ViewModel\BibViewModelBase.cs" />
    <Compile Include="ViewModel\Commande\CommandeBase.cs" />
    <Compile Include="ViewModel\Commande\CreateListCmd.cs" />
    <Compile Include="ViewModel\Commande\DeleteCmd.cs" />
    <Compile Include="ViewModel\Commande\ImportCmd.cs" />
    <Compile Include="ViewModel\Commande\InfoCmd.cs" />
    <Compile Include="ViewModel\Commande\Link\LinkRegister.cs" />
    <Compile Include="ViewModel\Commande\Link\RecordFather.cs" />
    <Compile Include="ViewModel\Commande\Play.cs" />
    <Compile Include="ViewModel\Commande\PlayList\AddToList.cs" />
    <Compile Include="ViewModel\Commande\PlayList\CheckCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCmd.cs" />
    <Compile Include="ViewModel\Commande\PlayList\ExportCompress.cs" />
    <Compile Include="ViewModel\Commande\PlayList\PlayListCommande.cs" />
    <Compile Include="ViewModel\Commande\RecordClassement.cs" />
    <Compile Include="ViewModel\DetailAlbumViewModel.cs" />
    <Compile Include="ViewModel\DetailClassementViewModel.cs" />
    <Compile Include="ViewModel\gen\ListWriter.cs" />
    <Compile Include="ViewModel\InfoViewModel.cs" />
    <Compile Include="ViewModel\Interfaces.cs" />
    <Compile Include="ViewModel\PieceViewModel.cs" />
    <Compile Include="ViewModel\PlayerViewModel.cs" />
    <Compile Include="ViewModel\StatItemViewModel.cs" />
    <Compile Include="ViewModel\TrackListViewModel.cs" />
    <Compile Include="ViewModel\PlayListViewModel.cs" />
    <Compile Include="ViewModel\ViewModelBase.cs" />
    <Compile Include="Vue\Adorn\AdornedControl.cs" />
    <Compile Include="Vue\Adorn\AdornerPlacement.cs" />
    <Compile Include="Vue\Adorn\FrameworkElementAdorner.cs" />
    <Compile Include="Vue\AlbumCtl.xaml.cs">
      <DependentUpon>AlbumCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BarAdorner.cs" />
    <Compile Include="Vue\BibCtl.xaml.cs">
      <DependentUpon>BibCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\BrowsePlayList.xaml.cs">
      <DependentUpon>BrowsePlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ClassementCtl.xaml.cs">
      <DependentUpon>ClassementCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfExport.xaml.cs">
      <DependentUpon>ConfExport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\ConfImport.xaml.cs">
      <DependentUpon>ConfImport.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\DataGridPlayList.xaml.cs">
      <DependentUpon>DataGridPlayList.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialog.xaml.cs">
      <DependentUpon>FolderBrowserDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\FolderBrowserDialogW.xaml.cs">
      <DependentUpon>FolderBrowserDialogW.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\getNb.xaml.cs">
      <DependentUpon>getNb.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Info.xaml.cs">
      <DependentUpon>Info.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\PlayerControler.xaml.cs">
      <DependentUpon>PlayerControler.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StatCtl.xaml.cs">
      <DependentUpon>StatCtl.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StateBar.xaml.cs">
      <DependentUpon>StateBar.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\StringDialog.xaml.cs">
      <DependentUpon>StringDialog.xaml</DependentUpon>
    </Compile>
    <Compile Include="Vue\Util\BaseConverter.cs" />
    <Compile Include="Vue\Util\StringFormatConverter.cs" />
    <Compile Include="Vue\Util\Utils.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Player.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Player.xaml.cs">
      <DependentUpon>Player.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Page Include="Vue\AlbumCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BibCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\BrowsePlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ClassementCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfExport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\ConfImport.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\DataGridPlayList.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\FolderBrowserDialogW.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\getNb.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Page Include="Vue\Info.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\PlayerControler.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StatCtl.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StateBar.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
    <Page Include="Vue\StringDialog.xaml">
      <SubType>Designer</SubType>
      <Generator>MSBuild:Compile</Generator>
    </Page>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="app.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <AppDesigner Include="Properties\" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\engine\pdb.player.engine.build\pdb.player.engine.build.csproj">
      <Project>{0F3BC2CF-E69D-4019-B6EA-A4B50A7FEB54}</Project>
      <Name>pdb.player.engine.build</Name>
    </ProjectReference>
    <ProjectReference Include="..\engine\pdb.player.engine\pdb.player.engine.csproj">
      <Project>{778B94A9-80ED-4440-9AC3-7E6E6F4AD49D}</Project>
      <Name>pdb.player.engine</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823d1d-851c-456b-ac4c-b0beec173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{c2b34ca9-3bb2-464f-8691-5f5b7cb2b997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Consolid\pdb.gen.csproj">
      <Project>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</Project>
      <Name>pdb.gen</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.Db\pdb.db.csproj">
      <Project>{43D27B47-E615-451D-AD25-67C5B8447C4A}</Project>
      <Name>pdb.db</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Vue\images\Toolbar-MP3-Forward-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Pause-icon.png" />
    <Resource Include="Vue\images\Toolbar-MP3-Play-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Rewind-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
    <Resource Include="Vue\images\Toolbar-MP3-Stop-icon.png">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Resource>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Interfaces.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.ComponentModel;
using pdb.gen.Tuning;

namespace pdb.player.ViewModel
{
    interface ItrackProvider : ISelectedTracks
    {
        ICollectionView PresentationTracks { get; }
        PlayListViewModel PlayList { get; }
        void Focus(int index);
        void doFilter(string filter);
    }

    interface ISelectedTracks
    {
        List<TrackListViewModel> SelectedTracks { get; }
    }
    public interface IName
    {
        string Name { get; set; }
    }

    interface IIhm
    {
        void InfoIHm(string message, string caption);
        bool Confirm(string question, string caption);
        bool? TriChoix(string question, string caption);
        Export getConfExport(string question);
        Import getConfImport(string question); 
       // int getNb(string question);
        string folderDialog();
        bool changeName(string title, IName data);
        PlayListViewModel selectPlayList(string title); 
    }
    interface IExportTracks : IIhm
    {
        //List<TrackListViewModel> ListTrack { get; }
        PlayListViewModel PlayList { get; }

    }

    interface IRedraw
    {
        void redraw();
    }

}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\ImportCmd.cs">
    <content><![CDATA[using System.IO;
using pdb.db.obj;
using pdb.obj;
using pdb.player.engine;
using pdb.db.piece.data;
using System;
using pdb.db;
using System.Text.RegularExpressions;
using pdb.gen.pertinence;
using pdb.gen.Tuning;

namespace pdb.player.ViewModel.Commande
{
    class ImportCmd : CommandeBase
    {
        private IIhm ihm;
        //  public static IIhm Ihm { set { ihm = value; } }
        private IPlayerEngine player;
        //public static IPlayerEngine Player { set { player = value; } }
        CListPiece list;

        private int nbImport;
        private int nbFile;
        private Import conf; 

        public ImportCmd(IIhm ihm, IPlayerEngine player)
        {
            this.ihm = ihm;
            this.player = player;
        }
        public override bool CanExecute(object parameter)
        {
            return true;
        }

        public override void Execute(object parameter)
        {
            conf = ihm.getConfImport("Import");
            string dir = conf.dir; 
            if (string.IsNullOrEmpty(dir))
                return;
            if (!ihm.Confirm("Importer le contenu de " + dir + " ?", "Import"))
                return;

            list = App.Db.List;

            ChronoData.refreshDate(DateTime.MinValue);
            ChronoData.DateAuto = false;
            nbImport = 0;
            nbFile = 0; 

            DirectoryInfo root = new DirectoryInfo(dir);
            import(root);
            ChronoData.DateAuto = true;
            ihm.InfoIHm(string.Format("importation de {0} terminée\r\n {1} fichier{2} importé{2} \r\n{3} fichier{4} pris en compte", dir, nbImport, (nbImport > 1 ? "s" : ""), nbFile, (nbFile > 1 ? "s" : "")), "Import");
        }

        private void import(DirectoryInfo dir)
        {
            if (dir.Name == "Podcasts")
                return;
            if (dir.Name.StartsWith("poubelle"))
                return;
            if (dir.Name == "hackit")
                return;
            if (dir.Name == "v1")
                return; 
            foreach (FileInfo f in dir.GetFiles())
                import(f);
            foreach (DirectoryInfo sub in dir.GetDirectories())
                import(sub);
        }

    
        private void import(FileInfo f)
        {
            if (f.IsMusic())
            {
                if (list.getPiece(f.FullName) != null)
                {
                //    App.log.log("emplacement déjà géré : {0}", f.FullName);
                    return;
                }

                App.log.log("chargement de " + f.FullName);
                var newT = new CPiece(f.FullName);
                var meta = new Metadata(f.FullName);
                meta.Album = conf.album;
                meta.Artist = conf.artist;
                if (conf.logical)
                {
                    TrackBuilder.buildFromFile(meta); 
                }
                else
                {
                    player.load(meta);
                }
                TrackBuilder.correction(meta);
                if (!string.IsNullOrEmpty(conf.album))
                {
                    meta.TrackNumber = nbFile + 1; 
                }
                TrackBuilder.buildFrom(newT, meta); 

               
                App.log.log("chargé {0} {1} {2} {3} {4}", newT.Year, newT.Artist, newT.Album, newT.Name, newT.TrackNumber);

                var org = list.getPiece(newT);
                if (org != null)
                {
                  //  App.log.log("référence déjà connue : {0} {1} {2} {3} {4} à l'emplacement {5}", org.Year, org.Artist, org.Album, org.Name, org.TrackNumber, org.Location);

                }


                list.Add(newT);
                if (org == null)
                {
                    newT.initClassementIfEmpty("0.0");
                    nbImport++;
                    App.log.log("importé {0} {1} {2} {3} {4} à l'emplacement {5}", newT.Year, newT.Artist, newT.Album, newT.Name, newT.TrackNumber, newT.Location); 
                }
                nbFile++;
                App.Db.saveAsync();
               
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfImport.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfImport"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:userCtl="clr-namespace:pdb.player.Vue"
        Title="Importer" Height="186" Width="453">
    <Grid Height="142" Width="435">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <userCtl:FolderBrowserDialog x:Name="folder" Grid.Row="0" />
          
        <Grid Grid.Row="1">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="182*" />
            </Grid.ColumnDefinitions>
            <Label Grid.Row="0" Grid.Column="0" >Artiste</Label>
            <TextBox Grid.Row="0" Grid.Column="1" Name="tb_artist" Width="200" />
            <Label Grid.Row="1" Grid.Column="0" >Album</Label>
            <TextBox Grid.Row="1" Grid.Column="1" Name="tb_album" Width="200"  />
            <Label Grid.Row="2" Grid.Column="0" >Logique</Label>
            <CheckBox Grid.Row="2" Grid.Column="1" Name="cb_logical" Width="200" Margin="0,6,0,-6" />
        </Grid> 
    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfImport.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using pdb.gen.Tuning;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfImport.xaml
    /// </summary>
    public partial class ConfImport : Window
    {
        private Import import; 
        public ConfImport()
        {
            InitializeComponent();
        }

        public ConfImport(string title, Import import)
            : this()
        {
            this.Title = title;
            this.import = import;
            this.Loaded += new RoutedEventHandler(ConfImport_Loaded);
            this.Closing += new System.ComponentModel.CancelEventHandler(ConfImport_Closing);
            folder.ok += new EventHandler(folder_ok);
            folder.cancel += new EventHandler(folder_cancel);
        }

        void folder_cancel(object sender, EventArgs e)
        {
            import.dir = null;
            Close(); 
        }

        void folder_ok(object sender, EventArgs e)
        {
            Close(); 
        }

        void ConfImport_Loaded(object sender, RoutedEventArgs e)
        {
            display(); 
        }

        void ConfImport_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            record() ; 
        }

        void display()
        {
            folder.Dir = import.dir;
            tb_album.Text = import.album;
            tb_artist.Text = import.artist;
            cb_logical.IsChecked = import.logical; 
           
        }
        void record()
        {
            import.dir = folder.Dir;
            import.album = tb_album.Text;
            import.artist = tb_artist.Text;
            import.logical = cb_logical.IsChecked.Value; 
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using pdb.gen.Tuning;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.util;
using pdb.player.Vue.Util;
using System.Windows.Threading;

namespace pdb.player.Vue
{
    public partial class DataGridPlayList : UserControl, ItrackProvider, IRedraw, IExportTracks
    {
        private static int nb;
        private int ID;
        private Logger log;
        private BgColorFormatConverter colorConvert = new BgColorFormatConverter();

        //  private BgDict<int, DataGridRow> dict = new BgDict<int, DataGridRow>(); 

        public DataGridPlayList()
        {
            ID = nb;
            log = Logger.getLogger("DataGridPlayList" + ID);
            nb++;
            InitializeComponent();
            this.Loaded += DataGridPlayList_Loaded;
            App.refresh += new EventHandler(App_refresh);
            PlayListCommande.Provider = this;
        }

        void App_refresh(object sender, EventArgs e)
        {
            log.log("dg::App_refresh");
            redraw();
        }

        //private void refresh()
        //{
        //    if (ID == 0)
        //    {
        //        init();
        //    }
        //}
        void DataGridPlayList_Loaded(object sender, RoutedEventArgs e)
        {
            init(null);
            PlayListViewModel.selectedPlaylistChange += PlayListViewModel_selectedPlaylistChange;
            PlayListViewModel.addDrow(this);

          //  TrackListViewModel.ExportStatusChange += tv_ExportStatusChanged; 
            ExportCmd.Ihm = this;
        }

        //void dg_RowEditEnding(object sender, DataGridRowEditEndingEventArgs e)
        //{
        //    e.Row.Background = colorConvert.getColor(sender as TrackListViewModel);
        //}


        void PlayListViewModel_selectedPlaylistChange(object sender, EventArgs e)
        {
            if (ID == 0)
            {
                init(sender as PlayListViewModel);
            }
        }

        private void init(PlayListViewModel old)
        {
            if (!Dispatcher.CheckAccess())
            {
                Dispatcher.Invoke(new Action<PlayListViewModel>(init));
                return;
            }
            log.log("dg::init");
            SortDescriptionCollection sort = null;
            ICollectionView view = null;
            if (old != null)
            {
                view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                if (view != null)
                    sort = view.SortDescriptions;
                if (sort != null)
                    old.Sort = sort;
            }


            var pl = PlayListViewModel.SelectedPlayList;
            var currentPlaying = TrackListViewModel.CurrentPlaying;
            if (pl == null)
                return;
            base.DataContext = null;

            var source = dg.ItemsSource;

            dg.ItemsSource = null;
            var items = pl.AlltracksVm;
            items.refresh();

            base.DataContext = items;
            int i = 0;
            if (pl.isSubList("gen"))
            {
            }
            else
            {
                foreach (TrackListViewModel track in items)
                {
                    i++;
                    track.Index = i;
                }
            }
            sort = pl.Sort;
            List<SortDescription> _sort = null;
            if (sort != null)
                _sort = new List<SortDescription>(sort);
            dg.ItemsSource = items;
            PlayerViewModel.Instance.set(this);
            TrackListViewModel.CurrentPlaying = currentPlaying;

            view = CollectionViewSource.GetDefaultView(dg.ItemsSource);

            if (_sort != null && _sort.Count > 0)
            {
                view.SortDescriptions.Clear();
                foreach (var _s in _sort)
                {
                    view.SortDescriptions.Add(_s);
                    foreach (DataGridColumn _c in dg.Columns)
                    {
                        if (_s.PropertyName == _c.SortMemberPath)
                        {
                            _c.SortDirection = _s.Direction;
                            break;
                        }
                    }
                    break;

                }
            }

            //foreach (TrackListViewModel tv in items)
            //    tv.PropertyChanged += new PropertyChangedEventHandler(tv_PropertyChanged);
          
            putExportTracks(pl, CollectionViewSource.GetDefaultView(dg.ItemsSource));

        }

        //void tv_PropertyChanged(object sender, PropertyChangedEventArgs e)
        //{
        //    if (e.PropertyName == "ExportStatus")
        //        updateColor(sender as TrackListViewModel); 
        //}

        //void updateColor(TrackListViewModel tv)
        //{
        //    if (tv == null)
        //        return; 
        //      var row = dg.ItemContainerGenerator.ContainerFromItem(tv) as DataGridRow;
        //      if (row != null)
        //          row.Background = colorConvert.getColor(tv); 
        //}

        //void tv_ExportStatusChanged(object sender, EventArgs e)
        //{          
        //        Dispatcher.BeginInvoke(DispatcherPriority.Background, new Action<TrackListViewModel>(updateColor), sender as TrackListViewModel);
           
        //}
        private void dg_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            try
            {
                var r = sender as DataGridRow;
                var t = r.Item as TrackListViewModel;
                PlayerViewModel.reset(this, t);
            }
            catch
            {
            }
        }

        private void dg_MouseClick(object sender, MouseButtonEventArgs e)
        {
            var r = sender as DataGridRow;
            var t = r.Item as TrackListViewModel;
            var l = new List<TrackListViewModel>();
            foreach (TrackListViewModel track in dg.SelectedItems)
                l.Add(track);
            lock (this)
                selectedTracks = l;
            TrackListViewModel.HumanSelected = t;
            startPoint = e.GetPosition(null);
        }

        private List<TrackListViewModel> selectedTracks = new List<TrackListViewModel>();

        private List<TrackListViewModel> SelectedTracks
        {
            get
            {
                lock (this)
                    return selectedTracks;
            }
        }
        ICollectionView ItrackProvider.PresentationTracks
        {
            get { return CollectionViewSource.GetDefaultView(dg.ItemsSource); }
        }
        void ItrackProvider.Focus(int index)
        {

            // dg.SelectedIndex = index;
            var indexbas = Math.Min(index + 100, dg.Items.Count - 1);
            scrol(indexbas);
            scrol(index);
        }

        List<TrackListViewModel> ISelectedTracks.SelectedTracks
        {
            get
            {
                return SelectedTracks;
            }
        }
        void scrol(int index)
        {
            if (!CheckAccess())
            {
                Dispatcher.Invoke(new Action<int>(this.scrol), index);
            }
            else
                dg.ScrollIntoView(dg.Items[index]);
        }
        public PlayListViewModel PlayList
        {
            get { return PlayListViewModel.SelectedPlayList; }
        }
        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter((this as ItrackProvider).PresentationTracks, filter);
        }
        private bool IsUserVisible(FrameworkElement element, FrameworkElement container)
        {
            if (!element.IsVisible)
                return false;
            Rect bounds = element.TransformToAncestor(container).TransformBounds(new Rect(0.0, 0.0, element.ActualWidth, element.ActualHeight));
            Rect rect = new Rect(0.0, 0.0, container.ActualWidth, container.ActualHeight);
            return rect.Contains(bounds.TopLeft) || rect.Contains(bounds.BottomRight);
        }

        public void redraw()
        {
            if (!CheckAccess())
            {
                Dispatcher.Invoke(new Action(this.redraw));
                return;
            }
            var pl = PlayListViewModel.SelectedPlayList;
            bool isgen = false;
            if (pl != null && pl.isSubList("gen"))
                isgen = true;

            var items = dg.ItemsSource as AllTracksViewModel;

            if (items == null)
            {
                dg.Items.Refresh();
            }
            else
            {
                ICollectionView view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                SortDescriptionCollection sort = view.SortDescriptions;

                List<SortDescription> _sort = null;
                if (sort != null)
                    _sort = new List<SortDescription>(sort);

                //items.refresh();
                int i = 0;
                foreach (TrackListViewModel track in items)
                {
                    i++;
                    if (!isgen)
                        track.Index = i;
                    track.refresh();
                }

                if (_sort != null && _sort.Count > 0 && view.SortDescriptions.Count > 0)
                {
                    view.SortDescriptions.Clear();
                    foreach (var _s in _sort)
                    {
                        view.SortDescriptions.Add(_s);



                    }
                }
                putExportTracks(pl, view);
            }
            return;


            try
            {
                isgen = false;

                if (isgen)
                {
                    log.log("dg::redraw::init");
                    init(pl);
                }
                else
                {
                    log.log("dg::redraw::Refresh");
                    dg.Items.Refresh();
                }
            }
            catch
            {
                try
                {
                    init(pl);
                }
                catch
                {
                }
            }

        }

        private void MenuItem_Click(object sender, RoutedEventArgs e)
        {
            var items = dg.SelectedItems;
            MessageBox.Show(items.Count.ToString());
        }

        public string folderDialog()
        {
            return App.Instance.folderDialog();
        }


        public System.ComponentModel.ICollectionView PresentationTracks
        {
            get
            {
                return ((ItrackProvider)this).PresentationTracks;
            }
        }






        public bool ModeAlbum
        {
            get { return MessageBox.Show("par albums complets", "export", MessageBoxButton.YesNo) == MessageBoxResult.Yes; }
        }

        public bool Continue
        {
            get { return MessageBox.Show("continuer le marché ?", "export", MessageBoxButton.YesNo) == MessageBoxResult.Yes; }
        }




        public void InfoIHm(string message, string caption)
        {
            App.Instance.InfoIHm(message, caption);
        }

        public bool Confirm(string question, string caption)
        {
            return App.Instance.Confirm(question, caption);
        }

        public bool? TriChoix(string question, string caption)
        {
            return App.Instance.TriChoix(question, caption);
        }

        public Export getConfExport(string question)
        {
            return App.Instance.getConfExport(question);
        }

        public Import getConfImport(string question)
        {
            return App.Instance.getConfImport(question);
        }

        public int getNb(string question)
        {
            return App.Instance.getNb(question);
        }

        public bool changeName(string title, IName data)
        {
            return App.Instance.changeName(title, data);
        }

        public PlayListViewModel selectPlayList(string title)
        {
            return App.Instance.selectPlayList(title);
        }



        //  private List<TrackListViewModel> list = new List<TrackListViewModel>(); 
        public List<TrackListViewModel> ListTrack
        {
            get { return null; }
        }

        private void putExportTracks(PlayListViewModel pl, ICollectionView view)
        {
            var list = new List<TrackListViewModel>();
            foreach (TrackListViewModel track in view)
                list.Add(track);
            pl.ExportTracks = list;

        }
        Point startPoint;
        private void dg_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            startPoint = e.GetPosition(null);
        }

        private void dg_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            var mousePos = e.GetPosition(null);
            var diff = startPoint - mousePos;

            if (Math.Abs(diff.X) > SystemParameters.MinimumHorizontalDragDistance
                || Math.Abs(diff.Y) > SystemParameters.MinimumVerticalDragDistance)
            {
                var treeView = sender as DataGrid;
                var treeViewItem = //(e.OriginalSource as DependencyObject).
                    Util.Util<DataGridRow>.FindAnchestor((DependencyObject)e.OriginalSource);
                //   FindAnchestor<TreeViewItem>((DependencyObject)e.OriginalSource);

                if (treeView == null || treeViewItem == null)
                    return;

                var folderViewModel = treeView.SelectedItem as TrackListViewModel;
                if (folderViewModel == null)
                    return;

                var dragData = new DataObject(folderViewModel);
                DragDrop.DoDragDrop(treeViewItem, dragData, DragDropEffects.Copy);
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\FolderBrowserDialog.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.FolderBrowserDialog"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             Height="40" Width="374"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <DockPanel Grid.Row="0"  Margin="3"  HorizontalAlignment="Stretch" >
            <TextBox Name="tb_path" Margin="5"  Width="200" DockPanel.Dock="Left" ToolTip="Répertoire de destination" />
            <Button Name="bt_browse" Margin="5" Width="40" Content="..." DockPanel.Dock="Left"  ToolTip="Parcourir"  Click="bt_browse_Click" />
            <Button Name="bt_Ok" Margin="5" Width="30" Content="Ok" Click="bt_Ok_Click" DockPanel.Dock="Right" />
            <Button Name="bt_Cancel" Margin="5" Width="40" Content="Cancel" Click="bt_Cancel_Click"  DockPanel.Dock="Right" />
        </DockPanel>
    </Grid>
</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\FolderBrowserDialog.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for FolderBrowserDialog.xaml
    /// </summary>
    public partial class FolderBrowserDialog : UserControl
    {
        public event EventHandler cancel;
        public event EventHandler ok;
        public FolderBrowserDialog()
        {
            InitializeComponent();
        }
        public FolderBrowserDialog(string dir)
            : this()
        {
            this.dir = dir;
        }

        private string dir;
        public string Dir
        {
            get { return dir; }
            set
            {
                if (dir != value)
                    dir = value;
                tb_path.Text = value;
            }
        }

        private void bt_browse_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new System.Windows.Forms.FolderBrowserDialog();

            dialog.SelectedPath = App.Db.DefaultFolder;
            System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            string dir = null;
            if (result == System.Windows.Forms.DialogResult.OK)
            {
                dir = dialog.SelectedPath;
                this.dir = dir;
                tb_path.Text = dir;
            }
        }

        private void bt_Ok_Click(object sender, RoutedEventArgs e)
        {
            this.dir = tb_path.Text;
            if (ok != null)
                ok(this, EventArgs.Empty);
        }

        private void bt_Cancel_Click(object sender, RoutedEventArgs e)
        {
            this.dir = null;
            tb_path.Text = null;
            if (cancel != null)
                cancel(this, EventArgs.Empty);
        }


    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\FolderBrowserDialogW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.FolderBrowserDialogW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:userCtl="clr-namespace:pdb.player.Vue"
        Title="FolderBrowserDialogW" Height="80" Width="400">
    <Grid>
        <userCtl:FolderBrowserDialog x:Name="folder" Grid.Row="0" />
    </Grid>
</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\FolderBrowserDialogW.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for FolderBrowserDialogW.xaml
    /// </summary>
    public partial class FolderBrowserDialogW : Window
    {
        
        public FolderBrowserDialogW()
        {
            InitializeComponent();          
        }

        public FolderBrowserDialogW(string path) : this()
        {
            InitializeComponent();
            folder.Dir = path; 
        }

        public string Dir { get { return folder.Dir; } }

        void FolderBrowserDialogW_Loaded(object sender, RoutedEventArgs e)
        {
            folder.ok += new EventHandler(folder_ok);
            folder.cancel += new EventHandler(folder_cancel);
        }

        void folder_cancel(object sender, EventArgs e)
        {
            Close(); 
        }

        void folder_ok(object sender, EventArgs e)
        {
            Close(); 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\pdb.gen.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{DFC524F3-50BB-40E3-BAC0-CA56950BBB5A}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.gen</RootNamespace>
    <AssemblyName>pdb.gen</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>false</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>false</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.gen.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="albums\Album.cs" />
    <Compile Include="albums\AlbumComparer.cs" />
    <Compile Include="albums\Albums.cs" />
    <Compile Include="albums\VirtualAlbumPiece.cs" />
    <Compile Include="CalcEquiv.cs" />
    <Compile Include="Consolid.cs" />
    <Compile Include="CLegacyListWriter.cs" />
    <Compile Include="CRank.cs" />
    <Compile Include="IListWriter.cs" />
    <Compile Include="ListPiece.cs" />
    <Compile Include="CPieceComparer.cs" />
    <Compile Include="ListSelection.cs" />
    <Compile Include="ListWriterMgr.cs" />
    <Compile Include="Math.cs" />
    <Compile Include="pertinence\TrackBuilder.cs" />
    <Compile Include="Piece.cs" />
    <Compile Include="CalcDate.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="stat\ClassStruct.cs" />
    <Compile Include="stat\Condenseur.cs" />
    <Compile Include="stat\DynamicStatBuilder.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="stat\MedianneValue.cs" />
    <Compile Include="stat\NewClassement.cs" />
    <Compile Include="stat\StatBuilder.cs" />
    <Compile Include="stat\StatConteneur.cs" />
    <Compile Include="TrackList.cs" />
    <Compile Include="Tuning\CConf.cs" />
    <Compile Include="Tuning\CConfQL.cs" />
    <Compile Include="Tuning\CConfSort.cs" />
    <Compile Include="Tuning\ConfGen.cs" />
    <Compile Include="Tuning\CTuning.cs" />
    <Compile Include="Tuning\Export.cs" />
    <Compile Include="Tuning\GroupingDisplay.cs" />
    <Compile Include="Tuning\Import.cs" />
    <Compile Include="Virtuel\VirtualPiece.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.ordo\pdb.ordo.csproj">
      <Project>{30823D1D-851C-456B-AC4C-B0BEEC173361}</Project>
      <Name>pdb.ordo</Name>
    </ProjectReference>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
    <ProjectReference Include="..\PieceDb.obj\pdb.obj.csproj">
      <Project>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</Project>
      <Name>pdb.obj</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
  <file path="\PieceDb.Consolid\pertinence\TrackBuilder.cs">
    <content><![CDATA[using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;
using pdb.obj;

namespace pdb.gen.pertinence
{
    public class TrackBuilder
    {
        private static Regex regDiese = new Regex(@"^#[0-9]+\ ");
        private static Regex regDiese2 = new Regex(@"[0-9]+\ #");
        private static Regex regDiese3 = new Regex(@"#\ [0-9]+");
        private static Regex regTrack1 = new Regex(@"(^[0-9]+)([^a-zA-Z]*)");
        private static TextInfo textInfo = new CultureInfo("fr-FR", false).TextInfo;

        private static Regex regNamePiste = new Regex(@"^Piste[^a-zA-Z]*[0-9]+");
        private static Regex regNameTrack = new Regex(@"^Track[^a-zA-Z]*[0-9]+");
        public static void correction(ITrackMetaData track)
        {
            string _album = "";
            string _name = "";
            int trackNumber = 0;

            var album = track.Album;
            if (!string.IsNullOrEmpty(album))
            {
                album = regDiese.Replace(album, "");
                album = regDiese2.Replace(album, "");
                album = regDiese3.Replace(album, "");
                album = album.Trim();
            }
            _album = album;

            if (!string.IsNullOrEmpty(track.Name))
                _name = track.Name; 

            var fname = Path.GetFileNameWithoutExtension(track.Location);
            if (regTrack1.IsMatch(fname))
            {
                string strTn = regTrack1.Match(fname).Groups[1].Value;
                var toDelete = regTrack1.Match(fname).Groups[0].Value;
                _name = _name.Replace(toDelete, "").Replace(strTn, "").Trim();

                int tn = -1;
                if (int.TryParse(strTn, out tn))
                    trackNumber = tn;

            }

            if (regNamePiste.IsMatch(_name) || regNameTrack.IsMatch(_name))
            {
                var __name = fname;
                if (regTrack1.IsMatch(fname))
                {
                    __name = regTrack1.Replace(fname, "");
                }

                _name = textInfo.ToTitleCase(__name);
            }

            //  if (string.IsNullOrEmpty(track.Album))
            track.Album = _album;
            //  if (string.IsNullOrEmpty(track.Name))
            track.Name = _name;
            //  if (track.TrackNumber <= 0)
            track.TrackNumber = trackNumber;

        }

        public static void buildFromFile(ITrackMetaData track)
        {
            FileInfo f = new FileInfo(track.Location);
            var fname = Path.GetFileNameWithoutExtension(track.Location);
            var fAlbum = f.Directory.Name;
            var fArtist = f.Directory.Parent.Name;
            int fTrackNumber = 0;


            if (regTrack1.IsMatch(fname))
            {
                string strTn = regTrack1.Match(fname).Groups[1].Value;
                var toDelete = regTrack1.Match(fname).Groups[0].Value;
                fname = fname.Replace(toDelete, "").Replace(strTn, "").Trim();

                int tn = -1;
                if (int.TryParse(strTn, out tn))
                    fTrackNumber = tn;

            }

            track.Name =textInfo.ToTitleCase( fname);
            track.TrackNumber = fTrackNumber;
            if (string.IsNullOrEmpty(track.Album))
                track.Album = textInfo.ToTitleCase( fAlbum);
            if (string.IsNullOrEmpty(track.Artist))
                track.Artist =textInfo.ToTitleCase( fArtist);
        }

        public static void buildFrom(ITrackMetaData pdb, ITrackMetaData media)
        {
            pdb.Album = media.Album;
            pdb.Artist = media.Artist;
            pdb.Name = media.Name;
            pdb.TrackNumber = media.TrackNumber;
            pdb.Year = media.Year; 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\CConf.cs">
    <content><![CDATA[using System;
using System.IO;
using System.Xml;
using pdb.gen.Tuning;
using pdb.ordo.conf;
using pdb.util;
using pdb.gen.albums;
namespace pdb.gen.conf
{
    public enum rankingType
    {
        middle = 0,
        up = 1,
        bottom = 2
    }

   
    public class CConf
    {
        private static volatile object _lock = new object(); 
        private const string CONF_FILE = @"..\pdb.conf.xml";
        private static string m_listBase = "classement";
        private static int m_before = 0;
        private static int m_after = 0;
        private static bool m_checkModifStrict = true;
        private static bool scan = false;
        private static string copyTo = "";
        private static bool copyModeFile = false;
        private static CConfSort m_sort = new CConfSort();
        private static int classementOffset = 0;
        private static rankingType _rankingType = rankingType.middle;
       // private static bool deleteFile;
        private static int maxTask = int.MaxValue; 

        private static CConfSort m_select = new CConfSort();
        private static ConfGen confGen = new ConfGen();

        private static bool removeVersions;
        private static bool condensation; 
       
       // private static int taskDelayError = -1;

        private static bool menage = false;

       
        private static bool ordonnancement; 

      //  private static DataConf dataConf;
        private static ConfOrdo ordoConf = new ConfOrdo(); 
     

        
        private static int volumeMin = -125;
        private static bool abortOpe;

        private static Export export = new Export();
        private static Import import = new Import(); 
       
     



        public static XmlElement loadConf()
        {
            lock (_lock)
            {
                misc.log("load conf");
                if (!File.Exists(CONF_FILE))
                    return null ;
                XmlDocument l_doc = new XmlDocument();
                l_doc.Load(CONF_FILE);
                XmlElement l_xmlRoot = l_doc.DocumentElement;
                XMLTool l_xmlConf = new XMLTool(l_xmlRoot);

                string l_str = l_xmlConf.getNodeValue("listBase");
                if (!string.IsNullOrEmpty(l_str))
                    m_listBase = l_str;

                l_str = l_xmlConf.getNodeValue("before");
                if (!string.IsNullOrEmpty(l_str))
                    m_before = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("after");
                if (!string.IsNullOrEmpty(l_str))
                    m_after = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("checkModifStrict");
                if (!string.IsNullOrEmpty(l_str))
                    m_checkModifStrict = Convert.ToBoolean(l_str);

                l_str = l_xmlConf.getNodeValue("scan");
                if (!string.IsNullOrEmpty(l_str))
                    scan = Convert.ToBoolean(l_str);

                l_str = l_xmlConf.getNodeValue("copyTo");
                if (!string.IsNullOrEmpty(l_str))
                {
                    copyTo = l_str;
                    l_str = l_xmlConf.getAttValue("copyTo", "copyModeFile");
                    if (!string.IsNullOrEmpty(l_str))
                        copyModeFile = Convert.ToBoolean(l_str);
                }

                l_str = l_xmlConf.getNodeValue("classementOffset");
                if (!string.IsNullOrEmpty(l_str))
                    classementOffset = Convert.ToInt32(l_str);
                l_str = l_xmlConf.getNodeValue("rankingType");
                if (!string.IsNullOrEmpty(l_str))
                    _rankingType = (rankingType)Enum.Parse(typeof(rankingType), l_str);

              

                l_str = l_xmlConf.getNodeValue("maxTask");
                if (!string.IsNullOrEmpty(l_str))
                    maxTask = Convert.ToInt32(l_str);

              

               

             

                l_str = l_xmlConf.getNodeValue("volumeMin");
                if (!string.IsNullOrEmpty(l_str))
                    volumeMin = Convert.ToInt32(l_str);

               

               

                removeVersions = l_xmlConf.getBoolValue("removeVersions", false);
                condensation = l_xmlConf.getBoolValue("condensation", false);
                abortOpe = l_xmlConf.getBoolValue("abortOpe"); 


               
                ordonnancement = l_xmlConf.getBoolValue("ordonnancement");

                menage = l_xmlConf.getBoolValue("menage", false);



                m_sort = new CConfSort(l_xmlConf.NodeLookUp("sort"), 0.5m);
                m_select = new CConfSort(l_xmlConf.NodeLookUp("selection"), 1);

                confGen = new ConfGen(l_xmlConf.NodeLookUp("gen"));
                Album.Medianne = confGen.Medianne; 
                

             //   dataConf = new DataConf(l_xmlConf.NodeLookUp("data"));

                ordoConf = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

                export = new Export(l_xmlConf.NodeLookUp("export"));
                import = new Import(l_xmlConf.NodeLookUp("import"));





                return l_xmlRoot; 
            }

        }


        public static string ListBase
        {
            get { return m_listBase; }
        }

        public static ConfGen ConfGen
        {
            get { return confGen; }
        }

        public static CConfSort Sort
        {
            get { return m_sort; }
        }
        public static CConfSort Select
        {
            get { return m_select; }
        }
        public static int Before
        {
            get { return m_before; }
        }
        public static int After
        {
            get { return m_after; }
        }
        public static bool CheckModifStrict
        {
            get { return m_checkModifStrict; }
        }
        public static int MaxTask { get { return maxTask; } }
        public static rankingType RankingType { get { return _rankingType; } }

        public static bool Scan { get { return scan; } }
        public static string CopyTo { get { return copyTo; } }

        public static bool CopyModeFile { get { return copyModeFile; } }

        public static int ClassementOffset { get { return classementOffset; } }

       // public static bool DeleteFile { get { return deleteFile; } }

       // public static DataConf DataConf { get { return dataConf; } }

        public static bool RemoveVersions { get { return removeVersions; } }
        public static bool Condensation { get { return condensation; } }

      

      //  public static int TaskDelayError { get { return taskDelayError; } }

        public static bool Menage { get { return menage; } }

       
        public static bool Ordonnancement { get { return ordonnancement; } }
        public static bool AbortOpe { get { return abortOpe; } }

        //public static int MaxScan { get { return maxScan; } }
        public static int VolumeMin { get { return volumeMin; } }

      
        public static ConfOrdo ConfOrdo { get { return ordoConf; } }

        public static Export Export { get { return export; } }
        public static Import Import { get { return import; } }
        public static string display()
        {   
            StringBuilder sb = new StringBuilder(); 
            sb.Append( String.Format("base:{0} before:{1} after: {2} select:{3} sort:{4}", m_listBase, m_before, m_after, m_select, m_sort));
            sb.AppendLine(confGen.ToString());
            sb.AppendLine(ordoConf.ToString()); 

            return sb.ToString();
        }

    }


    public enum ConfType
    {
        sort,
        selection
    }
}

]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\Import.cs">
    <content><![CDATA[using System;
using pdb.util;
using System.Xml;

namespace pdb.gen.Tuning
{
   public class Import : TuningBase
    {
        public string dir;
        public string album;
        public string artist;
        public bool logical;
        public Import()
            : base()
        {
        }
        public Import(XmlElement node)
            : base(node)
        {
            if (node == null)
                return;
            builds("dir", v => dir = v);
            builds("album", v => album = v);
            builds("artist", v => artist = v);
            buildb("logical", v => logical = v); 
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\Metadata.cs">
    <content><![CDATA[using System;
using pdb.obj;

namespace pdb.obj
{
    /// <summary>
    /// Simple conteneur de métadonnées
    /// </summary>
    public class Metadata : ITrackMetaData
    {
        public Metadata()
        {
        }

        public Metadata(string location)
        {
            this.location = location;
        }
        #region ITrackMetaData
        public int Rating
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }
        private int year = -1;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                year = value;
            }
        }

        public string Comment
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public bool Enabled
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public bool isPodcast
        {
            get { return false; }
        }

        public DateTime PlayedDate
        {
            get { return DateTime.MinValue; }
        }

        private TimeSpan duration;
        public TimeSpan Duration
        {
            get
            {
                return duration;
            }
            set
            {
                duration = value;
            }
        }

        public string ArtWork
        {
            get
            {
                return "";
            }
            set
            {

            }
        }

        public string Grouping
        {
            get { return ""; }
        }

        public void setGrouping(string value, bool prior)
        {

        }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public int PieceParentId
        {
            get
            {
                return -1;
            }
            set
            {

            }
        }

        public TrackIdentity Key
        {
            get { return null; }
        }
        private string location;
        public string Location
        {
            get { return location; }
        }

        public int PieceId
        {
            get { return -1; }
        }
        private string artist;
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                artist = value;
            }
        }
        private string album;
        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                album = value;
            }
        }
        private string name;
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }
        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                trackNumber = value;
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\PieceDb.obj\pdb.obj.csproj">
    <content><![CDATA[<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{9B849072-2B8E-4CE4-8AD7-D173724A9644}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>pdb.obj</RootNamespace>
    <AssemblyName>pdb.obj</AssemblyName>
    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\pdb.obj.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <CodeAnalysisLogFile>bin\Release\pdb.obj.dll.CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisUseTypeNameInSuppression>true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisModuleSuppressionsFile>GlobalSuppressions.cs</CodeAnalysisModuleSuppressionsFile>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSetDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\\Rule Sets</CodeAnalysisRuleSetDirectories>
    <CodeAnalysisIgnoreBuiltInRuleSets>true</CodeAnalysisIgnoreBuiltInRuleSets>
    <CodeAnalysisRuleDirectories>;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Team Tools\Static Analysis Tools\FxCop\\Rules</CodeAnalysisRuleDirectories>
    <CodeAnalysisIgnoreBuiltInRules>true</CodeAnalysisIgnoreBuiltInRules>
    <CodeAnalysisFailOnMissingRules>false</CodeAnalysisFailOnMissingRules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <PlatformTarget>x86</PlatformTarget>
    <OutputPath>bin\</OutputPath>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CPlayList.cs" />
    <Compile Include="CPlayListComparer.cs" />
    <Compile Include="DictRef.cs" />
    <Compile Include="FileType.cs" />
    <Compile Include="IBgTask.cs" />
    <Compile Include="ILoader.cs" />
    <Compile Include="Interfaces.cs" />
    <Compile Include="Metadata.cs" />
    <Compile Include="TrackIdentity.cs" />
    <Compile Include="TrackPlayListManager.cs" />
    <Compile Include="PlComponent.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\pdb.util\pdb.util.csproj">
      <Project>{C2B34CA9-3BB2-464F-8691-5F5B7CB2B997}</Project>
      <Name>pdb.util</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>]]></content>
  </file>
</db>
