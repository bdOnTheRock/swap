<db path="C:\bernard\db1\db4">
   <file path="\PieceDb.Db\MasterPiece.cs">
    <content><![CDATA[using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;

namespace pdb.db
{
    public class MasterPiece : IMasterPiece, IData
    {
        private const string TOKEN_DISABLED = "disabled";
        public const string TOKEN_DURATION = "duration";
        //durée en ms du titre
        private TimeSpan m_duration = new TimeSpan();
        private CPieceClassement m_classement;
        private CListDate m_dates;
        private CListFile m_files;
        private CPieceChecked m_Enabled;
        private static MasterPiece _NULL = new MasterPiece();
        public static MasterPiece NULL { get { return _NULL; } }

        public MasterPiece()
        {
            m_dates = new CListDate();
            m_files = new CListFile();
            m_classement = new CPieceClassement(this);
            m_Enabled = new CPieceChecked();
        }
        public MasterPiece(XmlElement a_xml)
        {
            var xmlTool = new XMLTool(a_xml);

            m_dates = new CListDate(a_xml);
            m_files = new CListFile(a_xml);
            m_classement = new CPieceClassement(this, a_xml);
            m_Enabled = new CPieceChecked();
            var xDisabled = xmlTool.NodeLookUp(TOKEN_DISABLED);

            if (xDisabled != null)
            {
                if (xDisabled.InnerText == "false")
                    Checked.Enable();
                else
                    Checked.Disable();
            }

            string strDur = "";
            var attDuration = a_xml.Attributes[TOKEN_DURATION];
            if (attDuration != null)
                strDur = attDuration.Value;
            else
                strDur = xmlTool.getNodeValue(TOKEN_DURATION);




            if (!string.IsNullOrEmpty(strDur))
            {
                var ms = Convert.ToDouble(strDur);
                if (ms > 1)
                    m_duration = TimeSpan.FromMilliseconds(ms);
            }

        }
        public CPieceClassement Classement { get { return m_classement; } }
        public CListFile Files { get { return m_files; } }
        public CListDate ListDates { get { return m_dates; } }
        internal CPieceChecked Checked { get { return m_Enabled; } }

        Classement IMasterPiece.Classement
        {
            get { return m_classement.Value; }
        }

        Classement IMasterPiece.DeepClassement
        {
            get { return m_classement.DbValue; }
        }

        Classement IMasterPiece.MaxClassement { get { return m_classement.MaxClassement(); } }


        public void setClassement(string className, int rating)
        {
            m_classement.setClassement(className, rating);
        }


        public void setClassement(string strClassement)
        {
            var cl = pdb.obj.Classement.create(strClassement);
            if (cl == null)
                throw new ApplicationException("input classement invalide " + strClassement);

            m_classement.Value = cl;
        }



        public void write(XmlWriter w)
        {

            if (!Checked.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "");
            Classement.write(w);
            Files.write(w);
            ListDates.write(w);




        }

        public bool HasChange(MasterPiece lastFull)
        {
            if (m_classement.HasChange(lastFull.m_classement))
                return true;
            if (m_files.HasChange(lastFull.m_files))
                return true;
            if (m_dates.HasChange(lastFull.m_dates))
                return true;
            return false;
        }

        public void writeDiff(XmlWriter w, MasterPiece lastFull)
        {
            m_classement.writeDiff(w, lastFull.m_classement);
            var major = m_files.writeDiff(w, lastFull.m_files);
            m_dates.writeDiff(w, lastFull.m_dates, major);

            if (!Checked.Enabled && lastFull.Checked.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "");

            if (Checked.Enabled && !lastFull.Checked.Enabled)
                w.WriteElementString(TOKEN_DISABLED, "false");


            if (Duration.TotalMilliseconds > 1 && lastFull.DurationInSec != DurationInSec)
                w.WriteElementString(TOKEN_DURATION, ((int)Duration.TotalMilliseconds).ToString());
        }

        private exportState _exportState;
        public exportState ExportStatus
        {
            get
            {
                return _exportState;
            }
            set
            {
                _exportState = value;
            }
        }

        public string Location
        {
            get
            {
                return m_files.Path;
            }
        }


        public List<string> RelativesPath
        {
            get
            {

                var _RelativesPath = new List<string>();
                foreach (CFile f in m_files)
                {
                    _RelativesPath.Add(f.File);
                }
                return _RelativesPath;
            }
        }

        public DateTime PlayedDate
        {
            get { return m_dates.LastModif; }
        }

        public List<DateTime> Dates
        {
            get { return m_dates.Dates; }
        }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return m_classement.getDates();
            }
        }

        public List<DateTime> DatesClassement
        {
            get
            {
                return m_classement.getDates();
            }
        }


        public bool Enabled
        {
            get
            {
                return m_Enabled.Enabled;
            }

            set
            {
                if (value)
                    m_Enabled.Enable();
                else
                    m_Enabled.Disable();
            }
        }

        public void consolid(MasterPiece remote, mergePriority a_priority)
        {

            m_classement.Consolid(remote.m_classement, a_priority);
            Checked.Consolid(remote.Checked, a_priority);

            if (m_duration.TotalMilliseconds < 2)
                this.m_duration = remote.m_duration;
            else if (remote.m_duration.TotalMilliseconds < 2)
                remote.m_duration = this.m_duration;
            else if (a_priority == mergePriority.right)
                m_duration = remote.m_duration;

            addData(remote);
        }

        public void addData(MasterPiece other)
        {
            m_dates.merge(other.m_dates);
            //  other.ListDates.merge(ListDates);

            m_files.merge(other.m_files);
            // other.Files.merge(Files);
        }


        public void addDataLink(MasterPiece other)
        {
            ListDates.merge(other.ListDates);
            other.ListDates.merge(ListDates);

            Files.merge(other.Files);
            other.Files.merge(Files);


            Classement.mergeOnlyVersion(other.Classement);
            other.Classement.mergeOnlyVersion(Classement);
        }

        public TimeSpan Duration
        {
            get { return m_duration; }
            set
            {
                if (value.TotalMilliseconds > 1)
                {
                    m_duration = value;
                }

            }
        }
        public int DurationInSec
        {
            get { return Convert.ToInt32(Duration.TotalSeconds); }
        }

        public String ClassEvol
        {
            get { return getClassementEvol(); }
        }
        public String getClassementEvol()
        {
            DateTime playedCorr = ListDates.LastModif;
            try
            {
                if (playedCorr > DateTime.MinValue)
                    playedCorr -= Duration;
            }
            catch (Exception)
            {
                // logTrack.log("{0} impossible de corriger la date jouée {1} avec la durée {2}", this, ListDates.LastModif, Duration);
            }
            if (Classement.LastModif > playedCorr)
            {
                return Classement.Evol;
            }
            return "";

        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListDate.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;

namespace pdb.db.obj
{

    /// <summary>
    /// liste des dates d'écoute d'un morceau
    /// </summary>
    /// <remarks></remarks>
    /// 

    class ListenDate : IComparable, IEquatable<ListenDate>
    {
        public readonly DateTime date;
        public readonly bool deleted;
        public ListenDate(XmlElement node)
        {
            deleted = XMLTool.getDeleted(node);
            date = Convert.ToDateTime(node.InnerText);
        }
        public ListenDate(DateTime dt)
        {
            this.date = dt;
        }

        public int CompareTo(object obj)
        {
            var o = obj as ListenDate;
            if (o == null)
                return -1;
            return -this.date.CompareTo(o.date);
        }

        public bool Equals(ListenDate other)
        {
            if (other == null)
                return false;
            return date.Equals(other.date);
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as ListenDate);
        }

        public override int GetHashCode()
        {
            return date.GetHashCode();
        }
        public override string ToString()
        {
            return date.ToString();
        }
    }

    public class CListDate : IData
    {

        private const string DATES = "dates";

        private const string DATE = "date";
        private List<ListenDate> m_list = new List<ListenDate>();
        public static int Period = 30;

        private static CDateComparer c_comparer = new CDateComparer();
        private static DateTime min = new DateTime(1970, 3, 27);
        public CListDate(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, DATES);
            if (l_xml == null)
                return;
            foreach (XmlElement l_xmlDate in l_xml)
            {
                m_list.Add(new ListenDate(l_xmlDate));
            }
        }
        public CListDate()
        {
        }



        public CListDate(List<DateTime> dates)
        {
            foreach (DateTime dt in dates)
                m_list.Add(new ListenDate(dt));
        }

        public void recordJustReadTrack()
        {
            m_list.Add(new ListenDate(DateTime.Now));
        }

        //public void check(System.DateTime a_date)
        //{
        //    if (a_date > min)
        //    {
        //        if (!m_list.Contains(a_date))
        //        {
        //            if (!isDateInList(a_date))
        //            {
        //                m_list.Add(a_date);
        //            }
        //        }
        //    }
        //}

        //private bool isDateInList(System.DateTime a_date)
        //{
        //    foreach (System.DateTime l_date in m_list)
        //    {
        //        if (l_date == a_date)
        //            return true;
        //        //string refe = l_date.ToString();
        //        //if (refe == a_date.ToString())
        //        //    return true;
        //        //if (refe == a_date.AddHours(1).ToString())
        //        //    return true;
        //        //if (refe == a_date.AddHours(-1).ToString())
        //        //    return true;
        //    }
        //    return false;
        //}

        private void check(ListenDate other)
        {
            if (!other.deleted && !m_list.Contains(other))
                m_list.Add(other);
            else if (other.deleted && m_list.Contains(other))
                m_list.Remove(other);

        }

        public void merge(CListDate other)
        {
            foreach (ListenDate o in other.m_list)
                check(o);
        }

        private void sort()
        {
            m_list.Sort((x, y) => -x.date.CompareTo(y.date));
        }


        #region IData Members




        public void write(XmlWriter w)
        {
            sort();
            w.WriteStartElement(DATES);

            foreach (ListenDate dt in m_list)
            {
                w.WriteElementString(CListDate.DATE, dt.date.ToString());
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListDate lastFull)
        {
            if (m_list.Count != lastFull.m_list.Count)
                return true;
            sort();
            lastFull.sort();
            int count = m_list.Count;
            for (int i = 0; i < count; i++)
            {
                if (!m_list[i].Equals(lastFull.m_list[i]))
                    return true;
            }
            return false;
        }
        public void writeDiff(XmlWriter w, CListDate lastFull, bool major)
        {
            if (!HasChange(lastFull))
                return;
            sort();
            lastFull.sort();
            w.WriteStartElement(DATES);

            foreach (var l_date in m_list)
            {
                if (lastFull.m_list.Contains(l_date))
                    continue;
                w.WriteElementString(CListDate.DATE, l_date.ToString());
            }
            if (major)
            {
                foreach (var l_date in lastFull.m_list)
                {
                    if (m_list.Contains(l_date))
                        continue;
                    w.WriteStartElement(CListDate.DATE);
                    XMLTool.writeDeleted(w);
                    w.WriteString(l_date.ToString());
                    w.WriteEndElement();
                }
            }


            w.WriteEndElement();
        }


        #endregion
        public int Count
        {
            get { return m_list.Count; }
        }


        public DateTime LastModif
        {
            get
            {
                if (m_list.Count == 0)
                    return System.DateTime.MinValue;
                sort();
                return m_list[0].date;
            }
        }
        public List<DateTime> Dates
        {
            get
            {
                return (from dt in m_list select dt.date).ToList();
            }
        }

        public class CDateComparer : IComparer<System.DateTime>
        {

            public int Compare(System.DateTime x, System.DateTime y)
            {
                return -1 * System.DateTime.Compare(x, y);
            }
        }

        public void removeLast()
        {
            int count = m_list.Count;
            if (count == 0)
                return;
            m_list.RemoveAt(0);
        }


    }
}





]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListFile.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util;
using pdb.obj;

using pdb.db.piece;

namespace pdb.db.obj
{
    /// <summary>
    /// liste des fichiers accédant au même morceau
    /// </summary>
    /// <remarks></remarks>
    public class CListFile : IEnumerable<CFile>, IData
    {


        //  private static CFileComparer c_comparer = new CFileComparer();
        private const string TOKEN_FILES = "files";
        private List<CFile> m_list = new List<CFile>();
        private CFile pertinentFile;
        // private bool? _exists;
        public CListFile(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, TOKEN_FILES);
            if (l_xml == null)
                return;
            bool deleted = false;
            var att = l_xml.Attributes["f"];
            if (att != null)
            {
                deleted = XMLTool.getDeleted(l_xml);
                CFile f = new CFile(att.Value, deleted);
                @add(f);
                return;
            }
            foreach (XmlElement l_xmlFile in l_xml)
            {
                deleted = XMLTool.getDeleted(l_xmlFile);
                CFile l_file = new CFile(l_xmlFile.InnerText, deleted);
                @add(l_file);
            }
        }
        public CListFile()
        {
        }

        public CListFile(CListFile o)
        {
            foreach (CFile f in o)
                @add(f);
        }

        private void check(CFile other)
        {
            if (!other.deleted && !m_list.Contains(other))
                m_list.Add(other);
            else if (other.deleted && m_list.Contains(other))
                m_list.Remove(other);

        }

        public void @add(CFile a_file)
        {
            //if (!a_file.exists()) return; //TODO provisoire
            bool l_bFound = false;
            foreach (CFile l_file in m_list)
            {
                if (a_file.Equals(l_file))
                {
                    l_bFound = true;
                    break;
                }
            }
            if (l_bFound)
                return;
            if (a_file.FileType.typeMusic())
            {
                m_list.Add(a_file);
                pertinentFile = null;
            }
        }
        //   private CFile _pertinent; 
        public CFile getPertinentFile()
        {
            if (pertinentFile != null)
                return pertinentFile;
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            bool checkEnd = true;
            var list = new List<CFile>();
            foreach (CFile f in m_list)
            {
                var exist = f.exists();
                if (exist == null)
                    checkEnd = false;
                else if (true == exist)
                    list.Add(f);
            }

            CFile ret = null;
            if (list.Count == 1)
            {
                ret = list[0];
            }
            else
            {

                try
                {
                    list.Sort(new CFileComparer());
                }
                catch (Exception e)
                {
                    Console.WriteLine("impossible de comparer les fichiers");
                    foreach (CFile file in list)
                    {
                        Console.Write(file.File + ";");
                    }
                    Console.WriteLine(e.ToString());
                }

                ret = list.Count == 0 ? null : list[0];
            }

            if (checkEnd)
                pertinentFile = ret;


            return ret;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        private CFile getFirstFile()
        {
            var pertinent = getPertinentFile();
            if (pertinent != null)
                return pertinent;
            //if (_pertinent != null)
            //    return _pertinent; 
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list; // m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            var _pertinent = list.Count == 0 ? null : list[0];
            return _pertinent;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        //public void getSecondaryFiles(List<CFile> list)
        //{
        //    if (m_list.Count <= 1)
        //        return;
        //    var pertinent = getPertinentFile();

        //    foreach (CFile f in m_list)
        //    {
        //        if (f.exists() && f != pertinent)
        //            list.Add(f);
        //    }

        //}

        //public string File
        //{
        //    get
        //    {
        //        CFile l_file = getPertinentFile();
        //        if (l_file == null)
        //        {
        //            if (m_list.Count > 0) return m_list[0].File;
        //            return "";
        //        }
        //        return l_file.File;
        //    }
        //}

        public string PathReduc
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.File;
            }
        }

        public CFile File
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return null;
                return l_file;
            }
        }

        public string Path
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.Path;
            }
        }

        public string getLocation()
        {
            if (pertinentFile != null)
                return pertinentFile.Path;
            if (m_list.Count > 0)
                return m_list[0].getPath();
            return "";
        }
        //public String getUri()
        //{
        //    CFile l_file = getPertinentFile();
        //    if (l_file == null)
        //        return "";
        //    return l_file.getUri();
        //}

        public bool? Exists
        {
            get
            {
                //if (_exists.HasValue)
                //    return _exists.Value;
                if (pertinentFile != null && pertinentFile.exists().HasValue)
                {
                    //  _exists = true;
                    return pertinentFile.exists();
                }

                bool? ret = null;
                bool endCheck = true;
                foreach (CFile f in m_list)
                {
                    var exist = f.exists();
                    if (true == exist)
                    {
                        return true;
                    }
                    else if (false == exist)
                        ret = false;
                    else
                        endCheck = false;
                }

                if (endCheck)
                    return ret;
                else
                    return null;

            }
        }

        public bool ExistsNow()
        {
            if (pertinentFile != null && pertinentFile.exists().HasValue)
            {
                //  _exists = true;
                return pertinentFile.exists().Value;
            }

            foreach (CFile f in m_list)
            {
                var exist = f.exists();
                if (true == exist)
                {
                    return true;
                }
                else if (false == exist)
                {
                }
                else
                {
                    if (FileRegister.ExistNow(f.Path)) ;
                    return true;
                }

            }
            return false;
        }

        public void merge(CListFile a_list)
        {
            CFile aux = getPertinentFile();
            foreach (CFile l_file in a_list)
            {
                check(l_file);
            }


            CFile _new = getPertinentFile();

            if (aux == null)
            {
                if (_new != null)
                    onChange();

            }
            else
            {
                if (!aux.Equals(_new))
                    onChange();
            }

        }

        //private IDataObserver observer;
        //public IDataObserver Observer { set { observer = value; } }
        private void onChange() { }// if (observer != null) observer.RefChange(); }


        /// <summary>
        /// teste s'il existe un fichier en commun entre deux listes
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public bool HasOnePathInCommonWith(CListFile other)
        {
            foreach (CFile l_myFile in m_list)
            {
                foreach (CFile l_outFile in other.m_list)
                {
                    if (l_myFile.Equals(l_outFile))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public bool HasOnePathInCommonWith(String path)
        {

            foreach (CFile l_myFile in m_list)
            {

                if (l_myFile.Path.Equals(path))
                {
                    return true;
                }

            }
            return false;
        }


        public int Count
        {
            get { return m_list.Count; }
        }

        public System.Collections.Generic.IEnumerator<CFile> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public bool isPodcast
        {
            get
            {
                foreach (CFile l_file in new List<CFile>(m_list))
                {
                    if (l_file.isPodcast)
                        return true;
                }
                return false;
            }
        }


        #region IData Members


        public void write(ITextWriter a_sw)
        {
            //   m_list.Sort(c_comparer)
            XMLTool.openBalise(a_sw, TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                l_file.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, TOKEN_FILES);
        }


        public void write(XmlWriter w)
        {
            m_list.Sort(new CFileComparerName());
            w.WriteStartElement(TOKEN_FILES);
            if (m_list.Count == 1 && m_list[0] != null)
            {
                w.WriteAttributeString("f", m_list[0].File);
            }
            else
            {

                foreach (CFile l_file in this)
                {
                    l_file.write(w);
                }
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListFile lastFull)
        {
            if (m_list.Count != lastFull.m_list.Count)
                return true;
            m_list.Sort(new CFileComparerName());
            lastFull.m_list.Sort(new CFileComparerName());
            int count = m_list.Count;
            for (int i = 0; i < count; i++)
            {
                if (!m_list[i].Equals(lastFull.m_list[i]))
                    return true;
            }
            return false;
        }

        public bool contains(CFile file)
        {
            return m_list.Contains(file);
        }
        /// <summary>
        /// Ecrit les changments
        /// </summary>
        /// <param name="w"></param>
        /// <param name="lastFull"></param>
        /// <returns>changement majeur</returns>
        public bool writeDiff(XmlWriter w, CListFile lastFull)
        {
            if (!HasChange(lastFull))
                return false;
            bool ret = false; 
            m_list.Sort(new CFileComparerName());
            lastFull.m_list.Sort(new CFileComparerName());

            w.WriteStartElement(TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                if (!lastFull.contains(l_file))
                    l_file.write(w);
            }

            foreach (CFile l_file in lastFull)
            {
                if (!this.contains(l_file))
                {
                    ret = true;  
                    l_file.writeDeleted(w);
                }
            }

            w.WriteEndElement();
            return ret; 
        }

        #endregion

        public CFile this[int a_index]
        {
            get
            {
                if (a_index < 0 || a_index >= Count)
                {
                    throw new ApplicationException("bad index:" + a_index + " / " + Count);
                }
                else
                {
                    return m_list[a_index];
                }
            }
        }

        public void Sort()
        {
            try
            {
                m_list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
        //private class CFileComparer : IComparer<CFile>
        //{

        //    public int Compare(CFile x, CFile y)
        //    {
        //        return string.Compare(x.File.Trim().ToUpper(), y.File.Trim().ToUpper());
        //    }
        //}

        // private long size = -1;
        public long Size
        {
            get
            {
                var file = getPertinentFile();
                if (file == null)
                    return 0;
                return file.Size;

            }

        }

        //public string DirAndFileName
        //{
        //    get
        //    {
        //        var file = getFirstFile();
        //        if (file == null)
        //            return "";
        //        return file.DirAndFileName;
        //    }
        //}


    }
}


]]></content>
  </file>
</db>
