<db path="C:\bernard\db2\">
   <file path="db4\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.obj;
using pdb.gen.albums;
using System.Linq;
using System.Linq.Expressions;
using System.Windows.Input;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static Logger logPerf = Logger.getLogger("Perf");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public static DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Normal;

        public static void setDispatcherPriority()
        {
            var str = CConf.DispatcherPriority;
            if (!string.IsNullOrEmpty(str))
            {
                DISPATCHER_PRIORITY = (DispatcherPriority)Enum.Parse(typeof(DispatcherPriority), str);
            }
        }

        private class UIItem
        {
            public readonly Action action;
            public readonly IClient client;
            public UIItem(Action action, IClient client)
            {
                this.action = action;
                this.client = client;
            }
        }

        private pdb.util.Queue<UIItem> uiItems = new util.Queue<UIItem>();
        // private DispatcherTimer uiTimer;


        static ILogger logDispatch;
        public static void Dispatch(Action action, IClient client)
        {
            Instance.dispatch(action, client);
        }
        public void dispatch(Action action, IClient client)
        {
            if (!client.HasLog)
                client.Log = logDispatch;
            //if (uiTimer == null)
            //{

            //    lock (_lock)
            //    {
            //        if (uiTimer == null)
            //        {
            //            uiTimer = new DispatcherTimer();

            //        }
            //    }
            //}

            if (!CheckAccess())
            {
                client.log("async");
                client.isAsync = true;
                Dispatcher.BeginInvoke(action, DISPATCHER_PRIORITY);
            }
            else
            {
                Dispatcher.BeginInvoke(action, DISPATCHER_PRIORITY);
                //action();
            }
        }

        //public void dispatchLessPrior(Action action, IClient client)
        //{
        //    Dispatcher.BeginInvoke(action, DispatcherPriority.ApplicationIdle);
        //}



        private void syncAction(Action action, IClient client)
        {
            client.log("debut Effectif");
            action();
            client.log("fin");
        }

        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            var xmlConf = CConf.loadConf();
            setDispatcherPriority();
            pdb.player.ViewModel.Colors.MementoColor.recover();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private string lastMessage;
        private void CheckException(string from, object sender, object ex)
        {
            if (ex is Exception)
            {
                var mess = (ex as Exception).Message;
                if (mess == lastMessage)
                {
                    displayMsg = true;
                }
                lastMessage = mess;

            }
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        private static bool changing;
        public static void setChanging() { changing = true; }
        public static void releaseChanging() { changing = false; }
        public static void invalidateAlbums()
        {
            if (gen == null)
                return;

            gen.invalidateAlbums();
            if (changing)
                return;
            go();
        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                var xmlConf = CConf.loadConf();
                setDispatcherPriority();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                logDispatch = Logger.getLogger("Dispatch");
                misc.init(log);



                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");



                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                gen.FilterNext = CConf.ConfGen.FilterNext;
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0);
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                //  Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }

        private static void resetOneCl()
        {
            lock (_lock)
            {
                try
                {
                    var conf = CConf.ZeroWorkConf;
                    if (conf.enabled)
                    {

                        // CPieceClassement.DateMin = DateTime.MinValue;
                        //   Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                        var oldKepp = new List<Piece>();

                        var _albums = gen.Albums;
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            foreach (Piece t in l)
                            {
                                if (t.Keep)
                                {
                                    t.setKeep(0); //t.Keep = false;
                                    oldKepp.Add(t);
                                    //t.resetMedianneCompact();
                                    //t.invalidateCache(true); 
                                }
                            }
                        }
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            Classement pluspetitNonNull = null;
                            Classement minusRecent = null;
                            Piece min = null;
                            Piece firstZero = null;
                            int nbnotes = 0;
                            int nbRecent = 0;
                            if (album.Name == "London Live")
                            {

                            }
                            //foreach (Piece t in l)
                            //{
                            //    var cl = t.DeepClassement; // p.Classement.DbValue;
                            //    // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                            //    if (cl.isPositive())// > zer0d)
                            //    {
                            //        nbnotes++;
                            //        if (t.LastClassementRecent || !t.Enabled)
                            //        {
                            //            if (!conf.alwaysKeep)
                            //            {
                            //                min = null;
                            //                break;
                            //            }

                            //            nbRecent++;
                            //            continue;
                            //        }
                            //        if (pluspetitNonNull == null || cl < pluspetitNonNull)
                            //        {
                            //            pluspetitNonNull = cl;
                            //            min = t;
                            //        }
                            //    }
                            //    else
                            //    {
                            //        if (conf.keep2Enabled)
                            //        {
                            //            if (t.Enabled && !t.LastClassementRecent)
                            //            {
                            //                if (firstZero == null)
                            //                {
                            //                    if (min == null || conf.alwaysKeep2)
                            //                    {
                            //                        firstZero = t;
                            //                    }
                            //                }
                            //            }
                            //        }
                            //    }
                            //}

                            bool alwaysKeepUsed = false;
                            foreach (Piece t in l)
                            {
                                var cl = t.DeepClassement; // p.Classement.DbValue;
                                                           // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);

                                bool isNote = cl.isPositive();
                                bool isRecent = t.LastClassementRecent || !t.Enabled;
                                if (isRecent)
                                    nbRecent++;
                                if (isNote)
                                    nbnotes++;
                                if (isNote)
                                {
                                    if (isRecent)
                                    {
                                        if (!conf.alwaysKeep)
                                        {
                                            min = null;
                                            break;
                                        }
                                        else
                                        {
                                            alwaysKeepUsed = true;
                                            if (conf.keepMinus >= 1 && cl < minusRecent)
                                                minusRecent = cl;
                                            continue;
                                        }
                                    }
                                    if (pluspetitNonNull == null || cl < pluspetitNonNull)
                                    {
                                        pluspetitNonNull = cl;
                                        min = t;
                                    }
                                }
                                else
                                {
                                    if (conf.keep2Enabled)
                                    {
                                        if (!isRecent)
                                        {
                                            if (firstZero == null)
                                            {
                                                if (min == null || conf.alwaysKeep2)
                                                {
                                                    firstZero = t;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            decimal coeff1 = -1;
                            decimal coeff2 = -1;

                            if (min != null)
                            {
                                if (coeff1 < 0)
                                    coeff1 = ((decimal)nbRecent + 1) / (l.Count + 1);
                                if (coeff2 < 0)
                                    coeff2 = (decimal)nbnotes / l.Count;
                                var coeff = coeff1 * coeff2;
                                if (conf.alwaysCoeffZero || !alwaysKeepUsed)
                                    coeff /= conf.coeffZero;

                                if (minusRecent != null)
                                {
                                    var maxValue = minusRecent.RapportClassement;
                                    //var keepValue = pluspetitNonNull.RapportClassement * coeff;
                                    //if (keepValue > maxValue)
                                    //{

                                    //}
                                    var coeffMax = maxValue / (pluspetitNonNull.RapportClassement * conf.keepMinus);
                                    if (coeff > coeffMax)
                                    {
                                        coeff = coeffMax;
                                        if (conf.dontKeepWhenHigh)
                                            coeff = 0;
                                    }

                                }
                                min.setKeep(coeff);
                            }
                            if (firstZero != null)
                            {
                                if (nbnotes == 0)
                                    nbnotes++;
                                try
                                {
                                    if (coeff2 < 0)
                                        coeff2 = (decimal)nbnotes / l.Count;

                                    firstZero.setKeep(-coeff2);
                                }
                                catch (Exception ex)
                                {
                                    misc.log(ex);
                                }
                            }



                        }

                        foreach (Piece t in oldKepp)
                        {

                            if (!t.Keep)
                            {
                                t.resetMedianneCompact();
                                t.invalidateCache(true);
                            }
                        }


                    }
                }
                finally
                {
                    //  CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                }
            }
        }



        private static void goInit()
        {
            var client = new SimpleClient("goInit\t", logPerf);
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;



            gen.ConsolidInit(Db.List.getList());
            client.log(" gen.ConsolidInit(Db.List.getList());");
            if (CConf.ZeroWorkConf.enabled)
            {

                resetOneCl();
                client.log("resetOneCl");
                //CPieceClassement.DateMin = DateTime.MinValue;
                ////Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                //Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                ////foreach (Piece p in gen.sortByClass())
                ////{
                ////    decimal clValue = p.ClassementValueDecimal(false) ;
                ////    if (clValue > zer0d)
                ////    {
                ////        if (clValue >= zer0d)
                ////        {
                ////            var dPiece = Db.getPiece(p.PieceId);
                ////            var strNewCl = "0000" + dPiece.getClassement().ToString();
                ////            var newCl = Classement.create(strNewCl);
                ////            p.Enabled = true;

                ////            p.setClassement(newCl.ClassList, newCl.Rating);
                ////            dPiece.Classement.eraseClassement2(newCl);
                ////        }
                ////        else
                ////            p.Enabled = false;
                ////    }
                ////}

                //var _albums = gen.Albums;
                //foreach (var album in _albums.List)
                //{
                //    var l = album.Tracks;
                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in l)
                //    {
                //        decimal clValue = t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        (min.Track as CPiece).Classement.keepValue();
                //    }
                //}
                ////    foreach (Piece t in l)
                ////    {
                ////        if (t.Parent == null)
                ////        {
                ////            decimal clValue = t.ClassementValueDecimal(false);
                ////            if (t.isClassListNumeric && clValue > zer0d)
                ////            {
                ////                if (clValue > pluspetitNonNull)
                ////                {
                ////                    var dPiece = Db.getPiece(t.PieceId);
                ////                    t.Enabled = true;
                ////                    t.setClassement("0", 0);
                ////                    dPiece.Classement.eraseClassement2();
                ////                }
                ////            }
                ////        }
                ////    }
                ////}

                ////gen.MakeConsolid(Db.List.getList(), true);
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
            }

            gen.MakeConsolid(null, true, true, client);
            //  if (CConf.ConfGen.LimitList <= 0)
            gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            client.log("creation bib");
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, client, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
            client.log("Fin goInit");
        }

        private static bool mustBuildCompleteAlbums(TrackListViewModel currentTrack)
        {
            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.RankAlbumReverse.CompareTo(y.RankAlbumReverse));
            int count = tracks.Count;
            int rank0 = currentTrack.RankAlbumReverse;

            int i = 0;
            // recherche trou avant ex rank0=3 pas de 1 ni de 2
            for (; i < count; i++)
            {
                var t = tracks[i];
                if (t.RankAlbumReverse >= rank0)
                    break;

                if (t.RankAlbumReverse > i + 1)
                    return true;
            }

            //if (i + 1 < count && tracks[i + 1].RankAlbumReverse > rank0 + 1)
            //{
            //    return true;
            //}

            return false;
        }

        private static void buildAffectedAlbumsWhenCurrentTrackChange(TrackListViewModel currentTrack, IDictionary<string, Album> dict, HashSet<Album> depot, bool navQuick)
        {
            if (currentTrack == null)
                return;
            TrackListViewModel item = currentTrack;
            var cl = item.PieceGen.getClassement(true);
            var _dict = dict;  // new Dictionary<string,Album>(); 

            //foreach (Album album in dict.Values)
            //{
            //    var current = album.PlusPetitEnabled; 
            //    if (current == null || cl<=current.getClassement(true))
            //        _dict.Add(album.Key, album); 
            //}

            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
            int count = tracks.Count;

            //int index = -1;
            //for (int i = 0; i < count; i++)
            //{
            //    var t = tracks[i];
            //    if (t.PieceId == currentTrack.PieceId)
            //    {
            //        index = i;
            //        break;
            //    }
            //}

            //if (index < 0)
            //{
            //    foreach (Album a in dict.Values)
            //        depot.Add(a);
            //    return;
            //}

            var hs = new HashSet<int>();
            if (navQuick)
                hs.Add(item.MasterId);
            int index = -1;
            try
            {
                while (true)
                {
                    index++;
                    if (index >= count)
                        return;

                    var t = tracks[index];
                    if (!hs.Add(t.MasterId))
                        continue;
                    if (navQuick && t.album == item.album)
                        continue;
                    //if (t.album == item.album)
                    //    continue;

                    if (_dict.ContainsKey(t.album.Key))
                    {
                        depot.Add(t.album);
                        if (depot.Count >= _dict.Count)
                            return;
                    }
                    else
                        break;

                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
            finally
            {

            }
        }

        private void automateNextTrack()
        {
            var client = new SimpleClient("automateNextTrack\t");
            this.dispatch(
                () =>
                {
                    PlayerViewModel.Instance.goToFirst();
                    App.go();
                }, client);
            //if (!CheckAccess())
            //    Dispatcher.BeginInvoke(new Action(this.automateNextTrack), App.DISPATCHER_PRIORITY);
            //else
            //{
            //    PlayerViewModel.Instance.forwardAuto();
            //    App.go();
            //}
        }

        static int nbGo = 0;
        static bool classementChange;
        private static SimpleClient client;
        public static bool Indispo { get; set; }
        private static void _go()
        {
            gen.Albums.endParallelSort();
            bool classementChange = App.classementChange;
            var _currentTrack = App._currentTrack;
            nbGo++;
            bool urgence = false;
            if (client != null)
            {
                client.log("FIN new step");
                client.cancel();
            }

            client = new SimpleClient("<--- chrono " + nbGo + "\t", logPerf);
            var clientArgs = new ClientEventArgs(client);

            try
            {

                bool reInit = !gen.AlbumBuild;
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                //   gen.compact(); 
                if (detailClassementViewModel != null)
                    detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;

                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;

                urgence = gen.Urgence && TrackListViewModel.CurrentPlaying == _currentTrack;
                if (!urgence)
                {
                    Db.saveAsync();
                    Memento.Instance.save();
                }
                client.log(string.Format("debut classementChange={0} gen.ClassementChanged={1} gen.Urgence={2} _currentTrack={3}", classementChange, gen.ClassementChanged, gen.Urgence, _currentTrack));
                if (PlayerViewModel.Instance.CreateRot)
                {
                    if (urgence)
                        PlayerViewModel.Instance.modeFirst();
                    if (gen.ClassementChanged)
                    {
                        classementChange = true;
                        App.classementChange = true;
                    }

                    if (!urgence && classementChange)
                    {
                        resetOneCl();
                        client.log("resetOneCl");
                        App.classementChange = false;
                    }

                    if (_currentTrack != null)
                    {
                        int nbAlbums = 0;
                        // bool sortDone = false;
                        if (urgence)
                        {
                            var affectedAlbums = gen.Albums.GetAndInvalidateAlbums(_currentTrack.PieceGen);
                            bool mustComplete = mustBuildCompleteAlbums(_currentTrack);

                            if (!mustComplete)
                            {

                                //}

                                var depot = new HashSet<Album>();
                                buildAffectedAlbumsWhenCurrentTrackChange(_currentTrack, affectedAlbums, depot, CConf.ConfGen.NavQuick);
                                if (depot.Count == 0)
                                {
                                    if (_currentTrack == TrackListViewModel.CurrentPlaying)
                                    {
                                        log.log("pas de makeSort. on passe au suivant on verra après");
                                        _currentTrack = null;
                                        gen.Urgence = false;

                                        App.Instance.automateNextTrack();
                                        return;

                                    }
                                    else
                                    {
                                        log.log("trop naze c'est trop long");
                                        gen.Urgence = false;

                                    }


                                }
                                //}
                                //}
                                else
                                {
                                    log.log("depot:");
                                    nbAlbums = gen.Albums.makeSort(depot, log);
                                    //sortDone = true;
                                }

                            }
                            else
                            {
                                log.log("y a des trous dans la raquette on force le makesort");
                                gen.Urgence = false;
                            }
                            //if (!sortDone && gen.Urgence)
                            //{
                            //    log.log("affected albums");
                            //    nbAlbums = gen.Albums.makeSort(_currentTrack.PieceGen, log);
                            //}
                            client.log(string.Format("makeSort partial {0} elt", nbAlbums));
                            _currentTrack.refresh();
                            while (Indispo)
                                Thread.Sleep(100);
                            if (nbAlbums > 0)
                            {
                                if (refreshAlbum != null)
                                    refreshAlbum("", clientArgs);
                                client.log("refreshAlbum");
                            }
                        }
                    }

                    _currentTrack = null;


                    // if (__end || __go) return;


                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 

                    while (Indispo)
                        Thread.Sleep(100);
                    gen.MakeConsolid(null, _updateStats, classementChange, client); //   bib.Musique.Tracks);
                    if (reInit)
                        gen.buildMusiqueAgain();
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                        setDispatcherPriority();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    while (Indispo)
                        Thread.Sleep(100);
                    gen.createRot(CConf.ListBase, client, App.bib);
                    if (reInit)
                        bib.syncMusique();
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();

                    while (Indispo)
                        Thread.Sleep(100);
                    if (refresh != null)
                        refresh(PHASE2, clientArgs);
                    client.log("refresh après createRot");


                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats && !urgence)
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => { if (detailClassementViewModel != null) detailClassementViewModel.IhmInDispo = ihmInDispo.none; });

                        }
                        else
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                        }
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    _currentTrack = null;
#if EXPORT
                    ExportCmd.CalculExport();
#endif
                    if (_updateStats && !urgence)
                    {
                        _updateStats = false;
                    }
                }
                client.log("FIN _go()");
                if (urgence && !DetailClassementViewModel.Instance.Auto)
                    go(false);

                if (classementChange && !urgence)
                    gen.Albums.parallelSort();

                if (!urgence && TrackListViewModel.HumanSelectedIsBusy)
                {
                    if (refreshArtWork != null)
                        refreshArtWork.BeginInvoke("toto", clientArgs, null, null);
                }


            }


        }

        public static event EventHandler<ClientEventArgs> refresh;
        public static event EventHandler<ClientEventArgs> refreshAlbum;
        public static event EventHandler<ClientEventArgs> refreshArtWork;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                return null;
                case MessageBoxResult.No:
                return false;
                case MessageBoxResult.None:
                return null;
                case MessageBoxResult.OK:
                return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.player\ViewModel\PlayListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Threading;
using pdb.db.obj;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;


namespace pdb.player.ViewModel
{
    public class PlayListViewModel : BibViewModelTreelBase, INotifyCollectionChanged, IEnumerable<PlayListViewModel>
    {
        protected Logger log;
        private object _lock = new object();
        private PlayList pl;
        private List<BibViewModelBase> _childs = new List<BibViewModelBase>();
        protected List<PlayListViewModel> _playlists = new List<PlayListViewModel>();
        //  private List<PlayListViewModel> __playlists = new List<PlayListViewModel>(); 
        private List<TrackListViewModel> _tracks = new List<TrackListViewModel>();

        //private static List<IRedraw> gui = new List<IRedraw>();
        //internal static void addDrow(IRedraw _gui) { gui.Add(_gui); }
        private static bool _log;
        public static bool Log { set { _log = value; } }
#if EXPORT
        #region export
        private List<TrackListViewModel> exportTracks = new List<TrackListViewModel>();
        public List<TrackListViewModel> ExportTracks { get { return exportTracks; } set { exportTracks = value; } }
        #endregion
#endif
        private bool _main = true;
        public void setSecondary() { _main = false; }


        private static void redraw()
        {
            // foreach (IRedraw _gui in gui)  _gui.redraw();
        }

        #region optim recherche
        //private static BgDictString<PlayListViewModel> dictPl = new BgDictString<PlayListViewModel>();
        //private static BgDictString<TrackListViewModel> dictT = new BgDictString<TrackListViewModel>();
        //protected static void recordPl(PlayListViewModel pl)
        //{
        //    dictPl.Add(pl.pl.getPath(), pl);
        //}

        //protected static string getKey(PlayListViewModel pl, int id)
        //{
        //    return pl.pl.getPath() + "|" + id;
        //}

        private HashSet<int> hs = new HashSet<int>();

        protected void recordTrack(TrackListViewModel t)
        {
            hs.Add(t.PieceId);
        }

        public bool contains(int id)
        {
            return hs.Contains(id);
        }

        //public static bool containsTrack(TrackListViewModel t, PlayListViewModel pl)
        //{
        //    return dictT.ContainsKey(getKey(pl, t.PieceId));
        //}

        protected void removeTrack(TrackListViewModel t)
        {
            hs.Remove(t.PieceId); // dictT.Remove(getKey(pl, t.PieceId));
        }

        //public static TrackListViewModel findTrack(PlayListViewModel pl, int id)
        //{
        //    var key = getKey(pl, id);
        //    if (dictT.ContainsKey(key))
        //        return dictT[key];
        //    return null;
        //}

        //public TrackListViewModel FindTrack(int id)
        //{
        //    return findTrack(this, id);
        //}

        public static void resetExport(exportState state)
        {
            misc.log("resetExport {0}", state);
            try
            {
                foreach (var t in TrackListViewModel.Dict.Values)
                    t.ExportStatus = state;
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public static void setExport(Piece p, exportState state)
        {
            if (_selectedPl != null)
            {

                try
                {
                    var t = TrackListViewModel.getOrCreate(p); // findTrack(_selectedPl, id);
                    if (t != null)
                    {
                        t.ExportStatus = state;
                    }

                    //foreach (TrackListViewModel t in _selectedPl._tracks)
                    //{
                    //    if (t.PieceId == id)
                    //        t.refresh();
                    //}
                }
                //foreach (TrackListViewModel t in dictT.Values)
                //{
                //    if (t.PieceId == id)
                //        t.ExportStatus = state;
                //}

                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }


        }

        //protected bool contains( int id)
        //{
        //    //return hs.Contains(id); 
        //    //var key = getKey(pl, id);
        //    //if (dictT.ContainsKey(key))
        //    //    return true;
        //    //return false;
        //}


        #endregion


        static PlayListViewModel()
        {
            //  App.refresh += new EventHandler(App_refresh);
        }

        static void App_refresh(object sender, EventArgs e)
        {
            //var pl = _selectedPl;
            //if (pl != null)
            //    pl.refresh(); 
        }

        public bool isSubList(string name)
        {
            return pl.isSubList(name);
        }

        public bool isSubList(PlayListViewModel pl)
        {
            return this.pl.isSubList(pl.PlayList);
        }

        public void init()
        {
            _childs.Clear();
            _playlists.Clear();
            _tracks.Clear();

            foreach (PlayList sublist in pl.PlayLists)
            {
                var _pl = new PlayListViewModel(sublist, this);
                _childs.Add(_pl);
                _playlists.Add(_pl);
                //  recordPl(_pl);
            }
            foreach (Piece track in pl.Items)
            {
                if (track.Virtual && !PlayerViewModel.Instance.WithVirtualAlbum)
                    continue;
                TrackListViewModel _t = null;
                if (_main)
                    _t = TrackListViewModel.getOrCreate(track); // new TrackListViewModel(track, this);
                else
                    _t = TrackListViewModel.getOrCreateA(track);
                _childs.Add(_t);
                _tracks.Add(_t);
                recordTrack(_t);
            }



            allTracks = new AllTracksViewModel(this, false, false);
        }


        public void Synch()
        {
            var hsnew = new HashSet<int>();
            foreach (Piece track in pl.Items)
            {
                hsnew.Add(track.PieceId);
                if (!hs.Contains(track.PieceId))
                {
                    log.log("Sync {0} ajout {1}", this, track);
                    TrackListViewModel _t = null;
                    if (_main)
                        _t = TrackListViewModel.getOrCreate(track); // new TrackListViewModel(track, this);
                    else
                        _t = TrackListViewModel.getOrCreateA(track);
                    _childs.Add(_t);
                    _tracks.Add(_t);
                }
            }

            foreach (int oldId in hs)
            {
                if (!hsnew.Contains(oldId))
                {
                    TrackListViewModel _t = null;
                    if (_main)
                        _t = TrackListViewModel.get(oldId); // new TrackListViewModel(track, this);
                    else
                        _t = TrackListViewModel.getA(oldId);
                    string desc = oldId.ToString();
                    if (_t != null)
                        desc = _t.ToString();
                    log.log("Sync {0} suppression {1}", this, desc);
                    if (_t != null)
                    {
                        _childs.Remove(_t);
                        _tracks.Remove(_t);
                    }
                }
            }

            hs = hsnew;
        }


        public PlayListViewModel get(string name)
        {
            return get(name, false);
        }

        public PlayListViewModel get(string name, bool create)
        {
            foreach (var pl in _playlists)
                if (pl.Name == name)
                    return pl;
            if (!create)
                return null;
            var _pl = new PlayList(name, this.pl);
            var _new = new PlayListViewModel(_pl, this);
            _playlists.Add(_new);
            _childs.Add(_new);
            // recordPl(_new);
            //_new.PropertyChanged += _pl_PropertyChanged;
            //_new.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, _new));

            //  redraw(); 
            return _new;
        }


        private PlayListViewModel _getFromPath(string[] tab, int index)
        {
            for (; index < tab.GetLength(0); index++)
            {
                string dir = tab[index];
                if (string.IsNullOrEmpty(dir))
                    continue;
                if (dir.Equals(Name))
                    continue;
                var sub = get(dir, false);
                if (sub == null)
                    return null;
                return sub._getFromPath(tab, index + 1);
            }

            return this;

        }

        public PlayListViewModel getFromPath(string path)
        {
            var tab = path.Split(PlayListComposite.SEP);
            return _getFromPath(tab, 0);
        }

        public List<TrackListViewModel> Tracks { get { return _tracks; } }
        private AllTracksViewModel allTracks;
        public AllTracksViewModel AlltracksVm { get { return allTracks; } }

        //private AllTracksViewModel alltracksVmd;
        //public AllTracksViewModel AlltracksVmd
        //{
        //    get
        //    {
        //        if (alltracksVmd == null)
        //            alltracksVmd = new AllTracksViewModel(this, true, false);
        //        return alltracksVmd;

        //    }
        //}

        //private AllTracksViewModel alltracksFather;
        //public AllTracksViewModel AllTrackFather
        //{
        //    get
        //    {
        //        if (alltracksFather == null)
        //            alltracksFather = new AllTracksViewModel(this,null, true);
        //        return alltracksFather;
        //    }
        //}


        //private AllTracksViewModel alltracksFatherDisabled;
        //public AllTracksViewModel AllTrackFatherDisabled
        //{
        //    get
        //    {
        //        if (alltracksFatherDisabled == null)
        //            alltracksFatherDisabled = new AllTracksViewModel(this, true, true);
        //        return alltracksFatherDisabled;
        //    }
        //}

        public PlayListViewModel(PlayList pl)
            : this(pl, null)
        {
        }

        private PlayListViewModel(PlayList pl, PlayListViewModel parent)
            : base(pl, parent)
        {
            this.pl = pl;
            log = Logger.getLogger(pl.getPath());
            init();

        }
        public PlayList PlayList { get { return pl; } }

        public string Name
        {
            get
            {
                return pl.Name;
            }
            set
            {
                if (value != Name)
                {
                    pl.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        #region selected

        /// <summary>
        /// element sélectionné. Répercuté jusqu'à la racine de l'arbre
        /// </summary>
        private static PlayListViewModel _selectedPl;
        public static PlayListViewModel SelectedPlayList
        {
            get
            {
                return _selectedPl;
            }
            private set
            {
                if (_selectedPl == value)
                    return;
                var _oldpl = _selectedPl;
                _selectedPl = value;
                if (_selectedPl != null)
                {
                    _selectedPl.IsSelected = true;
                    _selectedPl.IsExpanded = true;
                }
                OnSelectedPlayListChange(_oldpl);
            }
        }

        public static void initSelected(string strPl)
        {
            if (!string.IsNullOrEmpty(strPl))
            {
                var selected = App.bib.Root.getFromPath(strPl);

                if (selected != null)
                    PlayListViewModel.SelectedPlayList = selected;

            }
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;

                if (_isSelected)
                {
                    SelectedPlayList = this;
                }

            }
        }

        #endregion

        public static event EventHandler selectedPlaylistChange;
        private static void OnSelectedPlayListChange(PlayListViewModel oldPl)
        {
            if (selectedPlaylistChange != null)
                selectedPlaylistChange(oldPl, EventArgs.Empty);
        }


        #region INotifyCollectionChanged Members

        public event NotifyCollectionChangedEventHandler CollectionChanged;

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            var client = new SimpleClient("PlayListViewModel::OnCollectionChange", log);
            // Be nice - use BlockReentrancy like MSDN said
            lock (_lock)
            {
                client.log("_lock");
                var eventHandler = CollectionChanged;
                if (eventHandler != null)
                {
                    Delegate[] delegates = eventHandler.GetInvocationList();
                    // Walk thru invocation list

                    foreach (NotifyCollectionChangedEventHandler handler in delegates)
                    {

                        App.Dispatch(() => { handler(this, e); client.log("handler"); }, client);
                        //try
                        //{
                        //    var dispatcherObject = handler.Target as DispatcherObject;
                        //    // If the subscriber is a DispatcherObject and different thread
                        //    if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                        //    // Invoke handler in the target dispatcher's thread
                        //    {
                        //        var ope =
                        //        dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                        //                           handler, this, e);
                        //        ope.Completed += ope_Completed;
                        //    }
                        //    else // Execute handler as is
                        //        handler(this, e);
                        //}
                        //catch (Exception ex)
                        //{
                        //    App.log.log(ex.ToString());
                        //}
                    }
                }
            }
            client.End();

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (this.CollectionChanged == null)
            //    {
            //        int toto = 0;
            //    }
            //    else
            //        this.CollectionChanged(this, e);               
            //}
            //else
            //    dispatcher.Invoke(new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e); 

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("PlayListViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
        }

        #endregion

        public PlayListViewModel getOrCreatePlayList(string name)
        {

            var found = _playlists.Find(pl => pl.Name == name);
            if (found == null)
            {
                found = AddPlayList(name);
            }

            return found;
        }

        public PlayListViewModel AddPlayList(string name)
        {
            var subModel = new PlayList(name, pl);
            var sub = new PlayListViewModel(subModel, this);
            _childs.Add(sub);
            _playlists.Add(sub);
            //recordPl(sub);
            //   __playlists.Add(sub);
            //sub.PropertyChanged += _pl_PropertyChanged;
            //sub.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, sub));
            // PLayLists.Add(sub); 
            // redraw(); 
            return sub;
        }

        public TrackListViewModel AddTrack(IFile file, bool signal)
        {
            // var piece = App.Db.getPiece(location);
            return AddTrack(file as Piece, signal);

        }

        private TrackListViewModel Get(IFile file)
        {
            var t = TrackListViewModel.get(file.PieceId);
            if (t == null)
                t = AddTrack(file as Piece, false);
            return t;
        }

        private TrackListViewModel Get(Piece file)
        {
            var t = TrackListViewModel.get(file.PieceId);
            if (t == null)
                t = AddTrack(file, false);
            return t;
        }

        public TrackListViewModel AddTrack(Piece piece, bool signal)
        {
            if (_log) log.log("{0} AddTrack {1}", pl.getPath(), piece.ToString());
            if (hs.Contains(piece.PieceId))
            {
                App.Instance.InfoIHm(string.Format("le morceau {0} est déjà présent dans la liste {1}", piece, this), "Ajout dans la playlist");
                return null;
            }
            //var tl = new TrackList(piece);
            pl.add(piece);
            //var p = piece.Track;
            //CPiece cPiece = null;
            //if (p is CPiece)
            //    cPiece = p as CPiece;

            //else if (p is TrackListViewModel)
            //{
            //    var pp = ((TrackListViewModel)p).Piece;
            //    cPiece = pp as CPiece;
            //}


            //if (cPiece != null)
            //    pl.addPiece(cPiece);
            var vm = TrackListViewModel.getOrCreate(piece); // new TrackListViewModel(tl, this);
            _childs.Add(vm);
            _tracks.Add(vm);
            recordTrack(vm);
            //  vm.PropertyChanged += _pl_PropertyChanged;
            if (signal)
            {
                //OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, vm));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }

            return vm;
        }

        public void RemoveTrack(TrackListViewModel tl, bool signal)
        {
            if (_log) log.log("{0} RemoveTrack {1}", pl.getPath(), tl.Piece);
            _childs.Remove(tl);
            _tracks.Remove(tl);
            removeTrack(tl);


            tl.remove();
            //TODO faire la suppression de l'item de liste org

            if (signal)
            {
                // OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, tl));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }
        }

        private void insert(TrackListViewModel k, List<IFile> newElements)
        {
            int indexInsert = k.Index - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k);
        }

        private void insert2(TrackListViewModel k, List<Piece> newElements)
        {
            int indexInsert = k.Index2 - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k.PieceGen);
        }
        //  private bool filterNext; 
        public void mergeList(ICollection<IFile> newElements_, IAbortTask writer)
        {
            lock (Consolid.Lock)
            {
                lock (Albums.Lock)
                {
                    var tt = TrackListViewModel.HumanSelected;
                    if (tt != null)
                    {
                        tt.refresh();
                        //var g = tt.Grouping; 
                        // tt.Grouping = tt.PieceGen.RankAlbumReverse.ToString();
                    }

                    bool isMe = PlayListViewModel.SelectedPlayList == null || PlayListViewModel.SelectedPlayList == this;
                    bool isAlbum = this.isSubList("album");
                    bool isGen = this.isSubList("gen");


                    var confalbum = App.gen.SortAlbumMode;
                    int stackBefore = 4;
                    if (confalbum != null && confalbum.stackBefore > 0)
                        stackBefore = confalbum.stackBefore;

                    // bool checkStack = (PlayListViewModel.SelectedPlayList == null || PlayListViewModel.SelectedPlayList == this) && isGen && !isAlbum && confalbum.stackEnabled;

                    int _indexAlbumRead = -1;
                    int _indexTrackRead = -1;
                    Album _currentAlbum = null;
                    TrackListViewModel current = TrackListViewModel.CurrentPlaying;
                    Album currentAlbum = null;
                    if (current != null)
                        currentAlbum = current.album;
                    var conf = CConf.ConfGen;
                    List<TrackListViewModel> toDelete = new List<TrackListViewModel>();
                    List<TrackListViewModel> toKeep = new List<TrackListViewModel>();

                    var newElements = new HashList<IFile>(newElements_);


                    BgDict<int, bool?> newElt = new BgDict<int, bool?>();
                    foreach (IFile elt in newElements_)
                    {
                        newElt[elt.PieceId] = false;
                    }

                    int indexAlbumOrg = -1;
                    int indexTrackOrg = -1;

                    int indexAlbumOrg2 = -1;
                    int indexTrackOrg2 = -1;
                    var tracks = _tracks;
                    //if (isMe)
                    //{
                    tracks = new List<TrackListViewModel>(_tracks);
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
                    // }

                    int count0 = _tracks.Count;
                    //  var limitList = CConf.ConfGen.LimitList;

                    foreach (TrackListViewModel tl in tracks)
                    {
                        if (tl.album != _currentAlbum)
                        {
                            _currentAlbum = tl.album;
                            _indexAlbumRead++;
                            _indexTrackRead = 0;
                        }
                        else
                            _indexTrackRead++;
                        var found = newElt[tl.PieceId] != null;
                        bool keep = false;
                        //if (isMe)
                        //{
                        if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                        {
                            keep = true;
                        }
                        else if (current != null && current.PieceId == tl.PieceId)
                        {
                            keep = true;
                            indexAlbumOrg = _indexAlbumRead;
                            indexTrackOrg = _indexTrackRead;
                        }
                        //}

                        newElt[tl.PieceId] = keep;


                        //if (current != null && !keep && tl.Location == current.Location)
                        //{
                        //    App.log.log("bizarre");
                        //}
                        if (!found)
                        {
                            if (keep)
                                toKeep.Add(tl);
                            else
                                toDelete.Add(tl);
                        }
                    }

                    //if (checkStack)
                    //{
                    _indexAlbumRead = -1;
                    _indexTrackRead = -1;
                    tracks.Sort((x, y) => x.Index2.CompareTo(y.Index2));
                    // }

                    foreach (TrackListViewModel tl in tracks)
                    {
                        if (tl.album != _currentAlbum)
                        {
                            _currentAlbum = tl.album;
                            _indexAlbumRead++;
                            _indexTrackRead = 0;
                        }
                        else
                            _indexTrackRead++;
                        var found = newElt[tl.PieceId] != null;


                        if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                        {

                        }
                        else if (current != null && current.PieceId == tl.PieceId)
                        {

                            indexAlbumOrg2 = _indexAlbumRead;
                            indexTrackOrg2 = _indexTrackRead;
                        }

                    }
                    //  }



                    //Addition
                    List<IFile> toAdd = new List<IFile>();
                    //if (limitList <= 0 || !_log)
                    //{
                    foreach (IFile elt in newElements)
                    {
                        if (writer.Aborted)
                            return;

                        bool found = hs.Contains(elt.PieceId); // contains(this, elt.PieceId);


                        if (!found)
                            toAdd.Add(elt);

                    }
                    //  log.log("mergeList::fin determination toAdd");

                    if (toAdd.Count > 0 && _log)
                        log.log("{0} {1} elt to add", this, toAdd.Count);

                    if (tracks.Count > 0 && toAdd.Count > 100) //&& filterNext == PlayerViewModel.Instance.FilterNext)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt to add c'est trop!", this, toAdd.Count);
                        try { toAdd.RemoveRange(100, toAdd.Count - 100); }
                        catch { toAdd.Clear(); }

                        //return;
                        //var l = new List<IFile>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toAdd[i]);
                        //toAdd = l;
                    }

                    if (tracks.Count > 0 && toDelete.Count > 0 && _log)
                        log.log("{0} {1} elt to delete", this, toDelete.Count);

                    if (toDelete.Count > 100) //&& filterNext == PlayerViewModel.Instance.FilterNext)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt toDelete c'est trop!", this, toDelete.Count);

                        try { toDelete.RemoveRange(100, toDelete.Count - 100); }
                        catch { toDelete.Clear(); }

                        // toDelete.Clear();
                        //var l = new List<TrackListViewModel>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toDelete[i]);
                        //toDelete = l;
                    }


                    int count = toAdd.Count;
                    for (int i = 0; i < count; i++)
                    {
                        if (writer.Aborted) return;

                        AddTrack(toAdd[i], false);
                    }

                    foreach (TrackListViewModel vm in toDelete)
                    {
                        if (writer.Aborted) return;
                        RemoveTrack(vm, false);
                    }
                    //  }


                    var newElements3 = newElements;

                    if (isGen)
                    {
                        HashSet<int> moved = new HashSet<int>();
                        HashSet<int> empeached = new HashSet<int>();
                        HashSet<int> unavailable = new HashSet<int>();
                        newElements3 = new HashList<IFile>();
                        // chercher le premier album non quarantaine
                        decimal min = int.MaxValue;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            var t = newElements[i] as Piece;
                            if (!t.InStackSize && t.PieceAlbum != null)
                            {
                                min = t.PieceAlbum.ClassementValueLight;
                                break;
                            }
                        }


                        int ifirst = 0;
                        bool b = false;
                        Album courant = null;
                        for (; ifirst < newElements.Count; ifirst++)
                        {
                            var t = newElements[ifirst] as Piece;
                            if (t.PieceAlbum == courant)
                                continue;
                            courant = t.PieceAlbum;

                            if (courant.Absent)
                            {
                                unavailable.Add(t.PieceAlbum.Next.MasterId);
                            }
                            else
                            {
                                if (courant.InStackPeremption || (courant.InStackSize && courant.ClassementValueLightSt >= min)) //  checkStack && courant.ClassementValueLightSt >= min)
                                {
                                    if (!b)
                                    {
                                        courant.Empeached1 = true;
                                        b = true;
                                    }
                                    //if (courant.InStackPeremption)
                                    //{
                                    empeached.Add(t.PieceAlbum.Next.MasterId);
                                    courant.Empeached = true;
                                    // }

                                    moved.Add(t.PieceAlbum.Next.MasterId);
                                    courant.Moved = true;
                                }

                                else break;
                            }


                        }

                        if (ifirst < newElements.Count) // && checkStack)
                        {
                            //  int i = 0;

                            //HashSet<Album> aux = new HashSet<Album>();
                            //foreach (Album album in empeached)
                            //{
                            //    aux.Add(album); 
                            //}
                            //for (; i < newElements.Count; i++)
                            //{
                            //    var t = newElements[i] as Piece;
                            //    var a = t.PieceAlbum;
                            //    if (a == null)
                            //        continue;
                            //    if (aux.Add(a))
                            //    {
                            //        a.empeachedDecrement(); 
                            //    }
                            //}
                            HashSet<Album> albs = new HashSet<Album>();
                            //Album alb = null;
                            //Album alb2 = null;
                            //Album alb3 = null;
                            //Album alb4 = null;

                            courant = null;
                            int i = ifirst;
                            while (true)
                            {
                                if (i >= newElements.Count)
                                    break;
                                var t = newElements[i] as Piece;
                                if (t.InStackSize && t.ClassementValueLightSt >= min)
                                {
                                    moved.Add(t.PieceAlbum.Next.MasterId);
                                    t.Moved = true;
                                    if (t.isEmpeached())
                                    {
                                        empeached.Add(t.PieceAlbum.Next.MasterId);
                                    }

                                }
                                else if (t.AlbumAbsent)
                                { }// moved.Add(t.Album); 
                                else
                                {
                                    var _alb = t.PieceAlbum;
                                    if (courant != _alb)
                                    {
                                        courant = _alb;

                                        if (!albs.Contains(courant))
                                        {
                                            if (albs.Count < stackBefore)
                                            {
                                                albs.Add(courant);
                                            }
                                            else
                                                break;
                                        }




                                        //if (alb == null)
                                        //    alb = courant;
                                        //else if (alb2 == null)
                                        //    alb2 = courant;
                                        //else if (alb3 == null)
                                        //    alb3 = courant;
                                        //else if (alb4 == null)
                                        //    alb4 = courant;
                                        //else
                                        //    break;
                                    }

                                    newElements3.Add(t);
                                }
                                i++;
                            }

                            for (i = 0; i < newElements.Count; i++)
                            {
                                var t = newElements[i] as Piece;
                                var alb_ = t.PieceAlbum;
                                if (alb_ == null)
                                    continue;

                                if (!albs.Contains(alb_))
                                    newElements3.Add(t);
                                //if (alb_ != alb && alb_ != alb2 && alb_ != alb3 && alb_ != alb4)
                                //    newElements3.Add(t);
                            }
                        }
                        else
                            newElements3 = newElements;

                        allTracks.setNbAlbum(unavailable.Count, empeached.Count, moved.Count);



                    }
                    else
                    {
                        allTracks.setNbAlbum(-1, -1, -1);
                    }




                    var newElements2 = new List<IFile>(newElements3);
                    List<Piece> stackSorted = null;
                    //if (checkStack)
                    //{
                    stackSorted = new List<Piece>();
                    foreach (IFile iFile in newElements2)
                    {
                        //var t = Get(iFile); // TrackListViewModel.get(iFile.PieceId);// findTrack(this, iFile.PieceId);
                        //if (t != null)
                        //{
                        stackSorted.Add(iFile as Piece);
                        // }
                    }

                    stackSorted.Sort(new PieceStackCmp());

                    //}
                    foreach (IFile iFile in newElements3)
                    {
                        var keep = newElt[iFile.PieceId];
                        var t = Get(iFile); // TrackListViewModel.get(iFile.PieceId);// findTrack(this, iFile.PieceId);
                        if (t != null)
                        {
                            if (true == keep)
                            {
                                int index0 = t.Index - 1;
                                int index1 = newElements2.IndexOf(iFile);
                                if (index1 > index0)
                                {
                                    newElements2.Remove(iFile);
                                    insert(t, newElements2);
                                }

                                //if (checkStack)
                                //{
                                int index20 = t.Index2 - 1;
                                int index21 = stackSorted.IndexOf(t.PieceGen);
                                if (index21 > index20)
                                {
                                    stackSorted.Remove(t.PieceGen);
                                    insert2(t, stackSorted);
                                }
                                // }
                            }

                        }
                    }

                    foreach (TrackListViewModel k in toKeep)
                    {
                        insert(k, newElements2);
                    }

                    //if (checkStack)
                    //{
                    foreach (TrackListViewModel k in toKeep)
                    {
                        insert2(k, stackSorted);
                    }
                    // }

                    if (indexAlbumOrg >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;

                        bool dontTouch = false;

                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            var ifile = newElements2[i] as Piece;
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = newElements2.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {

                                newElements2.Remove(currentFile);
                                newElements2.Insert(newIndex, currentFile);
                            }
                        }
                    }



                    if (indexAlbumOrg2 >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;

                        bool dontTouch = false;

                        for (int i = 0; i < stackSorted.Count; i++)
                        {
                            var ifile = stackSorted[i];
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg2)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = stackSorted.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {
                                stackSorted.Remove(currentFile);
                                stackSorted.Insert(newIndex, currentFile);
                            }
                        }

                    }




                    int index = 1;
                    var rankMax = 0;
                    for (int i = 0; i < newElements3.Count; i++)
                    {
                        var ifile = newElements2[i];

                        var t = Get(ifile); // TrackListViewModel.get(ifile.PieceId); // findTrack(this, ifile.PieceId);
                        if (t == null)
                        {
                            App.log.log("file ID {0} non trouvé dans {1} {2}", ifile.PieceId, this, ifile.Location);

                        }
                        else
                        {
                            if (isMe)
                            {
                                var rank = t.RankAlbum;
                                if (rank > rankMax)
                                    rankMax = rank;


                                //var keep = newElt[ifile.PieceId];
                                //if (true != keep)
                                t.Index = index;

                                // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                                if (i == 0)
                                {
                                    t.refresh();
                                    // var g = t.Grouping; 
                                }
                            }
                        }
                        index++;
                    }

                    if (isMe)
                        Albums.RankZero = rankMax + 1;

                    //if (checkStack)
                    //{
                    index = 1;
                    for (int i = 0; i < stackSorted.Count; i++)
                    {
                        var t = Get(stackSorted[i]); // TrackListViewModel.get(stackSorted[i].PieceId); // findTrack(this, stackSorted[i].PieceId);
                        if (t == null)
                            continue;

                        //var keep = newElt[ifile.PieceId];
                        //if (true != keep)
                        t.Index2 = index;
                        // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                        if (i == 0)
                        {
                            t.refresh();
                            // var g = t.Grouping; 
                        }

                        index++;
                    }
                    // }

                    if (current != null && current.Index > 1)
                    {
                        App.log.log("le courant a l'index {0} {1}", current.Index, current);

                        int index1 = -1;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            if (newElements[i].PieceId == current.PieceId) { index1 = i; break; }
                        }

                        int index2 = -1;
                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            if (newElements2[i].PieceId == current.PieceId) { index2 = i; break; }
                        }

                        int index3 = -1;
                        for (int i = 0; i < newElements3.Count; i++)
                        {
                            if (newElements3[i].PieceId == current.PieceId) { index3 = i; break; }
                        }
                        App.log.log("indexes {0} {1} {2}", index1, index2, index3);

                    }

                    #region c'est bien mais un peu luxueux et ça casse le dont touch

                    /*
                    var hsf = new HashSet<int>();
                    var lf = new List<TrackListViewModel>();


                    var max = 0m;
                    for (int i = 0; i < newElements2.Count && i < stackBefore; i++)
                    {
                        var ifile = newElements2[i];
                        var t = Get(ifile);
                        if (t == null)
                            continue;
                        if (t.PieceGen == null || t.PieceGen.InStackPeremption)
                            continue;
                        if (hsf.Add(t.PieceId))
                        {
                            lf.Add(t);
                            max = t.ClassementValueLight;
                        }
                    }


                    for (int i = 0; i < stackSorted.Count && i < stackBefore; i++)
                    {
                        var t = Get(stackSorted[i]); // TrackListViewModel.get(stackSorted[i].PieceId); // findTrack(this, stackSorted[i].PieceId);
                        if (t == null)
                            continue;
                        if (!hsf.Contains(t.PieceId))
                        {
                            if (t.PieceGen == null || t.PieceGen.InStackPeremption)
                                continue;
                            if (t.ClassementValueLightSt > max)
                                continue;
                            hsf.Add(t.PieceId);
                            lf.Add(t);
                        }
                    }

                    lf.Sort((x, y) =>
                    {
                        var xx = x.ClassementValueLightSt > max ? x.ClassementValueLight : x.ClassementValueLightSt;
                        var yy = y.ClassementValueLightSt > max ? y.ClassementValueLight : y.ClassementValueLightSt;
                        return xx.CompareTo(yy);
                    });

                    for (int i = 0; i < lf.Count; i++)
                    {
                        lf[i].Index = i + 1;
                    }
                    */
                    #endregion




                    //if (limitList > 0)
                    //{
                    //    toAdd.Clear();
                    //    toDelete.Clear();
                    //    bool onlyNext = App.gen.FilterNext;
                    //    var list = new List<TrackListViewModel>();
                    //    foreach (IFile p in newElements3)
                    //    {
                    //        var t = Get(p); // TrackListViewModel.get(p.PieceId);
                    //        if (onlyNext && !t.PieceGen.IsNext)
                    //            continue;
                    //        list.Add(t);
                    //    }
                    //    list.Sort((x, y) => x.Index.CompareTo(y.Index));
                    //    if (list.Count > limitList)
                    //    {
                    //        list = list.GetRange(0, limitList);
                    //    }

                    //    var hs = new HashSet<int>();
                    //    foreach (TrackListViewModel t in _tracks)
                    //    {
                    //        hs.Add(t.PieceId);
                    //    }

                    //    var hsNew = new HashSet<int>();
                    //    foreach (TrackListViewModel t in list)
                    //    {
                    //        hsNew.Add(t.PieceId);
                    //        if (!hs.Contains(t.PieceId))
                    //        {
                    //            toAdd.Add(t);
                    //        }
                    //    }

                    //    foreach (TrackListViewModel t in _tracks)
                    //    {
                    //        if (!hsNew.Contains(t.PieceId))
                    //        {
                    //            toDelete.Add(t);
                    //        }
                    //    }


                    //    foreach (TrackListViewModel vm in toAdd)
                    //    {
                    //        if (writer.Aborted) return;

                    //        AddTrack(vm, false);
                    //    }

                    //    foreach (TrackListViewModel vm in toDelete)
                    //    {
                    //        if (writer.Aborted) return;
                    //        RemoveTrack(vm, false);
                    //    }
                    //}
                }

                //if (toAdd.Count > 0 || toDelete.Count > 0)
                //{
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                //if (alltracksFather != null)
                //    alltracksFather.refresh();
                //if (alltracksFatherDisabled != null)
                //    alltracksFatherDisabled.refresh();

                //}
                //filterNext = PlayerViewModel.Instance.FilterNext; 
            }
        }

        //private class StackCmp : IComparer<TrackListViewModel>
        //{
        //    public int Compare(TrackListViewModel x, TrackListViewModel y)
        //    {
        //        int cmp = x.ClassementValueLightSt.CompareTo(y.ClassementValueLightSt);
        //        //if (x.StackValue > 0 && y.StackValue > 0)
        //        //    cmp = 
        //        //else
        //        //    cmp = x.Index.CompareTo(y.Index);
        //        if (cmp != 0)
        //            return cmp;
        //        return x.Index.CompareTo(y.Index);
        //    }
        //}

        public IEnumerator<PlayListViewModel> GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        private SortDescriptionCollection sort;
        public SortDescriptionCollection Sort { get { return sort; } set { sort = value; } }

#if EXPORT
        public string getEmpreinte()
        {
            var sb = new StringBuilder();
            sb.Append(exportTracks.Count);
            sb.Append(" éléments:");
            long hash = 0;
            foreach (TrackListViewModel t in exportTracks)
            {
                hash += t.PieceId.GetHashCode();
            }
            sb.Append(hash);

            return sb.ToString();

        }
#endif
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\MockLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.iit;
using pdb.obj;

namespace pdb.podcast
{
    public class MockLoader : ILoader
    {
        private string defaultFolder;
        private CPlayList root = new CPlayList("root");

        public MockLoader(string defaultFolder)
        {
            this.defaultFolder = defaultFolder;
            if (!defaultFolder.EndsWith(@"\"))
                defaultFolder += @"\";
        }

        public void saveIds()
        {

        }

        public void init()
        {

        }

        public void loadTracks(bool firstStep, bool forceLoad, List<pdb.obj.ITrackInfoItunes> list)
        {

        }

        public void loadTracks(List<pdb.obj.ITrackInfoItunes> list)
        {

        }

        public string DefaultFolder
        {
            get { return defaultFolder; }
        }

        public bool ModeXml
        {
            set { }
        }

        public void import(pdb.obj.ITrackInfoItunes track)
        {

        }

        public void merge(pdb.obj.ITrackInfoItunes track)
        {

        }

        public PlayListComposite TreePlayList
        {
            get { return root; }
        }

        public int NbTrackCreated
        {
            get { return 0; }
        }

        public void reviveIfNecessary(ITrackInfoItunes track)
        {

        }

        public IPlayListFilter PlayListFilter
        {
            set { }
        }

        public pdb.obj.PlayListComposite getOrCreateFolder(string folder)
        {
            PlayListComposite plFolder = root.getComposite(folder);
            if (plFolder == null)
            {
                plFolder = new CPlayList(folder, root);
            }
            return plFolder;
        }

        public pdb.obj.PlayListComposite getOrCreateFolder(pdb.obj.PlayListComposite folder, string name, bool buildIf)
        {
            CPlayList plFolder = folder.getComposite(name) as CPlayList;
            if (plFolder == null)
            {
                plFolder = new CPlayList(name, folder as CPlayList);
            }
            return plFolder;
        }

        public pdb.iit.IPlayList getPlayList(pdb.obj.PlayListComposite folder, string name, bool buildIf)
        {
            throw new NotImplementedException();
        }

        public void mergeList(pdb.obj.CPlayList playlist, ICollection<pdb.obj.IFile> newElements_, bool withOrder, pdb.obj.IAbortTask writer, pdb.obj.IBgTask task)
        {
            
        }

        public void setConf(System.Xml.XmlElement xml)
        {

        }

        public bool Aborted
        {
            set { }
        }





        public bool LoadUrl
        {
            set { }
        }



        public void mergeList(CPlayList playlist, ICollection<IFile> newElements_, HashSet<string> ignore, bool withOrder, IAbortTask writer, IBgTask task)
        {
            throw new NotImplementedException();
        }


        public void updatePocasts()
        {
            throw new NotImplementedException();
        }


        public void loadTrackToDownload(IDictionary<string, ITrackInfoItunes> urls)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.iit;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Albums;
using pdb.podcast.Auto;
using pdb.podcast.Delta;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Sort;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;
using PlayList = pdb.it.PlayList;
using pdb.podcast.Date0;
using pdb.podcast.Notes;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static ILoader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto;
        static int step = -1;
        static Program _instance = new Program();
        // static bool calculRoots = false;
        static List<HashSet<int>> lists = null;
        static AlbumMgr albumMgr = AlbumMgr.Instance;

        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        public static Chrono chrono = new Chrono();
        private static Logger logChrono;
        private static DB.Db db;
        static Hibernator hibernator = new Hibernator();

        //public static DB.Db Db { get { return db; } }


        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {
            Logger.init(Environment.CurrentDirectory.Replace("\\", "_") + string.Join("_", args));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono", true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true;

            FileRegister.init(new Dictionary<string, FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true;

                loader.saveIds();
                //if (db != null)
                //    db.write();

                if (db != null)
                {
                    while (db.Writing)
                    {
                        misc.log("waiting db writing");
                        Thread.Sleep(1000);
                    }
                }
                Console.WriteLine("\nFin de l'opération d'enregistrement.");

                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();

                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Memory.End();
                Exporter.Abort();



                //if (_writeDb != null)
                //{
                //    misc.log("attente writeDb");
                //    _writeDb.Wait();
                //}
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                if (db != null)
                    db.write();
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}

        #region Task


        private List<ITrackInfoItunes> loadTracks(bool firstStep, bool forceLoad)
        {
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
            loader.loadTracks(firstStep, forceLoad, listTrack);

            return listTrack;

        }
        #endregion


        private static void SyncDb(List<TrackInfoItunes> list, bool checkInOut)
        {
            if (db == null)
                return;
            log.log("SyncDb checkInOut= " + checkInOut);
            foreach (TrackInfoItunes t in list)
            {
                if (checkInOut)
                    t.checkInOut();
                var tdb = db.get(t);
                if (tdb == null)
                {
                    log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                    continue;
                }
                tdb.synch(t);

            }
            log.log("Fin SyncDb checkInOut= " + checkInOut);

        }

        public void go(string[] args)
        {
            //  TrackInfoItunes.AlbumMgr = albumMgr;
            //int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            //if (countArgs > 0)
            //    confFile = args[0];
            bool _fin = false;

            bool modeDownLoad = false;
            foreach (string v in args)
            {
                if ("-download".Equals(v))
                {
                    modeDownLoad = true;
                    log.log("mode download");
                }
            }

            Album.logDebug = Logger.getLogger("pubDebug", false);
            Album.log = Logger.getLogger("pub2", Album.logDebug, true);
            Album.logDebug.NoReset = true;
            Album.log.NoReset = true;

            DateRefBuilder dateRefBuilder = new DateRefBuilder();
            try
            {

                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start(60);

                // bool firstLoad = true;


                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                // TrackInfoItunes.setDate0(Conf.Date0);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                //TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                TrackInfoItunes.PlayedLevel = Conf.DateLevel;
                var itConf = new pdb.it.Conf(xelt);

                // loader = new Loader(itConf, true);
                bool import = Conf.Import.enabled || Conf.Import.merge;
                db = new DB.Db();


                if (Conf.UseMock)
                    loader = new MockLoader(itConf.DefaultFolder);
                else
                    loader = new Loader(itConf, import, db,
                        () =>
                        {
                            misc.Pre = "[Load " + step + "] ";

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.AbortSpecial();
                            //   Thread.Sleep(1000); 
                            //  BackGroundTaskMgr.Start(); 
                        }, Conf.OnlyEnabled, Conf.OnlyUnRead)

                   ;
                // loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder;

                db.load();
                //  db.write(); return; 


                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();

                List<TrackInfoItunes> listIt = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);




                bool firstlaunched = false;
                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}"));
                        chrono.reset("Program");

                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.setConf(xelt);
                        //loader.Conf = new it.Conf(xelt);
                        // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut", true);
                        List<TrackInfoItunes> list = null;
                        DirConf root = null;
                        if (step == 0 || !Conf.Simulation)
                        {
                            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();



                            listTrack = loadTracks(step == 0, AutoBuilder.MustUpdate);


                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();

                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            // listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {

                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                // loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            //    loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            listIt = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            // GroupStat trackStat = new GroupStat();

                            loader.saveIds();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location)) // || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }
                                    FileRegister.Push(location);
                                    dictLoc[t.Location] = t;
                                    listIt.Add(t);
                                    // if (!t.Played)
                                    //    trackStat.recordTrack(t, typeState.all);
                                    //trackStat.recordTrack(t, typeState.all);
                                }
                            }



                            db.recordIt(listIt);
                            chrono.bip("loadTracks", true);
                            var dedoubler = new Dedoubler();
                            dedoubler.checkDoublons(db.Tracks);
                            chrono.bip("Dedoubler", true);

                            //if (dedoubler.NbDoublons>0)
                            //{
                            //    db.write(); 
                            //}

                            Download.Downloader downloader = null;
                            if (modeDownLoad)
                            {
                                //new Thread(() => loader.updatePocasts()).Start();
                                downloader = new Download.Downloader(db);
                                downloader.go();

                                loader.loadTrackToDownload(downloader.ToDownload);
                                return;
                            }



                            // ici on peut faire la verification des doublons - track hibernés et re-téléchargés par ce con d'itunes
                            using (var albumConsolid = new AlbumConsolid())
                            {
                                foreach (TrackAlbum album in albumMgr.List)
                                {
                                    albumConsolid.consolid(album);
                                }
                            }

                            log.log("nb123={0} nb12={1} nb13={2} nb23={3} nb1={4} nb2={5} nb3={6} nb0={7}, nb3n={8}",
                                AlbumConsolid.nb123, AlbumConsolid.nb12, AlbumConsolid.nb13, AlbumConsolid.nb23,
                                AlbumConsolid.nb1, AlbumConsolid.nb2, AlbumConsolid.nb3, AlbumConsolid.nb0, AlbumConsolid.nb3n);

                            var scan = Conf.Scan;
                            if (!string.IsNullOrEmpty(scan))
                            {
                                var s = new Scanneur(scan, loader as Loader, db);
                                s.Scan();
                                db.write();
                                return;
                            }
                            root = Conf.DirConf;
                            var feeds = root.Feeds;

                            if (Conf.Freewheel)
                            {
                                PlayList.StartOpe();
                                Freewheel(root);
                                log.log("Freewheel : fin sans enregistrement DB");
                                return;
                            }



                            if (Conf.Import.enabled)
                            {
                                var listImport = new List<TrackInfoItunes>();
                                hibernator.select(Conf.Import, listImport, db.Tracks, true);

                                foreach (TrackInfoItunes tdb in listImport)
                                {
                                    loader.import(tdb);
                                }
                            }
                            else if (Conf.Import.merge)
                            {
                                foreach (TrackInfoItunes t in listIt)
                                    loader.merge(t);
                            }



                            list = db.Tracks;
                            foreach (TrackInfoItunes track in list)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds", true);


                            var loaded = feeds.Loaded;
                            loaded.Sort(new PodCastComparer());

                            bool changeDate = false;
                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            {
                                dateRefBuilder.prepare(loaded);

                            }

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);



                            if (Conf.Sort.selectionBefore)
                            {



                                //***************** Lancement "pour de vrai" ***************************************

                                LimitItemLoader.ModeSelection = true;

                                loadCandidat(root);
                                chrono.bip("loadCandidat(root)");
                                //  AutoBuilder.test(); 
                                // standAlone(root); 
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root)");
                                //**********************************************************************************


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, true);
                                //****************************************


                            }



                            if (Conf.Sort.checkBefore)
                            {
                                Album.Init();
                                var sorter = new Sorter(Conf.Sort, list);
                                sorter.build();
                                chrono.bip("sorter.build();", true);


                                changeDate = dateRefBuilder.autoSafe(loaded);
                                //TrackInfoItunes.setDate0(Conf.Date0);
                                double offsetIni = dateRefBuilder.getOffset();
                                AutoBuilder.Offset = offsetIni;

                                if (Album.NbRepeches > 0 && !Conf.DateRef.auto)
                                {
                                    log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                    _fin = true;
                                }
                            }

                            dateRefBuilder.saveCurrent();
                            ContexteBuilder.Instance.init(loaded);
                            Conf.DateRef.contexte = ContexteBuilder.Instance.Debut;

                            if (Conf.Import.enabled || Conf.Import.merge)
                            {
                                _fin = true;

                            }



                            if (_fin)
                            {
                                log.log("fin sans enregistrement DB");
                                //  db.write();


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, false);
                                //****************************************
                                return;
                            }


                            if (Album.NbModif > 0)
                            {
                                resetLoad(root);

                            }
                            //bool changeDate = false;
                            //if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            //{
                            //    changeDate = dateRefBuilder.auto(loaded);
                            //    TrackInfoItunes.setDate0(Conf.Date0);
                            //    double offsetIni = dateRefBuilder.getOffset();
                            //    AutoBuilder.Offset = offsetIni;
                            //}
                            AutoBuilder.init(true);
                            if (Conf.Sort.stopOnOffset && changeDate)
                            {
                                log.log("fin cause stopOnOffset");
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                                return;
                            }

                            if (Conf.Sort.stopOnPub2 && Album.NbModifPertinent > 0)
                            {
                                log.log("fin cause stopOnPub2");
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                                return;
                            }

                            AutoBuilder.Offset = 0;
                            chrono.bip("AutoBuilder.init(true)");
                            xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            loader.setConf(xelt);

                            //ContexteBuilder.Instance.init(loaded);

                            //Conf.DateRef.contexte = ContexteBuilder.Instance.Debut;
                            //   dateRefBuilder.saveCurrent();



                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            //trackStat.report(descTrack);
                            //log.log(descTrack.ToString());

                            //var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            //var trackFile = DescBuilder.create("Tracks", sbT);
                            //trackStat.report(trackFile);
                            //sbT.Flush();

                            //asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            //chrono.bip("desc tracks", true);
                            //Logger.LogConsole = false;
                            //        loader.loadLists();
                            Logger.LogConsole = true;
                            chrono.bip("load list", true);

                        }
                        list = db.Tracks;


                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program");
                            root = Conf.DirConf;
                            var feeds = root.Feeds;
                            foreach (TrackInfoItunes track in feeds.getSelectedTracks())
                            {
                                track.clearLists();
                            }

                            feeds.clearSelectedTracks();

                            chrono.bip("track.clearLists", true);

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;




                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true;
                            AutoBuilder.init(true);
                            chrono.bip("AutoBuilder.init(true)");
                            loadCandidat(root);
                            chrono.bip("loadCandidat(root)");
                            //  AutoBuilder.test(); 
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            chrono.bip("Selection(root)");
                            //**********************************************************************************

                            Album.Init();

                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.reset ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.once ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.white ||
                                (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all && !firstlaunched))
                            {
                                if (Sorter.NbLaunch == 0 || (Conf.Sort.enabled != Tuning.Sort.sortMode.white && Conf.Sort.enabled != Tuning.Sort.sortMode.once))
                                {
                                    var sorter = new Sorter(Conf.Sort, list);
                                    sorter.build();
                                }
                                _fin = Conf.Sort.enabled == Tuning.Sort.sortMode.white || Conf.Sort.enabled == Tuning.Sort.sortMode.reset;
                                if (!_fin && Album.NbModif > 0)
                                    resetLoad(root);
                            }

                            firstlaunched = true;

                            if (Album.NbRepeches > 0)
                            {
                                log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                _fin = true;
                            }



                            if (!_fin) // && Album.NbModif == 0)
                            {

                                //***************** Lancement "pour de faux" ***************************************
                                AutoBuilder.Init3();
                                chrono.bip("AutoBuilder.Init3()");
                                LimitItemLoader.ModeSelection = false;
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root) 2");
                                LimitItemLoader.ModeSelection = true;
                                //**********************************************************************************
                            }
                            Exporter.TopCopy();
                            chrono.bip("selection");




                            // Conf.date00Consume();
                            // TrackInfoItunes.setDate0(Conf.Date0);

                            int iii = 0;
                            while (!BackGroundTaskMgr.ConfirmEnd(10))
                            {
                                iii++;
                                if (iii == 60)
                                    iii = 0;
                                if (iii == 0)
                                {
                                    log.log("Attente Classement");
                                }
                                Thread.Sleep(100);
                            }






                            if (_fin || Album.NbModif > 0)
                            {
                                log.log("{0} éléments ont la Pub2 modifiée", Album.NbModif);

                                //foreach (TrackInfoItunes t in list)
                                //{
                                //    var tdb = db.get(t);
                                //    if (tdb == null)
                                //    {
                                //        log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                //        continue;
                                //    }
                                //    tdb.synch(t);

                                //}



                                if (_fin)
                                {
                                    SyncDb(list, true);
                                    db.writeAsync();
                                    log.log("fin");
                                    return;
                                }
                                // continue;
                            }




                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    //if (count == 1)
                                    //    s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu");

                            if (Conf.GenFeed)
                            {
                                foreach (RootItItem rootItem in Conf.RootIt)
                                {
                                    var fAuto = loader.TreePlayList.getComposite(rootItem.name);
                                    var fFeeds = fAuto.getComposite("Feed");

                                    if (fFeeds != null)
                                    {
                                        scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                    }

                                }
                            }


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root, false);
                            //****************************************



                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                            //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            chrono.bip("AutoBuilder.init(false)");
                            bool cangoAuto = AutoBuilder.Check(feeds);

                            chrono.bip("AutoBuilder");
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");

                                postReport(root, true);

                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false;
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true;
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                //  tw = new StringBuilder();
                                //feeds.rapportPreSelected(tw);
                                //asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false;
                                log.log(sb2.ToString());
                                Logger.LogConsole = true;


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false;
                                log.log(sb3.ToString());
                                Logger.LogConsole = true;
                                chrono.bip("rapport", true);
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 



                        SyncDb(list, true);
                        db.writeAsync();


                        Logger.CreateNullLoggers = false;

                        int nbH = 0;
                        _fin = false;
                        if (Conf.Hibernate.enabled)
                        {
                            nbH = hibernator.go(loader, list);
                            if (nbH > 0)
                            {
                                log.log("{0} elements hibernés", nbH);
                                _fin = true;
                            }
                        }

                        lists = null;
                        WritePlayList(root);




                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;

                            Dictionary<string, Dictionary<int, TrackInfoItunes>> depots = new Dictionary<string, Dictionary<int, TrackInfoItunes>>();
                            foreach (SelectParam p in listP)
                            {

                                listS = new List<TrackInfoItunes>();
                                if (!string.IsNullOrEmpty(p.name))
                                {
                                    // Compatibilité anciennes listes
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                    buildList("_" + p.level, listS, prior, folder);
                                }
                                else
                                {

                                    var pp = p.Clone() as SelectParam;
                                    feeds.buildFirstSelectedTrackLevel(listS, p);

                                    var l = new List<TrackInfoItunes>();

                                    pp.nb = int.MaxValue;
                                    var selector = new TrackSelector(pp);
                                    foreach (TrackInfoItunes t in listS)
                                    {
                                        if (selector.select(t))
                                            l.Add(t);
                                    }

                                    string path = p.path;
                                    if (!string.IsNullOrWhiteSpace(path))
                                        buildList(path, l, prior);

                                    string[] _depots = p.depot;
                                    if (_depots != null)
                                    {
                                        foreach (string depot in _depots)
                                        {
                                            if (!depots.ContainsKey(depot))
                                                depots.Add(depot, new Dictionary<int, TrackInfoItunes>());

                                            var dep = depots[depot];
                                            foreach (TrackInfoItunes t in l)
                                            {
                                                if (!dep.ContainsKey(t.DbId))
                                                    dep.Add(t.DbId, t);
                                            }
                                        }
                                    }
                                }
                            }

                            foreach (KeyValuePair<string, Dictionary<int, TrackInfoItunes>> kvp in depots)
                            {
                                string path = kvp.Key;

                                var l = new List<TrackInfoItunes>(kvp.Value.Values);
                                l.Sort(new PodcastComparerPubPub2());
                                buildList(path, l, prior);
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);

                        var listSelected = root.Feeds.getSelectedTracks();

                        var sorterafter = new Sorter(Conf.Sort, list);
                        //    sorter.build();

                        foreach (TrackInfoItunes s in listSelected)
                        {
                            s.updateNative();
                        }






                        //if (Conf.Hibernate.enabled)
                        //{
                        //    Hibernator hibernator = new Hibernator();
                        //    var nb = hibernator.go(loader); 
                        //    if (nb >0)
                        //    {
                        //        misc.log("{0} elements hibernés", nb);
                        //        misc.log("fin ");
                        //        return; 
                        //    }

                        //}


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                log.log("Attente Classement");
                            }
                            Thread.Sleep(100);
                        }



                        //if (Conf.Sort.enabled >= Tuning.Sort.sortMode.once_all)
                        //{
                        //    var sorter = new Sorter(Conf.Sort, list);
                        //    sorter.build();
                        //}

                        if (Conf.Hibernate.enabled)
                        {
                            hibernator.doH();
                        }

                        if (loader.NbTrackCreated > 0)
                        {
                            log.log("{0} éléments ont été recréés", loader.NbTrackCreated);
                            _fin = true;
                        }

                        if (Album.NbRepeches > 0)
                        {
                            log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                            _fin = true;
                        }



                        if (Conf.UseMock)
                            _fin = true;



                        if (_fin)
                        {


                            log.log("fin");

                            return;
                        }





                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");



                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in db.Tracks)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogAll(ex.ToString());
                        misc.log(ex.ToString());
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        //private DirConf _attenteWriteHtml;
        // private volatile object _lockReportHtml = new object();
        private bool _end;
        // ThreadUtil thReport;
        DateTime lastReport;

        private void postReport(DirConf dir, bool force)
        {
            if (force || lastReport.AddSeconds(10) < DateTime.Now)
            {
                try
                {
                    reportHtml(dir);
                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                lastReport = DateTime.Now;
            }
            //if (thReport == null)
            //{
            //    lock (_lockReportHtml)
            //    {
            //        if (thReport == null)
            //        {
            //            thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
            //            thReport.Start();
            //        }
            //    }
            //}

            //lock (_lockReportHtml)
            //    _attenteWriteHtml = dir;
        }

        //private void loopReportHtml()
        //{
        //    DirConf traite = null;
        //    while (!_end)
        //    {
        //        Thread.Sleep(1000);
        //        if (_attenteWriteHtml == null)
        //            continue;
        //        lock (_lockReportHtml)
        //        {
        //            if (_attenteWriteHtml == null)
        //                continue;
        //            traite = _attenteWriteHtml;
        //            _attenteWriteHtml = null;
        //        }
        //        reportHtml(traite);
        //    }
        //}


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
                //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
                //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders, false);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders, false);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders, false);
        }

        public static void buildList(string path, List<TrackInfoItunes> list_, int prior)
        {
            bool absolutePath = path.StartsWith(@"\");
            var tab = path.Split('\\');
            int count = tab.GetLength(0);
            var folder = new List<string>();

            foreach (string s in tab)
            {
                if (!string.IsNullOrWhiteSpace(s))
                    folder.Add(s);
            }

            buildList(list_, prior, folder, absolutePath);
        }



        public static void buildList(List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            var newf = new List<string>(folders);
            int count = newf.Count;

            string name = newf[count - 1];
            newf.RemoveAt(count - 1);
            buildList(name, list_, prior, newf, absolutePath);
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            try
            {
                if (Conf.Simulation)
                    return;
                if (Conf.UseMock)
                {
                    var sb = new StringBuilder();
                    foreach (string f in folders)
                    {
                        sb.Append(f); sb.Append(@"\");
                    }
                    sb.Append(name);
                    log.logNoDate("---------------------------");
                    log.log("liste {0}", sb.ToString());
                    if (list_ != null)
                    {
                        foreach (TrackInfoItunes t in list_)
                        {
                            log.logNoDate(t.ToString());
                        }
                    }
                    return;
                }

                if (list_ != null && !Conf.NoRevival)
                {
                    foreach (TrackInfoItunes track in list_)
                    {
                        loader.reviveIfNecessary(track);
                    }
                }



                var rootIt = Conf.RootIt;
                RootItItem currentRoot = rootIt.roots[0];
                int count = rootIt.roots.Count;

                if (list_ != null)
                {
                    //   log.log("build list {0}",name);
                    //  var list = new List<IFile>(list_);
                    if (lists == null)
                    {
                        lists = new List<HashSet<int>>();
                        foreach (var item in rootIt.roots)
                        {
                            lists.Add(new HashSet<int>());
                        }
                        var list__ = new List<TrackInfoItunes>(list_);
                        list__.Sort(new PodcastComparerPubPub2());



                        int countTrack = list_.Count;

                        long size = 0;
                        int j = 0;
                        int indexRoot = 0;

                        //    HashSet<int> current = lists[0]; 

                        while (true)
                        {
                            if (j >= countTrack)
                                break;
                            TrackInfoItunes track = list__[j];
                            size += track.Size;
                            if (size <= currentRoot.size)
                            {
                                lists[indexRoot].Add(track.DbId);
                                // track.IndexRoot = indexRoot;
                            }
                            else
                            {

                                size = 0;
                                //  size += track.Size;
                                indexRoot++;
                                if (indexRoot >= count)
                                    break;
                                currentRoot = rootIt.roots[indexRoot];
                                continue;
                            }
                            j++;
                        }

                    }
                }


                for (int r = 0; r < count; r++)
                {
                    currentRoot = rootIt.roots[r];
                    folders = new List<string>(folders);
                    PlayListComposite folder = null;

                    if (absolutePath)
                    {
                        if (r > 0)
                            throw new Exception("un chemin absolu ne peut pas être géré dans une partition");
                        // folders[0] = folders[0].Substring(1);
                        folder = loader.TreePlayList;

                    }
                    else
                        folder = loader.TreePlayList.getComposite(currentRoot.name);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(currentRoot.name);


                    var nname = name;
                    if (name.Contains(Path.DirectorySeparatorChar.ToString()))
                    {
                        var tab = name.Split(Path.DirectorySeparatorChar);
                        string str = null;
                        for (int i = 0; i < tab.GetLength(0); i++)
                        {
                            if (str != null)
                                folders.Add(str);
                            if (!string.IsNullOrEmpty(tab[i]))
                                str = tab[i];
                        }
                        if (!string.IsNullOrEmpty(str))
                            nname = str;
                    }
                    List<IFile> l = null;

                    if (list_ != null)
                    {
                        l = new List<IFile>();
                        foreach (TrackInfoItunes t in list_)
                        {
                            if (lists[r].Contains(t.DbId))
                            {
                                if (Conf.NoRevival)
                                {
                                    if (!t.Present)
                                        continue;
                                }

                                l.Add(t);
                            }
                        }
                    }


                    for (int i = 0; i < folders.Count; i++)
                    {
                        var aux = folder;
                        folder = folder.getComposite(folders[i]);
                        if (folder == null)
                            folder = loader.getOrCreateFolder(aux, folders[i], l == null ? true : l.Count > 0);
                        if (folder == null)
                            return;
                    }

                    //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
                    var playlist = loader.getPlayList(folder, nname, l == null ? true : l.Count > 0);
                    if (playlist != null)
                    {
                        if (prior < int.MaxValue && prior >= 0)
                            playlist.setPrior(prior);
                        //if (list.Count > 0)


                        playlist.mergeList(l, hibernator.Ignore, _instance, Conf.OnlyEnabled, Conf.OnlyUnRead);
                        //  loader.mergeList(playlist, l, false, _instance, null);
                        //else
                        //    loader.removeList(folder, name);
                    }



                    //log.log("clear list {0}", name); 
                    //loader.ClearList(playlist);
                    //log.log("add items {0}", name); 
                    //foreach (TrackInfoItunes track in list)
                    //    loader.addItemToList(playlist, track); 

                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }


        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildGlobalList(string path, List<TrackInfoItunes> list_, int prior)
        {
            PlayListComposite folder = null;
            List<string> folders = new List<string>();
            string nname = "";
            if (Conf.UseMock)
                return;
            try
            {

                var tab = path.Split(Path.DirectorySeparatorChar);
                string str = null;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    if (str != null)
                        folders.Add(str);
                    if (!string.IsNullOrEmpty(tab[i]))
                        str = tab[i];
                }
                if (!string.IsNullOrEmpty(str))
                    nname = str;

                folder = loader.TreePlayList;





                var l = new List<IFile>();
                foreach (TrackInfoItunes t in list_)
                {
                    if (t.Present)
                        l.Add(t);
                }

                for (int i = 0; i < folders.Count; i++)
                {
                    var aux = folder;
                    folder = folder.getComposite(folders[i]);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(aux, folders[i], l.Count > 0);
                    if (folder == null)
                        return;
                }


                var playlist = loader.getPlayList(folder, nname, l.Count > 0);
                if (playlist != null)
                {
                    if (prior < int.MaxValue && prior >= 0)
                        playlist.setPrior(prior);


                    playlist.mergeList(l, hibernator.Ignore, _instance, false, false);

                }



            }

            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }




        }

        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            DateTime now = DateTime.Now;

            fLoader.Action(pre);
            var ts = (DateTime.Now - now).TotalMilliseconds;
            if (ts > 1 && Conf.LogDir && pre > action.none && pre < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", pre, dir.getPath(), ts.ToString("0"));
            }

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());

            now = DateTime.Now; ts = (DateTime.Now - now).TotalMilliseconds;
            fLoader.Action(post);

            if (ts > 1 && Conf.LogDir && post > action.none && post < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", post, dir.getPath(), (DateTime.Now - now).TotalMilliseconds.ToString("0"));
            }


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }

        private void resetLoad(DirConf dir)
        {
            recursif(dir, action.resort, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void Freewheel(DirConf dir)
        {
            dir.Loader.LimitsLoader.Freewheel();
        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
            List<TrackInfoItunes> list = null;
            //  var list = db.Tracks.FindAll(t => t.Present);
            //var list = db.Tracks.FindAll(t => t.isConcernedBySelection); 
            var Fin1ereJournee = ContexteBuilder.Instance.Fin1ereJournee;
            var limitContexte = ContexteBuilder.Instance.LimitWriteList;
            if (Conf.UseMock)
                list = db.Tracks.FindAll(t => t.isConcernedBySelection && t.isPodcast);
            else
                list = db.Tracks.FindAll(t => t.Present && t.isConcernedBySelection && t.isPodcast && t.Pub2 <= limitContexte);
            foreach (SelectParamBase listeGlobal in Conf.GlobalListes)
            {
                var selector = new TrackSelector(listeGlobal);
                var l = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (selector.select(t))
                        l.Add(t);
                }

                buildGlobalList(listeGlobal.path, l, 2);

            }

            //foreach (Note note in Conf.Notes)
            //{
            var builder = dir.NoteBuilder;
            if (builder == null)
                return;
            var note = builder.Note; // note.NoteBuilder; // new NoteBuilder(note);
            builder.build(list);
            builder.display();
            foreach (ListNote listNote in builder.Depot)
            {
                var path = string.Format(note.path, listNote.Note);
                var _l = listNote.List;
                if (note.histo)
                    _l.Sort(new PodCastComparer());
                else
                    _l.Sort(new PodCastComparerInv());
                buildGlobalList(path, _l, 2);

                if (!string.IsNullOrEmpty(note.single))
                {
                    var pathSingle = string.Format(note.single, listNote.Note);
                    var hs = new HashSet<string>();
                    var ls = new List<TrackInfoItunes>();
                    foreach (TrackInfoItunes t in _l)
                    {
                        if (!t.Selected)
                            continue;
                        if (!hs.Add(t.AlbumKey))
                            continue;
                        ls.Add(t);
                    }
                    buildGlobalList(pathSingle, ls, 2);
                }
            }
            // Sélection d'un unique item (preise encompte des niveaux précédents)
            if (!string.IsNullOrEmpty(note.unique))
            {
                Logger logger = Logger.getLogger("NotesU", false);
                //Dictionnaire global
                var hsGlobal = new HashSet<string>();
                var depot = new List<ListNote>(builder.Depot);
                int count = depot.Count;

                for (int i = count - 1; i >= 0; i--)
                {
                    ListNote listNote = depot[i];
                    var _l = listNote.List.FindAll(t => t.Selected && t.Pub <= Fin1ereJournee);
                    _l.Sort(new PodCastComparer());

                    var linv = _l.FindAll(t => t.Recent && ContexteBuilder.Instance.getRetard(t, note.date0Min) <= note.retardHisto);
                    linv.Sort(new PodCastComparerInv());

                    foreach (TrackInfoItunes t in _l)
                    {
                        if (linv.Contains(t))
                            continue;
                        linv.Add(t);
                    }

                    //if (note.histo)
                    //    _l.Sort(new PodCastComparer());
                    //else
                    //    _l.Sort(new PodCastComparerInv());
                    var ls = new List<TrackInfoItunes>();
                    var hs = new HashSet<string>();
                    var pathUnique = string.Format(note.unique, listNote.Note);
                    foreach (TrackInfoItunes t in linv)
                    {
                        //if (!t.Selected)
                        //    continue;
                        if (hsGlobal.Contains(t.AlbumKey))
                            continue;
                        if (hs.Contains(t.AlbumKey))
                            continue;
                        if (t.Pub <= ContexteBuilder.Instance.Zero)
                        {
                            hsGlobal.Add(t.AlbumKey);
                            hs.Add(t.AlbumKey);
                        }
                        else
                        {
                        }

                        ls.Add(t);

                        var tn = listNote.getTrackNote(t.DbId);
                        tn.log(logger);
                    }

                    buildGlobalList(pathUnique, ls, 2);
                }
            }

            //  }

            var contextB = ContexteBuilder.Instance;

            if (contextB.Enabled)
            {

                var selected = dir.getListe();
                selected.Sort(new PodCastComparer());
                var listContext = new List<TrackInfoItunes>();
                contextB.buildList(selected, listContext);

                buildList("_contexte", listContext, 2);
            }



        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                            break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Grouping = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Tuning\Conf.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Xml;
using pdb.ordo.conf;
using pdb.podcast.Auto;
using pdb.util;

namespace pdb.podcast.Tuning
{
    public enum menage
    {
        none,
        read,
        name
    }
    public class Conf
    {
        string SOV = "..\\sov\\";
        //private static string CONF_FILE = @"..\conf.xml";
        #region membres
        private DirConf root;
        private XmlElement xDir;
        private bool buildLimitMulti;
        private bool single;
        private Move move;
        private bool deleteDoublon;
        private bool getDescription;
        private int volumeMin = int.MinValue;
        private bool simulation;
        private string copyAll;
        private int maxScan = 10;
        private ConfOrdo ordo = new ConfOrdo();
        private menage menage = menage.none;
        private string poubelle = "";
        // private string zique;
        private bool writePlayLists;
        private bool writePreSel;
        private bool writeItems;
        private bool writeUse;
        private bool writeExclu;
        private bool genFeed;
        private int genFeedPrior = 11;
        private int genUsePrior = 11;
        private int genExcluPrior = 11;
        //private bool transmit = true;
        //private bool transmitTotal = true;
        //private bool transmitTotalGuest = true;
        private bool? cascading = null;
        private bool autoBlock;

        private ConfDate dates = new ConfDate();

        private List<SelectParam> selectParams = new List<SelectParam>();
        private List<Note> notes = new List<Note>();
        private Journal journal;
        private RootIt rootIt = new RootIt();
        private bool onlyEnabled = true;
        private bool onlyUnRead = true;
        private bool checkExist = true;

        // private Auto auto = null;
        private bool logGen = true;
        //private DateTime date0;
        //private DateTime date00;
        private double deltaOpen = 70;
        private Html html = new Html();

        private bool autoSequence = true;
        private bool borderVirtual;
        private bool borderIdem;
        private bool borderGranSlam;
        private bool borderTb;
        private bool autoSelect;
        private bool logDir;

        private Export export = new Export();
        private Hibernate import = new Hibernate();
        private Sort.Sort sort = new Sort.Sort();
        private Hibernate hibernate = new Hibernate();
        private Db db = new Db();
        private ConfAlbums albums = new ConfAlbums();
        private Listes listes = new Listes();
        private Listes globalListes = new Listes();

        private bool checkPub = true;

        private bool useMock;
        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        private bool freewheel = false;
        /// <summary>
        /// Semi-roue libre: on calcule les liste, mais on ne résurectionne pas de nouveaux tracks
        /// </summary>
        private bool noRevival = false;

        private string scan;

        private Contexte contexte = new Contexte();
        private DateRef dateRef = new DateRef();

        private List<string> folders = new List<string>();
        #endregion
        public static readonly Conf Instance = new Conf();
        private static bool started;
        private Conf() { confFile = new FileInfo(@"..\conf.xml"); }
        public void setConfFile(string conf)
        {
            this.confFile = new FileInfo(@"..\" + conf);

            if (!Directory.Exists(SOV))
                Directory.CreateDirectory(SOV);

            string timeStamp = DateTime.Now.ToString("yyyy-MM-dd HH_mm_ss");
            File.Copy(confFile.FullName, string.Format("{0}{1}_{2}", SOV, timeStamp, confFile.Name), true);
        }

        #region getters
        public static bool BuildLimitMulti { get { return Instance.buildLimitMulti; } }
        public static bool Single { get { return Instance.single; } }
        public static DirConf DirConf { get { return Instance.root; } }
        public static Move Move { get { return Instance.move; } }
        public static bool DeleteDoublon { get { return Instance.deleteDoublon; } }
        public static bool GetDescription { get { return Instance.getDescription; } }
        public static int VolumeMin { get { return Instance.volumeMin; } }
        public static bool Simulation { get { return Instance.simulation; } }
        public static string CopyAll { get { return Instance.copyAll; } }
        public static ConfOrdo Ordo { get { return Instance.ordo; } }
        public static int MaxScan { get { return Instance.maxScan; } }
        public static menage Menage { get { return Instance.menage; } }
        public static string Poubelle { get { return Instance.poubelle; } }
        public static bool WritePlayLists { get { return Instance.writePlayLists; } }
        public static bool WritePreSel { get { return Instance.writePreSel; } }
        public static bool WriteItems { get { return Instance.writeItems; } }
        public static bool WriteUse { get { return Instance.writeUse; } }
        public static bool WriteExclu { get { return Instance.writeExclu; } }
        public static bool GenFeed { get { return Instance.genFeed; } }
        public static int GenFeedPrior { get { return Instance.genFeedPrior; } }
        public static int GenUsePrior { get { return Instance.genUsePrior; } }
        public static int GenExcluPrior { get { return Instance.genExcluPrior; } }

        //public static bool Transmit { get { return Instance.transmit; } }
        //public static bool TransmitTotal { get { return Instance.transmitTotal; } }
        //public static bool TransmitTotalGuest { get { return Instance.transmitTotalGuest; } }
        public static bool? Cascading { get { return Instance.cascading; } }
        public static Dictionary<int, DateTime> PlayedDates { get { return Instance.dates.Dates; } }
        public static DateTime DateLevel { get { return Instance.dates.Level; } }

        internal static Journal Journal { get { return Instance.journal; } }
        internal static RootIt RootIt { get { return Instance.rootIt; } }

        public static bool OnlyEnabled { get { return Instance.onlyEnabled; } }
        public static bool OnlyUnRead { get { return Instance.onlyUnRead; } }
        public static bool CheckExist { get { return Instance.checkExist; } }

        public static bool AutoBlock { get { return Instance.autoBlock; } }
        public static bool LogGen { get { return Instance.logGen; } }

        internal static Html Html { get { return Instance.html; } }

        public static bool AutoSequence { get { return Instance.autoSequence; } }
        public static bool BorderVirtual { get { return Instance.borderVirtual; } }
        public static bool BorderIdem { get { return Instance.borderIdem; } }
        public static bool BorderGranSlam { get { return Instance.borderGranSlam; } }
        public static bool BorderTb { get { return Instance.borderTb; } }
        public static bool AutoSelect { get { return Instance.autoSelect; } }
        public static Export Export { get { return Instance.export; } }
        internal static Hibernate Import { get { return Instance.import; } }
        public static Sort.Sort Sort { get { return Instance.sort; } }
        public static ConfAlbums Albums { get { return Instance.albums; } }
        internal static Hibernate Hibernate { get { return Instance.hibernate; } }
        internal static Db Db { get { return Instance.db; } }
        /// <summary>
        /// muy important. on calcule les dates max avec pub plutôt que Pub2
        /// </summary>
        //  public static bool CheckPub { get { return Instance.checkPub; } }
        public static bool UseMock { get { return Instance.useMock; } }
        public static bool LogDir { get { return Instance.logDir; } }
        public static double DeltaOPen { get { return Instance.deltaOpen; } }
        internal static Listes Listes { get { return Instance.listes; } }
        internal static Listes GlobalListes { get { return Instance.globalListes; } }
        internal static List<SelectParam> SelectParams { get { return Instance.selectParams; } }
        internal static List<Note> Notes { get { return Instance.notes; } }

        internal static Contexte Contexte { get { return Instance.contexte; } }
        internal static DateRef DateRef { get { return Instance.dateRef; } }

        /// <summary>
        /// Roue libre: on ne calcule pas les listes, on se contente de supprimer les déjà lus ou désactivés
        /// </summary>
        public static bool Freewheel { get { return Instance.freewheel; } }

        /// <summary>
        /// Semi-roue libre: on calcule les liste, mais on ne résurectionne pas de nouveaux tracks
        /// </summary>
        public static bool NoRevival { get { return Instance.noRevival; } }

        public static string Scan { get { return Instance.scan; } }
        //  public static string Zique { get { return Instance.zique; } }
        #endregion

        private DateTime lastModif = DateTime.MinValue;
        private FileInfo confFile;
        public FileInfo ConfFile { get { return confFile; } }
        public static List<string> Folders { get { return Instance.folders; } }
        #region load

        public XmlElement load(bool waitForModification)
        {

            while (true)
            {
                confFile.Refresh();
                if (!confFile.Exists)
                    throw new ApplicationException(confFile + " n'existe pas !!");
                DateTime dt = confFile.LastWriteTime;
                if (dt > lastModif || !waitForModification)
                    break;
                Thread.Sleep(1000);
            }

            lastModif = confFile.LastWriteTime;

            XmlDocument l_doc = new XmlDocument();
            l_doc.Load(confFile.FullName);

            XmlElement xroot = l_doc.DocumentElement;
            XMLTool l_xmlConf = new XMLTool(xroot);

            string str = l_xmlConf.getNodeValue("volumeMin");
            if (!string.IsNullOrEmpty(str))
                volumeMin = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("maxScan");
            if (!string.IsNullOrEmpty(str))
                maxScan = Convert.ToInt32(str);

            buildLimitMulti = l_xmlConf.getBoolValue("buildLimitMulti");
            simulation = l_xmlConf.getBoolValue("simulation");
            //   zique = l_xmlConf.getNodeValue("zique");

            deleteDoublon = l_xmlConf.getBoolValue("deleteDoublon");
            getDescription = l_xmlConf.getBoolValue("getDescription");
            copyAll = l_xmlConf.getNodeValue("copyAll");

            poubelle = l_xmlConf.getNodeValue("poubelle");

            str = l_xmlConf.getNodeValue("menage");
            if (!string.IsNullOrEmpty(str))
                menage = (menage)(Enum.Parse(typeof(menage), str, true));

            writePlayLists = l_xmlConf.getBoolValue("writePlayLists");
            writePreSel = l_xmlConf.getBoolValue("writePreSel");
            writeItems = l_xmlConf.getBoolValue("writeItems");
            writeUse = l_xmlConf.getBoolValue("writeUse");
            writeExclu = l_xmlConf.getBoolValue("writeExclu");
            genFeed = l_xmlConf.getBoolValue("genFeed");
            str = l_xmlConf.getNodeValue("genFeedPrior");
            if (!string.IsNullOrEmpty(str))
                genFeedPrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genUsePrior");
            if (!string.IsNullOrEmpty(str))
                genUsePrior = Convert.ToInt32(str);

            str = l_xmlConf.getNodeValue("genExcluPrior");
            if (!string.IsNullOrEmpty(str))
                genExcluPrior = Convert.ToInt32(str);

            //transmit = l_xmlConf.getBoolValue("transmit");
            //transmitTotal = l_xmlConf.getBoolValue("transmitTotal");
            //transmitTotalGuest = l_xmlConf.getBoolValue("transmitTotalGuest");
            onlyEnabled = l_xmlConf.getBoolValue("onlyEnabled", true);
            onlyUnRead = l_xmlConf.getBoolValue("onlyUnRead", true);
            checkExist = l_xmlConf.getBoolValue("checkExist", true);
            str = l_xmlConf.getNodeValue("cascading");
            if (!string.IsNullOrEmpty(str))
                cascading = "true".Equals(str);
            //  cascading = l_xmlConf.getBoolValue("cascading");

            //str = l_xmlConf.getNodeValue("date0");
            //if (!string.IsNullOrEmpty(str))
            //    date0 = Convert.ToDateTime(str);

            //str = l_xmlConf.getNodeValue("date00");
            //if (!string.IsNullOrEmpty(str))
            //    date00 = Convert.ToDateTime(str);

            var xDateRef = l_xmlConf.NodeLookUp("dateRef");
            dateRef = new DateRef(xDateRef);

            var xDates = l_xmlConf.NodeLookUp("playedDates");
            dates = new ConfDate(xDates);

            logGen = l_xmlConf.getBoolValue("logGen");
            var createNullLoggerOrg = Logger.CreateNullLoggers;

            Logger.CreateNullLoggers = !logGen;
            xDir = l_xmlConf.NodeLookUp("dir");

            var rootLimit = new Limits();
            buildLimit(xDir, rootLimit, null);

            AutoBuilder.clear();
            root = DirConf.getDir(rootLimit, xDir.Attributes["name"].InnerText, null); //new DirConf(rootLimit, xDir.Attributes["name"].InnerText, null);
            root.build(null, xDir);
            buildDirChilds(xDir, root);
            root.Init();

            // AutoBuilder.getLoaders(); 

            XmlElement xMove = l_xmlConf.NodeLookUp("move");
            move = new Move(xMove);

            ordo = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

            selectParams.Clear();

            var xSelect = l_xmlConf.NodeLookUp("select");
            if (xSelect != null)
            {
                foreach (XmlNode xsub in xSelect)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        selectParams.Add(new SelectParam(xSelect, x));
                }
            }

            notes.Clear();
            var xNotes = l_xmlConf.NodeLookUp("notes");
            if (xNotes != null)
            {
                foreach (XmlNode xsub in xNotes)
                {
                    var x = xsub as XmlElement;
                    if (x != null)
                        notes.Add(new Note(x));
                }
            }

            journal = null;
            var xJournal = XMLTool.NodeLookUp(xroot, "journal");
            if (xJournal != null)
            {
                journal = new Tuning.Journal();
                buildLimitItem(xJournal, xJournal, journal);
                var xxJournal = new XMLTool(xJournal);
                journal.NbJour = xxJournal.getIntAttValue("nbJour");
            }

            rootIt = new Tuning.RootIt(l_xmlConf.NodeLookUp("rootIt")); //  l_xmlConf.getNodeValue("rootIt");

            autoBlock = l_xmlConf.getBoolValue("autoBlock", true);
            //XmlElement xAuto = l_xmlConf.NodeLookUp("auto");
            //if (xAuto == null)
            //    auto = null;
            //else
            //    auto = new Auto(xAuto);

            XmlElement xHtml = l_xmlConf.NodeLookUp("html");
            html = new Html(xHtml);

            autoSequence = l_xmlConf.getBoolValue("autoSequence", true);
            borderVirtual = l_xmlConf.getBoolValue("borderVirtual", false);
            borderIdem = l_xmlConf.getBoolValue("borderIdem", false);
            borderGranSlam = l_xmlConf.getBoolValue("borderGranSlam", false);
            borderTb = l_xmlConf.getBoolValue("borderTb", false);
            autoSelect = l_xmlConf.getBoolValue("autoSelect", false);
            checkPub = l_xmlConf.getBoolValue("checkPub", false);
            useMock = l_xmlConf.getBoolValue("useMock ", false);
            logDir = l_xmlConf.getBoolValue("logDir ", false);

            freewheel = l_xmlConf.getBoolValue("freewheel", false);
            noRevival = l_xmlConf.getBoolValue("noRevival", false);


            scan = l_xmlConf.getNodeValue("scan");

            var xExport = l_xmlConf.NodeLookUp("export"); // export = l_xmlConf.getNodeValue("export");
            export = new Tuning.Export(xExport);

            var xImport = l_xmlConf.NodeLookUp("import"); // export = l_xmlConf.getNodeValue("export");
            import = new Tuning.Hibernate(xImport);

            var xSort = l_xmlConf.NodeLookUp("sort");
            sort = new Tuning.Sort.Sort(xSort);


            var xAlbums = l_xmlConf.NodeLookUp("albums");
            albums = new ConfAlbums(xAlbums);

            var xHibernate = l_xmlConf.NodeLookUp("hibernate");
            hibernate = new Hibernate(xHibernate);


            var xDb = l_xmlConf.NodeLookUp("db");
            db = new Db(xDb);


            Logger.CreateNullLoggers = createNullLoggerOrg;
            var xlistes = l_xmlConf.NodeLookUp("listes");
            listes = new Listes(xlistes);

            var xglobal = l_xmlConf.NodeLookUp("global");
            globalListes = new Listes(xglobal);


            var xContext = l_xmlConf.NodeLookUp("context");
            contexte = new Contexte(xContext);

            folders = new List<string>();
            var xFolders = l_xmlConf.NodeLookUp("folders");
            if (xFolders != null)
            {
                foreach (var xsub in xFolders.ChildNodes)
                {
                    if (xsub is XmlElement)
                    {
                        var xxsub = xsub as XmlElement;
                        if (xxsub.Name == "f")
                        {
                            var f = XMLTool.getAttValue(xxsub, "f");
                            if (!string.IsNullOrEmpty(f))
                            {
                                if (!f.EndsWith("\\"))
                                    f = f + "\\";
                                folders.Add(f);
                            }
                        }
                    }
                }
            }

            started = true;
            return xroot;

        }

        #region limites

        private void buildDirChilds(XmlNode node, DirConf parent)
        {
            AutoBuilder.setClient(parent, node);
            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "auto")
                {
                    AutoBuilder.build(child, parent);
                }
                else
                {
                    if (child.Name == "dir")
                    {
                        string name = (child.Attributes["name"].InnerText);
                        Limits childLimite = parent.Limites.Clone() as Limits;
                        DirConf sub = DirConf.getDir(childLimite, name, parent); // new DirConf(childLimite, name, parent);
                        sub.buildR(xDir, child);

                        //if (child.Attributes["d"] != null)
                        //    sub.Duration = Convert.ToSingle(child.Attributes["d"].Value);



                        if (child.Attributes["uniqueAlbum"] != null)
                        {
                            sub.UniqueAlbum = child.Attributes["uniqueAlbum"].Value == "true";
                        }
                        if (child.Attributes["order"] != null)
                        {
                            sub.OrderNote = child.Attributes["order"].Value == "note";
                        }
                        if (child.Attributes["histo"] != null)
                        {
                            sub.Histo = child.Attributes["histo"].Value == "true";
                        }
                        if (child.Attributes["resetBefore"] != null)
                        {
                            sub.ResetBefore = child.Attributes["resetBefore"].Value == "true";
                        }
                        if (child.Attributes["resetAfter"] != null)
                        {
                            sub.ResetAfter = child.Attributes["resetAfter"].Value == "true";
                        }
                        //if (child.Attributes["serial"] != null)
                        //{
                        //    sub.Serial = child.Attributes["serial"].Value == "true";
                        //}

                        //if (child.Attributes["cascading"] != null)
                        //    sub.Cascading = child.Attributes["cascading"].Value == "true";
                        if (child.Attributes["selectionPre"] != null)
                            sub.SelectionPre = child.Attributes["selectionPre"].Value == "true";

                        sub.selectParams.Clear();
                        foreach (XmlNode xsub in child.ChildNodes)
                        {
                            if (xsub is XmlElement)
                            {
                                if (xsub.Name == "select")
                                {
                                    foreach (XmlNode xp in xsub.ChildNodes)
                                    {
                                        if (xsub is XmlElement)
                                        {
                                            var _param = new SelectParamBase(xsub as XmlElement, xp as XmlElement);
                                            sub.selectParams.Add(_param);
                                        }
                                    }
                                }
                            }
                        }

                        //if (child.Attributes["transmit"] != null)
                        //    sub.TransmitToParent = child.Attributes["transmit"].Value == "true";
                        //if (child.Attributes["transmitTotal"] != null)
                        //    sub.TransmitTotal = child.Attributes["transmitTotal"].Value == "true";
                        //if (child.Attributes["transmitTotalGuest"] != null)
                        //    sub.TransmitTotalGuest = child.Attributes["transmitTotalGuest"].Value == "true";
                        buildLimit(child, childLimite, sub);
                        parent.addChild(sub);
                        if (!started)
                            misc.log(sub.display());
                        buildDirChilds(child, sub);
                        sub.Init();

                    }
                }
            }

        }

        private void buildLimitItem(XmlNode parent, XmlNode child, LimitItem item)
        {
            string strTd = child.InnerText;
            if (!string.IsNullOrEmpty(strTd) && child.Name == "td")
                item.Td = Convert.ToDouble(strTd);

            AutoBuilder.setClient(item, child);

            //foreach (XmlNode sub in child.ChildNodes)
            //{
            //    if (sub.Name == "auto")
            //        AutoBuilder.build(sub, item);
            //}

            item.build(parent, child);

            //var dAtt0 = parent.Attributes["d"];
            //if (dAtt0 != null)
            //    item.Duration = Convert.ToSingle(dAtt0.InnerText);

            //var dAtt = child.Attributes["d"];
            //if (dAtt != null)
            //    item.Duration = Convert.ToSingle(dAtt.InnerText);

            //var cAtt0 = parent.Attributes["c"];
            //if (cAtt0 != null)
            //    item.Contribution = Convert.ToSingle(cAtt0.InnerText);

            //var cAtt = child.Attributes["c"];
            //if (cAtt != null)
            //    item.Contribution = Convert.ToSingle(cAtt.InnerText);

            //var fdAtt0 = parent.Attributes["fd"];
            //if (fdAtt0 != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt0.InnerText);

            //var fdAtt = child.Attributes["fd"];
            //if (fdAtt != null)
            //    item.FeedDuration = Convert.ToSingle(fdAtt.InnerText);

            //var nbAtt0 = parent.Attributes["nb"];
            //if (nbAtt0 != null)
            //    item.Nb = Convert.ToInt32(nbAtt0.InnerText);
            //var nbAtt = child.Attributes["nb"];
            //if (nbAtt != null)
            //    item.Nb = Convert.ToInt32(nbAtt.InnerText);

            //var dateAtt0 = parent.Attributes["date"];
            //if (dateAtt0 != null)
            //    item.DateMin = getDate(dateAtt0.InnerText);
            //var dateAtt = child.Attributes["date"];
            //if (dateAtt != null)
            //    item.DateMin = getDate(dateAtt.InnerText);

            //var dateAtt0Max = parent.Attributes["maxdate"];
            //if (dateAtt0Max != null)
            //    item.DateMax = getDate(dateAtt0Max.InnerText);
            //var dateAttMax = child.Attributes["maxdate"];
            //if (dateAttMax != null)
            //    item.DateMax = getDate(dateAttMax.InnerText);
        }

        //private static bool date00Consumed;
        //public static void date00Consume() { date00Consumed = true; }

        public static DateTime Date0
        {
            get
            {
                return Instance.dateRef.date0;
            }
        }

        public static DateTime DateContexte
        {
            get
            {
                return Instance.dateRef.contexte;
            }
        }


        public static DateTime getDate(string str)
        {
            if (string.IsNullOrWhiteSpace(str))
                return DateTime.MaxValue;
            double d = -1;
            var date0 = Date0;
            var dateContexte = DateContexte;
            var dateC0 = dateContexte;
            if (date0 < dateContexte)
                dateC0 = date0;

            if (str.EndsWith("c0"))
            {

                var _str = str.Remove(str.Length - 2);
                if (double.TryParse(_str, out d))
                {
                    return dateC0.AddDays(d);
                }
            }
            else if (str.EndsWith("c"))
            {

                var _str = str.Remove(str.Length - 1);
                if (double.TryParse(_str, out d))
                {
                    return dateContexte.AddDays(d);
                }
            }

            else if (double.TryParse(str, out d))
            {
                if (d >= 0)
                {
                    return date0.AddDays(d);
                }
                else
                    return DateTime.Now.Date.AddDays(d);
            }

            return Convert.ToDateTime(str);
        }

        private void buildLimit(XmlNode node, Limits limits, DirConf dir)
        {

            Limit[] tab = new Limit[Limits.NB];

            foreach (XmlNode child in node.ChildNodes)
            {
                if (child.Name == "list")
                {

                    int level = Convert.ToInt32(child.Attributes["l"].InnerText);
                    Limit limit = new Limit(level);
                    var items = new List<LimitItem>();

                    double tdMin = 0;
                    foreach (XmlNode xItem in child.ChildNodes)
                    {
                        //if (xItem.Name == "auto")
                        //{
                        //    AutoBuilder.build(xItem, limit);
                        //}
                        //else 
                        if (xItem.Name == "td")
                        {
                            var item = new LimitItem(limit);
                            item.TdMin = tdMin;
                            buildLimitItem(child, xItem, item);


                            var itemTd = item.Td;
                            if (itemTd < int.MaxValue)
                                tdMin = item.Td;
                            items.Add(item);
                        }
                    }

                    if (items.Count == 0)
                    {
                        var defaultItem = new LimitItem(limit);
                        buildLimitItem(child, child, defaultItem);
                        items.Add(defaultItem);
                    }

                    limit.Items = items;

                    //var dAtt = child.Attributes["d"];
                    //if (dAtt != null)
                    //    limit.Duration = Convert.ToInt32(dAtt.InnerText);

                    //var fdAtt = child.Attributes["fd"];
                    //if (fdAtt != null)
                    //    limit.FeedDuration = Convert.ToInt32(fdAtt.InnerText);

                    //var nbAtt = child.Attributes["nb"];
                    //if (nbAtt != null)
                    //    limit.Nb = Convert.ToInt32(nbAtt.InnerText);
                    tab[level] = limit;
                }

            }

            Limit current = null;
            bool oneTabAtLeast = false;
            //  LimitItem currentItem = null;

            double currentDuration = int.MaxValue;
            double lcurrentDuration = int.MaxValue;
            double currentContrib = int.MaxValue;
            double currentFeedDuration = int.MaxValue;
            // double lcurrentFeedDuration = int.MaxValue;
            int currentNb = int.MaxValue;
            int currentNbp = int.MaxValue;
            int lcurrentNb = int.MaxValue;

            int currentNbMax = int.MaxValue;
            int currentNbpMax = int.MaxValue;
            double currentTd = int.MaxValue;

            double currentTdMin = int.MaxValue;
            DateTime currentDateMin = DateTime.MinValue;
            DateTime currentDateMax = DateTime.MaxValue;
            // bool currentOverwrite = false;

            for (int i = 0; i < Limits.NB; i++)
            {

                //if (tab[i] != null)
                //{

                if (tab[i] != null)
                {
                    current = tab[i];
                    oneTabAtLeast = true;

                }

                if (!oneTabAtLeast)
                    current = limits[i];

                var _limit = limits[i];
                _limit.Level = i;
                limits[i].Parent = limits;

                //foreach (LimitItem currentItem in current.Items)
                //{

                if (_limit.Items.Count != current.Items.Count)
                {
                    _limit.Items.Clear();
                }

                for (int j = 0; current != null && j < current.Items.Count; j++)
                {

                    var currentItem = current.Items[j];
                    // if (currentItem.Duration < int.MaxValue)
                    currentDuration = currentItem.Duration;
                    // currentOverwrite = currentItem.OverwriteConf;
                    lcurrentDuration = currentItem.LoadDuration;
                    //if (currentItem.Contribution < int.MaxValue)
                    currentContrib = currentItem.Contribution;
                    // if (currentItem.FeedDuration < int.MaxValue)
                    currentFeedDuration = currentItem.FeedDuration;
                    //  lcurrentFeedDuration = currentItem.LoadFeedDuration;

                    //   if (currentItem.Nb < int.MaxValue)
                    currentNb = currentItem.Nb;
                    currentNbp = currentItem.Nbp;
                    lcurrentNb = currentItem.LoadNb;

                    currentNbMax = currentItem.NbMax;
                    currentNbpMax = currentItem.NbpMax;
                    //  if (currentItem.Td < int.MaxValue)
                    currentTd = currentItem.Td;
                    currentTdMin = currentItem.TdMin;

                    currentDateMin = currentItem.DateMin;
                    currentDateMax = currentItem.DateMax;
                    //}
                    //}

                    //if (current != null)
                    //{
                    LimitItem _limitItem = null;
                    if (j >= _limit.Items.Count)
                    {
                        _limitItem = currentItem.Clone() as LimitItem;
                        _limit.Items.Add(_limitItem);
                        _limitItem.Limit = _limit;

                    }
                    else
                    {
                        _limitItem = _limit.Items[j];

                    }
                    //if (currentDuration < int.MaxValue)
                    _limitItem.setDuration(currentDuration, false); // Duration = currentDuration;
                    _limitItem.LoadDuration = lcurrentDuration;
                    //if (currentContrib < int.MaxValue)
                    //    _limitItem.Contribution = currentContrib;
                    // if (currentFeedDuration < int.MaxValue)
                    _limitItem.setFeedDuration(currentFeedDuration, false); // FeedDuration = currentFeedDuration;
                    // _limitItem.LoadFeedDuration = lcurrentFeedDuration;
                    // if (currentNb < int.MaxValue)
                    _limitItem.setNb(currentNb, false);
                    _limitItem.setNbp(currentNbp, false);
                    _limitItem.LoadNb = lcurrentNb;

                    _limitItem.NbMax = currentNbMax;
                    _limitItem.setNbpMax(currentNbpMax, false);
                    //   if (currentTd < int.MaxValue)
                    _limitItem.Td = currentTd;
                    _limitItem.TdMin = currentTdMin;
                    _limitItem.DateMin = currentDateMin;
                    _limitItem.setDateMax(currentDateMax, false);
                    _limitItem.Contribution = currentContrib;
                    //   _limitItem.OverwriteConf = currentOverwrite;



                    if (dir != null)
                    {
                        if (_limitItem.Duration == int.MaxValue)
                            _limitItem.setDuration(dir.Duration, true); // Duration = dir.Duration;
                        if (_limitItem.LoadDuration == int.MaxValue)
                            _limitItem.LoadDuration = dir.LoadDuration;
                        if (_limitItem.Contribution == int.MaxValue)
                            _limitItem.Contribution = dir.Contribution;
                        if (_limitItem.Td == int.MaxValue)
                            _limitItem.Td = dir.Td;
                        if (_limitItem.Nb == int.MaxValue)
                            _limitItem.setNb(dir.Nb, true);
                        if (_limitItem.Nbp == int.MaxValue)
                            _limitItem.setNbp(dir.Nbp, true);
                        if (_limitItem.NbMax == int.MaxValue)
                            _limitItem.NbMax = dir.NbMax;
                        if (_limitItem.NbpMax == int.MaxValue)
                            _limitItem.setNbpMax(dir.NbpMax, true);
                        if (_limitItem.LoadNb == int.MaxValue)
                            _limitItem.LoadNb = dir.LoadNb;
                        if (_limitItem.FeedDuration == int.MaxValue)
                            _limitItem.setFeedDuration(dir.FeedDuration, true);
                        //if (_limitItem.LoadFeedDuration == int.MaxValue)
                        //    _limitItem.LoadFeedDuration = dir.LoadFeedDuration;
                        if (_limitItem.DateMin == DateTime.MinValue)
                            _limitItem.DateMin = dir.DateMin;
                        if (_limitItem.DateMax == DateTime.MaxValue)
                            _limitItem.setDateMax(dir.DateMax, true);
                    }

                    _limitItem.setParent(dir);

                }

                //}
                // }

            }

        }
        #endregion
        #endregion

    }
}
]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.IO;

namespace pdb.gen.albums
{
    public enum virtualMode
    {
        none = 0,
        artist = 1,
        path = 2,
        year = 3,
        extended = 4,
        extendedWord = 5,
        added = 6,
        list = 7,
        word = 8
    }

    public enum sortDone : byte
    {
        none,
        phaseUn,
        phaseDeux
    }

    public class Album : IEnumerable<Piece>
    {
        [Flags]
        private enum typeMove : byte
        {
            move = 1,
            empeached = 2,
            empeached1 = 4
        }
        const int NB_DEC = 3;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        const int A_REFAIRE_CAUSE_COMPACT = -10;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        //  private decimal classementValueLightSt = -1;
#if GEN2
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;
#endif
        private sortDone sortStatus;

        private int nbRecent;
        private int nbDone;
        public int Recents { get { return nbRecent; } }
        public int NbDone { get { return nbDone; } }
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (this.name == @"\")
                return ret;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && InStackSize)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)StackIndex / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }

            return ret;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                return getSt(classementValueLight);
                //if (classementValueLightSt >= 0)
                //    return classementValueLightSt;
                //classementValueLightSt = getSt(classementValueLight);

                //if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                //{
                //    //      1       10      50      99
                //    //      0.99    0.9     0.5     0.01
                //    //1.    0.01    0.1     0.5     0.99
                //    //2.    0.02    0.19    0.75    0.9999
                //    //10    0.095   0.65    0.999   0.99999999999
                //    //0.5   0.005   0.05    0.29    0.9
                //    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                //    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                //    if (delta != 1)
                //        delta = pdb.util.Math.Pow(delta, stackPower);
                //    delta = 1 - delta;

                //    if (delta < 0.001m)
                //        delta = 0.001m;

                //    classementValueLightSt = classementValueLight / delta;
                //}
                //else
                //    classementValueLightSt = classementValueLight;

                //  return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
#if GEN2
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
#else
                return ClassementValueLightSt;
#endif
            }
        }
        //  private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero
        {
            get
            {
#if GEN2
                return classementValueLightZero;
#else
                return ClassementValueLight;
#endif
            }
        }
        public decimal Rendement
        {
            get
            {
#if GEN2
                if (classementValueLight == 0) return 1; return classementValueLightZero / classementValueLight;
#else
                return 1;
#endif
            }
        }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private virtualMode mode;
        public virtualMode VirtualMode { get { return mode; } }
        //  private bool _virtual;
        public bool Virtual { get { return mode > virtualMode.none; } }
        public void setVirtual(virtualMode mode) { this.mode = mode; }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return this.mode == virtualMode.artist; } }
        private Piece pluspetitEnabled;
        public Piece PlusPetitEnabled { get { return pluspetitEnabled; } }
        // private int stackValue;
        private DateTime majDate;
        public DateTime MajDate { get { return majDate; } }

        //public int StackValue
        //{
        //    get
        //    {

        //        return stackValue;
        //    }
        //    set
        //    {
        //        if (value > 0 && this.Name == "\\")
        //        {
        //        }
        //        else
        //            stackValue = value;
        //    }
        //}

        public bool InStackSize { get { return StackIndex < stackSize && name != "\\"; } }
        public bool InStackPeremption { get { return StackIndex < stackPeremption && name != "\\"; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, mode);
                return key;
            }
        }

        public Album(string name, virtualMode mode)
        {
            this.name = name;
            this.mode = mode;
            quality = CRank.MAX;
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            quality = CRank.MAX;
        }
        private int quality;
        public int Quality
        {
            get { return quality; }
            set { quality = value; }
        }

        public int RankAlbumReverse
        {
            get
            {
                return Albums.RankZero - quality; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
            }
        }

        private decimal timeRest = decimal.MaxValue;
        public decimal TimeRest { get { return timeRest; } set { timeRest = System.Math.Round(value, NB_DEC); } }
        public string Name { get { return name; } }

        public override string ToString()
        {
            return string.Format("{0} {1} {2} elts", name, mode, Count);
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0
        {
            get
            {
#if GEN2
                return Piece.getClassementEquiv(classementValueLightZero);
#else
                return EquivLight;
#endif
            }
        }

        //// private string moyenne = "";
        //public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        private static Dict<string, typeMove> dictMove = new Dict<string, typeMove>();

        private static bool HasMoveValue(string key, typeMove type)
        {
            return dictMove[key].HasFlag(type);
        }
        private static void SetMoveValue(string key, bool value, typeMove type)
        {
            var v = dictMove[key];
            if (value)
            {
                v |= type;
            }
            else
            {
                v &= ~type;
            }
            if (v == 0)
                dictMove.Remove(key);
            else
                dictMove[key] = v;
        }

        public bool Moved
        {
            get
            {
                return HasMoveValue(Key, typeMove.move);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.move);
            }
        }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return HasMoveValue(Key, typeMove.empeached);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.empeached);
            }
        }

        public void empeachedDecrement()
        { //nbEmpeached--; 
        }

        // public int EmpeachedNb { get { return nbEmpeached; } }

        //private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1
        {
            get
            {
                return HasMoveValue(Key, typeMove.empeached1);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.empeached1);
            }
        }
        private static int stackSize = 20;
        public static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return StackIndex == stackSize; } }
        public bool AlmostFree1 { get { return StackIndex == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (build)
                throw new ApplicationException("déjà buildé");
            piece.PieceAlbum = this;


            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                quality = CRank.MAX;
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public void ClearAndMenage()
        {
            if (mode == virtualMode.word && name == "029")
            {
            }
            if (mode != virtualMode.none)
            {
                foreach (Piece p in list)
                    p.setParent(null);
            }
            Clear();
        }

        public void ConsolidChilds()
        {
            foreach (Piece p in list)
                p.consolidChild();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && !p.ClassmentPositive())
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                var exists = FileRegister.Exist(next.Location);
                return false == exists;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return false; } }// selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<IPieceAlbum> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {
                #region calcul virtuel



                DecimalPiece med = null;
#if GEN2
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;
#endif



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                // bool combineNow = mode.combine && mode.simple;
#if GEN2
                if (real)
                    _albumMedianne.buildVirtual(mode.combine, mode.simple);
                else
                {
#else
                if (mode.Main.coeffVirt > 1)
                    _albumMedianne.buildVirtual(true, mode.simple);
                else
                    list.Sort(new PieceClassementComparer(false));
#endif
#if GEN2
            }
#endif
#if GEN2

                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    med1 = med; med2 = med;

                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, pieceExtendedMode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }

                    if (mode.combine && !mode.simple)
                    {
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    }


                }

                
                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }
#else
                med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);
                var median = med.index;

                if (median != null)
                {
                    resultGlobalMin = median.getSimpleCause();
                }
#endif















                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, pieceExtendedMode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var cnext = cause.Next;
                if (cnext != null)
                {
                    if (cnext.UseCompact && !cnext.Empty)
                    {
                        if (cnext.Piece.ClassementRecentCompact)
                        {
                            cnext.UseCompact = false;
                            return A_REFAIRE_CAUSE_COMPACT;
                        }
                    }
                }
                classementValueLight = med.d;
                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    //if (mode.combine && !mode.simple)
                    //{
                    //    _albumMedianne.buildVirtual(true);
                    //    med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                    //    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    //}
                    //else
                    //{
                    //    if (true == cause.selectedMotifMin)
                    //        med = med2;
                    //    else
                    //        med = med1;
                    //}




                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

#if GEN2
                    foreach (var p in list)
                        p.finalyse();

#endif


                    if (cause.motifUp)
                    {
                        if (cause.selectedMotifMin.HasValue)
                        {
                            if (true == cause.selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else if (selectedMotifMin.HasValue)
                        {
                            if (true == selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else
                        {
                            if (true == resultGlobalMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }


                    }

                    try
                    {
                        if (med.index != null)
                            pluspetitEnabled = med.index.Piece;
                        if (med.index != null) med.index.Piece.MedianneLight = true;
                        if (med.indexBorder != null) med.indexBorder.Piece.Border = true;
                        if (med.indexBorderEffect != null) med.indexBorderEffect.Piece.BorderEffect = true;
                        if (med.indexBorderMin != null) med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public IPieceAlbum Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<IPieceAlbum> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;
            bool forceKeep = mode.forceKeep;
            bool forceKeep2 = mode.forceKeep2;
            bool dontDownByKeep = mode.dontDownByKeep;


            // PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            IPieceAlbum nextZero1 = null;
#if GEN2
            IPieceAlbum nextZero2 = null;
             IPieceAlbum min2 = null;
                Classement _min2 = null;
              Classement _minzero2 = null;
#endif

            IPieceAlbum min1 = null;

            IPieceAlbum min = null;
            Classement _min1 = null;

            Classement _minzero1 = null;

            bool realZero = false;
            IPieceAlbum Next = null;

            IPieceAlbum firstKeep = null;
            IPieceAlbum firstKeep2 = null;
            foreach (IPieceAlbum p in list)
            {
                if (p.Piece.Keep)
                {
                    if (forceKeep && p.Piece.KeepCoeff > 0)
                    {
                        if (firstKeep == null)
                            firstKeep = p;
                    }
                    if (p.Piece.KeepCoeff < 0)
                    {
                        if (firstKeep2 == null)
                            firstKeep2 = p;
                    }

                    //min= firstInAlbumEmpty; 
                    //break;
                }
                var piece = p.Piece;
                Classement v1 = piece.LastClassementRecent ? piece.getClassement(true) : p.Classement;
                //  var v1 = p.Classement;
#if GEN2
                var v2 = p.Classement2;
#endif

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            if (!p.Piece.Keep || !dontDownByKeep)
                            {
                                _minzero1 = v1;
                                nextZero1 = p;
                                if (v1.isZero())
                                    realZero = true;
                            }
                        }
                    }
#if GEN2

                    if (v2.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2.isZero())
                                realZero = true;
                        }

                    }

#endif

                    if (v1.isPositive() && v1 < _min1)
                    {
                        if (!p.Piece.Keep || !dontDownByKeep)
                        {
                            _min1 = v1;
                            min1 = p;
                        }
                    }
#if GEN2
                    if (v2.isPositive() && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }
#endif

                    if (p.Empty)
                        break;
                }
            }
            Classement _min = null;
#if GEN2
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;

            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }
#else
            min = min1;
            _min = _min1;
#endif

            IPieceAlbum nextZero = null;
            Classement _minzero = null;
#if GEN2
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }
#else
            nextZero = nextZero1; _minzero = _minzero1;
#endif

            //if (firstInAlbumEmpty != null)
            //{
            //    Next = firstInAlbumEmpty;
            //    cause.selectedMotifMin = cause.resultByFirstMin;
            //    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
            //}
            //else
            //{

            if (nextZero != null)
            {
                decimal _minValue = _min == null ? int.MaxValue : _min.RapportClassement;
                decimal _minZeroValue = _minzero == null ? int.MaxValue : _minzero.RapportClassement;
                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane

                    if (_minValue < classementValueLight && min != null)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.ClassementValueLightZero > classementValueLight + EPSILON || (classementValueLight > 0 && this.ClassementValueLightZero / classementValueLight > 1 + EPSILON)) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_minValue < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minZeroValue < classementValueLight)
                    {
                        classementValueLight = _minZeroValue;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {

                        classementValueLight = _min == null ? int.MaxValue : _min.RapportClassement;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min.RapportClassement;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }
            //}

            if (Next == nextZero)
            {
                bool refact = false;

                if (firstKeep2 != null && firstKeep2 == min && Next != firstKeep2 && !firstKeep2.LastClassementRecent)
                {
                    if (forceKeep2)
                    {
                        Next = firstKeep2; refact = true;
                    }
                    else if (firstKeep2.Piece.DeepClassement.isZero())
                    {
                        Next = firstKeep2; refact = true;
                    }
                }
                else if (firstKeep != null && firstKeep == min && Next != firstKeep && !firstKeep.LastClassementRecent)
                {
                    {
                        Next = firstKeep; refact = true;
                    }
                }

                if (refact)
                {
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                }
            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            if (real && min != null)
                this.pluspetitEnabled = min.Piece;
            return cause;



        }


        private bool makesort(List<Piece> list, List<IPieceAlbum> listE, ConfMedianne mode, ConfMedianne mode0, int nbrepeat)
        {
            int count = list.Count;

            if (sortStatus == sortDone.none)   //(!sort0Done)
            {
                // list.Sort(new CPieceComparerByQualityAndLength());
                var listSortedValues = new List<decimal>();
                //classed = false;
                //for (int i = 0; i < count; i++)
                //{
                //    listSortedValues.Add(list[i].Rank.SortValue);
                //    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                //        classed = true;
                //}
                ////misc.log("make sort Duration {0}", name); 
                //m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                //  listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                {
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                }
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                //   decimal moy = 0m;
                decimal offset = Album.conf.AlbumMoyOffset;
#if GEN2
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement(true);

                    p.setClassementVirtuel(rapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;
#endif

                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }
                if (sortStatus < sortDone.phaseUn)
                    sortStatus = sortDone.phaseUn;
                //   sort0Done = true;

            }


            if (sortStatus >= sortDone.phaseDeux)
                return false;

            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            // classementValueLightSt = -1;
            selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;

#if GEN2
            classementValueLightZeroSt = -1;
           
            classementValueLightZero = makeSort(listE, mode0, false);
            if (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }
#endif
            classementValueLight = makeSort(listE, mode, true);
            if (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }

            //   classementValueLightZero = A_REFAIRE_CAUSE_COMPACT;


            //   while (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLightZero = makeSort(listE, mode0, false);
            //   }

            ////   var _classementValueLight = makeSort(listE, mode, true);

            //   while (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLight = makeSort(listE, mode, true);
            //   }
#if GEN2
            var coeff1 = mode.Main.coeffVirt;
            var coeff2 = mode.Min.CoeffOld;
            var rendementmax = 1m;

            if (mode.combine)
                rendementmax = coeff1 * coeff2;
            else
                rendementmax = pdb.util.Math.Max(coeff1, coeff2);
            if (Rendement > 6 * rendementmax + 1e-6m)
            {
                nbrepeat++;
                sortStatus = sortDone.none;
                if (nbrepeat >= 3)
                {
                    // classementValueLight = classementValueLightZero;
                    return true;
                }
                return makesort(list, listE, mode, mode0, nbrepeat);

            }
#endif
            return true;
        }



        public bool makeSort(ConfMedianne mode, ConfMedianne mode0, ILogger logger, double dureeMinToLog) //IList<double> reference, IList<Piece> pieces)
        {

            if (sortStatus >= sortDone.phaseDeux)
                return false;
            DateTime nowa = DateTime.Now;
            var ts = (nowa - majDate);
            try
            {

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return false;

                var listE = new List<IPieceAlbum>(count);

                //if (CConf.ResetOneCl)
                //{

                //    // CPieceClassement.DateMin = DateTime.MinValue;
                //    decimal zer0d = 0;
                //    Piece oldKeep = null;


                //    foreach (Piece t in list)
                //    {
                //        if (t.Keep)
                //        {
                //            t.Keep = false;
                //            oldKeep = t;
                //            break;
                //        }
                //    }


                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in list)
                //    {
                //        var cl = t.DeepClassement; // p.Classement.DbValue;
                //        decimal clValue = Piece.classementHash.getCache(cl).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {

                //            if (t.LastClassementRecent || !t.Enabled)
                //            {
                //                min = null;
                //                break;
                //            }
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        min.Keep = true;
                //        var r = min.RapportClassement(true);
                //        if (r <= 0)
                //        {
                //        }
                //    }



                //    if (oldKeep != null && !oldKeep.Keep)
                //    {
                //        oldKeep.resetMedianneCompact();
                //        oldKeep.invalidateCache(true);
                //    }
                //}


                atLeastOneEnabled = false;
                int _nbr = 0;
                int _nbdone = 0;


                for (int i = 0; i < count; i++)
                {
                    var p = list[i];


                    if (sortStatus < sortDone.phaseDeux) //  (!sortDone)
                        p.resetMedianneCompact();
                    if (p.Enabled)
                    {
                        atLeastOneEnabled = true;

                    }
                    if (!p.Enabled && p.ClassmentPositive())
                        _nbdone++;
                    if (p.LastClassementRecent)
                        _nbr++;
#if GEN2
                    var pp = new PieceExtended(p);
#else
                    var pp = p;
#endif

                    if (mode.Main.coeffVirt > 1)
                        listE.Add(new PieceExtendedSimple(pp));
                    else
                        listE.Add(pp);
                }

                nbRecent = _nbr;
                nbDone = _nbdone;


                bool ret = makesort(list, listE, mode, mode0, 0);

                sortStatus = sortDone.phaseDeux;

                majDate = DateTime.Now;
                var duree = (majDate - nowa);
                if (duree.TotalMilliseconds > dureeMinToLog)
                    logger.log(string.Format("make Sort {0}| {1} {2}", ts.toString(), duree.toString(), this));

                return ret;
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return false;
        }



        public void mustRefresh()
        {
            build = false;
            sortStatus = sortDone.none;

            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
            albumAdded = DateTime.MaxValue;
        }

        public void refreshLight()
        {
            if (sortStatus == sortDone.phaseDeux)
                sortStatus = sortDone.phaseUn;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
        }



        //public decimal getTrackSortValue(int index, List<Piece> list)
        //{
        //    if (index < 0 || index >= list.Count)
        //        return 0;
        //    return list[index].RapportClassement(true);
        //}

        //decimal firstTrackSortValue = -1;
        //public decimal getFirstTrackSortValue()
        //{
        //    if (firstTrackSortValue == -1)
        //    {
        //        int count = list.Count;
        //        if (count == 0)
        //            return -1;
        //        var _list = new List<Piece>(list);
        //        _list.Sort(new PieceSortComparer());
        //        firstTrackSortValue = _list[count - 1].Rank.SortValue;
        //    }
        //    return firstTrackSortValue;
        //}
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            timeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> RawList
        {
            get
            {
                return new List<Piece>(list);
            }
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        //private CRank m_rank = new CRank();

        //public CRank Rank { get { return m_rank; } }



        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            quality = CRank.MAX;
            // rankStack = -1;
        }

        //public int QRank
        //{
        //    get { return m_rank.Quality; }
        //    set { m_rank.Quality = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}


        #endregion

        #region tri



        #endregion

        [Flags]
        private enum unsortMode : byte
        {
            album = 1,
            artist = 2

        }
        const char SEP = '\\';
        const int MAX_PATH_LEVEL = 10;

        public void addPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            paths.Add(p);
                        }
                        ilevel++;
                    }
                    // paths.Add(path);
                }
            }
        }

        public bool containsPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    if (paths.Contains(path))
                        return true; //paths.Add(path);
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            if (paths.Contains(p))
                                return true;
                        }
                        ilevel++;
                    }

                }
            }
            return false;
        }
        public void sortVirtual()
        {
            if (this.VirtualMode == virtualMode.none)
                return;
            var list = this.list.ToList<Piece>();
            int count = list.Count;
            if (count == 0)
                return;
            list.Sort((x, y) =>
            {
                var cmp = x.MasterTrackNumberForTri.CompareTo(y.MasterTrackNumberForTri);
                if (cmp != 0)
                    return cmp;
                return x.Location.CompareTo(y.Location);
            });
            var dictArtist = new Dictionary<string, List<Piece>>();
            var dictAlbum = new Dictionary<int, string>();
            var dictDir = new Dictionary<string, List<Piece>>();
            DirSort.reset();
            foreach (Piece p in list)
            {

                DirSort.record(p);
            }

            DirSort.go();


            foreach (Piece p in list)
            {
                if (p.TrackNumber == 0)
                {
                    p.TrackNumber = list.Count + p.MasterTrackNumber;
                }
            }

            list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;

            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}

            //var list2 = new List<Piece>(list);
            //list2.Sort(new VirtualPieceComparer());

            var hs = new HashSet<int>();
            var unsorted = new List<Piece>();
            Piece pp = list[0];
            hs.Add(pp.PieceId); unsorted.Add(pp);
            //string currentArtist = pp.Artist;
            //string currentAlbum = pp.Master.Album;


            int indexC = 0;
            //  bool singleAlbum = false;
            string currentArtist = Album.getKey(pp.Artist, virtualMode.artist);
            unsortMode mode = unsortMode.album | unsortMode.artist;
            if (VirtualByArtist)
                mode = unsortMode.album;

            HashSet<string> artists = new HashSet<string>();
            HashSet<string> albums = new HashSet<string>();
            artists.Add(currentArtist);
            albums.Add(pp.Master.PieceAlbum.Key);
            //  HashSet<string> paths = new HashSet<string>();
            //int pathlevel = 0;
            //  bool found = false;
            int nbc = 0;
            while (unsorted.Count < count)
            {
                nbc++;
                //int indexAlbum = -1;
                //int indexArtist = -1;


                // addPath(pp, paths, pathlevel);

                artists.Clear();
                albums.Clear();
                //    paths.Clear();
                artists.Add(currentArtist);
                albums.Add(pp.Master.PieceAlbum.Key);


                for (int i = 0; i < count; i++)
                {

                    var p = list[i];
                    if (hs.Contains(p.PieceId))
                        continue;

                    if (mode == 0)
                    {
                        hs.Add(p.PieceId);
                        unsorted.Add(p);
                        pp = p;
                        // indexAlbum = -1;
                        indexC = i;
                        continue;
                    }
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        var artist = p.Artist;
                        if (p.Artist != pp.Artist)
                        {
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            if (currentArtist != cartist)
                            {
                                if (!artists.Contains(cartist))
                                {
                                    if (mode.HasFlag(unsortMode.album))
                                    {
                                        if (albums.Contains(p.Master.PieceAlbum.Key))
                                        {
                                            //if (albums.Count <= 1)
                                            //    indexArtist = i;
                                            continue;
                                        }
                                    }

                                    //if (pathlevel <= MAX_PATH_LEVEL)
                                    //{
                                    //    if (containsPath(p, paths, pathlevel))
                                    //        continue;
                                    //}

                                    hs.Add(p.PieceId);
                                    unsorted.Add(p);
                                    pp = p;
                                    //indexAlbum = -1;
                                    //indexArtist = -1;

                                    albums.Add(pp.Master.PieceAlbum.Key);
                                    artists.Add(cartist);
                                    //  addPath(pp, paths, pathlevel); 
                                    indexC = i;
                                    currentArtist = cartist;
                                    //   found = true;
                                    continue;

                                }
                            }
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                    {
                        var album = p.Master.PieceAlbum.Key;
                        if (!albums.Contains(album))
                        {
                            //if (pathlevel <= MAX_PATH_LEVEL)
                            //{
                            //    if (containsPath(p, paths, pathlevel))
                            //        continue;
                            //}
                            hs.Add(p.PieceId);
                            unsorted.Add(p);
                            pp = p;
                            indexC = i;
                            //indexAlbum = -1;
                            albums.Add(album);
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            artists.Add(cartist);
                            currentArtist = cartist;
                            //   found = true;
                            //  addPath(pp, paths, pathlevel); 
                        }
                    }
                }


                //if (indexAlbum >= 0)
                //{
                //    // pas trouvé d'autre artiste, on se rabat sur l'album
                //    var p = list2[indexAlbum];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexAlbum;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else if (indexArtist >= 0)
                //{
                //    // on a trouvé un autre artiste sur le même album. pas si mal
                //    var p = list2[indexArtist];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexArtist;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else
                //{
                //    // rien trouvé de spécial
                //    if (indexC == 0 && !singleAlbum)
                //    {
                //        singleAlbum = true;
                //    }
                //    indexC = 0;

                //}

                if (indexC == 0)
                {

                    //if (found)
                    //{
                    //    found = false;
                    //}
                    //else
                    //{
                    //{
                    //    if (paths.Count == 0)
                    //    {
                    //        pathlevel = MAX_PATH_LEVEL; 
                    //    }
                    //    if (pathlevel < MAX_PATH_LEVEL)
                    //    {
                    //        pathlevel++;
                    //    }
                    //    else
                    //    {
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        if (mode.HasFlag(unsortMode.album))
                            // on cherche les artistes différents ( éventuellement même album ) 
                            mode &= ~unsortMode.album;
                        else
                        {
                            // on abandonne la recherche artiste et on réactive la recherche album
                            mode &= ~unsortMode.artist;
                            mode |= unsortMode.album;
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                        // on est en mode single album; 
                        mode &= ~unsortMode.album;

                    //pathlevel = 0;
                    //  }
                }
                //}
                // }
                indexC = 0;

            }

            for (int i = 0; i < unsorted.Count; i++)
            {
                unsorted[i].TrackNumber = i + 1;
            }



            //foreach (Piece p in list)
            //{
            //    if (p == null)
            //        continue;
            //    var artist = p.Artist;
            //    FileInfo file = null;
            //    try
            //    {
            //        file = new System.IO.FileInfo(p.Location);
            //    }
            //    catch
            //    {
            //        continue;
            //    }
            //    var dirAlbum = file.Directory;
            //    var dirArtist = dirAlbum.Parent;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = dirArtist.FullName;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = "-";
            //    if (!dictArtist.ContainsKey(artist))
            //        dictArtist.Add(artist, new List<Piece>());
            //    dictArtist[artist].Add(p);

            //    var _album = p.Master.Album;
            //    if (string.IsNullOrEmpty(_album))
            //        _album = dirAlbum.FullName;
            //    dictAlbum.Add(p.PieceId, _album);

            //    //if (!dictAlbum.ContainsKey(_album))
            //    //    dictAlbum.Add(_album, new List<Piece>());
            //    //dictAlbum[_album].Add(p);


            //}

            //foreach (List<Piece> l in dictArtist.Values)
            //{
            //    //
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //var listUnSortArtist = new List<Piece>(list);
            //listUnSortArtist.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));

            //var listUnSortAlbum = new List<Piece>();

            //List<Piece> aux = new List<Piece>();
            //int current = 0;

            //foreach (Piece p in listUnSortArtist)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {
            //        //aux.Add(p);
            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            string xa = x.Master.Album;
            //            string ya = y.Master.Album;
            //            if (dictAlbum.ContainsKey(x.PieceId))
            //                xa = dictAlbum[x.PieceId];
            //            else
            //            { }
            //            if (dictAlbum.ContainsKey(y.PieceId))
            //                ya = dictAlbum[y.PieceId];
            //            else
            //            { }
            //            var cmp = xa.CompareTo(ya);
            //            return cmp;
            //        });

            //        listUnSortAlbum.AddRange(aux);
            //        aux.Clear();

            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    string xa = x.Master.Album;
            //    string ya = y.Master.Album;
            //    if (dictAlbum.ContainsKey(x.PieceId))
            //        xa = dictAlbum[x.PieceId];
            //    else
            //    { }
            //    if (dictAlbum.ContainsKey(y.PieceId))
            //        ya = dictAlbum[y.PieceId];
            //    else
            //    { }
            //    var cmp = xa.CompareTo(ya);
            //    return cmp;
            //});

            //listUnSortAlbum.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnSortAlbum.Count; i++)
            //{
            //    listUnSortAlbum[i].TrackNumber = i + 1;
            //}

            //aux.Clear();
            //current = 0;
            //var listUnsortTrack = new List<Piece>();

            //foreach (Piece p in listUnSortAlbum)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {

            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            var xt = x.MasterTrackNumber;
            //            var yt = y.MasterTrackNumber;
            //            int cmp = 0;
            //            if (xt <= 0 || yt <= 0)
            //            {
            //                try
            //                {
            //                    cmp = x.Location.CompareTo(y.Location);
            //                }
            //                catch
            //                {
            //                }
            //            }
            //            cmp = xt.CompareTo(yt);
            //            return cmp;
            //        });

            //        listUnsortTrack.AddRange(aux);
            //        aux.Clear();
            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    var xt = x.MasterTrackNumber;
            //    var yt = y.MasterTrackNumber;
            //    int cmp = 0;
            //    if (xt <= 0 || yt <= 0)
            //    {
            //        try
            //        {
            //            cmp = x.Location.CompareTo(y.Location);
            //        }
            //        catch
            //        {
            //        }
            //    }
            //    cmp = xt.CompareTo(yt);
            //    return cmp;
            //});

            //listUnsortTrack.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnsortTrack.Count; i++)
            //{
            //    listUnsortTrack[i].TrackNumber = i + 1;
            //}




            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;
            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}
        }

        public bool isSameOf(Album o)
        {
            if (o == this)
                return false;
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && mode == o.mode;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }
        private DateTime albumAdded = DateTime.MaxValue;
        public DateTime AlbumAdded
        {
            get
            {
                if (albumAdded < DateTime.MaxValue)
                    return albumAdded;
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                albumAdded = min;
                return albumAdded;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, virtualMode mode)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();

                if (mode == virtualMode.word)
                {
                    __album = string.Format("¤¤[{0}]", __album);
                    return __album;
                }
                if (mode == virtualMode.list)
                {
                    __album = string.Format("/{0}", __album);
                    return __album;
                }

                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (mode == virtualMode.artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }
                else if (mode == virtualMode.year)
                {
                    if (_album.Length == 3)
                        __album = string.Format("£[{0}0']", __album);
                    else
                        __album = string.Format("£[{0}]", __album);
                }
                else if (mode == virtualMode.extended)
                {
                    __album = string.Format("¤[{0}]", __album);
                }
                else if (mode == virtualMode.extendedWord)
                {
                    __album = string.Format("¤[{0}]¤", __album);
                }
                else if (mode == virtualMode.added)
                {
                    __album = string.Format("<{0}>", __album);
                }

            }
            return __album;

        }



    }
}
]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\Tuning\ZeroWorkConf.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;

namespace pdb.gen.Tuning
{
    public class ZeroWorkConf : TuningBase
    {
        public bool enabled;
        public bool alwaysKeep;
        public bool keep2Enabled;
        public bool alwaysKeep2;
        public bool alwaysCoeffZero;
        public decimal coeffZero = 1m;
        public decimal keepMinus = 0m;
        public bool dontKeepWhenHigh = false;
        public ZeroWorkConf()
            : base()
        { }

        public ZeroWorkConf(XmlElement node) : base(node)
        {
            if (node == null)
                return;
            buildb("enabled", v => enabled = v);
            buildb("alwaysKeep", v => alwaysKeep = v);
            buildb("keep2Enabled", v => keep2Enabled = v);
            buildb("alwaysCoeffZero", v => alwaysCoeffZero = v);
            buildb("alwaysKeep2", v => alwaysKeep2 = v);
            buildb("dontKeepWhenHigh", v => dontKeepWhenHigh = v);
            builddec("keepMinus", v => keepMinus = v);
            builddec("coeffZero", v => coeffZero = v);
        }
    }
}
]]></content>
  </file>
</db>
