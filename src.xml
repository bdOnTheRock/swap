<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\engine\vlc\pdb.player.engine.vlc.pluginI\VlcWrapper.cs">
    <content><![CDATA[using AXVLC;
using pdb.util;
using System;
using pdb.obj;
using System.Threading;

namespace pdb.player.engine.vlc.pluginI
{
    public class VlcWrapper : IPlayerEngine
    {
        private Logger logger;
#if NONI
        private VLCPlugin2Class vlc;
        Equalization eq = Equalization.Instance; 
#else
        private  VLCPlugin2 vlc;
#endif
        public event EventHandler mediaEndReached;
        // public static VlcWrapper Instance = new VlcWrapper();
        public VlcWrapper()
        {
            logger = Logger.getLogger("vlc");
            try
            {
#if NONI
          vlc = new VLCPlugin2Class();
     //     vlc.setVariable(Equalization.VARGAIN, eq.getVarGain());
     //     vlc.setVariable(Equalization.VARFREQ, eq.getVarFreq()); 
                
#else
                vlc = new VLCPlugin2();


#endif
            }
            catch (Exception e)
            {
                logger.log("impossible de récupérer vlc " + e.ToString());
            }

            catch
            {
            }

#if NONI
            vlc.DVLCEvents_Event_pause += vlc_DVLCEvents_Event_pause;
            vlc.DVLCEvents_Event_play += vlc_DVLCEvents_Event_play;
            vlc.DVLCEvents_Event_stop += vlc_DVLCEvents_Event_stop;
            
#else
            vlc.MediaPlayerEncounteredError += vlc_MediaPlayerEncounteredError;
            vlc.MediaPlayerEndReached += vlc_MediaPlayerEndReached;
            vlc.pause += new DVLCEvents_pauseEventHandler(vlc_pause);
            vlc.AutoLoop = false;
            vlc.AutoPlay = false;

#endif
        }

        void vlc_pause()
        {
            log("vlc_pause");
        }

        #region event
        void vlc_MediaPlayerEndReached()
        {
            vlc.playlist.stop();
            log("vlc_MediaPlayerEndReached");
            if (mediaEndReached != null)
                mediaEndReached(this, EventArgs.Empty);
        }

        void vlc_MediaPlayerEncounteredError()
        {
            log("vlc_DVLCEvents_Event_stop");
        }

        void vlc_DVLCEvents_Event_stop()
        {
            log("vlc_DVLCEvents_Event_stop");
        }

        void vlc_DVLCEvents_Event_play()
        {
            log("vlc_DVLCEvents_Event_play");
        }

        void vlc_DVLCEvents_Event_pause()
        {
            log("vlc_DVLCEvents_Event_pause");
        }

        private void log(string txt)
        {
            logger.log(txt);
        }
        #endregion

        #region commande
        string location;
        public void play(string location, bool reload)
        {
            if (reload || location != this.location)
            {
                this.location = location;
#if NONI
                vlc.playlistClear();
                vlc.addTarget(new Uri(location).AbsoluteUri, null, VLCPlaylistMode.VLCPlayListReplaceAndGo, 0);
#else
                vlc.playlist.items.clear();
                vlc.playlist.add(new Uri(location).AbsoluteUri);
#endif
            }
#if NONI
            vlc.play();
#else
            vlc.playlist.play();
#endif
        }

        public void pause()
        {
#if NONI
            vlc.pause();
#else
            vlc.playlist.pause();
#endif
        }

        public void stop()
        {
#if NONI
            vlc.stop();
#else
            vlc.playlist.stop();
#endif
        }

        public TimeSpan Duration
        {
            get
            {
                var input = vlc.input;
                if (input == null)
                    return new TimeSpan();
                return TimeSpan.FromMilliseconds(input.Length);
            }
        }

        public TimeSpan Elapsed
        {
            get
            {
                var input = vlc.input;
                if (input == null)
                    return new TimeSpan();
                return TimeSpan.FromMilliseconds(input.Time);
            }
        }

        public double Position
        {
            get
            {

                var input = vlc.input;
                if (input == null)
                    return 0;
                return input.Position;
            }

            set
            {
                var input = vlc.input;
                if (input == null)
                    return;
                input.Position = value;
            }
        }

        public double Volume
        {
            set
            {

                vlc.Volume = (int)(200 * value);
            }

            get
            {
                return 200 * vlc.Volume;
            }
        }

        #endregion

        #region equalizer
        #endregion





        private playerstate state = playerstate.stop;
        public playerstate State
        {
            get { return state; }
        }

        private void insist(string phase, Action action)
        {
            int nb = 0;
            while (true)
            {
                vlc.Volume = 0; 
                vlc.playlist.play();
                try
                {
                    action();
                    if (nb > 0)
                        misc.log(phase + " "+ nb.ToString()); 
                    nb = 0;
                    return;
                }
                catch (Exception ex)
                {
                    nb++;
                    Thread.Sleep(1000);
                    if (nb >= 4)
                    {
                        misc.log("abandon " +phase + " " + nb.ToString()); 
                        return;
                    }
                }
            }
        }

        public void load(ITrackMetaData track)
        {
            vlc.playlist.items.clear();
            vlc.playlist.add(new Uri(track.Location).AbsoluteUri);
            vlc.Volume = 0; 
            vlc.playlist.play();

            while (!vlc.playlist.isPlaying)
                Thread.Sleep(100);
            // vlc.playlist.pause();


     
          
                vlc.playlist.play();
                vlc.Volume = 0; 
                insist("Album", () => track.Album = vlc.mediaDescription.album);
                insist("Artist" ,() => track.Artist = vlc.mediaDescription.artist);
                insist("Duration", () => track.Duration = Duration);
                insist("Name",() => track.Name = vlc.mediaDescription.title);
                insist("TrackNumber", () =>
                {
                    string tn = vlc.mediaDescription.trackNumber;
                    int trackNumber = -1;
                    if (!string.IsNullOrEmpty(tn))
                    {
                        try
                        {
                            trackNumber = Convert.ToInt32(tn);
                        }
                        catch
                        {
                        }
                    }


                    if (trackNumber > 0)
                        track.TrackNumber = trackNumber;
                });

                insist("Year", () =>
                {

                    string date = vlc.mediaDescription.date;
                    DateTime dateC = DateTime.MinValue;
                    if (!string.IsNullOrEmpty(date))
                    {
                        try
                        {
                            track.Year = Convert.ToInt32(date);
                        }
                        catch
                        {
                        }
                    }
                });


           


        }



    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using pdb.player.model;
using pdb.player.ViewModel.Commande;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Windows.Data;
using System.Windows.Input;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.util;
using System.Collections;
using pdb.gen.conf;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg; 
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg; 
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(int index)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }

 

    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object(); 
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel(); 
                    }
                }
                return _instance; 
            }
        }
        private IPlayerEngine player = PlayerBuilder.create("vlcplugin");

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        private bool sortByAlbum = true; 
        ItrackProvider _real;
        private Logger log;
        public static IPlayerEngine Player { get { return Instance.player; } }

       
        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return sortByAlbum;
            }
            set
            {
                if (value != sortByAlbum)
                {
                    sortByAlbum = value;
                    OnPropertyChanged("SortByAlbum");
                    App.go(); 
                }
            }
        }
        private bool sortAlbumStrict; 
        public bool SortAlbumStrict
        {
            get { return sortAlbumStrict;}
            set
            {
                if (value != sortAlbumStrict)
                {
                    sortAlbumStrict = value;                    
                    OnPropertyChanged("SortAlbumStrict");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            player.mediaEndReached += player_mediaEndReached;
            player.Volume = volume;
            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume(); 
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }


        public void forward()
        {
            movetoNext();
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext()
        {
            move(true);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {


                if (currentTrack != null)
                    tracks.MoveCurrentTo(currentTrack);
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    focus(tracks.CurrentPosition);
                    if (playing)
                    {
                        player.play(item.Location, true);
                    }
                }

            }
        }


        private void movetoPrevious()
        {
            move(false);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                                break;
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

                focus(tracks.CurrentPosition);

                State = playerstate.play;
                //item.Playing = true;
                player.play(currentTrack.Location, reload);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            player.stop();

        }

        private void next()
        {
            movetoNext();
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }
        private void focus(int index)
        {
            if (provider == null)
                return;
            provider.Focus(index);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = player.Elapsed;
                this.Length = player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    CurrentAuthorAlbum = String.Format("{0} - {1}", currentTrack.Artist, currentTrack.Album);
                    if (currentTrack.Exists)
                        currentTrack.Duration = length;
                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }



        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            Instance.provider = provider;
            Instance._positionstate = positionstate.free;
            Instance.CurrentTrack = track;
            Instance.currentPl = provider.PlayList;
            Instance.provider = provider;
            Instance.tracks = provider.PresentationTracks;
            Instance.play(true, true);
            Instance.makeResume();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            tracks.MoveCurrentTo(TrackListViewModel.CurrentPlaying);
                            provider.Focus(tracks.CurrentPosition);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
      //  private class filterTask
      //  {
      //      public filterTask()
      //      {
      //      }
      //      public string filter;
      //      //public string waitingFilter; 
      //      //private bool cancel; 
      //      //private Thread th;
      //      public Predicate<object> Filter;
      //      //public ICollectionView coll;
      //      //private bool busy;

      //      public void go()
      //      {
             
      //          if (!string.IsNullOrEmpty(filter))
      //              filter = filter.Trim().ToLower().removeAccent();

      //          var tab = filter.Split(' ');
      //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
      //          lock (this)
      //              busy = true;
      //          coll.Filter = item =>
      //          {
      //              TrackListViewModel vitem = item as TrackListViewModel;
      //              if (vitem == null) return false;

      //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
      //              //    return vitem.Classement.StartsWith(filter);
      //              bool ok = true;
      //              var name = vitem.Name.Trim().ToLower().removeAccent();
      //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
      //              var album = vitem.Album.Trim().ToLower().removeAccent();
      //              var classement = vitem.Classement;
      //              foreach (string str in tab)
      //              {
      //                  if (!ok)
      //                      return false;
      //                  if (string.IsNullOrEmpty(str))
      //                      continue;
      //                  var str_ = str.Trim();
      //                  if (str_ == string.Empty)
      //                      continue;

      //                  ok = name.Contains(str_)
      //                      || artist.Contains(str_)
      //                      || album.Contains(str_)
      //                      || classement.StartsWith(str_);

      //              }

      //              return ok;

      //          };

      //          lock (this)
      //              busy = true;

      //      }
      //      private void getItems()
      //      {
      //          try
      //          {
      //              if (!string.IsNullOrEmpty(filter))
      //                  filter = filter.Trim().ToLower().removeAccent();
      //              if (cancel)
      //                  return;
      //              var tab = filter.Split(' ');
      //              if (cancel)
      //                  return;
      //              Filter = item =>
      //              {
      //                  TrackListViewModel vitem = item as TrackListViewModel;
      //                  if (vitem == null) return false;

      //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
      //                  //    return vitem.Classement.StartsWith(filter);
      //                  bool ok = true;
      //                  var name = vitem.Name.Trim().ToLower().removeAccent();
      //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
      //                  var album = vitem.Album.Trim().ToLower().removeAccent();
      //                  var classement = vitem.Classement;
      //                  foreach (string str in tab)
      //                  {
      //                      if (!ok)
      //                          return false;
      //                      if (string.IsNullOrEmpty(str))
      //                          continue;
      //                      var str_ = str.Trim();
      //                      if (str_ == string.Empty)
      //                          continue;

      //                      ok = name.Contains(str_)
      //                          || artist.Contains(str_)
      //                          || album.Contains(str_)
      //                          || classement.StartsWith(str_);

      //                  }

      //                  return ok;

      //              };
      //          }
      //          catch (Exception ex)
      //          {
      //              App.log.log(ex.ToString()); 
      //          }
      //      }
      //  }
      ////  private static filterTask filtertask = new filterTask(); 
        public static void doFilter(ICollectionView coll, string filter)
        {
           
            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
          
            coll.Filter = item =>
            {
                TrackListViewModel vitem = item as TrackListViewModel;
                if (vitem == null) return false;

                //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                //    return vitem.Classement.StartsWith(filter);
                bool ok = true;
                var name = vitem.Name.Trim().ToLower().removeAccent();
                var artist = vitem.Artist.Trim().ToLower().removeAccent();
                var album = vitem.Album.Trim().ToLower().removeAccent();
                var classement = vitem.Classement;
                foreach (string str in tab)
                {
                    if (!ok)
                        return false;
                    if (string.IsNullOrEmpty(str))
                        continue;
                    var str_ = str.Trim();
                    if (str_ == string.Empty)
                        continue;

                    ok = name.Contains(str_)
                        || artist.Contains(str_)
                        || album.Contains(str_)
                        || classement.StartsWith(str_);

                }

                return ok;

            };
        }




        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}


        public void doFilter(String filter)
        {
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);
            makeResume();
        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            string newResume = resume;
            try
            {

                IEnumerable items = null;
                var provider = DisplayProvider;
                if (provider == null)
                    return;
                var tracks = provider.PresentationTracks;
                int nbOrg = -1;
                items = tracks;
                if (items == null)
                    return;

                var selected = provider.SelectedTracks;
                if (selected.Count > 1)
                {
                    items = selected;
                    nbOrg = 0;
                    foreach (TrackListViewModel t in tracks)
                        nbOrg++;
                }
                int nb = 0, nbSelected = 0, nbAbsent = 0;
                TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationAbsent = new TimeSpan();

                foreach (TrackListViewModel track in items)
                {
                    nb++;
                    duration += track.Duration;
                    if (track.Enabled)
                    {
                        nbSelected++;
                        durationSelected += track.Duration;
                    }
                    if (!track.Exists)
                    {
                        nbAbsent++;
                        durationAbsent += track.Duration;
                    }
                }

                ITextWriter sb = new pdb.util.StringBuilder();
                sb.Append(nb);
                sb.Append(" ");
                sb.Append("elt");
                if (nb > 1)
                    sb.Append("s");
                if (nbOrg >= 0)
                {
                    sb.Append(" sur ");
                    sb.Append(nbOrg);
                    sb.Append(",");
                }
                sb.Append(" ");
                humanDuration(sb, duration);
                sb.Append(" ( ");
                sb.Append(nbSelected);
                sb.Append(" ");
                sb.Append("elt");
                if (nbSelected > 1)
                    sb.Append("s");
                sb.Append(" ");
                humanDuration(sb, durationSelected);

                sb.Append(" )");

                if (nbAbsent > 0)
                {
                    sb.Append(" absents:");
                    sb.Append(nbAbsent);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationAbsent);
                }
                sb.Append("\t");

                var currentTrack = TrackListViewModel.HumanSelected;
                if (currentTrack != null)
                {
                    humanSize(sb, currentTrack.Size);
                    sb.Append(" ");
                    sb.Append(currentTrack.Location);
                }

                newResume = sb.ToString();
            }
            catch (Exception e0)
            {
                App.log.log(e0.ToString()); 
            }
            finally
            {
                if (newResume != resume)
                {
                    resume = newResume;
                    if (resumeChange != null)
                    {
                        try
                        {
                            resumeChange(this, EventArgs.Empty);
                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString()); 
                        }
                    }
                }
            }
        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append( size.HumanReadableSize(-1)); 
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append(" j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append(" h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append(" h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append(" m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append(" m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append(" s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.db;
using pdb.db.obj;
using pdb.gen;
using pdb.util;
using pdb.gen.Tuning;

namespace pdb.player.ViewModel.Commande.PlayList
{
    public enum compressState
    {
        none,
        record,
        enCours,
        end,
        reload,
        cancel
    }
    class ExportCmd : CommandeBase
    {
        private static IExportTracks ihm;
        public static IExportTracks Ihm { set { ihm = value; } }
        // private static bool cancel;
        // protected static string dir;
       protected static PlayListViewModel lastpl;
        protected static List<PiecePrior> presents;
        protected static Dict<int, PiecePrior> dict;
        protected static List<PiecePrior> list;
        protected static List<List<PiecePrior>> listes;
        protected static List<PlayListViewModel> playlists = new List<PlayListViewModel>();

        protected static Dictionary<int, object> ids;
        protected static Dict<int, PiecePrior> idCopie;
        protected static BgDictString<PiecePrior> idCopieLoc;
        private static int nbLoop = 0;
        protected static Export conf;
        private static bool modeAlbum;
        //private static int nbByAlbumMin = int.MaxValue;
        //private static int nbByAlbumMax = int.MaxValue;
        //private static int nbLot = 100; 
        protected static int nbFicherSup;
        protected static int nbFichierAdd;
        const string CAPTION = "export";
        protected string ANNULATION_EXPORT = "Annulation export";

        protected static BgDictString<List<PiecePrior>> locations = new BgDictString<List<PiecePrior>>(); 

        protected static compressState state;
        public static void CalculExport()
        {
            switch (state)
            {
                case compressState.none:
                    break;
                case compressState.record:
                    break;
                case compressState.enCours:
                    state = compressState.reload;
                    break;
                case compressState.end:
                    state = compressState.reload;
                    break;
                case compressState.reload:
                    break;
                case compressState.cancel:
                    break;
                default:
                    break;
            }
        }

        protected class PiecePrior
        {
            private int prior0 = int.MaxValue;
            private int prior1 = int.MaxValue;
            public readonly CPiece Piece;
            public PiecePrior(CPiece piece, int prior)
            {
                this.Piece = piece;
                this.prior0 = prior;
            }

            public int Prior0 { get { return prior0; } }
            public int Prior1 { get { return prior1; } }
            public int MasterId { get { return Piece.MasterId; } }
            public void setPrior(int prior)
            {
                if (prior < this.prior1)
                    this.prior1 = prior;
            }

            public static void mergePrior0(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return; 
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p0 = p.prior0;
                    if (p0 < min)
                        min = p0; 
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min; 
                }
            }

            public static void mergePrior1(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p1 = p.prior1;
                    if (p1 < min)
                        min = p1;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public override string ToString()
            {
                return "p=" + prior0 + " " + prior1 + " " + Piece.ToString();
            }
        }

        protected class PriorComparer : IComparer<PiecePrior>
        {
            public int Compare(PiecePrior x, PiecePrior y)
            {
                int cmp = x.Prior1.CompareTo(y.Prior1);
                if (cmp != 0)
                    return cmp;
                return x.Prior0.CompareTo(y.Prior0);
            }
        }

        public ExportCmd()
        {

        }


        public override bool CanExecute(object parameter)
        {
            return ihm != null;
        }

        public override void Execute(object parameter)
        {
            if (state <= compressState.record)
                record();
            else
                state = compressState.cancel;
            OnPropertyChanged("Header");
        }

        protected virtual List<PiecePrior> buildList(PlayListViewModel pl)
        {
            bool onlyEnabled = PlayerViewModel.Instance.OnlyEnabled && !modeAlbum;
            bool _modeAlbum = modeAlbum && !PlayerViewModel.Instance.SortByAlbum;
            var list = new List<PiecePrior>();
            var ids = new Dictionary<int, object>();
            int i = 0;
            var tracks = new List<TrackListViewModel>(pl.ExportTracks);
            int lastI = 0;
            string lastAlbum = "";
            int nbByAlbum = int.MaxValue;
            if (conf.modeAlbum)
                nbByAlbum = conf.nbMax;
            int nbLot = 0;
            while (true)
            {
                int nbInThisAlbum = 0;
                foreach (TrackListViewModel track in tracks)
                {
                    track.ExportStatus = exportState.miss; 
                    if (!onlyEnabled || track.Enabled)
                    {
                        CPiece piece = track.Piece;
                        if (piece.Exists)
                        {
                            int id = piece.MasterId;
                            if (ids.ContainsKey(id))
                                continue;
                            if (!_modeAlbum)
                            {
                                if (piece.Album == lastAlbum)
                                {
                                    if (track.Enabled)
                                    {
                                        nbInThisAlbum++;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                    }
                                }
                                else
                                {
                                    nbInThisAlbum = 1;
                                    lastAlbum = piece.Album;

                                }
                                var pp = dict[id]; // list.Add(piece);
                                pp.setPrior(i);
                                list.Add(pp);
                                ids.Add(id, pp);
                                i++;

                                if (track.Enabled)
                                {
                                    nbLot++;
                                    if (conf.modeAlbum && nbLot > conf.lot)
                                    {
                                        nbLot = 0;
                                        nbByAlbum--;
                                        if (nbByAlbum < conf.nbMin)
                                            nbByAlbum = conf.nbMin;
                                    }
                                }

                            }
                            else
                            {
                                if (conf.modeAlbum)
                                {
                                    if (piece.Album == lastAlbum)
                                        continue;
                                    else
                                    {
                                        nbLot++;
                                        if (nbLot > conf.lot)
                                        {
                                            nbLot = 0;
                                            nbByAlbum--;
                                            if (nbByAlbum < conf.nbMin)
                                                nbByAlbum = conf.nbMin;
                                        }
                                    }
                                }

                                var album = App.gen.getTracksAlbumByNumber(piece);
                                if (album != null)
                                {
                                    nbInThisAlbum = 0;
                                    lastAlbum = piece.Album;
                                    foreach (var p in album)
                                    {
                                        CPiece pp = p.Track as CPiece;
                                        if (pp.Exists)
                                        {
                                            if (!onlyEnabled || pp.Enabled)
                                            {
                                                id = pp.MasterId;

                                                if (ids.ContainsKey(id))
                                                    continue;
                                                var ppp = dict[id];
                                                ppp.setPrior(i);
                                                list.Add(ppp);
                                                ids.Add(id, ppp);
                                                i++;
                                                if (pp.Enabled)
                                                {
                                                    nbLot++;
                                                    if (conf.modeAlbum && nbLot > conf.lot)
                                                    {
                                                        nbLot = 0;
                                                        nbByAlbum--;
                                                        if (nbByAlbum < conf.nbMin)
                                                            nbByAlbum = conf.nbMin;
                                                    }

                                                    nbInThisAlbum++;
                                                    if (nbInThisAlbum >= nbByAlbum)
                                                        break;
                                                }
                                            }
                                        }

                                    }
                                }
                            }
                        }
                    }
                }
                if (!modeAlbum)
                    break;
                if (nbByAlbum == int.MaxValue)
                    break;
                if (i == lastI)
                    break;

                lastI = i;
                lastAlbum = "";
                if (conf.modeAlbum)
                {
                    if (conf.resetAfterLoop)
                        nbByAlbum = conf.nbMax;
                    if (nbByAlbum < conf.nbMin)
                        nbByAlbum = conf.nbMin; 
                }
            }
            listes.Add(list);
            //   ihm.InfoIHm("liste n° " + listes.Count + " " + list.Count + " éléments", CAPTION);
            OnPropertyChanged("Header");
            return list;
        }

        public override string Header
        {
            get
            {
                if (state > compressState.record)
                    return ANNULATION_EXPORT;

                return "Exporter la liste";
            }
        }



        private void record()
        {
            if (state == compressState.none)
            {
                state = compressState.record;
                OnPropertyChanged("Header");
                nbLoop = 0;
                conf = ihm.getConfExport("Configuration Export");

                //  dir = conf.dir; // ihm.folderDialog();

                if (string.IsNullOrEmpty(conf.dir))
                {
                    state = compressState.none;
                    return;
                }

                modeAlbum = conf.modeAlbum; // ihm.Confirm("par albums complets?", CAPTION);

                //if (modeAlbum)
                //{
                //    nbByAlbumMin = conf.nbMin; // ihm.getNb("Nombre de morceaux par passe?");
                //    nbByAlbumMax = conf.nbMax;
                //    nbLot = conf.lot;
                //}
                //else
                //    nbByAlbum = int.MaxValue;

                playlists.Clear();
            }

            bool? status = true;


            var pl = ihm.PlayList;
            if (!playlists.Contains(pl))
            {
                playlists.Add(pl);
                lastpl = pl;
            }

            status = ihm.TriChoix("liste n° " + playlists.Count + " " + pl.ExportTracks.Count + " éléments\r\n lancer l'export ?", CAPTION);



            if (status == null)
            {
                listes = null;
                playlists.Clear();
                state = compressState.none;
                OnPropertyChanged("Header");
                return;
            }
            if (false.Equals(status))
            {
                OnPropertyChanged("Header");
                return;
            }

            state = compressState.enCours;
            OnPropertyChanged("Header");

            var th = new Thread(export__);
            th.SetApartmentState(ApartmentState.STA);
            th.Start();
        }

        private void buildListIni()
        {

            listes = new List<List<PiecePrior>>();
            presents = new List<PiecePrior>();
            dict = new Dict<int, PiecePrior>();
            locations = new BgDictString<List<PiecePrior>>(); 


            if (!conf.dir.EndsWith("\\"))
                conf.dir += "\\";

            List<Piece> l = null;


            if (lastpl.isSubList("album") || PlayerViewModel.Instance.SortByAlbum)
            {
                l = App.gen.sortByAlbum();
                l.Reverse();
            }
            else
                l = App.gen.sortByClass();
            // l.Reverse();

            int i = 0;
            foreach (Piece p in l)
            {
                var piece = p.Track as CPiece;
                if (!dict.ContainsKey(piece.MasterId))
                {
                    var pp = new PiecePrior(piece, i);
                    i++;
                    presents.Add(pp);
                    dict[piece.MasterId] = pp;
                    foreach (CFile file in piece.Files)
                    {
                        var lp = locations[file.File];
                        if (lp == null)
                        {
                            lp = new List<PiecePrior>();
                            lp.Add(pp);
                            locations.Add(file.File, lp);
                        }
                        else
                        {
                            lp.Add(pp);
                            PiecePrior.mergePrior0(lp); 
                        }
                    }
                }
            }

        }

        [STAThread]
        private void export__()
        {


            while (true)
            {
                switch (state)
                {
                    case compressState.none:
                        return;
                    case compressState.enCours:
                        break;
                    case compressState.end: Thread.Sleep(1000); continue;
                    case compressState.reload:
                        break;
                    case compressState.cancel:
                        {
                            state = compressState.none;
                            nbLoop = 0;
                            return;
                        }

                    default:
                        break;
                }
                state = compressState.enCours;
                nbLoop++;

                buildListIni();

                foreach (PlayListViewModel pl in playlists)
                {
                    buildList(pl);
                }

                foreach (List<PiecePrior> lp in locations.Values)
                {
                    PiecePrior.mergePrior1(lp); 
                }

                // concaténation
                int max = 0;
                list = new List<PiecePrior>();
                foreach (var _l in listes)
                {
                    var count_ = _l.Count;
                    if (count_ > max)
                        max = count_;
                }
                int count = listes.Count;
                ids = new Dictionary<int, object>();


                for (int i = 0; i < max; i++)
                {
                    for (int j = 0; j < count; j++)
                    {
                        var l = listes[j];
                        if (i < l.Count)
                        {
                            var p = l[i];
                            int id = p.MasterId;
                            if (!ids.ContainsKey(id))
                            {
                                ids.Add(id, p);
                                list.Add(p);
                            }
                        }
                    }
                }






                App.log.log("Export lancé " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments", CAPTION);
                _export();

            }
        }

        protected virtual bool noMoreSpace()
        {
            return true;
        }
        protected virtual void prepareExport()
        {
        }

        private void _export()
        {

            try
            {
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (state != compressState.enCours)
                            return;
                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        var files = piece.Piece.Files;
                        foreach (CFile file in files)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    exists = true;
                                    break;
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            if (track != null)
                            {
                                track.ExportStatus = exportState.present;
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        App.log.log(e.ToString());
                    }
                }

                nbFicherSup = 0; nbFichierAdd = 0;
                idCopie = new Dict<int, PiecePrior>(); idCopieLoc = new BgDictString<PiecePrior>();
                presents.Sort(new PriorComparer());
                prepareExport();

                string orgDir = CFile.DefaultFolder;
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (state != compressState.enCours)
                            return;

                        int id = piece.MasterId;
                        if (idCopie.ContainsKey(id))
                            continue;
                        var files = piece.Piece.Files;
                        bool contFile = false;
                        foreach (CFile file in files)
                        {
                            if (idCopieLoc.ContainsKey(file.File))
                            {
                                contFile = true;
                                break;
                            }
                        }
                        if (contFile)
                            continue;

                        idCopie[id] = piece;
                        foreach (CFile file in files)
                        {
                            idCopieLoc[file.File] = piece;
                        }




                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        foreach (CFile file in files)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    exists = true;
                                    break;
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                        //    var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                        //    if (track != null)
                        //    {
                        //        track.ExportStatus = exportState.present; 
                        //    }
                            continue;
                        }

                        //2. Copie du meilleur fichier
                        CFile pertinent = files.getPertinentFile();
                        if (pertinent == null)
                            continue;


                        while (true)
                        {
                            if (state != compressState.enCours)
                                return;
                            try
                            {
                                FileInfo f = new FileInfo(pertinent.Path);
                                App.log.log(piece.Piece.DurationInSec + "s\tcopie vers " + conf.dir + pertinent.File + " ( " + piece + " )");
                                f.copyTree(conf.dir + pertinent.File, null);
                                var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                                if (track != null)
                                {
                                    track.ExportStatus = exportState.copy;
                                }
                                nbFichierAdd++;

                                break;
                            }
                            catch (System.IO.IOException io)
                            {
                                App.log.log(io.Message);
                                if (noMoreSpace())
                                    return;
                            }
                        }

                    }

                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }


                }
            }
            finally
            {
                App.log.log(string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6}",
                    listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : "")), CAPTION);
                //  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                list = null;
                listes = null;

                if (state == compressState.enCours)
                    state = compressState.end;
                OnPropertyChanged("Header");

            }
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des donn�es consolid�es morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        /// <summary>
        /// Liste des donn�es morceux dupliqu�s 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private volatile object _lock = new object();
        private bool _consolidEnCours;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
        }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList)
        {
            try
            {
                waitForConsolid();
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                var auxlistPieceInAlbum = new List<Piece>();
                albums = new Albums(this);
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>(); 
                htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        var piece = new Piece(track);
                        auxlistPieceInAlbum.Add(piece);
                        htIds.Add(piece.PieceId, piece);
                    }
                }
                // link
                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        listPieceInAlbum.Add(piece);
                        foreach (Piece child in piece.Childs)
                            listPieceInAlbum.Add(child);
                        albums.check(piece);
                    }
                }

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece); 
                    }
                }
                Ranking();
            }
            finally
            {
                lock (_lock)
                    _consolidEnCours = false;
            }

        }

        public void buildMusique()
        {
            foreach (Piece piece in listPieceInAlbum)
            {
                musique.addObj(piece);
            }

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.Tracks;
                tracks.Sort(new PieceTrackNumberComparer());
                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(ITrackMetaData track)
        {
            return albums.getAlbum(track);
        }

        public List<Piece> getTracksAlbum(ITrackMetaData track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumByNumber(ITrackMetaData track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        {
            var album = getAlbum(track);
            if (album == null)
                return;
            foreach (var p in album.Tracks)
            {
                container.Add(p);
            }
        }

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPieceInAlbum);
                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking()
        {
            QRanking();
            LRanking();
            QLRanking();

            misc.log("setTuningDateValues");
            var list = new List<Piece>(listPiece);
            foreach (Piece piece in list)
            {
                piece.FirstClass = false;
                CRank rank = piece.Rank;
                var sortValue = CTuning.Calc(rank, CConf.Sort);
                rank.SortValue = sortValue;

                ListSelection.setTuningDateValues(piece);
            }

            misc.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            misc.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            misc.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);

            albums.makeSort();
            misc.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                misc.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                misc.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        misc.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                misc.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    misc.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    misc.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    misc.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    misc.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                misc.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    misc.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            misc.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            misc.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            misc.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            misc.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit� +longueur en cas d'�galit�
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            misc.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }

            if (CConf.Condensation)
            {
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();

            }

        }

        public void builStats()
        {
            try
            {
                bool generDistrib = step % 10 == 0; 
                new StatBuilder(m_listQL).gener3(generDistrib);
                var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                stat.gener4("stats4.txt");
                stat = new StatBuilder(m_listQL) { Loupe = 2 };
                stat.gener4("stats4.txt");
                stat = new StatBuilder(m_listQL) { Loupe = 3 };
                stat.gener4("stats4.txt"); 
                var unselected = m_listQL.FindAll(t => !t.Enabled);
                new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                stat = new StatBuilder(unselected) { Loupe = 1 };
                stat.gener4("courant4.txt");
                stat = new StatBuilder(unselected) { Loupe = 2 };
                stat.gener4("courant4.txt");
                stat = new StatBuilder(unselected) { Loupe = 3 };
                stat.gener4("courant4.txt"); 

            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            return new DynamicStatBuilder(list).gener(className);
        }



        public void timeRanking()
        {
            misc.log("timeRanking");
            foreach (var piece in allClassed)
                ListSelection.setTuningDateValues(piece);


        }

        /// <summary>
        /// redirection des index metier de la table m�tier vers la table locale
        /// Copie des valeurs pertinentes(classlist)
        /// </summary>
        /// <remarks></remarks>
        public void eraseGrouping()
        {
            thCommentGo = false;
            thGroupingGo = false;
            misc.log("eraseGrouping");
            foreach (Piece piece in listPieceInAlbum)
            {
                piece.setGrouping("", false);
                piece.Comment = "";
            }
        }
        public void writeGrouping()
        {
            misc.log("writeGrouping");
            var list = new List<Piece>(listPieceInAlbum);
            // list.Sort(new CPieceComparerByQualityAndLength());
            list.Sort(new AllPieceComparer2());

            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }


        private bool thGroupingGo;
        private bool thCommentGo;

        public bool GroupinGO
        {
            set
            {
                thGroupingGo = value;
                if (value)
                {
                }
            }
        }
        public bool CommentGo
        {
            set
            {
                thCommentGo = value;
                if (value)
                {
                }
            }
        }



        private void writeGroupingAsync()
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in listPieceInAlbum)
            {
                try
                {
                    if (!thGroupingGo)
                        return;
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }

        private void writeCommentAsync()
        {
            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in listPiece)
            {
                try
                {
                    if (!thCommentGo)
                        return;
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }
        }

        public void writeGrouping(Piece piece)
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            piece.writeGrouping(writeGrouping);

        }
        private bool _sortByAlbum = true;
        public bool SortByAlbum { set { _sortByAlbum = value; } }

        private bool _albumSortStrict = CConf.ConfGen.AlbumSortStrict;
        public bool SortAlbumStrict { set { _albumSortStrict = value; } get { return _albumSortStrict; } }

        public void writeComment()
        {
            misc.log("writeComment");
            var list = new List<Piece>(listPiece);
            list.Sort(new CPieceComparerByQualityAndLength());

            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }




        }

        public void writeComment(Piece piece)
        {
            var writeComment = CConf.ConfGen.WriteComment;
            try
            {
                piece.writeComment(writeComment);
            }
            catch (Exception ex)
            {
                misc.log("writeComment::" + ex.ToString());
            }
        }



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            var conf = CConf.ConfGen;

            misc.log("Clegacy:createRot {0}", a_baseName);
            List<Piece> l_list = new List<Piece>();
            List<Piece> source = null;
            if (_sortByAlbum)
                source = allClassedInAlbumEnabled;
            else
                source = m_listTrackClassed;
            foreach (Piece l_piece in source)
            {
                //if (l_piece.belongsTo(a_baseName))
                //{
                l_list.Add(l_piece);
                // }
            }
            m_listWriter = new CLegacyListWriter(l_list, _sortByAlbum);

            l_list = new List<Piece>();
            foreach (Piece piece in listPieceInAlbum)
                l_list.Add(piece);

            listWriterAll = new CLegacyListWriter(l_list, _sortByAlbum);


            foreach (IListWriter writer in writers)
                m_listWriter.addWriter(writer);

            foreach (IListWriter writer in writers)
                listWriterAll.addWriter(writer);

            //      m_listWriter.reset();
            foreach (var duration in conf.Listes)
            {


                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(mode, duration, "g", false);
                    m_listWriter.writeGen(mode, duration, "e", true);
                }
            }

            if (conf.GenCheck)
                m_listWriter.writeCheckClassement(0);

            for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
            {
                m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
            }


            foreach (var duration in conf.Listes)
            {

                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(albums, mode, duration, "g", false);
                }
            }

            listWriterAll.writeGen(albums, null, null, "all", false);

            return;

            writeRot(1);

            m_listWriter.writeCheckClassement(1);

            m_listWriter.reset();
            writeRotMin(-1);
            writeRotMin(10);
            writeRotMin(1);
        }
        private void writeRotMin(int a_nbHour)
        {
            misc.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\stat\StatBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using pdb.util;

namespace pdb.gen.stat
{
    class StatBuilder
    {


        private List<Piece> list;
        private StreamWriter st;
        private int level;
        private int sub;
        private int delta;

        private decimal coeff;

        public const int VAL_MAX = 6000;
        private int min;
        private int nbCurrent;
        private Regex reg = new Regex("[6789]");
        public const int NB_MEDIANE = 36;
        private StatConteneur conteneur = new StatConteneur();
        public StatBuilder(IEnumerable<Piece> list)
        {
            this.list = new List<Piece>(list);
            this.list.Reverse();
        }

        private void record()
        {
            st.Write((double)min / 1000);
            st.Write("\t");
            st.WriteLine(nbCurrent);
        }
        private void record3()
        {
            st.Write((double)min / 10000);
            st.Write("\t");
            double v = (double)nbCurrent / (double)coeff;
            st.WriteLine(v.ToString("0.#####"));
        }

        private void record4()
        {
            st.Write((decimal)min /( 10000 * loupeCoeff));
            st.Write("\t");
            double v = (double)nbCurrent / (double)coeff;
            st.WriteLine(v.ToString("0.#####"));
        }

        private void record2()
        {
            conteneur.record(level, sub, min, nbCurrent);
        }

        public void gener()
        {
            gener("stats.txt");
        }

        public void gener0()
        {
            gener0("stats.txt");
        }


        public void gener0(string file)
        {
            decimal EPSILON = 0.00000001m;
            int count = list.Count;
            if (count == 0)
                return;
            using (Stream stream = new FileStream(@"..\" + file, FileMode.Create))
            {
                using (st = new StreamWriter(stream, Encoding.ASCII))
                {
                    try
                    {
                        int deltaBase = 10000;
                        for (level = 0; level < 4; level++)
                        {
                            deltaBase /= 10;
                            int nb = VAL_MAX / deltaBase;
                            //  var tab = new int[nb]; 
                            for (sub = 3; sub >= 1; sub--)
                            {
                                // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                delta = sub * deltaBase;
                                //   nb =(int)( 6 / sub * Math.Pow(10, 4 - level)); 
                                // level = 1 =>600

                                // parcourir la liste triée
                                // pour chaque pièce comparer classNameAndRating
                                int index = 0;
                                st.WriteLine();
                                st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub);

                                min = 0;
                                int max = delta;


                                var current = list[index].ClassementValueDecimal;
                                nbCurrent = 0;

                                bool _end = false;
                                while (true)
                                {
                                    if (min >= VAL_MAX)
                                        break;

                                    if (current * 1000 + EPSILON >= max || _end)
                                    {
                                        //if (!reg.IsMatch(min.ToString()))
                                        record();

                                        min = max;
                                        while (reg.IsMatch(min.ToString()))
                                            min += deltaBase;

                                        max = min + delta;
                                        nbCurrent = 0;

                                    }
                                    else
                                    {
                                        nbCurrent++;
                                        index++;
                                        if (index >= list.Count)
                                        {

                                            _end = true;
                                            continue;
                                        }
                                        current = list[index].ClassementValueDecimal;
                                    }
                                }

                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                    }
                    st.WriteLine();

                    try
                    {
                        //phase deux déterminer les tantièmes
                        //1,2,3..10,20,30..100,
                        double nbTot = count;
                        double portion = nbTot;
                        int K = 1;
                        decimal valueFrom = 0;

                        decimal classTo = 6.0m;
                        decimal classFrom = 0.0m;

                        List<Tranche> tranches = new List<Tranche>();
                        const int DETAIL = 1000;

                        for (int i = 0; i < 6 * DETAIL; i++)
                        {
                            if (reg.IsMatch(i.ToString()))
                                continue;
                            tranches.Add(new Tranche(i));
                        }
                        for (level = 1; level < 2; level++)
                        {



                            for (int div = 2; div <= NB_MEDIANE; div++)
                            {


                                //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                valueFrom = 0;
                                int iFrom = 0;
                                int iTo = count - 1;
                                portion = nbTot / div;
                                classFrom = 0;
                                for (sub = 1; sub <= div; sub++)
                                {

                                    double to = sub * portion;
                                    iTo = 0;
                                    if (to > 0)
                                        iTo = (int)to - 1;
                                    if (iTo >= list.Count)
                                        iTo = list.Count - 1;
                                    if (iTo < 0)
                                        iTo = 0;
                                    decimal rapport = list[iTo].RapportClassementDecimal;
                                    classTo = list[iTo].ClassementValueDecimal;


                                    //st.Write(classFrom);
                                    ////st.Write("\t");
                                    //st.Write(classTo);
                                    //st.Write("\t");
                                    ////st.Write(valueFrom);
                                    ////
                                    //st.Write(rapport);
                                    //st.Write("\t");


                                    //int nb = (iTo - iFrom + 1);                          
                                    //st.Write(nb);
                                    //st.Write("\t");
                                    decimal densite = 0;
                                    if (rapport != valueFrom)
                                        densite = 1.0m / ((rapport - valueFrom) * (decimal)div);
                                    //st.Write("\t");
                                    //st.Write(densite);
                                    //st.WriteLine(); 

                                    for (int i = 0; i < 6 * DETAIL; i++)
                                    {
                                        if (i < classFrom * DETAIL)
                                            continue;
                                        if (i > classTo * DETAIL)
                                            continue;
                                        if (reg.IsMatch(i.ToString()))
                                            continue;
                                        Tranche tranche = tranches.Find(t => t.index == i);
                                        tranche.densites[div - 1] = densite;
                                    }

                                    valueFrom = rapport;
                                    iFrom = iTo;
                                    classFrom = classTo;
                                }
                            }
                            K *= 10;
                        }

                        st.WriteLine();
                        st.Write("\t");
                        st.Write("\t");
                        st.Write("\t");

                        for (int i = 0; i < NB_MEDIANE; i++)
                        {
                            st.Write(i + 2);
                            st.Write("\t");
                            st.Write(i + 2);
                            st.Write("\t");
                        }
                        Tranche last = null;
                        foreach (Tranche tranche in tranches)
                        {
                            st.WriteLine();
                            st.Write((double)tranche.index / DETAIL);
                            st.Write("\t");

                            for (int i = 0; i < NB_MEDIANE; i++)
                            {
                                var densite = tranche.densites[i];
                                st.Write(densite);
                                st.Write("\t");
                                if (last == null || last.densites[i] != densite)
                                {
                                    st.Write(densite);
                                }
                                else
                                    st.Write(0);
                                st.Write("\t");
                            }
                            last = tranche;
                        }

                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e);
                    }
                }
            }
        }


        public void gener3(bool generDistrib)
        {
            gener3("stats3.txt", generDistrib);
        }
        public void gener3(string file, bool generDistrib)
        {
            decimal EPSILON = 0.00000001m;
            int VAL_MAX = StatBuilder.VAL_MAX * 10;
            int count = list.Count;
            if (count == 0)
                return;
            misc.log("gener " + file);


            var filename = Path.GetFileNameWithoutExtension(file);
            var ext = Path.GetExtension(file);
            string _file = @"..\" + filename + "_med" + ext;
            string f0 = @"..\" + file;
            string f0tmp = f0 + ".tmp";
            string f1tmp = _file + ".tmp";
            using (Stream stream = new FileStream(f0tmp, FileMode.Create))
            {
                using (st = new StreamWriter(stream, Encoding.ASCII))
                {
                    try
                    {
                        int deltaBase = 100000;
                        for (level = 4; level >= 0; level--)
                        {
                            deltaBase /= 10;
                            int nb = VAL_MAX / deltaBase;

                            for (sub = 3; sub >= 1; sub--)
                            {
                                coeff = (int)Math.Pow(6, level) * sub;
                                // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                delta = sub * deltaBase;
                                int index = 0;
                                st.WriteLine();
                                st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub);

                                min = 0;
                                int max = delta;


                                decimal current = list[index].ClassementValueDecimal;
                                nbCurrent = 0;

                                bool _end = false;
                                while (true)
                                {
                                    if (min >= VAL_MAX)
                                        break;

                                    if (current * 10000 + EPSILON >= max || _end)
                                    {

                                        record3();

                                        min = max;
                                        while (reg.IsMatch(min.ToString()))
                                            min += deltaBase;

                                        max = min + delta;
                                        nbCurrent = 0;

                                    }
                                    else
                                    {
                                        nbCurrent++;
                                        index++;
                                        if (index >= list.Count)
                                        {

                                            _end = true;
                                            continue;
                                        }
                                        current = list[index].ClassementValueDecimal;
                                    }
                                }

                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                    }

                }
            }

            File.Copy(f0tmp, f0, true);
            File.Delete(f0tmp);

            misc.log("fin gener " + file);

            if (!generDistrib)
                return;

            misc.log("gener distrib " + _file);

            using (FileStream stream2 = new FileStream(f1tmp, FileMode.Create))
            {
                using (st = new StreamWriter(stream2, Encoding.UTF8))
                {

                    try
                    {
                        //phase deux déterminer les tantièmes
                        //1,2,3..10,20,30..100,
                        double nbTot = count;
                        double portion = nbTot;
                        int K = 1;
                        decimal valueFrom = 0;

                        decimal classTo = 6.0m;
                        decimal classFrom = 0.0m;

                        List<Tranche> tranches = new List<Tranche>();
                        Dict<int, Tranche> dict = new Dict<int, Tranche>();
                        const int DETAIL = 10000;

                        for (int i = 0; i < 6 * DETAIL; i++)
                        {
                            if (reg.IsMatch(i.ToString()))
                                continue;
                            var tranche = new Tranche(i);
                            tranches.Add(tranche);
                            dict[i] = tranche;
                        }
                        for (level = 1; level < 2; level++)
                        {



                            for (int div = 2; div <= NB_MEDIANE; div++)
                            {


                                //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                valueFrom = 0;
                                int iFrom = 0;
                                int iTo = count - 1;
                                portion = nbTot / div;
                                classFrom = 0;
                                for (sub = 1; sub <= div; sub++)
                                {

                                    double to = sub * portion;
                                    iTo = 0;
                                    if (to > 0)
                                        iTo = (int)to - 1;
                                    if (iTo >= list.Count)
                                        iTo = list.Count - 1;
                                    if (iTo < 0)
                                        iTo = 0;
                                    decimal rapport = list[iTo].RapportClassementDecimal;
                                    classTo = list[iTo].ClassementValueDecimal;


                                    //st.Write(classFrom);
                                    ////st.Write("\t");
                                    //st.Write(classTo);
                                    //st.Write("\t");
                                    ////st.Write(valueFrom);
                                    ////
                                    //st.Write(rapport);
                                    //st.Write("\t");


                                    //int nb = (iTo - iFrom + 1);                          
                                    //st.Write(nb);
                                    //st.Write("\t");
                                    decimal densite = 0m;
                                    if (rapport != valueFrom)
                                        densite = 1.0m / ((rapport - valueFrom) * div);
                                    //st.Write("\t");
                                    //st.Write(densite);
                                    //st.WriteLine(); 

                                    for (int i = 0; i < 6 * DETAIL; i++)
                                    {
                                        if (i < classFrom * DETAIL)
                                            continue;
                                        if (i > classTo * DETAIL)
                                            continue;
                                        if (reg.IsMatch(i.ToString()))
                                            continue;
                                        Tranche tranche = dict[i];
                                        //  Tranche tranche = tranches.Find(t => t.index == i);
                                        tranche.densites[div - 1] = densite;
                                    }

                                    valueFrom = rapport;
                                    iFrom = iTo;
                                    classFrom = classTo;
                                }
                            }
                            K *= 10;
                        }

                        st.WriteLine();
                        st.Write("\t");
                        st.Write("\t");
                        st.Write("\t");

                        for (int i = 0; i < NB_MEDIANE; i++)
                        {
                            st.Write(i + 2);
                            st.Write("\t");
                            st.Write(i + 2);
                            st.Write("\t");
                        }
                        Tranche last = null;
                        foreach (Tranche tranche in tranches)
                        {
                            st.WriteLine();
                            st.Write((double)tranche.index / DETAIL);
                            st.Write("\t");

                            for (int i = 0; i < NB_MEDIANE; i++)
                            {
                                var densite = tranche.densites[i];
                                st.Write(densite);
                                st.Write("\t");
                                if (last == null || last.densites[i] != densite)
                                {
                                    st.Write(densite);
                                }
                                else
                                    st.Write(0);
                                st.Write("\t");
                            }
                            last = tranche;
                        }

                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e);
                    }
                }

            }

            File.Copy(f1tmp, _file, true);
            File.Delete(f1tmp);

            misc.log("fin gener distrib " + _file);
        }

        private int loupe;
        private decimal loupeCoeff;
        public int Loupe { set { loupe = value; loupeCoeff = Math.Pow(1000, loupe); } }
        public void gener4(string file)
        {
            decimal EPSILON = 0.00000001m / loupeCoeff;
            decimal VAL_MAX = StatBuilder.VAL_MAX * 10; // on laisse inchangé pour faire seulement une partie
            int count = list.Count;
            if (count == 0)
                return;
            misc.log("gener " + file + loupe);


            var filename = Path.GetFileNameWithoutExtension(file);
            var ext = Path.GetExtension(file);
            var str = "";
            if (loupe > 0)
                str = loupe.ToString();
            string _file = @"..\" + filename + "_med" + str + ext;
            string f0 = @"..\" + filename + str + ext;
            string f0tmp = f0 + ".tmp";
         //   string f1tmp = _file + ".tmp";
            using (Stream stream = new FileStream(f0tmp, FileMode.Create))
            {
                using (st = new StreamWriter(stream, Encoding.ASCII))
                {
                    try
                    {
                        int deltaBase = (int)(100000);
                        for (level = 4; level >= 0; level--)
                        {
                            deltaBase /= 10;
                            //int nb = VAL_MAX / deltaBase;

                            for (sub = 3; sub >= 1; sub--)
                            {
                                coeff = Math.Pow(6, level - 3* loupe) * sub ; /// loupeCoeff;
                                // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                int delta = (int)(sub * deltaBase);
                                int index = 0;
                                st.WriteLine();
                                st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" sub:"); st.WriteLine(sub);

                                min = 0;
                                var max = delta;


                                decimal current = list[index].ClassementValueDecimal;
                                nbCurrent = 0;

                                bool _end = false;
                                while (true)
                                {
                                    if (min >= VAL_MAX)
                                        break;

                                    if (current * 10000 * loupeCoeff + EPSILON >= max || _end)
                                    {

                                        record4();

                                        min = max;
                                        while (reg.IsMatch(min.ToString()))
                                            min += (int)deltaBase;

                                        max = min + delta;
                                        nbCurrent = 0;

                                    }
                                    else
                                    {
                                        nbCurrent++;
                                        index++;
                                        if (index >= list.Count)
                                        {

                                            _end = true;
                                            continue;
                                        }
                                        current = list[index].ClassementValueDecimal;
                                    }
                                }

                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                    }

                }
            }

            File.Copy(f0tmp, f0, true);
            File.Delete(f0tmp);

            misc.log("fin gener " + file + loupe);
            /*
            if (!generDistrib)
                return;

            misc.log("gener distrib " + _file);

            using (FileStream stream2 = new FileStream(f1tmp, FileMode.Create))
            {
                using (st = new StreamWriter(stream2, Encoding.UTF8))
                {

                    try
                    {
                        //phase deux déterminer les tantièmes
                        //1,2,3..10,20,30..100,
                        double nbTot = count;
                        double portion = nbTot;
                        int K = 1;
                        decimal valueFrom = 0;

                        decimal classTo = 6.0m;
                        decimal classFrom = 0.0m;

                        List<Tranche> tranches = new List<Tranche>();
                        Dict<int, Tranche> dict = new Dict<int, Tranche>();
                        const int DETAIL = 10000;

                        for (int i = 0; i < 6 * DETAIL; i++)
                        {
                            if (reg.IsMatch(i.ToString()))
                                continue;
                            var tranche = new Tranche(i);
                            tranches.Add(tranche);
                            dict[i] = tranche;
                        }
                        for (level = 1; level < 2; level++)
                        {



                            for (int div = 2; div <= NB_MEDIANE; div++)
                            {


                                //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                valueFrom = 0;
                                int iFrom = 0;
                                int iTo = count - 1;
                                portion = nbTot / div;
                                classFrom = 0;
                                for (sub = 1; sub <= div; sub++)
                                {

                                    double to = sub * portion;
                                    iTo = 0;
                                    if (to > 0)
                                        iTo = (int)to - 1;
                                    if (iTo >= list.Count)
                                        iTo = list.Count - 1;
                                    if (iTo < 0)
                                        iTo = 0;
                                    decimal rapport = list[iTo].RapportClassementDecimal;
                                    classTo = list[iTo].ClassementValueDecimal;


                                    //st.Write(classFrom);
                                    ////st.Write("\t");
                                    //st.Write(classTo);
                                    //st.Write("\t");
                                    ////st.Write(valueFrom);
                                    ////
                                    //st.Write(rapport);
                                    //st.Write("\t");


                                    //int nb = (iTo - iFrom + 1);                          
                                    //st.Write(nb);
                                    //st.Write("\t");
                                    decimal densite = 0m;
                                    if (rapport != valueFrom)
                                        densite = 1.0m / ((rapport - valueFrom) * div);
                                    //st.Write("\t");
                                    //st.Write(densite);
                                    //st.WriteLine(); 

                                    for (int i = 0; i < 6 * DETAIL; i++)
                                    {
                                        if (i < classFrom * DETAIL)
                                            continue;
                                        if (i > classTo * DETAIL)
                                            continue;
                                        if (reg.IsMatch(i.ToString()))
                                            continue;
                                        Tranche tranche = dict[i];
                                        //  Tranche tranche = tranches.Find(t => t.index == i);
                                        tranche.densites[div - 1] = densite;
                                    }

                                    valueFrom = rapport;
                                    iFrom = iTo;
                                    classFrom = classTo;
                                }
                            }
                            K *= 10;
                        }

                        st.WriteLine();
                        st.Write("\t");
                        st.Write("\t");
                        st.Write("\t");

                        for (int i = 0; i < NB_MEDIANE; i++)
                        {
                            st.Write(i + 2);
                            st.Write("\t");
                            st.Write(i + 2);
                            st.Write("\t");
                        }
                        Tranche last = null;
                        foreach (Tranche tranche in tranches)
                        {
                            st.WriteLine();
                            st.Write((double)tranche.index / DETAIL);
                            st.Write("\t");

                            for (int i = 0; i < NB_MEDIANE; i++)
                            {
                                var densite = tranche.densites[i];
                                st.Write(densite);
                                st.Write("\t");
                                if (last == null || last.densites[i] != densite)
                                {
                                    st.Write(densite);
                                }
                                else
                                    st.Write(0);
                                st.Write("\t");
                            }
                            last = tranche;
                        }

                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e);
                    }
                }

            }

            File.Copy(f1tmp, _file, true);
            File.Delete(f1tmp);

            misc.log("fin gener distrib " + _file);
             * */
        }

        public void gener(string file)
        {
            int count = list.Count;
            if (count == 0)
                return;
            decimal EPSILON = 0.00000001m;

            var filename = Path.GetFileNameWithoutExtension(file);
            var ext = Path.GetExtension(file);
            string _file = @"..\" + filename + "2" + ext;
            using (Stream stream = new FileStream(_file, FileMode.Create))
            {
                using (pdb.util.TextWriter st = new pdb.util.TextWriter(stream, Encoding.ASCII))
                {
                    try
                    {
                        int deltaBase = 10000;
                        for (level = 3; level >= 0; level--)
                        {
                            deltaBase /= 10;
                            int nb = VAL_MAX / deltaBase;
                            //  var tab = new int[nb]; 
                            for (sub = 3; sub >= 1; sub--)
                            {
                                // level 0 > 0,1,2,3,4,5 puis 01, 23,45, puis 0,3
                                delta = sub * deltaBase;
                                int index = 0;


                                min = 0;
                                int max = delta;


                                var current = list[index].ClassementValueDecimal;
                                nbCurrent = 0;

                                bool _end = false;
                                while (true)
                                {
                                    if (min >= VAL_MAX)
                                        break;

                                    if (current * 1000 + EPSILON >= max || _end)
                                    {
                                        record2();

                                        min = max;
                                        while (reg.IsMatch(min.ToString()))
                                            min += deltaBase;

                                        max = min + delta;
                                        nbCurrent = 0;

                                    }
                                    else
                                    {
                                        nbCurrent++;
                                        index++;
                                        if (index >= list.Count)
                                        {

                                            _end = true;
                                            continue;
                                        }
                                        current = list[index].ClassementValueDecimal;
                                    }
                                }

                            }
                        }

                        var datas = conteneur.Datas;

                        var results = new List<ResultLine>();

                        min = 0;
                        while (true)
                        {
                            while (reg.IsMatch(min.ToString()))
                                min++;
                            if (min >= VAL_MAX)
                                break;
                            results.Add(new ResultLine(min));
                            min++;
                        }

                        foreach (StatItem item in datas)
                        {
                            var level = item.level;
                            var sub = item.sub;
                            var _min = item.min;
                            var nb = item.nb;
                            // Détermination de la colonne
                            int col = 3 * level + sub - 1;

                            // Détermination du coeff d'expansion / moyenne
                            int coeff = (int)Math.Pow(6, level) * sub;

                            ResultLine res0 = results.Find(r => r.min == _min);
                            int index0 = results.IndexOf(res0);

                            for (int i = 0; i < coeff; i++)
                            {
                                results[index0 + i][col] = (double)nb / (double)coeff;
                            }

                        }


                        st.Append("min"); st.Append("\t");
                        for (int l = 0; l < 4; l++)
                        {
                            for (int s = 1; s <= 3; s++)
                            {
                                st.Append(l); st.Append(" ");
                                st.Append(s); st.Append("\t");
                            }

                        }
                        st.AppendLine();
                        st.AppendLine();


                        foreach (ResultLine line in results)
                        {
                            line.getLine(st); st.AppendLine();
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                    }

                    try
                    {

                        st.AppendLine();
                        st.AppendLine();
                        //phase deux déterminer les tantièmes
                        //1,2,3..10,20,30..100,
                        double nbTot = count;
                        double portion = nbTot;
                        int K = 1;
                        decimal valueFrom = 0m;

                        decimal classTo = 6.0m;
                        decimal classFrom = 0.0m;

                        List<Tranche> tranches = new List<Tranche>();
                        const int DETAIL = 1000;
                        for (int i = 0; i < 6 * DETAIL; i++)
                        {
                            if (reg.IsMatch(i.ToString()))
                                continue;
                            tranches.Add(new Tranche(i));
                        }
                        for (level = 1; level < 2; level++)
                        {



                            for (int div = 2; div <= NB_MEDIANE; div++)
                            {


                                //  st.Write("\t\t\tlevel:"); st.Write(level); st.Write(" div:"); st.WriteLine(div);
                                valueFrom = 0;
                                int iFrom = 0;
                                int iTo = count - 1;
                                portion = nbTot / div;
                                classFrom = 0;
                                for (sub = 1; sub <= div; sub++)
                                {

                                    double to = sub * portion;
                                    iTo = 0;
                                    if (to > 0)
                                        iTo = (int)to - 1;
                                    if (iTo >= list.Count)
                                        iTo = list.Count - 1;
                                    if (iTo < 0)
                                        iTo = 0;
                                    var rapport = list[iTo].RapportClassementDecimal;
                                    classTo = list[iTo].ClassementValueDecimal;


                                    //st.Write(classFrom);
                                    ////st.Write("\t");
                                    //st.Write(classTo);
                                    //st.Write("\t");
                                    ////st.Write(valueFrom);
                                    ////
                                    //st.Write(rapport);
                                    //st.Write("\t");


                                    //int nb = (iTo - iFrom + 1);                          
                                    //st.Write(nb);
                                    //st.Write("\t");
                                    decimal densite = 0m;
                                    if (rapport != valueFrom)
                                        densite = 1.0m / ((rapport - valueFrom) * div);
                                    //st.Write("\t");
                                    //st.Write(densite);
                                    //st.WriteLine(); 

                                    for (int i = 0; i < 6 * DETAIL; i++)
                                    {
                                        if (i < classFrom * DETAIL)
                                            continue;
                                        if (i > classTo * DETAIL)
                                            continue;
                                        if (reg.IsMatch(i.ToString()))
                                            continue;
                                        Tranche tranche = tranches.Find(t => t.index == i);
                                        tranche.densites[div - 1] = densite;
                                    }

                                    valueFrom = rapport;
                                    iFrom = iTo;
                                    classFrom = classTo;
                                }
                            }
                            K *= 10;
                        }

                        st.AppendLine();
                        st.Append("\t");
                        st.Append("\t");
                        st.Append("\t");

                        for (int i = 0; i < NB_MEDIANE; i++)
                        {
                            st.Append(i + 2);
                            st.Append("\t");
                            st.Append(i + 2);
                            st.Append("\t");
                        }
                        Tranche last = null;
                        foreach (Tranche tranche in tranches)
                        {
                            st.AppendLine();
                            st.Append((double)tranche.index / DETAIL);
                            st.Append("\t");


                            for (int i = 0; i < NB_MEDIANE; i++)
                            {
                                var densite = tranche.densites[i];
                                st.Append(densite);
                                st.Append("\t");
                                if (last == null || last.densites[i] != densite)
                                {
                                    st.Append(densite);
                                }
                                else
                                    st.Append(0);
                                st.Append("\t");
                            }
                            last = tranche;
                        }

                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                    }
                }
            }
        }


    }
}
]]></content>
  </file>
 </db>
