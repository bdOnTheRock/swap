<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.piece.type;
using pdb.db.obj;


namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log =Logger.getLogger("Program");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background; 


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {

                pdb.player.ViewModel.Colors.MementoColor.recover();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");


                var xmlConf = CConf.loadConf();
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate; 
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode; 

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        private static void goInit()
        {
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;
            gen.MakeConsolid(Db.List.getList(),true);



            if (CConf.ResetOneCl)
            {
                Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                foreach (Piece p in gen.sortByClass())
                {
                    decimal clValue = p.ClassementValueDecimal;
                    if (clValue > zer0d)
                    {
                        if (clValue >= zer0d)
                        {
                            var dPiece = Db.getPiece(p.PieceId);
                            var strNewCl = "0000" + dPiece.getClassement().ToString();
                            var newCl = Classement.create(strNewCl);
                            p.Enabled = true;

                            p.setClassement(newCl.ClassList, newCl.Rating);
                            dPiece.Classement.eraseClassement2(newCl);
                        }
                        else
                            p.Enabled = false;
                    }
                }
                /*
                var _albums = gen.Albums;
                foreach (var album in _albums.List)
                {
                    if (album.Name == "Mémos vocaux" || album.Name == "Pictures at an Exhibition")
                    {
                    }
                    var l = album.Tracks;
                    decimal pluspetitNonNull = int.MaxValue;
                    foreach (Piece t in l)
                    {
                        decimal clValue = t.ClassementValueDecimal;
                        if (clValue > zer0d)
                        {
                            if (clValue < pluspetitNonNull)
                                pluspetitNonNull = clValue;
                        }

                    }
                    foreach (Piece t in l)
                    {
                        if (t.Parent == null)
                        {
                            decimal clValue = t.ClassementValueDecimal;
                            if (t.isClassListNumeric && clValue > zer0d)
                            {
                                if (clValue > pluspetitNonNull)
                                {
                                    var dPiece = Db.getPiece(t.PieceId);
                                    t.Enabled = true;
                                    t.setClassement("0", 0);
                                    dPiece.Classement.eraseClassement2();
                                }
                            }
                        }
                    }
                }*/
                gen.MakeConsolid(Db.List.getList(),true);
            }


            gen.buildMusique();
           // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


          //  gen.timeRanking();
           // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            

            foreach (CPiece p in Db.List)
            {
                if (p.DurationInSec == 0 && p.Exists)
                {
                    try
                    {
                        PlayerViewModel.Player.getDuration(p);
                        log.log("{0} duration {1} s", p, p.DurationInSec);
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }

                }
            }


           // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
           // new Thread(() =>
            gen.builStats(null); 
        }

        private static void _go()
        {
            try
            {
                Memento.Instance.save();
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort; 
                }
                detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                // if (__end || __go) return;

                if (PlayerViewModel.Instance.CreateRot)
                {
                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 
                    gen.MakeConsolid(Db.List.getList(),_updateStats); //   bib.Musique.Tracks);
                    //  if (__end || __go) return;
                   // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);

                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, App.bib);
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();
                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats)
                        {                           
                            detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => detailClassementViewModel.IhmInDispo = ihmInDispo.none); 

                        }
                        else
                            detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                if (refresh != null && PlayerViewModel.Instance.CreateRot)
                    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats)
                    {
                        _updateStats = false;                         
                    }
                }
            }


        }

        public static event EventHandler refresh;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            App.bib.Aborted = true;
            Db.WriteDB1();
            Db.WriteDB2();
            App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.Track);
            if (l == null)
                return null;
            foreach (ITrackMetaData p in l)
            {

                TrackListViewModel trackList = PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                    return null;
                case MessageBoxResult.No:
                    return false;
                case MessageBoxResult.None:
                    return null;
                case MessageBoxResult.OK:
                    return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Threading;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.player.ViewModel.Commande;
using pdb.util;
using pdb.gen.auto;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg;
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg;
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(TrackListViewModel t)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }



    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object();
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort { get { return confAlbumSort; } set { confAlbumSort = value; } }
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel();
                    }
                }
                return _instance;
            }
        }

        public ConfFilter ConfFilter { get { return FilterTask.conf; } }
        private IPlayerEngine player = PlayerBuilder.create("vlcplugin");

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        public static event EventHandler autoChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        // private bool sortByAlbum = true;
        private bool withVirtualAlbum = CConf.ConfGen.AlbumVirtual;
        private bool withArtistVirtual = CConf.ConfGen.ArtistVirtual;
        private bool navAuto = CConf.ConfGen.NavAuto;
        public bool NavAuto
        {
            get { return navAuto; }
            set
            {
                if (value != navAuto)
                {
                    navAuto = value;
                    OnPropertyChanged("NavAuto");
                }
            }
        }

        private bool filterOnlyNext;
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                    OnPropertyChanged("FilterNext");
                }
            }
        }
        ItrackProvider _real;
        private Logger log;
        public static IPlayerEngine Player { get { return Instance.player; } }


        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }
        private bool createRot = true;
        public bool CreateRot
        {
            get
            {
                return createRot;
            }
            set
            {
                if (value != createRot)
                {
                    createRot = value;
                    OnPropertyChanged("CreateRot");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return confAlbumSort.Enabled;
            }
        }
        //private albumSortMode sortAlbumMode;
        //public albumSortMode SortAlbumMode
        //{
        //    get { return sortAlbumMode; }
        //    set
        //    {
        //        if (value != sortAlbumMode)
        //        {
        //            sortAlbumMode = value;
        //            OnPropertyChanged("SortAlbumMode");
        //            App.go();
        //        }
        //    }
        //}

        public bool WithVirtualAlbum
        {
            get { return withVirtualAlbum; }
            set
            {
                if (value != withVirtualAlbum)
                {
                    withVirtualAlbum = value;
                    OnPropertyChanged("WithVirtualAlbum");
                    App.go();
                }
            }
        }

        public bool WithVirtualArtist
        {
            get { return withArtistVirtual; }
            set
            {
                if (value != withArtistVirtual)
                {
                    withArtistVirtual = value;
                    OnPropertyChanged("WithVirtualArtist");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            player.mediaEndReached += player_mediaEndReached;
            player.Volume = volume;
            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume();
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }

        public void checkNavIni()
        {
            if (!navAuto)
                return;

            var tracks = PresentationTracks;
            bool foundFirst = false;
            TrackListViewModel f = null;

            foreach (TrackListViewModel t in tracks)
            {
                if (t.Index == 1)
                {
                    foundFirst = true;
                }
                if (foundFirst && t.PieceGen.IsNext)
                {
                    f = t;
                    break;
                }
            }

            if (f == null)
                return;

            tracks.MoveCurrentTo(f);
            focus(f);

        }

        public void forward()
        {
            if (!navAuto)
                movetoNext(true);
            else
            {
                var t = TrackListViewModel.HumanSelected;
                if (t != null)
                {
                    t.refresh();
                    //  var g = t.Grouping; 
                }

                var pl = PlayListViewModel.SelectedPlayList;
                if (pl == null)
                {
                    movetoNext(true);
                    return;
                }

                string _album = "";
                if (currentTrack != null)
                    _album = currentTrack.Album;
                movetoNext(true); // des fois le morceaux affiché n'est pas celui joué. Dommage...
                if (currentTrack != null && currentTrack.Album == _album)
                {
                    if (state == playerstate.play)
                        play(false, true);
                    return;
                }

                if (currentTrack == null)
                    return;
                var album = App.gen.Albums.getAlbum(CurrentTrack.Track);
                var tracks = album.Tracks;
                //    tracks.Sort(new PieceClassementComparer());
                //  decimal val = int.MaxValue;
                int i = 0;
                TrackListViewModel choose = null;
                if (confAlbumSort.ComposantsUtiles[0].cmpMin > modeMin.non)
                {
                    var next = album.Next;
                    if (next != null)
                        choose = pl.FindTrack(next.PieceId);
                }
                else
                {
                    for (i = 0; i < tracks.Count; i++)
                    {
                        var item = tracks[i];
                        if (item != null && (!onlyEnabled || item.Enabled))
                        {
                            var tl = pl.FindTrack(item.PieceId);
                            if (!tl.Exists)
                                continue;
                            choose = tl;

                            //val = v;
                            // choose = tl;
                            if (item.VirtualClassement == 0m)
                            {
                                break;
                                //if (confAlbumSort.ComposantsUtiles[0].cmpMin != modeMin.toujours)
                                //    choose = tl;
                                //break;
                            }
                            // choose = tl;
                        }
                    }
                }

                if (choose != null)
                {
                    //var p = choose.PieceGen;
                    //if (p != null)
                    //   confAlbumSort.auto(p.AutoCoeff1, p.AutoCoeff2); 
                    if (choose != currentTrack)
                    {
                        reset(provider, choose, state == playerstate.play);
                        var coll = PresentationTracks;
                        coll.MoveCurrentTo(choose);
                    }
                  
                    focus(choose);

                }

            }
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext(bool autoPlay)
        {
            move(true, autoPlay);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext, bool autoPlay)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {

                int masterId = 0;
                if (currentTrack != null)
                {
                    tracks.MoveCurrentTo(currentTrack);
                    masterId = currentTrack.MasterId;
                }
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.Exists && (!onlyEnabled || item.Enabled) && item.MasterId != masterId)
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    // focus(item);
                    if (playing && autoPlay)
                    {
                        player.play(item.Location, true);
                    }
                    // focus(item);
                }

            }
        }


        private void movetoPrevious()
        {
            move(false, true);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }


        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.Exists && (!onlyEnabled || item.Enabled))
                                break;
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

                //  focus(item);

                State = playerstate.play;
                //item.Playing = true;
                player.play(currentTrack.Location, reload);
                focus(item);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            player.stop();

        }

        private void next()
        {
            if (navAuto)
                forward();
            else
                movetoNext(true);
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }

        public void focusHelp()
        {
            var t = TrackListViewModel.CurrentPlaying;
            if (t == null)
                t = TrackListViewModel.HumanSelected;
            if (t == null) return;
            focus(t);
        }
        private void focus(TrackListViewModel t)
        {
            if (provider == null)
                return;
            provider.Focus(t);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = player.Elapsed;
                this.Length = player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    var sb = new System.Text.StringBuilder();
                    sb.Append(currentTrack.Artist);
                    sb.Append(" - ");
                    sb.Append(currentTrack.Album);
                    if (currentTrack.PieceGen != null)
                    {
                        if (currentTrack.PieceGen.Virtual)
                        {
                            sb.Append(" (");
                            sb.Append(currentTrack.PieceGen.Master.Album);
                            sb.Append(")");
                        }
                    }
                    CurrentAuthorAlbum = sb.ToString();
                    if (currentTrack.Exists)
                        currentTrack.Duration = length;

                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            reset(provider, track, true);
        }

        public static void makeauto(TrackListViewModel current)
        {
            if (current != null)
            {
                var p = current.PieceGen;
                if (p != null)
                {
                    MedianneDriver.auto(confAlbumSort, p); 
                    if (autoChange != null)
                        autoChange(current, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track, bool autoPlay)
        {
            if (provider != null)
            {
                Instance.provider = provider;
                Instance.currentPl = provider.PlayList;
                Instance.provider = provider;
                Instance.tracks = provider.PresentationTracks;

            }
            Instance._positionstate = positionstate.free;






            Instance.CurrentTrack = track;
            if (autoPlay)
                Instance.play(true, true);
            Instance.makeResume();
            App.go();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            var currentPlaying = TrackListViewModel.CurrentPlaying;
                            tracks.MoveCurrentTo(currentPlaying);
                            provider.Focus(currentPlaying);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
        //  private class filterTask
        //  {
        //      public filterTask()
        //      {
        //      }
        //      public string filter;
        //      //public string waitingFilter; 
        //      //private bool cancel; 
        //      //private Thread th;
        //      public Predicate<object> Filter;
        //      //public ICollectionView coll;
        //      //private bool busy;

        //      public void go()
        //      {

        //          if (!string.IsNullOrEmpty(filter))
        //              filter = filter.Trim().ToLower().removeAccent();

        //          var tab = filter.Split(' ');
        //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
        //          lock (this)
        //              busy = true;
        //          coll.Filter = item =>
        //          {
        //              TrackListViewModel vitem = item as TrackListViewModel;
        //              if (vitem == null) return false;

        //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //              //    return vitem.Classement.StartsWith(filter);
        //              bool ok = true;
        //              var name = vitem.Name.Trim().ToLower().removeAccent();
        //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //              var album = vitem.Album.Trim().ToLower().removeAccent();
        //              var classement = vitem.Classement;
        //              foreach (string str in tab)
        //              {
        //                  if (!ok)
        //                      return false;
        //                  if (string.IsNullOrEmpty(str))
        //                      continue;
        //                  var str_ = str.Trim();
        //                  if (str_ == string.Empty)
        //                      continue;

        //                  ok = name.Contains(str_)
        //                      || artist.Contains(str_)
        //                      || album.Contains(str_)
        //                      || classement.StartsWith(str_);

        //              }

        //              return ok;

        //          };

        //          lock (this)
        //              busy = true;

        //      }
        //      private void getItems()
        //      {
        //          try
        //          {
        //              if (!string.IsNullOrEmpty(filter))
        //                  filter = filter.Trim().ToLower().removeAccent();
        //              if (cancel)
        //                  return;
        //              var tab = filter.Split(' ');
        //              if (cancel)
        //                  return;
        //              Filter = item =>
        //              {
        //                  TrackListViewModel vitem = item as TrackListViewModel;
        //                  if (vitem == null) return false;

        //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //                  //    return vitem.Classement.StartsWith(filter);
        //                  bool ok = true;
        //                  var name = vitem.Name.Trim().ToLower().removeAccent();
        //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //                  var album = vitem.Album.Trim().ToLower().removeAccent();
        //                  var classement = vitem.Classement;
        //                  foreach (string str in tab)
        //                  {
        //                      if (!ok)
        //                          return false;
        //                      if (string.IsNullOrEmpty(str))
        //                          continue;
        //                      var str_ = str.Trim();
        //                      if (str_ == string.Empty)
        //                          continue;

        //                      ok = name.Contains(str_)
        //                          || artist.Contains(str_)
        //                          || album.Contains(str_)
        //                          || classement.StartsWith(str_);

        //                  }

        //                  return ok;

        //              };
        //          }
        //          catch (Exception ex)
        //          {
        //              App.log.log(ex.ToString()); 
        //          }
        //      }
        //  }
        ////  private static filterTask filtertask = new filterTask(); 
        private static IDisposable work;
        private static FilterTask filterTask = null;

        private static bool cancel;
        public static void doFilter0(ICollectionView coll, string filter)
        {

            ILogger log = App.log;
            log.log("filter=>{0}", filter);
            lock (_lock)
            {
                if (work == null)
                {
                    log.log("filter=>{0} verrou libre", filter);
                    work = coll.DeferRefresh();
                }
                else
                {
                    log.log("filter=>{0} verrou pris, abandon tâche en cours", filter);
                    cancel = true;
                }
            }

            var _cancel = cancel;
            if (_cancel)
                log.log("filter=>{0} verrou pris, attente fin tâche en cours", filter);
            while (cancel)
                Thread.Sleep(30);

            if (_cancel)
                log.log("filter=>{0} verrou pris, fin d'attente fin tâche en cours", filter);

            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 


            _cancel = cancel;
            if (!_cancel)
            {
                lock (_lock)
                    _cancel = cancel;
            }

            if (!_cancel)
            {
                log.log("filter=>{0} lancement filtre", filter);
                coll.Filter = item =>
                {
                    if (cancel)
                        return false;
                    TrackListViewModel vitem = item as TrackListViewModel;
                    if (vitem == null) return false;



                    //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                    //    return vitem.Classement.StartsWith(filter);
                    bool ok = true;
                    var name = vitem.Name.Trim().ToLower().removeAccent();
                    var artist = vitem.Artist.Trim().ToLower().removeAccent();
                    var album = vitem.Album.Trim().ToLower().removeAccent();
                    List<string> paths = null;
                    
                    var classement = vitem.Classement;
                    foreach (string str in tab)
                    {
                        if (!ok)
                            return false;
                        if (string.IsNullOrEmpty(str))
                            continue;
                        var str_ = str.Trim();
                        if (str_ == string.Empty)
                            continue;

                        ok = name.Contains(str_)
                            || artist.Contains(str_)
                            || album.Contains(str_)
                            || classement.StartsWith(str_);

                        if (!ok)
                        {
                            if (paths == null)
                            {
                                paths = new List<string>(); 
                                foreach (var f in vitem.Piece.Files)
                                {
                                    paths.Add(f.File.ToLower().removeAccent()); 
                                }
                            }

                            foreach (string path in paths)
                            {
                                if (path.Contains(str))
                                    return true; 
                            }
                        }
                    }

                    return ok;

                };

                if (cancel)
                    log.log("filter=>{0} la tâche a été interrompue", filter);
            }
            else
            {
                log.log("filter=>{0} finalement pas de lancement", filter);
            }
            lock (_lock)
            {
                if (!cancel)
                {
                    if (work != null)
                    {
                        log.log("filter=>{0} application du filtre", filter);
                        work.Dispose();
                    }
                    else
                    {
                        log.log("filter=>{0} ben pourquoa le work était null ????", filter);
                    }
                    work = null;

                }
            }

            lock (_lock)
                cancel = false;

            log.log("filter=>{0} fin", filter);
        }




        private class FilterTask
        {
            public static ConfFilter conf = new ConfFilter();
            private ICollectionView coll;
            public readonly string filter0;
            public readonly bool filterNext;

            private string filter;
            private bool _cancel;
            private bool end;
            private Thread th;
            SimpleChrono log;
            public string step;
            private HashSet<int> l = new HashSet<int>();
            public FilterTask(string filter, bool filterNext, ICollectionView coll, SimpleChrono log)
            {
                this.filter0 = filter;
                this.filter = filter;
                this.filterNext = filterNext;

                this.coll = coll;
                this.log = log;
                step = "ini";
                th = new Thread(calc);
                th.Start();
            }

            public void cancel()
            {
                lock (_lock)
                    _cancel = true;
            }

            public bool End { get { return end; } }
            public bool Cancel { get { return _cancel; } }
            private bool toClear;

            private void calc()
            {
                step = "calc";
                try
                {
                    if (string.IsNullOrEmpty(filter) && !filterNext)
                    {
                        toClear = true;
                        apply();
                        return;
                    }
                    toClear = false;

                    filter = filter.Trim().ToLower().removeAccent();
                    //if (string.IsNullOrWhiteSpace(filter) && !filterNext && conf.includeVirtual && conf.includeVirtualArtist)
                    //{
                    //    clear(); 
                    //    return;
                    //}

                    var tab = filter.Split(' ');

                    int nb = 0;
                    int nbOk = 0;

                    foreach (TrackListViewModel vitem in coll.SourceCollection)
                    {
                        if (_cancel)
                            return;

                        if (filterNext && !vitem.PieceGen.IsNext)
                            continue;
                        if (conf.onlyMaster && vitem.Piece.Parent != null)
                            continue;
                        if (!filterNext)
                        {
                            if (vitem.PieceGen.Virtual && !conf.includeVirtual)
                                continue;
                            if (vitem.PieceGen.VirtualByArtist && !conf.includeVirtualArtist)
                                continue;
                        }



                        bool ok = true;

                        if (conf.onlyId)
                        {
                            ok = filter == vitem.PieceId.ToString();
                        }
                        else
                        {

                            var name = vitem.Name.Trim().ToLower().removeAccent();
                            var artist = vitem.Artist.Trim().ToLower().removeAccent();
                            var album = vitem.Album.Trim().ToLower().removeAccent();
                            var masterAlbum = vitem.MasterAlbum.Trim().ToLower().removeAccent();
                            var classement = vitem.Classement;
                            List<string> paths = null;
                            foreach (string str in tab)
                            {
                                if (ok)
                                {
                                    if (string.IsNullOrEmpty(str))
                                        continue;
                                    var str_ = str.Trim();
                                    if (str_ == string.Empty)
                                        continue;

                                    ok = name.Contains(str_)
                                        || artist.Contains(str_)
                                        || album.Contains(str_)
                                        || masterAlbum.Contains(str_)
                                        || classement.StartsWith(str_)
                                        || (conf.includeId && str == vitem.PieceId.ToString())
                                        ;

                                    if (!ok)
                                    {
                                        if (paths == null)
                                        {
                                            paths = new List<string>();
                                            foreach (var f in vitem.Piece.Files)
                                            {
                                                paths.Add(f.File.ToLower().removeAccent());
                                            }
                                        }

                                        foreach (string path in paths)
                                        {
                                            if (path.Contains(str))
                                            {
                                                ok = true;
                                                break; 
                                            }
                                        }
                                    }

                                }
                                else
                                    break;

                            }
                        }


                        nb++;
                        if (ok)
                        {
                            if (conf.family)
                            {
                                foreach (Piece p in vitem.PieceGen.Master)
                                {
                                    if (!filterNext)
                                    {
                                        if (p.Virtual && !conf.includeVirtual)
                                            continue;
                                        if (p.VirtualByArtist && !conf.includeVirtualArtist)
                                            continue;
                                    }
                                    l.Add(p.PieceId);
                                }
                            }
                            else
                                l.Add(vitem.PieceId);

                            nbOk++;
                        }
                    }

                    log.log(string.Format("{0}/{1}", nbOk, nb));
                    // log.log(string.Format("calc:{0} item{1} {2} sélectionné{3}", nb, (nb > 1 ? "s" : ""), nbOk, (nbOk > 1 ? "s" : "")));   

                    lock (_lock)
                    {
                        if (_cancel)
                            return;
                    }


                    apply();


                }
                finally
                {
                    if (_cancel)
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par cancel");
                    }
                }





            }




            public void apply()
            {
                step = "apply";

                bool __cancel = _cancel;

                if (!__cancel)
                {
                    lock (_lock)
                        __cancel = _cancel;
                }


                if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
                {

                    if (__cancel)
                        return;
                    step = "applyAppDispatcher";
                    try
                    {
                        if (toClear)
                        {
                            log.log("clear filter");
                            coll.Filter = null;
                            log.log("fin clear filter");
                            return;
                        }

                        if (work == null)
                        {
                            log.log("creation du tempo");
                            work = coll.DeferRefresh();
                        }
                        else
                        {
                            log.log("tempo déjà créé ");

                        }


                        coll.Filter = item =>
                        {
                            if (_cancel)
                                return false;

                            var t = item as TrackListViewModel;
                            if (t == null)
                                return false;
                            if (!l.Contains(t.PieceId))
                                return false;
                            return true;
                        };




                        if (!__cancel)
                        {
                            log.log("application");
                            work.Dispose();
                            work = null;
                            log.log("fin application");
                        }
                        else
                        {
                            log.log("abandon application");
                        }
                    }
                    finally
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par application");
                        PlayerViewModel.Instance.makeResume();
                        PlayerViewModel.Instance.focusHelp();
                    }
                }
                else
                {
                    App.Current.Dispatcher.BeginInvoke(new Action(apply), App.DISPATCHER_PRIORITY);
                }
            }

            public override string ToString()
            {
                return string.Format("en cours:{0} step:{1} end:{2} cancel:{3}", filter0, step, End, Cancel);
            }

        }


        public static void doFilter(ICollectionView coll, string filter)
        {
            SimpleChrono log = new SimpleChrono(string.Format("\tfilter=>{0}\t", filter), App.log);

            log.log("");
            lock (_lock)
            {
                bool _cancelCurrent = false;
                bool _same = false;

                if (filterTask != null)
                {
                    log.log(filterTask.ToString());
                }

                _cancelCurrent = filterTask != null && !filterTask.End;
                _same = _cancelCurrent && filterTask.filter0.Equals(filter) && filterTask.filterNext == Instance.FilterNext;
                if (_same)
                {
                    log.log("identique");
                    return;
                }
                else if (_cancelCurrent)
                {
                    log.log("abandon tâche en cours");
                    filterTask.cancel();
                }

                else
                {
                    log.log("verrou libre");
                }

                filterTask = new FilterTask(filter, Instance.filterOnlyNext, coll, log);

            }





        }



        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}


        public void doFilter(String filter)
        {
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);

        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
            {
                string newResume = resume;
                try
                {

                    IEnumerable items = null;
                    var provider = DisplayProvider;
                    if (provider == null)
                        return;
                    var tracks = provider.PresentationTracks;
                    int nbOrg = -1;
                    items = tracks;
                    if (items == null)
                        return;

                    var selected = provider.SelectedTracks;
                    if (selected.Count > 1)
                    {
                        items = selected;
                        nbOrg = 0;
                        foreach (TrackListViewModel t in tracks)
                            nbOrg++;
                    }
                    int nb = 0, nbSelected = 0, nbPresent = 0;
                    TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationPresent = new TimeSpan();
                    HashSet<int> h = new HashSet<int>();

                    foreach (TrackListViewModel track in items)
                    {
                        if (!h.Add(track.PieceGen.MasterId))
                            continue;
                        nb++;
                        duration += track.Duration;
                        if (track.Enabled)
                        {
                            nbSelected++;
                            durationSelected += track.Duration;
                        }
                        if (track.Exists)
                        {
                            nbPresent++;
                            durationPresent += track.Duration;
                        }
                    }

                    ITextWriter sb = new pdb.util.StringBuilder();
                    sb.Append(nb);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    if (nbOrg >= 0)
                    {
                        sb.Append(" sur ");
                        sb.Append(nbOrg);
                        sb.Append(",");
                    }
                    sb.Append(" ");
                    humanDuration(sb, duration);
                    sb.Append(" ( ");
                    sb.Append(nbSelected);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nbSelected > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationSelected);

                    sb.Append(" )");

                    if (nbPresent > 0)
                    {
                        sb.Append(" presents: ");
                        sb.Append(nbPresent);
                        sb.Append(" ");
                        sb.Append("elt");
                        if (nb > 1)
                            sb.Append("s");
                        sb.Append(" ");
                        humanDuration(sb, durationPresent);
                    }
                    sb.Append("\t");

                    var currentTrack = TrackListViewModel.HumanSelected;
                    if (currentTrack != null)
                    {
                        humanSize(sb, currentTrack.Size);
                        sb.Append(" ");
                        sb.Append(currentTrack.getLocation());
                    }

                    newResume = sb.ToString();

                }
                catch (Exception e0)
                {
                    App.log.log(e0.ToString());
                }
                finally
                {
                    if (newResume != resume)
                    {
                        resume = newResume;
                        if (resumeChange != null)
                        {
                            try
                            {
                                resumeChange(this, EventArgs.Empty);
                            }
                            catch (Exception ex)
                            {
                                App.log.log(ex.ToString());
                            }
                        }
                    }
                }
            }
            else
            {
                App.Current.Dispatcher.BeginInvoke(new Action(makeResume), App.DISPATCHER_PRIORITY);
            }

        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append(size.HumanReadableSize(-1));
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append("j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append("m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append("m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append("s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Threading;
using pdb.db.obj;
using pdb.gen;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.albums;
using System.Linq;


namespace pdb.player.ViewModel
{
    public class PlayListViewModel : BibViewModelBase, INotifyCollectionChanged, IEnumerable<PlayListViewModel>
    {
        protected Logger log;
        private object _lock = new object();
        private CPlayList pl;
        private List<BibViewModelBase> _childs = new List<BibViewModelBase>();
        protected List<PlayListViewModel> _playlists = new List<PlayListViewModel>();
        //  private List<PlayListViewModel> __playlists = new List<PlayListViewModel>(); 
        private List<TrackListViewModel> _tracks = new List<TrackListViewModel>();

        private static List<IRedraw> gui = new List<IRedraw>();
        internal static void addDrow(IRedraw _gui) { gui.Add(_gui); }
        private static bool _log;
        public static bool Log { set { _log = value; } }

        #region export
        private List<TrackListViewModel> exportTracks = new List<TrackListViewModel>();
        public List<TrackListViewModel> ExportTracks { get { return exportTracks; } set { exportTracks = value; } }
        #endregion

        private static void redraw()
        {
            // foreach (IRedraw _gui in gui)  _gui.redraw();
        }

        #region optim recherche
        private static BgDictString<PlayListViewModel> dictPl = new BgDictString<PlayListViewModel>();
        private static BgDictString<TrackListViewModel> dictT = new BgDictString<TrackListViewModel>();
        protected static void recordPl(PlayListViewModel pl)
        {
            dictPl.Add(pl.pl.getPath(), pl);
        }

        protected static string getKey(PlayListViewModel pl, int id)
        {
            return pl.pl.getPath() + "|" + id;
        }


        protected static void recordTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            dictT.Add(getKey(pl, t.PieceId), t);
        }

        public static bool containsTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            return dictT.ContainsKey(getKey(pl, t.PieceId));
        }

        protected static void removeTrack(TrackListViewModel t, PlayListViewModel pl)
        {
            dictT.Remove(getKey(pl, t.PieceId));
        }

        public static TrackListViewModel findTrack(PlayListViewModel pl, int id)
        {
            var key = getKey(pl, id);
            if (dictT.ContainsKey(key))
                return dictT[key];
            return null;
        }

        public TrackListViewModel FindTrack(int id)
        {
            return findTrack(this, id);
        }

        public static void resetExport(exportState state)
        {
            misc.log("resetExport {0}", state);
            try
            {
                foreach (var t in dictT.Values)
                    t.ExportStatus = state;
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }

        public static void setExport(int id, exportState state)
        {
            if (_selectedPl != null)
            {

                try
                {
                    var t = findTrack(_selectedPl, id);
                    if (t != null)
                    {
                        t.ExportStatus = state;
                    }

                    //foreach (TrackListViewModel t in _selectedPl._tracks)
                    //{
                    //    if (t.PieceId == id)
                    //        t.refresh();
                    //}
                }
                //foreach (TrackListViewModel t in dictT.Values)
                //{
                //    if (t.PieceId == id)
                //        t.ExportStatus = state;
                //}

                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }


        }

        protected bool contains(PlayListViewModel pl, int id)
        {
            var key = getKey(pl, id);
            if (dictT.ContainsKey(key))
                return true;
            return false;
        }


        #endregion


        static PlayListViewModel()
        {
            //  App.refresh += new EventHandler(App_refresh);
        }

        static void App_refresh(object sender, EventArgs e)
        {
            //var pl = _selectedPl;
            //if (pl != null)
            //    pl.refresh(); 
        }

        public bool isSubList(string name)
        {
            return pl.isSubList(name);
        }

        public bool isSubList(PlayListViewModel pl)
        {
            return this.pl.isSubList(pl.PlayList);
        }

        private void init()
        {
            _childs.Clear();
            _playlists.Clear();
            _tracks.Clear();

            foreach (PlComponent component in pl)
            {

                if (component is CPlayList)
                {
                    var sublist = component as CPlayList;
                    var _pl = new PlayListViewModel(sublist, this);
                    _childs.Add(_pl);
                    _playlists.Add(_pl);
                    recordPl(_pl);
                    //_pl.PropertyChanged += new PropertyChangedEventHandler(_pl_PropertyChanged);
                    //_pl.CollectionChanged += new NotifyCollectionChangedEventHandler(_pl_CollectionChanged);
                    //              __playlists.Add(_pl); 
                }
                else
                {
                    var track = component as TrackList;
                    if (track.Virtual && !PlayerViewModel.Instance.WithVirtualAlbum)
                        continue;
                    var _t = new TrackListViewModel(track, this);
                    _childs.Add(_t);
                    _tracks.Add(_t);
                    recordTrack(_t, this);
                }
            }

            allTracks = new AllTracksViewModel(this, false, false);
        }


        public PlayListViewModel get(string name)
        {
            return get(name, false);
        }

        public PlayListViewModel get(string name, bool create)
        {
            foreach (var pl in _playlists)
                if (pl.Name == name)
                    return pl;
            if (!create)
                return null;
            var _pl = new CPlayList(name, this.pl);
            var _new = new PlayListViewModel(_pl, this);
            _playlists.Add(_new);
            _childs.Add(_new);
            recordPl(_new);
            //_new.PropertyChanged += _pl_PropertyChanged;
            //_new.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, _new));

            //  redraw(); 
            return _new;
        }


        private PlayListViewModel _getFromPath(string[] tab, int index)
        {
            for (; index < tab.GetLength(0); index++)
            {
                string dir = tab[index];
                if (string.IsNullOrEmpty(dir))
                    continue;
                if (dir.Equals(Name))
                    continue;
                var sub = get(dir, false);
                if (sub == null)
                    return null;
                return sub._getFromPath(tab, index + 1);
            }

            return this;

        }

        public PlayListViewModel getFromPath(string path)
        {
            var tab = path.Split(PlayListComposite.SEP);
            return _getFromPath(tab, 0);
        }

        public List<TrackListViewModel> Tracks { get { return _tracks; } }
        private AllTracksViewModel allTracks;
        public AllTracksViewModel AlltracksVm { get { return allTracks; } }

        //private AllTracksViewModel alltracksVmd;
        //public AllTracksViewModel AlltracksVmd
        //{
        //    get
        //    {
        //        if (alltracksVmd == null)
        //            alltracksVmd = new AllTracksViewModel(this, true, false);
        //        return alltracksVmd;

        //    }
        //}

        //private AllTracksViewModel alltracksFather;
        //public AllTracksViewModel AllTrackFather
        //{
        //    get
        //    {
        //        if (alltracksFather == null)
        //            alltracksFather = new AllTracksViewModel(this,null, true);
        //        return alltracksFather;
        //    }
        //}


        //private AllTracksViewModel alltracksFatherDisabled;
        //public AllTracksViewModel AllTrackFatherDisabled
        //{
        //    get
        //    {
        //        if (alltracksFatherDisabled == null)
        //            alltracksFatherDisabled = new AllTracksViewModel(this, true, true);
        //        return alltracksFatherDisabled;
        //    }
        //}

        public PlayListViewModel(CPlayList pl)
            : this(pl, null)
        {
        }

        private PlayListViewModel(CPlayList pl, PlayListViewModel parent)
            : base(pl, parent)
        {
            this.pl = pl;
            log = Logger.getLogger(pl.getPath());
            init();

        }
        public CPlayList PlayList { get { return pl; } }

        public string Name
        {
            get
            {
                return pl.Name;
            }
            set
            {
                if (value != Name)
                {
                    pl.Name = value;
                    OnPropertyChanged("Name");
                }
            }
        }

        #region selected

        /// <summary>
        /// element sélectionné. Répercuté jusqu'à la racine de l'arbre
        /// </summary>
        private static PlayListViewModel _selectedPl;
        public static PlayListViewModel SelectedPlayList
        {
            get
            {
                return _selectedPl;
            }
            private set
            {
                if (_selectedPl == value)
                    return;
                var _oldpl = _selectedPl;
                _selectedPl = value;
                if (_selectedPl != null)
                {
                    _selectedPl.IsSelected = true;
                    _selectedPl.IsExpanded = true;
                }
                OnSelectedPlayListChange(_oldpl);
            }
        }

        public static void initSelected(string strPl)
        {
            if (!string.IsNullOrEmpty(strPl))
            {
                var selected = App.bib.Root.getFromPath(strPl);

                if (selected != null)
                    PlayListViewModel.SelectedPlayList = selected;

            }
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                base.IsSelected = value;

                if (_isSelected)
                {
                    SelectedPlayList = this;
                }

            }
        }

        #endregion

        public static event EventHandler selectedPlaylistChange;
        private static void OnSelectedPlayListChange(PlayListViewModel oldPl)
        {
            if (selectedPlaylistChange != null)
                selectedPlaylistChange(oldPl, EventArgs.Empty);
        }


        #region INotifyCollectionChanged Members

        public event NotifyCollectionChangedEventHandler CollectionChanged;

        protected void OnCollectionChange(NotifyCollectionChangedEventArgs e)
        {
            // Be nice - use BlockReentrancy like MSDN said
            lock (_lock)
            {
                var eventHandler = CollectionChanged;
                if (eventHandler != null)
                {
                    Delegate[] delegates = eventHandler.GetInvocationList();
                    // Walk thru invocation list
                    foreach (NotifyCollectionChangedEventHandler handler in delegates)
                    {
                        try
                        {
                            var dispatcherObject = handler.Target as DispatcherObject;
                            // If the subscriber is a DispatcherObject and different thread
                            if (dispatcherObject != null && dispatcherObject.CheckAccess() == false)
                            // Invoke handler in the target dispatcher's thread
                            {
                                var ope =
                                dispatcherObject.Dispatcher.BeginInvoke(App.DISPATCHER_PRIORITY,
                                                   handler, this, e);
                                ope.Completed += ope_Completed;
                            }
                            else // Execute handler as is
                                handler(this, e);
                        }
                        catch (Exception ex)
                        {
                            App.log.log(ex.ToString());
                        }
                    }
                }
            }

            //var dispatcher = Dispatcher.CurrentDispatcher;
            //if (dispatcher.CheckAccess())
            //{
            //    if (this.CollectionChanged == null)
            //    {
            //        int toto = 0;
            //    }
            //    else
            //        this.CollectionChanged(this, e);               
            //}
            //else
            //    dispatcher.Invoke(new Action<NotifyCollectionChangedEventArgs>(OnCollectionChange), e); 

        }

        void ope_Completed(object sender, EventArgs e)
        {
            App.log.log(string.Format("PlayListViewModel::OnCollectionChange {0} CollectionChanged completé", sender));
        }

        #endregion

        public PlayListViewModel getOrCreatePlayList(string name)
        {

            var found = _playlists.Find(pl => pl.Name == name);
            if (found == null)
            {
                found = AddPlayList(name);
            }

            return found;
        }

        public PlayListViewModel AddPlayList(string name)
        {
            var subModel = new CPlayList(name, pl);
            var sub = new PlayListViewModel(subModel, this);
            _childs.Add(sub);
            _playlists.Add(sub);
            recordPl(sub);
            //   __playlists.Add(sub);
            //sub.PropertyChanged += _pl_PropertyChanged;
            //sub.CollectionChanged += _pl_CollectionChanged; 
            OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, sub));
            // PLayLists.Add(sub); 
            // redraw(); 
            return sub;
        }

        public TrackListViewModel AddTrack(IFile file, bool signal)
        {
            // var piece = App.Db.getPiece(location);
            return AddTrack(file as Piece, signal);

        }

        public TrackListViewModel AddTrack(Piece piece, bool signal)
        {
            if (_log) log.log("{0} AddTrack {1}", pl.getPath(), piece.ToString());
            if (contains(this, piece.PieceId))
            {
                App.Instance.InfoIHm(string.Format("le morceau {0} est déjà présent dans la liste {1}", piece, this), "Ajout dans la playlist");
                return null;
            }
            var tl = new TrackList(piece);
            pl.add(tl);
            var p = piece.Track;
            CPiece cPiece = null;
            if (p is CPiece)
                cPiece = p as CPiece;

            else if (p is TrackListViewModel)
            {
                var pp = ((TrackListViewModel)p).Piece;
                cPiece = pp as CPiece;
            }


            //if (cPiece != null)
            //    pl.addPiece(cPiece);
            var vm = new TrackListViewModel(tl, this);
            _childs.Add(vm);
            _tracks.Add(vm);
            recordTrack(vm, this);
            //  vm.PropertyChanged += _pl_PropertyChanged;
            if (signal)
            {
                //OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, vm));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }

            return vm;
        }

        public void RemoveTrack(TrackListViewModel tl, bool signal)
        {
            if (_log) log.log("{0} RemoveTrack {1}", pl.getPath(), tl.Track.Piece);
            _childs.Remove(tl);
            _tracks.Remove(tl);
            removeTrack(tl, this);


            tl.remove();
            //TODO faire la suppression de l'item de liste org

            if (signal)
            {
                // OnCollectionChange(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, tl));
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                redraw();
            }
        }

        private void insert(TrackListViewModel k, List<IFile> newElements)
        {
            int indexInsert = k.Index - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k);
        }

        private void insert2(TrackListViewModel k, List<Piece> newElements)
        {
            int indexInsert = k.Index2 - 1;
            if (indexInsert < 0)
                indexInsert = 0;
            if (indexInsert > newElements.Count)
                indexInsert = newElements.Count;
            newElements.Insert(indexInsert, k.PieceGen);
        }

        public void mergeList(ICollection<IFile> newElements_, IAbortTask writer)
        {
            lock (Consolid.Lock)
            {
                lock (Albums.Lock)
                {
                    var tt = TrackListViewModel.HumanSelected;
                    if (tt != null)
                    {
                        tt.refresh();
                        //var g = tt.Grouping; 
                        // tt.Grouping = tt.PieceGen.RankAlbumReverse.ToString();
                    }

                    // bool isMe = PlayListViewModel.SelectedPlayList == this;
                    bool isAlbum = this.isSubList("album");
                    bool isGen = this.isSubList("gen");

                    var confalbum = App.gen.SortAlbumMode;
                    int stackBefore = 4;
                    if (confalbum != null && confalbum.stackBefore > 0)
                        stackBefore = confalbum.stackBefore;

                   // bool checkStack = (PlayListViewModel.SelectedPlayList == null || PlayListViewModel.SelectedPlayList == this) && isGen && !isAlbum && confalbum.stackEnabled;

                    int _indexAlbumRead = -1;
                    int _indexTrackRead = -1;
                    Album _currentAlbum = null;
                    TrackListViewModel current = TrackListViewModel.CurrentPlaying;
                    Album currentAlbum = null;
                    if (current != null)
                        currentAlbum = current.album;
                    var conf = CConf.ConfGen;
                    List<TrackListViewModel> toDelete = new List<TrackListViewModel>();
                    List<TrackListViewModel> toKeep = new List<TrackListViewModel>();

                    var newElements = new HashList<IFile>(newElements_);


                    BgDict<int, bool?> newElt = new BgDict<int, bool?>();
                    foreach (IFile elt in newElements_)
                    {
                        newElt[elt.PieceId] = false;
                    }

                    int indexAlbumOrg = -1;
                    int indexTrackOrg = -1;

                    int indexAlbumOrg2 = -1;
                    int indexTrackOrg2 = -1;
                    var tracks = _tracks;
                    //if (isMe)
                    //{
                    tracks = new List<TrackListViewModel>(_tracks);
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
                    // }

                    foreach (TrackListViewModel tl in tracks)
                    {
                        if (tl.album != _currentAlbum)
                        {
                            _currentAlbum = tl.album;
                            _indexAlbumRead++;
                            _indexTrackRead = 0;
                        }
                        else
                            _indexTrackRead++;
                        var found = newElt[tl.PieceId] != null;
                        bool keep = false;
                        //if (isMe)
                        //{
                        if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                        {
                            keep = true;
                        }
                        else if (current != null && current.PieceId == tl.PieceId)
                        {
                            keep = true;
                            indexAlbumOrg = _indexAlbumRead;
                            indexTrackOrg = _indexTrackRead;
                        }
                        //}

                        newElt[tl.PieceId] = keep;


                        //if (current != null && !keep && tl.Location == current.Location)
                        //{
                        //    App.log.log("bizarre");
                        //}
                        if (!found)
                        {
                            if (keep)
                                toKeep.Add(tl);
                            else
                                toDelete.Add(tl);
                        }
                    }

                    //if (checkStack)
                    //{
                        _indexAlbumRead = -1;
                        _indexTrackRead = -1;
                        tracks.Sort((x, y) => x.Index2.CompareTo(y.Index2));
                        // }

                        foreach (TrackListViewModel tl in tracks)
                        {
                            if (tl.album != _currentAlbum)
                            {
                                _currentAlbum = tl.album;
                                _indexAlbumRead++;
                                _indexTrackRead = 0;
                            }
                            else
                                _indexTrackRead++;
                            var found = newElt[tl.PieceId] != null;


                            if (isAlbum && currentAlbum == tl.album) // Equals(tl.Album))
                            {

                            }
                            else if (current != null && current.PieceId == tl.PieceId)
                            {

                                indexAlbumOrg2 = _indexAlbumRead;
                                indexTrackOrg2 = _indexTrackRead;
                            }

                        }
                  //  }



                    //Addition
                    List<IFile> toAdd = new List<IFile>();
                    foreach (IFile elt in newElements)
                    {
                        if (writer.Aborted)
                            return;

                        bool found = contains(this, elt.PieceId);


                        if (!found)
                            toAdd.Add(elt);

                    }
                    //  log.log("mergeList::fin determination toAdd");

                    if (toAdd.Count > 0 && _log)
                        log.log("{0} {1} elt to add", this, toAdd.Count);

                    if (tracks.Count > 0 && toAdd.Count > 100)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt to add c'est trop!", this, toAdd.Count);
                        try { toAdd.RemoveRange(100, toAdd.Count - 100); }
                        catch { toAdd.Clear(); }
                        
                        //return;
                        //var l = new List<IFile>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toAdd[i]);
                        //toAdd = l;
                    }

                    if (tracks.Count > 0 && toDelete.Count > 0 && _log)
                        log.log("{0} {1} elt to delete", this, toDelete.Count);

                    if (toDelete.Count > 100)
                    {
                        log.log("!!!!!!!!!!!!!!!{0} {1} elt toDelete c'est trop!", this, toDelete.Count);

                        try { toDelete.RemoveRange(100, toDelete.Count - 100); }
                        catch { toDelete.Clear(); }

                       // toDelete.Clear();
                        //var l = new List<TrackListViewModel>(100);
                        //for (int i = 0; i < 100; i++)
                        //    l.Add(toDelete[i]);
                        //toDelete = l;
                    }


                    int count = toAdd.Count;
                    for (int i = 0; i < count; i++)
                    {
                        if (writer.Aborted) return;

                        AddTrack(toAdd[i], false);
                    }

                    foreach (TrackListViewModel vm in toDelete)
                    {
                        if (writer.Aborted) return;
                        RemoveTrack(vm, false);
                    }


                    var newElements3 = newElements;

                    if (isGen)
                    {
                        HashSet<int> moved = new HashSet<int>();
                        HashSet<int> empeached = new HashSet<int>();
                        HashSet<int> unavailable = new HashSet<int>();
                        newElements3 = new HashList<IFile>();
                        // chercher le premier album non quarantaine
                        decimal min = int.MaxValue;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            var t = newElements[i] as Piece;
                            if (t.StackValue == 0 && t.PieceAlbum != null)
                            {
                                min = t.PieceAlbum.ClassementValueLight;
                                break;
                            }
                        }


                        int ifirst = 0;
                        bool b = false;
                        Album courant = null;
                        for (; ifirst < newElements.Count; ifirst++)
                        {
                            var t = newElements[ifirst] as Piece;
                            if (t.PieceAlbum == courant)
                                continue;
                            courant = t.PieceAlbum;

                            if (courant.Absent)
                            {
                                unavailable.Add(t.PieceAlbum.Next.MasterId);
                            }
                            else
                            {
                                if (courant.StackValue > 0 &&  courant.ClassementValueLightSt >= min) //  checkStack && courant.ClassementValueLightSt >= min)
                                {
                                    if (!b)
                                    {
                                        courant.Empeached1 = true;
                                        b = true;
                                    }

                                    moved.Add(t.PieceAlbum.Next.MasterId);
                                    empeached.Add(t.PieceAlbum.Next.MasterId);

                                    courant.Moved = true;
                                    courant.Empeached = true;

                                }
                                else break;
                            }


                        }

                        if (ifirst < newElements.Count) // && checkStack)
                        {
                            //  int i = 0;

                            //HashSet<Album> aux = new HashSet<Album>();
                            //foreach (Album album in empeached)
                            //{
                            //    aux.Add(album); 
                            //}
                            //for (; i < newElements.Count; i++)
                            //{
                            //    var t = newElements[i] as Piece;
                            //    var a = t.PieceAlbum;
                            //    if (a == null)
                            //        continue;
                            //    if (aux.Add(a))
                            //    {
                            //        a.empeachedDecrement(); 
                            //    }
                            //}
                            HashSet<Album> albs = new HashSet<Album>();
                            //Album alb = null;
                            //Album alb2 = null;
                            //Album alb3 = null;
                            //Album alb4 = null;

                            courant = null;
                            int i = ifirst;
                            while (true)
                            {
                                if (i >= newElements.Count)
                                    break;
                                var t = newElements[i] as Piece;
                                if (t.StackValue > 0 && t.ClassementValueLightSt >= min)
                                {
                                    moved.Add(t.PieceAlbum.Next.MasterId);
                                    t.Moved = true;
                                    if (t.isEmpeached())
                                    {
                                        empeached.Add(t.PieceAlbum.Next.MasterId);
                                    }

                                }
                                else if (t.AlbumAbsent)
                                { }// moved.Add(t.Album); 
                                else
                                {
                                    var _alb = t.PieceAlbum;
                                    if (courant != _alb)
                                    {
                                        courant = _alb;

                                        if (!albs.Contains(courant))
                                        {
                                            if (albs.Count < stackBefore)
                                            {
                                                albs.Add(courant);
                                            }
                                            else
                                                break;
                                        }




                                        //if (alb == null)
                                        //    alb = courant;
                                        //else if (alb2 == null)
                                        //    alb2 = courant;
                                        //else if (alb3 == null)
                                        //    alb3 = courant;
                                        //else if (alb4 == null)
                                        //    alb4 = courant;
                                        //else
                                        //    break;
                                    }

                                    newElements3.Add(t);
                                }
                                i++;
                            }

                            for (i = 0; i < newElements.Count; i++)
                            {
                                var t = newElements[i] as Piece;
                                var alb_ = t.PieceAlbum;
                                if (alb_ == null)
                                    continue;

                                if (!albs.Contains(alb_))
                                    newElements3.Add(t);
                                //if (alb_ != alb && alb_ != alb2 && alb_ != alb3 && alb_ != alb4)
                                //    newElements3.Add(t);
                            }
                        }
                        else
                            newElements3 = newElements;

                        allTracks.setNbAlbum(unavailable.Count, empeached.Count, moved.Count);



                    }
                    else
                    {
                        allTracks.setNbAlbum(-1, -1, -1);
                    }




                    var newElements2 = new List<IFile>(newElements3);
                    List<Piece> stackSorted = null;
                    //if (checkStack)
                    //{
                        stackSorted = new List<Piece>();
                        foreach (IFile iFile in newElements2)
                        {
                            var t = findTrack(this, iFile.PieceId);
                            if (t != null)
                            {
                                stackSorted.Add(t.PieceGen);
                            }
                        }

                        stackSorted.Sort(new PieceStackCmp());

                    //}
                    foreach (IFile iFile in newElements3)
                    {
                        var keep = newElt[iFile.PieceId];
                        var t = findTrack(this, iFile.PieceId);
                        if (t != null)
                        {
                            if (true == keep)
                            {
                                int index0 = t.Index - 1;
                                int index1 = newElements2.IndexOf(iFile);
                                if (index1 > index0)
                                {
                                    newElements2.Remove(iFile);
                                    insert(t, newElements2);
                                }

                                //if (checkStack)
                                //{
                                    int index20 = t.Index2 - 1;
                                    int index21 = stackSorted.IndexOf(t.PieceGen);
                                    if (index21 > index20)
                                    {
                                        stackSorted.Remove(t.PieceGen);
                                        insert2(t, stackSorted);
                                    }
                               // }
                            }

                        }
                    }

                    foreach (TrackListViewModel k in toKeep)
                    {
                        insert(k, newElements2);
                    }

                    //if (checkStack)
                    //{
                        foreach (TrackListViewModel k in toKeep)
                        {
                            insert2(k, stackSorted);
                        }
                   // }

                    if (indexAlbumOrg >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;

                        bool dontTouch = false;

                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            var ifile = newElements2[i] as Piece;
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = newElements2.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {

                                newElements2.Remove(currentFile);
                                newElements2.Insert(newIndex, currentFile);
                            }
                        }
                    }



                    if (indexAlbumOrg2 >= 0)
                    {
                        _indexAlbumRead = -1;
                        _currentAlbum = null;
                        int newIndex = 0;

                        bool dontTouch = false;

                        for (int i = 0; i < stackSorted.Count; i++)
                        {
                            var ifile = stackSorted[i];
                            if (ifile == null)
                            {
                                dontTouch = true;
                                break;
                            }
                            if (ifile.PieceAlbum != _currentAlbum)
                            {
                                _indexAlbumRead++;
                                _currentAlbum = ifile.PieceAlbum;
                            }
                            if (_currentAlbum == currentAlbum)
                            {
                                dontTouch = true;
                                break;
                            }

                            if (_indexAlbumRead == indexAlbumOrg2)
                            {
                                newIndex = i;
                                break;
                            }
                        }


                        if (!dontTouch)
                        {
                            var currentFile = stackSorted.Find(p => p.PieceId == current.PieceId);
                            if (currentFile != null)
                            {
                                stackSorted.Remove(currentFile);
                                stackSorted.Insert(newIndex, currentFile);
                            }
                        }

                    }




                    int index = 1;
                    for (int i = 0; i < newElements3.Count; i++)
                    {
                        var ifile = newElements2[i];
                        var t = findTrack(this, ifile.PieceId);
                        if (t == null)
                        {
                            App.log.log("file ID {0} non trouvé dans {1} {2}", ifile.PieceId, this, ifile.Location);

                        }
                        else
                        {
                            //var keep = newElt[ifile.PieceId];
                            //if (true != keep)
                            t.Index = index;
                            // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                            if (i == 0)
                            {
                                t.refresh();
                                // var g = t.Grouping; 
                            }
                        }
                        index++;
                    }

                    //if (checkStack)
                    //{
                        index = 1;
                        for (int i = 0; i < stackSorted.Count; i++)
                        {
                            var t = findTrack(this, stackSorted[i].PieceId);
                            if (t == null)
                                continue;

                            //var keep = newElt[ifile.PieceId];
                            //if (true != keep)
                            t.Index2 = index;
                            // t.Grouping = t.PieceGen.RankAlbumReverse.ToString(); 
                            if (i == 0)
                            {
                                t.refresh();
                                // var g = t.Grouping; 
                            }

                            index++;
                        }
                   // }

                    if (current != null && current.Index > 1)
                    {
                        App.log.log("le courant a l'index {0} {1}", current.Index, current);

                        int index1 = -1;
                        for (int i = 0; i < newElements.Count; i++)
                        {
                            if (newElements[i].PieceId == current.PieceId) { index1 = i; break; }
                        }

                        int index2 = -1;
                        for (int i = 0; i < newElements2.Count; i++)
                        {
                            if (newElements2[i].PieceId == current.PieceId) { index2 = i; break; }
                        }

                        int index3 = -1;
                        for (int i = 0; i < newElements3.Count; i++)
                        {
                            if (newElements3[i].PieceId == current.PieceId) { index3 = i; break; }
                        }
                        App.log.log("indexes {0} {1} {2}", index1, index2, index3);

                    }



                }

                //if (toAdd.Count > 0 || toDelete.Count > 0)
                //{
                AlltracksVm.refresh();
                //if (alltracksVmd != null)
                //    alltracksVmd.refresh();
                //if (alltracksFather != null)
                //    alltracksFather.refresh();
                //if (alltracksFatherDisabled != null)
                //    alltracksFatherDisabled.refresh();

                //}
            }
        }

        private class StackCmp : IComparer<TrackListViewModel>
        {
            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                int cmp = x.ClassementValueLightSt.CompareTo(y.ClassementValueLightSt);
                //if (x.StackValue > 0 && y.StackValue > 0)
                //    cmp = 
                //else
                //    cmp = x.Index.CompareTo(y.Index);
                if (cmp != 0)
                    return cmp;
                return x.Index.CompareTo(y.Index);
            }
        }

        public IEnumerator<PlayListViewModel> GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _playlists.GetEnumerator();
        }

        private SortDescriptionCollection sort;
        public SortDescriptionCollection Sort { get { return sort; } set { sort = value; } }

        public string getEmpreinte()
        {
            var sb = new StringBuilder();
            sb.Append(exportTracks.Count);
            sb.Append(" éléments:");
            long hash = 0;
            foreach (TrackListViewModel t in exportTracks)
            {
                hash += t.PieceId.GetHashCode();
            }
            sb.Append(hash);

            return sb.ToString();

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\TrackListViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Windows;
using pdb.obj;
using pdb.util;
using pdb.gen;
using pdb.db.obj;
using pdb.gen.albums;
using pdb.gen.medianne;

namespace pdb.player.ViewModel
{

    public class TrackListViewModel : BibViewModelBase, ITrackNativeDates
    {




        #region répercut
        //  private static BgDict<int, List<TrackListViewModel>> dictT = new BgDict<int, List<TrackListViewModel>>();
        #endregion
        private TrackList track;
        private PieceViewModel piece;
        private static TrackListViewModel currentPlaying;
        private static TrackListViewModel currentSelected;
        public TrackList Track { get { return track; } }
        public CPiece Piece { get { return piece.Piece; } }
        public Piece PieceGen { get { return track.Piece; } }
        public Piece Master { get { return PieceGen.Master; } }

        public void remove()
        {
            //var list = dictT[PieceId];
            //if (list == null)
            //    return;
            //list.Remove(this);
        }

        public void refresh()
        {
            // piece.eraseCommentGrouping();
            OnPropertyChanged("ExportStatus");
            OnPropertyChanged("TV");
            //OnPropertyChanged("Comment");
            //OnPropertyChanged("Grouping");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("ClassementVirtuel");
            OnPropertyChanged("MedianneStatus");
            OnPropertyChanged("");
        }

        public override bool IsSelected
        {
            get
            {
                return base.IsSelected;
            }
            set
            {
                if (value != base.IsSelected)
                {
                    base.IsSelected = value;
                    if (value)
                        CurrentSelected = this;
                    OnPropertyChanged("TV");
                }
            }
        }

        private int index;
        public int Index
        {
            get { return index; }
            set
            {
                if (value != index)
                {
                    index = value;
                    OnPropertyChanged("Index");
                }
            }
        }

        private int index2;
        public int Index2
        {
            get { return index2; }
            set
            {
                if (value != index2)
                {
                    index2 = value;
                    OnPropertyChanged("Index2");
                }
            }
        }

        public int StackValue { get { return PieceGen.StackValue; } }
        public int StackIndex { get { return PieceGen.StackIndex; } }

        public bool Empeached { get { return PieceGen.isEmpeached(); } set { PieceGen.Empeached = value; } }
        public int EmpeachedNb { get { return PieceGen.EmpeachedNb; } }

        public static event EventHandler CurrentSelectedChanged;
        public static TrackListViewModel CurrentSelected
        {
            get
            {
                return currentSelected;
            }
            set
            {
                if (value != currentSelected)
                {
                    currentSelected = value;
                    if (CurrentSelectedChanged != null)
                        CurrentSelectedChanged("Track", EventArgs.Empty);
                }
            }
        }

        public static event EventHandler CurrentHumanSelectedChanged;
        private static TrackListViewModel humanSelected;
        private static int humanSelectedId;
        public static TrackListViewModel HumanSelected
        {
            get { return humanSelected; }
            //set
            //{
            //    if (value != humanSelected)
            //    {
            //        humanSelected = value;
            //        if (CurrentHumanSelectedChanged != null)
            //            CurrentHumanSelectedChanged("Human", EventArgs.Empty);
            //    }
            //}
        }

        private static bool setHumanSelectedUsed;
        private static volatile object _lock = new object();
        public static void setHumanSelected(PlayListViewModel pl, TrackListViewModel track)
        {
            lock (_lock)
            {
                if (setHumanSelectedUsed)
                    return;
            }

            try
            {
                lock (_lock)
                    setHumanSelectedUsed = true;
                //if (humanSelected != null)
                //{
                //    humanSelected.refresh();
                //   // var b = humanSelected.Grouping; 
                //}
                if (track != humanSelected)
                {
                    humanSelected = track;


                    //  humanSelected.refresh();
                    // var b = humanSelected.Grouping; 
                    int id = 0;
                    if (track != null) id = track.PieceId;
                    if (id != humanSelectedId)
                    {
                        humanSelectedId = id;
                        if (CurrentHumanSelectedChanged != null)
                            CurrentHumanSelectedChanged(pl, EventArgs.Empty);
                    }
                }
            }
            finally
            {
                lock (_lock)
                    setHumanSelectedUsed = false;
            }
        }

        public bool Enabled
        {
            get
            {
                return piece.Enabled;
            }
            set
            {
                piece.Enabled = value;
                //if (value != track.Enabled)
                //{
                //    track.Piece.Enabled = value;
                //    OnPropertyChanged("Enabled");
                //}
            }
        }
        //  private exportState exportState;
        //public int ExportState
        //{
        //    get
        //    {
        //        return (int)exportState;
        //    }
        //}

        public static EventHandler ExportStatusChange;
        private static void OnExportStatusChange(TrackListViewModel tv)
        {
            if (ExportStatusChange != null)
                ExportStatusChange(tv, EventArgs.Empty);
        }

        public static event EventHandler ClassementChange;
        private static void OnClassementChange(TrackListViewModel tv)
        {
            if (ClassementChange != null)
                ClassementChange(tv, EventArgs.Empty);
        }

        public TrackListViewModel TV { get { return this; } }

        public exportState ExportStatus
        {
            get
            {
                return Piece.ExportStatus; // exportState;
            }
            set
            {
                if (Piece.ExportStatus != value)
                {
                    Piece.ExportStatus = value;
                    OnPropertyChanged("ExportStatus");
                    OnPropertyChanged("TV");
                    OnPropertyChanged("Background");
                    OnExportStatusChange(this);
                    //refresh();


                }
            }
        }

        public int IndexExport
        {
            get { return PieceGen.IndexExport; }
        }

        public selectedCoeff SelectedMotif
        {
            get
            {
                if (PieceGen == null)
                    return selectedCoeff.none;
                return PieceGen.SelectedMotif;
            }
        }








        public TrackListViewModel(TrackList track, PlayListViewModel playlist)
            : base(track, playlist)
        {
            this.track = track;
            this.piece = PieceViewModel.getPiece(track); // new PieceViewModel(track); // track.Piece.Track as CPiece; 
            piece.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(piece_PropertyChanged);
            int id = track.PieceId;
            //if (!dictT.ContainsKey(id))
            //{
            //    var list = new List<TrackListViewModel>();
            //    dictT.Add(id, list);
            //}

            //dictT[id].Add(this);

        }

        void piece_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            OnPropertyChanged(e.PropertyName);
        }

        public String StrPlaying
        {
            get
            {
                if (playing) return "<))";
                return "";
            }
        }
        public string MedianneStatus
        {
            get
            {
                var p = PieceGen;
                if (p.Medianne)
                    return ">>";
                if (p.MedianneLight)
                    return ">";
                if (p.Border)
                    return "-";
                if (p.BorderMin)
                    return "-";
                if (p.BorderEffect)
                    return "--";

                return "";
            }
        }

        private bool playing;
        public bool Playing
        {
            get { return playing; }
            set
            {
                if (value != playing)
                {
                    playing = value;
                    if (playing)
                    {
                        CurrentPlaying = this;
                    }
                    OnPropertyChanged("Playing");
                    OnPropertyChanged("StrPlaying");
                }
            }
        }

        public static TrackListViewModel CurrentPlaying
        {
            get
            {
                return currentPlaying;
            }
            set
            {
                if (value != currentPlaying)
                {
                    if (currentPlaying != null)
                        currentPlaying.Playing = false;
                    currentPlaying = value;
                }
            }
        }

        public int Rating
        {
            get
            {
                return piece.Rating;
            }
            set
            {
                piece.Rating = value;
                //if (value != track.Rating)
                //{
                //    track.Rating = value;
                //    onPropertyChanged("Rating");
                //}
            }
        }

        //  private pdb.db.obj.CPiece CPiece { get { return track.Piece.Track as pdb.db.obj.CPiece; } }

        public string ClassementCompact
        {
            get { return PieceGen.ClassementCompact; }
        }

        //public static readonly DependencyProperty ClassementProperty =
        //DependencyProperty.Register("Classement", typeof(String),
        // typeof(PieceViewModel), new UIPropertyMetadata(null));
        public String Classement
        {
            get
            {
                return piece.Piece.StrClassement;
            }
            set
            {

                // piece.StrClassement = value;
                //if (value != piece.Piece.StrClassement)
                //{

                lock (Albums.LockSort)
                {
                    piece.Classement = value;
                    PieceGen.invalidateCache();
                    App.gen.Albums.signalClassChange(track);
                    try
                    {

                        PlayerViewModel.makeauto(this);
                        App.bib.setClassement(this, value);



                        // piece.Piece.StrClassement = value;

                    }
                    catch
                    {
                    }

                    OnClassementChange(this);
                    App.go(true);
                    // onPropertyChanged("Classement");


                    // }

                }
            }
        }

        public int Year
        {
            get
            {
                return piece.Year;
            }
            set
            {
                piece.Year = value;
                //if (value != piece.Year)
                //{
                //    track.Year = value;
                //    onPropertyChanged("Year");
                //}
            }
        }

        public DateTime Added { get { return piece.Added; } }

        public DateTime FirstAcces
        {
            get
            {
                return piece.FirstAcces;
            }
        }



        public DateTime AlbumAdded
        {
            get
            {
                return piece.AlbumAdded;
            }
        }

        public int RankAlbum { get { return PieceGen.RankAlbum; } }
        public int RankAlbumZero { get { return PieceGen.RankAlbumZero; } }
        public int RankAlbumReverse { get { return PieceGen.RankAlbumReverse; } }
        public int RankAllAlbum { get { return PieceGen.RankAllAlbum; } }
        public int RankAlbumSt { get { return PieceGen.RankAlbumSt; } }
        public int RankAlbumZeroSt { get { return PieceGen.RankAlbumZeroSt; } }


        public int Rank { get { return PieceGen.Rank.Twice; } }
        //public static readonly DependencyProperty CommentProperty =
        //DependencyProperty.Register("Comment", typeof(string),
        //typeof(PieceViewModel), new UIPropertyMetadata(null)); 
        //public string Comment
        //{
        //    get
        //    {
        //        if (PieceGen.Virtual)
        //            return "";
        //        return piece.Comment;
        //    }
        //    set
        //    {
        //        if (PieceGen.Virtual)
        //            return;
        //        //piece.Comment = value; 
        //        if (value != piece.Comment)
        //        {
        //            //  track.Comment = value;
        //            piece.Comment = value;
        //            OnPropertyChanged("Comment");

        //        }
        //    }
        //}

        //public string Grouping
        //{
        //    get { return track.Piece.Grouping; }
        //    set
        //    {
        //        //  piece.Grouping = value;
        //        if (value != track.Piece.Grouping)
        //        {
        //            track.Piece.setGrouping(value, true);
        //            // track.setGrouping(value, true);
        //            OnPropertyChanged("Grouping");
        //        }
        //    }
        //}




        public bool isPodcast
        {
            get { return piece.isPodcast; }
        }


        public TimeSpan Duration
        {
            get { return piece.Duration; }
            set
            {
                piece.Duration = value;
                //if (!Exists)
                //    return; 
                //if (value != Duration)
                //{
                //    var deltaMs = Math.Abs(value.TotalMilliseconds - Duration.TotalMilliseconds);
                //    if (deltaMs >= 1)
                //    {
                //        track.Duration = value;
                //        if (deltaMs >= 1000)
                //            onPropertyChanged("Duration");
                //    }
                //}
            }
        }

        public string File
        {
            get { return piece.Piece.Files.PathReduc; }
        }

        public string Location
        {
            get { return piece.Location; }
        }

        public string Artist
        {
            get
            {
                return piece.Artist;
            }
            set
            {
                piece.Artist = value;
                //if (value != track.Artist)
                //{
                //    track.Artist = value;
                //    onPropertyChanged("Artist");
                //}
            }
        }

        public string Album
        {
            get
            {
                if (track.Virtual)
                {
                    if (track.Piece.VirtualByArtist)
                        return string.Format("[{0}]", track.Album);
                    return track.Album;
                }
                return piece.Album;
            }
            set
            {
                if (!track.Virtual)
                    piece.Album = value;
                //if (value != track.Album)
                //{
                //    track.Album = value;
                //    onPropertyChanged("Album");
                //}
            }
        }

        public string MasterAlbum
        {
            get
            {
                //    if (track.Virtual)
                //        return " " + PieceGen.Master.Album;
                return PieceGen.Master.Album;
            }
            set
            {
                if (value == null)
                    return;
                value = value.Trim();
                if (value != PieceGen.Master.Album)
                {
                    PieceGen.Master.Album = value;
                    OnPropertyChanged("MasterAlbum");
                }
            }
        }

        public Album album { get { return PieceGen.PieceAlbum; } }

        public string Name
        {
            get
            {
                return piece.Name;
            }
            set
            {
                piece.Name = value;
                //if (value != track.Name)
                //{
                //    track.Piece.Name = value;
                //    onPropertyChanged("Name");
                //}
            }
        }

        public int TrackNumber
        {
            get
            {
                return track.Piece.TrackNumber;
            }
            set
            {
                if (!track.Virtual)
                    piece.TrackNumber = value;
                //if (value != track.TrackNumber)
                //{
                //    track.TrackNumber = value;
                //    onPropertyChanged("TrackNumber");
                //}
            }
        }


        public void setClassement(string className, int rating)
        {
            piece.Piece.setClassement(className, rating);
            PieceGen.invalidateCache();

        }

        public string ClassName
        {
            get
            {
                return piece.Piece.ClassName;
            }
            set
            {
                piece.Piece.ClassName = value;
            }
        }


        public DateTime PlayedDate
        {
            get { return piece.Piece.PlayedDate; }
        }

        public string ArtWork
        {
            get
            {
                return piece.Piece.ArtWork;
            }
            set
            {
                piece.Piece.ArtWork = value;
            }
        }

        //public void setGrouping(string value, bool prior)
        //{
        //    track.Piece.setGrouping(value, prior);
        //    piece.Grouping = value; // TODO je fait quoi de ça ???
        //    // onPropertyChanged("Grouping");
        //}

        public string ClassementVirtuel { get { return PieceGen.ClassementVirtuel; } }

        public decimal CoeffVirtuel { get { return PieceGen.CoeffVirtuel -1; } }

        public string ClassementVirtuel2 { get { return PieceGen.ClassementVirtuel2; } }

        public decimal CoeffVirtuel2 { get { return PieceGen.CoeffVirtuel2-1; } }

        public bool FirstClass
        {
            get
            {
                return true;
            }
            set
            {

            }
        }

        public List<CPlayList> ClassPlayLists
        {
            get { return piece.Piece.ClassPlayLists; }
        }

        public List<DateTime> Dates
        {
            get { return new List<DateTime>(piece.Piece.Dates); }
        }

        public List<DateTime> DatesClassement
        {
            get { return piece.Piece.DatesClassement; }
        }

        public string ClassEvol
        {
            get { return track.Piece.ClassEvol; }
        }

        public long Size { get { return Piece.Size; } }

        public bool Exists { get { return Piece.Exists; } }

        //public void onPropertyChanged(string propertyName)
        //{
        //    var list = dictT[PieceId];
        //    if (list == null)
        //    {
        //        OnPropertyChanged(propertyName);
        //    }
        //    else
        //    {
        //        foreach (TrackListViewModel t in dictT[PieceId])
        //            t.OnPropertyChanged(propertyName);
        //    }
        //}




        public int PieceId
        {
            get { return track.PieceId; }
        }
        public int MasterId { get { return PieceGen.MasterId; } }


        public int PieceParentId
        {
            get { return track.PieceParentId; }
            set { track.PieceParentId = value; }
        }

        public void setParent(TrackListViewModel parent)
        {
            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();

            piece.Piece.Parent = parent.Piece.Master;
            track.Piece.Parent = parent.track.Piece;

            track.Piece.albumMustRefresh();
            parent.track.Piece.albumMustRefresh();
        }

        public void fusion(TrackListViewModel toDelete)
        {
            App.Db.List.fusion(piece.Piece, toDelete.Piece);

        }





        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion


        public List<string> RelativesPath
        {
            get { return track.RelativesPath; }
        }

        public DateTime? UpdateClassement { get { return PieceGen.UpdateClassement; } }
        public DateTime? AlbumUpdateClassement { get { return PieceGen.AlbumUpdateClassement; } }

        public DateTime? LastRead { get { return PieceGen.LastRead; } }
        public DateTime? AlbumLastRead { get { return PieceGen.AlbumLastRead; } }

        public int NbClass { get { return PieceGen.NbClass; } }

        public List<DateTime> DatesClassementBrut
        {
            get
            {
                return track.DatesClassementBrut;
            }
        }


        public string getLocation()
        {
            return piece.getLocation();
        }

        public string EquivLight
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight;
            }
        }

        public string EquivLight0
        {
            get
            {
                if (album == null)
                    return "";
                return album.EquivLight0;
            }
        }

        public string EquivLightSt
        {
            get
            {

                if (album == null)
                    return "";
                return album.EquivLightSt;
            }
        }

        public decimal ClassementValueLightSt
        {
            get
            {
                if (album == null)
                    return 0;
                return album.ClassementValueLightSt;
            }
        }

        public int AlbumCount
        {
            get
            {
                if (album == null)
                    return 0;
                return album.Count;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\DataGridPlayList.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.DataGridPlayList"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             mc:Ignorable="d" 
             d:DesignHeight="300" d:DesignWidth="300" >
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0" x:Name="dg" x:Uid="main" ConfCouleur="main"
                            AutoGenerateColumns="False" IsSynchronizedWithCurrentItem="False"                   
                            SelectedItem="{Binding SelectedTrack, Mode=TwoWay}"               
                  >
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="{Binding Export.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding Export}" />
                    <MenuItem Header="{Binding ExportCompress.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding ExportCompress}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>


            <DataGrid.Columns>


                <DataGridTextColumn Binding="{Binding Index,Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}">
                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport0}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                            <Setter Property="Foreground" Value="Black" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>

                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>

                    </DataGridTemplateColumn.CellTemplate>


                </DataGridTemplateColumn>

                <!--<DataGridCheckBoxColumn Header="" Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->

                <DataGridCheckBoxColumn Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <DataGridTextColumn Header="Nom" Binding="{Binding Name}"/>
                <DataGridTextColumn Header="Piste"  Binding="{Binding TrackNumber,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Album" Binding="{Binding Album}"/>
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt" Binding="{Binding RankAlbumSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankSt0" Binding="{Binding RankAlbumZeroSt, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAlbumReverse" Binding="{Binding RankAlbumReverse, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="RankAllAlbum" Binding="{Binding RankAllAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <!--<DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>-->
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}">

                    <!--<DataGridTextColumn.ElementStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.ElementStyle>-->
                </DataGridTextColumn>
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                <DataGridTextColumn Header="StackValue" Binding="{Binding StackValue, Mode=OneWay}"  >
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell" >
                            <Setter Property="ToolTip" Value="{Binding NbAlbumMoved, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                        </Style>
                    </DataGridTextColumn.CellStyle>

                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />

                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Lecture"  Binding="{Binding LastRead, Mode=OneWay,Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Lecture Album"  Binding="{Binding AlbumLastRead, Mode=OneWay, Converter={StaticResource date}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>

                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />

                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="Ajouté"  Binding="{Binding Added, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="Ajouté (Album)"  Binding="{Binding AlbumAdded, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="1er accès"  Binding="{Binding FirstAcces, Mode=OneWay, Converter={StaticResource date}}" />
                <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLight0"  Binding="{Binding EquivLight0, Mode=OneWay}" />
                <DataGridTextColumn Header="EquivLightSt"  Binding="{Binding EquivLightSt, Mode=OneWay}" />
                <DataGridCheckBoxColumn Header="Empêché" Binding="{Binding Empeached, UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ClassementValueLightSt"  Binding="{Binding ClassementValueLightSt, Mode=OneWay}" />

                <DataGridTextColumn Header="is" Binding="{Binding Index2,Mode=OneWay}"/>
                <DataGridTextColumn Header="EmpêchéHisto"  Binding="{Binding EmpeachedNb, Mode=OneWay}" />

                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="File" Binding="{Binding File, Mode=OneWay}" />






            </DataGrid.Columns>

            <DataGrid.ItemContainerStyle>
                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseMove" Handler="dg_PreviewMouseMove" />


                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <!--<Setter Property="IsEnabled" Value="{Binding Exists}" />-->
                    <Setter Property="FontWeight" Value="Normal" />
                    <!--<Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}" />-->
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="Foreground" Value="Brown" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exists}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                     
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>
            <!--<DataGrid.RowStyle>
                <Style TargetType="{x:Type DataGridRow}">
                    <Setter Property="Background" Value="{Binding ExportStatus, Converter={StaticResource colorExport},  UpdateSourceTrigger=PropertyChanged}"/>
                </Style>
            </DataGrid.RowStyle>-->
            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=main, UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dg_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <!--<EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />-->
                    <Setter Property="BorderThickness" Value="0" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />

                </Style>
            </DataGrid.RowStyle>

        </l:EnhancedDataGrid>
        <ContentControl Name="Cctl" Grid.Row="1" >
            <DockPanel Grid.Row="1" Name="dp_status" >
                <!--<TextBlock DockPanel.Dock="Bottom" Text="{Binding NbAlbumMovedDesc}" />-->
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMovedUnavailable,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbEmpeached,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,4,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" Text="{Binding NbAlbumMoved,UpdateSourceTrigger=PropertyChanged}"  Margin="0,0,10,0" FontSize="11"/>
                <TextBlock DockPanel.Dock="Left" HorizontalAlignment="Left" Text="{Binding AutoResume,UpdateSourceTrigger=PropertyChanged}" FontWeight="DemiBold" FontSize="11" Margin="0,0,10,0"/>



                <TextBlock DockPanel.Dock="Bottom" FontSize="11" Text="{Binding Resume}" Background="{Binding TV, Converter={StaticResource colorExport00}, ConverterParameter=main,  UpdateSourceTrigger=PropertyChanged}" />
            </DockPanel>
        </ContentControl>
    </Grid>

</UserControl>
]]></content>
  </file>
  <file path="\pdb.player\Vue\Memento.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using System.Windows;
using pdb.gen.Tuning;
using System.Xml;
using pdb.util;

namespace pdb.player.Vue
{
    [Serializable]
    class Memento
    {
        [NonSerialized]
        const string FILE_CONF = "confAlbum.xml";
        [NonSerialized]
        const string PATH = TuningBase.DIR_CONF + "memento.dat";
        [NonSerialized]
        const string PATH_CONF = TuningBase.DIR_CONF + FILE_CONF;
        [NonSerialized]
        const string SOV_CONF = TuningBase.DIR_CONF + "sov\\";
        [NonSerialized]
        private static volatile Memento _instance;
        [NonSerialized]
        private FileRotator fileRotator;
        public WindowPos winPos = null;
        public CmpPos cmpPos = null;
        public string selectedPlaylist = "";
        public Dictionary<string, object> dict = new Dictionary<string, object>();
        [NonSerialized]
        public ConfAlbumSort confAlbum;


        private Memento()
        {
            fileRotator = new FileRotator();
        }
        public static Memento Instance
        {
            get
            {
                if (_instance == null)
                {

                    var formater = new BinaryFormatter();
                    try
                    {
                        using (Stream st = new FileStream(PATH, FileMode.Open))
                        {
                            _instance = (Memento)(formater.Deserialize(st));
                        }
                        var doc = new XmlDocument();
                        doc.Load(PATH_CONF);
                        var conf = new ConfAlbumSort(doc.DocumentElement);

                        _instance.confAlbum = conf;
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        if (Application.Current is App)
                            throw;
                    }


                }

                if (_instance == null)
                    _instance = new Memento();

                _instance.fileRotator = new FileRotator();
                return _instance;

            }
        }
        public void save()
        {
            var formater = new BinaryFormatter();
            using (Stream st = new FileStream(PATH, FileMode.Create))
            {
                formater.Serialize(st, this);
            }
            if (this.confAlbum != null)
            {
                fileRotator.save(PATH_CONF, SOV_CONF, 100);
                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.UTF8;
                using (XmlWriter writer = XmlWriter.Create(PATH_CONF, settings))
                {
                    this.confAlbum.save(writer);
                }
            }
        }
    }
    [Serializable]
    class WindowPos
    {
        public double Top;
        public double Left;
        public double Width;
        public double Height;
    }
    [Serializable]
    class CmpPos
    {
        public Length cdBib;
        public Length cdMain;
        public Length cdAlbum;
        public Length cdClassement;
    }

    [Serializable]
    public class Length
    {
        public double value;
        public GridUnitType unit;
        public Length(GridLength ihm)
        {
            value = ihm.Value;
            unit = ihm.GridUnitType;
        }
        public GridLength toGrid()
        {
            return new GridLength(value, unit);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\CLegacyListWriter.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.Tuning;
using pdb.gen.albums;
namespace pdb.gen
{

    public class CLegacyListWriter
    {
        private List<Piece> m_list = new List<Piece>();
        private List<Piece> m_listIni = null;
        private IEnumerable<Piece> m_enum;
        private int m_rotPeriod = -1;
        private static CPieceInListComparer c_comparer = new CPieceInListComparer();
        private bool m_bIni = false;
        private static DateTime now = DateTime.Now;
        private static Logger logger = Logger.getLogger("gen", true);
        public CLegacyListWriter(IList<Piece> a_pieceEnumerator)
        {
            m_enum = a_pieceEnumerator;
            //    this.sortByAlbum = sortByAlbum; 

            foreach (Piece l_piece in m_enum)
            {
                m_list.Add(l_piece);
            }
            m_listIni = new List<Piece>(m_list);

        }


        private ICollection<ListWriterMgr> writers = new List<ListWriterMgr>();
        public void addWriter(IListWriter writer) { writers.Add(new ListWriterMgr(writer)); }


        public void reset()
        {

            const int MIN_DURATION = 10 * 3600;
            m_list.Clear();
            m_listIni.Clear();
            foreach (Piece l_piece in m_enum)
            {
                m_list.Add(l_piece);
            }
            if (!m_bIni)
            {
                m_bIni = true;
                m_listIni = new List<Piece>(m_list);

            }
            double l_totalDuration = getDuration(1, null);
            while (l_totalDuration < MIN_DURATION && ListSelection.Scale > 0.01)
            {
                ListSelection.Scale *= 0.9;
                l_totalDuration = getDuration(1, null);
            }

            // If CConf.Sort.Quality.Mode = listMode.substract Then CPiece.Scale *= 0.1


        }
        public void writeRot(int a_base)
        {
            logger.log("write rot" + a_base);
            List<Piece> l_listPieceCLass = new List<Piece>();
            foreach (Piece l_piece in m_list)
            {
                if (l_piece.QRank > 0 && ListSelection.canPlay(l_piece, a_base))
                {
                    l_listPieceCLass.Add(l_piece);
                }
            }
            l_listPieceCLass.Sort(c_comparer);
            m_list = l_listPieceCLass;

            writePlayList("rot" + a_base, l_listPieceCLass, false, true);
        }

        //public bool SortByAlbum { set { sortByAlbum = value; } }
        //private bool sortByAlbum = true; 
        public void writeGen(ExtendToNative<datesMode> mode, ExtendToNative<double> nbHours, string baseName, bool onlyEvol, bool sortByAlbum)
        {
            try
            {
                var conf = CConf.ConfGen;
                logger.log("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol);
                bool withTimeOrder = mode.extendTimeOrder && nbHours.extendTimeOrder;

                var timeRestLimit = 0m;
                if (nbHours.level)
                {
                    CRank fictif = new CRank();
                    fictif.Quality = 1;
                    fictif.Lenght = 1;
                    fictif.Twice = 1;
                    DateTime dtFictif = DateTime.Now.AddDays(-nbHours.item);
                    List<DateTime> lfictif = new List<DateTime> { dtFictif };
                    timeRestLimit = CalcDate.getRest(lfictif, fictif);
                    logger.log("Limite {0} => {1} {2} ", nbHours.item, timeRestLimit, conf.Vie.TotalDays() * timeRestLimit);
                }

                List<Piece> l_listPieceCLass = new List<Piece>();
                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.QRank > 0)
                    {

                        if (!(string.IsNullOrEmpty(l_piece.ClassEvol) && onlyEvol))
                        {
                            if (l_piece.Enabled || !conf.OnlyEnabled)
                                l_listPieceCLass.Add(l_piece);
                        }

                    }
                }
                l_listPieceCLass.Sort(new PieceRestComparer());


                TimeSpan limit = TimeSpan.FromHours(nbHours.item);
                TimeSpan current = new TimeSpan();

                List<Piece> ret = new List<Piece>(l_listPieceCLass.Count);
                // string lastClassement = "";
                bool rejet = false;

                foreach (Piece piece in l_listPieceCLass)
                {
                    if (nbHours.level)
                    {
                        if (piece.Rank.TimeRest <= timeRestLimit)
                            ret.Add(piece);
                    }
                    else if (nbHours.item == 0)
                    {
                        if (piece.Rank.TimeRest == 0)
                            ret.Add(piece);
                    }
                    else
                    {
                        current += piece.Duration;
                        if (current > limit || rejet)
                        {
                            if (!rejet)
                                logger.log("writeGen rejet {0} {1} {2} {3} {4} {5} {6}", mode, nbHours, baseName, onlyEvol, piece.ClassNameAndRating, piece, piece.Rank.TimeRest);
                            rejet = true;
                            //if (piece.ClassNameAndRating.Equals(lastClassement))
                            //{
                            //    log.log("writeGen {0} {1} {2} {3} {4} récupéré par {5}", mode, nbHours, baseName, onlyEvol, piece, lastClassement);
                            //}
                            //else
                            break;
                        }
                        ret.Add(piece);
                        // log.log("writeGen {0} {1} {2} {3} {4} {5} {6}", mode, nbHours, baseName, onlyEvol, piece.ClassNameAndRating, piece, piece.Rank.TimeRest);
                        // rejet = false; 
                        // lastClassement = piece.ClassNameAndRating;
                    }
                }

                if (withTimeOrder)
                    ret.Sort(new PieceRestComparer());
                else
                {
                    if (sortByAlbum)
                        ret.Sort(new AllPieceComparer2());
                    else
                    {
                        ret.Sort(new CPieceComparerByQualityAndLength2());
                        ret.Reverse();
                    }
                    // extension des listes normales
                    if (CConf.ConfGen.Anticipation && !nbHours.level && nbHours.item != 0 && ret.Count > 0)
                    {
                        Piece first = ret[0];
                        var listlecture = new List<Piece>(l_listPieceCLass);
                        listlecture.Sort(new PieceSortComparerList());
                        listlecture.Reverse();
                        while (true)
                        {
                            // que se passe-t-il quand le premier élément de la liste est consommé (g1)
                            // si on refait le calcul

                            int indexLecture = listlecture.IndexOf(first);
                            if (indexLecture < 0)
                                break;
                            int indexPrecedentLecture = indexLecture - 1;
                            if (indexPrecedentLecture < 0)
                                break;
                            Piece precedentLecture = listlecture[indexPrecedentLecture];
                            if (ret.Contains(precedentLecture))
                                break;
                            // si le précedent dans l'ordre de la lecture est aussi le précédent dans l'ordre reste, on le conserve 

                            int indexRest = l_listPieceCLass.IndexOf(first);
                            if (indexRest < 0)
                                break;
                            int indexRestSuivant = indexRest + 1;
                            if (indexRestSuivant >= l_listPieceCLass.Count)
                                break;

                            Piece suivantRest = l_listPieceCLass[indexRestSuivant];
                            if (ret.Contains(suivantRest))
                                break;
                            if (suivantRest != precedentLecture)
                            {
                                int indexLecture2 = listlecture.IndexOf(suivantRest);
                                if (indexLecture2 > indexLecture)
                                    break;
                            }

                            ret.Add(precedentLecture);
                            first = precedentLecture;


                        }

                        if (withTimeOrder)
                            ret.Sort(new PieceRestComparer());
                        else
                        {
                            if (sortByAlbum)
                                ret.Sort(new AllPieceComparer2());
                            else
                            {
                                ret.Sort(new CPieceComparerByQualityAndLength2());
                                ret.Reverse();
                            }
                        }

                        //ret.Sort(new PieceSortComparerList());
                        //ret.Reverse();
                    }

                }
                // 

                var large = ret;

                if (conf.GenLarge)
                    large = getLarge(ret);
                //ret.Reverse();
                //large.Reverse();

                // var hash = new HashList<Piece>(ret); 

                bool extendToNative = mode.extend && nbHours.extend;
                bool withOrder = conf.WithOrder && (nbHours.item > 0 || conf.OrderZero);
                withOrder = withOrder || withTimeOrder;
                string strLevel = "";
                if (nbHours.level)
                    strLevel = "_";
                writePlayList(mode.ToString(), baseName + strLevel + nbHours, ret, withOrder, extendToNative);

                withOrder = withOrder && conf.OrderLarge;
                if (conf.GenLarge)
                    writePlayList(mode.ToString(), baseName + strLevel + nbHours + "+", large, withOrder, extendToNative);

                //var writeGrouping = CConf.ConfGen.WriteGrouping;
                //if (writeGrouping > writeGrouping.none && (nbHours.item > 0 || conf.WriteGroupingZero))
                //{
                //    foreach (var piece in ret)
                //    {
                //        piece.MarkAsUpdateGrouping();
                //    }

                //    if (conf.GenLarge)
                //    {
                //        foreach (var piece in large)
                //        {
                //            piece.MarkAsUpdateGrouping();
                //        }
                //    }
                //}
            }
            catch (Exception ex)
            {
                misc.logError(string.Format("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol), ex);
            }
        }


        internal void writeGen(Albums albums, ExtendToNative<datesMode> mode, ExtendToNative<double> nbHours, string baseName, bool onlyEvol)
        {
            try
            {
                logger.log("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol);
                bool withTimeOrder = mode != null && nbHours != null && mode.extendTimeOrder && nbHours.extendTimeOrder;

                var timeRestLimit = 0m;
                if (nbHours != null && nbHours.level)
                {
                    CRank fictif = new CRank();
                    fictif.Quality = 1;
                    fictif.Lenght = 1;
                    fictif.Twice = 1;
                    DateTime dtFictif = DateTime.Now.AddDays(-nbHours.item);
                    List<DateTime> lfictif = new List<DateTime> { dtFictif };
                    timeRestLimit = CalcDate.getRest(lfictif, fictif);
                    logger.log("Limite {0} => {1} {2} ", nbHours.item, timeRestLimit, CConf.ConfGen.Vie.TotalDays() * timeRestLimit);
                }

                var list = albums.makeSelection();



                TimeSpan limit = new TimeSpan();
                if (nbHours != null)
                    limit = TimeSpan.FromHours(nbHours.item);
                TimeSpan current = new TimeSpan();

                List<Album> retAlbum = new List<Album>();


                foreach (Album album in list)
                {
                    //if (album.Name.Contains(@"Ipod\noir\F07"))
                    //{
                        
                    //}
                    if (!album.Classed)
                        continue;
                    if (!album.AtLeastOneEnabled)
                        continue;
                    if (nbHours == null)
                        retAlbum.Add(album);
                    else if (nbHours.level)
                    {
                        if (album.Rank.TimeRest <= timeRestLimit)
                            retAlbum.Add(album);
                    }
                    else if (nbHours.item == 0)
                    {
                        if (album.Rank.TimeRest == 0)
                            retAlbum.Add(album);
                    }
                    else
                    {
                        retAlbum.Add(album);
                        current += album.Duration;
                        if (current > limit)
                        {
                            break;
                        }
                    }
                }

                //retAlbum.Sort(new AlbumSortComparer());
                //retAlbum.Reverse(); 

                var ret = new List<Piece>();
                foreach (Album album in retAlbum)
                {
                    ret.AddRange(album.Sort());
                }


                // if (!CConf.ConfGen.AlbumOrdo)

                //ret.Sort(new AllPieceComparer());
                //ret.Reverse();

                ret.Sort(new AllPieceComparer2());

                // var hash = new HashList<Piece>(ret); 
                var conf = CConf.ConfGen;
                bool extendToNative = mode != null && mode.extend && nbHours != null && nbHours.extend;
                bool withOrder = conf.WithOrder && ((nbHours != null && nbHours.item > 0) || conf.OrderZero);
                withOrder = withOrder || withTimeOrder;
                string strLevel = "";
                if (nbHours == null)
                    strLevel = "";
                else if (nbHours.level)
                    strLevel = "_";

                //var jum = ret.FindAll(t => t.Name == "Jumpin' Jack Flash"); 
                writePlayList("album\\" + mode, baseName + strLevel + nbHours, ret, CConf.ConfGen.AlbumOrdo, extendToNative);
                //IList<Piece> large = ret;

                //large = getLarge(ret);
                //withOrder = withOrder && conf.OrderLarge;
                //writePlayList(mode.ToString(), baseName + strLevel + nbHours + "+", large, withOrder, extendToNative);

                //var writeGrouping = CConf.ConfGen.WriteGrouping;
                //if (writeGrouping > writeGrouping.none && ((nbHours != null && nbHours.item > 0) || conf.WriteGroupingZero))
                //{
                //    foreach (var piece in ret)
                //    {
                //        piece.MarkAsUpdateGrouping();
                //    }

                //    //if (conf.GenLarge)
                //    //{
                //    //    foreach (var piece in large)
                //    //    {
                //    //        piece.MarkAsUpdateGrouping();
                //    //    }
                //    //}
                //}
            }
            catch (Exception ex)
            {
                misc.logError(string.Format("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol), ex);
            }
        }




        public void writePrecisionClassement(string baseName, int precision, bool onlyEvol, bool extendToNative)
        {
            logger.log("writePrecisionClassement" + precision);
            List<Piece> l_listPieceCLass = new List<Piece>();
            foreach (Piece l_piece in m_listIni)
            {
                if (l_piece.QRank > 0)
                {
                    if (!(string.IsNullOrEmpty(l_piece.ClassEvol) && onlyEvol))
                        l_listPieceCLass.Add(l_piece);
                }
            }

            List<Piece> ret = new List<Piece>(l_listPieceCLass.Count);

            foreach (Piece piece in l_listPieceCLass)
            {
                if (piece.classPrecision() <= precision)
                    ret.Add(piece);
            }



            writePlayList("precision", baseName + precision, ret, false, extendToNative);
            var large = getLarge(ret);
            writePlayList("precision", baseName + precision + "+", large, false, extendToNative);


        }


        public void writeCheckClassement(int a_base)
        {
            logger.log("write check Classement " + a_base);
            List<Piece> l_listPieceCLass = new List<Piece>();

            if (a_base == 0)
            {
                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.ClassEvol != "")
                    {
                        l_listPieceCLass.Add(l_piece);
                    }
                }
            }
            else
            {

                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.QRank > 0 && ListSelection.mustPlayToPreciseClassement(l_piece, now, a_base)) // l_piece.mustPlayToPreciseClassement(now, a_base))
                    {
                        l_listPieceCLass.Add(l_piece);
                    }
                }
            }
            l_listPieceCLass.Sort(c_comparer);

            writePlayList("check" + a_base, l_listPieceCLass, false, true);
            var l_large = getLarge(l_listPieceCLass);
            writePlayList("_check" + a_base, l_large, false, true);
        }


        public void writeRotMin(int a_hDuration)
        {
            log("rotMax " + a_hDuration);
            int l_duration = 3600 * a_hDuration;
            m_list = writeRotMin_(l_duration);
            string l_name = a_hDuration.ToString();
            if (a_hDuration < 0)
                l_name = "all";

            string l_name0 = "rotMax" + l_name;
            string l_nameLarge = "_" + l_name0;


            writePlayList(l_name0, m_list, CConf.ConfGen.WithOrder, true);
            var l_large = getLarge(m_list);
            writePlayList(l_nameLarge, l_large, CConf.ConfGen.WithOrder, true);

        }
        /// <summary>
        /// écit une liste basée sur une durée max
        /// </summary>
        /// <param name="a_ms">durée totale de la liste, en ms</param>
        /// <remarks></remarks>
        private List<Piece> writeRotMin_(int a_ms)
        {
            double l_totalDuration = 0;
            int l_durationTarget = a_ms;
            int l_iEnd = 100 * ListSelection.Period;

            List<Piece> l_list = null;
            List<Piece> l_Oldlist = null;
            int l_period = m_rotPeriod;

            do
            {
                l_totalDuration = 0;
                l_Oldlist = l_list;

                l_list = new List<Piece>();

                l_period += 1;


                l_totalDuration = getDuration(l_period, l_list);

                //For Each l_piece As CPiece In m_list
                //    If l_piece.Rank > 0 AndAlso l_piece.canPlay(l_period) Then
                //        l_list.Add(l_piece)
                //        l_totalDuration += l_piece.Duration
                //    End If
                //Next

                m_list = l_list;
                //   log("period " + l_period.ToString() + " " + m_list.Count + "/" + (l_totalDuration / 60000).ToString(".") + " min");
            } while (l_totalDuration > l_durationTarget && l_period < l_iEnd && l_durationTarget > 0);
            m_rotPeriod = l_period - 1;

            if (l_Oldlist == null)
                l_Oldlist = l_list;
            l_Oldlist.Sort(c_comparer);
            return l_Oldlist;




        }

        private double getDuration(int a_base, IList a_list)
        {
            double l_totalDuration = 0;
            foreach (Piece l_piece in m_list)
            {
                if (l_piece.QRank > 0 && ListSelection.canPlay(l_piece, a_base))
                {
                    if (a_list != null)
                        a_list.Add(l_piece);
                    l_totalDuration += l_piece.Duration.TotalSeconds;
                }
            }
            return l_totalDuration;
        }

        private List<Piece> getLarge(IList<Piece> a_list)
        {
            var conf = CConf.ConfGen;

            HashList<Piece> l_large = new HashList<Piece>();
            var listClassEnabled = Consolid.QLClassed.FindAll(p => !conf.OnlyEnabled || p.Enabled);
            HashList<Piece> l_ref = new HashList<Piece>(listClassEnabled);
            int l_deltaBefore = CConf.Before;
            int l_deleteAfter = CConf.After;
            foreach (Piece l_piece in a_list)
            {
                int l_current = l_ref.IndexOf(l_piece); //l_piece.QLRank - 1;
                if (l_current < 0)
                    continue;
                int l_iBefore = l_current + l_deltaBefore;
                int l_after = l_current - l_deleteAfter;

                for (int l_iIndex = l_iBefore; l_iIndex >= l_after; l_iIndex--)
                {
                    if (l_iIndex >= 0 && l_iIndex < l_ref.Count)
                    {
                        var piece = l_ref[l_iIndex];
                        if ((!conf.OnlyEnabled || piece.Enabled) && !l_large.Contains(piece))
                            l_large.Add(piece);
                    }
                }
            }
            return l_large.List;
        }
        private void log(String txt)
        {
            logger.log(txt);
        }

        private void writePlayList(string folder, string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative)
        {

            //    BgDictString<object> dict = new BgDictString<object>();

            //if (max < a_list.Count)
            //{
            //    a_list = new List<Piece>(a_list);
            //    a_list.Reverse();
            //}
            List<IFile> list = new List<IFile>();

            //int nb = 0;
            //int nbAfterRead = -1; 
            foreach (IFile file in a_list)
            {
                //if (dict.ContainsKey(file.Location))
                //{
                //    logger.log("déjà présent '{0}'\\{1}\\{2} ", folder, a_fileName, file.Location);
                //}

                //else
                //{
                //    dict.Add(file.Location, file);
                list.Add(file);
                //nb++;
                //nbAfterRead++; 
                //if (nb >= max && nbAfterRead >= maxAfterRead)
                //    break;
                //   }

            }
            string GEN = "gen";
            if (!string.IsNullOrEmpty(folder) && !folder.EndsWith("\\"))
                GEN += "\\" + folder;
            foreach (ListWriterMgr writer in writers)
            {

                writer.writePlayList(GEN, a_fileName, list, withOrder);
                if (!extendToNative)
                    return;
            }
        }


        private void writePlayList(string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative)
        {
            writePlayList(null, a_fileName, a_list, withOrder, extendToNative);

        }

        //private class FileImpl : IFile
        //{
        //    private string location;
        //    private int id;


        //    public FileImpl(IFile file)
        //    {
        //        this.location = file.Location;
        //        this.id = file.PieceId;

        //    }

        //    #region IFile Members

        //    public string Location
        //    {
        //        get { return location; }
        //    }

        //    public override bool Equals(object obj)
        //    {
        //        var o = obj as IFile;
        //        if (o == null)
        //            return false;
        //        return location.Equals(o.Location);

        //    }

        //    public override int GetHashCode()
        //    {
        //        return location.GetHashCode();
        //    }

        //    public override string ToString()
        //    {
        //        return location;
        //    }

        //    #endregion


        //    public int PieceId
        //    {
        //        get { return id; }
        //    }
        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;
using pdb.gen.Virtuel;
using pdb.gen.Tuning;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private static Logger logger = Logger.getLogger("gen", true);
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des données consolidées morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        private List<Piece> all = new List<Piece>();
        /// <summary>
        /// Liste des données morceux dupliqués 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private static volatile object _lock = new object();
        private bool _consolidEnCours;
        private bool goCompact = true;
        private bool _firstConsolid = true;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
            albums = new Albums(this);
        }
        /// <summary>
        /// Lance le compactage à la prochaine génération
        /// </summary>
        public void GoCompact() { goCompact = true; }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public Albums Albums { get { return albums; } }
        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList, bool makeSort)
        {
            try
            {
                waitForConsolid();
                logger.log("consolid");
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                all = new List<Piece>();

                // albums = new Albums(this);
                VirtualPiece.init();
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>();
                //  htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        Piece piece = null;
                        int pieceId = track.PieceId;
                        if (htIds.ContainsKey(pieceId))
                        {
                            piece = htIds[pieceId];
                            piece.initRank();
                        }
                        else
                        {
                            piece = new Piece(track);
                            htIds.Add(pieceId, piece);
                        }

                        all.Add(piece);

                    }
                }
                // link
                foreach (Piece piece in all)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                albums.checkBuild();
                logger.log("build albums");
                foreach (Piece piece in all)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        foreach (Piece p in piece)
                        {
                            if (albums.check(p))
                                listPieceInAlbum.Add(p);
                        }
                    }
                }

                var confGen = CConf.ConfGen;
                var min = confGen.AlbumMin;

                if (_albumVirtual && _firstConsolid)
                {
                    logger.log("build albums virtuels");
                    var listCandidat = new List<Piece>();
                    var dictTmp = new BgDictString<Album>();
                    foreach (Piece piece in all)
                    {
                        if (piece.Parent == null)
                        {
                            piece.buildVirtualAlbums(listCandidat);
                        }
                    }
                    foreach (Piece p in listCandidat)
                        albums.checkVirtual(p, dictTmp);




                    min = confGen.PathVirtualMin;
                    if (min > 1)
                    {
                        // Suppression des albums virtuel par répertoire avec trop peu de morceaux
                        foreach (var key in new List<string>(dictTmp.Keys))
                        {
                            var a = dictTmp[key];
                            if (a.Virtual && !a.VirtualByArtist)
                            {
                                if (a.Count < min)
                                    dictTmp.Remove(key);
                            }
                        }
                    }

                    if (confGen.ArtistVirtual)
                    {
                        min = confGen.AristVirtualMin;
                        if (min > 1)
                        {
                            // Suppression des albums artiste avec trop peu de morceaux
                            foreach (var key in new List<string>(dictTmp.Keys))
                            {
                                var a = dictTmp[key];
                                if (a.VirtualByArtist)
                                {
                                    if (a.Count < min)
                                        dictTmp.Remove(key);

                                }
                            }
                        }
                    }


                  


                    var listAlbums = new List<Album>(dictTmp.Values);

                    listAlbums.Sort(new VirtualAlbumComparer());
                    albums.checkVirtuals(listAlbums, listPieceInAlbum);

                }

                albums.buildDone();

                // Suppression des albums avec trop peu de morceaux
                min = confGen.AlbumMin;
                if (min > 1)
                {
                    // Suppression des albums standards avec trop peu de morceaux
                    var dict = albums.Dict;
                    foreach (var key in new List<string>(dict.Keys))
                    {
                        var a = dict[key];
                        if (!a.Virtual)
                        {
                            if (a.Count < min)
                                dict.Remove(key);
                        }
                    }
                }


                StackAlbum.Instance.init(all);



                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece);
                    }
                }

                if (_firstConsolid)
                    albums.sortVirtual();
                Ranking(makeSort);
            }
            finally
            {
                lock (_lock)
                {
                    _firstConsolid = false;
                    _consolidEnCours = false;
                }
            }

        }

        public void buildMusique()
        {
            var d = new HashSet<int>();
            foreach (Piece piece in all)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


            foreach (Piece piece in listPieceInAlbum)
            {
                if (d.Add(piece.PieceId))
                    musique.addObj(piece);
            }


#if GEN_ALBUM

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.TrackByNumber;

                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }
#endif

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(TrackList track)
        {
            return albums.getAlbum(track);
        }

        public HashList<Piece> getTracksAlbum(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return new HashList<Piece>();
            return album.Tracks;
        }

        public List<Piece> getTracksAlbumReverse(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackSortedByExportPriority.List;
        }

        public List<Piece> getTracksAlbumByNumber(TrackList track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.TrackByNumber;
        }

        //public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        //{
        //    var album = getAlbum(track);
        //    if (album == null)
        //        return;
        //    foreach (var p in album.Tracks)
        //    {
        //        container.Add(p);
        //    }
        //}

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();

                var list = new List<Piece>();
                var d = new HashSet<int>();
                foreach (Piece piece in all)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                foreach (Piece piece in listPieceInAlbum)
                {
                    if (d.Add(piece.PieceId))
                        list.Add(piece);
                }


                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking(bool makeSort)
        {
            albums.buildStack(makeSort);
            QRanking();
            LRanking();
            QLRanking();


            var list = new List<Piece>(listPiece);
            //logger.log("setTuningDateValues");


            //foreach (Piece piece in list)
            //{
            //    piece.Rank.TimeRest = -1;
            //}
            //foreach (Piece piece in list)
            //{
            //    piece.FirstClass = false;
            //    CRank rank = piece.Rank;
            //    var sortValue = CTuning.Calc(rank, CConf.Sort);
            //    rank.SortValue = sortValue;

            //    ListSelection.setTuningDateValues(piece);
            //}

            logger.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            logger.log("list.Sort(new PieceDeltaComparer());");
            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            logger.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            logger.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);
            // if (makeSort)
            albums.makeSort();
            logger.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

            CTuning.Total = listPieceInAlbum.Count;

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                logger.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                logger.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        logger.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                logger.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    logger.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    logger.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    logger.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    logger.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                logger.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    logger.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                logger.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            logger.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            logger.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            logger.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            logger.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualité +longueur en cas d'égalité
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            logger.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }
#if COMPACT
            if (goCompact || CConf.ConfGen.AlbumSort.compactAny)
            {
                goCompact = false;
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();
            }
#endif

            //if (CConf.Condensation)
            //{
            //    var l = new List<Piece>(this.listPiece);
            //    l.Sort(new CPieceComparerByQualityAndLength2());
            //    new Condenseur(m_listQL).gener2();

            //}

        }


        private static volatile object _lockStat = new object();
        //   private static volatile object _lockStat2 = new object();
        private static bool buildingStat;
        const string BUILDING_STATE = @"..\building.txt";
        const string LOADING_EXCEL = @"..\busyExcel.txt";

        private void _buildStat(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 1");
                    return;
                }


                try
                {
                    if (File.Exists(LOADING_EXCEL))
                    {
                        string content = File.ReadAllText(LOADING_EXCEL);
                        misc.log(content);
                        if (content.Contains("BUSY"))
                        {
                            return;
                        }
                    }
                }
                catch (Exception ex)
                {
                    misc.logError("Impossible de lire le fichier lock excel", ex);
                    return;
                }

                buildingStat = true;
            }



            try
            {
                //bool ok = Monitor.TryEnter(_lockStat2, 60 * 1000);
                //if (!ok)
                //{
                //    misc.log("Pas pu entrer pour générer les stats !!!!!!");
                //    return;
                //}


                File.WriteAllText(BUILDING_STATE, "BUILDING");
                bool generDistrib = step % 10 == 0;

                if (_albumSortMode.createCourant)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled);
                    new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("courant4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("courant4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createInter)
                {
                    var unselected = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent); //  ( CalcDate.getLastModif(t.DatesClassement) > _albumSortMode.lastModif && t.ClassementProvisoire));
                    new StatBuilder(unselected).gener3("stats3.txt", (step % 10 == 0));
                    var stat = new StatBuilder(unselected) { Loupe = 1 };
                    stat.gener4("stats4.txt");
                    stat = new StatBuilder(unselected) { Loupe = 2 };
                    stat.gener4("stats4.txt");
                    //stat = new StatBuilder(unselected) { Loupe = 3 };
                    //stat.gener4("courant4.txt");
                }

                if (_albumSortMode.createAll)
                {
                    new StatBuilder(m_listQL).gener3("all.txt", generDistrib);


                    //  new StatBuilder(m_listQL).gener3(generDistrib);
                    var stat = new StatBuilder(m_listQL) { Loupe = 1 };
                    stat.gener4("all.txt");
                    stat = new StatBuilder(m_listQL) { Loupe = 2 };
                    stat.gener4("all.txt");
                    //stat = new StatBuilder(m_listQL) { Loupe = 3 };
                    //stat.gener4("stats4.txt");
                }


            }
            catch (Exception ex)
            {
                logger.log(ex.ToString());
            }
            finally
            {
                lock (_lockStat)
                {
                    buildingStat = false;
                    File.WriteAllText(BUILDING_STATE, "FREE");
                }
                if (rappel != null)
                    rappel();
            }
        }

        public void builStats(Action rappel)
        {
            lock (_lockStat)
            {
                if (buildingStat)
                {
                    misc.log("stats building by _lockStat 0");
                    return;
                }

            }
            new Thread(() => _buildStat(rappel)).Start();

        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).gener(className);
        }

        public List<Piece> getTracks(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            else
                list = m_listQL.FindAll(t => !t.Enabled || t.ClassementProvisoireRecent);
            return new DynamicStatBuilder(list).getPieces(className);
        }



        //public void timeRanking()
        //{
        //    logger.log("timeRanking");
        //    foreach (var piece in allClassed)
        //        piece.Rank.TimeRest = -1;
        //    foreach (var piece in allClassed)
        //        ListSelection.setTuningDateValues(piece);


        //}

        ///// <summary>
        ///// redirection des index metier de la table m�tier vers la table locale
        ///// Copie des valeurs pertinentes(classlist)
        ///// </summary>
        ///// <remarks></remarks>
        //public void eraseGrouping()
        //{
        //    thCommentGo = false;
        //    thGroupingGo = false;
        //    logger.log("eraseGrouping");
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        piece.setGrouping("", false);
        //        piece.Comment = "";
        //    }
        //}
        //public void writeGrouping()
        //{
        //    logger.log("writeGrouping");
        //    var list = new List<Piece>(listPieceInAlbum);
        //    // list.Sort(new CPieceComparerByQualityAndLength());
        //    list.Sort(new AllPieceComparer2());

        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}


        //private bool thGroupingGo;
        //private bool thCommentGo;

        //public bool GroupinGO
        //{
        //    set
        //    {
        //        thGroupingGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}
        //public bool CommentGo
        //{
        //    set
        //    {
        //        thCommentGo = value;
        //        if (value)
        //        {
        //        }
        //    }
        //}



        //private void writeGroupingAsync()
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    foreach (Piece piece in listPieceInAlbum)
        //    {
        //        try
        //        {
        //            if (!thGroupingGo)
        //                return;
        //            piece.writeGrouping(writeGrouping);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeGrouping::" + ex.ToString());
        //        }

        //    }
        //}

        //private void writeCommentAsync()
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in listPiece)
        //    {
        //        try
        //        {
        //            if (!thCommentGo)
        //                return;
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            misc.log("writeComment::" + ex.ToString());
        //        }
        //    }
        //}

        //public void writeGrouping(Piece piece)
        //{
        //    var writeGrouping = CConf.ConfGen.WriteGrouping;
        //    piece.writeGrouping(writeGrouping);

        //}
        // private bool _sortByAlbum = true;
        //   public bool SortByAlbum { get { return _albumSortMode.Enabled; } }

        private ConfAlbumSort _albumSortMode;
        public ConfAlbumSort SortAlbumMode { set { _albumSortMode = value; } get { return _albumSortMode; } }

        private bool _albumVirtual = CConf.ConfGen.AlbumVirtual;
        public bool AlbumVirtual { get { return _albumVirtual; } set { _albumVirtual = value; } }

        //public void writeComment()
        //{
        //    logger.log("writeComment");
        //    var list = new List<Piece>(listPiece);
        //    list.Sort(new CPieceComparerByQualityAndLength());

        //    var writeComment = CConf.ConfGen.WriteComment;
        //    foreach (Piece piece in list)
        //    {
        //        try
        //        {
        //            piece.writeComment(writeComment);
        //        }
        //        catch (Exception ex)
        //        {
        //            logger.log("writeComment::" + ex.ToString());
        //        }
        //    }




        //}

        //public void writeComment(Piece piece)
        //{
        //    var writeComment = CConf.ConfGen.WriteComment;
        //    try
        //    {
        //        piece.writeComment(writeComment);
        //    }
        //    catch (Exception ex)
        //    {
        //        logger.log("writeComment::" + ex.ToString());
        //    }
        //}



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter m_listWriterAlb;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public static object Lock { get { return _lock; } }
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            lock (_lock)
            {
                var conf = CConf.ConfGen;

                logger.log("Clegacy:createRot {0}", a_baseName);
                List<Piece> l_list = new List<Piece>(m_listTrackClassed);
                List<Piece> l_listAlb = new List<Piece>(allClassedInAlbumEnabled);
                var l_all = new List<Piece>(listPieceInAlbum);
                //  List<Piece> source = null;
                ////  if (SortByAlbum)
                //      source = allClassedInAlbumEnabled;
                //  else
                //      source = m_listTrackClassed;
                //  foreach (Piece l_piece in source)
                //  {
                //      //if (l_piece.belongsTo(a_baseName))
                //      //{
                //      l_list.Add(l_piece);
                //      // }
                //  }





                listWriterAll = new CLegacyListWriter(l_all);






                //      m_listWriter.reset();
                m_listWriter = new CLegacyListWriter(l_list);
                foreach (IListWriter writer in writers)
                    m_listWriter.addWriter(writer);
                //    logger.log("fin creation des writers 0");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {
                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriter.writeGen(mode, duration, "g", false, false);
                            if (conf.GenE)
                                m_listWriter.writeGen(mode, duration, "e", true, false);
                        }
                    }
                }

                if (conf.GenCheck)
                    m_listWriter.writeCheckClassement(0);

                for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
                {
                    m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                    if (conf.GenE)
                        m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
                }
                m_listWriterAlb = new CLegacyListWriter(l_listAlb);

                foreach (IListWriter writer in writers)
                    m_listWriterAlb.addWriter(writer);

                //  logger.log("fin creation des writers alb");
                if (conf.Modes.Count > 0 && conf.Listes.Count > 0)
                {
                    foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                    {

                        foreach (Piece piece in allClassed)
                        {
                            piece.Rank.TimeRest = -1;
                        }

                        foreach (Piece piece in allClassed)
                        {
                            ListSelection.setTuningDateValues(piece, mode.item);
                        }
                        foreach (var duration in conf.Listes)
                        {
                            m_listWriterAlb.writeGen(albums, mode, duration, "g", false);
                        }
                    }
                }

                foreach (IListWriter writer in writers)
                    listWriterAll.addWriter(writer);
                listWriterAll.writeGen(albums, null, null, "all", false);
                //  misc.log("Clegacy:fin createRot {0}", a_baseName);
                return;

                writeRot(1);

                m_listWriter.writeCheckClassement(1);

                m_listWriter.reset();
                writeRotMin(-1);
                writeRotMin(10);
                writeRotMin(1);
            }
        }
        private void writeRotMin(int a_nbHour)
        {
            logger.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;

namespace pdb.gen.albums
{


    public class Album : IEnumerable<Piece>
    {
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }


            return ret; ;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
            }
        }
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero { get { return classementValueLightZero; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return _virtualByArtist; } set { _virtualByArtist = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, VirtualByArtist);
                return key;
            }
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0 { get { return Piece.getClassementEquiv(classementValueLightZero); } }

        // private string moyenne = "";
        public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return stackValue == stackSize; } }
        public bool AlmostFree1 { get { return stackValue == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            piece.PieceAlbum = this;
            if (build)
                return true;

            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                var status = "";
                if (_virtual)
                    status = "v";
                if (_virtualByArtist)
                    status = "va";
                logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                m_rank.init();
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && p.RapportClassement == 0)
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<PieceExtended> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {

                #region calcul virtuel



                DecimalPiece med = null;
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                bool combineNow = mode.combine && mode.simple;
                if (real)
                    _albumMedianne.buildVirtual(combineNow);
                else
                {
                    list.Sort(new PieceClassementComparer(false));
                }


                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.main);
                    med1 = med; med2 = med;
                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, PieceExtended.mode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }
                }

              

                if (mode.combine && mode.simple)
                {

                    var median = med.index;
                    
                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }









                classementValueLight = med.d;



                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, PieceExtended.mode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    if (mode.combine && !mode.simple)
                    {
                        _albumMedianne.buildVirtual(true);
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                        cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    }
                    else
                    {
                        if (true == cause.selectedMotifMin)
                            med = med2;
                        else
                            med = med1;
                    }



                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

                    foreach (var p in list)
                        p.finalyse();



                    if (cause.motifUp)
                    {
                        if (true == selectedMotifMin)
                            selectedCoeff = selectedCoeff.min;
                        else
                            selectedCoeff = selectedCoeff.main;
                    }

                    try
                    {
                        med.index.Piece.MedianneLight = true;
                        med.indexBorder.Piece.Border = true;
                        med.indexBorderEffect.Piece.BorderEffect = true;
                        med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public PieceExtended Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<PieceExtended> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;


            PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            PieceExtended nextZero1 = null;
            PieceExtended nextZero2 = null;

            PieceExtended min1 = null;
            PieceExtended min2 = null;
            PieceExtended min = null;
            decimal _min1 = int.MaxValue;
            decimal _min2 = int.MaxValue;
            decimal _minzero1 = int.MaxValue;
            decimal _minzero2 = int.MaxValue;
            bool realZero = false;
            PieceExtended Next = null;
            foreach (PieceExtended p in list)
            {
                var v1 = p.VirtualClassement;
                var v2 = p.VirtualClassement2;

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            _minzero1 = v1;
                            nextZero1 = p;
                            if (v1 == 0)
                                realZero = true;
                        }
                    }

                    if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2 == 0)
                                realZero = true;
                        }

                    }



                    if (v1 > 0 && v1 < _min1)
                    {
                        _min1 = v1;
                        min1 = p;
                    }

                    if (v2 > 0 && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }

                    if (p.Empty)
                        break;
                }
            }
            decimal _min = 0;
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;
            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }

            PieceExtended nextZero = null;
            decimal _minzero = int.MaxValue;
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }

            if (nextZero != null)
            {

                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.classementValueLightZero > classementValueLight + EPSILON) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minzero < classementValueLight)
                    {
                        classementValueLight = _minzero;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {
                        classementValueLight = _min;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            return cause;



        }




        public void makeSort(ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            classementValueLightSt = -1;
            classementValueLightZeroSt = -1;
            selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;
            classementValueLight = 0;
            classementValueLightZero = 0;

            try
            {



                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return;

                var listE = new List<PieceExtended>(count);
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    p.eraseInfoMedianne();
                    var pp = new PieceExtended(p);
                    listE.Add(pp);
                }


                decimal offset = Album.conf.AlbumMoyOffset;



                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                classed = false;
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                }
                //misc.log("make sort Duration {0}", name); 
                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                decimal moy = 0m;

                #region init
                // misc.log("make sort calcul brut init {0}", name); 
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;

                    p.setClassementVirtuel(list[i].RapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;


                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }


                #endregion


                #region calcul virtuel
                //misc.log("make sort calcul virtuel {0}", name); 
                #region init (prise en compte coeff des enabled)
                //var coeffEnabled = conf.coeffEnabled;
                //for (int i = 0; i < count; i++)
                //{
                //    var p = list[i];
                //    var rapportClassement = p.RapportClassement;
                //    if (coeffEnabled != 1m && p.Enabled && (!conf.oldAsZero || !p.LastClassementRecent))
                //    {
                //        rapportClassement *= coeffEnabled;
                //    }
                //    p.setClassementVirtuel(rapportClassement);
                //    p.setClassementVirtuel2(rapportClassement);
                //}
                //list.Sort(new PieceClassementComparer(false));
                #endregion

                classementValueLightZero = makeSort(listE, mode0, false);
                classementValueLight = makeSort(listE, mode, true);

                #endregion

            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

        }



        public void mustRefresh()
        {
            build = false;
            //   sortDone = false;
            // selectionDone = false;
            atLeastOneEnabled = false;
            _tracksSortByClassement = null;

        }



        public decimal getTrackSortValue(int index, List<Piece> list)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }
        //  private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;
            //if (selectionDone)
            //    return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            // selectionDone = true;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            m_rank.init();
            // rankStack = -1;
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public bool isSameOf(Album o)
        {
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && _virtual == o._virtual && _virtualByArtist == o._virtualByArtist;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public DateTime AlbumAdded
        {
            get
            {
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                return min;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, bool artist)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();


                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }

            }
            return __album;

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        public BgDictString<Album> Dict { get { return dict; } }
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object();
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }


        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                foreach (Album album in dict.Values)
                {
                    album.checkBuild();
                }
            }
        }

        private string getKey(string _album, bool artist)
        {
            return Album.getKey(_album, artist);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                var confGen = CConf.ConfGen;
                var min1 = confGen.AlbumMin;
                var min2 = confGen.PathVirtualMin;
                var min3 = confGen.AristVirtualMin;
                foreach (Album album in new List<Album>( dict.Values))
                {
                    int count = album.Count;
                    bool toKeep = album.buildDone();
                    if (toKeep)
                    {

                        if (album.Virtual)
                        {
                            if (album.VirtualByArtist)
                            {
                                if (min3 > 1 && count < min3)
                                    toKeep = false;
                            }
                            else if (min2 > 1 && count < min2)
                                toKeep = false;
                        }
                        else if (min1 > 1 && count < min1)
                            toKeep = false;



                        if (!toKeep)
                        {
                            misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
                            dict.Remove(getKey(album.Name, album.VirtualByArtist));
                        }
                        
                    }

                }
              

            }
        }

     

        private bool check_(Piece piece, string albumOrg, bool virtualByArtist, IDictionary<string, Album> dict)
        {
            string __album = getKey(albumOrg, virtualByArtist);


            var album = dict[__album];
            if (album == null)
            {
                misc.log("creation album {0}", __album);
                album = new Album(albumOrg, __album);
                album.Virtual = piece.Virtual;
                album.VirtualByArtist = piece.VirtualByArtist;
                dict.Add(__album, album);
            }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualByArtist, dict);
        }

        public int Count { get { return dict.Count; } }





        public void sortVirtual()
        {
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }
        }

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {

            if (piece.Virtual)
                check_(piece, dict);

        }

        public Album getAlbum(TrackList piece)
        {
            return piece.Piece.PieceAlbum;
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
        }

        public void makeSort()
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var main = confMedianne.Main;
                var coeffVirt = main.coeffVirt;
                var safe = main.safe;
                var coeffOld = main.CoeffOld;


                if (confSort.reset)
                {
                    main.coeffVirt = 1;
                    main.CoeffOld = 1;
                    main.safe = 0;
                }





                var list = new List<Album>(dict.Values);
                DateTime now = DateTime.Now;

                foreach (Album album in list)
                {
                    album.makeSort(confMedianne, conf0); //listRef, reference); 
                }

                misc.log(string.Format("makeSort : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                now = DateTime.Now;
                //if (confSort.reset)
                //{
                main.coeffVirt = coeffVirt;
                main.CoeffOld = coeffOld;
                main.safe = safe;
                // }


                list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                list.Reverse();
                for (int i = 0; i < list.Count; i++)
                {
                    list[i].Rank.Sort = i + 1;
                }

                List<Album> listSt = null;
                List<Album> list0 = null;
                List<Album> listSt0 = null;


                if (confSort.sortSt || confSort.correcMainRank || confSort.correcMainCoeff || confSort.correcMainZero)
                {
                    listSt = new List<Album>(list);

                    listSt.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                    listSt.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        listSt[i].RankSt = i + 1;
                    }
                    misc.log(string.Format("sort St : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sort0)
                {
                    now = DateTime.Now;
                    list0 = new List<Album>(list);

                    list0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                    list0.Reverse();
                    for (int i = 0; i < list0.Count; i++)
                    {
                        list0[i].RankZero = i + 1;
                    }
                    misc.log(string.Format("sort 0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sortSt0 || confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    listSt0 = new List<Album>(list);

                    listSt0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, conf0));
                    listSt0.Reverse();
                    for (int i = 0; i < listSt0.Count; i++)
                    {
                        listSt0[i].RankZeroSt = i + 1;
                    }
                    misc.log(string.Format("sort St0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    for (int i = listSt.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        Album zero = listSt0[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (un == zero)
                            un.InvalidateMain();
                    }
                    misc.log(string.Format("correcMainRank : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainCoeff)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLightSt * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLightSt;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }
                    misc.log(string.Format("correcMainCoeff : {0} ms", (DateTime.Now - now).TotalMilliseconds));

                }
                if (confSort.correcMainZero)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var unNext = un.Next;
                            if (unNext == null)
                                continue;

                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;

                                if (o.ClassementValueLightZeroSt < un.ClassementValueLightZeroSt)
                                {
                                    correc = false;
                                    break;
                                }

                                if (!unClassementRecent)
                                {
                                    if (o.ClassementValueLightZeroSt == un.ClassementValueLightZeroSt)
                                    {
                                        if (onext.LastClassementRecent)
                                        {
                                            correc = false;
                                            break;
                                        }
                                    }

                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }


                                //if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //    break;
                                // }



                                //if (o.RankSt <= un.RankSt)
                                //{
                                //    if (o.RankZeroSt > un.RankZeroSt)
                                //    {
                                //        correc = false;
                                //        break;
                                //    }

                                //    if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //        break;
                                //}

                            }

                            if (true == correc)
                                un.InvalidateMain();

                        }



                    }

                    misc.log(string.Format("correcMainZero : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }




                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var list = new List<Album>(dict.Values);

            //var confGen = CConf.ConfGen;
            //var min1 = confGen.AlbumMin;
            //var min2 = confGen.PathVirtualMin;
            //var min3 = confGen.AristVirtualMin;
            //foreach (Album album in dict.Values)
            //{
            //    int count = album.Count;
            //    bool toKeep = true;


            //    if (album.Virtual)
            //    {
            //        if (album.VirtualByArtist)
            //        {
            //            if (min3 > 1 && count < min3)
            //                toKeep = false;
            //        }
            //        else if (min2 > 1 && count < min2)
            //            toKeep = false;
            //    }
            //    else if (min1 > 1 && count < min1)
            //        toKeep = false;



            //    if (!toKeep)
            //    {
            //        misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
            //    }
            //    else
            //        list.Add(album);

            //}

            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list;
        }

        public void changeAlbum(Piece p, string newA)
        {
            var currentAlb = dict[getKey(p.Album, false)];
            if (currentAlb != null)
                currentAlb.mustRefresh();
            check_(p, newA, false, this.dict);
            var newAlb = dict[getKey(newA, false)];
            if (newAlb != null)
                newAlb.mustRefresh();
            p.albumMustRefresh();
        }

        public void changeArtist(Piece p, string newA)
        {



            var currentAlb = dict[getKey(p.Artist, true)];
            if (currentAlb != null)
                currentAlb.mustRefresh();

            check_(p, newA, true, this.dict);
            var newAlb = dict[getKey(newA, true)];
            if (newAlb != null)
                newAlb.mustRefresh();
            p.albumMustRefresh();
        }

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                bool found = false;
                foreach (Album album in dict.Values)
                {
                    if (album.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.Clear();
                }
                else
                {
                    // on le prend.
                    dict.Add(getKey(candidat.Name, candidat.VirtualByArtist), candidat);
                    foreach (Piece p in candidat)
                    {
                        p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }




        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(TrackList track)
        {
            track.Piece.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track.Piece);
        }



    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\ConfGen.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.gen.conf;
using pdb.util;
using System.Collections.Generic;
using pdb.gen.albums;

namespace pdb.gen.Tuning
{
    public enum writeGrouping
    {
        none = 0,
        selected = 1,
        mix = 2,
        all = 3,

    }

    public enum datesMode
    {
        play = 1,
        @class = 2,
        classMin = 3,
        mix = 4,
        mixMin = 5

    }

    public class ExtendToNative<T>
    {
        public readonly T item;
        public readonly bool extend;
        public readonly bool extendTimeOrder;
        public readonly bool level;

        public ExtendToNative(T item, bool extend, bool extendTimeOrder, bool level)
        {
            this.item = item;
            this.extend = extend;
            this.extendTimeOrder = extendTimeOrder;
            this.level = level;
        }

        public override string ToString()
        {
            return item.ToString();
        }
    }
    public class ConfGen
    {

        private CConfQL confCourbe = new CConfQL();

        private TimeSpan vie = TimeSpan.FromDays(365);
        datesMode dates;
        private List<ExtendToNative<double>> listes = new List<ExtendToNative<double>>();
        private decimal exp = 1;
        private bool withOrder;
        private bool orderZero;
        private bool orderLarge;
        private bool genE;
        private bool genLarge;
        private bool writeGroupingZero;
        private bool genCheck;
        bool albumOrdo;
        bool onlyEnabled;
        /// <summary>
        /// Simuler la conso du premier élément
        /// </summary>
        private bool anticipation;

        //private double equivDelta = 0.00001;
        //private int equivStep = 100000; 
        private writeGrouping writeGrouping = writeGrouping.selected;
        private writeGrouping writeComment = writeGrouping.all;

        private GroupingDisplay groupingDisplay = new GroupingDisplay(null);

        private DateTime minPlayDate = DateTime.MinValue;
        private DateTime minClassDate = DateTime.MinValue;
        private int offsetPlayDate = 0;
        private int offsetClassDate = 0;
        private int offsetClassMin = 1;
        private int listLimit = int.MaxValue;
        private int listReaderAfter = 0;
        private int listReaderBefore = 0;
      //  private decimal medianne = 0.5m;
        private decimal albumMoyOffset = 0m;

        private List<ExtendToNative<datesMode>> cat = new List<ExtendToNative<datesMode>>();
        private ExtendToNative<int> precisionMin = new ExtendToNative<int>(-1, false, false, false);
        private ExtendToNative<int> precisionMax = new ExtendToNative<int>(-1, false, false, false);

        private ConfAlbumSort albumSortMode = new ConfAlbumSort(); 

     
        private bool albumVirtual = false;
        private bool artistVirtual = false;
        private int albumMin = -1;
        private int pathVirtualMin = -1; 
        private int artistVirtualMin = -1;
      
        private bool navAuto = false; 

        public ConfGen()
        {
        }
        public ConfGen(XmlElement a_xml)
        {
            if (a_xml == null)
                return;
            XMLTool l_xml = new XMLTool(a_xml);
            XmlElement xmlQuality = l_xml.NodeLookUp("courbe");
            
            confCourbe = new CConfQL(xmlQuality);

            var str = l_xml.getNodeValue("dates");
            if (!string.IsNullOrEmpty(str))
                dates = (datesMode)Enum.Parse(typeof(datesMode), str, true);
            var xTime = l_xml.NodeLookUp("time");
            if (xTime != null)
            {
                var _xtime = new XMLTool(xTime);
                string l_str = _xtime.getNodeValue("vie").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    vie = TimeSpan.FromDays(Convert.ToDouble(l_str));

                l_str = _xtime.getNodeValue("exp").Trim();
                if (!string.IsNullOrEmpty(l_str))
                    exp = Convert.ToDecimal(l_str);
            }

            var xLists = l_xml.NodeLookUp("lists");
            if (xLists != null)
            {
                foreach (XmlNode xList in xLists.ChildNodes)
                {
                    if (xList is XmlElement)
                    {

                        double iList = Convert.ToDouble(xList.InnerText);
                        bool extend = false;
                        var att = xList.Attributes["nat"];
                        if (att != null && att.Value == "true")
                            extend = true;

                        bool extendtimeOrder = false;
                        att = xList.Attributes["timeOrder"];
                        if (att != null && att.Value == "true")
                            extendtimeOrder = true;

                        bool _level = false;
                        att = xList.Attributes["level"];
                        if (att != null && att.Value == "true")
                            _level = true;

                        ExtendToNative<double> e = new ExtendToNative<double>(iList, extend, extendtimeOrder, _level);
                        listes.Add(e);
                    }
                }
            }

            str = l_xml.getNodeValue("writeGrouping");
            if (!string.IsNullOrEmpty(str))
                writeGrouping = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("writeComment");
            if (!string.IsNullOrEmpty(str))
                writeComment = (writeGrouping)Enum.Parse(typeof(writeGrouping), str);

            str = l_xml.getNodeValue("equivDelta");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.coeffDelta = Convert.ToDecimal(str);

            str = l_xml.getNodeValue("equivStep");
            if (!string.IsNullOrEmpty(str))
                CalcEquiv.MAX_STEP = Convert.ToInt32(str);

            var l_display = l_xml.NodeLookUp("display");
            groupingDisplay = new GroupingDisplay(l_display);

            withOrder = l_xml.getBoolValue("withOrder");
            orderLarge = l_xml.getBoolValue("orderLarge");
            orderZero = l_xml.getBoolValue("orderZero");
            genE = l_xml.getBoolValue("genE");
            genLarge = l_xml.getBoolValue("genLarge");
            writeGroupingZero = l_xml.getBoolValue("writeGroupingZero");
            genCheck = l_xml.getBoolValue("genCheck");
            anticipation = l_xml.getBoolValue("anticipation");
            albumOrdo = l_xml.getBoolValue("albumOrdo");
            onlyEnabled = l_xml.getBoolValue("onlyEnabled");
           
            albumVirtual = l_xml.getBoolValue("albumVirtual", albumVirtual);
            artistVirtual = l_xml.getBoolValue("artistVirtual", artistVirtual);


            str = l_xml.getNodeValue("artistVirtualMin");
               if (!string.IsNullOrEmpty(str))
                artistVirtualMin = Convert.ToInt32(str);

            str = l_xml.getNodeValue("albumMin");
               if (!string.IsNullOrEmpty(str))
                   albumMin = Convert.ToInt32(str);
            str = l_xml.getNodeValue("pathVirtualMin");
               if (!string.IsNullOrEmpty(str))
                   pathVirtualMin = Convert.ToInt32(str);
         
            navAuto = l_xml.getBoolValue("navAuto", navAuto);

            str = l_xml.getNodeValue("minPlayDate");
            if (!string.IsNullOrEmpty(str))
                minPlayDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("minClassDate");
            if (!string.IsNullOrEmpty(str))
                minClassDate = Convert.ToDateTime(str);

            str = l_xml.getNodeValue("offsetPlayDate");
            if (!string.IsNullOrEmpty(str))
                offsetPlayDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassDate");
            if (!string.IsNullOrEmpty(str))
                offsetClassDate = Convert.ToInt32(str);

            str = l_xml.getNodeValue("offsetClassMin");
            if (!string.IsNullOrEmpty(str))
                offsetClassMin = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listLimit");
            if (!string.IsNullOrEmpty(str))
                listLimit = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderAfter");
            if (!string.IsNullOrEmpty(str))
                listReaderAfter = Convert.ToInt32(str);

            str = l_xml.getNodeValue("listReaderBefore");
            if (!string.IsNullOrEmpty(str))
                listReaderBefore = Convert.ToInt32(str);

            str = l_xml.getNodeValue("albumMoyOffset");
            if (!string.IsNullOrEmpty(str))
                albumMoyOffset = Convert.ToDecimal(str);
            var xalbumSort = l_xml.NodeLookUp("albumSort");

            albumSortMode = new ConfAlbumSort(xalbumSort); 
        

            var xDir = l_xml.NodeLookUp("dir");
            if (xDir != null)
            {
                foreach (XmlNode xSub in xDir.ChildNodes)
                {
                    if (xSub is XmlElement)
                    {
                        if (xSub.Name == "precision")
                        {
                            var _precisionMin = Convert.ToInt32(xSub.Attributes["min"].Value);
                            bool _extend = false;

                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                _extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;
                            var _precisionMax = Convert.ToInt32(xSub.Attributes["max"].Value);

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;


                            precisionMin = new ExtendToNative<int>(_precisionMin, _extend, _extendtimeOrder, _level);
                            precisionMax = new ExtendToNative<int>(_precisionMax, _extend, _extendtimeOrder, _level);
                        }
                        else
                        {
                            datesMode item = (datesMode)(Enum.Parse(typeof(datesMode), xSub.Name, true));
                            bool extend = false;
                            var att = xSub.Attributes["nat"];
                            if (att != null && att.Value == "true")
                                extend = true;

                            bool _extendtimeOrder = false;
                            att = xSub.Attributes["timeOrder"];
                            if (att != null && att.Value == "true")
                                _extendtimeOrder = true;

                            bool _level = false;
                            att = xSub.Attributes["level"];
                            if (att != null && att.Value == "true")
                                _level = true;

                            cat.Add(new ExtendToNative<datesMode>(item, extend, _extendtimeOrder, _level));

                        }
                    }

                }
            }

        }

        public CConfQL Courbe { get { return confCourbe; } }

        public decimal Exp { get { return exp; } }
        public TimeSpan Vie { get { return vie; } }
        public datesMode Dates { get { return dates; } }
        public List<ExtendToNative<double>> Listes { get { return listes; } }

        //public writeGrouping WriteGrouping { get { return writeGrouping; } }
        //public writeGrouping WriteComment { get { return writeComment; } }
        public timeMode TimeMode { get { return groupingDisplay.TimeMode; } }
        public List<DisplayGrouping> DisplayCategories
        {
            get
            {
                var list = groupingDisplay.Categories;
                var found = list.Find(c => c.category == displayCategory.timeValue);

                int indexCurrentTimeValue = -1; 
                if (found != null)
                    indexCurrentTimeValue = list.IndexOf(found);
                if (indexCurrentTimeValue >= 0)
                {
                    list[indexCurrentTimeValue].category = (displayCategory)dates;
                }

                return list;
            }
        }
        public bool WithOrder { get { return withOrder; } }
        public bool OrderLarge { get { return orderLarge; } }
        public bool OrderZero { get { return orderZero; } }
        public bool GenE { get { return genE; } }
        public bool GenLarge { get { return genLarge; } }
        public bool GenCheck { get { return genCheck; } }
        public bool Anticipation { get { return anticipation; } }
        public bool WriteGroupingZero { get { return writeGroupingZero; } }
        public bool AlbumOrdo { get { return albumOrdo; } }
        public bool OnlyEnabled { get { return onlyEnabled; } }


        public DateTime MinPlayDate { get { return minPlayDate; } }
        public DateTime MinClassDate { get { return minClassDate; } }

        public int OffsetPlayDate { get { return offsetPlayDate; } }
        public int OffsetClassDate { get { return offsetClassDate; } }
        public int OffsetClassMin { get { return offsetClassMin; } }
        public override string ToString()
        {
            return string.Format(" vie:{0} exp:{1} quality:{2} onlyPlayed:{3} writeGrouping:{4} display:{5}", vie, exp, confCourbe, dates, writeGrouping, groupingDisplay);
        }

        public List<ExtendToNative<datesMode>> Modes { get { return cat; } }
        public ExtendToNative<int> PrecisionMin { get { return precisionMin; } }
        public ExtendToNative<int> PrecisionMax { get { return precisionMax; } }
        public int ListLimit { get { return listLimit; } }
        public int ListReaderAfter { get { return listReaderAfter; } }
        public int ListReaderBefore { get { return listReaderBefore; } }
        public decimal AlbumMoyOffset { get { return albumMoyOffset; } }
        public ConfAlbumSort AlbumSort { get { return albumSortMode; } set { albumSortMode = value; } }
        public bool AlbumVirtual { get { return albumVirtual; } }
        public bool ArtistVirtual { get { return artistVirtual; } }
        public int AristVirtualMin { get { return artistVirtualMin; } }
        public int PathVirtualMin { get { return pathVirtualMin; } }
        
        public int AlbumMin { get { return albumMin; } }
        public bool NavAuto { get { return navAuto; } }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\CListFile.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.util;
using pdb.obj;

using pdb.db.piece;

namespace pdb.db.obj
{
    /// <summary>
    /// liste des fichiers accédant au même morceau
    /// </summary>
    /// <remarks></remarks>
    public class CListFile : IEnumerable<CFile>, IData
    {


        //  private static CFileComparer c_comparer = new CFileComparer();
        private const string TOKEN_FILES = "files";
        private List<CFile> m_list = new List<CFile>();
        private CFile pertinentFile;
       // private bool? _exists;
        public CListFile(XmlElement a_xml)
        {
            XmlElement l_xml = XMLTool.NodeLookUp(a_xml, TOKEN_FILES);
            if (l_xml == null)
                return;
            var att = l_xml.Attributes["f"];
            if (att != null)
            {
                CFile f = new CFile(att.Value);
                @add(f);
                return;
            }
            foreach (XmlElement l_xmlFile in l_xml)
            {
                CFile l_file = new CFile(l_xmlFile.InnerText);
                @add(l_file);
            }
        }
        public CListFile()
        {
        }

        public CListFile(CListFile o)
        {
            foreach (CFile f in o)
                @add(f);
        }
        public void @add(CFile a_file)
        {
            //if (!a_file.exists()) return; //TODO provisoire
            bool l_bFound = false;
            foreach (CFile l_file in m_list)
            {
                if (a_file.Equals(l_file))
                {
                    l_bFound = true;
                    break;
                }
            }
            if (l_bFound)
                return;
            if (a_file.FileType.typeMusic())
            {
                m_list.Add(a_file);
                pertinentFile = null;
            }
        }
        //   private CFile _pertinent; 
        public CFile getPertinentFile()
        {
            if (pertinentFile != null)
                return pertinentFile;
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            pertinentFile = list.Count == 0 ? null : list[0];
            return pertinentFile;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        private CFile getFirstFile()
        {
            var pertinent = getPertinentFile();
            if (pertinent != null)
                return pertinent;
            //if (_pertinent != null)
            //    return _pertinent; 
            //  var list = m_list.FindAll(delegate(CFile file) { return file.exists(); }); 
            var list = m_list; // m_list.FindAll(file => file.exists());


            if (list.Count == 1)
                return list[0];

            try
            {
                list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine("impossible de comparer les fichiers");
                foreach (CFile file in list)
                {
                    Console.Write(file.File + ";");
                }
                Console.WriteLine(e.ToString());
            }

            var _pertinent = list.Count == 0 ? null : list[0];
            return _pertinent;
            //if (m_list.Count == 1)
            //    return m_list[0];


            //foreach (CFile l_file in m_list)
            //{
            //    if (l_file.exists())
            //        return l_file;
            //}
            //return m_list[0];
        }

        public void getSecondaryFiles(List<CFile> list)
        {
            if (m_list.Count <= 1)
                return;
            var pertinent = getPertinentFile();

            foreach (CFile f in m_list)
            {
                if (f.exists() && f != pertinent)
                    list.Add(f);
            }

        }

        //public string File
        //{
        //    get
        //    {
        //        CFile l_file = getPertinentFile();
        //        if (l_file == null)
        //        {
        //            if (m_list.Count > 0) return m_list[0].File;
        //            return "";
        //        }
        //        return l_file.File;
        //    }
        //}

        public string PathReduc
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.File;
            }
        }

        public CFile File
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return null;
                return l_file;
            }
        }

        public string Path
        {
            get
            {
                CFile l_file = getFirstFile();
                if (l_file == null)
                    return "";
                return l_file.Path;
            }
        }

        public string getLocation()
        {
            if (pertinentFile != null)
                return pertinentFile.Path;
            if (m_list.Count > 0)
                return m_list[0].getPath();
            return ""; 
        }
        //public String getUri()
        //{
        //    CFile l_file = getPertinentFile();
        //    if (l_file == null)
        //        return "";
        //    return l_file.getUri();
        //}

        public bool Exists
        {
            get
            {
                //if (_exists.HasValue)
                //    return _exists.Value;
                if (pertinentFile != null)
                {
                  //  _exists = true;
                    return true;
                }

                foreach (CFile f in m_list)
                {
                    if (f.exists())
                    {
                     //   _exists = true;
                        return true;
                    }
                }

              //  _exists = false;
                return false;

            }
        }

        public void merge(CListFile a_list)
        {
            CFile aux = getPertinentFile();
            foreach (CFile l_file in a_list)
            {
                @add(l_file);
            }


            CFile _new = getPertinentFile();

            if (aux == null)
            {
                if (_new != null)
                    onChange();

            }
            else
            {
                if (!aux.Equals(_new))
                    onChange();
            }

        }

        private IDataObserver observer;
        public IDataObserver Observer { set { observer = value; } }
        private void onChange() { if (observer != null) observer.RefChange(); }


        /// <summary>
        /// teste s'il existe un fichier en commun entre deux listes
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        /// <remarks></remarks>
        public bool HasOnePathInCommonWith(CListFile other)
        {
            foreach (CFile l_myFile in m_list)
            {
                foreach (CFile l_outFile in other.m_list)
                {
                    if (l_myFile.Equals(l_outFile))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public bool HasOnePathInCommonWith(String path)
        {

            foreach (CFile l_myFile in m_list)
            {

                if (l_myFile.Path.Equals(path))
                {
                    return true;
                }

            }
            return false;
        }


        public int Count
        {
            get { return m_list.Count; }
        }

        public System.Collections.Generic.IEnumerator<CFile> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public bool isPodcast
        {
            get
            {
                foreach (CFile l_file in new List<CFile>(m_list))
                {
                    if (l_file.isPodcast)
                        return true;
                }
                return false;
            }
        }


        #region IData Members


        public void write(ITextWriter a_sw)
        {
            //   m_list.Sort(c_comparer)
            XMLTool.openBalise(a_sw, TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                l_file.write(a_sw);
            }
            XMLTool.closeBalise(a_sw, TOKEN_FILES);
        }


        public void write(XmlWriter w)
        {
            m_list.Sort(new CFileComparerName());
            w.WriteStartElement(TOKEN_FILES);
            if (m_list.Count == 1 && m_list[0] != null)
            {
                w.WriteAttributeString("f", m_list[0].File);
            }
            else
            {

                foreach (CFile l_file in this)
                {
                    l_file.write(w);
                }
            }
            w.WriteEndElement();
        }
        public bool HasChange(CListFile lastFull)
        {
            return m_list.Count != lastFull.m_list.Count;
        }
        public void writeDiff(XmlWriter w, CListFile lastFull)
        {
            if (m_list.Count == lastFull.m_list.Count)
                return;
            m_list.Sort(new CFileComparerName());
            lastFull.m_list.Sort(new CFileComparerName());

            w.WriteStartElement(TOKEN_FILES);
            foreach (CFile l_file in this)
            {
                bool found = false;
                foreach (CFile o in lastFull.m_list)
                {
                    if (o.File.Equals(l_file.File))
                    {
                        found = true;
                        break;
                    }
                }
                if (found)
                    continue;

                l_file.write(w);
            }
            w.WriteEndElement();
        }

        #endregion

        public CFile this[int a_index]
        {
            get
            {
                if (a_index < 0 || a_index >= Count)
                {
                    throw new ApplicationException("bad index:" + a_index + " / " + Count);
                }
                else
                {
                    return m_list[a_index];
                }
            }
        }

        public void Sort()
        {
            try
            {
                m_list.Sort(new CFileComparer());
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
        //private class CFileComparer : IComparer<CFile>
        //{

        //    public int Compare(CFile x, CFile y)
        //    {
        //        return string.Compare(x.File.Trim().ToUpper(), y.File.Trim().ToUpper());
        //    }
        //}

        // private long size = -1;
        public long Size
        {
            get
            {
                    var file = getPertinentFile();
                    if (file == null)
                    return 0;
                return file.Size;

        }

        }

        //public string DirAndFileName
        //{
        //    get
        //    {
        //        var file = getFirstFile();
        //        if (file == null)
        //            return "";
        //        return file.DirAndFileName;
        //    }
        //}


    }
}


]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceData.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.value;
using pdb.db.piece.version;
using pdb.util;



namespace pdb.db.piece.data
{

    /// <summary>
    /// Donnée + liste des versions
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class CPieceData<T> : IData, IEnumerable<CPieceDataVersion<T>>
    {
        /// <summary>
        /// Liste des versions
        /// </summary>
        protected List<CPieceDataVersion<T>> m_list = new List<CPieceDataVersion<T>>();
        private static CDataVersionComparerInv c_comparerInv = new CDataVersionComparerInv();

        private bool m_bOverride = false;
        public abstract string getToken();
        public abstract T getNullValue();
        public abstract CPieceDataValue<T> createPieceDataValue(XmlElement a_node);
        public abstract CPieceDataValue<T> createPieceDataValue(string a_value);
        public abstract CPieceDataValue<T> createPieceDataValueT(T value);
        // protected Bool empty = Bool.not_defined;
        //   protected static DateTime _now = DateTime.Now;

        protected IDataObserver observer;
        public IDataObserver Observer { set { observer = value; } }

        public bool Override { get { return m_bOverride; } }


        public static DateTime Now
        {
            get
            {
                return ChronoData.Now;
            }
        }

        #region signaux

        //public class PieceDataChangeNativeEventArgs : EventArgs
        //{
        //    public PieceDataChangeNativeEventArgs(T value) { this.Value = value; }
        //    readonly public T Value;
        //}

        //public class PieceDataChangeLocalEventArgs : EventArgs
        //{
        //    public PieceDataChangeLocalEventArgs(T Old, T New) { this.Old = Old; this.New = New; }
        //    readonly public T Old;
        //    readonly public T New;
        //}

        //  public event EventHandler<PieceDataChangeNativeEventArgs> changeNativeValue;
        private void OnchangeNativeValue(T value) { if (observer != null) changeNativeValue(value); }
        protected abstract void changeNativeValue(T value);

        //  public event EventHandler<PieceDataChangeLocalEventArgs> changeLocalValueByRemote;
        private void OnChangeLocalByRemote(T Old, T New)// { if (changeLocalValueByRemote != null) changeLocalValueByRemote(this, new PieceDataChangeLocalEventArgs(Old, New)); }
        {
            if (observer != null)
                observer.changeByRemote(getToken(), Old, New);
        }
        //  public event EventHandler<PieceDataChangeLocalEventArgs> changeLocalValueByNative;
        private void OnChangeLocalByNative(T Old, T New) // { if (changeLocalValueByNative != null) changeLocalValueByNative(this, new PieceDataChangeLocalEventArgs(Old, New)); }
        {
            if (observer != null)
                observer.changeByNative(getToken(), Old, New);
        }
        //public event EventHandler<PieceDataChangeLocalEventArgs> cannotMerge;
        private void OnCannotMerge(T Old, T New) { }

        // public event EventHandler change;
        private void onChange() { if (observer != null) observer.RefChange(); }
        #endregion


        public CPieceData(CPieceData<T> o)
        {
            foreach (CPieceDataVersion<T> v in o.m_list)
                m_list.Add(new CPieceDataVersion<T>(v)); 
        }

        public CPieceData(string a_value)
        {
            CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(a_value, this);
            m_list.Add(l_version);

        }

        public CPieceData(T value)
        {
            CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(value, this);
            m_list.Add(l_version);
        }

        public CPieceData()
        {
        }






        /// <summary>
        /// Ajoute si nécessaire les versions réciproques 
        /// </summary>
        /// <param name="a_list"></param>
        /// <remarks>On ne prend en compte que les versions de date définie</remarks>
        /// 




        public void mergeOnlyVersion(CPieceData<T> a_list)
        {
            foreach (CPieceDataVersion<T> l_version in a_list.m_list)
            {
                check(l_version);
            }
            sortAndCompact();
            foreach (CPieceDataVersion<T> l_remote in this.m_list)
            {
                a_list.check(l_remote);
            }
            a_list.sortAndCompact();
        }

        public void mergeAll(CPieceData<T> other, mergePriority a_priority)
        {
            T valueOrg = Value;
            mergeOnlyVersion(other);
            if (!this.Equals(other))
            {
                mergePriority l_ret = this.isMaster(other, a_priority);
                if (l_ret == mergePriority.left)
                {
                    OnChangeLocalByNative(other.Value, this.Value);
                    other.eraseSingleFrom(this);
                }
                else if (l_ret == mergePriority.right)
                {
                    this.eraseSingleFrom(other);
                }
                else
                {
                    OnCannotMerge(this.Value, other.Value);
                }
            }

            if (!Value.Equals(valueOrg))
            {
                onChange();
            }
        }

        /// <summary>
        /// Synchronise les infos de deux pieces (local-distant)
        /// </summary>
        /// <param name="remote">Piece sur fichier pdb_export</param>
        /// <remarks>on teste le cgangement de valeur</remarks>
        public virtual void Consolid(CPieceData<T> remote, mergePriority a_priority)
        {
            sortAndCompact();
            remote.sortAndCompact();
            T l_valueOrg = Value;
            mergeAll(remote, a_priority);

            if (!l_valueOrg.Equals(Value))
            {
                m_bOverride = true;
                OnChangeLocalByRemote(l_valueOrg, Value);
            }

            sortAndCompact();
            remote.sortAndCompact();

        }

        public bool Imported
        {
            get { return m_bOverride; }
        }

        protected virtual void LegacyConsolidByNative(CPieceData<T> local)
        {
            local.eraseSingleFrom(this);
        }

        protected virtual bool canErase()
        {
            return false;
        }

        public void removeVersions()
        {
            sortAndCompact();
            if (m_list.Count > 1)
            {
                m_list = new List<CPieceDataVersion<T>> { m_list[0] };
            }
        }






        public virtual void LegacyConsolid(CPieceData<T> local)
        {
            if (!this.Equals(local))
            {
                mergePriority l_merge = checklegacyModif(local);

                if (l_merge == mergePriority.right)
                {
                    this.m_bOverride = true;
                    this.eraseSingleFrom(local);
                    // this.empty = Bool.not_defined;
                    OnchangeNativeValue(Value);
                }
                else
                {
                    OnChangeLocalByNative(local.Value, this.Value);
                    if ((local.Significant || canErase()) && Now != local.LastModif)
                    {
                        CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(Now, m_list[0].Data);
                        local.m_list.Add(l_version);
                        local.sortAndCompact();
                    }
                    else
                    {
                        local.eraseSingleFrom(this);
                    }
                    //    local.empty = Bool.not_defined;
                }

            }
        }

        public virtual void SynchroNative(T native)
        {
            if (native != null && isSignificant(native) && !Value.Equals(native))
            {
                bool update = true;
                if (native is string)
                {
                    if (native.ToString().Trim().Equals(Value.ToString().Trim()))
                        update = false;
                }

                if (update)
                {
                    OnChangeLocalByNative(this.Value, native);
                    CPieceDataValue<T> newValue = createPieceDataValueT(native);
                    CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(Now, newValue);
                    m_list.Add(l_version);
                    sortAndCompact();
                }
            }
        }

        /// <summary>
        /// Dans le cas d'une égalité de principe, tenter une comparaison basée sur la complétude
        /// </summary>
        /// <param name="remote "></param>
        /// <returns>Indique si la comparaison a été faite</returns>
        /// <remarks></remarks>
        public bool choose(CPieceData<T> remote)
        {
            mergeAll(remote, mergePriority.none);
            // si le merge est effectif (ie l'un des deux a une date définie alors le erge est fait
            // pour provoquer un merge manuel il faut que les deux soient sans date et différents
            return Equals(remote);
        }
        public void mergeManual(CPieceData<T> other)
        {
            //Console.WriteLine("master ? 1 (final:1)   2 ( final:2 ) n:no");
            //string l_resp = Console.ReadLine();
            //if (l_resp == "1")
            //{
            //    Console.WriteLine("merge from first to second");
            //    //Console.WriteLine("merge from second to first")
            //    other.eraseSingleFrom(this);

            //}
            //else if (l_resp == "2")
            //{
            //    Console.WriteLine("merge from second to first");
            //    this.eraseSingleFrom(other);
            //}
            //else
            //{
            Console.WriteLine("abort merge");
            //Return choice.no
            //}
        }

        /// <summary>
        /// Parfois, des valeurs identiques sont indiquées commme des modifications. 
        /// Ordonnancement par ordre chronomogique, et élimination des doublons
        /// </summary>
        protected void sortAndCompact()
        {
            if (m_list.Count < 2) return;
            m_list.Sort(c_comparerInv);
            CPieceDataVersion<T> last = m_list[m_list.Count - 1];
            List<CPieceDataVersion<T>> aux = new List<CPieceDataVersion<T>>(m_list);
            for (int i = m_list.Count - 2; i >= 0; i--)
            {
                CPieceDataVersion<T> current = m_list[i];
                if (current.Data.Equals(last.Data))
                    aux.Remove(current);
                last = current;
            }
            m_list = aux;

        }

        private void eraseSingleFrom(CPieceData<T> a_list)
        {


            if (m_list.Count == 0)
            {
                CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(a_list.m_list[0].Date, a_list.m_list[0].Data);
                m_list.Add(l_version);

            }
            else
            {
                m_list[0].Data = a_list.m_list[0].Data;
            }
            //  empty = Bool.not_defined;

            onChange();


        }



        public bool Equals(CPieceData<T> obj)
        {
            return Value.Equals(obj.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        /// <summary>
        /// détermine quelle info est maitre dans la perspective de les merger
        /// </summary>
        /// <param name="remote"></param>
        /// <param name="a_priority"></param>
        /// <returns>True  : Je suis maître</returns>
        /// <remarks>Pre-condition:  me != remote</remarks>
        private mergePriority isMaster(CPieceData<T> remote, mergePriority a_priority)
        {
            if (this.Equals(remote))
                throw new PieceDbException(this.ToString() + " and " + remote.ToString() + " are equivalent");

            mergePriority l_consistencyComp = compareByConsistency(remote);
            if (l_consistencyComp != mergePriority.none)
                return l_consistencyComp;

            if (LastModif == System.DateTime.MinValue && remote.LastModif == System.DateTime.MinValue)
            {
                return a_priority;
            }
            else
            {
                return mergePriority.none;
                //  throw new PieceDbException("meme date de modif pourtant les fichiers sont différents!");
            }
        }
        protected virtual bool CheckLegacyConsistency()
        {
            return true;
        }
        private mergePriority checklegacyModif(CPieceData<T> local)
        {
            if (CheckLegacyConsistency())
            {
                mergePriority l_consistencyComp = compareByConsistency(local);
                if (l_consistencyComp != mergePriority.none)
                    return l_consistencyComp;
            }

            if (local.Imported) return mergePriority.right;
            return mergePriority.left;
        }

        private mergePriority checklegacyModif(T native)
        {
            if (CheckLegacyConsistency())
            {
                mergePriority l_consistencyComp = compareByConsistency(native);
                if (l_consistencyComp != mergePriority.none)
                    return l_consistencyComp;
                //right = native qui est master
            }
            if (this.Imported) return mergePriority.left;
            return mergePriority.right;
        }


        private mergePriority compareByConsistency(CPieceData<T> other)
        {
            if (!Significant && other.Significant)
                return mergePriority.right;
            if (Significant && !other.Significant)
                return mergePriority.left;

            if (Empty && !other.Empty)
                return mergePriority.right;
            if (!Empty && other.Empty)
                return mergePriority.left;

            return mergePriority.none;
        }

        private mergePriority compareByConsistency(T native)
        {
            if (!Significant && isSignificant(native))
                return mergePriority.right;
            if (Significant && !isSignificant(native))
                return mergePriority.left;

            return mergePriority.none;
        }

        public System.DateTime LastModif
        {
            get
            {
                if (Empty)
                    return System.DateTime.MinValue;
                //  sortAndCompact();
                return m_list[0].Date;
            }
        }

        protected virtual T getPlainValue()
        {
            return m_list[0].Data.Value; 
        }

        public T Value
        {
            get
            {
                if (Empty)
                    return getNullValue();
                //sortAndCompact();
                //int i = 0;
                //while (true)
                //{
                //    var version = m_list[i];
                //    if (!version.Consider)
                //    {
                //        i++;
                //        continue;
                //    }
                //    return version.Data.Value;
                //}
                return getPlainValue(); 

            }
            set
            {
                if (value.Equals(Value)) return;
                m_list.Insert(0, new CPieceDataVersion<T>(Now, createPieceDataValueT(value)));
                sortAndCompact();

            }
        }

        public void removeLastVersion()
        {
            int count = m_list.Count;
            if (count <= 1)
                return;
            m_list.RemoveAt(0);
            sortAndCompact();
        }

        public T LastValue
        {
            get
            {
                if (Empty)
                    return getNullValue();
                int count = m_list.Count;
                if (count < 2)
                    return getNullValue();
                int i = 1;
                while (true)
                {
                    var version = m_list[i];
                    //if (!version.Consider)
                    //{
                    //    i++;
                    //    if (i >= count)
                    //    {
                    //        return getNullValue();
                    //    }
                    //    continue;
                    //}
                    return version.Data.Value;
                }

            }

        }


        private bool Simple
        {
            get { return (m_list.Count == 1 && m_list[0].Date == System.DateTime.MinValue) || Empty; }
        }
        public bool Empty
        {
            get
            {
                //if (empty == Bool.not_defined)
                //{
                bool ret = m_list.Count == 0 || m_list[0].Empty;
                return ret;
                //    empty = ret ? Bool.True : Bool.False;
                //    return ret;
                //}
                //return empty == Bool.True;

            }
        }

        public bool Significant
        {
            get
            {
                if (m_list.Count > 1)
                    return true;
                return m_list.Count == 1 && m_list[0].Significant;
            }
        }
        public abstract bool isSignificant(T value);



        public void checkList(CPieceData<T> other)
        {
            foreach (CPieceDataVersion<T> version in other)
            {
                check(version);
            }
            sortAndCompact();
        }


        /// <summary>
        /// indique si la liste contient déja la version
        /// </summary>
        /// <param name="a_version">version testée</param>
        /// <returns>True : si version connue</returns>
        /// <remarks>On ne prend en compte que les dates définies</remarks>
        private bool Contains(CPieceDataVersion<T> a_version)
        {
            foreach (CPieceDataVersion<T> l_elt in this)
            {
                System.DateTime l_date = l_elt.Date;
                if (l_date > System.DateTime.MinValue && a_version.Date == l_date)
                {
                    return true;
                }
            }
            return false;
        }


        private void check(CPieceDataVersion<T> a_version)
        {
            if (!Contains(a_version))
            {
                if (a_version.Date > System.DateTime.MinValue)
                {
                    //if (a_version.Consider)
                    //{
                        m_list.Add(a_version);
                        //     empty = Bool.not_defined;
                    //}
                }
            }

        }


        public CPieceData(System.Xml.XmlElement a_node)
        {

            bool l_bSingle = false;

            XmlElement l_Mynode = XMLTool.NodeLookUp(a_node, getToken());

            if (l_Mynode == null)
                return;

            XmlAttribute att = l_Mynode.Attributes[CPieceDataValue<T>.TOKEN];
            if (att != null)
            {
                l_bSingle = true;
            }




            foreach (XmlNode l_node in l_Mynode)
            {
                if (!l_bSingle)
                {

                    if (l_node is XmlElement && l_node.Name == CPieceDataVersion<T>.VERSION)
                    {
                        XmlElement l_elt = (XmlElement)l_node;
                        CPieceDataVersion<T> l_version = new CPieceDataVersion<T>(l_elt, this);
                        if ((!l_version.Data.Empty || canErase()))
                        {
                            m_list.Add(l_version);
                        }
                    }
                    else
                    {
                        l_bSingle = true;
                        // break; // TODO: might not be correct. Was : Exit For
                    }
                }
            }

            if (l_bSingle)
            {
                CPieceDataVersion<T> l_version = null;
                if (l_Mynode != null)
                    l_version = new CPieceDataVersion<T>(l_Mynode, this);
                else
                    l_version = new CPieceDataVersion<T>(att.Value, this);
                m_list.Add(l_version);
            }
            sortAndCompact();
        }




        public void write(ITextWriter a_sw)
        {
            if (Empty)
                return;
            XMLTool.openBalise(a_sw, getToken());
            if (Simple)
            {
                a_sw.Append(m_list[0].Data.ToString());
            }
            else
            {
                sortAndCompact();
                //    m_list.Sort(c_comparerInv); 
                foreach (CPieceDataVersion<T> l_version in m_list)
                {
                    l_version.write(a_sw);
                }
            }
            XMLTool.closeBalise(a_sw, getToken());
        }

        protected virtual void writeSimple(XmlWriter w)
        {
            w.WriteElementString(getToken(), m_list[0].Data.ToString());
            //  w.WriteAttributeString(getToken(), m_list[0].Data.ToString()); 
        }

        public void write(XmlWriter w)
        {
            if (Empty)
                return;
            //  w.WriteStartElement(getToken()); 

            if (Simple)
            {
                writeSimple(w);


            }
            else
            {
                w.WriteStartElement(getToken());
                sortAndCompact();
                //    m_list.Sort(c_comparerInv); 
                foreach (CPieceDataVersion<T> l_version in new List<CPieceDataVersion<T>>(m_list))
                {
                    l_version.write(w);
                }
                w.WriteEndElement();
            }

        }

        public bool HasChange(CPieceData<T> lastFull)
        {
            if (lastFull.Value == null || !lastFull.Value.Equals(Value))
                return true;
            return false;
        }

        public void writeDiff(XmlWriter w, CPieceData<T> lastFull)
        {
            //if (Empty)
            //    return;
            ////  w.WriteStartElement(getToken()); 

            sortAndCompact();
            lastFull.sortAndCompact();

            if (Value == null)
            {
                if (lastFull.Value == null)
                    return;
            }

            if (lastFull.Value == null || !lastFull.Value.Equals(Value))
            {

                if (Simple)
                {
                    if (lastFull.m_list.Count < 1 || m_list.Count < 1 || !(lastFull.m_list[0].Data.Value.Equals(m_list[0].Data.Value)))
                    {
                        writeSimple(w);
                        return;
                    }


                }
                else
                {
                    w.WriteStartElement(getToken());

                    //    m_list.Sort(c_comparerInv); 

                    //int count = lastFull.m_list.Count;
                    //int count0 = count; 
                    //if (m_list.Count > count)
                    //    count = m_list.Count;

                    //for (int i = count -1 ; i >=0; i++)
                    //{
                    //    CPieceDataVersion<T> my = m_list[i];
                    //    CPieceDataVersion<T> old = null;
                    //    if (i < count0 - 1)
                    //        old = lastFull.m_list[i]; 

                    //    if (old == null)



                    //}
                    foreach (CPieceDataVersion<T> l_version in new List<CPieceDataVersion<T>>(m_list))
                    {
                        bool found = false;
                        foreach (CPieceDataVersion<T> l_version_old in new List<CPieceDataVersion<T>>(lastFull.m_list))
                        {
                            if (l_version_old.Date == l_version.Date && l_version_old.Data.Equals(l_version.Data))
                            {
                                found = true;
                                break;
                            }

                        }

                        if (found)
                            continue;
                        l_version.write(w);
                    }
                    w.WriteEndElement();
                }
            }

        }



        public virtual CListDate Dates
        {
            get
            {
                CListDate dates = new CListDate();
                foreach (CPieceDataVersion<T> data in m_list)
                {
                    dates.check(data.Date);
                }
                return dates;
            }
        }
        //private class CDataVersionComparer : IComparer<CPieceDataVersion<T>>
        //{


        //    public int Compare(CPieceDataVersion<T> x, CPieceDataVersion<T> y)
        //    {
        //        return System.DateTime.Compare(x.Date, y.Date);
        //    }
        //}
        private class CDataVersionComparerInv : IComparer<CPieceDataVersion<T>>
        {
            public int Compare(CPieceDataVersion<T> x, CPieceDataVersion<T> y)
            {
                //if (!x.Consider)
                //{
                //    if (!y.Consider)
                //        return -1 * System.DateTime.Compare(x.Date, y.Date);
                //    return 1;
                //}
                //if (!y.Consider)
                //    return -1;

                return - System.DateTime.Compare(x.Date, y.Date);
            }
        }

        public System.Collections.IEnumerator GetEnumerator1()
        {
            return m_list.GetEnumerator();
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator1();
        }

        public System.Collections.Generic.IEnumerator<CPieceDataVersion<T>> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\data\CPieceDataClassement.cs">
    <content><![CDATA[using System;
using pdb.db.piece.type;
using pdb.db.piece.value;
using pdb.db.piece.version;
using pdb.util;
using pdb.db.obj;
using System.Collections.Generic;
using System.Xml;
namespace pdb.db.piece.data
{


    public class CPieceClassement : CPieceData<Classement>
    {

        private const string TOKEN_CLASSEMENT = "classement";
        public CPieceClassement(CPieceClassement o)
            : base(o)
        {
        }

        public CPieceClassement(System.Xml.XmlElement a_node)
            : base(a_node)
        {
            if (XMLTool.NodeLookUp(a_node, getToken()) == null)
            {
                CPieceDataValueClassement l_data = new CPieceDataValueClassement(a_node);
                m_list.Add(new CPieceDataVersion<Classement>(DateTime.MinValue, l_data));
            }
            //  int count = m_list.Count;
            //            if (count > 0)
            //            {
            //                var version = m_list[count - 1];
            //                if (string.IsNullOrEmpty(version.Data.Value.ClassList))
            //                {
            //                    version.Consider = false;
            //                    //  empty = Bool.not_defined; 
            //                }
            //#if ASC
            //                var versionF = m_list[0];
            //                var valueOrg = versionF.Data;
            //                var classOrg = valueOrg.Value.ClassList;
            //                var rating = valueOrg.Value.Rating;
            //                if (classOrg.StartsWith("0"))
            //                {
            //                    classOrg = "1";
            //                    rating = 0; 
            //                  //  classOrg = classOrg.Remove(0, 1);
            //                }

            //                valueOrg.Value = new Classement(classOrg, rating); 

            //#endif
            //            }


        }

        public void initClassementIfEmpty(string classement)
        {
            if (m_list.Count > 0)
                return;
            var cl = pdb.db.piece.type.Classement.create(classement);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
        }

        public void eraseClassement()
        {
            m_list = new List<CPieceDataVersion<Classement>>();
            initClassementIfEmpty("0.0");
        }

        public CPieceClassement(string strClassement)
        {
            var cl = pdb.db.piece.type.Classement.create(strClassement);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
        }

        public CPieceClassement(string a_class, int a_rating)
        {
            Classement l_class = new Classement(a_class, a_rating);
            m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(l_class)));
            // empty = Bool.not_defined; 

        }

        public CPieceClassement(int a_rating)
            : this("", a_rating)
        {
        }
        public CPieceClassement()
            : base()
        {
        }

        protected override bool CheckLegacyConsistency()
        {
            return false;
        }
        public override CPieceDataValue<Classement> createPieceDataValue(System.Xml.XmlElement a_node)
        {
            return new CPieceDataValueClassement(a_node);
        }

        public override string getToken()
        {
            return TOKEN_CLASSEMENT;
        }

        public override CPieceDataValue<Classement> createPieceDataValue(string a_str)
        {
            return null;
        }

        public override Classement getNullValue()
        {
            return new Classement("", 0);
        }
        public override CPieceDataValue<Classement> createPieceDataValueT(Classement value)
        {
            return new CPieceDataValueClassement(value);
        }

        public override bool isSignificant(Classement value)
        {
            return value.ClassList != "";
        }

        public string ClassList
        {
            get { return Value.ClassList; }


            //TODO A REVOIR
            set
            {
                if (m_list.Count == 0)
                {
                    int l_rating = Rating;
                    Classement l_new = new Classement(value, l_rating);
                    m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(l_new)));
                    //  empty = Bool.False;
                }
                else
                {
                    if (Value.ClassList != value)
                    {
                        //int l_rating = Rating;
                        //Classement l_new = new Classement(value, l_rating);
                        //m_list.Add(new CPieceDataVersion<Classement>(now, new CPieceDataValueClassement(l_new)));
                        m_list[0].Data.Value.ClassList = value;
                    }
                    // empty = Bool.not_defined;
                }
            }
        }

        protected override void writeSimple(XmlWriter w)
        {
            w.WriteStartElement(getToken());
            m_list[0].Data.write(w);
            w.WriteEndElement();
        }

        public void setClassement(string className, int rating)
        {
            Classement cl = new Classement(className, rating);
            if (m_list.Count == 0)
                m_list.Add(new CPieceDataVersion<Classement>(Now, new CPieceDataValueClassement(cl)));
            else
                m_list[0].Data.Value = cl;
            sortAndCompact();
        }

        public void eraseClassement2()
        {
            Classement cl = Classement.create("0.0");
            eraseClassement2(cl);
        }

        public void eraseClassement2(Classement cl)
        {
            m_list = new List<CPieceDataVersion<Classement>>();
            m_list.Add(new CPieceDataVersion<Classement>(DateTime.MinValue, new CPieceDataValueClassement(cl)));
        }

        public int Rating
        {
            get { return Value.Rating; }
            set { Value.Rating = value; }
        }



        protected override bool canErase()
        {
            return true;
        }

        public override void Consolid(CPieceData<Classement> remote, mergePriority a_priority)
        {
            base.Consolid(remote, a_priority);
            this.checkList(remote);
        }

        public override void LegacyConsolid(CPieceData<Classement> local)
        {
            base.LegacyConsolid(local);
            this.checkList(local);
        }

        public bool isClassListNumeric { get { return Value.isClassListNumeric; } }



        public String Evol
        {
            get
            {

                if (m_list.Count <= 1) return "++";

                Classement last = m_list[0].Data.Value;
                Classement before = m_list[1].Data.Value;

                String strLast = last.ClassNameAndRating;
                String strBefore = before.ClassNameAndRating;

                int cmp = compareClassNameAndRating(strLast, strBefore);
                if (cmp == 0)
                    return "=";  // normalement impossible
                if (cmp < 0) return "+";
                return "-";
            }

        }

        public static int compareClassNameAndRating(string strX, string strY)
        {
            int max = strX.Length > strY.Length ? strX.Length : strY.Length;
            for (int i = 0; i < max; i++)
            {
                int iX = strX.getInt(i); // CUtil.getInt(strX, i);
                int iY = strY.getInt(i);//CUtil.getInt(strY, i);
                if (iX != iY)
                    return -iX.CompareTo(iY);
            }
            return 0;
        }

        public List<DateTime> getDates()
        {
            var list = new List<DateTime>();
            foreach (var version in new List<CPieceDataVersion<Classement>>(m_list))
            {
                list.Add(version.Date);
            }
            return list;

        }

        public override CListDate Dates
        {
            get
            {
                var list = new List<DateTime>();
                //    double current = -1;
                sortAndCompact();
                foreach (var version in new List<CPieceDataVersion<Classement>>(m_list))
                {
                    //double aux = version.Data.Value.getNormValue();
                    //if (aux != current)
                    //{
                    list.Add(version.Date);
                    // current = aux; 
                    //}
                }
                return new CListDate(list);
            }
        }

        public void Menage(CPiece piece)
        {
            sortAndCompact();
            //   misc.log("ménage " + this); 

            var aux = new List<CPieceDataVersion<Classement>>(m_list);


            //// 1. parcours jusqu'à trouver 1.0
            //int index1 = -1;
            //int count = aux.Count;

            //for (int i = 0; i < count; i++)
            //{
            //   CPieceDataVersion <Classement> clv = aux[i];
            //   if (clv.Data.Value.getNormValue() == 1)
            //   {
            //       index1 = i;
            //       break; 
            //   }
            //}

            //if (index1 >= 0)
            //{
            //    while (aux.Count > index1 + 1)
            //    {
            //        misc.log( piece  + " suppression " + aux[index1 + 1] + " cause départ à 1");
            //        aux.RemoveAt(index1 + 1);
            //    }
            //}

            //2. vérification des allez-retours 
            int count = aux.Count;

            while (count > 2)
            {
                for (int i = 0; i < count; i++)
                {
                    var clv0 = aux[i].Data.Value;
                    if (i + 2 >= count)
                    {
                        count = -1;
                        break;
                    }
                    var clv2 = aux[i + 2].Data.Value;
                    if (clv2.getNormValue() == clv0.getNormValue())
                    {
                        misc.log(piece + "suppression " + aux[i] + " cause doublon avec " + aux[i + 2]);
                        aux.RemoveAt(i);
                        count = aux.Count;
                        break;
                    }
                }

            }

            m_list = aux;
            sortAndCompact();



        }

        public override string ToString()
        {
            return Value.ToString();
        }

        protected override void changeNativeValue(Classement value)
        {
            observer.changeNativeValueClassement(value);
        }

        #region on repart de zero
        private static DateTime dateMin;
        public static DateTime DateMin { set { dateMin = value; } }

        protected override Classement getPlainValue()
        {
            if (m_list[0].Date < dateMin)
            {
                if (m_list[0].Data.Empty)
                    return getNullValue();
                return new Classement("0", 0);
            }
            return base.getPlainValue();
        }
        #endregion

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Db\piece\version\CPieceDataVersion.cs">
    <content><![CDATA[using System;
using System.Xml;
using pdb.db.piece.data;
using pdb.db.piece.value;
using pdb.util;
namespace pdb.db.piece.version
{

    /// <summary>
    /// Enregistrement d'une version d'une valeur
    /// deux parties = date de modif et valeur (générique)
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <remarks></remarks>
    public class CPieceDataVersion<T> : IData
    {
        public const string VERSION = "version";
        private const string TOKEN_DATE = "date";
        private System.DateTime m_date;

        protected CPieceDataValue<T> m_value;
        public CPieceDataVersion(System.DateTime a_date, CPieceDataValue<T> a_value)
        {
            m_date = a_date;
            m_value = a_value;
        }

        public CPieceDataVersion(CPieceDataVersion<T>  o)
        {
            m_date = o.m_date;
            m_value = o.m_value.createCopy();             
        }

      

        //private bool _consider = true;
        //public bool Consider { get { return _consider; } set { _consider = value; } }

        

        public CPieceDataVersion(XmlElement a_node, CPieceData<T> a_pieceData)
        {
            System.DateTime l_date = System.DateTime.MinValue;
            XMLTool l_xml = new XMLTool(a_node);
            string l_strDate = l_xml.getNodeValue(TOKEN_DATE);
            if (string.IsNullOrEmpty(l_strDate))
            {
                var att = a_node.Attributes[TOKEN_DATE];
                if (att != null)
                    l_strDate = att.Value;
            }
            if (!string.IsNullOrEmpty(l_strDate))
                l_date = Convert.ToDateTime(l_strDate);
            m_date = l_date;
            m_value = a_pieceData.createPieceDataValue(a_node);
        }


        public CPieceDataVersion(string a_value, CPieceData<T> a_pieceData)
        {
            m_date = System.DateTime.MinValue;
            m_value = a_pieceData.createPieceDataValue(a_value.TrimSafe());
        }

        public CPieceDataVersion(T value, CPieceData<T> a_pieceData)
        {
            m_date = System.DateTime.MinValue;
            m_value = a_pieceData.createPieceDataValueT(value);
        }

        public bool Significant
        {
            get { return m_value.Significant; }
        }
        public bool Empty
        {
            get { return (m_date == System.DateTime.MinValue && m_value.Empty);} //|| (!_consider); }
        }
        public System.DateTime Date
        {
            get { return m_date; }
        }
        public CPieceDataValue<T> Data
        {
            get { return m_value; }
            set { m_value = value; }
        }

        public override string ToString()
        {
            return m_date + ":" + m_value.Value;
        }

        public void write(ITextWriter a_sw)
        {
            if (Empty)
                return;
            XMLTool.openBalise(a_sw, VERSION);
            if (m_date > System.DateTime.MinValue)
                XMLTool.writeValue(a_sw, TOKEN_DATE, m_date.ToString());
            m_value.write(a_sw);
            XMLTool.closeBalise(a_sw, VERSION);
        }

        #region IData Members


        public void write(XmlWriter w)
        {
            if (Empty)
                return;


            w.WriteStartElement(VERSION);
            if (m_date > System.DateTime.MinValue)
                w.WriteAttributeString(TOKEN_DATE, m_date.ToString());
            //  w.WriteElementString(TOKEN_DATE, m_date.ToString()); 
            m_value.write(w);
            w.WriteEndElement();
        }

        #endregion
    }
}
]]></content>
  </file>
</db>
