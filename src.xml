<db path="C:\Bernard\db1\PieceDb3Ref">
   <file path="\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    class AutoBuilder : IComparable<AutoBuilder>, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private IBuilderSource source; public IBuilderSource Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;
        private List<AutoBuilderItem> chooses = new List<AutoBuilderItem>();
        public const int STOP_MAX = 3;
        private int _stopLevel = STOP_MAX;
        // private bool 



        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(IBuilderSource source)
        {
            this.source = source;
            source.addBorderObs(this);
        }
        private static AutoBuilder main;
        public static void build(XmlNode xAuto, IBuilderSource source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    {
                        //if (!exist)
                        //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                        tw.Write(DateTime.Now); tw.Write(SEP);
                        tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                        tw.Write(d.ToString("0.###")); tw.Write(SEP);
                        tw.Write(org.ToString("0.###")); tw.Write(SEP);
                        tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(atomicMode); tw.Write(SEP);
                        tw.Write(state); tw.Write(SEP);
                        for (int i = 0; i < imax; i++)
                        {
                            if (i > 0)
                            {
                                tw.WriteLine();
                                for (int j = 0; j < 11; j++)
                                    tw.Write(SEP);
                            }
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].track);
                            tw.Write(SEP);
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].item);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].track);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].item);
                            tw.Write(SEP);
                        }
                        tw.WriteLine();
                    }
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
            _stopLevel = STOP_MAX;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            //bool firstWIthTb = first && Conf.BorderTb;
            //bool secondwithoutTb = !first && !Conf.BorderTb;
            //bool readXml = firstWIthTb || secondwithoutTb;

            bool readXml = first;
            FileInfo f = null;
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                if (first)
                    builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static void Init3()
        {
            foreach (AutoBuilder item in list)
            {
                item.init3();
            }
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check3();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                AutoBuilder builder = null;
                if (!started)
                {
                    started = true;
                    foreach (AutoBuilder b in list)
                        b.total = b.source.getTotalSize();
                }
                // application de la précédente modif
                builder = list[index];
                if (builder.state > builderstate.none)
                {
                    builder.makeEmpreinteNonSequence();
                    decrementIndex();
                }
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    builder = list[i];
                    bool cango = false;
                    bool _cont = false;
                    while (true)
                    {
                        if (i == index || _cont)
                        {
                            cango = builder.check();
                            index = i;
                            main = builder;
                            _cont = false;
                            break;
                        }
                        else
                            cango = builder.checkWithoutModify();
                        if (builder.state == builderstate.none)
                            _cont = true;
                        else
                            break;
                    }
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (i == index)
                    {
                        if (builder.newv != builder.org)
                        {
                            _modifFile = true;
                        }
                        else
                        {
                            //index--;
                            //if (index < 0)
                            //    index = list.Count - 1;
                        }
                    }
                    if (_modifFile)
                        break;
                }
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                    _cango = false;
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        private bool check()
        {
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.none)
                reset();
            else if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
                else
                {
                    mustUpdate = false;
                    canGo = true;
                    org = newv;
                    return true;
                }
            }
            if (Conf.AutoSequence || total < 0)
                total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
            if (state == builderstate.none)
                delta0 = delta;
            state = builderstate.enCours;
            lastd = d;
            d = 0;
            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return true;
            string attTarget = conf.type.ToString();
            var att = xml.Attributes[attTarget];
            if (att == null)
                return true;
            org = Convert.ToDouble(att.Value);
            newv = org;
            try
            {
                if (delta * delta0 < 0)
                {
                    if (atomicMode < 0)
                    {
                        atomicMode = 0;
                        //if (minMem == null)
                        //    minMem = new Memory(mem0);
                        //if (maxMem == null)
                        //    maxMem = new Memory(mem0);
                        //if (minMem.suppressions.Count == 0)
                        //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
                        //if (maxMem.ajouts.Count == 0)
                        //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
                    }
                }
                bool cancelSameConf = false;
                bool cancelNb = false;
                if (atomicMode >= 0)
                {
                    atomicMode++;
                    if (Math.Abs(dmin - delta) < EPSILON)
                        sameConfiguration++;
                    else if (Math.Abs(dmax - delta) < EPSILON)
                        sameConfiguration++;
                    else
                        sameConfiguration = 0;
                    if (sameConfiguration > conf.idem)
                        cancelSameConf = true;
                    if (atomicMode > conf.cloop)
                        cancelNb = true;
                }
                if (delta >= 0)
                {
                    if (mem0.suppressions.Count > 0)
                        minMem = new Memory(mem0);
                    if (delta < conf.write)
                        canGo = true;
                    //  lastGoodLevel = org;
                    //if (maxMem != null && minMem != null)
                    //{
                    if (atomicMode > 0)
                    {
                        if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
                        {
                            log("abandon recherche cartésienne cause idem");
                            state = builderstate.stable;
                            return true;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            state = builderstate.stable;
                            return true;
                        }
                        //if (Math.Abs(dmin - delta) < 0.01)
                        //    dminAlready = true;
                        //else
                        //    dminAlready = false;
                        if (maxMem != null && minMem != null)
                        {
                            if (minMem.suppressions.Count == maxMem.ajouts.Count)
                            {
                                bool identique = true;
                                for (int i = 0; i < minMem.suppressions.Count; i++)
                                {
                                    if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                    {
                                        identique = false;
                                        break;
                                    }
                                }
                                if (identique)
                                {
                                    if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
                                    {
                                        mustUpdate = false;
                                        log("abandon recherche cartésienne cause cycle");
                                        state = builderstate.stable;
                                        _empreinte = newEmpreinte;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    cmin = org;
                    dmin = delta;
                    // lastGoodDelta = (int)delta;
                    lastTotal = (int)total;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        //if (atomicMode > conf.cloop)
                        //{
                        //    mustUpdate = false;
                        //    log("abandon recherche cartésienne cause cloop");
                        //    state = builderstate.stable;
                        //    _empreinte = newEmpreinte;
                        //    return true;
                        //}
                        //if (dminAlready && dmaxAlready)
                        //{
                        //    mustUpdate = false;
                        //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
                        //    return true;
                        //}
                        d = 0.5 * (cmax - cmin);
                    }
                    else
                    {
                        double _d = int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmax - cmin;
                        double aux = int.MaxValue;
                        // double aux2 = int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - level.d) * level.inf;
                            if (aux > d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {

                            if (org > conf.max)
                                d = conf.max - org;
                            else
                            {
                                d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 < d)
                        //    d = aux2;

                        if (d > _d)
                            d = _d;
                    }
                }
                else if (delta < 0)
                {
                    if (mem0.ajouts.Count > 0)
                        maxMem = new Memory(mem0);
                    mustUpdate = true;
                    canGo = false;
                    //if (maxMem != null && minMem != null)
                    //{
                    //    if (atomicMode < 0)
                    //        atomicMode = 0;
                    //    atomicMode++;
                    //}
                    cmax = org;
                    dmax = delta;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        bool identique = false;
                        if (minMem != null && maxMem != null
                            && maxMem.ajouts.Count == minMem.suppressions.Count)
                        {
                            identique = true;
                            for (int i = 0; i < minMem.suppressions.Count; i++)
                            {
                                if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                {
                                    identique = false;
                                    break;
                                }
                            }
                        }
                        if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
                        {
                            log("retour derniere bonne valeur cause idem");
                            d = cmin - cmax;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            d = cmin - cmax;
                        }
                        else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
                        {
                            log("retour derniere bonne valeur cause cycle");
                            d = cmin - cmax;
                        }
                        //else if (atomicMode > conf.cloop)
                        //{                      
                        //    log("abandon recherche cartésienne cause cloop");
                        //    d = cmin - cmax;
                        //}
                        else
                            d = 0.5 * (cmin - cmax);
                    }
                    else
                    {

                        double _d = -int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmin - cmax;
                        double aux = -int.MaxValue;
                        // double aux2 = -int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - conf.delta + level.d) * level.sup;
                            if (aux < d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {
                            if (org < conf.min)
                                d = (conf.min - org);
                            else
                            {
                                d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 > d)
                        //    d = aux2;

                        if (d < _d)
                            d = _d;
                    }
                    //d = (delta - conf.delta) * conf.sup;
                    //if (org <= lastGoodLevel)
                    //{
                    //    lastGoodLevel = -1;
                    //    lastGoodDelta = -1;
                    //    lastTotal = -1;
                    //}
                }
                if (Math.Abs(d) < 0.00000001)
                {
                    mustUpdate = false;
                    // unCart();
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                //if (dejaVu)
                //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
                log("correction {0}", d);
                newv = org + d;
                if (newv <= 0)
                    newv = 0;
                if (conf.coeff > 0)
                {
                    if (newv > conf.max)
                        newv = conf.max;
                    else if (newv < conf.min)
                        newv = conf.min;
                }
                newv = Math.Round(newv, 8);
                log(" valeur {0} --> {1}", org, newv);
                att.Value = newv.ToString();
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
                string strDate = "";
                var attD = xml.Attributes["date"];
                if (attD != null)
                    strDate = attD.Value;
                bool exist = File.Exists(file);
                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void calcChoose(bool up, bool strict, bool checkSelect)
        {
            choose = null;
            double dt = double.MaxValue;
            double gap = double.MaxValue;
            // bool trou = false;
            foreach (AutoBuilderItem item in items)
            {
                item.after(up, strict, checkSelect);
                item.setTension(up, strict, checkSelect);
                if (item.Stop(_stopLevel))
                {
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }
                double aux = double.MaxValue;
                // var tension = item.Tension;
                if (conf.selectFix)
                {
                    var tension = item.Tension;
                    aux = up ? tension : -tension;
                }
                else
                    aux = item.Dt;

                if (conf.selectAbs && !conf.selectFix && aux < 0)
                    aux *= -1;



                if (item.getCauses().Count == 0)
                {
                    // trou = true;
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }

                //var _gap = Math.Abs(aux);
                //if (_gap < gap)
                //    gap = _gap;

                if (aux < dt)
                {
                    dt = aux;
                    newv = item.NewV;
                    choose = item;
                }
            }
            //if (trou && conf.gap && gap < double.MaxValue)
            //{
            //    foreach (AutoBuilderItem item in items)
            //    {
            //        if (item.Stop)
            //            continue;
            //        item.gap(up, conf.selectFix, gap);
            //    }
            //}
        }

        private bool check2()
        {
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


                //else if (choose != null)
                //    choose.makePertinent();
            }
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }

                total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                log("delta {0}", delta);

                if (_stopLevel < 0)
                {
                    log("arret cause stopLevel");
                    state = builderstate.stable;
                    return true;
                }
                if (delta * lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (choose != null && _stopLevel > 0)
                    {
                        log("retour arrière");
                        _stopLevel--;
                        choose.stop(_stopLevel);
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                    else
                    {
                        if (delta > 0)
                        {
                            // ok!
                            log("pas de retour arriere stoplevel=0");
                            state = builderstate.stable;
                            _empreinte = newEmpreinte;
                            return true;
                        }
                        else
                        {
                            _stopLevel--;
                            choose.stop(_stopLevel);
                            canGo = false;
                            mustUpdate = true;
                            return false;
                        }
                    }
                }
                lastDelta = delta;
                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            return true;
                        }
                    }
                }



                choose = null;
                if (_stopLevel >= 3 && conf.checkSelect && conf.checkStrict)
                    calcChoose(up, true, true);
                if (choose != null)
                    log("REEL - SELECT");
                else
                {
                    if (_stopLevel >= 2 && conf.checkSelect)
                        calcChoose(up, false, true);
                    if (choose != null)
                        log("VIRTUEL SELECT");
                    else
                    {
                        if (_stopLevel >= 1 && conf.checkStrict)
                            calcChoose(up, true, false);
                        if (choose != null)
                            log("REEL");
                        else
                        {
                            if (_stopLevel >= 0)
                            {
                                calcChoose(up, false, false);
                                if (choose != null)
                                    log("VIRTUEL");
                            }
                        }
                    }
                }


                if (choose == null)
                {
                    log("choose null");
                    _stopLevel--;
                    if (_stopLevel < 0)
                    {
                        state = builderstate.stable;
                        return true;
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                }

                org = choose.Org;



                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (conf.checkEvol)
                    {
                        // var nextTrack = choose.rejected(real).candidat;
                        var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
                        if (delta < size)
                        {
                            _stopLevel--;
                            // choose.stop();
                            if (conf.stopAll)
                            {
                                foreach (AutoBuilderItem item in items)
                                    item.stop(_stopLevel);
                                //state = builderstate.stable;
                                //return true;
                            }
                            else
                            {
                                choose.stop(_stopLevel);
                            }
                        }
                    }

                }
                else
                {
                }
                choose.save();
                Program.logAuto.log("===> " + choose.ToString());
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    bool exist = File.Exists(file);
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void init3()
        {
            _cause = null;


            foreach (AutoBuilderItem item in items)
                item.setTension();
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


            }
            mustUpdate = false;
            canGo = false;

            total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);

        }

        private bool check3()
        {
            // _modifFile = false; 

            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }



                if (_stopLevel < 0)
                {
                    log("arret cause stopLevel");
                    state = builderstate.stable;
                    return true;
                }
                var _lastDelta = lastDelta;
                lastDelta = delta;
                if (delta * _lastDelta < 0)
                {
                    //if (delta > 0)
                    //{
                    //    // ok!
                    //    state = builderstate.stable;
                    //    _empreinte = newEmpreinte;
                    //    return true;
                    //}
                    // retour arrière
                    if (delta > 0)
                    {
                        // ok!
                        log("pas de retour arriere stoplevel=0");
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        _stopLevel--;
                        foreach (AutoBuilderItem choose in chooses)
                        {
                            if (choose != null && _stopLevel > 0)
                            {
                                log("retour arrière");
                                choose.stop(_stopLevel);
                            }
                        }
                        return false;
                    }

                }

                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;
                if (up && delta < conf.delta)
                {
                    log("delta");
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                //if (delta * delta0 < 0)
                //{
                //    if (choose != null)
                //    {
                //        _stopLevel--;
                //        choose.stop(_stopLevel);
                //    }
                //    canGo = false;
                //    mustUpdate = true;
                //    return false;
                //}
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            return true;
                        }
                    }
                }

                if (_cause == null)
                {
                    log("_cause NULL");
                    state = builderstate.stable;
                    return true;

                }
                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                }

                var cdv = _cause.causes;
                chooses.Clear();
                foreach (CauseDataValue cd in cdv.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Update)
                        continue;

                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;
                    item.save(cd.val);
                    chooses.Add(item);

                }
                if (chooses.Count == 0)
                {
                    log("pas de choose");
                    state = builderstate.stable;
                    return true;

                }





            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    bool exist = File.Exists(file);
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }


        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder();
            sb.Append(string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9})", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
                sb.Append(item);
            sb.AppendLine();
            return sb.ToString();

        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************");
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            if (choose != null)
                type = choose.type.ToString();
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
            Program.logAuto.log("{0} {1} stop:{2}", name, type, _stopLevel.ToString());

            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);

            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                //   log(" valeur {0} --> {1}", org, newv);

                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log("");
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        private CauseRegister causeRegister = new CauseRegister();
        public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB_TYPE; i++)
            {
                var data = cd.datas[i];
                if (data == null) //|| data.virtuel)
                    continue;

                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].Virtuel = true;
                if (!cd.datas[i].Virtuel)
                    nb++;
            }

            //if (nb == 0)
            //    return; 

            causeRegister.signal(cd);
            if (nb > 1)
                checkCause(cd);

        }

        private CauseDatasTension _cause;
        private void checkCause(CauseDatas cause)
        {
            bool up = delta > 0;
            bool selected = cause.Selected;
            if (up && selected)
                return;
            if (!up && !selected)
                return;

            if (up)
            {
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel && !cd.Ok)
                        return;
                }

                double tot = 0;
                bool _checked = false; 
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (cd.Ok)
                        continue;
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (cd.val <= item.torg)
                        continue;

                    _checked = true; 

                    var tension = item.getTension(cd.val);
                    if (!conf.selectFix)
                    {
                        tension = item.Dt;
                    }

                    tot += (tension * tension);
                    if (_cause != null && tot >= _cause.tension)
                        return;

                    cd.Update = true;

                }
                if (tot >0 && _checked // (tot > 0 //COMMENT on peut avoir ZERO ???? et pourtant
                    && (_cause == null || tot < _cause.tension))
                    _cause = new CauseDatasTension(cause, tot);

            }
            else
            {
                //foreach (CauseDataValue cd in cause.datas)
                //{
                //    if (cd.Virtuel && cd.Ok)
                //        return;
                //}

                double aux = 0;
                double min = int.MaxValue;
                CauseDataValue cdMin = null;
                foreach (CauseDataValue cd in cause.datas)
                {
                    if (cd.Virtuel)
                        continue;
                    if (!cd.Ok)
                        continue;
                    var item = items.Find(it => it.type == cd.type);
                    if (item == null)
                        continue;

                    if (cd.val >= item.torg)
                        continue;

                    var tension = item.getTension(cd.val);
                    if (conf.selectFix)
                    {
                        aux = -tension;
                    }

                    else
                    {
                        aux = tension - item.Tension;
                        if (conf.selectAbs && aux < 0)
                            aux = -aux;
                    }


                    if (aux < min)
                    {
                        min = aux;
                        cdMin = cd;
                    }

                }
                if (cdMin == null)
                    return;

                if (_cause == null || _cause.tension > min)
                {
                    cdMin.Update = true;
                    _cause = new CauseDatasTension(cause, min);
                }

            }

        }



    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\FeedLimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using timeSpan = pdb.util.timeSpan;

namespace pdb.podcast.Load
{
    public enum loadState
    {
        loadCandidat,
        standAlone,
        selection,
        end
    }
    public enum depotType
    {
        load,
        rapporte
    }
    /// <summary>
    /// Chargeur des pistes associées à un item de limite sur un dossier
    /// </summary>
    class FeedLimitItemLoader
    {
        private loadState state;
        /// <summary>
        /// Répertoire
        /// </summary>
        private DirConf dir;
        /// <summary>
        /// Limite
        /// </summary>
        public readonly LimitItem limit;
        /// <summary>
        /// Album
        /// </summary>
        private string album;
        /// <summary>
        /// Chargeur de limite
        /// </summary>
        private LimitsLoader parent;


        /// <summary>
        /// Nombre de piste max
        /// </summary>
        int nbMax;
        int loadNbMax;
        /// <summary>
        /// Durée cumulée max
        /// </summary>
        timeSpan durationMax;
        timeSpan loadDurationMax;

        ///// <summary>
        ///// Date de publication min
        ///// </summary>
        //DateTime dateMin;

        // private Logger logger;
        private Logger logLimit;
        private Logger logItem;

        /// <summary>
        /// Durée cumulée
        /// </summary>
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtuel = new timeSpan();
        timeSpan durationStop = new timeSpan();
      



        /// <summary>
        /// Nombre total
        /// </summary>
        int nb = 0;
        int nbVirtuel = 0;
        int nbStop = 0;

        private bool? endByFd;
        public bool EndByFd { get { if (endByFd == null) return false; return endByFd.Value; } }

        private bool _okFd; public bool OkFd { get { return _okFd; } }
        private bool _okNb; public bool OkNb { get { return _okNb; } }


        public void phase2()
        {
            currentDuration = new timeSpan();
            //list = new List<TrackInfoItunes>();
            //selected = new BgDictString0<TrackInfoItunes>(); 
            currentDurationVirtuel = new timeSpan();
            durationStop = new timeSpan();
            nb = 0;
            nbVirtuel = 0;
            nbStop = 0;
            state = loadState.selection;
            endByFd = null;
            _indexForTotal = -1;
        }

        private int nbTest;
        private  timeSpan dureeTest;

        public void phaseTest()
        {
            nbTest = 0;
            dureeTest = new timeSpan(); 
        }
        public bool test( int _nbMax, timeSpan tsMax, TrackInfoItunes track)
        {
          
            nbTest++;
            dureeTest += track.Duree;
        
            return (nbTest <= _nbMax && dureeTest <= tsMax); 
        }


        //private bool loadEqSel;
        //public bool LoadEqSel { get { return loadEqSel; } }

        public FeedLimitItemLoader(LimitItem limit, string album, LimitsLoader parent)
        {
            this.dir = limit.Dir;
            this.limit = limit;

            this.parent = parent;
            this.album = album;


            nbMax = limit.Nb;


            var feedDuration = limit.FeedDuration;
            int rating = limit.Rating;
            durationMax = timeSpan.FromMinutes(feedDuration);


            loadDurationMax = durationMax;
            loadNbMax = nbMax;

            bool loadEqSeld = true;
            bool loadEqSeln = true;

            //if (limit.Dir.Cascading)
            //{
            if (limit.LoadNb > nbMax)
            {
                loadNbMax = limit.LoadNb;
                loadEqSeln = false;
            }
            if (limit.LoadFeedDuration > feedDuration)
            {
                loadDurationMax = timeSpan.FromMinutes(limit.LoadFeedDuration);
                loadEqSeld = false;
            }

            //}
            if (loadEqSeln)
                loadNbMax++;
            if (loadEqSeld)
                loadDurationMax = timeSpan.FromMinutes(loadDurationMax.TotalMinute + 200);

            logItem = Logger.getLogger(limit.ID + "\\" + album, null, false);
            logLimit = limit.Logger;
        }

        private void log(string txt)
        {
            logLimit.log(txt);
            logItem.log(txt);
        }

        private void log(string txt, params object[] other)
        {

            logLimit.log(txt, other);
            logItem.log(txt, other);
        }




        public timeSpan getCurrentDuration(bool real)
        {
            if (real)
                return currentDuration;
            return currentDurationVirtuel;
        }
        //  public void addTrackSuppl(TrackInfoItunes candidat) { durationForTotal += candidat.Duree; }
        //  public timeSpan DureeSupl { get { return durationForTotal; } }

        /// <summary>
        /// Quelle duree pour obtenir un nb d'éléménts et une durée min
        /// </summary>
        /// <param name="nb">nb d'éléments</param>
        /// <param name="fd">durée min</param>
        /// <returns></returns>
        //public timeSpan getTotalDurationFor(int nb, timeSpan fd)
        //{
        //    if (_indexForTotal > 0)
        //    {
        //    }
        //    timeSpan ret = new timeSpan();
        //    timeSpan aux = new timeSpan();

        //    int _nb = 0;
        //    int count = list.Count;
        //    for (int i = 0; i < count; i++)
        //    {
        //        var t = list[i];
        //        _nb++;
        //        aux += t.Duree;
        //        if (i >= _indexForTotal)
        //        {
        //            if (!selected.ContainsKey(t.Location))
        //            {
        //                if (_nb <= nb || aux <= fd)
        //                    ret += t.Duree;
        //                else
        //                {
        //                }

        //            }
        //            else
        //            {
        //            }
        //        }


        //        //if (_nb > nbMax && _nb > nb)
        //        //    return ret;
        //        //aux += t.Duree;
        //        //if (aux > durationMax && aux > fd)
        //        //    return ret;

        //        //if (i >= _indexForTotal)
        //        //{
        //        //    ret += t.Duree;
        //        //}
        //    }
        //    return ret;
        //}

        public timeSpan getDurationStop(bool real)
        {
            if (durationStop.Value == 0)
                return getCurrentDuration(real);
            return durationStop;
        }

        public int getNb(bool real)
        {

            if (real)
                return nb;
            return nbVirtuel;
        }
        public int getNbStop(bool real)
        {
            if (nbStop == 0)
                return getNb(real);
            return nbStop;
        }

        public int Nb { get { return nb; } }
        private int _indexForTotal = -1;
        public int IndexBase { get { return _indexForTotal; } set { _indexForTotal = value; } }
        public bool control(TrackInfoItunes track, bool select, bool real, bool increment, bool forTotal)
        {
            //if (state == loadState.end)
            //    return false;


            string location = track.Location;
            if (string.IsNullOrEmpty(location))
                return false;



            //     string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration.TotalMinutes.ToString("0"), track.ToString());
            string phase = select ? "ctl" : "load";

            if (!Logger.CreateNullLoggers)
            {
                string str = string.Format("{0} {1} {2} {3}", limit, nb, currentDuration, track.ToString());

                log("-->  {0} ok {1} ", phase, str);
            }

            var ok = checkStatus(string.Format("-->  {0}", phase), select, track, limit, real, increment, forTotal);

            if (!ok)
                return false;

            if (select && real && LimitItemLoader.ModeSelection)
            {
                var selected = selectMode.simple;
                if (dir.Histo)
                {
                    selected = selectMode.serial;
                    if (dir.HistoAll.HasValue && dir.HistoAll.Value)
                        selected = selectMode.histo;
                    if (dir.Serial)
                        selected = selectMode.serial;
                }
                else
                {
                    //if (!candidat.Serial && !candidat.Histo)
                    selected = selectMode.simple;
                }

                track.select(selected, limit);
                limit.Dir.Feeds.recordTrack(track, limit);
            }

            //report aux niveaux inférieurs
            if (real)
                parent.recordLimitItemCandidat(track, limit);
            return true;
        }




        private bool checkStatus(string phase, bool select, TrackInfoItunes track, LimitItem itemSource, bool real, bool increment, bool forTotal)
        {
            endByFd = null;
            _okFd = true;
            _okNb = true;
            bool ret = true;
            //        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration.TotalMinutes.ToString("0"), track.ToString());
            //nbVirtuel = nb;
            //currentDurationVirtuel = currentDuration; 
            if (forTotal && _indexForTotal < 0)
                _indexForTotal = nb;
            var nbBase = real ? nb : nbVirtuel;

            var _nb = nbBase + 1;
            var durationBase = real ? currentDuration : currentDurationVirtuel;
            var dur = durationBase + track.Duree;

            int _nbMax = select ? this.nbMax : this.loadNbMax;
            var _durationMax = select ? this.durationMax : this.loadDurationMax;

            if (_nb > _nbMax)
            {
                _okNb = false;
                if (real)
                {
                    if (LimitItemLoader.ModeSelection)
                        limit.NbFeedLimit = true;
                    if (!Logger.CreateNullLoggers)
                    {
                        string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
                        log("{0} stop nb {1} ", phase, str);
                    }
                    if (state != loadState.end)
                    {
                        state = loadState.end;
                        nbStop = _nb;
                    }
                }

                endByFd = false;
                ret = false;
            }



            // vérification des valeurs cumulées
            if (dur > _durationMax)
            {
                _okFd = false;
                if (real)
                {

                    if (!limit.DurationFeedLimit)
                    {
                        if (!Logger.CreateNullLoggers)
                        {
                            string str = string.Format("{0} {1} {2} {3} {4}", limit, itemSource, (nb), currentDuration, track.ToString());
                            log("{0} stop d. {1} ", phase, str);
                        }
                    }
                    if (LimitItemLoader.ModeSelection)
                        limit.DurationFeedLimit = true;
                    if (state != loadState.end)
                    {
                        state = loadState.end;
                        durationStop = dur;
                    }

                }

                //if (select || durationMax == loadDurationMax)
                //{
                //    if (ret)
                //    {
                //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, false);
                //        limit.signal(tb);
                //    }
                //    //limit.checkBorderFd(track, dur, false);
                //}

                if (endByFd == null)
                    endByFd = true;
                ret = false;
            }
            else
            {
                // endByFd = null;
                //if (select || durationMax == loadDurationMax)
                //{
                //    if (ret)
                //    {
                //        var tb = new TrackBorderItem(limit, track, borderType.fd, dur, true);
                //        limit.signal(tb);
                //    }
                //}
            }






            if (increment)
            {
                if (real)
                {
                    nb += 1;
                    currentDuration += track.Duree;

                 //   list.Add(track);
                    //if (ret)
                    //{
                    //    if (selected.ContainsKey(track.Location))
                    //    {
                    //    }
                    //    else
                    //    selected.Add(track.Location, track); 
                    //}
                }

                currentDurationVirtuel += track.Duree;
                nbVirtuel += 1;
            }
            return ret;

        }

    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Load\LimitItemLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.podcast.Tuning;
using pdb.util;
using pdb.util.list;
using pdb.podcast.Auto;
using pdb.podcast.Selection;
//using TimeSpan = pdb.util.timeSpan; 

namespace pdb.podcast.Load
{
    class LimitItemLoader
    {
        private static bool _selection;
        public static bool ModeSelection { get { return _selection; } set { _selection = value; } }
        private LimitItem limit;
        private LimitsLoader parent;
        private IDictionary<string, FeedLimitItemLoader> loaders = new BgDictString0<FeedLimitItemLoader>();
        //  public SequentialDictString<TrackInfoItunes> preloaded = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> standAlone = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacy = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> legacyRelax = new SequentialDictString<TrackInfoItunes>();
        private SequentialDictString<TrackInfoItunes> selected = new SequentialDictString<TrackInfoItunes>();
        public SequentialDictString<TrackInfoItunes> exclu = new SequentialDictString<TrackInfoItunes>();
        /// <summary>
        /// Ensemble des tracks chargés en premier par la limite
        /// </summary>
        public List<TrackInfoItunes> use = new List<TrackInfoItunes>();
        private Logger log;
        timeSpan currentDuration = new timeSpan();
        timeSpan currentDurationVirtual = new timeSpan();
        timeSpan durationStop = new timeSpan();
        timeSpan currentContrib = new timeSpan();
        timeSpan trackDurationMax;
        timeSpan trackDurationMin;



        List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> selectedByFd = new BgDictString0<TrackInfoItunes>();
        BgDictString0<TrackInfoItunes> manageByFd = new BgDictString0<TrackInfoItunes>();
        bool loadEqSel;

        public LimitItemLoader(LimitsLoader parent, LimitItem limit)
        {
            this.parent = parent;
            this.limit = limit;
            log = limit.Logger;

            trackDurationMax = timeSpan.FromMinutes(limit.Td);
            trackDurationMin = timeSpan.FromMinutes(limit.TdMin);
        }

        public void loadCandidats(List<TrackInfoItunes> _loaded)
        {
            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var duration = limit.Duration;
            //var _loadDuration = limit.LoadDuration; 
            loadEqSel = true;
            //if (limit.Dir.Cascading)
            //{
            var dd = limit.LoadDuration;
            if (dd > duration)
            {
                loadEqSel = false;
                duration = dd;
            }
            //}

            if (loadEqSel)
                duration += 200;


            //var duration = limit.LoadDuration;
            var durationMax = timeSpan.FromMinutes(duration);
            var dateMin = limit.DateMin;
            var dateMax = limit.DateMax;

            foreach (TrackInfoItunes candidat in _loaded)
            {
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                if (standAlone.ContainsKey(location))
                    continue;

                var d = candidat.Pub;
                if (d < dateMin)
                    continue;

                var duree = candidat.Duree;
                if (duree > trackDurationMax)
                    continue;
                if (duree < trackDurationMin)
                    continue;
                standAlone.Add(location, candidat);
                Exporter.Record(candidat);
                continue;

                //bool okDate = d <= dateMax;
                ////if (Conf.BorderVirtual)
                ////    limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, okDate, false));
                ////if (!okDate)
                ////    continue;
                ////  var tb = new TrackBorderItem(limit, candidat, borderType.m    axdate, candidat.Pub, okDate);
                ////  limit.signal(tb);

                ////if (Conf.BorderVirtual)
                ////{
                ////     var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, border.);
                ////      limit.signal(tb);
                ////}

                ////if (!okDate && !Conf.BorderVirtual)
                ////    continue;


                //var loader = getLoader(candidat.Album);
                //bool _control = loader.control(candidat, false, okDate);

                ////if (!_control && !Conf.BorderVirtual)
                ////    continue;

                //var currentDurationBase = (okDate && _control) ? currentDuration : currentDurationVirtual;
                //var newDuration = currentDurationBase + candidat.Duree;
                //bool okTotalDuration = newDuration <= durationMax;
                //bool selected = _control && okTotalDuration; //
                //bool okNb = loader.OkNb;

                //////question fd
                ////if (loader.LoadEqSel)
                ////{
                ////    var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                ////        loader.OkFd, loader.getDurationStop(okDate)
                ////        , okNb, loader.getNbStop(okDate)
                ////        , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

                ////    Program.CauseRegister.signal(dataRoot); 

                ////    var dataAuto =  new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                ////        loader.OkFd, loader.getCurrentDuration(okDate)
                ////        , okNb, loader.getNbStop(okDate)
                ////        , okTotalDuration, newDuration, candidat, limit);

                ////    limit.signal(dataAuto); 

                ////    //Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                ////    //    loader.OkFd, loader.getDurationStop(okDate)
                ////    //    , okNb, loader.getNbStop(okDate)
                ////    //    , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                ////    //limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                ////    //limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                ////    //limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));



                ////    if (okDate && _control && okTotalDuration)
                ////        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedStrict));
                ////    else if (okDate && okTotalDuration)
                ////    {
                ////        if (loader.EndByFd)
                ////            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedStrict));
                ////    }
                ////    else if (Conf.BorderVirtual)
                ////    {
                ////        if (_control)
                ////            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                ////        else if (loader.EndByFd)
                ////            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));
                ////    }


                ////    //if (!_control)
                ////    //{
                ////    //    if (okDate && okTotalDuration && loader.EndByFd)
                ////    //    {
                ////    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                ////    //        limit.signal(tb);
                ////    //    }
                ////    //    else if (Conf.BorderVirtual)
                ////    //    {
                ////    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                ////    //        limit.signal(tb);
                ////    //    }
                ////    //}
                ////}

                ////if (loadEqSel)
                ////{
                ////    // question d
                ////    if (okDate && _control && okTotalDuration)
                ////        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                ////    else if (okDate && _control)
                ////        limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                ////    else if (Conf.BorderVirtual)
                ////    {
                ////        if (okTotalDuration)
                ////            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                ////        else
                ////            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                ////    }
                ////    //if (!okTotalDuration)
                ////    //{
                ////    //    if (okDate && _control)
                ////    //    {
                ////    //        var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict);
                ////    //        limit.signal(tb);
                ////    //    }
                ////    //    else if (Conf.BorderVirtual)
                ////    //    {
                ////    //        var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight);
                ////    //        limit.signal(tb);
                ////    //    }
                ////    //}

                ////    // question date
                ////    if (okDate && _control && okTotalDuration)
                ////        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                ////    else if (_control && okTotalDuration)
                ////        limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                ////    else if (Conf.BorderVirtual)
                ////    {
                ////        if (okDate)
                ////            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                ////        else
                ////            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                ////    }

                ////}



                ////if (loadEqSel)
                ////{
                ////    if ((okDate && _control) || Conf.BorderVirtual)
                ////    {
                ////       var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okTotalDuration);
                ////        limit.signal(tb);
                ////    }
                ////}

                ////if ((okDate && _control))
                ////{                   
                ////    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okTotalDuration,true);
                ////    limit.signal(tb);
                ////}

                ////if (_control && okTotalDuration)
                ////{
                ////    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate);
                ////    limit.signal(tb);
                ////}

                ////if (okDate && okTotalDuration)
                ////{
                ////    if (!loader.limit.NbFeedLimit)
                ////    {
                ////        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.CurrentDuration, _control);
                ////        limit.signal(tb); 
                ////    }
                ////}

                //// limit.checkBorderDates(candidat, selected);

                //if (okDate && _control)
                //    currentDuration += candidat.Duree; // newDuration; //
                //currentDurationVirtual += candidat.Duree;

                //// preloaded.Add(location, candidat);
                //if (selected)
                //{
                //    //   standAlone.Add(location, candidat);
                //    candidat.select(selectMode.standAlone, limit);

                //}
                //else if (okDate && _control && !okTotalDuration)
                //{
                //    //if (!limit.LoadDurationLimitAtteinte)
                //    //    log.log("loadCandidats duréée limite atteinte {0}", (currentDuration)); //.TotalMinutes.ToString("0"));
                //    //limit.LoadDurationLimitAtteinte = true;
                //    if (durationStop.Value == 0)
                //    {
                //        durationStop = currentDuration;
                //    }
                //    // break;
                //}

                ////if (okDate && _control)
                ////    currentDuration = newDuration; // += candidat.Duree;
                ////   currentDurationVirtual += candidat.Duree;

            }

        }



        //private bool control(TrackInfoItunes track, bool select, bool real)
        //{
        //    var loader = getLoader(track.Album);
        //    return loader.control(track, select, real);
        //}

        private FeedLimitItemLoader getLoader(string album)
        {

            FeedLimitItemLoader loader = null;
            if (!loaders.ContainsKey(album))
            {
                loader = new FeedLimitItemLoader(limit, album, parent);
                loaders.Add(album, loader);
                if (parent.state == loadState.selection)
                    loader.phase2();
            }
            else
                loader = loaders[album];
            return loader;
        }

        public void phase2()
        {
            currentDuration = new timeSpan();
            currentDurationVirtual = new timeSpan();
            selectedByFd = new BgDictString0<TrackInfoItunes>();
            manageByFd = new BgDictString0<TrackInfoItunes>();

            if (_selection)
            {
                currentContrib = new timeSpan();
                limit.DurationLimitAtteinte = false;
                limit.ContributionLimitAtteinte = false;
                limit.DurationFeedLimit = false;
                limit.NbFeedLimit = false;
            }
            foreach (FeedLimitItemLoader loader in loaders.Values)
                loader.phase2();
        }

        public void recordGuest(TrackInfoItunes track, LimitItem itemSource)
        {
            if (itemSource == limit)
                return;
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            bool transmitTotal = limit.Dir.TransmitTotalGuest;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;


            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {

                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);
            }
        }

        public void recordTrackFromChild(TrackInfoItunes track, LimitItem itemSource, bool transmitTotal)
        {
            var location = track.Location;
            if (string.IsNullOrEmpty(location))
                return;
            //if (standAlone.ContainsKey(location))
            //    return;
            if (transmitTotal && legacy.ContainsKey(location))
                return;
            if (!transmitTotal && legacyRelax.ContainsKey(location))
                return;
            if (track.Duree <= trackDurationMax && track.Duree >= trackDurationMin) // && track.Pub >= dateMin)
            {
                if (transmitTotal)
                    legacy.Add(location, track);
                else
                    legacyRelax.Add(location, track);

            }
        }



        //private timeSpan getDuration(int nb, timeSpan minfd)
        //{
        //    timeSpan tot = new timeSpan();
        //    foreach (FeedLimitItemLoader feed in loaders.Values)
        //    {
        //        tot += feed.getTotalDurationFor(nb, minfd);
        //    }
        //    return tot;
        //}

        public void Selection()
        {

            if (limit.Nb == 0 || limit.FeedDuration == 0 || limit.Duration == 0)
                return;

            var histo = limit.Dir.Histo;

            var relax = legacyRelax.List;
            if (relax.Count > 0)
            {
            }

            if (histo)
                relax.Sort(new PodCastComparer());
            else
                relax.Sort(new PodCastComparerInv());
            selection(relax, false, false);

            var list = legacy.List;
            if (histo)
                list.Sort(new PodCastComparer());
            else
                list.Sort(new PodCastComparerInv());

            selection(list, false, true);



            var list2 = standAlone.List;
            if (histo)
                list2.Sort(new PodCastComparer());
            else
                list2.Sort(new PodCastComparerInv());

            selection(list2, true, true);

        }

        private void selection(List<TrackInfoItunes> list, bool select, bool increment)
        {
            var duration = limit.Duration;
            var durationMax = timeSpan.FromMinutes(duration);
            var contributionMax = timeSpan.FromMinutes(limit.Contribution);

            int count = list.Count;
            for (int index = 0; index < count; index++)
            {
                TrackInfoItunes candidat = list[index];
                //foreach (TrackInfoItunes candidat in list)
                //{

                if (candidat.Album == "Géopolitique")
                {
                }
                var location = candidat.Location;
                if (string.IsNullOrEmpty(location))
                    continue;

                //if (_selection && selected.ContainsKey(location))
                //    continue;
                // vérification à postériori par rapports aux différents niveaux
                bool newContribut = candidat.Selected;

                var d = candidat.Pub;
                bool okDate = d <= limit.DateMax;
                var loader = getLoader(candidat.Album);
                bool okTotalDuration = false;
                bool _control = false;

                //tester uniquement fd et nb
                // _control = loader.control(candidat, select, false, false);

                // var _newDuration = currentDuration;
                //if (increment)
                //    _newDuration = currentDuration + candidat.Duree;

                // savoir si ça passe uniquement avec le critère d
                okTotalDuration = currentDuration <= durationMax;

                bool okprovi = okDate && okTotalDuration;
                bool ok = okDate && okTotalDuration && _control;

                // rejouer le controle pour incrémenter nb et fd      
                if (!increment) // données venant de sous-dossier (histo, voisins....)
                {
                    _control = loader.control(candidat, select, okDate && okTotalDuration, true, false);
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                }



                //if (!loader.LoadEqSel)
                //{

                //    if (_control)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight));
                //    else if (loader.EndByFd)
                //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight));

                //}

                //if (!increment && !_selection) //!loader.LoadEqSel &&
                //{
                //    //  if (!loader.OkNb)
                //    //  Program.CauseRegister.Get(candidat).check(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNb(okDate)), limit);
                //    // if (!loader.OkFd)
                //    // Program.CauseRegister.Get(candidat).check(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit);

                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkNb, borderType.nb, timeSpan.FromMinutes(loader.getNbStop(okDate)), limit, candidat));
                //    limit.Dir.CauseRegister.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getDurationStop(okDate), limit, candidat));

                //    limit.signal(new CauseDatas(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                //    limit.signal(new CauseDatas(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                //}

                //if (!control(candidat, select, okDuration))
                //    continue;

                if (increment)
                {
                    if (manageByFd.ContainsKey(location))
                    {
                        _control = false;
                        if (selectedByFd.ContainsKey(location))
                            _control = true;
                    }
                    else
                    {
                        _control = loader.control(candidat, select, true, true, true);
                        loader.IndexBase = index;
                    }



                    // si les deux autres sont bons, incrémenter la durée totale
                    var newDuration = currentDuration;
                    if (!manageByFd.ContainsKey(location))
                    {
                        if (_control)
                        {
                            currentDurationVirtual += candidat.Duree;
                            if (okDate)
                                currentDuration += candidat.Duree;
                        }
                    }
                    newDuration = currentDurationVirtual; 
                    if (_control && !selectedByFd.ContainsKey(location))
                        selectedByFd.Add(location, candidat);
                    if (!manageByFd.ContainsKey(location))
                        manageByFd.Add(location, candidat);
                    okTotalDuration = newDuration <= durationMax;

                

                    //okTotalDuration = newDuration <= durationMax;
                    //_control = loader.control(candidat, select, okDate && okTotalDuration, true,true);

                    //if (okDate && _control)
                    //    currentDuration += candidat.Duree;
                    //currentDurationVirtual = currentDuration; // += candidat.Duree;

                    //var newDuration = okDate && _control ? currentDuration : currentDurationVirtual;

                    //  bool okTotalDuration = newDuration <= durationMax;

                    if (!_selection)
                    {

                        if (_control)
                        {
                        }
                        else
                        {
                            var fd = loader.getCurrentDuration(true);
                            var nb = loader.getNb(true);

                            newDuration = new timeSpan();
                            foreach (FeedLimitItemLoader l in loaders.Values)
                                l.phaseTest();
                            for (int j = 0; j <= index; j++)
                            {
                                TrackInfoItunes t = list[j];
                                var subloader = getLoader(t.Album);
                                var subok = subloader.test(nb, fd, t);
                                if (j >= subloader.IndexBase)
                                {
                                    if (subok || selectedByFd.ContainsKey(location))
                                        newDuration += t.Duree;
                                }

                            }
                            // newDuration += getDuration(nb, fd);

                            if (newDuration < currentDuration)
                            {
                            }
                            else if (newDuration > currentDurationVirtual)
                            {
                            }
                            okTotalDuration = newDuration <= durationMax;
                        }


                        //question fd
                        //if (!loader.LoadEqSel)
                        //{
                        var dataRoot = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                      loader.OkFd, loader.getDurationStop(okDate)
                      , loader.OkNb, loader.getNbStop(okDate)
                      , okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, candidat, limit);

                        limit.Dir.CauseRegister.signal(dataRoot);

                        var dataAuto = new CauseDatas(okDate, new timeSpan(d - Conf.Date0),
                            //loader.OkFd, loader.getCurrentDuration(okDate && okTotalDuration)
                            //, loader.OkNb, loader.getNb(okDate && okTotalDuration)
                            //, okTotalDuration, newDuration, candidat, limit);
                                loader.OkFd, loader.getCurrentDuration(true)
                        , loader.OkNb, loader.getNb(true)
                        , okTotalDuration, newDuration, candidat, limit);

                        limit.signal(dataAuto);
                    }




                    //   Program.CauseRegister.Get(candidat).check(okDate, new timeSpan(d - Conf.Date0),
                    //loader.OkFd, loader.getDurationStop(okDate)
                    //, loader.OkNb, loader.getNbStop(okDate)
                    //, okTotalDuration, durationStop.Value == 0 ? newDuration : durationStop, limit);

                    //   limit.signal(new CauseData(okDate, borderType.maxdate, new timeSpan(d - Conf.Date0), limit, candidat));
                    //   limit.signal(new CauseData(loader.OkFd, borderType.fd, loader.getCurrentDuration(okDate), limit, candidat));
                    //   limit.signal(new CauseData(okTotalDuration, borderType.d, newDuration, limit, candidat));

                    if (Conf.BorderTb)
                    {
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict));
                        else if (okDate && okTotalDuration)
                        {
                            if (loader.EndByFd)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict));
                        }
                        //else if (Conf.BorderVirtual)
                        //{
                        //    if (_control)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedLight));
                        //    else if (loader.EndByFd)
                        //        limit.signal(new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedLight));
                        //}


                        //}

                        //if (!loadEqSel)
                        //{
                        // question d
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedStrict));
                        else if (okDate && _control)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okTotalDuration)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.d, newDuration, borderStatus.rejectedLight));
                        }


                        // question date
                        if (okDate && _control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedStrict));
                        else if (_control && okTotalDuration)
                            limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedStrict));
                        else if (Conf.BorderVirtual)
                        {
                            if (okDate)
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.selectedLight));
                            else
                                limit.signal(new TrackBorderItem(limit, candidat, borderType.maxdate, d, borderStatus.rejectedLight));
                        }

                        //}

                    }


                    ////question duree
                    //if (okDate && _control) // || Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, true); limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.d, newDuration, okDuration, false); limit.signal(tb);
                    //}

                    ////question fd

                    //if (_control)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.selectedStrict); limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.selectedLight); limit.signal(tb);

                    //    }
                    //}
                    //else //if (!loader.limit.NbFeedLimit)
                    //{
                    //    if (okDate && okDuration)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(true), borderStatus.rejectedStrict);
                    //        limit.signal(tb);
                    //    }
                    //    else if (Conf.BorderVirtual)
                    //    {
                    //        var tb = new TrackBorderItem(limit, candidat, borderType.fd, loader.getCurrentDuration(okDate), borderStatus.rejectedLight);
                    //        limit.signal(tb);
                    //    }
                    //}
                    ////question date
                    //if (_control && okDuration)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, true);
                    //    limit.signal(tb);
                    //}
                    //else if (Conf.BorderVirtual)
                    //{
                    //    var tb = new TrackBorderItem(limit, candidat, borderType.maxdate, candidat.Pub, okDate, false);
                    //    limit.signal(tb);
                    //}



                    //if (!_control && !Conf.BorderVirtual)
                    //    continue;
                    if (!okDate)
                        continue;

                    if (!_control)
                        continue;
                    if (!okTotalDuration)
                    {
                        if (!Logger.CreateNullLoggers)
                            log.log("duration {0}", (newDuration)); //.TotalMinutes.ToString("0"));

                        if (_selection)
                            limit.DurationLimitAtteinte = true;
                        if (durationStop.Value == 0)
                        {
                            // currentDuration = newDuration;
                            durationStop = currentDuration;
                        }

                    }

                    if (!okTotalDuration)
                        continue;


                    if (_selection && !newContribut)
                    {
                        // pour l'instant ? on ne gère pas la contribtion en mode rejeu

                        currentContrib += candidat.Duree;
                        if (currentContrib > contributionMax)
                        {
                            log.log("contribution {0}", (currentContrib)); //.TotalMinutes.ToString("0"));
                            limit.ContributionLimitAtteinte = true;
                            break;
                        }

                        use.Add(candidat);
                    }

                    //   currentDuration = newDuration;




                    if (_selection)
                    {
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        limit.Dir.recordTrack(candidat, limit);
                        // enregistrement pour stockage et stats // et NON ! en plus gestion de la propagation des sous-répertoires vers les répertoires parent
                        //  limit.Dir.recordTrack(candidat, limit);

                        selected.Add(location, candidat);

                        if (select)
                            exclu.Add(location, candidat);
                    }





                }

            }
        }

        public LimitItem Item { get { return limit; } }

    }
}
]]></content>
  </file>
</db>
