<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.podcast\Exporter.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.podcast.Tuning;
using pdb.util;

namespace pdb.podcast
{
    class Exporter
    {
        enum state
        {
            none,
            record,
            copy,

        }
        private Exporter()
        {
        }
        static Exporter Instance = new Exporter();
        BgDictString<TrackInfoItunes> dict = new BgDictString<TrackInfoItunes>();
        List<TrackInfoItunes> list = new List<TrackInfoItunes>();
        private state status;

        DirectoryInfo dirDest = null;
        string dirDestPath = "";
        const string PODCASTS = "podcasts";
        const string ZIQUE = "zique";

        public static void TopRecord() { Instance.topRecord(); }
        public static void TopCopy() { Instance.topCopy(); }
        public static void Record(TrackInfoItunes track) { Instance.record(track); }

        void topRecord()
        {
            var dest = Conf.Export;
            if (string.IsNullOrEmpty(dest))
            {
                status = state.none;
                return;
            }
            this.dirDest = new DirectoryInfo(dest);
            this.dirDestPath = dirDest.FullName + Path.DirectorySeparatorChar;
            if (status == state.none)
                status = state.record;
        }

        void record(TrackInfoItunes track)
        {
            if (status != state.record)
                return;
            dict[track.Location] = track;
        }
        void topCopy()
        {
            if (status != state.record)
                return;
            status = state.copy;
            list = new List<TrackInfoItunes>(dict.Values);
            list.Sort(new PodCastComparer());
            new Thread(loop).Start();

        }

        private void checkDir(BgDictString0<bool> dict, DirectoryInfo dir)
        {
            if (status != state.copy)
                return;
            foreach (FileInfo f in dir.GetFiles())
            {
                if (status != state.copy)
                    return;
                dict.Add(f.FullName.getShortPath(PODCASTS, ZIQUE), false);
            }

            foreach (DirectoryInfo sub in dir.GetDirectories())
            {
                if (status != state.copy)
                    return;
                checkDir(dict, sub);
            }
        }

        private void loop()
        {
            int i = 0;
            int count = list.Count;
            try
            {
                var d = new BgDictString0<bool>();
                checkDir(d, dirDest);

                foreach (TrackInfoItunes t0 in list)
                {
                    if (status != state.copy)
                        return;
                    var shortPath = t0.Location.getShortPath(PODCASTS, ZIQUE);
                    d[shortPath] = true;
                }

                foreach (KeyValuePair<string, bool> kvp in d.getKeyValuePairs())
                {
                    if (status != state.copy)
                        return;
                    if (!kvp.Value)
                    {
                        string fdest = dirDestPath + kvp.Key;
                        misc.log("suppression de {0}", fdest);
                        File.Delete(fdest);
                    }
                }
                while (i < count && status == state.copy)
                {
                    try
                    {
                        TrackInfoItunes t = list[i];
                        FileInfo f = new FileInfo(t.Location);
                        var shortPath = f.FullName.getShortPath(PODCASTS, ZIQUE);
                        string fdest = dirDestPath + shortPath;
                        if (!File.Exists(fdest))
                        {
                            misc.log("copie de {0}", t);
                            f.copyTree(fdest, null);
                        }

                        i++;
                    }
                    catch (System.IO.IOException ioe)
                    {
                        misc.log(ioe.ToString());
                        if (ioe.Message.Contains("space"))
                        {
                            status = state.none;
                        }
                    }

                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                    }

                }
            }

            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
            finally
            {
                status = state.none;
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilder.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using pdb.podcast.Tuning;
using pdb.podcast.Report;
using pdb.podcast.Selection;
namespace pdb.podcast.Auto
{

    enum builderstate
    {
        none,
        enCours,
        stable
    }
    class AutoBuilder : IComparable<AutoBuilder>, IBorderTransmit
    {
        const char SEP = '\t';
        const string DAT = @"..\Data\";
        string file = "";
        private bool mustUpdate; public static bool MustUpdate = false;
        private double total = -1;
        private double delta;
        private double lastd;
        private double d;
        private double org;
        private double newv;
        private bool canGo;
        //private int lastGoodDelta;
        //private double lastGoodLevel;
        private int lastTotal;
        private int atomicMode;
        private int sameConfiguration;
        private double cmin;
        private double cmax;
        private double dmin;
        private double dmax;
        public const double EPSILON = 1e-10;
        //private bool dminAlready;
        //private bool dmaxAlready;
        private string _empreinte = "";
        private double delta0 = 0;
        private double lastDelta = 0;
        private Memory mem0;
        private Memory mem1;
        private Memory minMem;
        private Memory maxMem;
        private StringBuilder sb = new StringBuilder();
        // private static DateTime lastModif;
        private pdb.podcast.Tuning.Auto conf;
        private static List<AutoBuilder> list = new List<AutoBuilder>();
        private static int index;
        private IBuilderSource source; public IBuilderSource Source { get { return source; } }

        private LimitItemBase client;
        private static XmlElement xmlRoot;
        private static XmlDocument doc;
        private static bool started = false;
        private string name = "";
        private builderstate state;
        private int naturalOrder = 1;
        private List<AutoBuilderItem> items = new List<AutoBuilderItem>();
        private AutoBuilderItem choose;
        public const int STOP_MAX = 3;
        private int _stopLevel = STOP_MAX;



        private AutoBuilder(pdb.podcast.Tuning.Auto conf)
        {
            this.conf = conf;
            this.name = conf.name;
            mem0 = new Memory(DAT + "v." + conf.name + ".db.txt");
            mem1 = new Memory(DAT + "r." + conf.name + ".db.txt");
            this.file = DAT + "auto." + conf.name + ".log";
            foreach (pdb.podcast.Tuning.Auto sub in conf.items)
            {
                var item = new AutoBuilderItem(this, sub);
                items.Add(item);
            }
        }
        private void setConf(pdb.podcast.Tuning.Auto value)
        {

            conf = value;
            for (int i = 0; i < items.Count && i < conf.items.Count; i++)
            {
                items[i].setConf(conf.items[i]);
            }

        }

        private void setSource(IBuilderSource source)
        {
            this.source = source;
            source.addBorderObs(this);
        }
        private static AutoBuilder main;
        public static void build(XmlNode xAuto, IBuilderSource source)
        {
            if (xAuto is XmlElement)
            {
                var conf = new pdb.podcast.Tuning.Auto(null, null, xAuto as XmlElement);
                var name = conf.name;
                AutoBuilder builder = list.Find(a => a.name == name);
                if (builder == null)
                {
                    builder = new AutoBuilder(conf);
                    list.Add(builder);
                    builder.naturalOrder = list.Count;
                    index = list.Count - 1;
                    if (main == null)
                        main = builder;
                }
                builder.setConf(conf);
                builder.setSource(source);

            }
        }
        public static void setClient(LimitItemBase client, XmlNode node)
        {
            var att = node.Attributes["auto"];
            if (att == null)
                return;
            var name = att.Value;
            AutoBuilder builder = list.Find(a => a.name == name);
            if (builder == null)
                return;
            builder.client = client;

        }
        private void makeDelta(Memory mem, string mode, string file)
        {
            if (!File.Exists(file))
                File.WriteAllText(file, "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate\tAdd\tiAdd\ttSupp\tiSup\t\r\n");
            mem.load();
            var listSe = source.getSelectedTracks();
            var loaded = source.getAllTracks();
            if (mem.Loaded)
            {
                var auxDixt = new pdb.util.BgDictString<TrackInfoItunes>(); // BgDictString<string, TrackInfoItunes>();
                foreach (TrackInfoItunes s in listSe)
                {
                    var key = s.Location;
                    auxDixt[key] = s;
                    if (!mem.dict.ContainsKey(key))
                    {
                        var desc = new TrackItemdesc(s.ToString(), s.GetProvider());
                        string line = desc.ToString();
                        mem.ajouts.Add(desc);
                        mem.tajouts.Add(s);
                        sb.AppendLine(string.Format("{0} delta {1} ajouté {2}", name, mode, line));
                    }
                }
                foreach (string key in mem.dict.Keys)
                {
                    if (!auxDixt.ContainsKey(key))
                    {
                        var line = mem.dict[key];
                        mem.suppressions.Add(line);
                        if (loaded.ContainsKey(key))
                        {
                            var t = loaded[key];
                            mem.tsuppressions.Add(t);
                        }
                        sb.AppendLine(string.Format("{0} delta {1} supprimé {2}", name, mode, line));
                    }
                }
                if (mem.ajouts.Count > 0 || mem.suppressions.Count > 0)
                {
                    int imax = Math.Max(mem.ajouts.Count, mem.suppressions.Count);
                    using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                    {
                        //if (!exist)
                        //    tw.WriteLine("quand\tdiff\tcorr\torg\tnew\tAdd\tiAdd\ttSupp\tiSup");
                        tw.Write(DateTime.Now); tw.Write(SEP);
                        tw.Write((delta).ToString("0.###")); tw.Write(SEP);
                        tw.Write(d.ToString("0.###")); tw.Write(SEP);
                        tw.Write(org.ToString("0.###")); tw.Write(SEP);
                        tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                        tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                        tw.Write(atomicMode); tw.Write(SEP);
                        tw.Write(state); tw.Write(SEP);
                        for (int i = 0; i < imax; i++)
                        {
                            if (i > 0)
                            {
                                tw.WriteLine();
                                for (int j = 0; j < 11; j++)
                                    tw.Write(SEP);
                            }
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].track);
                            tw.Write(SEP);
                            if (i < mem.ajouts.Count)
                                tw.Write(mem.ajouts[i].item);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].track);
                            tw.Write(SEP);
                            if (i < mem.suppressions.Count)
                                tw.Write(mem.suppressions[i].item);
                            tw.Write(SEP);
                        }
                        tw.WriteLine();
                    }
                }
            }
            mem.save(listSe);
        }
        private void reset()
        {
            atomicMode = -1;
            cmin = 0;
            cmax = int.MaxValue;
            dmin = int.MaxValue;
            dmax = -dmin;
            //dminAlready = false;
            //dmaxAlready = false;
            minMem = null;
            maxMem = null;
            sameConfiguration = 0;
            _empreinte = "";
            delta0 = 0;
            lastDelta = 0;
            state = builderstate.none;
            foreach (AutoBuilderItem item in items)
                item.reset();
            _stopLevel = STOP_MAX;
        }
        private static void decrementIndex()
        {
            index--;
            if (index < 0)
                index = list.Count - 1;
        }
        //  private bool _modifFile; 

        public static bool Stable
        {
            get
            {

                foreach (AutoBuilder builder in list)
                    if (builder.state != builderstate.stable)
                        return false;
                return true;
            }
        }

        public static void init(bool first)
        {
            if (list.Count == 0)
                return;
            list.Sort();
            bool firstWIthTb = first && Conf.BorderTb;
            bool secondwithoutTb = !first && !Conf.BorderTb;
            bool readXml = firstWIthTb || secondwithoutTb;
            FileInfo f = null;
            if (readXml)
            {
                f = Conf.Instance.ConfFile;
                doc = new XmlDocument();
                doc.PreserveWhitespace = true;
                doc.Load(f.FullName);
                xmlRoot = doc.DocumentElement.SelectSingleNode("./dir") as XmlElement;
            }

            bool _modifFIle = false;
            foreach (AutoBuilder builder in list)
            {
                if (readXml)
                    builder.setValueOrg();
                if (first)
                    builder.causeRegister.Clear();
                if (builder.ToSave() && readXml)
                    _modifFIle = true;
            }

            if (_modifFIle)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }
        }

        private bool ToSave()
        {
            foreach (AutoBuilderItem item in items)
            {
                if (item.ToSave)
                    return true;
            }
            return false;
        }

        public void setValueOrg()
        {

            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return;
            foreach (AutoBuilderItem item in items)
                item.setOrg(xml);
        }
        public static bool Check(Feeds feeds)
        {
            if (list.Count == 0)
                return true;
            list.Sort();
            FileInfo f = Conf.Instance.ConfFile;

            bool _cango = true;
            MustUpdate = false;
            bool _modifFile = false;
            if (Conf.AutoSequence)
            {
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    var builder = list[i];
                    main = builder;
                    var cango = builder.check2();
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (builder.newv != builder.org || builder.ToSave())
                    {
                        _modifFile = true;
                    }
                    if (!cango || MustUpdate || _modifFile)
                        break;
                }
                if (i > 0)
                    _cango = false;
            }
            else
            {
                AutoBuilder builder = null;
                if (!started)
                {
                    started = true;
                    foreach (AutoBuilder b in list)
                        b.total = b.source.getTotalSize();
                }
                // application de la précédente modif
                builder = list[index];
                if (builder.state > builderstate.none)
                {
                    builder.makeEmpreinteNonSequence();
                    decrementIndex();
                }
                int i = -1;
                for (i = list.Count - 1; i >= 0; i--)
                {
                    builder = list[i];
                    bool cango = false;
                    bool _cont = false;
                    while (true)
                    {
                        if (i == index || _cont)
                        {
                            cango = builder.check();
                            index = i;
                            main = builder;
                            _cont = false;
                            break;
                        }
                        else
                            cango = builder.checkWithoutModify();
                        if (builder.state == builderstate.none)
                            _cont = true;
                        else
                            break;
                    }
                    if (!cango)
                        _cango = false;
                    if (builder.mustUpdate)
                        MustUpdate = true;
                    if (i == index)
                    {
                        if (builder.newv != builder.org)
                        {
                            _modifFile = true;
                        }
                        else
                        {
                            //index--;
                            //if (index < 0)
                            //    index = list.Count - 1;
                        }
                    }
                    if (_modifFile)
                        break;
                }
            }
            if (_modifFile)
            {
                f.CopyTo(f.FullName + ".sov", true);
                doc.Save(f.FullName);
            }

            foreach (AutoBuilder builder in list)
            {
                if (builder.state == builderstate.none)
                    _cango = false;
            }
            return _cango;
        }


        private void log(string txt)
        {
            Program.logAuto.log(string.Format("{0}", txt));
        }
        private void log(string txt, params object[] args)
        {
            string _txt = string.Format(txt, args);
            log(_txt);
        }
        private void makeEmpreinteNonSequence()
        {
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
            }
            _empreinte = newEmpreinte;
            total = source.getTotalSize();
        }
        private bool checkWithoutModify()
        {
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            try
            {
                if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }
                else
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                }
                if (Conf.AutoSequence || total < 0)
                    total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                if (delta >= 0)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                }
                else if (delta < 0)
                {
                    mustUpdate = true;
                    canGo = false;
                }
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
            }
            return canGo;
        }
        private bool check()
        {
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();
            if (state == builderstate.none)
                reset();
            else if (state == builderstate.stable)
            {
                if (newEmpreinte != _empreinte)
                    reset();
                else
                {
                    mustUpdate = false;
                    canGo = true;
                    org = newv;
                    return true;
                }
            }
            if (Conf.AutoSequence || total < 0)
                total = source.getTotalSize();
            double target = conf.target;
            delta = target - total;
            log("delta {0}", delta);
            if (state == builderstate.none)
                delta0 = delta;
            state = builderstate.enCours;
            lastd = d;
            d = 0;
            xml = null;
            lookup(xmlRoot);
            if (xml == null)
                return true;
            string attTarget = conf.type.ToString();
            var att = xml.Attributes[attTarget];
            if (att == null)
                return true;
            org = Convert.ToDouble(att.Value);
            newv = org;
            try
            {
                if (delta * delta0 < 0)
                {
                    if (atomicMode < 0)
                    {
                        atomicMode = 0;
                        //if (minMem == null)
                        //    minMem = new Memory(mem0);
                        //if (maxMem == null)
                        //    maxMem = new Memory(mem0);
                        //if (minMem.suppressions.Count == 0)
                        //    minMem.suppressions = new List<TrackItemdesc>(maxMem.ajouts);
                        //if (maxMem.ajouts.Count == 0)
                        //    maxMem.ajouts = new List<TrackItemdesc>(minMem.suppressions);
                    }
                }
                bool cancelSameConf = false;
                bool cancelNb = false;
                if (atomicMode >= 0)
                {
                    atomicMode++;
                    if (Math.Abs(dmin - delta) < EPSILON)
                        sameConfiguration++;
                    else if (Math.Abs(dmax - delta) < EPSILON)
                        sameConfiguration++;
                    else
                        sameConfiguration = 0;
                    if (sameConfiguration > conf.idem)
                        cancelSameConf = true;
                    if (atomicMode > conf.cloop)
                        cancelNb = true;
                }
                if (delta >= 0)
                {
                    if (mem0.suppressions.Count > 0)
                        minMem = new Memory(mem0);
                    if (delta < conf.write)
                        canGo = true;
                    //  lastGoodLevel = org;
                    //if (maxMem != null && minMem != null)
                    //{
                    if (atomicMode > 0)
                    {
                        if (cancelSameConf) //|| (mem0.suppressions.Count == 1 && mem0.ajouts.Count ==0))
                        {
                            log("abandon recherche cartésienne cause idem");
                            state = builderstate.stable;
                            return true;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            state = builderstate.stable;
                            return true;
                        }
                        //if (Math.Abs(dmin - delta) < 0.01)
                        //    dminAlready = true;
                        //else
                        //    dminAlready = false;
                        if (maxMem != null && minMem != null)
                        {
                            if (minMem.suppressions.Count == maxMem.ajouts.Count)
                            {
                                bool identique = true;
                                for (int i = 0; i < minMem.suppressions.Count; i++)
                                {
                                    if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                    {
                                        identique = false;
                                        break;
                                    }
                                }
                                if (identique)
                                {
                                    if (minMem.suppressions.Count == 1 || atomicMode > conf.verif)
                                    {
                                        mustUpdate = false;
                                        log("abandon recherche cartésienne cause cycle");
                                        state = builderstate.stable;
                                        _empreinte = newEmpreinte;
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    cmin = org;
                    dmin = delta;
                    // lastGoodDelta = (int)delta;
                    lastTotal = (int)total;
                    if (delta < conf.delta)
                    {
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    mustUpdate = true;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        //if (atomicMode > conf.cloop)
                        //{
                        //    mustUpdate = false;
                        //    log("abandon recherche cartésienne cause cloop");
                        //    state = builderstate.stable;
                        //    _empreinte = newEmpreinte;
                        //    return true;
                        //}
                        //if (dminAlready && dmaxAlready)
                        //{
                        //    mustUpdate = false;
                        //    Program.logAuto.log("abandon recherche cartésienne cause cycle");
                        //    return true;
                        //}
                        d = 0.5 * (cmax - cmin);
                    }
                    else
                    {
                        double _d = int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmax - cmin;
                        double aux = int.MaxValue;
                        // double aux2 = int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - level.d) * level.inf;
                            if (aux > d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {

                            if (org > conf.max)
                                d = conf.max - org;
                            else
                            {
                                d *= conf.coeff * (conf.max - org) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target + de) * (conf.max - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 < d)
                        //    d = aux2;

                        if (d > _d)
                            d = _d;
                    }
                }
                else if (delta < 0)
                {
                    if (mem0.ajouts.Count > 0)
                        maxMem = new Memory(mem0);
                    mustUpdate = true;
                    canGo = false;
                    //if (maxMem != null && minMem != null)
                    //{
                    //    if (atomicMode < 0)
                    //        atomicMode = 0;
                    //    atomicMode++;
                    //}
                    cmax = org;
                    dmax = delta;
                    d = 0;
                    if (atomicMode > 0)
                    {
                        bool identique = false;
                        if (minMem != null && maxMem != null
                            && maxMem.ajouts.Count == minMem.suppressions.Count)
                        {
                            identique = true;
                            for (int i = 0; i < minMem.suppressions.Count; i++)
                            {
                                if (!minMem.suppressions[i].Equals(maxMem.ajouts[i]))
                                {
                                    identique = false;
                                    break;
                                }
                            }
                        }
                        if (cancelSameConf)// || (mem0.ajouts.Count == 1 && mem0.suppressions.Count == 0))
                        {
                            log("retour derniere bonne valeur cause idem");
                            d = cmin - cmax;
                        }
                        else if (cancelNb)
                        {
                            log("abandon recherche cartésienne cause cloop");
                            d = cmin - cmax;
                        }
                        else if (identique && (minMem.suppressions.Count == 1 || atomicMode > conf.verif))
                        {
                            log("retour derniere bonne valeur cause cycle");
                            d = cmin - cmax;
                        }
                        //else if (atomicMode > conf.cloop)
                        //{                      
                        //    log("abandon recherche cartésienne cause cloop");
                        //    d = cmin - cmax;
                        //}
                        else
                            d = 0.5 * (cmin - cmax);
                    }
                    else
                    {

                        double _d = -int.MaxValue;
                        if (cmax >= 0 && cmin >= 0)
                            _d = cmin - cmax;
                        double aux = -int.MaxValue;
                        // double aux2 = -int.MaxValue;
                        foreach (Level level in conf.levels)
                        {
                            aux = (delta - conf.delta + level.d) * level.sup;
                            if (aux < d)
                                d = aux;
                        }
                        if (conf.coeff > 0)
                        {
                            if (org < conf.min)
                                d = (conf.min - org);
                            else
                            {
                                d *= conf.coeff * (org - conf.min) / (conf.max - conf.min);
                            }
                            //else
                            //{
                            //    var de = Math.Abs(delta);
                            //    aux2 = de / (target+de) * (conf.min - org) * conf.coeff;
                            //}
                        }

                        //if (d == 0 || aux2 > d)
                        //    d = aux2;

                        if (d < _d)
                            d = _d;
                    }
                    //d = (delta - conf.delta) * conf.sup;
                    //if (org <= lastGoodLevel)
                    //{
                    //    lastGoodLevel = -1;
                    //    lastGoodDelta = -1;
                    //    lastTotal = -1;
                    //}
                }
                if (Math.Abs(d) < 0.00000001)
                {
                    mustUpdate = false;
                    // unCart();
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                //if (dejaVu)
                //    Program.logAuto.log("déjà vu lastGoodLevel:{0} lastGoodDelta:{1}", lastGoodLevel, lastGoodDelta);
                log("correction {0}", d);
                newv = org + d;
                if (newv <= 0)
                    newv = 0;
                if (conf.coeff > 0)
                {
                    if (newv > conf.max)
                        newv = conf.max;
                    else if (newv < conf.min)
                        newv = conf.min;
                }
                newv = Math.Round(newv, 8);
                log(" valeur {0} --> {1}", org, newv);
                att.Value = newv.ToString();
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }
                string strDate = "";
                var attD = xml.Attributes["date"];
                if (attD != null)
                    strDate = attD.Value;
                bool exist = File.Exists(file);
                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        private void calcChoose(bool up, bool strict, bool checkSelect)
        {
            choose = null;
            double dt = double.MaxValue;
            double gap = double.MaxValue;
            bool trou = false;
            foreach (AutoBuilderItem item in items)
            {
                item.after(up, strict, checkSelect);
                item.setTension(up, strict);
                if (item.Stop(_stopLevel))
                {
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }
                double aux = double.MaxValue;
                // var tension = item.Tension;
                if (conf.selectFix)
                {
                    var tension = item.Tension;
                    aux = up ? tension : -tension;
                }
                else
                    aux = item.Dt;

                if (conf.selectAbs && !conf.selectFix && aux < 0)
                    aux *= -1;



                if (item.getCauses().Count == 0)
                {
                    trou = true;
                    if ((strict || checkSelect) && Conf.BorderGranSlam)
                    {
                        choose = null;
                        break;
                    }
                    continue;
                }

                var _gap = Math.Abs(aux);
                if (_gap < gap)
                    gap = _gap;

                if (aux < dt)
                {
                    dt = aux;
                    newv = item.NewV;
                    choose = item;
                }
            }
            //if (trou && conf.gap && gap < double.MaxValue)
            //{
            //    foreach (AutoBuilderItem item in items)
            //    {
            //        if (item.Stop)
            //            continue;
            //        item.gap(up, conf.selectFix, gap);
            //    }
            //}
        }

        private bool check2()
        {
            // _modifFile = false; 
            sb = new StringBuilder();
            sb.AppendLine();
            makeDelta(mem0, "virtuel", DAT + "vhisto." + conf.name + ".txt");




            if (mem0.ajouts.Count > 0 || mem0.suppressions.Count > 0)
            {
                if (conf.pertinentExclu)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item != choose)
                            item.makePertinent();
                    }
                }
                else if (conf.pertinentAll)
                {
                    foreach (AutoBuilderItem item in items)
                        item.makePertinent();
                }
                else
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        item.checkAjout(mem0.tajouts);
                        item.checkAjout(mem0.tsuppressions);
                    }
                }


                //else if (choose != null)
                //    choose.makePertinent();
            }
            mustUpdate = false;
            canGo = false;
            var newEmpreinte = source.getEmpreinte();

            try
            {
                if (state == builderstate.none)
                    reset();
                else if (state == builderstate.stable)
                {
                    if (newEmpreinte != _empreinte)
                        reset();
                    else
                    {
                        mustUpdate = false;
                        canGo = true;
                        org = newv;
                        return true;
                    }
                }

                total = source.getTotalSize();
                double target = conf.target;
                delta = target - total;
                log("delta {0}", delta);
                if (delta * lastDelta < 0)
                {
                    if (delta > 0)
                    {
                        // ok!
                        state = builderstate.stable;
                        _empreinte = newEmpreinte;
                        return true;
                    }
                    // retour arrière
                    if (choose != null)
                    {
                        _stopLevel--;
                        choose.stop(_stopLevel);
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                }
                lastDelta = delta;
                if (state == builderstate.none)
                    delta0 = delta;
                state = builderstate.enCours;
                lastd = d;
                d = 0;

                bool up = delta > 0;
                if (up && delta < conf.delta)
                {
                    state = builderstate.stable;
                    _empreinte = newEmpreinte;
                    return true;
                }
                mustUpdate = true;
                //double dt = double.MaxValue;

                //bool real = true;
                if (delta * delta0 < 0)
                {
                    if (choose != null)
                    {
                        _stopLevel--;
                        choose.stop(_stopLevel);
                    }
                    canGo = false;
                    mustUpdate = true;
                    return false;
                }
                if (conf.stopAll)
                {
                    foreach (AutoBuilderItem item in items)
                    {
                        if (item.Stop(1))
                        {
                            state = builderstate.stable;
                            return true;
                        }
                    }
                }



                choose = null;
                if (_stopLevel >= 3 && conf.checkSelect && conf.checkStrict)
                    calcChoose(up, true, true);
                if (choose != null)
                    log("REEL - SELECT");
                else
                {
                    if (_stopLevel >= 2 && conf.checkStrict)
                        calcChoose(up, true, false);
                    if (choose != null)
                        log("REEL");
                    else
                    {
                        if (_stopLevel >= 1 && conf.checkSelect)
                            calcChoose(up, false, true);
                        if (choose != null)
                            log("SELECT");
                        else
                        {
                            calcChoose(up, false, false);
                        }
                    }
                }


                if (choose == null)
                {
                    log("choose null");
                    _stopLevel--;
                    if (_stopLevel < 0)
                    {
                        state = builderstate.stable;
                        return true;
                    }
                    else
                    {
                        canGo = false;
                        mustUpdate = true;
                        return false;
                    }
                }

                org = choose.Org;



                if (up)
                {
                    if (delta < conf.write)
                        canGo = true;
                    if (conf.checkEvol)
                    {
                        // var nextTrack = choose.rejected(real).candidat;
                        var size = choose.EvolSize; // Stat.getSizeinMo(nextTrack);
                        if (delta < size)
                        {
                            _stopLevel--;
                            // choose.stop();
                            if (conf.stopAll)
                            {
                                foreach (AutoBuilderItem item in items)
                                    item.stop(_stopLevel);
                                //state = builderstate.stable;
                                //return true;
                            }
                            else
                            {
                                choose.stop(_stopLevel);
                            }
                        }
                    }

                }
                else
                {
                }
                choose.save();
                Program.logAuto.log("===> " + choose.ToString());
            }
            finally
            {
                if (state == builderstate.stable)
                {
                    mustUpdate = false;
                    _empreinte = newEmpreinte;
                    canGo = true;
                }

                using (TextWriter tw = new StreamWriter(file, true, Encoding.UTF8))
                {
                    bool exist = File.Exists(file);
                    // "quand\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tAdd\tiAdd\ttSupp\tiSup\tstate\t\r\n");
                    if (!exist)
                        tw.WriteLine("quand\ttarget\tdelta\tinf\tsup\ttotal\tdiff\tcorr\torg\tnew\tcmin\tcmax\tdmin\tdmax\tatomic\tstate");
                    tw.Write(DateTime.Now); tw.Write(SEP);
                    tw.Write(conf.target.ToString("0.###")); tw.Write(SEP);
                    tw.Write(conf.delta.ToString("0.###")); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].inf.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    if (conf.levels.Count > 0) tw.Write(conf.levels[0].sup.ToString("0.###")); else tw.Write(""); tw.Write(SEP);
                    tw.Write(total.ToString("0.###")); tw.Write(SEP);
                    tw.Write((-delta).ToString("0.###")); tw.Write(SEP);
                    tw.Write(d.ToString("0.###")); tw.Write(SEP);
                    tw.Write(org.ToString("0.###")); tw.Write(SEP);
                    tw.Write(newv.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(cmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmin.ToString("0.###")); tw.Write(SEP);
                    tw.Write(dmax.ToString("0.###")); tw.Write(SEP);
                    tw.Write(atomicMode); tw.Write(SEP);
                    tw.Write(state); tw.Write(SEP);
                    tw.WriteLine();
                }
                if (canGo)
                    // makeDelta(mem1, "reel", @"..\rhisto.txt");
                    makeDelta(mem1, "reel", DAT + "rhisto." + conf.name + ".txt");
            }
            return canGo;
        }

        public static void Log()
        {
            if (main == null)
                return;
            main.log();
        }
        public override string ToString()
        {
            var strMin = minMem == null ? "" : minMem.suppressions.Count.ToString();
            var strMax = maxMem == null ? "" : maxMem.ajouts.Count.ToString();
            var strName = string.Format("{0} ({1}) {2}", name, resolveOrder(), newv);
            var sb = new StringBuilder();
            sb.Append(string.Format("{0} {1} delta->{2} correction->{3}  mustUpdate->{4} canGo {5} atomic {6} idem {7} ({8}/{9})", strName, state, delta.ToString("0.###"), d.ToString("0.###"), mustUpdate, canGo, atomicMode, sameConfiguration, strMin, strMax));
            sb.AppendLine();
            foreach (AutoBuilderItem item in items)
                sb.Append(item);
            sb.AppendLine();
            return sb.ToString();

        }
        private void log()
        {
            Program.logAuto.log("");
            Program.logAuto.log("*****************************************************************************************");
            Program.logAuto.log("{0} {1}", name, sb.ToString());
            var type = "";
            if (choose != null)
                type = choose.type.ToString();
            Program.logAuto.log("{0} {1} total:{2}", name, type, total.ToString("0.###"));
            Program.logAuto.log("{0} {1} delta:{2}", name, type, delta.ToString("0.###"));
            Program.logAuto.log("{0} {1} stop:{2}", name, type, _stopLevel.ToString());

            //if (choose != null)               
            //   Program.logAuto.log("{0}", choose);

            //Program.logAuto.log("{0} cmin {1}", name, cmin.ToString("0.###"));
            //Program.logAuto.log("{0} dmin {1}", name, dmin.ToString("0.###"));
            //Program.logAuto.log("{0} cmax {1}", name, cmax.ToString("0.###"));
            //Program.logAuto.log("{0} dmax {1}", name, dmax.ToString("0.###"));
            if (mustUpdate)
            {
                //foreach (AutoBuilder builder in list)
                //{
                //    if (builder.d != 0)
                //    {
                log("correction {0}", d);
                log(" valeur {0} --> {1}", org, newv);
                //    }
                //}
            }
            else Program.logAuto.log("valeur non modifiée {0}", org);
            Program.logAuto.log("");
            foreach (AutoBuilder builder in list)
            {
                Program.logAuto.log(builder.ToString());
            }
            Program.logAuto.log("-------------------------------------------------------------------------------------------------------------------");
        }
        private XmlElement xml;
        public void lookup(XmlElement node)
        {
            var att = node.Attributes["auto"];
            if (att != null)
            {
                // && conf.name.Equals(att.Value))
                var targets = att.Value.Split(';');
                foreach (var target in targets)
                {
                    if (name.Equals(target))
                    {
                        xml = node;
                        return;
                    }
                }
            }
            foreach (XmlNode sub in node.ChildNodes)
            {
                if (sub is XmlElement)
                {
                    lookup(sub as XmlElement);
                    if (xml != null)
                        return;
                }
            }
        }
        private int resolveOrder()
        {
            if (conf.order < int.MaxValue)
                return conf.order;
            return naturalOrder;
        }
        public int CompareTo(AutoBuilder other)
        {
            if (other == this)
                return 0;
            var cmp = resolveOrder().CompareTo(other.resolveOrder());
            if (cmp == 0)
                throw new ApplicationException(string.Format("deux builders d'ordre identique {0}/{1}", this.name, other.name));
            return cmp;
        }

        private bool checkSignal;
        public void signal(TrackBorderItem tb)
        {
            checkSignal = false;
            var item = items.Find(i => i.type == tb.type);
            if (item != null)
            {
                if (client != null)
                {
                    if (!tb.source.isChildOf(client))
                        return;
                }
                item.signal(tb);
                checkSignal = true;
            }

        }

        public bool Checked
        {
            get { return checkSignal; }
        }

        private CauseRegister causeRegister = new CauseRegister();
        public CauseRegister CauseRegister { get { return causeRegister; } }

        //public void signal(CauseData cd)
        //{
        //    checkSignal = true;
        //    var item = items.Find(i => i.type == cd.type);
        //    if (item != null)
        //    {
        //        if (client != null)
        //        {
        //            if (!cd.limit.isChildOf(client))
        //                return;
        //        }
        //        causeRegister.signal(cd);
        //        //checkSignal = true;           
        //    }


        //}

        public void signal(CauseDatas cd)
        {
            checkSignal = true;
            if (client != null)
            {
                if (!cd.limit.isChildOf(client))
                    return;
            }
            int nb = 0;
            for (int i = 0; i < Causes.NB; i++)
            {
                var data = cd.datas[i];
                if (data == null || data.virtuel)
                    continue;
                var item = items.Find(it => it.type == data.type);
                if (item == null)
                    cd.datas[i].virtuel = true;
                else
                    nb++;
            }

            //if (nb == 0)
            //    return; 

            causeRegister.signal(cd);

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;
using pdb.podcast.Selection;
using pdb.podcast.Report;

namespace pdb.podcast.Auto
{
    class AutoBuilderItem : IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private timeSpan tpertinentOrg;
        private TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        private double evolSize;
        public double NewV { get { return newv; } }
        internal TrackBorderItem rejected(bool real) { return real ? _rejected : _rejectedLight; }
        internal TrackBorderItem selected(bool real) { return real ? _selected : _selectedLight; }
        internal void makePertinent() { pertinentOrg = org; }

        public void checkAjout(IEnumerable<TrackInfoItunes> list)
        {
            if (pertinentOrg == org)
                return;

            var lcauses = _causes;


            foreach (Causes causes in lcauses)
            {
                foreach (TrackInfoItunes t in list)
                {
                    if (causes.candidat.Location == t.Location)
                    {
                        pertinentOrg = org;
                        return;
                    }
                }

            }


        }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlElement xml;
        double dd;
        double d;
        private bool lastStrict;
        private bool lastUp;
        private double lastDelta;

        private double lastOrg;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        public AutoBuilderItem(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente - conf.min;
            dd = d * d;
        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _selectedLight;
        private TrackBorderItem _rejected;
        private TrackBorderItem _rejectedLight;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }

            //    tb.status = borderStatus.rejectedXtraLight; 
            //}


            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }


        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;

                if (!tb.Virtual)
                {
                    if (_selected == null)
                        _selected = tb;
                    else if (tb.val > _selected.val)
                        _selected = tb;
                }

                if (_selectedLight == null)
                    _selectedLight = tb;
                else if (tb.val > _selectedLight.val)
                    _selectedLight = tb;

                //if (_selected == null)
                //    setSelect(tb);
                //else
                //{
                //    if (tb.status > _selected.status && !Conf.BorderIdem)
                //        setSelect(tb);
                //    else if (tb.status == _selected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val > _selected.val)
                //            setSelect(tb);
                //    }
                //}

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;

                if (!tb.Virtual)
                {
                    if (_rejected == null)
                        _rejected = tb;
                    else if (tb.val < _rejected.val)
                        _rejected = tb;
                }

                if (_rejectedLight == null)
                    _rejectedLight = tb;
                else if (tb.val < _rejectedLight.val)
                    _rejectedLight = tb;


                //if (_rejected == null)
                //    setRejec(tb);
                //else
                //{
                //    if (tb.status > _rejected.status && !Conf.BorderIdem)
                //        setRejec(tb);
                //    else if (tb.status == _rejected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val < _rejected.val)
                //            setRejec(tb);
                //    }
                //}

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
            // Program.logAuto.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];
            lastOrg = org;
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            tpertinentOrg = getValue(pertinentOrg);
            //  misc.log(ToString());
        }
        private double dt; public double Dt { get { return dt; } }
        private double tension; public double Tension { get { return tension; } }
        private int _stop = AutoBuilder.STOP_MAX;
        public bool Stop(int level) { return _stop < level; }

        public void stop(int level)
        {
            newv = lastOrg;
            org = lastOrg;
            if (_stop > level)
                _stop = level;
            save();
        }
        public void reset()
        {
            _stop = AutoBuilder.STOP_MAX;
        }
        public void setTension(bool up, bool real)
        {

            dt = getDt(up, real);
        }

        private double getDt(bool up, bool real)
        {
            double t0 = _getTension(pertinentOrg);
            tension = _getTension(up, real);
            return (tension - t0) / conf.coeff;

        }

        private double getTension(bool up, bool real)
        {
            return _getTension(up, real) / conf.coeff;
        }

        private double getValue(TimeSpan val)
        {
            switch (type)
            {

                case borderType.d:
                case borderType.fd:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                case borderType.c:
                    break;
                default: return -1;

            }
            return -1;
        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.d:
                case borderType.fd:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                case borderType.c:
                    break;
                default: return new TimeSpan();

            }
            return new TimeSpan();
        }
        public double EvolSize { get { return evolSize; } }

        public List<Causes> getCauses()
        {
            return _causes;
        }

        //public List<Causes> getcauses(bool up, bool strict)
        //{
        //    List<Causes> list = null;
        //    if (up)
        //    {
        //        if (strict)
        //            list = _causesRejetStrict;
        //        else
        //            list = _causesRejet;
        //    }
        //    else
        //    {
        //        if (strict)
        //            list = _causesSelectStrict;
        //        else
        //            list = _causesSelect;
        //    }
        //    return list;
        //}

        public void gap(bool up, bool fix, double _gap)
        {
            _gap = Math.Abs(_gap);
            if (fix)
            {
                newv = Math.Abs(_gap);
            }
            else
            {
                if (up)
                    newv = org + _gap;
                else
                    newv = org - _gap;
            }
            save();
        }

        private double _getTension(bool up, bool strict)
        {
            lastStrict = strict;
            lastUp = up;
            // double t0 = getTension(org, dd);
            newv = org;
            evolSize = 0;
            var list = _causes;


            if (list.Count > 0)
            {
                var cause = list[0].getCause(type, strict, !up);
                newv = Math.Round(getValue(cause.val), 8);
                foreach (var c in list)
                {
                    var cand = c.candidat;
                    evolSize += Stat.getSizeinMo(cand);
                }
            }
            else
                return int.MaxValue;


            //if (false)
            //{

            //    if (up)
            //    {
            //        var _rejected = strict ? this._rejected : this._rejectedLight;
            //        if (_rejected == null)
            //            return int.MaxValue;
            //        newv = Math.Abs(Math.Round(getValue(_rejected.val), 8));
            //        evolSize = Stat.getSizeinMo(_rejected.candidat);

            //    }
            //    else
            //    {
            //        var _selected = strict ? this._selected : this._selectedLight;
            //        if (_selected == null)
            //            return int.MaxValue;
            //        newv = Math.Round(getValue(_selected.val), 8);
            //    }
            //}

            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            _toSave = true;
        }

        private List<Causes> _causes = new List<Causes>();
        //private List<Causes> _causesRejet = new List<Causes>();
        //private List<Causes> _causesSelect = new List<Causes>();

        //private List<Causes> _causesRejetStrict = new List<Causes>();
        //private List<Causes> _causesSelectStrict = new List<Causes>();


      
        //public void after()
        //{            
        //    _causesRejet = new List<Causes>();
        //    _causesSelect = new List<Causes>();
        //    _causesRejetStrict = new List<Causes>();
        //    _causesSelectStrict = new List<Causes>();
        //    after(true, true);
        //    after(true, false);
        //    after(false, true);
        //    after(false, false);
        //}
        public void after(bool up, bool strict, bool checkSelection)
        {
            _causes = new List<Causes>();
            var list = parent.CauseRegister.getList(false);
            int min = int.MaxValue;
            //  int minStrict = int.MaxValue;
            if (!up)
            {
                min = 0;
                //   minStrict = 0; 
            }
            int orgValue = torg.Value;
            foreach (Causes causes in list)
            {
                var candidat = causes.candidat;
                if (checkSelection)
                {
                    if (up && candidat.Selected)
                        continue;
                    if (!up && !candidat.Selected)
                        continue;
                }
                var cause = causes.getCause(type, strict, !up);
                if (cause == null)
                    continue;
                if (up && cause.success)
                    continue;
                if (!up && !cause.success)
                    continue;
                //if (value < 0)
                //    value = -value;
                int value = cause.val.Value;

                if (up)
                {

                    if (value == min)
                    {
                        _causes.Add(causes);

                    }
                    else if (value < min)
                    {
                        _causes.Clear();
                        _causes.Add(causes);
                        min = value;
                    }

                }
                else
                {
                    if (value >= orgValue)
                        continue;

                    if (value == min)
                    {
                        _causes.Add(causes);
                    }
                    else if (value > min)
                    {
                        _causes.Clear();
                        _causes.Add(causes);
                        min = value;
                    }


                }

            }
        }


        private double _getTension(double org)
        {


            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }



        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");

            sb.Append("stop="); sb.Append(_stop); sb.Append(" ");

            sb.Append("pertinent="); sb.Append(pertinentOrg); sb.Append(" ");
            sb.Append("tension="); sb.Append(tension); sb.Append(" ");
            sb.Append("dt="); sb.Append(dt); sb.Append(" ");

            var causes = _causes; // getcauses(lastUp, lastStrict);
            foreach (Causes cause in causes)
            {
                sb.AppendLine();
                var strStrict = lastStrict ? "strict " : "light ";
                var strselect = lastUp ? "rejet " : "select ";
                sb.Append(strselect);
                sb.Append(strStrict);
                sb.Append(cause.getCause(type, lastStrict, !lastUp));
                sb.Append(" "); sb.Append(cause.candidat);
            }

            //if (_causesRejetStrict.Count > 0)
            //{


            //    foreach (Causes cause in _causesRejetStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet strict "); sb.Append(cause.getCause(type,true,false));                     
            //    }
            //}

            //else if (_causesRejet.Count > 0)
            //{

            //    foreach (Causes cause in _causesRejet)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet light "); sb.Append(cause.getCause(type,false, false));      
            //    }
            //}

            //if (_causesSelectStrict.Count > 0)
            //{

            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select strict "); sb.Append(cause.getCause(type,true,true));      
            //    }
            //}

            //else if (_causesSelect.Count > 0)
            //{              
            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select light "); sb.Append(cause.getCause(type,false,true));      
            //    }
            //}



            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }


        public void signal(CauseDatas cd)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.podcast\Tuning\Auto.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.util;
using pdb.podcast.Auto;
namespace pdb.podcast.Tuning
{
    class Auto
    {
        delegate void sets(string value);
        delegate void setd(double value);
        delegate void seti(int value);
        delegate void setb(bool value);

        private void buildd(XmlNode parent, XmlNode child, string name, setd setd)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                setd(Convert.ToDouble(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
            elt = child[name];
            if (elt != null)
                setd(Convert.ToDouble(elt.InnerText));
        }

        private void buildi(XmlNode parent, XmlNode child, string name, seti seti)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));
            att = child.Attributes[name];
            if (att != null)
                seti(Convert.ToInt32(att.InnerText));

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
            elt = child[name];
            if (elt != null)
                seti(Convert.ToInt32(elt.InnerText));
        }

        private void builds(XmlNode parent, XmlNode child, string name, sets sets)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                sets(att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                sets(att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                sets(elt.InnerText);
            elt = child[name];
            if (elt != null)
                sets(elt.InnerText);
        }

        private void buildb(XmlNode parent, XmlNode child, string name, setb setb)
        {
            XmlAttribute att = null;
            if (parent != null)
                att = parent.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);
            att = child.Attributes[name];
            if (att != null)
                setb("true" == att.InnerText);

            XmlElement elt = null;
            if (parent != null)
                elt = parent[name];
            if (elt != null)
                setb("true" == elt.InnerText);
            elt = child[name];
            if (elt != null)
                setb("true" == elt.InnerText);
        }

        public string name = "";
        public borderType type = borderType.d;
        public double target;
        public double delta;
        public double write;
        public int cloop = 20;
        public int verif = 4;
        public int idem = 4;
        public int order = int.MaxValue;
        public double min = -int.MaxValue;
        public double max = int.MaxValue;
        public double coeff = 0;
        public bool selectFix;
        public bool selectAbs;
        public bool pertinentAll;
        public bool pertinentExclu; 
        public bool stopAll=true;
        public bool checkStrict;
        public bool checkSelect;
        public bool checkEvol; 
        public bool gap = false; 
        public double pente; 
        public List<Level> levels = new List<Level>();
        public List<Auto> items = new List<Auto>();

        public Auto()
        {
        }
        public Auto(Auto parent, XmlElement xparent, XmlElement node)
        {
            if (node == null)
                return;
            //if (parent != null)
            //{
            //    name = parent.name; 
            //    type = parent.type; 
            //    target = parent.target; 
            //    write = parent.write; 
            //    delta = parent.delta; 
            //    write = parent.write; 
            //    cloop = parent.cloop; 
            //    verif = parent.verif; 
            //    idem = parent.idem; 
            //    order = parent.order; 
            //    min = parent.min; 
            //    max = parent.max; 
            //    coeff = parent.coeff; 
            //    levels = new List<Level>(parent.levels); 
            //}
            XMLTool xml = new XMLTool(node);

            if (node.Attributes["type"] != null)
                type = (borderType)Enum.Parse(typeof(borderType), node.Attributes["type"].Value, true);
            builds(xparent, node, "name", (v) => name = v);
            buildd(xparent, node, "target", (v) => target = v);
            buildd(xparent, node, "delta", (v) => delta = v);
            buildd(xparent, node, "write", (v) => write = v);
            buildi(xparent, node, "cloop", (v) => cloop = v);
            buildi(xparent, node, "verif", (v) => verif = v);
            buildi(xparent, node, "verif", (v) => idem = v);
            buildi(xparent, node, "order", (v) => order = v);

            buildd(xparent, node, "min", (v) => min = v);
            buildd(xparent, node, "max", (v) => max = v);
            buildd(xparent, node, "coeff", (v) => coeff = v);
            buildb(xparent, node, "selectFix", (v) => selectFix = v);
            buildb(xparent, node, "selectAbs", (v) => selectAbs = v);
            buildb(xparent, node, "pertinentAll", (v) => pertinentAll = v);
            buildb(xparent, node, "stopAll", (v) => stopAll = v);
            buildb(xparent, node, "gap", (v) => gap = v);
            buildb(xparent, node, "checkStrict", (v) => checkStrict = v);
            buildb(xparent, node, "checkSelect", (v) => checkSelect = v);
            buildb(xparent, node, "checkEvol", (v) => checkEvol = v);
            buildb(xparent, node, "pertinentExclu", (v) => pertinentExclu = v);
            buildd(xparent, node, "pente", (v) => pente = v); 

            

            /*//  type = xml.getAttValue("type");
            //  target = xml.getDoubleAttValue("target");
             // delta = xml.getDoubleAttValue("delta");
             // write = xml.getDoubleAttValue("write");
            //  cloop = xml.getIntAttValue("cloop", 20);
            //  verif = xml.getIntAttValue("verif", 4);
             // idem = xml.getIntAttValue("idem", 4);
             // order = xml.getIntAttValue("order", int.MaxValue);
              min = xml.getDoubleAttValue("min", -int.MaxValue);
              max = xml.getDoubleAttValue("max", int.MaxValue);
              coeff = xml.getDoubleAttValue("coeff", 0);
           
              string str = "";
              if (target < 0)
              {
                  str = xml.getNodeValue("target");
                  if (!string.IsNullOrEmpty(str))
                      target = Convert.ToDouble(str);
              }
              if (delta < 0)
              {
                  str = xml.getNodeValue("delta");
                  if (!string.IsNullOrEmpty(str))
                      delta = Convert.ToDouble(str);
              }
              if (write < 0)
              {
                  str = xml.getNodeValue("write");
                  if (!string.IsNullOrEmpty(str))
                      write = Convert.ToDouble(str);
              }
              str = xml.getNodeValue("cloop");
              if (!string.IsNullOrEmpty(str))
                  cloop = Convert.ToInt16(str);
              str = xml.getNodeValue("verif");
              if (!string.IsNullOrEmpty(str))
                  verif = Convert.ToInt16(str);
              str = xml.getNodeValue("idem");
              if (!string.IsNullOrEmpty(str))
                  idem = Convert.ToInt16(str);
              str = xml.getNodeValue("order");
              if (!string.IsNullOrEmpty(str))
                  order = Convert.ToInt16(str);
              str = xml.getNodeValue("min");
              if (!string.IsNullOrEmpty(str))
                  min = Convert.ToDouble(str);
              str = xml.getNodeValue("max");
              if (!string.IsNullOrEmpty(str))
                  max = Convert.ToDouble(str);
              str = xml.getNodeValue("coeff");
              if (!string.IsNullOrEmpty(str))
                  coeff = Convert.ToDouble(str);
              levels = new List<Level>();*/

            if (parent != null)
                levels = new List<Level>(parent.levels);

            var xlevels = xml.NodeLookUp("levels");

            if (xlevels != null)
            {
                levels.Clear();
                foreach (XmlNode sub in xlevels.ChildNodes)
                {
                    if (sub is XmlElement)
                    {
                        var level = new Level(sub as XmlElement);
                        levels.Add(level);
                    }
                }
            }
            else if (levels.Count == 0)
            {
                var level = new Level(node);
                levels.Add(level);
            }
            var xitems = xml.NodeLookUp("items");
            if (xitems != null)
            {
                foreach (XmlNode sub in xitems.ChildNodes)
                {
                    if (sub is XmlElement)
                    {
                        var subAuto = new Auto(this, node, sub as XmlElement);
                        items.Add(subAuto);
                    }
                }
            }

        }
    }
    class Level
    {
        public double d;
        public double inf;
        public double sup;
        public Level()
        {
        }
        public Level(XmlElement node)
        {
            if (node == null)
                return;
            XMLTool xml = new XMLTool(node);
            d = xml.getDoubleAttValue("d");
            inf = xml.getDoubleAttValue("inf");
            sup = xml.getDoubleAttValue("sup");
            string str = xml.getAttValue("d");
            if (!string.IsNullOrEmpty(str))
                d = Convert.ToDouble(str);
            str = xml.getAttValue("inf");
            if (!string.IsNullOrEmpty(str))
                inf = Convert.ToDouble(str);
            str = xml.getAttValue("sup");
            if (!string.IsNullOrEmpty(str))
                sup = Convert.ToDouble(str);
        }
    }
}]]></content>
  </file>
  <file path="\pdb.util\misc.cs">
    <content><![CDATA[using System;
using System.IO;
using System.Threading;

namespace pdb.util
{
    /// <summary>
    /// utilitaires divers
    /// </summary>
    /// <remarks></remarks>
    public static class misc
    {
        const int K = 1024; 
        public static void gcCollect(string org)
        {
          
            DateTime now = DateTime.Now;
            long mem0 = GC.GetTotalMemory(false); 
            GC.Collect();
            long mem1 = GC.GetTotalMemory(false);

            var _mem0 = mem0.HumanReadableSize(-1);
            var _mem1 = mem1.HumanReadableSize(-1); 
            var delta =(mem0 - mem1).HumanReadableSize(-1); 

            misc.log("GC.Collect " + org + " " + _mem0 + " " + _mem1 + " (" + delta + ") "  + (DateTime.Now - now).TotalMilliseconds.ToString("0"));
        }
        private static ILogger logger = new DefaultLogger();
        private static getDefaultLogger _getDefaultLogger; 
        //public static void init(ILogger a_logger)
        //{
        //    logger = a_logger;
        //    //if (logger is Logger)
        //    //    Logger.init();
        //}

        public static void init(getDefaultLogger getDefaultLogger)
        {
            _getDefaultLogger = getDefaultLogger; 
        }

        public static string Pre { set { Logger.Pre = value; } }

        private static ILogger Logger
        {
            get
            {
                if (logger is DefaultLogger && _getDefaultLogger != null)
                    logger = _getDefaultLogger();
                return logger; 
            }
        }


        public static void logNoDate(String txt)
        {
            Logger.logNoDate(txt);
        }

        public static void log(string txt, params object[] other)
        {
            Logger.log(txt, other);
        }

        public static void logError(string txt, Exception ex)
        {
            log("[Error] " + txt + " " + ex.ToString());
        }

        public static void logWarn(string txt)
        {
            log("[Warn] " + txt);
        }

        public static string moveTree(this FileInfo org, String dest, bool? overWrite)
        {
           return tree(org, dest, true, overWrite);
        }

        public static string copyTree(this FileInfo org, String dest, bool? overWrite)
        {
            return tree(org, dest, false, overWrite);
        }

        public static string getShortPath(this string path, params string[] keywords)
        {
            
            string[] dirs = path.Split(Path.DirectorySeparatorChar);
            int found = 0;
            int count = dirs.GetLength(0);
            for (int i = count - 2; i > 0; i--)
            {
                var s = dirs[i].ToLower();
                if (string.IsNullOrEmpty(s))
                    continue; 
                foreach (string key in keywords)
                {
                    if (key.Equals(s))
                    {
                        found = i; 
                        break; 
                    }
                }
                if (found > 0)
                    break; 
            }

            var sb = new StringBuilder();
            var begin = false; 
            for (int i = found + 1; i < count; i++)
            {
                var s = dirs[i];
                if (string.IsNullOrEmpty(s))
                    continue;
                if (begin)
                {
                    sb.Append(Path.DirectorySeparatorChar); 
                }
                begin = true;
                sb.Append(s); 
            }
            return sb.ToString(); 
        }


        private static string tree(FileInfo org, String dest, bool deleteOrg, bool? overwrite)
        {
            string newDest = dest;
            String[] dirs = dest.Split(Path.DirectorySeparatorChar);

            int i = 0;
            DirectoryInfo root = new DirectoryInfo(dirs[0] + Path.DirectorySeparatorChar);
            for (i = 1; i < dirs.GetLength(0) - 1; i++)
            {
                String strDir0 = dirs[i] + Path.DirectorySeparatorChar;
                String StrDir = root.FullName + strDir0;
                DirectoryInfo dir = new DirectoryInfo(StrDir);
                if (!dir.Exists)
                {
                    dir.Create();
                    try
                    {
                        dir.Attributes &= ~FileAttributes.ReadOnly;
                    }
                    catch (Exception ea)
                    {
                     //   log("impossible de poser les attributs de répertoire " +ea.ToString()); 
                    }
                    
                }
                root = dir;
            }
            //object o;

            FileInfo orgg = new FileInfo(org.FullName);
            if (overwrite == null)
            {
                if (File.Exists(dest))
                    return newDest;
                org.CopyTo(dest, false);
            }
            else if (overwrite.Value)
                org.CopyTo(dest, true);
            else
            {
                if (!File.Exists(dest))
                    org.CopyTo(dest, false);
                else
                {
                    int index = 1;
                    string fdest = Path.GetDirectoryName(dest) + Path.DirectorySeparatorChar + Path.GetFileNameWithoutExtension(dest);
                    string ext = Path.GetExtension(dest);


                    newDest = fdest + "_" + index + ext;
                    while (File.Exists(newDest))
                    {
                        index++;
                        newDest = fdest + index + ext;
                    }
                    org.CopyTo(newDest, false);
                }
            }
            try
            {
                File.SetAttributes(newDest, File.GetAttributes(newDest) & ~FileAttributes.ReadOnly);
            }

            catch (Exception ea2)
            {
               // log("impossible de poser les attributs de fichier " + ea2.ToString());
            }



            if (deleteOrg) org.Delete();
            DirectoryInfo current = orgg.Directory;

            while (current.GetFileSystemInfos().GetLength(0) == 0)
            {
                DirectoryInfo parent = current.Parent;
                current.Delete();
                current = parent;
            }

            return newDest;
        }

        public static void deleteFile(string path)
        {
            var file = FileRegister.Check(path);
            if (!file.Exists)
            {
                log("fichier {0} non présent", path); 
                return;
            }
            var fi = new FileInfo(path);
            log("suppression fichier {0}", path); 
            fi.Delete();
            file.delete();

            DirectoryInfo current = fi.Directory;

            while (current.GetFileSystemInfos().GetLength(0) == 0)
            {
                DirectoryInfo parent = current.Parent;
                log("suppression répertoire {0}", current.FullName); 
                current.Delete();
                current = parent;
            }


        }


        public static void DeleteDir(DirectoryInfo dir)
        {
            Console.WriteLine("DeleteDir " + dir.FullName); 
            try
            {
                if (!dir.Exists)
                    return;
                foreach (FileInfo file in dir.GetFiles())
                {
                    try
                    {
                        file.Delete();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("impossible de supprimer " + file.FullName + " " + ex);
                    }
                }
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    DeleteDir(sub);
                try
                {
                    dir.Delete();
                }
                catch (Exception edelDir)
                {
                    Console.WriteLine("impossible de supprimer en final " + dir.FullName + " " + edelDir.Message);
                }
            }
            catch (Exception exd)
            {
                Console.WriteLine("impossible de supprimer " + dir.FullName + " " + exd);
            }
        }

       


    }
}]]></content>
  </file>
  <file path="\PieceDb.Consolid\CLegacyListWriter.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using pdb.gen.conf;
using pdb.obj;
using pdb.util;
using pdb.gen.Tuning;
using pdb.gen.albums;
namespace pdb.gen
{

    public class CLegacyListWriter
    {
        private List<Piece> m_list = new List<Piece>();
        private List<Piece> m_listIni = null;
        private IEnumerable<Piece> m_enum;
        private int m_rotPeriod = -1;
        private static CPieceInListComparer c_comparer = new CPieceInListComparer();
        private bool m_bIni = false;
        private static DateTime now = DateTime.Now;
        private static Logger logger = Logger.getLogger("gen", false); 
        public CLegacyListWriter(IList<Piece> a_pieceEnumerator, bool sortByAlbum)
        {
            m_enum = a_pieceEnumerator;
            this.sortByAlbum = sortByAlbum; 

            foreach (Piece l_piece in m_enum)
            {
                m_list.Add(l_piece);
            }
            m_listIni = new List<Piece>(m_list);

        }


        private ICollection<ListWriterMgr> writers = new List<ListWriterMgr>();
        public void addWriter(IListWriter writer) { writers.Add(new ListWriterMgr(writer)); }
   

        public void reset()
        {

            const int MIN_DURATION = 10 * 3600;
            m_list.Clear();
            m_listIni.Clear();
            foreach (Piece l_piece in m_enum)
            {
                m_list.Add(l_piece);
            }
            if (!m_bIni)
            {
                m_bIni = true;
                m_listIni = new List<Piece>(m_list);

            }
            double l_totalDuration = getDuration(1, null);
            while (l_totalDuration < MIN_DURATION && ListSelection.Scale > 0.01)
            {
                ListSelection.Scale *= 0.9;
                l_totalDuration = getDuration(1, null);
            }

            // If CConf.Sort.Quality.Mode = listMode.substract Then CPiece.Scale *= 0.1


        }
        public void writeRot(int a_base)
        {
            logger.log("write rot" + a_base);
            List<Piece> l_listPieceCLass = new List<Piece>();
            foreach (Piece l_piece in m_list)
            {
                if (l_piece.QRank > 0 && ListSelection.canPlay(l_piece, a_base))
                {
                    l_listPieceCLass.Add(l_piece);
                }
            }
            l_listPieceCLass.Sort(c_comparer);
            m_list = l_listPieceCLass;

            writePlayList("rot" + a_base, l_listPieceCLass, false, true);
        }

        public bool SortByAlbum { set { sortByAlbum = value; } }
        private bool sortByAlbum = true; 
        public void writeGen(ExtendToNative<datesMode> mode, ExtendToNative<double> nbHours, string baseName, bool onlyEvol)
        {
            try
            {
                var conf = CConf.ConfGen;
                logger.log("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol);
                bool withTimeOrder = mode.extendTimeOrder && nbHours.extendTimeOrder;

                var timeRestLimit = 0m;
                if (nbHours.level)
                {
                    CRank fictif = new CRank();
                    fictif.Quality = 1;
                    fictif.Lenght = 1;
                    fictif.Twice = 1;
                    DateTime dtFictif = DateTime.Now.AddDays(-nbHours.item);
                    List<DateTime> lfictif = new List<DateTime> { dtFictif };
                    timeRestLimit = CalcDate.getRest(lfictif, fictif);
                   logger.log("Limite {0} => {1} {2} ", nbHours.item, timeRestLimit, conf.Vie.TotalDays() * timeRestLimit);
                }

                List<Piece> l_listPieceCLass = new List<Piece>();
                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.QRank > 0)
                    {

                        if (!(string.IsNullOrEmpty(l_piece.ClassEvol) && onlyEvol))
                        {
                            if (l_piece.Enabled || !conf.OnlyEnabled)
                                l_listPieceCLass.Add(l_piece);
                        }

                    }
                }
                l_listPieceCLass.Sort(new PieceRestComparer());


                TimeSpan limit = TimeSpan.FromHours(nbHours.item);
                TimeSpan current = new TimeSpan();

                List<Piece> ret = new List<Piece>(l_listPieceCLass.Count);
                // string lastClassement = "";
                bool rejet = false;

                foreach (Piece piece in l_listPieceCLass)
                {
                    if (nbHours.level)
                    {
                        if (piece.Rank.TimeRest <= timeRestLimit)
                            ret.Add(piece);
                    }
                    else if (nbHours.item == 0)
                    {
                        if (piece.Rank.TimeRest == 0)
                            ret.Add(piece);
                    }
                    else
                    {
                        current += piece.Duration;
                        if (current > limit || rejet)
                        {
                            if (!rejet)
                                logger.log("writeGen rejet {0} {1} {2} {3} {4} {5} {6}", mode, nbHours, baseName, onlyEvol, piece.ClassNameAndRating, piece, piece.Rank.TimeRest);
                            rejet = true;
                            //if (piece.ClassNameAndRating.Equals(lastClassement))
                            //{
                            //    log.log("writeGen {0} {1} {2} {3} {4} récupéré par {5}", mode, nbHours, baseName, onlyEvol, piece, lastClassement);
                            //}
                            //else
                            break;
                        }
                        ret.Add(piece);
                        // log.log("writeGen {0} {1} {2} {3} {4} {5} {6}", mode, nbHours, baseName, onlyEvol, piece.ClassNameAndRating, piece, piece.Rank.TimeRest);
                        // rejet = false; 
                        // lastClassement = piece.ClassNameAndRating;
                    }
                }

                if (withTimeOrder)
                    ret.Sort(new PieceRestComparer());
                else
                {
                    if (sortByAlbum)
                        ret.Sort(new AllPieceComparer2());
                    else
                    {
                        ret.Sort(new CPieceComparerByQualityAndLength2());
                        ret.Reverse();
                    }
                    // extension des listes normales
                    if (CConf.ConfGen.Anticipation && !nbHours.level && nbHours.item != 0 && ret.Count > 0)
                    {
                        Piece first = ret[0];
                        var listlecture = new List<Piece>(l_listPieceCLass);
                        listlecture.Sort(new PieceSortComparerList());
                        listlecture.Reverse();
                        while (true)
                        {
                            // que se passe-t-il quand le premier élément de la liste est consommé (g1)
                            // si on refait le calcul

                            int indexLecture = listlecture.IndexOf(first);
                            if (indexLecture < 0)
                                break;
                            int indexPrecedentLecture = indexLecture - 1;
                            if (indexPrecedentLecture < 0)
                                break;
                            Piece precedentLecture = listlecture[indexPrecedentLecture];
                            if (ret.Contains(precedentLecture))
                                break;
                            // si le précedent dans l'ordre de la lecture est aussi le précédent dans l'ordre reste, on le conserve 

                            int indexRest = l_listPieceCLass.IndexOf(first);
                            if (indexRest < 0)
                                break;
                            int indexRestSuivant = indexRest + 1;
                            if (indexRestSuivant >= l_listPieceCLass.Count)
                                break;

                            Piece suivantRest = l_listPieceCLass[indexRestSuivant];
                            if (ret.Contains(suivantRest))
                                break;
                            if (suivantRest != precedentLecture)
                            {
                                int indexLecture2 = listlecture.IndexOf(suivantRest);
                                if (indexLecture2 > indexLecture)
                                    break;
                            }

                            ret.Add(precedentLecture);
                            first = precedentLecture;


                        }

                        if (withTimeOrder)
                            ret.Sort(new PieceRestComparer());
                        else
                        {
                            if (sortByAlbum)
                                ret.Sort(new AllPieceComparer2());
                            else
                            {
                                ret.Sort(new CPieceComparerByQualityAndLength2());
                                ret.Reverse();
                            }
                        }

                        //ret.Sort(new PieceSortComparerList());
                        //ret.Reverse();
                    }

                }
                // 

                var large = getLarge(ret);
                //ret.Reverse();
                //large.Reverse();

                // var hash = new HashList<Piece>(ret); 

                bool extendToNative = mode.extend && nbHours.extend;
                bool withOrder = conf.WithOrder && (nbHours.item > 0 || conf.OrderZero);
                withOrder = withOrder || withTimeOrder;
                string strLevel = "";
                if (nbHours.level)
                    strLevel = "_";
                writePlayList(mode.ToString(), baseName + strLevel + nbHours, ret, withOrder, extendToNative);

                withOrder = withOrder && conf.OrderLarge;
                writePlayList(mode.ToString(), baseName + strLevel + nbHours + "+", large, withOrder, extendToNative);

                var writeGrouping = CConf.ConfGen.WriteGrouping;
                if (writeGrouping > writeGrouping.none && (nbHours.item > 0 || conf.WriteGroupingZero))
                {
                    foreach (var piece in ret)
                    {
                        piece.MarkAsUpdateGrouping();
                    }

                    if (conf.GenLarge)
                    {
                        foreach (var piece in large)
                        {
                            piece.MarkAsUpdateGrouping();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                misc.logError(string.Format("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol), ex);
            }
        }

        
        internal void writeGen(Albums albums, ExtendToNative<datesMode> mode, ExtendToNative<double> nbHours, string baseName, bool onlyEvol)
        {
            try
            {
                logger.log("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol);
                bool withTimeOrder = mode != null && nbHours != null &&  mode.extendTimeOrder && nbHours.extendTimeOrder;

                var timeRestLimit = 0m;
                if (nbHours != null && nbHours.level)
                {
                    CRank fictif = new CRank();
                    fictif.Quality = 1;
                    fictif.Lenght = 1;
                    fictif.Twice = 1;
                    DateTime dtFictif = DateTime.Now.AddDays(-nbHours.item);
                    List<DateTime> lfictif = new List<DateTime> { dtFictif };
                    timeRestLimit = CalcDate.getRest(lfictif, fictif);
                    logger.log("Limite {0} => {1} {2} ", nbHours.item, timeRestLimit, CConf.ConfGen.Vie.TotalDays() * timeRestLimit);
                }

                var list = albums.makeSelection();



                TimeSpan limit = new TimeSpan(); 
                if (nbHours != null)
                    limit = TimeSpan.FromHours(nbHours.item);
                TimeSpan current = new TimeSpan();

                List<Album> retAlbum = new List<Album>();


                foreach (Album album in list)
                {
                    if (!album.Classed)
                        continue;
                    //if (!album.AtLeastOneEnabled)
                    //    continue; 
                    if (nbHours == null)
                        retAlbum.Add(album); 
                    else if (nbHours.level)
                    {
                        if (album.Rank.TimeRest <= timeRestLimit)
                            retAlbum.Add(album);
                    }
                    else if (nbHours.item == 0)
                    {
                        if (album.Rank.TimeRest == 0)
                            retAlbum.Add(album);
                    }
                    else
                    {
                        retAlbum.Add(album);
                        current += album.Duration;
                        if (current > limit)
                        {
                            break;
                        }
                    }
                }

                //retAlbum.Sort(new AlbumSortComparer());
                //retAlbum.Reverse(); 

                var ret = new List<Piece>();
                foreach (Album album in retAlbum)
                {
                    ret.AddRange(album.Sort());
                }


                // if (!CConf.ConfGen.AlbumOrdo)
            
               //ret.Sort(new AllPieceComparer());
               //ret.Reverse();

                ret.Sort(new AllPieceComparer2());
              
                // var hash = new HashList<Piece>(ret); 
                var conf = CConf.ConfGen;
                bool extendToNative =mode!= null &&  mode.extend && nbHours != null && nbHours.extend;
                bool withOrder = conf.WithOrder && ((nbHours != null && nbHours.item > 0) || conf.OrderZero);
                withOrder = withOrder || withTimeOrder;
                string strLevel = "";
                if (nbHours == null)
                    strLevel = "";
                else if (nbHours.level)
                    strLevel = "_";
                writePlayList("album\\" + mode, baseName + strLevel + nbHours, ret, CConf.ConfGen.AlbumOrdo, extendToNative);
                IList<Piece> large = ret;

                //large = getLarge(ret);
                //withOrder = withOrder && conf.OrderLarge;
                //writePlayList(mode.ToString(), baseName + strLevel + nbHours + "+", large, withOrder, extendToNative);

                var writeGrouping = CConf.ConfGen.WriteGrouping;
                if (writeGrouping > writeGrouping.none && ((nbHours !=null && nbHours.item > 0)|| conf.WriteGroupingZero))
                {
                    foreach (var piece in ret)
                    {
                        piece.MarkAsUpdateGrouping();
                    }

                    if (conf.GenLarge)
                    {
                        foreach (var piece in large)
                        {
                            piece.MarkAsUpdateGrouping();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                misc.logError(string.Format("writeGen {0} {1} {2} {3}", mode, nbHours, baseName, onlyEvol), ex);
            }
        }




        public void writePrecisionClassement(string baseName, int precision, bool onlyEvol, bool extendToNative)
        {
            logger.log("writePrecisionClassement" + precision);
            List<Piece> l_listPieceCLass = new List<Piece>();
            foreach (Piece l_piece in m_listIni)
            {
                if (l_piece.QRank > 0)
                {
                    if (!(string.IsNullOrEmpty(l_piece.ClassEvol) && onlyEvol))
                        l_listPieceCLass.Add(l_piece);
                }
            }

            List<Piece> ret = new List<Piece>(l_listPieceCLass.Count);

            foreach (Piece piece in l_listPieceCLass)
            {
                if (piece.classPrecision() <= precision)
                    ret.Add(piece);
            }



            writePlayList("precision", baseName + precision, ret, false, extendToNative);
            var large = getLarge(ret);
            writePlayList("precision", baseName + precision + "+", large, false, extendToNative);


        }


        public void writeCheckClassement(int a_base)
        {
            logger.log("write check Classement " + a_base);
            List<Piece> l_listPieceCLass = new List<Piece>();

            if (a_base == 0)
            {
                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.ClassEvol != "")
                    {
                        l_listPieceCLass.Add(l_piece);
                    }
                }
            }
            else
            {

                foreach (Piece l_piece in m_listIni)
                {
                    if (l_piece.QRank > 0 && ListSelection.mustPlayToPreciseClassement(l_piece, now, a_base)) // l_piece.mustPlayToPreciseClassement(now, a_base))
                    {
                        l_listPieceCLass.Add(l_piece);
                    }
                }
            }
            l_listPieceCLass.Sort(c_comparer);

            writePlayList("check" + a_base, l_listPieceCLass, false, true);
            var l_large = getLarge(l_listPieceCLass);
            writePlayList("_check" + a_base, l_large, false, true);
        }


        public void writeRotMin(int a_hDuration)
        {
            log("rotMax " + a_hDuration);
            int l_duration = 3600 * a_hDuration;
            m_list = writeRotMin_(l_duration);
            string l_name = a_hDuration.ToString();
            if (a_hDuration < 0)
                l_name = "all";

            string l_name0 = "rotMax" + l_name;
            string l_nameLarge = "_" + l_name0;


            writePlayList(l_name0, m_list, CConf.ConfGen.WithOrder, true);
            var l_large = getLarge(m_list);
            writePlayList(l_nameLarge, l_large, CConf.ConfGen.WithOrder, true);

        }
        /// <summary>
        /// écit une liste basée sur une durée max
        /// </summary>
        /// <param name="a_ms">durée totale de la liste, en ms</param>
        /// <remarks></remarks>
        private List<Piece> writeRotMin_(int a_ms)
        {
            double l_totalDuration = 0;
            int l_durationTarget = a_ms;
            int l_iEnd = 100 * ListSelection.Period;

            List<Piece> l_list = null;
            List<Piece> l_Oldlist = null;
            int l_period = m_rotPeriod;

            do
            {
                l_totalDuration = 0;
                l_Oldlist = l_list;

                l_list = new List<Piece>();

                l_period += 1;


                l_totalDuration = getDuration(l_period, l_list);

                //For Each l_piece As CPiece In m_list
                //    If l_piece.Rank > 0 AndAlso l_piece.canPlay(l_period) Then
                //        l_list.Add(l_piece)
                //        l_totalDuration += l_piece.Duration
                //    End If
                //Next

                m_list = l_list;
                //   log("period " + l_period.ToString() + " " + m_list.Count + "/" + (l_totalDuration / 60000).ToString(".") + " min");
            } while (l_totalDuration > l_durationTarget && l_period < l_iEnd && l_durationTarget > 0);
            m_rotPeriod = l_period - 1;

            if (l_Oldlist == null)
                l_Oldlist = l_list;
            l_Oldlist.Sort(c_comparer);
            return l_Oldlist;




        }

        private double getDuration(int a_base, IList a_list)
        {
            double l_totalDuration = 0;
            foreach (Piece l_piece in m_list)
            {
                if (l_piece.QRank > 0 && ListSelection.canPlay(l_piece, a_base))
                {
                    if (a_list != null)
                        a_list.Add(l_piece);
                    l_totalDuration += l_piece.Duration.TotalSeconds;
                }
            }
            return l_totalDuration;
        }

        private List<Piece> getLarge(IList<Piece> a_list)
        {
            var conf = CConf.ConfGen;
            HashList<Piece> l_large = new HashList<Piece>();
            var listClassEnabled = Consolid.QLClassed.FindAll(p => !conf.OnlyEnabled || p.Enabled);
            HashList<Piece> l_ref = new HashList<Piece>(listClassEnabled);
            int l_deltaBefore = CConf.Before;
            int l_deleteAfter = CConf.After;
            foreach (Piece l_piece in a_list)
            {
                int l_current = l_ref.IndexOf(l_piece); //l_piece.QLRank - 1;
                if (l_current < 0)
                    continue;
                int l_iBefore = l_current + l_deltaBefore;
                int l_after = l_current - l_deleteAfter;

                for (int l_iIndex = l_iBefore; l_iIndex >= l_after; l_iIndex--)
                {
                    if (l_iIndex >= 0 && l_iIndex < l_ref.Count)
                    {
                        var piece = l_ref[l_iIndex];
                        if ((!conf.OnlyEnabled || piece.Enabled) && !l_large.Contains(piece))
                            l_large.Add(piece);
                    }
                }
            }
            return l_large.List;
        }
        private void log(String txt)
        {
            logger.log(txt);
        }

        private void writePlayList(string folder, string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative)
        {

        //    BgDictString<object> dict = new BgDictString<object>();
           
            //if (max < a_list.Count)
            //{
            //    a_list = new List<Piece>(a_list);
            //    a_list.Reverse();
            //}
            List<IFile> list = new List<IFile>();

            //int nb = 0;
            //int nbAfterRead = -1; 
            foreach (IFile file in a_list)
            {
                //if (dict.ContainsKey(file.Location))
                //{
                //    logger.log("déjà présent '{0}'\\{1}\\{2} ", folder, a_fileName, file.Location);
                //}

                //else
                //{
                //    dict.Add(file.Location, file);
                    list.Add(file);
                    //nb++;
                    //nbAfterRead++; 
                    //if (nb >= max && nbAfterRead >= maxAfterRead)
                    //    break;
             //   }

            }
            string GEN = "gen";
            if (!string.IsNullOrEmpty(folder) && !folder.EndsWith("\\"))
                GEN += "\\" + folder;
            foreach (ListWriterMgr writer in writers)
            {

                writer.writePlayList(GEN, a_fileName, list, withOrder);
                if (!extendToNative)
                    return;
            }
        }


        private void writePlayList(string a_fileName, List<Piece> a_list, bool withOrder, bool extendToNative)
        {
            writePlayList(null, a_fileName, a_list, withOrder, extendToNative);

        }

        //private class FileImpl : IFile
        //{
        //    private string location;
        //    private int id;


        //    public FileImpl(IFile file)
        //    {
        //        this.location = file.Location;
        //        this.id = file.PieceId;

        //    }

        //    #region IFile Members

        //    public string Location
        //    {
        //        get { return location; }
        //    }

        //    public override bool Equals(object obj)
        //    {
        //        var o = obj as IFile;
        //        if (o == null)
        //            return false;
        //        return location.Equals(o.Location);

        //    }

        //    public override int GetHashCode()
        //    {
        //        return location.GetHashCode();
        //    }

        //    public override string ToString()
        //    {
        //        return location;
        //    }

        //    #endregion


        //    public int PieceId
        //    {
        //        get { return id; }
        //    }
        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Consolid.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using pdb.gen.albums;
using pdb.gen.conf;
using pdb.gen.stat;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Threading;

namespace pdb.gen
{
    /// <summary>
    /// G�re l'application propri�taire
    /// </summary>
    /// <remarks></remarks>ranking
    /// 
    public class Consolid
    {
        private CListPiece m_list;
        private List<Piece> m_listTrackClassed = new List<Piece>();
        /// <summary>
        /// Liste des donn�es consolid�es morceaux maitres
        /// </summary>
        private List<Piece> listPiece = new List<Piece>();
        private List<Piece> allClassed = new List<Piece>();
        private List<Piece> allClassedInAlbumEnabled = new List<Piece>();
        /// <summary>
        /// Liste des donn�es morceux dupliqu�s 
        /// </summary>
        private List<Piece> listPieceInAlbum = new List<Piece>();
        private Albums albums; // = new Albums(CConf.ConfGen.AlbumSortStrict);
        private BgDict<int, Piece> htIds = new BgDict<int, Piece>();

        private volatile object _lock = new object();
        private bool _consolidEnCours;


        #region navigation
        private static IComponentFactor creator = new TrackListCreator();
        private CPlayList root = new CPlayList("root", null, creator);
        public CPlayList Root { get { return root; } }
        private CPlayList musique;
        private CPlayList classement;
        private CPlayList listes;
        #endregion

        public DateTime Now { set { CalcDate.refreshDate(value); } }

        private int step;
        public int Step { set { step = value; } }

        public Consolid()
        {
            Piece.Gen = this;
            musique = new CPlayList("musique", root, creator);
            classement = new CPlayList("classement", root, creator);
            listes = new CPlayList("listes", root, creator);
        }

        private void buildClassTree(IPlayList pl)
        {
            pl.DeleteChilds();
            var l = new List<Piece>(allClassed);
            l.Reverse();
            foreach (Piece piece in l)
            {

                var _class = piece.ClassNameAndRating;
                char[] tab = _class.ToCharArray();
                int count = tab.GetLength(0);
                buildClassTree(pl, piece, tab, count, -1);
            }
        }

        public void buildClassTree()
        {
            buildClassTree(classement);
        }


        private void buildClassTree(IPlayList parent, Piece piece, char[] strClass, int count, int index)
        {
            if (index == count - 2)
            {
                parent.addObj(piece);
                return;
            }

            var _index = index + 1;
            var pl = parent.getOrCreate(strClass[_index].ToString());
            buildClassTree(pl, piece, strClass, count, _index);

        }

        private void waitForConsolid()
        {
            bool cango = false;
            try
            {
                do
                {
                    lock (_lock)
                        cango = !_consolidEnCours;
                    if (cango)
                        return;
                    Thread.Sleep(1000);
                } while (!cango);
            }
            finally
            {
                _consolidEnCours = true;
            }
        }

        public void MakeConsolid(IEnumerable<ITrackNativeDates> dbList)
        {
            try
            {
                waitForConsolid();
                listPiece = new List<Piece>();
                listPieceInAlbum = new List<Piece>();
                var auxlistPieceInAlbum = new List<Piece>();
                albums = new Albums(this);
                m_listTrackClassed = new List<Piece>();
                allClassed = new List<Piece>();
                allClassedInAlbumEnabled = new List<Piece>(); 
                htIds = new BgDict<int, Piece>();
                foreach (ITrackNativeDates track in dbList)
                {

                    if (!track.isPodcast)
                    {
                        var piece = new Piece(track);
                        auxlistPieceInAlbum.Add(piece);
                        htIds.Add(piece.PieceId, piece);
                    }
                }
                // link
                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    int parentId = piece.PieceParentId;
                    if (parentId > 0)
                    {
                        piece.Parent = htIds[parentId];
                    }
                }

                // liste FORT + albums

                foreach (Piece piece in auxlistPieceInAlbum)
                {
                    if (piece.Parent == null)
                    {
                        listPiece.Add(piece);
                        listPieceInAlbum.Add(piece);
                        foreach (Piece child in piece.Childs)
                            listPieceInAlbum.Add(child);
                        albums.check(piece);
                    }
                }

                foreach (Piece piece in listPieceInAlbum)
                {
                    if (!string.IsNullOrEmpty(piece.ClassName))
                    {
                        allClassed.Add(piece);
                        if (piece.PieceAlbum != null && piece.PieceAlbum.AtLeastOneEnabled)
                            allClassedInAlbumEnabled.Add(piece); 
                    }
                }
                Ranking();
            }
            finally
            {
                lock (_lock)
                    _consolidEnCours = false;
            }

        }

        public void buildMusique()
        {
            foreach (Piece piece in listPieceInAlbum)
            {
                musique.addObj(piece);
            }

            var _albums = musique.getOrCreate("albums");
            foreach (Album album in albums.List)
            {
                CPlayList _alb = _albums.getOrCreate(album.Name);
                var tracks = album.Tracks;
                tracks.Sort(new PieceTrackNumberComparer());
                foreach (Piece piece in tracks)
                {
                    _alb.addObj(piece);
                }
            }

        }

        public void buildLists(CPlayList listes)
        {
            buildList(this.listes, listes);
        }

        private void buildList(CPlayList mine, CPlayList ext)
        {
            foreach (PlComponent c in ext)
            {
                if (c is CPlayList)
                {
                    var subExt = c as CPlayList;
                    var sub = new CPlayList(subExt.Name, mine);
                    sub.ID = subExt.ID;
                    // mine.add(sub);
                    buildList(sub, subExt);
                }
                else
                {
                    var t = c as IFile;
                    var piece = htIds[t.PieceId];
                    mine.add(new TrackList(piece));
                }
            }
        }

        internal Album getAlbum(ITrackMetaData track)
        {
            return albums.getAlbum(track);
        }

        public List<Piece> getTracksAlbum(ITrackMetaData track)
        {
            var album = getAlbum(track);
            if (album == null)
                return null;
            return album.Tracks;
        }

        public void buildAlbum(ITrackMetaData track, List<ITrackMetaData> container)
        {
            var album = getAlbum(track);
            if (album == null)
                return;
            foreach (var p in album.Tracks)
            {
                container.Add(p);
            }
        }

        public List<Piece> sortByClass()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPiece);
                list.Sort(new CPieceComparerByQualityAndLength());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        public List<Piece> sortByAlbum()
        {
            try
            {
                waitForConsolid();
                var list = new List<Piece>(listPieceInAlbum);
                list.Sort(new AllPieceComparer2());
                return list;
            }
            finally
            {
                _consolidEnCours = false;
            }
        }

        private void Ranking()
        {
            QRanking();
            LRanking();
            QLRanking();

            misc.log("setTuningDateValues");
            var list = new List<Piece>(listPiece);
            foreach (Piece piece in list)
            {
                piece.FirstClass = false;
                CRank rank = piece.Rank;
                var sortValue = CTuning.Calc(rank, CConf.Sort);
                rank.SortValue = sortValue;

                ListSelection.setTuningDateValues(piece);
            }

            misc.log("PieceRestComparer->RankRest ");
            list.Sort(new PieceRestComparer());

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }

            list.Sort(new PieceDeltaComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankDelta = i + 1;
            }

            misc.log("PieceSortComparer->Sort ");
            list.Sort(new PieceSortComparer());
            list.Reverse();

            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
            misc.log("AlbumsSort ");
            var all = new List<Piece>(listPieceInAlbum);

            albums.makeSort();
            misc.log("AllPieceComparer->RankAllAlbum ");
            all.Sort(new AllPieceComparer());
            for (int i = 0; i < all.Count; i++)
            {
                all[i].RankAllAlbum = i + 1;
            }

        }

        BackGroundTaskMgr bg = BackGroundTaskMgr.getMgrlarge("copy");
        bool endCopy = false;
        public void CopyFiles(string defaultDir, IEnumerable<ITrackNativeDates> trace)
        {
            if (trace == null)
                return;
            string destDir = CConf.CopyTo;
            if (string.IsNullOrEmpty(destDir))
                return;
            bool copyModeFile = CConf.CopyModeFile;

            if (copyModeFile)
            {

                var list = new List<Piece>();
                foreach (ITrackNativeDates track in trace)
                {

                    list.Add(new Piece(track));
                }


                var l_pieceComparer = new CPieceComparerByQualityAndLength();
                list.Sort(l_pieceComparer);


                //compactage de la liste en tenant compte des mieux not�s
                var remote = new CListPiece(list);

                var l = new List<Piece>(m_listTrackClassed);
                l.Sort(new CPieceComparerByQualityLengthAndEnable());

                using (StreamWriter sr = new StreamWriter(@"..\listCopy.txt", false))
                {
                    bool endCopie = false;
                    int count = m_listTrackClassed.Count;
                    foreach (Piece l_piece in l)
                    {
                        if (endCopie)
                            return;

                        if (!remote.Contains(l_piece) && File.Exists(l_piece.Location))
                        {
                            try
                            {
                                StringBuilder sb = new StringBuilder();

                                sb.Append(l_piece.ClassementValueDecimal);
                                //sb.Append(":");
                                //sb.Append(l_piece.Rating / 20);
                                sb.Append(" ");
                                sb.Append(l_piece.Location);
                                if (!l_piece.Enabled)
                                {
                                    sb.Append(" disabled");
                                }
                                sb.Append("==>");
                                sb.Append(destDir);
                                string txt = sb.ToString();
                                sr.WriteLine(txt);
                                sr.Flush();
                                misc.log("copy " + txt);

                                copy(l_piece, defaultDir, destDir);
                            }
                            catch (Exception ex)
                            {
                                misc.log(ex.ToString());
                                sr.WriteLine(ex.ToString());
                                endCopie = true;
                                // endCopie = true;

                            }
                        }

                    }
                }
            }

            else
            {
                BgDictString<DirectoryInfo> directoriesCopied = new BgDictString<DirectoryInfo>();

                Dictionary<string, int> items = new Dictionary<string, int>();


                DirectoryInfo dest = new DirectoryInfo(destDir);
                DirectoryInfo from = new DirectoryInfo(defaultDir);
                List<DirectoryInfo> dirs = new List<DirectoryInfo>();
                StringBuilder sb = new StringBuilder();
                try
                {

                    recordSoon(directoriesCopied, from, dest, dest);
                    deleteSoon(dest);

                    for (int i = 0; i < m_listTrackClassed.Count; i++)
                    {

                        var l_piece = m_listTrackClassed[i];
                        misc.log(">> check {0} {1} {2} ", (i + 1), l_piece.Location, l_piece.ClassNameAndRating);
                        FileInfo file = new FileInfo(l_piece.Location);
                        DirectoryInfo dir = file.Directory;
                        string path = dir.FullName;
                        if (!directoriesCopied.ContainsKey(path))
                        {
                            if (!items.ContainsKey(path))
                            {
                                items.Add(path, 1);
                            }
                            else
                                items[path]++;

                            bool go = false;
                            int passes = items[path];
                            int nbfiles = 0;
                            foreach (FileInfo f in dir.GetFiles())
                            {
                                if (f.IsMusic())
                                    nbfiles++;
                            }




                            if (nbfiles > 0)
                            {
                                double rapport = (double)passes / (double)nbfiles;
                                misc.log(" {0} passe(s) / {1} fichiers ({2})", passes, nbfiles, rapport);
                                if (rapport > 0.5)
                                    go = true;
                                //if (nbfiles <= 3) go = true;
                                //if (passes == 3 && nbfiles <= 5) go = true;
                                //if (passes >= 5) go = true;


                                if (go)
                                {
                                    misc.log(">> copy {0} {1} ", (i + 1), l_piece.Location);
                                    dirs.Add(dir);
                                    sb.AppendLine(dir.FullName);
                                    directoriesCopied.Add(dir.FullName, null);
                                }
                            }

                        }
                    }
                    misc.log(sb.ToString());
                    File.WriteAllText(@"..\classementAlbums.txt", sb.ToString());

                    foreach (DirectoryInfo dir in dirs)
                    {

                        copy(from, dir, dest);
                    }
                }
                catch
                {
                    misc.log("fin de copie");
                }
            }


        }

        private void copy(Piece piece, string musicFrom, string dirDest)
        {
            string pathDest = piece.Location.Replace(musicFrom, dirDest);
            string[] elts = pathDest.Split(Path.DirectorySeparatorChar);

            StringBuilder sbPath = new StringBuilder();
            sbPath.Append(elts[0]); sbPath.Append(Path.DirectorySeparatorChar);
            DirectoryInfo current = new DirectoryInfo(sbPath.ToString());
            for (int i = 1; i < elts.GetLength(0) - 1; i++)
            {
                string elt = elts[i];
                sbPath.Append(elt); sbPath.Append(Path.DirectorySeparatorChar);
                DirectoryInfo aux = new DirectoryInfo(sbPath.ToString());

                if (!aux.Exists)
                    aux.Create();
                current = aux;
            }
            if (!File.Exists(pathDest))
                File.Copy(piece.Location, pathDest, true);
        }

        private class BgtaskCopy : BgTaskBase
        {
            private FileInfo file;
            private string dest;
            private Consolid master;
            public BgtaskCopy(Consolid master, FileInfo file, string dest)
                : base(dest)
            {
                success = true;
                this.master = master;
                this.file = file;
                this.dest = dest;
            }

            public override void exec()
            {
                try
                {
                    if (master.endCopy)
                        return;
                    file.CopyTo(dest);
                }
                catch (Exception e)
                {
                    misc.log(e.ToString());
                    master.endCopy = true;

                }
            }
        }


        private void recordSoon(BgDictString<DirectoryInfo> dict, DirectoryInfo from, DirectoryInfo baseDirectory, DirectoryInfo dir)
        {
            string path = dir.FullName.Replace(baseDirectory.FullName, from.FullName);
            if (!string.IsNullOrEmpty(path))
                dict.Add(path, dir);

            foreach (DirectoryInfo sub in dir.GetDirectories())
                recordSoon(dict, from, baseDirectory, sub);
        }

        private void deleteSoon(DirectoryInfo dir)
        {
            try
            {
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    deleteSoon(sub);
                dir.Delete();
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.ToString());
            }
        }

        private void copy(DirectoryInfo from, DirectoryInfo dir, DirectoryInfo dest)
        {
            try
            {
                if (endCopy)
                    return;
                misc.log("copy {0} ", dir.FullName);
                string path = dir.FullName.Replace(from.FullName, "");
                string[] elts = path.Split(Path.DirectorySeparatorChar);

                DirectoryInfo current = dest;
                bool toBeCreated = false;
                foreach (string elt in elts)
                {
                    DirectoryInfo sub = new DirectoryInfo(current.FullName + Path.DirectorySeparatorChar + elt);
                    if (!sub.Exists)
                    {
                        toBeCreated = true;
                        sub.Create();
                    }
                    current = sub;
                }

                if (!toBeCreated)
                {
                    bool _continue = true;
                    var aux = current;
                    while (_continue)
                    {
                        try
                        {

                            current.Delete();
                            current = current.Parent;
                            _continue = true;

                        }
                        catch
                        {
                            _continue = false;
                        }
                    }
                    return;
                }

                foreach (FileInfo file in dir.GetFiles())
                {
                    if (endCopy)
                        return;
                    string fileDest = current.FullName + Path.DirectorySeparatorChar + file.Name;
                    misc.log("copy " + fileDest);
                    file.CopyTo(fileDest);
                }
            }
            catch (Exception e)
            {
                misc.log(dir.FullName + " " + e.Message);
                throw;
            }
        }

        private static List<Piece> m_listQL;
        public static List<Piece> QLClassed
        {
            get
            {
                return m_listQL;
            }
        }
        /// <summary>
        /// calcul du classement en fonction des listes 
        /// </summary>
        /// <remarks></remarks>
        private void QRanking()
        {
            misc.log("Qranking");



            CPieceComparerByGoodness l_pieceComparer = new CPieceComparerByGoodness();

            foreach (Piece piece in listPiece)
            {
                piece.Rank.init();
            }


            //on ordonne les morceaux top-down => sont privil�gi�s les plus en vue
            listPiece.Sort(l_pieceComparer);

            //compactage de la liste en tenant compte des mieux not�s
            m_list = new CListPiece(listPiece);

            misc.log("Qranking:legacyList Compact:" + m_list.Count);

            foreach (Piece l_piece in m_list)
            {
                if (l_piece.ClassName != "")
                {
                    m_listTrackClassed.Add(l_piece);
                }
            }

            misc.log("Qranking:track classed :" + m_listTrackClassed.Count);
            int l_nbPiece = 0;

            int l_iLast = 0;
            int l_count = m_listTrackClassed.Count;
            for (int i = 0; i <= l_count - 2; i++)
            {
                l_nbPiece += 1;
                Piece l_One = m_listTrackClassed[i];
                Piece l_Two = m_listTrackClassed[i + 1];


                int l_iCmp = l_pieceComparer.Compare(l_One, l_Two);
                if (l_iCmp == 0)
                {
                }
                else
                {
                    int rank = getRank(l_iLast, l_nbPiece);

                    for (int ii = l_iLast; ii <= i; ii++)
                    {
                        m_listTrackClassed[ii].QRank = rank;
                    }

                    l_iLast = l_nbPiece;
                }
            }

            for (int ii = l_iLast; ii <= l_count - 1; ii++)
            {
                int rank = getRank(l_iLast, l_nbPiece);
                m_listTrackClassed[ii].QRank = rank > 0 ? rank : 1;
            }

            CTuning.Total = m_listTrackClassed.Count;

            foreach (Piece piece in listPiece)
            {
                if (piece.QRank <= 0)
                    piece.QRank = CTuning.Total;
            }

            Console.WriteLine("Qranking:total class�s : " + m_listTrackClassed.Count);

        }

        private int getRank(int l_iLast, int l_nbPiece)
        {
            double qRank = l_iLast + 1 + l_nbPiece;
            switch (CConf.RankingType)
            {
                case rankingType.middle: qRank = 0.5 * qRank; break;
                case rankingType.up: qRank = l_iLast + 1; break;
                case rankingType.bottom: qRank = l_nbPiece; break;
                default:
                    break;
            }
            return Convert.ToInt32(qRank);
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur longueur
        /// </summary>
        /// <remarks></remarks>
        private void LRanking()
        {
            misc.log("LRanking");
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByLenght());
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.LRank = l_iIndex + 1;
            }
        }
        /// <summary>
        /// Tri des morceaux en fonction de leur qualit� +longueur en cas d'�galit�
        /// </summary>
        /// <remarks></remarks>
        private void QLRanking()
        {
            misc.log("QLRanking");
            m_listQL = new List<Piece>(m_listTrackClassed);
            m_listQL.Sort(new CPieceComparerByQualityAndLength());
            List<Piece> l_aux = new List<Piece>(listPiece);
            l_aux.Sort(new CPieceComparerByQualityAndLength());
            int count = l_aux.Count;
            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.QLRank = l_iIndex + 1;
            }

            l_aux.Sort(new CPieceComparerByQualityAndLengthInv());

            for (int l_iIndex = 0; l_iIndex <= l_aux.Count - 1; l_iIndex++)
            {
                Piece l_piece = l_aux[l_iIndex];
                l_piece.Rank.TwiceInv = l_iIndex + 1;
            }

            if (CConf.Condensation)
            {
                var l = new List<Piece>(this.listPiece);
                l.Sort(new CPieceComparerByQualityAndLength2());
                new Condenseur(m_listQL).gener2();

            }

        }

        public void builStats()
        {
            try
            {
                new StatBuilder(m_listQL).gener3(step % 10 == 0);
                var unselected = m_listQL.FindAll(t => !t.Enabled);
                new StatBuilder(unselected).gener3("courant3.txt", (step % 10 == 0));
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
        }


        public DynamicStat generStat(string className, bool onlyDisabled)
        {
            var list = m_listQL;
            if (onlyDisabled)
                list = m_listQL.FindAll(t => !t.Enabled);
            return new DynamicStatBuilder(list).gener(className);
        }



        public void timeRanking()
        {
            misc.log("timeRanking");
            foreach (var piece in allClassed)
                ListSelection.setTuningDateValues(piece);


        }

        /// <summary>
        /// redirection des index metier de la table m�tier vers la table locale
        /// Copie des valeurs pertinentes(classlist)
        /// </summary>
        /// <remarks></remarks>
        public void eraseGrouping()
        {
            thCommentGo = false;
            thGroupingGo = false;
            misc.log("eraseGrouping");
            foreach (Piece piece in listPieceInAlbum)
            {
                piece.setGrouping("", false);
                piece.Comment = "";
            }
        }
        public void writeGrouping()
        {
            misc.log("writeGrouping");
            var list = new List<Piece>(listPieceInAlbum);
            // list.Sort(new CPieceComparerByQualityAndLength());
            list.Sort(new AllPieceComparer2());

            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }


        private bool thGroupingGo;
        private bool thCommentGo;

        public bool GroupinGO
        {
            set
            {
                thGroupingGo = value;
                if (value)
                {
                }
            }
        }
        public bool CommentGo
        {
            set
            {
                thCommentGo = value;
                if (value)
                {
                }
            }
        }



        private void writeGroupingAsync()
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            foreach (Piece piece in listPieceInAlbum)
            {
                try
                {
                    if (!thGroupingGo)
                        return;
                    piece.writeGrouping(writeGrouping);
                }
                catch (Exception ex)
                {
                    misc.log("writeGrouping::" + ex.ToString());
                }

            }
        }

        private void writeCommentAsync()
        {
            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in listPiece)
            {
                try
                {
                    if (!thCommentGo)
                        return;
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }
        }

        public void writeGrouping(Piece piece)
        {
            var writeGrouping = CConf.ConfGen.WriteGrouping;
            piece.writeGrouping(writeGrouping);

        }
        private bool _sortByAlbum = true;
        public bool SortByAlbum { set { _sortByAlbum = value; } }

        private bool _albumSortStrict = CConf.ConfGen.AlbumSortStrict;
        public bool SortAlbumStrict { set { _albumSortStrict = value; } get { return _albumSortStrict; } }

        public void writeComment()
        {
            misc.log("writeComment");
            var list = new List<Piece>(listPiece);
            list.Sort(new CPieceComparerByQualityAndLength());

            var writeComment = CConf.ConfGen.WriteComment;
            foreach (Piece piece in list)
            {
                try
                {
                    piece.writeComment(writeComment);
                }
                catch (Exception ex)
                {
                    misc.log("writeComment::" + ex.ToString());
                }
            }




        }

        public void writeComment(Piece piece)
        {
            var writeComment = CConf.ConfGen.WriteComment;
            try
            {
                piece.writeComment(writeComment);
            }
            catch (Exception ex)
            {
                misc.log("writeComment::" + ex.ToString());
            }
        }



        #region "rot"
        private CLegacyListWriter m_listWriter;
        private CLegacyListWriter listWriterAll;
        // Private m_rotTotalDuration As Integer = 0

        // private int m_rotPeriod = 0;
        public void createRot(string a_baseName, params IListWriter[] writers)
        {
            var conf = CConf.ConfGen;

            misc.log("Clegacy:createRot {0}", a_baseName);
            List<Piece> l_list = new List<Piece>();
            List<Piece> source = null;
            if (_sortByAlbum)
                source = allClassedInAlbumEnabled;
            else
                source = m_listTrackClassed;
            foreach (Piece l_piece in source)
            {
                //if (l_piece.belongsTo(a_baseName))
                //{
                l_list.Add(l_piece);
                // }
            }
            m_listWriter = new CLegacyListWriter(l_list, _sortByAlbum);

            l_list = new List<Piece>();
            foreach (Piece piece in listPieceInAlbum)
                l_list.Add(piece);

            listWriterAll = new CLegacyListWriter(l_list, _sortByAlbum);


            foreach (IListWriter writer in writers)
                m_listWriter.addWriter(writer);

            foreach (IListWriter writer in writers)
                listWriterAll.addWriter(writer);

            //      m_listWriter.reset();
            foreach (var duration in conf.Listes)
            {


                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(mode, duration, "g", false);
                    m_listWriter.writeGen(mode, duration, "e", true);
                }
            }

            if (conf.GenCheck)
                m_listWriter.writeCheckClassement(0);

            for (int precision = conf.PrecisionMin.item; precision <= conf.PrecisionMax.item && precision > 0; precision++)
            {
                m_listWriter.writePrecisionClassement("g", precision, false, conf.PrecisionMin.extend);
                m_listWriter.writePrecisionClassement("e", precision, true, conf.PrecisionMin.extend);
            }


            foreach (var duration in conf.Listes)
            {

                foreach (var mode in conf.Modes) //  Enum.GetValues(typeof(datesMode)))
                {

                    foreach (Piece piece in allClassed)
                        ListSelection.setTuningDateValues(piece, mode.item);

                    m_listWriter.writeGen(albums, mode, duration, "g", false);
                }
            }

            listWriterAll.writeGen(albums, null, null, "all", false);

            return;

            writeRot(1);

            m_listWriter.writeCheckClassement(1);

            m_listWriter.reset();
            writeRotMin(-1);
            writeRotMin(10);
            writeRotMin(1);
        }
        private void writeRotMin(int a_nbHour)
        {
            misc.log("----------------------");
            m_listWriter.writeRotMin(a_nbHour);
        }
        private void writeRot(int a_base)
        {
            m_listWriter.writeRot(a_base);

        }
        #endregion
    }
}



]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    class Album
    {
        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen; 

        private List<Piece> list = new List<Piece>();
        public Album(string name)
        {
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        //private Piece equiv;


        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true; 
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        public List<Piece> Tracks
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceClassementValueComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        public void makeSort() //IList<double> reference, IList<Piece> pieces)
        {
            decimal offset = conf.AlbumMoyOffset; 
            int count = list.Count; 
            list.Sort(new PieceSortComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < count; i++)
            {
                listSortedValues.Add(list[i].Rank.SortValue);
                if (!classed && list[i].isClassListNumeric)
                    classed = true;
            }
            m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne);

            listSortedValues = new List<decimal>();
            list.Sort(new PieceDurationValueComparer());
            for (int i = 0; i < count; i++)
                listSortedValues.Add(list[i].Duration.TotalMilliseconds());
            durationValue = CalcMedianne.getMedianne(listSortedValues, medianne);



            listSortedValues = new List<decimal>();
            list.Sort(new PieceClassementValueComparer());
            decimal moy = 0m; 
            for (int i = 0; i < count; i++)
            {
                var rapportClassement = list[i].RapportClassement;
                moy += rapportClassement;
                if (offset > 0m && rapportClassement > 0.0m)
                    moy += offset; 

                listSortedValues.Add(rapportClassement);
            }
            if (count > 0)
                moy /= count;
            classMoy = moy; 
            classementValue = CalcMedianne.getMedianne(listSortedValues, medianne);


            //int iequiv = CalcMedianne.getEquiv(reference, m_rank.SortValue, 0, reference.Count - 1);
            //equiv = pieces[iequiv];
            equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 
            moyenne = Piece.getClassementEquiv(classMoy); 



        }

        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest);
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumComparer.cs">
    <content><![CDATA[using System.Collections.Generic;
using System.IO;
using System;
using pdb.gen.conf;

namespace pdb.gen.albums
{
    class AlbumClassComparer : IComparer<Album>
    {
        private bool albumSortStrict;
        public AlbumClassComparer(bool albumSortStrict)
        {
            this.albumSortStrict = albumSortStrict;
        }
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            //if (x.Name == "Alien Lanes" || y.Name == "Alien Lanes")
            //{
            //    int toto = 0; 
            //}
            //si classement == 0 mais que l'autre est tellement nul que m�me ma moyenne est sup�rieure � sa moyenne
            int cmp = 0;
            if (!albumSortStrict)
            {
                if (x.ClassementValue == 0m || y.ClassementValue == 0m)
                {
                    cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
                    if (cmp != 0)
                        return cmp;
                }
            }


            cmp = x.ClassementValue.CompareTo(y.ClassementValue);
            if (cmp != 0)
                return cmp;

            cmp = x.ClassementMoy.CompareTo(y.ClassementMoy);
            if (cmp != 0)
                return cmp;

            int i = 0;
            var t1 = -2m;
            var t2 = -2m;
            while (true)
            {
                t1 = x.getTrackSortValue(i);
                t2 = y.getTrackSortValue(i);

                cmp = t1.CompareTo(t2);
                if (cmp != 0)
                    return cmp;



                if (t1 == 0)
                    break;

                i++;

            }
            cmp = x.DurationValue.CompareTo(y.DurationValue);
            if (cmp != 0)
                return cmp;
            return -x.Name.CompareTo(y.Name);

        }
    }

    class AlbumClassComparer2 : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            return x.Rank.Sort.CompareTo(y.Rank.Sort);
        }
    }


    class AlbumSortComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            if (x == y)
                return 0;

            if (x == null)
                return 1;

            if (y == null)
                return -1;

            int cmp = x.Rank.SortValue.CompareTo(y.Rank.SortValue);
            if (cmp != 0)
                return cmp;

            if (x.Rank.SortValue == 0)
            {

            }

            var xx = x.getFirstTrackSortValue();
            var yy = y.getFirstTrackSortValue();

            return xx.CompareTo(yy);

        }
    }

    class AlbumRestComparer : IComparer<Album>
    {
        static AlbumSortComparer subCmp = new AlbumSortComparer();
        const decimal EPSILON = 0.00001m;
        public int Compare(Album x, Album y)
        {
            var xx = x.Rank.TimeRest;
            var yy = y.Rank.TimeRest;
            int cmp = 0;
            if (Math.Abs(xx - yy) >= EPSILON)
                cmp = xx.CompareTo(yy);
            if (cmp == 0)
                return subCmp.Compare(x, y);
            return cmp;
        }
    }

    class PieceInAlbumComparer : IComparer<Piece>
    {
        private bool debile(int trackNumber)
        {
            return trackNumber <= 0 || trackNumber > 100;
        }

        private bool debile(Piece piece)
        {
            return debile(piece.TrackNumber);
        }
        public int Compare(Piece x, Piece y)
        {
            if (debile(x))
            {
                if (debile(y))
                {
                    var f1 = Path.GetFileName(x.Location);
                    var f2 = Path.GetFileName(y.Location);
                    return f1.CompareTo(f2);
                }
                return -1;
            }
            if (debile(y))
                return 1;
            return x.TrackNumber.CompareTo(y.TrackNumber);
        }
    }

    class AllPieceComparer : IComparer<Piece>
    {
        PieceInAlbumComparer pieceComp = new PieceInAlbumComparer();
        IComparer<Album> albumcomp = new AlbumClassComparer2();

        public int Compare(Piece x, Piece y)
        {
            int cmp = albumcomp.Compare(x.PieceAlbum, y.PieceAlbum);
            if (cmp != 0)
                return cmp;
            return -pieceComp.Compare(x, y);
        }
    }

    class AllPieceComparer2 : IComparer<Piece>
    {
        public int Compare(Piece x, Piece y)
        {
            return -x.RankAllAlbum.CompareTo(y.RankAllAlbum);
        }
    }

    class AlbumNameComparer : IComparer<Album>
    {
        public int Compare(Album x, Album y)
        {
            return x.Name.CompareTo(y.Name);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using pdb.util;
using System.Collections.Generic;
using System;
using pdb.obj;

namespace pdb.gen.albums
{
    class Albums
    {
        public Albums(Consolid consolid)
        {
            this.consolid = consolid; 
        }
        private BgDictString<Album> dict = new BgDictString<Album>();
        private Consolid consolid; 
        private void check_(Piece piece)
        {
            string __album = "-"; 
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                var album = dict[__album];
                if (album == null)
                {
                    album = new Album(__album);
                    dict.Add(__album, album); 
                }
                album.add(piece);
               
            }
          

        }

        public void check(Piece piece)
        {
            check_(piece);
            foreach (Piece child in piece.Childs)
                check_(child); 
        }

        public Album getAlbum(ITrackMetaData piece)
        {
            string __album = "-";
            var _album = piece.Album;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim();
                return dict[__album];
            }
            return null; 
        }

        public void makeSort()
        {
            var listRef = new List<double>();
            //foreach (Piece piece in reference)
            //    listRef.Add(piece.RapportClassement); // piece.Rank.SortValue); 
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSort(); //listRef, reference); 
            }

            list.Sort(new AlbumClassComparer(consolid.SortAlbumStrict));
            list.Reverse();
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.Sort = i + 1;
            }
        }

        public List<Album> makeSelection()
        {
            var list = new List<Album>(dict.Values);
            foreach (Album album in list)
            {
                album.makeSelection();
            }
            list.Sort(new AlbumRestComparer());
            for (int i = 0; i < list.Count; i++)
            {
                list[i].Rank.RankRest = i + 1;
            }
            return list; 
        }


        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list; 
            }
        }


      
    }
}
]]></content>
  </file>
</db>
