<db path="C:\Bernard\db1\pdb4">
  <file path="\pdb.player\ViewModel\Commande\PlayList\ExportCmd.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using pdb.db;
using pdb.db.obj;
using pdb.gen;
using pdb.util;
using pdb.gen.Tuning;
using System.Runtime.InteropServices;
using pdb.gen.albums;
using pdb.obj;

namespace pdb.player.ViewModel.Commande.PlayList
{
    class StatAlbum
    {
        private string key;
        private int count;

        public void clear()
        {
            count = 0;
        }

        public StatAlbum(string key)
        {
            this.key = key;
        }

        public override bool Equals(object obj)
        {
            if (obj is StatAlbum)
            {
                return key.Equals(((StatAlbum)obj).key);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return key.GetHashCode();
        }

        public int Count { get { return count; } }
        public void record()
        {
            count++;
        }
    }

    class StatAlbums
    {
        private BgDictString0<StatAlbum> dict = new BgDictString0<StatAlbum>();

        public void clear()
        {
            foreach (var stat in dict)
            {
                stat.Value.clear();
            }
        }

        public StatAlbum getStat(Album album)
        {
            var key = album.Key;
            var s = dict[key];
            if (s == null)
            {
                s = new StatAlbum(key);
                dict.Add(key, s);
            }
            return s;
        }
    }


    public enum compressState
    {
        none,
        enCours,
        reload,
        cancel
    }




    class ExportCmd : CommandeBase
    {
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GetDiskFreeSpaceEx(string lpDirectoryName,
        out ulong lpFreeBytesAvailable,
        out ulong lpTotalNumberOfBytes,
        out ulong lpTotalNumberOfFreeBytes);

        private static long getFreeSpace()
        {
            ulong FreeBytesAvailable;
            ulong TotalNumberOfBytes;
            ulong TotalNumberOfFreeBytes;

            bool success = GetDiskFreeSpaceEx(conf.dir, out FreeBytesAvailable, out TotalNumberOfBytes,
                               out TotalNumberOfFreeBytes);
            if (!success)
                throw new System.ComponentModel.Win32Exception();
            return (long)TotalNumberOfFreeBytes;
        }



        private static IExportTracks ihm;
        public static IExportTracks Ihm { set { ihm = value; } }
        // private static bool cancel;
        // protected static string dir;
        protected static PlayListViewModel lastpl;
        protected static List<PiecePrior> presents;
        protected static Dict<int, PiecePrior> dict;
        protected static List<PiecePrior> list;
        protected static List<List<PiecePrior>> listes;
        protected static List<PlayListViewModel> playlists = new List<PlayListViewModel>();
        protected static Dict<string, string> empreintes = new Dict<string, string>();
        protected static StatAlbums statAlbums = new StatAlbums();

        //  protected static Dictionary<int, object> ids;
        protected static HashSet<int> idCopie;
        protected static HashSet<string> idCopieLoc;
        private static int nbLoop = 0;
        protected static Export conf;
        private static bool modeAlbum;
        //private static int nbByAlbumMin = int.MaxValue;
        //private static int nbByAlbumMax = int.MaxValue;
        //private static int nbLot = 100; 
        protected static int nbFicherSup;
        protected static int nbFichierAdd;
        const string CAPTION = "export";
        protected string ANNULATION_EXPORT = "Annulation export";
        protected static volatile object _lock = new object();
        protected static Thread thCalcul;
        protected static Thread thCopy;

        protected static bool endCopy;
        protected static bool endCopyFinal; 
        protected static compressState copy;
        protected static bool endCalcul;

        protected static compressState query;

        //protected static BgDictString<List<PiecePrior>> locations = new BgDictString<List<PiecePrior>>();

        protected static ILogger logger = Logger.getLogger("export");

        protected static void sendCancel()
        {
            lock (_lock)
            {
                if (query < compressState.cancel)
                    query = compressState.cancel;
            }
        }
        protected static compressState Query
        {
            get
            {
                lock (_lock)
                    return query;
            }
            set
            {
                lock (_lock)
                    query = value;
            }
        }





        public static void CalculExport()
        {
            if (conf != null && conf.oneShot)
                return;
            switch (Query)
            {
                case compressState.none:
                    break;
                case compressState.enCours:
                    //if (checkSthChange())
                    //{
                    //PlayListViewModel.resetExport(exportState.none);
                    Query = compressState.reload;
                    //lock (_lock)
                    //    state = compressState.reload;
                    //}
                    break;
                case compressState.cancel:
                    PlayListViewModel.resetExport(exportState.none);
                    Query = compressState.none;
                    break;
                default:
                    break;
            }
        }

        private static bool checkSthChange()
        {
            bool ret = false;
            foreach (PlayListViewModel pl in playlists)
            {
                var emp = empreintes[pl.Name];
                logger.log("{0} ancienne empreinte {1}", pl.Name, emp);
                var _newEmpre = pl.getEmpreinte();
                logger.log("{0} nouvelle empreinte {1}", pl.Name, _newEmpre);
                if (emp != _newEmpre)
                {
                    logger.log("on recalcule");
                    ret = true;
                }
                empreintes[pl.Name] = _newEmpre;

            }
            return ret;

        }

        protected class PiecePrior
        {
            private int prior0 = int.MaxValue;
            private int prior1 = int.MaxValue;
            public readonly Piece PieceGen;
            public PiecePrior(Piece piece, int prior)
            {
                this.PieceGen = piece;
                this.prior0 = prior;
            }

            public CListFile Files { get { return (PieceGen.Track as CPiece).Files; } }

            public int Prior0 { get { return prior0; } }
            public int Prior1 { get { return prior1; } }
            // public int MasterId { get { return Piece.MasterId; } }
            public int PieceId { get { return PieceGen.PieceId; } }
            public void setPrior(int prior)
            {
                if (prior < this.prior1)
                    this.prior1 = prior;
            }

            public static void mergePrior0(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p0 = p.prior0;
                    if (p0 < min)
                        min = p0;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public static void mergePrior1(ICollection<PiecePrior> list)
            {
                if (list.Count <= 1)
                    return;
                int min = int.MaxValue;
                foreach (PiecePrior p in list)
                {
                    var p1 = p.prior1;
                    if (p1 < min)
                        min = p1;
                }
                foreach (PiecePrior p in list)
                {
                    p.prior0 = min;
                }
            }

            public override string ToString()
            {
                int rank = PieceGen.RankAlbumReverse;
                int nb = PieceGen.NbExportPresents;
                return string.Format("{0} {1} {2}\t {3} {4} {5}", rank, nb, PieceGen.TrackNumber, prior0, prior1, PieceGen.ToString());
                //  return rank + " " + PieceGen.TrackNumber + "\t" + prior0 + " " + prior1 + " " + PieceGen.ToString();
            }
        }

        protected class PriorComparer : IComparer<PiecePrior>
        {
            public int Compare(PiecePrior x, PiecePrior y)
            {
                int cmp = x.Prior1.CompareTo(y.Prior1);
                if (cmp != 0)
                    return cmp;
                return x.Prior0.CompareTo(y.Prior0);
            }
        }

        public ExportCmd()
        {

        }


        public override bool CanExecute(object parameter)
        {
            return ihm != null;
        }

        public override void Execute(object parameter)
        {
            if (Query <= compressState.none)
                record();
            else
            {
                sendCancel();
                PlayListViewModel.resetExport(exportState.none);
            }
            OnPropertyChanged("Header");
        }
        private class TrackAlbumReverseComparer : IComparer<TrackListViewModel>
        {
            //  private static PieceClassementComparerInv comparer = new PieceClassementComparerInv();
            //private bool disabledAlway;

            //public TrackAlbumReverseComparer(bool disabledAlway)
            //{
            //    this.disabledAlway = disabledAlway; 
            //}

            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var xx = x.PieceGen;
                var yy = y.PieceGen;
                if (xx.PieceAlbum != yy.PieceAlbum)
                    return x.Index.CompareTo(y.Index);

                return xx.IndexExport.CompareTo(yy.IndexExport);

                //if (disabledAlway)
                //{
                //    if (x.Enabled != y.Enabled)
                //    {
                //        return -x.Enabled.CompareTo(y.Enabled); // ? -1 : 1;
                //    }
                //}
                //var xv = x.PieceGen.RapportClassement;
                //var yv = y.PieceGen.RapportClassement;

                //int cmp = 0;
                //if (xv > 0 && yv > 0)
                //{
                //    cmp = xv.CompareTo(yv);
                //    if (cmp != 0) return cmp;
                //    cmp = x.PieceGen.VirtualClassement.CompareTo(y.PieceGen.VirtualClassement);
                //    if (cmp != 0) return cmp;
                //}

                //cmp = x.TrackNumber.CompareTo(y.TrackNumber);
                //if (cmp != 0)
                //    return cmp;
                //return x.Location.CompareTo(y.Location);

            }
        }
        protected virtual List<PiecePrior> buildList(PlayListViewModel pl)
        {

            var list = new List<PiecePrior>();
            try
            {
                bool onlyEnabled = PlayerViewModel.Instance.OnlyEnabled && !modeAlbum;
                bool _modeAlbum = modeAlbum && !PlayerViewModel.Instance.SortByAlbum;

                // var ids = new Dictionary<int, object>();
                int i = 0;
                var tracks = new List<TrackListViewModel>(pl.ExportTracks);
                logger.log("export::buildList {0} {1} elements", pl, tracks.Count);
                if (conf.albumReverse)
                {
                    tracks.Sort(new TrackAlbumReverseComparer()); //conf.disabledAlway));

                }
                else
                    tracks.Sort((x, y) => x.Index.CompareTo(y.Index));

                int lastI = 0;
                Album lastAlbum = null;
                StatAlbum lastStatAlbum = null;
                //  int inext = -1; 
                int nbByAlbum = int.MaxValue;
                int limitMax = int.MaxValue;
                if (conf.modeAlbum)
                {
                    nbByAlbum = conf.nbMax;
                    limitMax = conf.limitMax;
                    if (limitMax < nbByAlbum)
                        limitMax = nbByAlbum;
                }
                int nbLot = 0;
                int ii = -1;
                var ids = new HashSet<int>();
                while (true)
                {

                    if (query != compressState.enCours)
                        return list;
                    int nbInThisAlbum = 0;
                    foreach (TrackListViewModel track in tracks)
                    {
                        if (query != compressState.enCours)
                            return list;
                        ii++;
                        int id = track.PieceGen.PieceId;
                        if (ids.Contains(id))
                            continue;
                        //  track.ExportStatus = exportState.miss; 
                        if (!onlyEnabled || track.Enabled)
                        {
                            // CPiece piece = track.Piece;
                            if (track.Exists)
                            {
                                var pp = dict[id]; // list.Add(piece);
                                if (pp == null)
                                {
                                    pp = new PiecePrior(track.PieceGen, ii);
                                    dict[id] = pp;
                                    presents.Add(pp);
                                }

                                if (!_modeAlbum)
                                {
                                    if (track.album == lastAlbum)
                                    {
                                        if (lastStatAlbum.Count > limitMax)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;
                                    }
                                    else
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);
                                        lastStatAlbum = statAlbums.getStat(lastAlbum);
                                        if (lastStatAlbum.Count > limitMax)
                                            continue;

                                        if (track.Enabled || (conf.countFirsts && track.PieceGen.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && track.PieceGen.VirtualClassement <= lastAlbum.ClassementValueLight))
                                            nbInThisAlbum++;
                                        else if (nbInThisAlbum >= nbByAlbum)
                                            continue;
                                        if (nbInThisAlbum > nbByAlbum)
                                            continue;

                                    }

                                    pp.setPrior(i);
                                    list.Add(pp);
                                    lastStatAlbum.record();
                                    ids.Add(id);
                                    i++;

                                    //  if (track.Enabled || conf.countAll)
                                    nbLot++;

                                    if (conf.modeAlbum && nbLot > conf.lot)
                                    {
                                        nbLot = 0;
                                        nbByAlbum--;
                                        if (nbByAlbum < conf.nbMin)
                                            nbByAlbum = conf.nbMin;
                                        if (nbByAlbum == 0)
                                            break;

                                        limitMax = conf.limitMax;
                                        if (limitMax < nbByAlbum)
                                            limitMax = nbByAlbum;

                                    }


                                }
                                else
                                {
                                    if (conf.modeAlbum)
                                    {
                                        if (track.album == lastAlbum)
                                            continue;
                                        else
                                        {
                                            nbLot++;
                                            if (nbLot > conf.lot)
                                            {
                                                nbLot = 0;
                                                nbByAlbum--;
                                                if (nbByAlbum < conf.nbMin)
                                                    nbByAlbum = conf.nbMin;
                                                if (nbByAlbum == 0)
                                                    break;

                                                limitMax = conf.limitMax;
                                                if (limitMax < nbByAlbum)
                                                    limitMax = nbByAlbum;
                                            }
                                        }
                                    }
                                    List<Piece> album = null;
                                    if (conf.albumReverse)
                                        album = App.gen.getTracksAlbumReverse(track.Track);
                                    else
                                        album = App.gen.getTracksAlbumByNumber(track.Track); // piece);
                                    if (album != null)
                                    {
                                        nbInThisAlbum = 0;
                                        lastAlbum = track.album;// inext = lastAlbum.IndexClass(lastAlbum.Next);  //.Album;
                                        foreach (var p in album)
                                        {
                                            var piece = p.Track as CPiece;
                                            if (piece != null && piece.Exists)
                                            {
                                                if (!onlyEnabled || piece.Enabled)
                                                {
                                                    id = p.PieceId;

                                                    //if (ids.Contains(id))
                                                    //    continue;
                                                    var ppp = dict[id];
                                                    ppp.setPrior(i);
                                                    list.Add(ppp);
                                                    //   ids.Add(id);
                                                    i++;
                                                    if (piece.Enabled || (conf.countFirsts && p.VirtualClassement >= lastAlbum.ClassementValueLight) || (conf.countLasts && p.VirtualClassement <= lastAlbum.ClassementValueLight))
                                                    {
                                                        nbLot++;
                                                        if (conf.modeAlbum && nbLot > conf.lot)
                                                        {
                                                            nbLot = 0;
                                                            nbByAlbum--;
                                                            if (nbByAlbum < conf.nbMin)
                                                                nbByAlbum = conf.nbMin;

                                                            limitMax = conf.limitMax;
                                                            if (limitMax < nbByAlbum)
                                                                limitMax = nbByAlbum;
                                                        }

                                                        nbInThisAlbum++;
                                                        if (nbInThisAlbum >= nbByAlbum)
                                                            break;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (!modeAlbum)
                        break;
                    if (nbByAlbum == int.MaxValue)
                        break;
                    if (nbByAlbum > 0)
                    {
                        if (i == lastI)
                            break;
                    }

                    lastI = i;
                    lastAlbum = null;
                    if (conf.modeAlbum)
                    {
                        if (conf.resetAfterLoop)
                            nbByAlbum = conf.nbMax;
                        if (nbByAlbum < conf.nbMin)
                            nbByAlbum = conf.nbMin;
                        if (nbByAlbum == 0)
                            nbByAlbum = 1;

                        limitMax = conf.limitMax;
                        if (limitMax < nbByAlbum)
                            limitMax = nbByAlbum;
                    }
                }
                listes.Add(list);
                //   ihm.InfoIHm("liste n° " + listes.Count + " " + list.Count + " éléments", CAPTION);
                OnPropertyChanged("Header");
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }
            return list;
        }

        public override string Header
        {
            get
            {
                if (query == compressState.enCours || query == compressState.reload)
                    return ANNULATION_EXPORT;

                return "Exporter la liste";
            }
        }



        private void record()
        {
            if (Query == compressState.none)
            {

                OnPropertyChanged("Header");
                nbLoop = 0;
                conf = ihm.getConfExport("Configuration Export");

                //  dir = conf.dir; // ihm.folderDialog();

                if (string.IsNullOrEmpty(conf.dir))
                {
                    Query = compressState.none;
                    return;
                }

                modeAlbum = conf.modeAlbum; // ihm.Confirm("par albums complets?", CAPTION);

                //if (modeAlbum)
                //{
                //    nbByAlbumMin = conf.nbMin; // ihm.getNb("Nombre de morceaux par passe?");
                //    nbByAlbumMax = conf.nbMax;
                //    nbLot = conf.lot;
                //}
                //else
                //    nbByAlbum = int.MaxValue;

                playlists.Clear(); empreintes.Clear();
            }

            bool? status = true;


            var pl = ihm.PlayList;
            if (!playlists.Contains(pl))
            {
                playlists.Add(pl);
                empreintes[pl.Name] = pl.getEmpreinte();
                lastpl = pl;
            }

            status = ihm.TriChoix("liste n° " + playlists.Count + " " + pl.ExportTracks.Count + " éléments\r\n lancer l'export ?", CAPTION);



            if (status == null)
            {
                //listes = new List<List<PiecePrior>>();
                playlists.Clear(); empreintes.Clear();
                Query = compressState.none;
                OnPropertyChanged("Header");
                return;
            }
            if (false.Equals(status))
            {
                OnPropertyChanged("Header");
                return;
            }

            waitCalculForEnd();

            Query = compressState.enCours;

            lock (_lock)
            {
                if (thCalcul == null)
                {
                    thCalcul = new Thread(calculLoop);
                    thCalcul.SetApartmentState(ApartmentState.STA);
                    thCalcul.Start();
                }

                if (thCopy == null)
                {
                    thCopy = new Thread(copyLoop);
                    thCopy.SetApartmentState(ApartmentState.STA);
                    thCopy.Start();
                }
            }


            OnPropertyChanged("Header");
        }
        //protected static long totalSize = 0;
        //protected static long capacity = int.MaxValue;
        //protected static long freeSpace; 
        //private static void refreshInfoFreeSpace()
        //{
        //    DriveInfo drive = new DriveInfo(Path.GetPathRoot(conf.dir));
        //    var calculfree = freeSpace; 
        //    freeSpace = drive.AvailableFreeSpace;
        //    var delta = freeSpace - calculfree;
        //    if (delta > 0)
        //        App.log.log("difference free space " + delta); 

        //}

        private void buildListIni()
        {

            logger.log("export:buildListIni");
            lock (_lock)
            {
                statAlbums.clear();
                listes = new List<List<PiecePrior>>();
                presents = new List<PiecePrior>();
                dict = new Dict<int, PiecePrior>();
            }
            //  locations = new BgDictString<List<PiecePrior>>();

            try
            {

                if (!conf.dir.EndsWith("\\"))
                    conf.dir += "\\";
                //  refreshInfoFreeSpace(); 

                List<Piece> l = null;


                if (lastpl.isSubList("album") || PlayerViewModel.Instance.SortByAlbum)
                {
                    l = App.gen.sortByAlbum();
                    l.Reverse();
                }
                else
                    l = App.gen.sortByClass();
                // l.Reverse();

                int i = 0;
                foreach (Piece p in l)
                {

                    if (query != compressState.enCours)
                        return;
                    //var piece = p.Track as CPiece;
                    if (!dict.ContainsKey(p.PieceId))
                    {
                        var pp = new PiecePrior(p, i);
                        i++;
                        presents.Add(pp);
                        dict[p.PieceId] = pp;

                        //var piece = p.Track as CPiece;
                        //foreach (CFile file in piece.Files)
                        //{
                        //    var lp = locations[file.File];
                        //    if (lp == null)
                        //    {
                        //        lp = new List<PiecePrior>();
                        //        lp.Add(pp);
                        //        locations.Add(file.File, lp);
                        //    }
                        //    else
                        //    {
                        //        lp.Add(pp);
                        //        PiecePrior.mergePrior0(lp);
                        //    }
                        //}

                    }
                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }

        }

        private void waitCalculForEnd()
        {
            lock (_lock)
            {

                if (query == compressState.none)
                    return;
                if (query == compressState.enCours)
                    query = compressState.cancel;
            }
            var dt = DateTime.Now;
            int nb = 0;
            while (true)
            {
                lock (_lock)
                    if (endCalcul)
                        return;
                Thread.Sleep(100);
                if ((DateTime.Now - dt).TotalSeconds > 10)
                    return;
                nb++;
                if (nb >= 10)
                {
                    nb = 0;
                    logger.log("waitForEnd Calcul");
                }
            }

        }


        private void waitCopyForEnd()
        {
            lock (_lock)
            {
                if (copy == compressState.none)
                    return;
                if (copy == compressState.enCours)
                    copy = compressState.cancel;
                if (endCopy)
                    return;
            }
            var dt = DateTime.Now;
            int nb = 0;
            while (true)
            {
                lock (_lock)
                {
                    if (endCopy)
                        return;
                    if (query != compressState.enCours)
                    {
                        logger.log("abandon attente car query={0}", query);
                        return;
                    }
                }
                Thread.Sleep(100);
                if ((DateTime.Now - dt).TotalSeconds > 10)
                    return;
                nb++;
                if (nb >= 10)
                {
                    nb = 0;
                    logger.log("waitForEnd Copy");
                }
            }

        }


        [STAThread]
        private void copyLoop()
        {
            while (true)
            {
                try
                {
                    compressState _cp;
                    lock (_lock)
                        _cp = copy;
                    if (_cp != compressState.enCours)
                    {
                        Thread.Sleep(1000);
                        continue;
                    }

                    _copy();
                }

                catch (Exception ex)
                {
                    logger.log(ex.ToString());
                }
            }
        }


        [STAThread]
        private void calculLoop()
        {


            while (true)
            {
                try
                {
                    switch (Query)
                    {
                        case compressState.none: Thread.Sleep(1000); continue;

                        case compressState.enCours:
                            if (endCopyFinal)
                            {
                                Thread.Sleep(1000); continue;
                            }
                            break;
                        case compressState.reload:
                            waitCalculForEnd();
                            break;

                        case compressState.cancel:
                            {
                                waitCalculForEnd();
                                waitCopyForEnd();
                                Query = compressState.none;
                                nbLoop = 0;
                                Thread.Sleep(1000); continue;
                            }

                        default:
                            break;
                    }
                    lock (_lock)
                    {
                        endCalcul = false;
                        query = compressState.enCours;
                        nbLoop++;
                    }



                    buildListIni();

                    foreach (PlayListViewModel pl in playlists)
                    {
                        buildList(pl);
                    }

                    //foreach (List<PiecePrior> lp in locations.Values)
                    //{
                    //    PiecePrior.mergePrior1(lp);
                    //}

                    // concaténation
                    int max = 0;
                    list = new List<PiecePrior>();
                    foreach (var _l in listes)
                    {
                        if (query != compressState.enCours)
                            return;
                        var count_ = _l.Count;
                        if (count_ > max)
                            max = count_;
                    }
                    int count = listes.Count;


                    for (int i = 0; i < max; i++)
                    {
                        if (query != compressState.enCours)
                            return;
                        for (int j = 0; j < count; j++)
                        {
                            var l = listes[j];
                            if (i < l.Count)
                            {
                                var p = l[i];
                                list.Add(p);
                            }
                        }
                    }



                    waitCopyForEnd();
                    lock (_lock)
                    {
                        if (query != compressState.enCours)
                            continue;
                        App.log.log("Export lancé " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments", CAPTION);
                        endCopy = false; copy = compressState.enCours; endCopyFinal = false; 
                    }

                    while (true)
                    {
                        Thread.Sleep(100);

                        if (endCopy || query != compressState.enCours)
                            break;

                    }


                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                    Thread.Sleep(1000);
                }

                finally
                {
                    lock (_lock)
                        endCalcul = true;
                   

                }

            }
        }

        protected virtual bool noMoreSpace()
        {
            return true;
        }
        protected virtual void prepareExport()
        {
        }

        protected void setExport(exportState state, PiecePrior p)
        {
            setExport(state, p.PieceGen);
        }

        protected void setExport(exportState state, ITrackNativeDates p)
        {
            p.ExportStatus = state;
            PlayListViewModel.setExport(p.PieceId, state);


            var h = TrackListViewModel.HumanSelected;
            if (h != null)
            {
                if (p.Album == h.Album)
                {
                    TrackListViewModel trackAlbum = PlayListViewModel.findTrack(App.bib.Musique, p.PieceId);
                    if (trackAlbum != null)
                    {
                        trackAlbum.ExportStatus = state;
                    }

                }
            }

            //var track = PlayListViewModel.findTrack(lastpl, p.PieceId);
            //if (track != null)
            //{
            //    track.ExportStatus = state;
            //}
            //var h = TrackListViewModel.HumanSelected;
            //if (h != null)
            //{
            //    if (p.Album == h.Album)
            //    {
            //        var album = App.getAlbum(h);
            //        var f = album.Find(t => t.PieceId == p.PieceId);
            //        if (f != null)
            //            track.ExportStatus = state;
            //    }
            //  }
        }
        [STAThread]
        private void _copy()
        {
            PlayListViewModel.resetExport(exportState.none);
            try
            {
                List<PiecePrior> _list = null;
                lock (_lock)
                {
                    _list = new List<PiecePrior>(list);
                }
                foreach (PiecePrior piece in _list)
                {
                    try
                    {
                        if (copy != compressState.enCours)
                            return;
                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        var files = piece.Files;
                        foreach (CFile file in files)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {
                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }
                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            setExport(exportState.present, piece);
                            // PlayListViewModel.setExport(piece.Piece.PieceId, exportState.present);
                            //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //if (track != null)
                            //{
                            //    track.ExportStatus = exportState.present;
                            //}
                        }
                        else
                            setExport(exportState.miss, piece);
                    }
                    catch (Exception e)
                    {
                        App.log.log(e.ToString());
                    }
                }

                nbFicherSup = 0; nbFichierAdd = 0;
                idCopie = new HashSet<int>();
                idCopieLoc = new HashSet<string>();
                presents.Sort(new PriorComparer());
                prepareExport();

                string orgDir = CFile.DefaultFolder;
                foreach (PiecePrior piece in list)
                {
                    try
                    {
                        if (copy != compressState.enCours)
                            return;

                        int id = piece.PieceId;
                        if (idCopie.Contains(id))
                            continue;
                        var files = piece.Files;
                        bool contFile = false;
                        foreach (CFile file in files)
                        {
                            if (idCopieLoc.Contains(file.File))
                            {
                                contFile = true;
                                break;
                            }
                        }
                        if (contFile)
                            continue;

                        idCopie.Add(id); // idCopie[id] = piece;
                        foreach (CFile file in files)
                        {
                            idCopieLoc.Add(file.File); // [file.File] = piece;
                        }




                        //1. Vérification que le fichier n'existe pas déjà 
                        bool exists = false;
                        foreach (CFile file in files)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                                string path = conf.dir + file.File;
                                var fv = FileRegister.Check(path);
                                if (fv.Exists)
                                {

                                    if (fv.Length == file.Size)
                                    {
                                        exists = true;
                                        break;
                                    }
                                    else
                                    {
                                        fv.delete();
                                    }

                                }
                            }

                            catch
                            {
                            }
                        }



                        if (exists)
                        {
                            //    var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                            //    if (track != null)
                            //    {
                            //        track.ExportStatus = exportState.present; 
                            //    }
                            continue;
                        }

                        //2. Copie du meilleur fichier
                        CFile pertinent = files.getPertinentFile();
                        if (pertinent == null)
                            continue;


                        while (true)
                        {
                            if (copy != compressState.enCours)
                                return;
                            try
                            {
                              var f = FileRegister.Check( pertinent.Path); //  FileInfo f = new  FileInfo FileInfo(pertinent.Path);
                                var freeSpace = getFreeSpace() - conf.marge;
                                long nextfreeAvailable = freeSpace - f.Length;
                                if (nextfreeAvailable < 0)
                                {
                                    if (noMoreSpace())
                                        return;
                                    continue;
                                }
                                App.log.log("copie\t" + piece + "->" + conf.dir + pertinent.File + " ( " + piece + " )");                                
                                f.copyTree(conf.dir + pertinent.File, true);
                                //  freeSpace = nextfreeAvailable; 
                                //  PlayListViewModel.setExport(piece.Piece.PieceId, exportState.copy);
                                setExport(exportState.copy, piece);
                                //var track = PlayListViewModel.findTrack(lastpl, piece.Piece.PieceId);
                                //if (track != null)
                                //{
                                //    track.ExportStatus = exportState.copy;
                                //}
                                nbFichierAdd++;

                                break;
                            }
                            catch (System.IO.IOException io)
                            {
                                App.log.log(io.Message);
                                //  refreshInfoFreeSpace(); 
                                if (noMoreSpace())
                                    return;
                            }
                        }

                    }

                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }


                }
            }
            catch (Exception ex)
            {
                App.log.log(ex.ToString());

            }
            finally
            {
                compressState _copy;
                lock (_lock)
                    _copy = copy;

                if (Query != compressState.none && _copy != compressState.none)
                {
                    var _status = string.Format("statusCalc={0} statusCopy={1} calc={2} copy={3}", endCalcul, endCopy, query, copy); 
                    var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6} {7}",
                        listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""), _status);
                    App.log.log(log, CAPTION);
                    if (conf.oneShot)
                        ihm.InfoIHm(log, CAPTION);
                    //  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                    //list = new List<PiecePrior>();
                    //listes = new List<List<PiecePrior>>(); 

                    if (_copy == compressState.enCours)
                    {
                        endCopyFinal = true; 
                       // PlayListViewModel.resetExport(exportState.none);
                    }

                    OnPropertyChanged("Header");
                }

                lock (_lock)
                {
                    endCopy = true;
                    copy = compressState.none;
                }
                //var log = string.Format("Fin de l'export {0} liste{1} éléments\r\n{2} fichier{3} copié{3}\r\n{4} fichier{5} supprimé{6}",
                //    listes.Count, (list.Count > 1 ? "s " : " "), nbFichierAdd, (nbFichierAdd > 1 ? "s" : ""), nbFicherSup, (nbFicherSup > 1 ? "s" : ""), (nbFicherSup > 1 ? "s" : ""));
                //App.log.log(log, CAPTION);
                //if (conf.oneShot)
                //    ihm.InfoIHm(log, CAPTION);
                ////  ihm.InfoIHm("Fin de l'export " + listes.Count + " liste" + (list.Count > 1 ? "s " : " ") + list.Count + " éléments\r\n" + idCopie.Count + " fichiers copiés\r\n" + nbFicherSup + "fichier" + (nbFicherSup > 1 ? "s" : "") + " supprimé" + (nbFicherSup > 1 ? "s" : ""), CAPTION);
                //list = null;
                //listes = null;

                //if (state == compressState.enCours)
                //{
                //}
                //else
                //    PlayListViewModel.resetExport(exportState.none);

                //lock (_lock)
                //    state = compressState.end;
                //OnPropertyChanged("Header");

            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\FileUtil.cs">
    <content><![CDATA[using System;
using System.IO;

using Microsoft.Win32;

namespace pdb.util
{
    /// <summary>
    /// Utilitaires de manipulation de fichiers
    /// </summary>
    public static class FileUtil
    {
        public const int KILO = 1024;
        public const int MEGA = KILO * KILO;
        public const int GIGA = MEGA * KILO;

        /// <summary>
        /// Enregistrement d'un fichier sans limite max
        /// </summary>
        /// <param name="input"></param>
        /// <param name="path"></param>
        public static void RecordFile(Stream input, String path)
        {
            RecordFile(input, path, long.MaxValue);
        }

        /// <summary>
        /// Enregistrement d'un fichier avec une limite de taille
        /// </summary>
        /// <param name="input">Flux d'entrée</param>
        /// <param name="path">Chemin destination</param>
        /// <param name="sizeMax">taille maximum gérée (en octets)</param>
        /// <remarks>Lance toutes les IO.Exceptions</remarks>
        public static void RecordFile(Stream input, String path, long sizeMax)
        {
            if (input.Length > sizeMax)
            {
                throw new ApplicationException("Exception manipulation du fichier : taile flux > SizeMax ");
            }

            using (input)
            {
                using (Stream sFile = new FileStream(path, FileMode.Create))
                {
                    const int BUF_LENGHT = 4096;

                    byte[] buf = new byte[BUF_LENGHT];
                    int nb = input.Read(buf, 0, BUF_LENGHT);
                    while (nb > 0)
                    {
                        sFile.Write(buf, 0, nb);
                        nb = input.Read(buf, 0, BUF_LENGHT);
                    }

                }
            }

        }

        public static byte[] ReadFile(String path)
        {
            byte[] tab;
            using (Stream fs = new FileStream(path, FileMode.Open))
            {
                tab = new byte[fs.Length];
                fs.Read(tab, 0, tab.GetLength(0));
            }
            return tab;
        }

        public static MemoryStream getStream(String path)
        {
            using (Stream fs = new FileStream(path, FileMode.Open))
            {
                MemoryStream memStr = new MemoryStream();
                const int BUF = 4096;
                byte[] buffer = new byte[BUF];
                int nb = 0;
                while ((nb = fs.Read(buffer, 0, BUF)) > 0)
                {
                    memStr.Write(buffer, 0, nb);
                }
                memStr.Flush();
                memStr.Position = 0;
                return memStr;
            }
        }

        /// <summary>
        /// Fournit la taille d'un fichier user friendly
        /// </summary>
        /// <param name="size"></param>
        /// <returns></returns>
        public static String HumanReadableSize(this long size, int level)
        {
            //level <=0 ==>3.6 Mo
            // level ==0 ==> 3 Mo
            // level == 1 ==> 3 Mo 614 Ko

            if (size > GIGA)
            {
                return getHumanParty(size, GIGA, "Go", level);
            }

            if (size > MEGA)
            {
                return getHumanParty(size, MEGA, "Mo", level);
            }
            if (size > KILO)
            {
                return getHumanParty(size, KILO, "Ko", level);
            }

            return getHumanParty(size, 1, "o", level); 
        }

        private static String getHumanParty(long size, int kilo, String unite, int  level)
        {
            double ratio = (double)size / kilo; 
            int partie = (int)Math.Floor(ratio);
            long reste = size - partie * kilo;

           if (reste == 0 || level ==0 || kilo == 1)
               return string.Format("{0} {1}", partie, unite);

           if (level < 0)
           {
               return string.Format("{0:0.###} {1}", ratio, unite); 
           }

           return string.Format("{0} {1} {2}", partie ,unite, HumanReadableSize(reste, level-1));


            //if (level>0)
            //    return String.Format("{0} {1}{2}", partie, unite, reste == 0 ? "" : " " + HumanReadableSize(reste, complete));
            //else
            //{
            //    if (reste == 0)
            //        return (string.Format("{0} {1}", partie, unite)); 
            //    else 
            //    {

            //    }

            //}

            //    return string.Format("{0} {1}{2}", partie, reste == 0 ? "" : "." + HumanReadableSize(reste, complete));
        }

        public static String getMimeType(this String file)
        {
            var contentType = "application/octet-stream";
            String ext = Path.GetExtension(file);
            try
            {

                var fileClass = Registry.ClassesRoot.OpenSubKey(ext);
                contentType = fileClass.GetValue("Content Type").ToString();
            }
            catch
            {
                switch (ext)
                {
                    case ".doc":
                        return "application/msword";
                    case ".docx":
                        return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                    case ".ppt":
                        return "application/vnd.ms-powerpoint";
                    case ".pptx":
                        return "application/vnd.openxmlformats-officedocument.presentationml.presentation";
                    case ".xls":
                        return "application/vnd.ms-excel";
                    case ".xlsx":
                        return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
                    case ".pdf":
                        return "application/pdf";
                    case ".xml":
                        return "text/xml";
                    case ".csv":
                        return "application/vnd.ms-excel";
                    case ".zip":
                        return "application/zip";
                    case ".txt":
                        return "text/plain";
                    default:
                        break;
                }
            }
            return contentType;
        }

        //public static FileInfo findFile(String directory, String seq_id)
        //{
        //    DirectoryInfo dir = new DirectoryInfo(directory);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        if (file.Name.StartsWith(seq_id))
        //            return file;
        //    }
        //    return null;
        //}
    }
}
]]></content>
  </file>
  <file path="\pdb.util\misc.cs">
    <content><![CDATA[using System;
using System.IO;
using System.Threading;

namespace pdb.util
{
    /// <summary>
    /// utilitaires divers
    /// </summary>
    /// <remarks></remarks>
    public static class misc
    {
        const int K = 1024;
        public static void gcCollect(string org)
        {

            DateTime now = DateTime.Now;
            long mem0 = GC.GetTotalMemory(false);
            GC.Collect();
            long mem1 = GC.GetTotalMemory(false);

            var _mem0 = mem0.HumanReadableSize(-1);
            var _mem1 = mem1.HumanReadableSize(-1);
            var delta = (mem0 - mem1).HumanReadableSize(-1);

            misc.log("GC.Collect " + org + " " + _mem0 + " " + _mem1 + " (" + delta + ") " + (DateTime.Now - now).TotalMilliseconds.ToString("0"));
        }
        private static ILogger logger = new DefaultLogger();
        private static getDefaultLogger _getDefaultLogger;
        //public static void init(ILogger a_logger)
        //{
        //    logger = a_logger;
        //    //if (logger is Logger)
        //    //    Logger.init();
        //}

        public static void init(getDefaultLogger getDefaultLogger)
        {
            _getDefaultLogger = getDefaultLogger;
        }

        public static void init(ILogger logger)
        {
            misc.logger = logger;
        }

        public static string Pre { set { Logger.Pre = value; } }

        private static ILogger Logger
        {
            get
            {
                if (logger is DefaultLogger && _getDefaultLogger != null)
                    logger = _getDefaultLogger();
                return logger;
            }
        }


        public static void logNoDate(String txt)
        {
            Logger.logNoDate(txt);
        }

        public static void log(string txt, params object[] other)
        {
            Logger.log(txt, other);
        }

        public static void log(string txt)
        {
            Logger.log(txt);
        }

        public static void logError(string txt, Exception ex)
        {
            log("[Error] " + txt + " " + ex.ToString());
        }

        public static void logWarn(string txt)
        {
            log("[Warn] " + txt);
        }

        public static string moveTree(this FileInfo org, String dest, bool? overWrite)
        {
            return tree(org, dest, true, overWrite);
        }

        public static string copyTree(this FileInfo org, String dest, bool? overWrite)
        {
            return tree(org, dest, false, overWrite);
        }

        public static string copyTree(this FileValue org, String dest, bool? overWrite)
        {
            var fi = new FileInfo(org.FullName); 
            return tree(fi, dest, false, overWrite);
        }

        public static string getShortPath(this string path, params string[] keywords)
        {

            string[] dirs = path.Split(Path.DirectorySeparatorChar);
            int found = 0;
            int count = dirs.GetLength(0);
            foreach (string key in keywords)
            {
                for (int i = count - 2; i > 0; i--)
                {
                    var s = dirs[i].ToLower();
                    if (string.IsNullOrEmpty(s))
                        continue;

                    if (key.Equals(s))
                    {
                        found = i;
                        break;
                    }
                }
                if (found > 0)
                    break;
            }


            var sb = new StringBuilder();
            var begin = false;
            for (int i = found + 1; i < count; i++)
            {
                var s = dirs[i];
                if (string.IsNullOrEmpty(s))
                    continue;
                if (begin)
                {
                    sb.Append(Path.DirectorySeparatorChar);
                }
                begin = true;
                sb.Append(s);
            }
            return sb.ToString();
        }


        private static string tree(FileInfo org, String dest, bool deleteOrg, bool? overwrite)
        {
            string newDest = dest;
            String[] dirs = dest.Split(Path.DirectorySeparatorChar);

            int i = 0;
            DirectoryInfo root = new DirectoryInfo(dirs[0] + Path.DirectorySeparatorChar);
            for (i = 1; i < dirs.GetLength(0) - 1; i++)
            {
                String strDir0 = dirs[i] + Path.DirectorySeparatorChar;
                String StrDir = root.FullName + strDir0;
                DirectoryInfo dir = new DirectoryInfo(StrDir);
                if (!dir.Exists)
                {
                    dir.Create();
                    try
                    {
                        dir.Attributes &= ~FileAttributes.ReadOnly;
                    }
                    catch (Exception ea)
                    {
                        //   log("impossible de poser les attributs de répertoire " +ea.ToString()); 
                    }

                }
                root = dir;
            }
            //object o;

            FileInfo orgg = new FileInfo(org.FullName);
            var f = FileRegister.Check(dest);
            if (overwrite == null)
            {

                if (f.Exists)
                    return newDest;
                var d = org.CopyTo(dest, false);
                f.copy(d.Length);

            }
            else if (overwrite.Value)
            {
                var d = org.CopyTo(dest, true);
                f.copy(d.Length);
            }
            else
            {
                if (f.Exists)
                {
                    var d = org.CopyTo(dest, false);
                    f.copy(d.Length);
                }
                else
                {
                    int index = 1;
                    string fdest = Path.GetDirectoryName(dest) + Path.DirectorySeparatorChar + Path.GetFileNameWithoutExtension(dest);
                    string ext = Path.GetExtension(dest);


                    newDest = fdest + "_" + index + ext;
                    var newf = FileRegister.Check(newDest);
                    while (newf.Exists)
                    {
                        index++;
                        newDest = fdest + index + ext;
                        newf = FileRegister.Check(newDest);
                    }
                    var d = org.CopyTo(newDest, false);
                    newf.copy(d.Length);

                }
            }
            try
            {
                File.SetAttributes(newDest, File.GetAttributes(newDest) & ~FileAttributes.ReadOnly);
            }

            catch (Exception ea2)
            {
                // log("impossible de poser les attributs de fichier " + ea2.ToString());
            }



            if (deleteOrg)
            {
                org.Delete();
                FileRegister.Check(org.FullName).delete();
            }
            DirectoryInfo current = orgg.Directory;

            while (current.GetFileSystemInfos().GetLength(0) == 0)
            {
                DirectoryInfo parent = current.Parent;
                current.Delete();
                current = parent;
            }

            return newDest;
        }

        //public static void deleteFile(string path)
        //{
        //}

        public static void deleteFile(string path, string desc)
        {
            var file = FileRegister.Check(path);
            if (!file.Exists)
            {
                log("fichier {0} non présent", desc);
                return;
            }
            var fi = new FileInfo(path);
            log("suppr\t{0}", desc);
            fi.Delete();
            file.delete();

            DirectoryInfo current = fi.Directory;

            while (current.GetFileSystemInfos().GetLength(0) == 0)
            {
                DirectoryInfo parent = current.Parent;
                log("suppression répertoire {0}", current.FullName);
                current.Delete();
                current = parent;
            }


        }


        public static void DeleteDir(DirectoryInfo dir)
        {
            Console.WriteLine("DeleteDir " + dir.FullName);
            try
            {
                if (!dir.Exists)
                    return;
                foreach (FileInfo file in dir.GetFiles())
                {
                    try
                    {
                        file.Delete();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("impossible de supprimer " + file.FullName + " " + ex);
                    }
                }
                foreach (DirectoryInfo sub in dir.GetDirectories())
                    DeleteDir(sub);
                try
                {
                    dir.Delete();
                }
                catch (Exception edelDir)
                {
                    Console.WriteLine("impossible de supprimer en final " + dir.FullName + " " + edelDir.Message);
                }
            }
            catch (Exception exd)
            {
                Console.WriteLine("impossible de supprimer " + dir.FullName + " " + exd);
            }
        }




    }
}]]></content>
  </file>
  <file path="\PieceDb.Db\CDb.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Xml;
using pdb.db.obj;
using pdb.db.piece.data;
using pdb.obj;
using pdb.util;
using Math = System.Math; 

namespace pdb.db
{
    public enum mergePriority
    {
        left = -1,
        right = 1,
        none = 0
    }
    /// <summary>
    /// g�re la persistence
    /// </summary>  
    /// <remarks></remarks>
    public class CDb
    {
        public const int CURRENT_VERSION = 3;
        public static int Version;

        const string SEQ_PIECE = "seq_piece";
        const string SEQ_LIST = "seq_list";
        private static int pieceSequenceId = 0;
        private static int listSequenceId = 0;
        private static int getPieceNextId { get { pieceSequenceId++; return pieceSequenceId; } }
        private static int getListNextId { get { listSequenceId++; return listSequenceId; } }
        private FileInfo LOCAL_FILE;
        private FileInfo REMOTE_FILE;
        private FileInfo LastFullFile;
        private FileInfo DiffFile;
        private FileInfo SOV;
        private CListPiece m_list;
        private CListPiece lastFull; private CListPiece remoteOrg;
        private CListPiece trace;
        private DateTime now;
        private string sovRep;
        private DateTime lastSov;
        private int nbOpe;

        private bool loadRemote;
        private bool loadTrace;
        private bool loadLastFull;
        private bool loadDiff;



        private FileInfo remoteTrace;
        private DataConf conf;

        private dbMode mode;
        public dbMode Mode { get { return mode; } }
        public CDb(DataConf conf)
        {
            this.conf = conf;
            LOCAL_FILE = conf.dbLocal;
            REMOTE_FILE = conf.dbRemote;
            remoteTrace = conf.dbTrace;
            LastFullFile = conf.dbLastFull;
            DiffFile = conf.dbDiff;
            SOV = conf.dbSov;
            this.mode = conf.mode;

            init();
        }

        public string DefaultFolder { get { return conf.defaultFolder; } }

        private void init()
        {
            this.now = DateTime.Now;
            lastSov = now;
            sovRep = now.ToString("yy-MM-dd_HH-mm-ss");



            System.DateTime l_localDate = System.DateTime.MinValue;
            System.DateTime l_remoteDate = System.DateTime.MinValue;

            if (LOCAL_FILE.Exists)
                l_localDate = LOCAL_FILE.LastWriteTime;
            if (REMOTE_FILE.Exists)
                l_remoteDate = REMOTE_FILE.LastWriteTime;


            TimeSpan l_dif = l_localDate.Subtract(l_remoteDate);
            double l_sec = l_dif.TotalSeconds;
            if (REMOTE_FILE.Exists)
            {

                if (Math.Abs(l_sec) > 3 || (LOCAL_FILE.Exists && REMOTE_FILE.Length != LOCAL_FILE.Length))
                {
                    loadRemote = true;
                }
                else
                {
                    log("not load remote, same file");
                }
            }
            else
            {
                log("remote file does not exist");
            }

            if (remoteTrace != null && remoteTrace.Exists)
                loadTrace = true;




        }

        public void loadData()
        {
            // cas diff-> je mémorise lastFull, je r�cup�re l'instantan�
            // cas full -> je ne m�morise pas lastFull, je r�cup�re le diff et fait le merge

            // gestion des diff
            //if (mode == dbMode.diff)
            //{
            // je sauvegarde lastFull
            misc.log("mode:{0}  LastFullFile.Exists: {1} DiffFile.Exists: {2}", mode, LastFullFile.Exists, DiffFile.Exists);
            if (mode == dbMode.diff)
            {
                if (LastFullFile.Exists)
                {
                    log("load lastFull");
                    lastFull = loadData(LastFullFile);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                }

                log("load local");
                m_list = loadData(LOCAL_FILE);
            }

            else
            {

                log("load local");
                m_list = loadData(LOCAL_FILE);
                if (DiffFile.Exists)
                {


                    log("load diff");
                    var diff = loadData(DiffFile);


                    log("consolid diff and local");
                    foreach (CPiece pdiff in diff)
                    {
                        m_list.Consolid(pdiff, mergePriority.right);
                    }

                    var sov = DiffFile.FullName.Replace(".xml", ".sov.xml");
                    DiffFile.CopyTo(sov, true);
                    DiffFile.Delete();


                    write();

                    log("load local consolidé for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);
                    addToZip(true, LOCAL_FILE.FullName);
                }
                else
                {
                    log("load local for lastFull");
                    lastFull = loadData(LOCAL_FILE);
                    File.Copy(LOCAL_FILE.FullName, LastFullFile.FullName, true);

                    if (loadRemote)
                    {
                        log("load remote");
                        remoteOrg = loadData(REMOTE_FILE);
                        log("consolid remote and local");
                        m_list.Consolid(remoteOrg);
                    }
                }
            }


            if (loadTrace)
            {
                log("load trace");
                trace = loadData(remoteTrace);
            }
        }

        public void eraseClassementForEnabled()
        {

            foreach (CPiece piece in m_list)
            {
                if (piece.Enabled)
                {
                    piece.eraseClassement();
                }
            }
        }

        public List<ITrackIdentity> Files
        {
            get
            {
                return new List<ITrackIdentity>(m_list.getList());
            }
        }

        // r�cup�ration des infos externes
        public void LegacyConsolid(CListPiece list, DateTime date)
        {
            misc.log("Cdb::LegacyConsolid");

            DateTime now = DateTime.Now;
            ChronoData.refreshDate(date);

            foreach (CPiece ext in list)
            {
                m_list.legacyConsolid(ext);
            }

            m_list.bilanNatives();

           // setAlbumArtistFromFile();

        }

        public void LegacyConsolid(CPiece ext)
        {
            m_list.legacyConsolid(ext);
        }

        public void SynchroNative(DateTime date)
        {
            misc.log("Cdb::SynchroNative");
            ChronoData.refreshDate(date);
            foreach (CPiece piece in m_list)
            {
                piece.SynchroNative();
            }

        }

        //private void setAlbumArtistFromFile()
        //{
        //    foreach (ITrackMetaData piece in m_list)
        //    {
        //        setAlbumArtistFromFile(piece);
        //    }
        //}



        private void setAlbumArtistFromFile(ITrackMetaData piece)
        {

            try
            {
                string location = piece.Location;
                if (location.isNullorEmpty())
                    return;
                FileInfo file = new FileInfo(location);
                DirectoryInfo dAlbum = file.Directory;
                string dirAlbum = dAlbum.Name;
                string dirArtist = dAlbum.Parent.Name;
                string artist = piece.Artist;
                string album = piece.Album;

                string newArtist = artist;
                string newAlbum = album;




                if (artist.isNullorEmpty())
                {
                    if (!TrackIdentity.UNKNOW_ARTIST.Equals(dirArtist))
                        newArtist = dirArtist;
                    //if (!UNKNOW_ARTIST.Equals(newArtist))
                    //    piece.Artist = newArtist;
                }

                if (album.isNullorEmpty())
                {
                    if (!dirAlbum.Contains(TrackIdentity.UNKNOW_ALBUM))
                    {
                        newAlbum = dirAlbum;
                        if (newArtist.NotNullOrEmpty())
                        {
                            if (!TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                                newAlbum = newAlbum.Replace(newArtist, "");
                        }
                    }
                }

                //if (TrackIdentity.UNKNOW_ARTIST.Equals(newArtist))
                //    piece.Artist = "";
                //else 
                if (newArtist != artist)
                    piece.Artist = newArtist;

                //if (TrackIdentity.UNKNOW_ALBUM.Equals(newAlbum))
                //    piece.Album = "";
                //else
                if (newAlbum != album)
                    piece.Album = newAlbum;

            }
            catch (Exception e)
            {
                misc.log(e.ToString());
            }
        }



        #region "sauvegarde"



        public void Sov(string fileIt)
        {
            var list = new List<string> { fileIt, LOCAL_FILE.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            ZipUtil.compress(SOV.FullName, sovRep, list);
        }

        public void SovIni()
        {
            var list = new List<string> { LOCAL_FILE.FullName, LastFullFile.FullName, DiffFile.FullName };
            if (loadRemote)
                list.Add(REMOTE_FILE.FullName);
            if (loadTrace)
                list.Add(remoteTrace.FullName);

            list.AddRange(conf.othersIni); 

            ZipUtil.compress(SOV.FullName, sovRep, list);
        }

       
        #endregion

        public void removeVersions()
        {
            misc.log("Suppression des versions !!!");
            foreach (CPiece piece in m_list)
            {
                piece.removeVersions();
            }
        }

        public void Menage()
        {
            foreach (CPiece piece in m_list)
            {
                piece.Menage();
            }
        }

        public void WriteDB1()
        {

            misc.log("CDb:WriteDB1");

            lock (lockSave)
            {
                write();
                File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);
                misc.log("CDb:fin WriteDB1");
            }

        }
        public void saveAsync()
        {
            lock (this)
            {
                _goSave = true;
                if (thSave == null)
                {
                    thSave = new Thread(loopSave);
                    thSave.Start();
                }
            }
        }
        private Thread thSave;
        private bool _goSave;
        private volatile object lockSave = new object();

        private void write()
        {
            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;
            using (XmlWriter writer = XmlWriter.Create(REMOTE_FILE.FullName + ".tmp", settings))
            {
                writer.WriteStartElement("db");
                writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                writer.WriteAttributeString(SEQ_LIST, listSequenceId.ToString());
                m_list.write(writer);
                writer.WriteEndDocument();
                writer.Flush();
            }

            File.Copy(REMOTE_FILE.FullName + ".tmp", REMOTE_FILE.FullName, true);



            if (lastFull != null)
            {
                try
                {
                    var diff = DiffFile.FullName;
                    if (mode == dbMode.full)
                        diff = diff.Replace(".xml", ".d.xml");

                    using (XmlWriter writer = XmlWriter.Create(diff + ".tmp", settings))
                    {
                        writer.WriteStartElement("db");
                        writer.WriteAttributeString("version", CURRENT_VERSION.ToString());
                        writer.WriteAttributeString(SEQ_PIECE, pieceSequenceId.ToString());
                        m_list.writeDiff(writer, lastFull);
                        writer.WriteEndDocument();
                        writer.Flush();
                    }

                    File.Copy(diff + ".tmp", DiffFile.FullName, true);
                }
                catch (Exception ex)
                {
                    misc.log(ex.ToString());
                }
            }

            WriteDB2();
        }
        private void loopSave()
        {
            while (true)
            {
                Thread.Sleep(1000);
                if (!_goSave)
                    continue;
                lock (this)
                    _goSave = false;

                lock (lockSave)
                {

                    try
                    {
                        write();
                    }
                    catch (Exception ex)
                    {
                        misc.log(ex.ToString());
                        lock (this)
                            _goSave = true;
                    }
                }

            }
        }

        public void WriteDB2()
        {

            misc.log("CDb:WriteDB2");
            lock (lockSave)
                REMOTE_FILE.CopyTo(LOCAL_FILE.FullName, true);
            misc.log("CDb:WriteDB2");

            nbOpe++;
            var now = DateTime.Now;
            var ts = now - lastSov;
            if (nbOpe >= conf.sovNb || ts > conf.sovMin)
            {
                nbOpe = 0;
                lastSov = now;
                DiffFile.Refresh();
                if (DiffFile.Exists)
                {
                    var list = new List<string> { DiffFile.FullName };
                    list.AddRange(conf.othersDiff); 
                    addToZip(true, list.ToArray());
                    //var cp = DiffFile.DirectoryName + Path.DirectorySeparatorChar + now.ToString("yy-MM-dd_HH-mm-ss") + DiffFile.Name;
                    //DiffFile.CopyTo(cp);
                    //var list = new List<string> { cp };
                    //ZipUtil.compress(SOV.FullName, sovRep, list);
                    //File.Delete(cp); 
                }


            }
        }

        private void addToZip(bool withHorodate, params string[] list)
        {
            ZipUtil.compress(SOV.FullName, sovRep, list, withHorodate);
        }


        public CListPiece List
        {
            get
            {
                return m_list;

            }

        }

        public CListPiece Remote
        {
            get
            {
                if (loadRemote)
                    return remoteOrg;
                return null;
            }

        }

        public CListPiece Trace
        {
            get { return trace; }
        }

        private XmlElement loadList(FileInfo file, List<CPiece> list)
        {
            XmlElement root = null;
            if (file.Exists)
            {
                XmlDocument l_doc = new XmlDocument();


                l_doc.Load(file.FullName);

                root = l_doc.DocumentElement;
                var xmlTool = new XMLTool(root);
                var version = xmlTool.getIntAttValue("version");
                if (version > 0)
                    Version = version;


                var seqPiece = xmlTool.getIntAttValue(SEQ_PIECE);
                if (seqPiece > pieceSequenceId)
                {
                    pieceSequenceId = seqPiece;
                }

                var seqList = xmlTool.getIntAttValue(SEQ_LIST);
                if (seqList > listSequenceId)
                {
                    listSequenceId = seqList;
                }

                var pieceRoot = root;
                if (version > 0)
                    pieceRoot = root.ChildNodes[0] as XmlElement;



                foreach (XmlElement l_xml in pieceRoot.ChildNodes)
                {
                    CPiece l_piece = new CPiece(l_xml);

                    list.Add(l_piece); //TODO provisoire
                    if (version > 0)
                        checkId(l_piece);
                    else
                    {
                        if (m_list != null)
                        {
                            m_list.checkId(l_piece); 
                        }
                        checkId(l_piece);
                    }
                    //}
                }
                misc.log("aux list: " + list.Count);




            }
            else
            {

            }

            return root;
        }



        private  CListPiece loadData(FileInfo file)
        {
            if (file.Exists)
            {

                List<CPiece> l_list = new List<CPiece>();
                var root = loadList(file, l_list);


                misc.log("aux list: " + l_list.Count);
                System.DateTime l_date = file.LastWriteTime; // File.GetLastWriteTime(a_path);

                //chasse aux doublons
                CListPiece l_ret = new CListPiece(l_list, l_date);
                misc.log(" list: " + l_ret.Count);

                var xLists = XMLTool.NodeLookUp(root, CListPiece.TOKEN_LISTS);

                l_ret.loadListes(xLists);
                return l_ret;
            }
            else
            {
                return new CListPiece();
            }

        }

        public static void checkId(CPiece l_piece)
        {
            if (l_piece.PieceId < 0)
                l_piece.setId(getPieceNextId);
            if (l_piece.PieceId > pieceSequenceId)
                pieceSequenceId = l_piece.PieceId;
        }

        public static void checkId(CPlayList pl)
        {
            if (pl.ID < 0)
                pl.ID = getListNextId;
            if (pl.ID > listSequenceId)
                listSequenceId = pl.ID;
        }
        private void log(String txt)
        {
            misc.log(txt);
        }

        public CPiece getPiece(string location)
        {
            return m_list.getPiece(location);
        }

        public CPiece getPiece(int id)
        {
            return m_list.getPiece(id);
        }
    }


}


]]></content>
  </file>
</db>
