<db path="C:\Bernard\db1\PieceDb3Ref">
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml">
    <content><![CDATA[<Window x:Class="pdb.player.Vue.ConfAlbumSortW"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="ConfAlbumSortW" Height="191" Width="1122" Loaded="Window_Loaded">
    <Grid Height="116" Width="861">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="182*" />
            <ColumnDefinition Width="201*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="7*" />
        </Grid.RowDefinitions>
        <Grid Grid.ColumnSpan="2" Margin="0,0,-172,0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="236*" />
            </Grid.ColumnDefinitions>
            <CheckBox Grid.Row="0" Grid.Column="0" Name="cb_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="0" Grid.Column="1" Name="cbxSort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox  Grid.Row="0" Grid.Column="2" Name="tb_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="3" Name="cb_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="4" Name="cb_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="5" Name="cb_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="6" Name="cb_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="7" Name="tb_safe" Width="30" ToolTip="safe" Margin="5" KeyUp="tb_safe_KeyDown" />
            <TextBox  Grid.Row="0" Grid.Column="8" Name="tb_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="9" Name="cb_removeFirst" ToolTip="mise à zero des premiers" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="10" Name="cb_deleteFirst" ToolTip="suppression des premiers" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="0" Grid.Column="11" Name="cbx1_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="0" Grid.Column="12" Name="cb_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="13" Name="cb_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="0" Grid.Column="14" Name="tb_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="0" Grid.Column="15" Name="cb_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="16" Name="cb_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="17" Name="cb_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="18" Name="cb_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="19" Name="cb_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="20" Name="cb_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="0" Grid.Column="21" Name="cb_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
         
            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="0" Grid.Column="22" Name="cbx_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="0" Grid.Column="23" Name="tb_zero" Width="120" ToolTip="zéro" Margin="5" />

            <CheckBox Grid.Row="1" Grid.Column="0"  Name="cb2_enabled" ToolTip="utilisé" Margin="5" Padding="2" />
            <ComboBox Grid.Row="1" Grid.Column="1" Name="cbx2Sort" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas de conf" Name="none2"></ComboBoxItem>
                <ComboBoxItem ToolTip="tri sur moyenne quand aucun des albums n'a défini sa médianne" Name="strict2">strict</ComboBoxItem>
                <ComboBoxItem ToolTip="calcul Médianne moins strict" Name="light2" >light</ComboBoxItem>
                <ComboBoxItem ToolTip="tri uniquement sur la moyenne" Name="moy2" >moy</ComboBoxItem>
            </ComboBox>

            <TextBox Grid.Row="1" Grid.Column="2"  Name="tb2_medianne" Width="30" ToolTip="medianne" Margin="5" />
            <CheckBox Grid.Row="1" Grid.Column="3" Name="cb2_quasi" ToolTip="quasi" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="4" Name="cb2_lissage" ToolTip="lissage" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="5" Name="cb2_removeEpsilon" ToolTip="removeEpsilon" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="6" Name="cb2_reSort" ToolTip="reSort" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="7" Name="tb2_safe" Width="30" ToolTip="safe" Margin="5" />
            <TextBox  Grid.Row="1" Grid.Column="8" Name="tb2_coeff" Width="30" ToolTip="coeff des morceaux virtuels" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="9" Name="cb2_removeFirst" ToolTip="removeFirst" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="10" Name="cb2_deleteFirst" ToolTip="deleteFirst" Margin="5" Padding="2" />
            <ComboBox ToolTip="removelast" Grid.Row="1" Grid.Column="11" Name="cbx2_removeLast" Height="22" Padding="4" >
                <ComboBoxItem>non</ComboBoxItem>
                <ComboBoxItem>unselected</ComboBoxItem>
                <ComboBoxItem>virtuels</ComboBoxItem>
                <ComboBoxItem>tous</ComboBoxItem>
            </ComboBox>
            <CheckBox  Grid.Row="1" Grid.Column="12" Name="cb2_cumul" ToolTip="cumul" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="13" Name="cb2_noAdd" ToolTip="pas d'ajout" Margin="5" Padding="2" />
            <TextBox  Grid.Row="1" Grid.Column="14" Name="tb2_exp" Width="30" ToolTip="exposant proportion des morceaux gérés" Margin="5" />
            <CheckBox  Grid.Row="1" Grid.Column="15" Name="cb2_removeEnabled" ToolTip="remove enabled" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="16" Name="cb2_virtOnlyDisabled" ToolTip="virtuel: seulement les décochés" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="17" Name="cb2_forceCoeffVirt" ToolTip="virtuel: coeff forcé" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="18" Name="cb2_virtAlignSelected" ToolTip="virtuel: aligné sur le coché" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="19" Name="cb2_virtAlignPrec" ToolTip="virtuel: aligné sur le précédent" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="20" Name="cb2_coeffVirtAdjust" ToolTip="coeffvirt ajusté sur coeff selected" Margin="5" Padding="2" />
            <CheckBox  Grid.Row="1" Grid.Column="21" Name="cb2_coeffVirtAuto" ToolTip="coeffvirt automatique" Margin="5" Padding="2" />
            <ComboBox ToolTip="ajusté avec le plus mauvais coché si besoin" Grid.Row="1" Grid.Column="22" Name="cbx2_cmpMinn" Height="22" Padding="4" >
                <ComboBoxItem ToolTip="pas géré" >non</ComboBoxItem>
                <ComboBoxItem ToolTip="ce qui reste dispo est plus grand que la médianne">orphelin</ComboBoxItem>
                <ComboBoxItem ToolTip="tou ce qui est noté et coché">toujours</ComboBoxItem>
            </ComboBox>
            <TextBox  Grid.Row="1" Grid.Column="23" Name="tb2_zero" Width="120" ToolTip="zéro" Margin="5" />
        </Grid>
        
        <StackPanel Grid.Row="2"  Orientation="Horizontal"  HorizontalAlignment="Right" Margin="0,5" Grid.Column="1" Width="243">
            <TextBox Grid.Row="2" Name="tb_stackSize" Width="30"  VerticalAlignment="Center" Text="10" ToolTip="taille de la pile d'exclusion" Margin="5" Padding="2"/>
            <TextBox Grid.Row="2" Name="tb_coeffEnabled" Width="60"  VerticalAlignment="Center" Text="1" ToolTip="Coeff des morceaux cochés"  KeyUp="tb_safe_KeyDown" Margin="5" Padding="2"/>
            <Button Grid.Row="2" Name="bt_cancel" Height="25" HorizontalAlignment="Right" Content="Cancel" Click="bt_cancel_Click"   Margin="5" Padding="2"/>
            <Button Grid.Row="2" Name="bt_ok" Height="25" HorizontalAlignment="Right" Content="Ok" Click="bt_ok_Click"   Margin="5" Padding="2"/>
        </StackPanel>
    </Grid>

</Window>
]]></content>
  </file>
  <file path="\pdb.player\Vue\ConfAlbumSortW.xaml.cs">
    <content><![CDATA[using System;
using System.Windows;
using pdb.gen.Tuning;
using pdb.gen;
using pdb.db.piece.type;

namespace pdb.player.Vue
{
    /// <summary>
    /// Interaction logic for ConfAlbumSortW.xaml
    /// </summary>
    public partial class ConfAlbumSortW : Window
    {
        private ConfAlbumSort conf;
        public ConfAlbumSortW()
        {
            InitializeComponent();
            this.Loaded += new RoutedEventHandler(ConfAlbumSortW_Loaded);
        }

        void ConfAlbumSortW_Loaded(object sender, RoutedEventArgs e)
        {
            bt_ok.IsDefault = true; 
            display();
        }

        public ConfAlbumSortW(ConfAlbumSort conf)
            : this()
        {
            this.conf = conf;
        }

        void display()
        {
            tb_coeffEnabled.Text = conf.coeffEnabled.ToString();
            tb_stackSize.Text = conf.stackSize.ToString(); 
            var list = conf.Composants;
            var item1 = list[0];
            cb_enabled.IsChecked = item1.enabled;
            cbxSort.SelectedIndex = (int)item1.type;
            tb_medianne.Text = item1.medianne.ToString();
            cb_quasi.IsChecked = item1.quasi;
            cb_lissage.IsChecked = item1.lissage;
            cb_removeEpsilon.IsChecked = item1.removeEpsilon;
            cb_reSort.IsChecked = item1.reSort;
            cb_removeFirst.IsChecked = item1.removeFirst;
            cb_deleteFirst.IsChecked = item1.deleteFirst;
            cbx1_removeLast.SelectedIndex = (int)item1.removeLast;
            cb_cumul.IsChecked = item1.cumul;
            cb_noAdd.IsChecked = item1.noAdd;
            tb_safe.Text = item1.safe.ToString();
            tb_coeff.Text = item1.coeffVirt.ToString();
            tb_exp.Text = item1.expEnabled.ToString();
            tb_zero.Text = Piece.getClassementEquiv(item1.zero);
            cb_removeEnabled.IsChecked = item1.removeEnabled;
            cb_virtOnlyDisabled.IsChecked = item1.virtOnlyDisabled;
            cb_forceCoeffVirt.IsChecked = item1.forceCoeffVirt;
            cb_virtAlignPrec.IsChecked = item1.virtAlignPrec;
            cb_virtAlignSelected.IsChecked = item1.virtAlignSelected;
            cb_coeffVirtAdjust.IsChecked = item1.coeffVirtAdjust;
            cb_coeffVirtAuto.IsChecked = item1.coeffVirtAuto;
            cbx_cmpMinn.SelectedIndex = (int)item1.cmpMin; 



            if (list.Count > 1)
            {
                item1 = list[1];
                cb2_enabled.IsChecked = item1.enabled;
                cbx2Sort.SelectedIndex = (int)item1.type;
                tb2_medianne.Text = item1.medianne.ToString();
                cb2_quasi.IsChecked = item1.quasi;
                cb2_lissage.IsChecked = item1.lissage;
                cb2_removeEpsilon.IsChecked = item1.removeEpsilon;
                cb2_reSort.IsChecked = item1.reSort;
                cb2_removeFirst.IsChecked = item1.removeFirst;
                cb2_deleteFirst.IsChecked = item1.deleteFirst;
                cbx2_removeLast.SelectedIndex = (int)item1.removeLast;
                cb2_cumul.IsChecked = item1.cumul;
                cb2_noAdd.IsChecked = item1.noAdd;
                tb2_safe.Text = item1.safe.ToString();
                tb2_coeff.Text = item1.coeffVirt.ToString();
                tb2_exp.Text = item1.expEnabled.ToString();
                tb2_zero.Text = Piece.getClassementEquiv(item1.zero);
                cb2_removeEnabled.IsChecked = item1.removeEnabled;
                cb2_virtOnlyDisabled.IsChecked = item1.virtOnlyDisabled;
                cb2_forceCoeffVirt.IsChecked = item1.forceCoeffVirt;
                cb2_virtAlignPrec.IsChecked = item1.virtAlignPrec;
                cb2_virtAlignSelected.IsChecked = item1.virtAlignSelected;
                cb2_coeffVirtAdjust.IsChecked = item1.coeffVirtAdjust;
                cb2_coeffVirtAuto.IsChecked = item1.coeffVirtAuto;
                cbx2_cmpMinn.SelectedIndex = (int)item1.cmpMin; 
            }
        }
        void record()
        {
            conf.coeffEnabled = Convert.ToDecimal(tb_coeffEnabled.Text);
            conf.stackSize = Convert.ToInt32(tb_stackSize.Text); 
            var list = conf.Composants;
            var item1 = list[0];
            item1.enabled = cb_enabled.IsChecked.Value;
            item1.type = (util.medianneMode)cbxSort.SelectedIndex;
            item1.medianne = Convert.ToDecimal(tb_medianne.Text);
            item1.quasi = cb_quasi.IsChecked.Value;
            item1.lissage = cb_lissage.IsChecked.Value;
            item1.removeEpsilon = cb_removeEpsilon.IsChecked.Value;
            item1.reSort = cb_reSort.IsChecked.Value;
            item1.removeFirst = cb_removeFirst.IsChecked.Value;
            item1.deleteFirst = cb_deleteFirst.IsChecked.Value;
            item1.removeLast = (util.removeLast)cbx1_removeLast.SelectedIndex;
            item1.cumul = cb_cumul.IsChecked.Value;
            item1.noAdd = cb_noAdd.IsChecked.Value;
            item1.safe = Convert.ToInt32(tb_safe.Text);
            item1.coeffVirt = Convert.ToDecimal(tb_coeff.Text);
            item1.expEnabled = Convert.ToDecimal(tb_exp.Text);
            var cl = Classement.create(tb_zero.Text);
            item1.zero = cl.RapportClassement;
            item1.removeEnabled = cb_removeEnabled.IsChecked.Value;
            item1.virtOnlyDisabled = cb_virtOnlyDisabled.IsChecked.Value;
            item1.forceCoeffVirt = cb_forceCoeffVirt.IsChecked.Value;
            item1.virtAlignPrec = cb_virtAlignPrec.IsChecked.Value;
            item1.virtAlignSelected = cb_virtAlignSelected.IsChecked.Value;
            item1.coeffVirtAuto = cb_coeffVirtAuto.IsChecked.Value;
            item1.coeffVirtAdjust = cb_coeffVirtAdjust.IsChecked.Value;
            item1.cmpMin = (util.modeMin)cbx_cmpMinn.SelectedIndex;
          
            if (list.Count > 1)
            {
                if (cbx2Sort.SelectedIndex == 0)
                {
                    list.RemoveAt(1);
                    return;
                }
            }
            else
            {
                if (cbx2Sort.SelectedIndex > 0)
                {
                    item1 = new util.ConfMedianne();
                    list.Add(item1);
                }
            }

            if (list.Count > 1)
            {
                item1 = list[1];

                item1.enabled = cb2_enabled.IsChecked.Value;
                item1.type = (util.medianneMode)cbx2Sort.SelectedIndex;
                item1.medianne = Convert.ToDecimal(tb2_medianne.Text);
                item1.quasi = cb2_quasi.IsChecked.Value;
                item1.lissage = cb2_lissage.IsChecked.Value;
                item1.removeEpsilon = cb2_removeEpsilon.IsChecked.Value;
                item1.reSort = cb2_reSort.IsChecked.Value;
                item1.removeFirst = cb2_removeFirst.IsChecked.Value;
                item1.deleteFirst = cb2_deleteFirst.IsChecked.Value;
                item1.removeLast = (util.removeLast)cbx2_removeLast.SelectedIndex;
                item1.cumul = cb2_cumul.IsChecked.Value;
                item1.noAdd = cb2_noAdd.IsChecked.Value;
                item1.safe = Convert.ToInt32(tb2_safe.Text);
                item1.coeffVirt = Convert.ToDecimal(tb2_coeff.Text);
                item1.expEnabled = Convert.ToDecimal(tb2_exp.Text);
                item1.zero = Convert.ToDecimal(tb2_zero.Text);

                cl = Classement.create(tb2_zero.Text);
                item1.zero = cl.RapportClassement;
                item1.removeEnabled = cb2_removeEnabled.IsChecked.Value;
                item1.virtOnlyDisabled = cb2_virtOnlyDisabled.IsChecked.Value;
                item1.forceCoeffVirt = cb2_forceCoeffVirt.IsChecked.Value;
                item1.virtAlignPrec = cb2_virtAlignPrec.IsChecked.Value;
                item1.virtAlignSelected = cb2_virtAlignSelected.IsChecked.Value;
                item1.coeffVirtAuto = cb2_coeffVirtAuto.IsChecked.Value;
                item1.coeffVirtAdjust = cb2_coeffVirtAdjust.IsChecked.Value;
                item1.cmpMin = (util.modeMin)cbx2_cmpMinn.SelectedIndex;
            }
        }

        private void bt_cancel_Click(object sender, RoutedEventArgs e)
        {
            Close();
        }

        private void bt_ok_Click(object sender, RoutedEventArgs e)
        {
            record();
            Close();
            conf.Calcul();
            App.go();
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {

        }

        private void tb_safe_KeyDown(object sender, System.Windows.Input.KeyEventArgs e)
        {
            onchange(); 
        }

        private void tb_safe_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            onchange(); 
        }

        private void onchange()
        {
            if (true != cb_coeffVirtAdjust.IsChecked)
                return;
            try
            {
                var safe = Convert.ToInt32(tb_safe.Text);
                var coeffEnabled = Convert.ToDecimal(tb_coeffEnabled.Text);
                var coeffVirt = Math.Pow((double)coeffEnabled, 1.0 / (safe + 1.0));
                tb_coeff.Text = coeffVirt.ToString();
            }
            catch
            {
            }

        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\Vue\Util\StringFormatConverter.cs">
    <content><![CDATA[using System;
using System.Windows.Data;
using pdb.util;
using pdb.player.ViewModel;
using System.Windows.Media;
using pdb.gen;
using pdb.gen.albums;

namespace pdb.player.Vue.Util
{
    [ValueConversion(typeof(object), typeof(string))]
    public class StringFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            string format = parameter as string;
            if (!string.IsNullOrEmpty(format))
            {
                return string.Format(culture, format, value);
            }
            else
            {
                return value.ToString();
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TimeSpan), typeof(string))]
    public class TimeFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is TimeSpan)
            {
                TimeSpan ts = (TimeSpan)value;
                return String.Format("{0}:{1}{2}", ts.Minutes, ts.Seconds >= 10 ? "" : "0", ts.Seconds);
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }

    [ValueConversion(typeof(string), typeof(string))]
    public class ClFormatConverter : BaseConverter, IValueConverter
    {
        static int NB_DEC = 4;
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value == null)
                return "";
            var str = value.ToString();
            int count = str.Length;
            return Piece.getReadableCl(str);
            if (count < 4)
                return str;

            var tab = str.ToCharArray();
            var sb = new StringBuilder();
            bool second = false;
            //if (str.StartsWith("0"))
            second = true;
            int i = 0;

            bool pt = false;
            for (int ii = 0; ii < count; ii++)
            {
                var c = tab[ii];
                if (c == '.')
                    pt = true;

                if (!pt)
                {
                    if (c != ' ')
                    {

                        if (i > NB_DEC || (i >= NB_DEC && second))
                        {
                            if (!second)
                            {
                                second = true;
                                i = 1;
                            }
                            else
                                i = 0;
                            sb.Append(" ");
                        }
                        i++;
                    }
                }
                sb.Append(c);
            }

            return sb.ToString();


        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (value == null) return "";
            return value.ToString().Replace(" ", "");
        }
    }


    [ValueConversion(typeof(int), typeof(string))]
    public class IntFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                int ivalue = (int)value;
                if (ivalue <= 0) return "";
            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            int result;
            if (int.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }


    [ValueConversion(typeof(decimal), typeof(string))]
    public class DecimalFormatConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is decimal)
            {
                decimal dvalue = (decimal)value;
                if (dvalue <= 0) return "";
                return dvalue.ToString("0.###");

            }
            return value.ToString();

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            decimal result;
            if (decimal.TryParse(value.ToString(), out result))
            {
                return result;
            }
            return null;
        }
    }

    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class BgColorFormatConverter : BaseConverter, IValueConverter
    {
        private static SolidColorBrush brSelected;
        private static SolidColorBrush brMoved; 
        static BgColorFormatConverter()
        {
            Color color = (Color)ColorConverter.ConvertFromString("#3399ff");
          
            // #008ae6 - la mienne un peu terne
            //#88a9db
            //#547dab
            // #007acc

            //#3399ff - celle de seven w+r
            brSelected = new SolidColorBrush(color);
            color = (Color)ColorConverter.ConvertFromString("#93c8ce");
            brMoved = new SolidColorBrush(color);

        }
        public SolidColorBrush getColor(TrackListViewModel tv)
        {
            if (tv.IsSelected) return brSelected;
            if (tv.PieceGen.Moved) return brMoved; 
            exportState es = tv.ExportStatus;
            if (!tv.Exists)
                es = exportState.miss;
            switch (es)
            {
                case exportState.none: return Brushes.White;
                case exportState.miss: return Brushes.LightGray;
                case exportState.present: return Brushes.White;
                case exportState.copy: return Brushes.LightGreen;
                case exportState.delete: return Brushes.DarkGray;
                default:
                    break;
            }

            return Brushes.White;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                return getColor(tv);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(TrackListViewModel), typeof(Brush))]
    public class ForeColorFormatConverter : BaseConverter, IValueConverter
    {
        public SolidColorBrush getColor(TrackListViewModel tv)
        {
            if (tv.IsSelected) return Brushes.White;
            return Brushes.Black;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                TrackListViewModel tv = value as TrackListViewModel;
                return getColor(tv);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(ihmInDispo), typeof(Brush))]
    public class ColorDispoConverter : BaseConverter, IValueConverter
    {
        private SolidColorBrush getColor(ihmInDispo info)
        {

            switch (info)
            {
                case ihmInDispo.none: return Brushes.Transparent;
                case ihmInDispo.rot: return Brushes.Gainsboro;
                case ihmInDispo.stat: return Brushes.LightSlateGray;
                default:
                    break;
            }
            return Brushes.White;
        }

        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {

                ihmInDispo info = (ihmInDispo)value;
                return getColor(info);

            }
            catch
            {

            }
            return Brushes.White;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
    }


    [ValueConversion(typeof(bool), typeof(System.Windows.Visibility))]
    public class BoolToVis : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter,
                          System.Globalization.CultureInfo culture)
        {
            if (value is bool)
            {
                return (bool)value ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
            }
            return null;

        }

        public object ConvertBack(object value, Type targetType, object parameter,
                        System.Globalization.CultureInfo culture)
        {
            if (System.Windows.Visibility.Visible.Equals(value)) return true;
            if (System.Windows.Visibility.Collapsed.Equals(value)) return false;
            return null;

        }
    }
    [ValueConversion(typeof(medianneMode), typeof(int))]
    public class SortModeConverter : BaseConverter, IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is medianneMode)
            {
                return (int)value;
            }
            return null;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is int)
            {
                return (medianneMode)(int)(value);
            }
            return null;
        }
    }





}
]]></content>
  </file>
  <file path="\pdb.podcast\Build\PubLoader.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;

namespace pdb.podcast.Build
{
    class PubLoader
    {
        const char SEP = '|'; 
        public static DateTime MIN = new DateTime(1970, 1, 1);
        private static Regex regexComment = new Regex(@".*(\d\d\d\d/\d\d/\d\d\ \d\d:\d\d).*");
        private static Regex regex1 = new Regex(@".*(\d\d\.\d\d\.\d\d\d\d).*");
        private static Regex regex2 = new Regex(@".*(\d\d\d\d)(\d\d)(\d\d).*");
        private static Regex regex3 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_(\d\d)\.(\d\d)_.*");
        private static Regex reg2000 = new Regex(@".*(\d\d)\.(\d\d)\.(\d\d)_.*");
        private IPub track;
        public PubLoader(IPub track)
        {
            this.track = track;
        }

        private static DateTime BUG2000 = new DateTime(1999, 12, 30);
        private static DateTime BUG2000_2 = new DateTime(99, 12, 30);

        public void setPub(bool updateNative)
        {
            string _comment = track.Comment;
            DateTime dateComment = DateTime.MinValue;
            bool pubYear = false;

            if (_comment.Contains(SEP))
                _comment = _comment.Split(SEP)[1]; 


            //if (track.Name.Contains("Nougaro"))
            //{
            //    int toto = 0;
            //}

            try
            {
                dateComment = Convert.ToDateTime(_comment);

            }
            catch
            {
                if (regexComment.IsMatch(_comment))
                {
                    Match m = regexComment.Match(_comment);
                    string strDate = m.Groups[1].Value;
                    try
                    {
                        var d = Convert.ToDateTime(strDate);
                        if (d != BUG2000)
                        {
                            track.Pub = d;
                            if (track.Pub.DayOfYear == 1)
                                pubYear = true;
                        }

                    }
                    catch
                    {
                    }
                }
            }

            if (dateComment.Date == BUG2000)
            {
                dateComment = DateTime.MinValue;
            }

            if ((track.Pub < MIN || track.Pub.DayOfYear == 1) && (dateComment > MIN && dateComment.DayOfYear > 1))
            {
                track.Pub = dateComment;
            }
            string name = track.Name;
            checkDate1(name);
            checkDate2(name);
            checkDate3(name);



            if (!string.IsNullOrEmpty(track.Location))
            {
                string fileName = Path.GetFileName(track.Location);
                checkDate1(fileName);
                checkDate2(fileName);
                checkDate3(fileName);
                checkDate2000(fileName);
            }

            if (track.Pub <= MIN)
            {
                if (track.Year > 1970)
                {
                    DateTime dtYear = new DateTime(track.Year, 1, 1);
                    if (track.TrackNumber > 0)
                        dtYear = dtYear.AddDays(track.TrackNumber);
                    track.Pub = dtYear;
                    pubYear = true;
                }
            }


            if (track.Pub > MIN && track.Year > 1970)
            {
                if (track.Year != track.Pub.Year)
                {
                    var old = track.Pub;
                    track.Pub = new DateTime(track.Year, old.Month, old.Day, old.Hour, old.Minute, old.Second);
                }
            }



            if (track.Added < MIN) track.Added = MIN;

            // DateTime dt_ = track.Pub;
            if (track.Pub <= MIN)
                track.Pub = track.Added;


            string comment = track.Pub.ToString("yyyy/MM/dd HH:mm"); // dt_.Year + "-" + dt_.Month + "-" + dt_.Day;
            if (track.Offset > DateTime.MinValue)
                comment = track.Offset.ToString("yyyy/MM/dd HH:mm") + SEP + comment; 
            //if (pubYear)
            //    comment = getFileNameCmp(comment);
            if (_comment != comment)
            {
                try
                {
                    //string commentFound = track.Comment;
                    //string truc = commentFound;
                    if (_comment.Contains("_"))
                    {
                        //déjà fait
                        return;
                    }
                    //  truc = truc.Split('_')[0];

                    DateTime iComment = Convert.ToDateTime(_comment);
                    if (iComment != BUG2000 && iComment.DayOfYear != 1 && track.Pub.DayOfYear == 1)
                    {
                        track.Pub = iComment;
                    }
                    else
                    {
                        if (updateNative)
                            track.Comment = comment;
                    }
                }
                catch
                {
                    if (updateNative)
                        track.Comment = comment;
                }
            }



        }

        private string getFileNameCmp(string comment)
        {
            string fileName = Path.GetFileNameWithoutExtension(track.Location);

            if (fileName.Contains(" "))
            {
                var tab = fileName.Split(' ');
                fileName = tab[tab.GetLength(0) - 1];
            }

            if (fileName.Contains("_"))
            {
                var tab = fileName.Split('_');
                fileName = tab[tab.GetLength(0) - 1];
            }

            if (fileName.Length > 3)
                return comment;

            int nb = 0;
            bool isNum = Int32.TryParse(fileName, out nb);

            if (!isNum)
                return comment;

            while (fileName.Length < 3)
            {
                fileName = "0" + fileName;
            }
            return comment + "_" + fileName;
        }
        private void checkDate1(string info)
        {
            if (track.Pub > MIN)
                return;
            if (track.Pub < MIN)
                track.Pub = MIN;

            if (regex1.IsMatch(info))
            {
                try
                {
                    Match m = regex1.Match(info);
                    string strDate = m.Groups[1].Value;
                    DateTime dt = Convert.ToDateTime(strDate);
                    if (dt != BUG2000)
                        track.Pub = dt;
                }
                catch { }
            }
        }

        private void checkDate2(string info)
        {
            if (track.Pub > MIN)
                return;
            if (track.Pub < MIN)
                track.Pub = MIN;

            if (regex2.IsMatch(info))
            {
                try
                {
                    Match m = regex2.Match(info);
                    int year = Convert.ToInt16(m.Groups[1].Value);
                    int month = Convert.ToInt16(m.Groups[2].Value);
                    int day = Convert.ToInt16(m.Groups[3].Value);
                    DateTime dt = new DateTime(year, month, day);
                    if (dt != BUG2000)
                        track.Pub = dt;
                }
                catch { }
            }
        }

        private void checkDate3(string info)
        {
            if (track.Pub > MIN)
                return;
            if (track.Pub < MIN)
                track.Pub = MIN;

            if (regex3.IsMatch(info))
            {
                try
                {
                    Match m = regex3.Match(info);
                    int year = Convert.ToInt16(m.Groups[1].Value);
                    int month = Convert.ToInt16(m.Groups[2].Value);
                    int day = Convert.ToInt16(m.Groups[3].Value);
                    int hh = Convert.ToInt16(m.Groups[4].Value);
                    int mm = Convert.ToInt16(m.Groups[5].Value);

                    DateTime dt = new DateTime(year, month, day, hh, mm, 0);
                    if (dt != BUG2000 && dt != BUG2000_2)
                        track.Pub = dt;
                }
                catch { }
            }
        }

        private void checkDate2000(string info)
        {
            if (track.Pub > MIN)
                return;
            if (track.Pub < MIN)
                track.Pub = MIN;

            if (reg2000.IsMatch(info))
            {
                try
                {
                    Match m = reg2000.Match(info);
                    int year = Convert.ToInt16(m.Groups[1].Value) + 2000;
                    if (year > DateTime.Now.Year)
                        year -= 100;
                    int month = Convert.ToInt16(m.Groups[2].Value);
                    int day = Convert.ToInt16(m.Groups[3].Value);

                    DateTime dt = new DateTime(year, month, day);
                    if (dt != BUG2000)
                        track.Pub = dt;
                }
                catch { }
            }
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.util\Medianne.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;

namespace pdb.util
{
    public enum medianneMode
    {
        none = 0,
        strict = 1,
        light = 2,
        moy = 3

    }
    public enum removeLast
    {
        non = 0,
        unselected=1,
        virtuel = 2,
        tous = 3
    }

    public enum modeMin
    {
        /// <summary>
        /// On ne gère pas
        /// </summary>
        non = 0, 
        /// <summary>
        /// Morceaux supérieurs à la limite ( pas d'influence sur le résultat)
        /// </summary>
        orphelin=1,
        /// <summary>
        /// Morceaux cochés et notés
        /// </summary>
        toujours=2

    }
    public class ConfMedianne : TuningBase
    {
        public medianneMode type;
        public decimal medianne = 0.5m;
        public bool quasi;
        public int safe;
        public decimal coeffVirt = 10m;
        public bool enabled;
        public bool lissage;
        public bool removeEpsilon;
        public bool reSort;
        public bool removeFirst;
        public bool deleteFirst;
        public removeLast removeLast; 
        public bool cumul;
        public decimal expEnabled = 0m;
        public bool noAdd;
        public decimal zero = 0m;
        /// <summary>
        /// 
        /// </summary>
        public bool removeEnabled;
        public bool virtOnlyDisabled;
        public bool forceCoeffVirt;
        public bool virtAlignSelected;
        public bool virtAlignPrec;
        public bool coeffVirtAuto;
        public bool coeffVirtAdjust;
        public modeMin cmpMin; 
        public ConfMedianne()
        {
        }
        public ConfMedianne(ConfMedianne o)
        {
            type = o.type;
            medianne = o.medianne;
            quasi = o.quasi;
            safe = o.safe;
            coeffVirt = o.coeffVirt;
            enabled = o.enabled;
            lissage = o.lissage;
            removeEpsilon = o.removeEpsilon;
            reSort = o.reSort;
            removeFirst = o.removeFirst;
            deleteFirst = o.deleteFirst;
            removeLast = o.removeLast;
            cumul = o.cumul;
            expEnabled = o.expEnabled;
            noAdd = o.noAdd;
            zero = o.zero;
            removeEnabled = o.removeEnabled;
            virtOnlyDisabled = o.virtOnlyDisabled;
            forceCoeffVirt = o.forceCoeffVirt;
            virtAlignSelected = o.virtAlignSelected;
            virtAlignPrec = o.virtAlignPrec;
            coeffVirtAuto = o.coeffVirtAuto;
            coeffVirtAdjust = o.coeffVirtAdjust;
            cmpMin = o.cmpMin; 
        }

        public ConfMedianne(XmlElement parent, XmlElement child)
            : base(parent, child)
        {
            var strType = "";
            builds("type", v => strType = v);
            type = (medianneMode)Enum.Parse(typeof(medianneMode), strType, true);
            builddec("medianne", v => medianne = v);
            builddec("coeffVirt", v => coeffVirt = v);
            buildb("quasi", v => quasi = v);
            buildi("safe", v => safe = v);
            buildb("enabled", v => enabled = v);
            buildb("lissage", v => lissage = v);
            buildb("removeEpsilon", v => removeEpsilon = v);
            buildb("reSort", v => reSort = v);
            buildb("removeFirst", v => removeFirst = v);
            buildb("deleteFirst", v => deleteFirst = v);
            buildb("cumul", v => cumul = v);
            buildb("noAdd", v => noAdd = v); 
         
            builddec("expEnabled", v => expEnabled = v);
            builddec("zero", v => zero = v);
            buildb("removeEnabled", v => removeEnabled = v);
            buildb("virtOnlyDisabled", v => virtOnlyDisabled = v);
            buildb("forceCoeffVirt", v => forceCoeffVirt = v);
            buildb("virtAlignSelected", v => virtAlignSelected = v);
            buildb("virtAlignPrec", v=> virtAlignPrec = v);
            buildb("coeffVirtAuto", v => coeffVirtAuto = v);
            buildb("coeffVirtAdjust", v => coeffVirtAdjust = v);
           
            string _modeMin = "";
            builds("cmpMin", v => _modeMin = v);
            if (!string.IsNullOrEmpty(_modeMin))
                cmpMin = (modeMin)Enum.Parse(typeof(modeMin), _modeMin, true);


            string _removeLast = null;
            builds("removeLast", v => _removeLast = v);
            removeLast = (removeLast)Enum.Parse(typeof(removeLast), _removeLast, true);
        }
    }
    public class CalcMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(IList<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        public static DecimalIndex getMedianneLight(IList<decimal> list, ConfMedianne mode)
        {

            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, mode.medianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int indexV = 0;

            int count = list.Count;

            if (mode.safe > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                //for (int i00 = 1; i00 <= i0; i00++)
                //{
                //    decimal coeff = (decimal)i00 / (decimal)i0;
                List<decimal> _list = new List<decimal>(list);
                //for (int i = i00; i < count; i++)
                //    _list[i] = 0m;
                //liste partielle originale
                //  List<decimal> _list0 = new List<decimal>(_list);
                int _count = Math.Min(count, i0 + mode.safe);
                decimal[] virt = new decimal[_count];
                for (int i = 0; i < i0; i++)
                {
                    decimal _coeff = 1m;
                    decimal _base = _list[i];
                    for (int j = i + 1; j < _count; j++)
                    {
                        _coeff /= mode.coeffVirt;
                        virt[j] += _base * _coeff;
                    }
                }

                decimal value = int.MaxValue;
                int ii = 0;
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = _list[ii];
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (mode.lissage || value == 0m)
                        {
                            value = calc;
                            _list[ii] = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (mode.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= mode.safe)
                            continue;
                        _list[i] = 0m;
                    }

                }

                if (mode.reSort)
                {
                    _list.Sort();
                    _list.Reverse();
                }

                //for (int i = 0; i < nbAdd; i++)
                //    _list.RemoveAt(0); 


                var retAux = calcmedianneVirt(_list, mode.medianne, mode.quasi);
                //retAux.d *= coeff;
                if (retAux > ret)
                {
                    ret = retAux;
                    //  ret.index += nbAdd; 
                }
                //}


            }
            else
                ret = calcmedianneVirt(list, mode.medianne, mode.quasi);

            //  ret = getRapport(ret);


            return ret;
        }


        public static DecimalIndex getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi, int nbVirt)
        {
            DecimalIndex ret = new DecimalIndex();
            var medianne = getMedianne_(list, coeffMedianne);
            ret.d = medianne;
            ret.index = index;
            if (list.Count == 1)
                return ret;

            int count = list.Count;


            // decimal ret = medianne; //int.MinValue;

            if (nbVirt > 0)
            {

                int i0 = count - 1;

                for (int i = 0; i < count; i++)
                {
                    if (list[i] == 0m)
                    {
                        i0 = i;
                        break;
                    }
                }
                if (i0 == 0)
                    return ret;

                for (int i00 = 1; i00 <= i0; i00++)
                {
                    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>(list);
                    for (int i = i00; i < count; i++)
                        _list[i] = 0m;
                    int _count = Math.Min(count, i00 + nbVirt);
                    decimal[] virt = new decimal[_count];
                    for (int i = 0; i < i00; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = _list[i];
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= 10m;
                            virt[j] += _base * _coeff;
                        }
                    }
                    // decimal prec = -1m;  
                    int _nbVirt = 0;
                    decimal value = int.MaxValue;
                    int ii = 0;
                    for (ii = 1; ii < count && ii < _count; ii++)
                    {
                        //   prec = value;
                        value = _list[ii];
                        var calc = virt[ii];
                        if (value < calc)
                        {
                            if (_nbVirt >= nbVirt)
                                break;
                            _nbVirt++;
                            value = calc;  //Math.Min(prec, calc);
                            _list[ii] = value;

                        }
                        else
                            _nbVirt = 0;
                    }
                    for (int i = ii; i < count && i < _count; i++)
                    {
                        _list[i] = 0m;
                    }
                    //_list.Sort();
                    //_list.Reverse(); 



                    var retAux = calcmedianneVirt(_list, coeffMedianne, quasi);
                    retAux.d *= coeff;
                    if (retAux > ret)
                        ret = retAux;
                }


            }
            else
                ret = calcmedianneVirt(list, coeffMedianne, quasi);

            //  ret = getRapport(ret);

            //if (ret < medianne)
            //    ret = medianne;
            return ret;
        }

        private static decimal getLn(decimal rapport)
        {
            if (rapport <= 0)
                return 0m;
            return Convert.ToDecimal(10 + Math.Log10((double)rapport));
        }
        private static decimal getRapport(decimal ln)
        {
            return Convert.ToDecimal(Math.Pow(10, (double)ln - 10));
        }

        private static DecimalIndex calcmedianneVirt(IList<decimal> _list, decimal coeffMedianne, bool quasi)
        {

            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                {

                    _list.RemoveAt(count - i);
                }

                var aux = getMedianne_(_list, coeffMedianne);
                if (aux == 0m)
                    continue;
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                }

                if (_list[count - i - 1] > 0m)
                    break;


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }


        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System.Collections.Generic;
using pdb.util;
using System;
using System.Globalization;
using pdb.gen.Tuning;
using pdb.gen.conf;
using System.Linq;

namespace pdb.gen.albums
{
    public class Album
    {

        private string name;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }



        private List<Piece> list = new List<Piece>();
        private static int _sID = 0;
        private int _dID;


        public Album(string name)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        private string equiv = "";
        public string Equiv { get { return equiv; } }

        private string equivLight = "";
        public string EquivLight { get { return equivLight; } }

        private string equivLight0 = "";
        public string EquivLight0 { get { return equivLight0; } }

        private string moyenne = "";
        public string Moyenne { get { return moyenne; } }

        public bool Moved { get; set; }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (list.Contains(piece))
                return false;
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);
            piece.PieceAlbum = this;
            return true;
        }

        public List<Piece> Tracks
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceClassementDisplayComparer());
                return l;
            }
        }


        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        private bool atLeastOneEnabled;
        public bool AtLeastOneEnabled { get { return atLeastOneEnabled; } }

        public void makeSort(decimal coeffEnabled, ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            try
            {
                //if (name == "The College Dropout")
                //{
                //}
                decimal offset = conf.AlbumMoyOffset;
                int count = list.Count;
                list.Sort(new PieceSortComparer());
                var listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                {
                    listSortedValues.Add(list[i].Rank.SortValue);
                    if (!classed && list[i].isClassListNumeric)
                        classed = true;
                }

                m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                decimal moy = 0m;
                #region calcul brut
                #region init
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    //if (coeffEnabled != 1m && p.Enabled)
                    //{
                    //    rapportClassement /= coeffEnabled;
                    //}
                    p.setClassementVirtuel(list[i].RapportClassement);

                    list[i].eraseInfoMedianne();

                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                list.Sort(new PieceClassementComparer());
                listSortedValues = new List<decimal>();
                for (int i = 0; i < count; i++)
                    listSortedValues.Add(list[i].VirtualClassement);

                #endregion

                if (count > 0)
                    moy /= count;
                classMoy = moy;



                var med = CalcMedianne.getMedianne(listSortedValues, medianne);
                classementValue = med.d;
                if (classementValue > 0m)
                    list[med.index].Medianne = true;

                var _med = AlbumMedianne.getMedianneLight(new List<Piece>(list), coeffEnabled, mode0, false);
                equivLight0 = Piece.getClassementEquiv(_med.d);

                #endregion
                #region calcul virtuel
                #region init (prise en compte coeff des enabled)
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement;
                    if (coeffEnabled != 1m && p.Enabled)
                    {
                        rapportClassement /= coeffEnabled;
                    }
                    p.setClassementVirtuel(rapportClassement);
                }
                list.Sort(new PieceClassementComparer());
                #endregion

                med = AlbumMedianne.getMedianneLight(new List<Piece>(list), coeffEnabled, mode, true);
                classementValueLight = med.d;

                #endregion

                equiv = Piece.getClassementEquiv(classementValue); // (10000 * m_rank.SortValue).ToString("00000.0", cu); 
                equivLight = Piece.getClassementEquiv(classementValueLight);

                moyenne = Piece.getClassementEquiv(classMoy);
                var modeMin = mode.cmpMin;

                if (modeMin > modeMin.non)
                {
                    bool ok = false;
                    decimal _min = int.MaxValue;
                    foreach (Piece p in list)
                    {

                        if (p.Enabled && FileRegister.Exist(p.Location))
                        {
                            var v = p.VirtualClassement;
                            if (v > 0 && v < _min)
                            {
                                ok = true;
                                _min = v;
                            }
                        }
                    }

                    if (ok)
                    {
                        if (_min > classementValueLight || modeMin == modeMin.toujours)
                            classementValueLight = _min;
                    }


                }


            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }



        }



        public decimal getTrackSortValue(int index)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }

        public void makeSelection()
        {
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private void initRank()
        {
            m_rank.init();
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return name.Equals(o.name);
        }
        public override int GetHashCode()
        {
            return name.GetHashCode();
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.util;
using System.Collections;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        private static int index;
        public static int Index { get { return index; } }


        public static DecimalIndex getMedianne(IEnumerable list, decimal coeffMedianne)
        {
            var _list = new List<decimal>();
            foreach (object o in list)
            {
                _list.Add(Convert.ToDecimal(o));
            }
            return getMedianne(_list, coeffMedianne);
        }

        public static DecimalIndex getMedianne(List<decimal> list, decimal coeffMedianne)
        {
            return new DecimalIndex() { d = getMedianne_(list, coeffMedianne), index = index };
        }

        //public static DecimalIndex getMedianneLight(List<decimal> list, List<Piece> pieces, ConfMedianne mode, bool signal)
        //{
        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {


        //        var _zero = mode.zero;
        //        var medianne = getMedianne_(list, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;

        //        if (list.Count == 1)
        //            return ret0;

        //        if (mode.safe == 0)
        //        {
        //            return calcmedianneVirt(list, mode, 0, 0);
        //        }

        //        int indexV = 0;
        //        int nbAdd = 0;

        //        int count = list.Count;

        //        if (mode.safe > 0)
        //        {

        //            int i0 = count - 1;
        //            int _nbNoAdd = 0;

        //            for (int i = 0; i < count; i++)
        //            {
        //                if (list[i] <= _zero)
        //                {
        //                    i0 = i;
        //                    _nbNoAdd = count - i0;
        //                    break;
        //                }
        //            }
        //            if (i0 == 0)
        //                return ret0;

        //            //for (int i00 = 1; i00 <= i0; i00++)
        //            //{
        //            //    decimal coeff = (decimal)i00 / (decimal)i0;
        //            List<decimal> _list = new List<decimal>(list);
        //            //for (int i = i00; i < count; i++)
        //            //    _list[i] = 0m;
        //            //liste partielle originale
        //            //  List<decimal> _list0 = new List<decimal>(_list);
        //            int _count = System.Math.Min(count, i0 + mode.safe);
        //            decimal[] virt = new decimal[_count];
        //            _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
        //            if (mode.noAdd)
        //            {

        //                decimal _coeff = 1m;
        //                for (int j = _nbNoAdd - 1; j >= 0; j--)
        //                {
        //                    if (j < count)
        //                    {
        //                        _coeff /= mode.coeffVirt;
        //                        _list[j] = _list[j] * _coeff;
        //                    }
        //                }
        //            }
        //            else if (mode.lissage || mode.removeEpsilon || mode.cumul)
        //            {
        //                for (int i = 0; i < i0; i++)
        //                {
        //                    decimal _coeff = 1m;
        //                    decimal _base = _list[i];
        //                    for (int j = i + 1; j < _count; j++)
        //                    {
        //                        _coeff /= mode.coeffVirt;
        //                        virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
        //                    }
        //                }
        //            }
        //            else
        //            {
        //                decimal courant = _list[0];
        //                for (int i = 1; i < _count; i++)
        //                {
        //                    if (_list[i] <= _zero)
        //                    {
        //                        courant /= mode.coeffVirt;
        //                        virt[i] = courant;
        //                    }
        //                    else
        //                        courant = _list[i];
        //                }
        //            }

        //            decimal value = int.MaxValue;
        //            int ii = 0;
        //            if (mode.noAdd)
        //            {
        //                //for (ii = 1; ii < count && ii < _count; ii++)
        //                //{
        //                //    var calc = virt[ii];
        //                //    if (calc > 0m)
        //                //        list[ii] = calc;
        //                //}
        //            }
        //            else
        //            {
        //                for (ii = 1; ii < count && ii < _count; ii++)
        //                {
        //                    value = _list[ii];
        //                    var calc = virt[ii];
        //                    if (value < calc)
        //                    {
        //                        if (mode.lissage || value <= _zero)
        //                        {
        //                            if (value <= _zero)
        //                                nbAdd++;
        //                            value = calc;
        //                            _list[ii] = value;
        //                        }

        //                    }
        //                    else
        //                        indexV = ii;
        //                }
        //                if (mode.removeEpsilon)
        //                {
        //                    // j'ai 5 virtuel alors que j'ai deux safe
        //                    ///xx---
        //                    int nb = 0;
        //                    for (int i = indexV + 1; i < _count; i++)
        //                    {
        //                        nb++;
        //                        if (nb <= mode.safe)
        //                            continue;
        //                        _list[i] = 0m;
        //                    }

        //                }
        //                if (mode.removeFirst)
        //                {
        //                    for (int i = 0; i < nbAdd; i++)
        //                    {
        //                        _list[i] = 0m;
        //                    }
        //                }
        //            }

        //            for (int i = 0; i < _list.Count && i < pieces.Count; i++)
        //                pieces[i].setClassementVirtuel(_list[i]);

        //            if (mode.deleteFirst)
        //            {
        //                for (int i = 0; i < nbAdd; i++)
        //                {
        //                    _list.RemoveAt(0);
        //                }
        //            }

        //            if (mode.reSort || mode.removeFirst || mode.noAdd)
        //            {
        //                _list.Sort();
        //                _list.Reverse();
        //                pieces.Sort(new PieceCmp());
        //            }



        //            if (mode.noAdd)
        //                nbAdd = _nbNoAdd;

        //            ret = calcmedianneVirt(_list, mode, nbAdd, System.Math.Min(i0, mode.safe));
        //            if (mode.expEnabled != 0)
        //            {
        //                int _nb = pieces.Count<Piece>(p => !p.Enabled);
        //                decimal _c = (decimal)_nb / (decimal)count;
        //                _c = Math.Pow(_c, mode.expEnabled);
        //                ret.d *= _c;
        //            }


        //        }
        //        else
        //            ret = calcmedianneVirt(list, mode, 0, 0);

        //        //if (ret < ret0)
        //        //    ret = ret0; 



        //    }
        //    finally
        //    {
        //        if (signal)
        //        {
        //            try
        //            {
        //                pieces[ret.index].MedianneLight = true;
        //                pieces[ret.indexBorder].Border = true;
        //                pieces[ret.indexBorderEffect].BorderEffect = true;
        //                pieces[ret.indexBorderMin].BorderMin = true;

        //            }
        //            catch { }
        //        }
        //    }

        //    return ret;
        //}

        public static DecimalIndex getMedianneLight(List<Piece> pieces, decimal coeffEnabled, ConfMedianne mode, bool signal)
        {

            DecimalIndex ret0 = new DecimalIndex();
            DecimalIndex ret = ret0;
            try
            {
                var _zero = mode.zero;
                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = index;
                ret = ret0;
                if (pieces.Count == 1)
                    return ret0;

                if (mode.safe == 0)
                {
                    return calcmedianneVirt(pieces, mode, 0, 0);
                }

                int indexV = 0;
                int nbAdd = 0;

                int count = pieces.Count;
                List<Piece> _pieces = pieces;
                //if (mode.virtOnlyDisabled)
                //{
                //    _pieces = pieces.FindAll(p => !p.Enabled && p.VirtualClassement > 0m);
                //    _pieces.Sort(new PieceCmp());
                //}


                if (mode.safe > 0)
                {
                    int i0 = count - 1;
                    int _nbNoAdd = 0;
                    //if (mode.virtOnlyDisabled)
                    //{
                    //    _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);
                    //}
                    //else
                    //{

                    for (int i = 0; i < count; i++)
                    {
                        var pp = pieces[i];
                        if (pp.VirtualClassement == 0m)
                        {
                            i0 = i;
                            _nbNoAdd = count - i0;
                            break;
                        }
                    }

                    if (mode.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
                        _nbNoAdd = pieces.Count<Piece>(p => p.Enabled);  // || p.VirtualClassement == 0m);
                    if (i0 == 0)
                        return ret0;
                    //}

                    //for (int i00 = 1; i00 <= i0; i00++)
                    //{
                    //    decimal coeff = (decimal)i00 / (decimal)i0;
                    List<decimal> _list = new List<decimal>();
                    for (int i = 0; i < _pieces.Count; i++)
                        _list.Add(_pieces[i].VirtualClassement);
                    //for (int i = i00; i < count; i++)
                    //    _list[i] = 0m;
                    //liste partielle originale
                    //  List<decimal> _list0 = new List<decimal>(_list);
                    int _count = System.Math.Min(count, i0 + mode.safe);
                    decimal[] virt = new decimal[_count];
                    _nbNoAdd = System.Math.Min(mode.safe, _nbNoAdd);
                    if (mode.noAdd)
                    {
                        var _coeffVirt = mode.coeffVirt;
                        if (count < mode.safe && mode.coeffVirtAuto)
                        {
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        }
                        decimal _coeff = 1m;
                        decimal prec = 0m;
                        if (mode.virtAlignPrec)
                        {
                            if (_nbNoAdd < _list.Count)
                                prec = _list[_nbNoAdd];
                        }

                        for (int j = _nbNoAdd - 1; j >= 0; j--)
                        {
                            if (j < _pieces.Count)
                            {

                                if (!mode.virtOnlyDisabled || !_pieces[j].Enabled)
                                {
                                    _coeff /= _coeffVirt;
                                    var cand = _list[j] * _coeff;
                                    if (mode.virtAlignPrec)
                                    {
                                        if (cand < prec)
                                            cand = prec;
                                    }

                                    if (mode.virtAlignSelected && mode.virtOnlyDisabled)
                                    {
                                        // quel serait le score s'il était coché
                                        var vu = _list[j] / coeffEnabled;
                                        // en plus une petite marge
                                        //  vu *= mode.coeffVirt; 
                                        if (cand < vu)
                                            cand = vu;
                                    }
                                    _list[j] = cand;
                                }
                                else if (mode.forceCoeffVirt)
                                    _coeff /= _coeffVirt;
                                prec = _list[j];
                            }
                        }

                    }
                    else if (mode.lissage || mode.removeEpsilon || mode.cumul)
                    {
                        for (int i = 0; i < i0; i++)
                        {
                            decimal _coeff = 1m;
                            decimal _base = _list[i];
                            for (int j = i + 1; j < _count; j++)
                            {
                                _coeff /= mode.coeffVirt;
                                virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                            }
                        }
                    }
                    else
                    {
                        decimal courant = _list[0];
                        for (int i = 1; i < _count; i++)
                        {
                            if (_list[i] <= _zero)
                            {
                                courant /= mode.coeffVirt;
                                virt[i] = courant;
                            }
                            else
                                courant = _list[i];
                        }
                    }

                    decimal value = int.MaxValue;
                    int ii = 0;
                    if (mode.noAdd)
                    {
                        //for (ii = 1; ii < count && ii < _count; ii++)
                        //{
                        //    var calc = virt[ii];
                        //    if (calc > 0m)
                        //        list[ii] = calc;
                        //}
                    }
                    else
                    {
                        for (ii = 1; ii < count && ii < _count; ii++)
                        {
                            value = _list[ii];
                            var calc = virt[ii];
                            if (value < calc)
                            {
                                if (mode.lissage || value <= _zero)
                                {
                                    if (value <= _zero)
                                        nbAdd++;
                                    value = calc;
                                    _list[ii] = value;
                                }

                            }
                            else
                                indexV = ii;
                        }
                        if (mode.removeEpsilon)
                        {
                            // j'ai 5 virtuel alors que j'ai deux safe
                            ///xx---
                            int nb = 0;
                            for (int i = indexV + 1; i < _count; i++)
                            {
                                nb++;
                                if (nb <= mode.safe)
                                    continue;
                                _list[i] = 0m;
                            }

                        }
                        if (mode.removeFirst)
                        {
                            for (int i = 0; i < nbAdd; i++)
                            {
                                _list[i] = 0m;
                            }
                        }
                    }

                    for (int i = 0; i < _list.Count && i < _pieces.Count; i++)
                        _pieces[i].setClassementVirtuel(_list[i]);

                    if (mode.deleteFirst)
                    {
                        for (int i = 0; i < nbAdd; i++)
                        {
                            pieces.RemoveAt(0);
                        }
                    }

                    if (mode.reSort || mode.removeFirst || mode.noAdd)
                    {
                        //_list.Sort();
                        //_list.Reverse();
                        pieces.Sort(new PieceCmp());
                    }



                    if (mode.noAdd)
                        nbAdd = _nbNoAdd;

                    ret = calcmedianneVirt(pieces, mode, nbAdd, System.Math.Min(i0, mode.safe));
                    if (mode.expEnabled != 0)
                    {
                        int _nb = pieces.Count<Piece>(p => !p.Enabled);
                        decimal _c = (decimal)_nb / (decimal)count;
                        _c = Math.Pow(_c, mode.expEnabled);
                        ret.d *= _c;
                    }


                }
                else
                    ret = calcmedianneVirt(pieces, mode, 0, 0);

                //if (ret < ret0)
                //    ret = ret0; 

            }
            finally
            {

                if (signal)
                {
                    try
                    {
                        pieces[ret.index].MedianneLight = true;
                        pieces[ret.indexBorder].Border = true;
                        pieces[ret.indexBorderEffect].BorderEffect = true;
                        pieces[ret.indexBorderMin].BorderMin = true;

                    }
                    catch { }
                }
            }

            return ret;
        }




        private class PieceCmp : IComparer<Piece>
        {
            private static PieceTrackNumberComparer tn = new PieceTrackNumberComparer();
            public int Compare(Piece x, Piece y)
            {
                int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }




        private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        {
            var _list = new List<decimal>(list);
            int count = _list.Count;

            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {

                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                if (_list[count - i - 1] > conf.zero)
                {

                    if (conf.removeLast == removeLast.non)
                        break;
                    _nbSupp++;
                    if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                        break;
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }



        private static DecimalIndex calcmedianneVirt(IList<Piece> list, ConfMedianne conf, int nbAdd, int nbDel)
        {
            var _list = new List<Piece>(list);
            var classes = _list.FindAll(p => p.VirtualClassement > conf.zero); 
            int count = _list.Count;

            int nbEnabled = classes.Count<Piece>(p => p.Enabled);
            int nbDisabled = classes.Count<Piece>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled); 


            DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
            int _nbSupp = 0;
            //int _nbSuppDisabled = 0;
            //int _nbSuppEnabled = 0;
            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {

                if (i > 0)
                {
                    //var d = _list[count - i];
                    //if (d.Enabled)
                    //    nbEnabled--;
                    //else
                    //    nbDisabled--;
                   
                    _list.RemoveAt(count - i);

                }

                var aux = getMedianne_(_list, conf.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = count - i - 1;
                }
                // aux = getLn(aux);
                //decimal coeff = 1; 
                //if (count >2)
                //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
                if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
                {
                    coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
                }
                if (conf.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = index;
                    ret.indexBorderEffect = count - i - 1;
                }

                ret.indexBorderMin = count - i - 1;
                var p = _list[count - i - 1];

                if (p.VirtualClassement > conf.zero)
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considèere qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--; 

                    if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected )&& nbEnabled < 0)
                            break;
                       
                        if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break; 
                        }
                          
                        _nbSupp++;
                        if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
                            break;
                        // }


                    }
                }


            }

            //     if (ret == int.MinValue)
            //         return 0m;
            return ret;
        }

        public static decimal getMedianneLight0(IList<decimal> list, decimal coeffMedianne, bool quasi)
        {
            if (list.Count == 1)
                return getMedianne_(list, coeffMedianne);
            decimal ret = 0m;
            int count = list.Count;

            List<decimal> _list = new List<decimal>(list);
            // ret = getMedianne_(_list, coeffMedianne);
            decimal nb = 0m;
            for (int i = 0; i < count - 1; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);
                var aux = getMedianne_(_list, coeffMedianne);
                decimal coeff = count - 1 - i;
                if (quasi)
                    coeff *= coeff;
                ret += aux * coeff;
                nb += coeff;


            }
            ret /= nb;


            return ret;
        }
        private static decimal getMedianne_(IList<decimal> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0];
            if (coeffMedianne == 0)
                return list[0];
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1];
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index];
            var val1 = list[i1];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        private static decimal getMedianne_(IList<Piece> list, decimal coeffMedianne)
        {
            index = 0;
            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1)
                return list[0].VirtualClassement;
            if (coeffMedianne == 0)
                return list[0].VirtualClassement;
            if (coeffMedianne == 1)
            {
                index = count - 1;
                return list[count - 1].VirtualClassement;
            }

            var medianne = coeffMedianne * (count - 1);

            index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].VirtualClassement;
            var val1 = list[i1].VirtualClassement;
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
                return val0;
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                index = i1;
                return val1;
            }

            var pente = (val1 - val0);
            var dx = medianne - index;
            var dy = pente * dx;
            return val0 + dy;

        }

        //public static int getEquiv(IList<double> listRef, double target, int i0, int i1)
        //{
        //    var val0 = listRef[i0]; 
        //     var val1 = listRef[i1]; 
        //    if (i1 - i0 == 1)
        //    {
        //        // on prend le plus proche
        //        var delta0 = target - val0;
        //        var delta1 = val1 - target; 

        //        if (delta0 <= delta1)
        //            return i0;
        //        return i1; 
        //    }

        //    int imiddle = (i0 + i1) / 2;
        //    if (imiddle == i0)
        //        imiddle++; 
        //    var vmiddle = listRef[imiddle];

        //    if (vmiddle == target)
        //        return imiddle;
        //    if (Math.Abs(vmiddle - target) < PRECISION)
        //        return imiddle;

        //    if (vmiddle < target)
        //        return getEquiv(listRef, target, imiddle, i1);
        //    return getEquiv(listRef, target, i0, imiddle); 


        //}
    }
}
]]></content>
  </file>
</db>
