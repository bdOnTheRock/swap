<db path="C:\Bernard\db1\pdb4">
  <file path="\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;

namespace pdb.gen.albums
{


    public class Album : IEnumerable<Piece>
    {
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        private decimal classementValueLightSt = -1;
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;

        private bool sortDone;
        private bool sort0Done;
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }


            return ret; ;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                if (classementValueLightSt >= 0)
                    return classementValueLightSt;
                return getSt(classementValueLight);

                if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    classementValueLightSt = classementValueLight / delta;
                }
                else
                    classementValueLightSt = classementValueLight;

                return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
            }
        }
        private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero { get { return classementValueLightZero; } }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private bool _virtual;
        public bool Virtual { get { return _virtual; } set { _virtual = value; } }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return _virtualByArtist; } set { _virtualByArtist = value; } }
        private int stackValue;
        public int StackValue { get { return stackValue; } set { stackValue = value; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, VirtualByArtist);
                return key;
            }
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            m_rank.init();
        }

        public string Name { get { return name; } }

        public override string ToString()
        {
            return name;
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0 { get { return Piece.getClassementEquiv(classementValueLightZero); } }

        // private string moyenne = "";
        public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        public bool Moved { get; set; }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return nbEmpeached > 0;
            }
            set
            {
                if (value)
                    nbEmpeached = stackPeremption;
                else
                    nbEmpeached = 0;
            }
        }

        public void empeachedDecrement() { nbEmpeached--; }

        public int EmpeachedNb { get { return nbEmpeached; } }

        private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1 { get; set; }
        private static int stackSize = 20;
        private static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return stackValue == stackSize; } }
        public bool AlmostFree1 { get { return stackValue == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            piece.PieceAlbum = this;
            if (build)
                return true;

            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                m_rank.init();
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && p.RapportClassement == 0)
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                if (FileRegister.Exist(next.Location))
                    return false;
                return true;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<PieceExtended> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {

                #region calcul virtuel



                DecimalPiece med = null;
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
              // bool combineNow = mode.combine && mode.simple;
                if (real)
                    _albumMedianne.buildVirtual(mode.combine, mode.simple);
                else
                {
                    list.Sort(new PieceClassementComparer(false));
                }


                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.main);
                    med1 = med; med2 = med;
                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, PieceExtended.mode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }

                    if (mode.combine && !mode.simple)
                    {
                        med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine);
                    }


                }



                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }









                classementValueLight = med.d;



                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, PieceExtended.mode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    //if (mode.combine && !mode.simple)
                    //{
                    //    _albumMedianne.buildVirtual(true);
                    //    med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                    //    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    //}
                    //else
                    //{
                    //    if (true == cause.selectedMotifMin)
                    //        med = med2;
                    //    else
                    //        med = med1;
                    //}



                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

                    foreach (var p in list)
                        p.finalyse();



                    if (cause.motifUp)
                    {
                        if (cause.selectedMotifMin.HasValue)
                        {
                            if (true == cause.selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else if (selectedMotifMin.HasValue)
                        {
                            if (true == selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else
                        {
                            if (true == resultGlobalMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }

                        
                    }

                    try
                    {
                        med.index.Piece.MedianneLight = true;
                        med.indexBorder.Piece.Border = true;
                        med.indexBorderEffect.Piece.BorderEffect = true;
                        med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public PieceExtended Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<PieceExtended> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;


           // PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            PieceExtended nextZero1 = null;
            PieceExtended nextZero2 = null;

            PieceExtended min1 = null;
            PieceExtended min2 = null;
            PieceExtended min = null;
            decimal _min1 = int.MaxValue;
            decimal _min2 = int.MaxValue;
            decimal _minzero1 = int.MaxValue;
            decimal _minzero2 = int.MaxValue;
            bool realZero = false;
            PieceExtended Next = null;
            foreach (PieceExtended p in list)
            {
                var v1 = p.VirtualClassement;
                var v2 = p.VirtualClassement2;

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            _minzero1 = v1;
                            nextZero1 = p;
                            if (v1 == 0)
                                realZero = true;
                        }
                    }

                    if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2 == 0)
                                realZero = true;
                        }

                    }



                    if (v1 > 0 && v1 < _min1)
                    {
                        _min1 = v1;
                        min1 = p;
                    }

                    if (v2 > 0 && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }

                    if (p.Empty)
                        break;
                }
            }
            decimal _min = 0;
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;
            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }

            PieceExtended nextZero = null;
            decimal _minzero = int.MaxValue;
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }

            if (nextZero != null)
            {

                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.classementValueLightZero > classementValueLight + EPSILON) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_min < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _min;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minzero < classementValueLight)
                    {
                        classementValueLight = _minzero;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {
                        classementValueLight = _min;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            return cause;



        }




        public void makeSort(ConfMedianne mode, ConfMedianne mode0) //IList<double> reference, IList<Piece> pieces)
        {
            if (sortDone && sort0Done)
                return;

            try
            {

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return;

                var listE = new List<PieceExtended>(count);

                atLeastOneEnabled = false;
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    if (!sortDone)
                        p.eraseInfoMedianne();
                    if (p.Enabled)
                        atLeastOneEnabled = true;
                    var pp = new PieceExtended(p);
                    listE.Add(pp);
                }

                if (!sort0Done)
                {
                    list.Sort(new PieceSortComparer());
                    var listSortedValues = new List<decimal>();
                    classed = false;
                    for (int i = 0; i < count; i++)
                    {
                        listSortedValues.Add(list[i].Rank.SortValue);
                        if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                            classed = true;
                    }
                    //misc.log("make sort Duration {0}", name); 
                    m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                    listSortedValues = new List<decimal>();
                    list.Sort(new PieceDurationValueComparer());
                    for (int i = 0; i < count; i++)
                        listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                    durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                    //}
                    decimal moy = 0m;
                    decimal offset = Album.conf.AlbumMoyOffset;

                    for (int i = 0; i < count; i++)
                    {
                        var p = list[i];
                        var rapportClassement = p.RapportClassement;

                        p.setClassementVirtuel(list[i].RapportClassement);


                        moy += rapportClassement;
                        if (offset > 0m && rapportClassement > 0.0m)
                            moy += offset;
                    }

                    if (count > 0)
                        moy /= count;
                    classMoy = moy;


                    listE.Sort(new PieceClassementComparer(false));
                    this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                    //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                    classementValue = this.med.d;
                    if (classementValue > 0m)
                    {
                        if (med.index != null)
                            med.index.Piece.Medianne = true;
                        //if (this.med.index > 0 && this.med.index < list.Count)
                        //    list[this.med.index].Medianne = true;
                    }

                    sort0Done = true;

                }


                if (sortDone)
                    return;

                trackSortedByExportPriority = null;
                _tracksSortByClassement = null;
                classementValueLightSt = -1;
                classementValueLightZeroSt = -1;
                selectedCoeff = selectedCoeff.noCoeff;
                selectedSure = false;
                classementValueLight = 0;
                classementValueLightZero = 0;







                classementValueLightZero = makeSort(listE, mode0, false);
                classementValueLight = makeSort(listE, mode, true);


            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            sortDone = true;

        }



        public void mustRefresh()
        {
            build = false;
            sortDone = false;
            sort0Done = false; 
            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
        }

        public void refreshLight()
        {
            sortDone = false;
        }



        public decimal getTrackSortValue(int index, List<Piece> list)
        {
            if (index < 0 || index >= list.Count)
                return 0;
            return list[index].RapportClassement;
        }

        decimal firstTrackSortValue = -1;
        public decimal getFirstTrackSortValue()
        {
            if (firstTrackSortValue == -1)
            {
                int count = list.Count;
                if (count == 0)
                    return -1;
                var _list = new List<Piece>(list);
                _list.Sort(new PieceSortComparer());
                firstTrackSortValue = _list[count - 1].Rank.SortValue;
            }
            return firstTrackSortValue;
        }
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            m_rank.TimeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        private CRank m_rank = new CRank();

        public CRank Rank { get { return m_rank; } }

        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            m_rank.init();
            // rankStack = -1;
        }

        public int QRank
        {
            get { return m_rank.Quality; }
            set { m_rank.Quality = value; }
        }

        public int LRank
        {
            get { return m_rank.Lenght; }
            set { m_rank.Lenght = value; }
        }

        public int QLRank
        {
            get { return m_rank.Twice; }
            set { m_rank.Twice = value; }
        }


        #endregion

        #region tri



        #endregion

        public void sortVirtual()
        {
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceInVirtualAlbumComparer());
            int nb = 0;
            foreach (var piece in list)
            {
                nb++;
                piece.TrackNumber = nb;
            }
        }

        public bool isSameOf(Album o)
        {
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && _virtual == o._virtual && _virtualByArtist == o._virtualByArtist;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public DateTime AlbumAdded
        {
            get
            {
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                return min;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public static string getKey(string _album, bool artist)
        {
            string __album = "-";
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();


                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }

            }
            return __album;

        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\AlbumMedianne.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using pdb.gen.auto;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using Math = pdb.util.Math;

namespace pdb.gen.albums
{
    class AlbumMedianne
    {
        const decimal PRECISION = 0.0000001m;
        const decimal EPSILON = 0.0000000000001m;
        const decimal EPSILON_LOG = EPSILON;
        // private static PieceExtended index;
        //  public static int Index { get { return index; } }
        private static PieceExtended median;


        //public static DecimalIndex getMedianne(IList<Piece> list, bool main, decimal coeffMedianne)
        //{

        //    return new DecimalIndex() { d = getMedianne_(list, main, coeffMedianne), index = index };
        //}


        public static DecimalPiece getMedianne(IList<PieceExtended> list, bool main, decimal coeffMedianne)
        {
            PieceExtended.Mode = PieceExtended.mode.main;
            var ret = getMedianne_(list, coeffMedianne);
            return new DecimalPiece() { d = ret, index = median };
        }
        private List<PieceExtended> pieces;
        private ConfMedianne mode;
        private int _nbNoAdd;
        public AlbumMedianne(List<PieceExtended> pieces, ConfMedianne mode)
        {
            this.pieces = pieces;
            this.mode = mode;
            this._nbNoAdd = getNoAdd(mode.Main);
        }



        public void buildVirtual(bool combine, bool simple)
        {
            if (!mode.Min.Use)
            {
                buildVirtual0(mode.Main, true);
                align(mode.Main, PieceExtended.mode.main);
            }
            else if (combine && simple)
            {
                buildVirtual0(mode.Main, true);
                buildVirtual0(mode.Min, false);
                foreach (PieceExtended p in pieces)
                    p.Combine();
                align(mode.Main, PieceExtended.mode.combine);
            }
            else
            {
                buildVirtual0(mode.Main, true);
                buildVirtual0(mode.Min, false);
                align(mode.Main, PieceExtended.mode.main);
                align(mode.Min, PieceExtended.mode.min);

                if (combine)
                {
                    foreach (PieceExtended p in pieces)
                        p.Combine();
                    align(mode.Main, PieceExtended.mode.combine);
                }
            }
        }

        private int getNoAdd(ConfMedianneVirt modeVirt)
        {

            var safe = modeVirt.safe;

            int i0 = 0;
            int count = pieces.Count;
            if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
            {
                _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
                if (_nbNoAdd > 0)
                    _nbNoAdd--;
            }
            else if (modeVirt.noAddAll)
                _nbNoAdd = pieces.Count;
            else
            {
                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.VirtualClassement == 0m)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }
            }

            if (modeVirt.noAddEnd)
            {
                // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                // morceaux déjà notés
                var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
                _nbNoAdd = _nbNoAdd - nb2;
                if (_nbNoAdd < 0)
                    _nbNoAdd = 0;
            }
            _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

            return _nbNoAdd;
        }

        public void align(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        {
            var count = pieces.Count;
            if (count < 2)
                return;
            PieceExtended.Mode = main;
            pieces.Sort(new PieceCmp0());

            decimal prec = pieces[count - 1].Value;

            var coeffEnabled = modeVirt.CoeffOld;


            for (int j = count - 2; j >= 0; j--)
            {
                var cand = pieces[j].Value;
                bool change = false;
                if (cand == 0)
                    continue;
                if (modeVirt.virtAlignPrec)
                {
                    if (cand < prec)
                    {
                        cand = prec + EPSILON;
                        change = true;
                    }
                }

                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                {

                    // quel serait le score s'il était coché
                    var vu = pieces[j].Value / coeffEnabled;
                    // en plus une petite marge
                    //  vu *= mode.coeffVirt; 
                    if (cand < vu)
                    {
                        cand = vu;
                        change = true;
                    }
                }
                if (change)
                    pieces[j].Value = cand;

                prec = cand;
            }

        }

        //public void align0(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        //{
        //    var count = pieces.Count; 
        //    if (count < 2)
        //        return;
        //    pieces.Sort(new PieceCmp0()); 
        //    //if (main== PieceExtended.mode.main)
        //    //    pieces.Sort(new PieceCmp());
        //    //else if (main == PieceExtended.mode.min)
        //    //    pieces.Sort(new PieceCmp2());
        //    //else
        //    //    pieces.Sort(new PieceCmp3());
        //    decimal prec = 0m;

        //    var coeffEnabled = modeVirt.CoeffOld;

        //    if (modeVirt.virtAlignPrec)
        //    {
        //        //if (_nbNoAdd < pieces.Count)
        //            prec = pieces[_nbNoAdd].Value;
        //    }

        //    for (int j = _nbNoAdd - 1; j >= 0; j--)
        //    {
        //        if (j < pieces.Count)
        //        {

        //            if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
        //            {
        //                var cand = pieces[j].Value;
        //                if (modeVirt.virtAlignPrec)
        //                {
        //                    if (cand < prec)
        //                        cand = prec + EPSILON;
        //                }

        //                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
        //                {

        //                    // quel serait le score s'il était coché
        //                    var vu = pieces[j].Value / coeffEnabled;
        //                    // en plus une petite marge
        //                    //  vu *= mode.coeffVirt; 
        //                    if (cand < vu)
        //                        cand = vu;
        //                }
        //                pieces[j].Value = cand;

        //            }

        //            prec = pieces[j].Value;
        //        }
        //    }
        //}

        public void buildVirtual0(ConfMedianneVirt modeVirt, bool main)
        {
            var coeffEnabled = modeVirt.CoeffOld;

            var _coeffVirt = modeVirt.coeffVirt;
            var safe = modeVirt.safe;
            int i0 = 0;

            int count = pieces.Count;
            PieceClassementComparer cmp = null;
            PieceExtended.Mode = main ? PieceExtended.mode.main : PieceExtended.mode.min;

            if (coeffEnabled > 1)
            {
                for (int i = 0; i < count; i++)
                {
                    var p = pieces[i];

                    if (coeffEnabled != 1m && p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
                        p.setCoeff(coeffEnabled, main);
                }
            }

            cmp = new PieceClassementComparer(false, main ? PieceExtended.mode.main : PieceExtended.mode.min);
            pieces.Sort(cmp);

            int indexV = 0;
            int nbAdd = 0;
            var _zero = mode.zero;
            i0 = count - 1;


            //if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
            //{
            //    _nbNoAdd = pieces.Count(p => p.Enabled);
            //    if (_nbNoAdd > 0)
            //        _nbNoAdd--;
            //}
            //else if (modeVirt.noAddAll)
            //    _nbNoAdd = pieces.Count;
            //else
            //{
            //    for (int i = 0; i < count; i++)
            //    {
            //        var pp = pieces[i];
            //        if (pp.VirtualClassement == 0m)
            //        {
            //            i0 = i;
            //            _nbNoAdd = count - i0;
            //            break;
            //        }
            //    }
            //}

            //if (modeVirt.noAddEnd)
            //{
            //    // morceaux déjà notés
            //    var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
            //    _nbNoAdd = _nbNoAdd - nb2;
            //    if (_nbNoAdd < 0)
            //        _nbNoAdd = 0;
            //}

            int _count = System.Math.Min(count, i0 + safe);
            decimal[] virt = null; // = new decimal[_count];
            //_nbNoAdd = System.Math.Min(safe, _nbNoAdd);

            if (modeVirt.noAdd)
            {
                if (_coeffVirt > 1)
                {

                    if (count < safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;


                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < pieces.Count)
                        {

                            if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
                                _coeff *= _coeffVirt;
                            else if (modeVirt.forceCoeffVirt)
                                _coeff *= _coeffVirt;
                            if (pieces[j].Empty)
                                continue;
                            pieces[j].Value = pieces[j].Value / _coeff;
                            //pieces[j].EffectMain = coeffEnabled < _coeff;

                        }
                    }
                }

            }
            else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = pieces[i].Value;
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= _coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
            }
            else
            {
                if (_coeffVirt > 1)
                {
                    if (virt == null)
                        virt = new decimal[_count];
                    decimal courant = pieces[0].Value;
                    for (int i = 1; i < _count; i++)
                    {
                        if (pieces[i].Value <= _zero)
                        {
                            courant /= _coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = pieces[i].Value;
                    }
                }
            }

            decimal value = int.MaxValue;


            if (!modeVirt.noAdd)
            {
                int ii = 0;
                if (virt == null)
                    virt = new decimal[_count];
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = pieces[ii].Value;
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (modeVirt.lissage || value <= _zero)
                        {
                            if (value <= _zero)
                                nbAdd++;
                            value = calc;
                            pieces[ii].Value = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (modeVirt.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= safe)
                            continue;
                        pieces[i].Value = 0m;
                    }

                }
                if (mode.removeFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces[i].Value = 0m;
                    }
                }
            }



            if (mode.deleteFirst)
            {
                for (int i = 0; i < nbAdd; i++)
                {
                    pieces.RemoveAt(0);
                }
            }

        }

        public static int buildVirtual(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, bool main, bool combine, ref int i0)
        {
            var coeffEnabled = modeVirt.CoeffOld;

            var _coeffVirt = modeVirt.coeffVirt;
            var safe = modeVirt.safe;
            if (combine)
            {
                coeffEnabled = mode.Main.CoeffOld * mode.Min.CoeffOld;
                _coeffVirt = mode.Main.coeffVirt * mode.Min.coeffVirt;
                safe = (int)Math.Max(mode.Main.safe, mode.Min.safe);
            }


            //   var coeff = 1 / coeffEnabled; 
            int count = pieces.Count;
            PieceClassementComparer cmp = new PieceClassementComparer(false);
            pieces.Sort(cmp);
            //if (coeffEnabled != 1)
            //{
            if (coeffEnabled > 1)
            {
                for (int i = 0; i < count; i++)
                {
                    var p = pieces[i];
                    //  var rapportClassement = p.RapportClassement;
                    if (coeffEnabled != 1m && p.Enabled && (!modeVirt.oldAsZero || !p.LastClassementRecent))
                    {
                        p.setCoeff(coeffEnabled, main);
                        //rapportClassement /= coeffEnabled;
                    }

                    //p.setClassementVirtuel(rapportClassement);
                    //if (!main)
                    //    p.setClassementVirtuel2(rapportClassement);
                }
            }

            cmp = new PieceClassementComparer(false, main ? PieceExtended.mode.main : PieceExtended.mode.min);
            pieces.Sort(cmp);
            // }

            int indexV = 0;
            int nbAdd = 0;


            // List<Piece> _pieces = pieces;
            var _zero = mode.zero;


            //if (modeVirt.safe > 0)
            //{
            i0 = count - 1;
            int _nbNoAdd = 0;




            if (modeVirt.virtOnlyDisabled || mode.removeLast == removeLast.unselected)
            {
                _nbNoAdd = pieces.Count(p => p.Enabled);  // || p.VirtualClassement == 0m);
                if (_nbNoAdd > 0)
                    _nbNoAdd--;
            }
            else if (modeVirt.noAddAll)
                _nbNoAdd = pieces.Count;
            else
            {
                for (int i = 0; i < count; i++)
                {
                    var pp = pieces[i];
                    if (pp.VirtualClassement == 0m)
                    {
                        i0 = i;
                        _nbNoAdd = count - i0;
                        break;
                    }
                }
            }

            if (modeVirt.noAddEnd)
            {
                // var nb1 = pieces.Count<Piece>(p => p.Enabled);
                // morceaux déjà notés
                var nb2 = pieces.Count<PieceExtended>(p => !p.Enabled && p.RapportClassement > 0);
                _nbNoAdd = _nbNoAdd - nb2;
                if (_nbNoAdd < 0)
                    _nbNoAdd = 0;
            }
            //if (i0 == 0)
            //    return 0;
            //}

            //for (int i00 = 1; i00 <= i0; i00++)
            //{
            //    decimal coeff = (decimal)i00 / (decimal)i0;
            //List<decimal> _list = new List<decimal>();
            //for (int i = 0; i < pieces.Count; i++)
            //    _list.Add(pieces[i].getVirtual(main));
            //for (int i = i00; i < count; i++)
            //    _list[i] = 0m;
            //liste partielle originale
            //  List<decimal> _list0 = new List<decimal>(_list);
            int _count = System.Math.Min(count, i0 + safe);
            decimal[] virt = new decimal[_count];
            _nbNoAdd = System.Math.Min(safe, _nbNoAdd);

            if (modeVirt.noAdd)
            {
                if (_coeffVirt > 1)
                {
                    // var coeffEnabled = modeVirt.coeffOld; 

                    if (count < safe && modeVirt.coeffVirtAuto)
                    {
                        if (modeVirt.coeffVirtAdjust)
                            _coeffVirt = Math.Pow(coeffEnabled, 1.0m / (count + 1.0m));
                        else
                        {
                            // ex 2^10 = 1024
                            // je veux obtenir 1024 avec 3
                            _coeffVirt = Math.Pow(_coeffVirt, (decimal)safe / (decimal)count);
                        }
                    }

                    decimal _coeff = 1m;
                    decimal prec = 0m;
                    if (modeVirt.virtAlignPrec)
                    {
                        if (_nbNoAdd < pieces.Count)
                            prec = pieces[_nbNoAdd].Value;
                    }

                    for (int j = _nbNoAdd - 1; j >= 0; j--)
                    {
                        if (j < pieces.Count)
                        {

                            if (!modeVirt.virtOnlyDisabled || !pieces[j].Enabled)
                            {
                                _coeff *= _coeffVirt;
                                var cand = pieces[j].Value / _coeff;
                                if (modeVirt.virtAlignPrec)
                                {
                                    if (cand < prec)
                                        cand = prec + EPSILON;
                                }

                                if (modeVirt.virtAlignSelected && modeVirt.virtOnlyDisabled)
                                {
                                    // quel serait le score s'il était coché
                                    var vu = pieces[j].Value / coeffEnabled;
                                    // en plus une petite marge
                                    //  vu *= mode.coeffVirt; 
                                    if (cand < vu)
                                        cand = vu;
                                }
                                pieces[j].Value = cand;
                                // pieces[j].EffectMain = coeffEnabled < _coeff;
                            }
                            else if (modeVirt.forceCoeffVirt)
                                _coeff /= _coeffVirt;
                            prec = pieces[j].Value;
                        }
                    }
                }

            }
            else if (modeVirt.lissage || modeVirt.removeEpsilon || modeVirt.cumul)
            {
                if (_coeffVirt > 1)
                {
                    for (int i = 0; i < i0; i++)
                    {
                        decimal _coeff = 1m;
                        decimal _base = pieces[i].Value;
                        for (int j = i + 1; j < _count; j++)
                        {
                            _coeff /= _coeffVirt;
                            virt[j] = System.Math.Max(virt[j], _base * _coeff); //     += _base * _coeff;
                        }
                    }
                }
            }
            else
            {
                if (_coeffVirt > 1)
                {
                    decimal courant = pieces[0].Value;
                    for (int i = 1; i < _count; i++)
                    {
                        if (pieces[i].Value <= _zero)
                        {
                            courant /= _coeffVirt;
                            virt[i] = courant;
                        }
                        else
                            courant = pieces[i].Value;
                    }
                }
            }

            decimal value = int.MaxValue;
            int ii = 0;
            if (modeVirt.noAdd)
            {
                //for (ii = 1; ii < count && ii < _count; ii++)
                //{
                //    var calc = virt[ii];
                //    if (calc > 0m)
                //        list[ii] = calc;
                //}
            }
            else
            {
                for (ii = 1; ii < count && ii < _count; ii++)
                {
                    value = pieces[ii].Value;
                    var calc = virt[ii];
                    if (value < calc)
                    {
                        if (modeVirt.lissage || value <= _zero)
                        {
                            if (value <= _zero)
                                nbAdd++;
                            value = calc;
                            pieces[ii].Value = value;
                        }

                    }
                    else
                        indexV = ii;
                }
                if (modeVirt.removeEpsilon)
                {
                    // j'ai 5 virtuel alors que j'ai deux safe
                    ///xx---
                    int nb = 0;
                    for (int i = indexV + 1; i < _count; i++)
                    {
                        nb++;
                        if (nb <= safe)
                            continue;
                        pieces[i].Value = 0m;
                    }

                }
                if (mode.removeFirst)
                {
                    for (int i = 0; i < nbAdd; i++)
                    {
                        pieces[i].Value = 0m;
                    }
                }
            }

            //for (int i = 0; i < _list.Count && i < pieces.Count; i++)
            //{
            //    pieces[i].setValue(_list[i], main); 
            //    //if (main)
            //    //    pieces[i].setClassementVirtuel(_list[i]);
            //    //else
            //    //    pieces[i].setClassementVirtuel2(_list[i]);
            //}

            if (mode.deleteFirst)
            {
                for (int i = 0; i < nbAdd; i++)
                {
                    pieces.RemoveAt(0);
                }
            }

            if (modeVirt.reSort || mode.removeFirst || modeVirt.noAdd)
            {
                //_list.Sort();
                //_list.Reverse();
                if (main)
                    pieces.Sort(new PieceCmp());
                else
                    pieces.Sort(new PieceCmp2());
            }



            if (modeVirt.noAdd)
                nbAdd = _nbNoAdd;
            //}
            return nbAdd;
        }


        public DecimalPiece getMedianneLight(ConfMedianneVirt modeVirt, PieceExtended.mode main)
        {

            DecimalPiece ret0 = new DecimalPiece();
            DecimalPiece ret = ret0;
            try
            {
                var _zero = mode.zero;

                PieceExtended.Mode = main;
                //foreach (PieceExtended p in pieces)
                //    p.Mode = main;

                var medianne = getMedianne_(pieces, mode.medianne);
                ret0.d = medianne;
                ret0.index = median;
                ret = ret0;


                int i0 = 0;
                int count = pieces.Count;


                ret = calcmedianneVirt(modeVirt);
                if (mode.expEnabled != 0)
                {
                    int _nb = pieces.Count<PieceExtended>(p => !p.Enabled);
                    decimal _c = (decimal)_nb / (decimal)count;
                    _c = Math.Pow(_c, mode.expEnabled);
                    ret.d *= _c;
                }




            }
            finally
            {


            }

            return ret;
        }






        //public static DecimalIndex getMedianneLight(List<PieceExtended> pieces, ConfMedianne mode, ConfMedianneVirt modeVirt, PieceExtended.mode main, bool combine)
        //{

        //    DecimalIndex ret0 = new DecimalIndex();
        //    DecimalIndex ret = ret0;
        //    try
        //    {
        //        var _zero = mode.zero;


        //        foreach (PieceExtended p in pieces)
        //            p.Mode = main;

        //        var medianne = getMedianne_(pieces, mode.medianne);
        //        ret0.d = medianne;
        //        ret0.index = index;
        //        ret = ret0;
        //        //if (pieces.Count == 1)
        //        //    return ret0;

        //        int i0 = 0;
        //        int count = pieces.Count;
        //        int nbAdd = buildVirtual(pieces, mode, modeVirt, main, combine, ref i0);
        //        //if (mode.combine && mode.simple)
        //        //{
        //        //    int i1 = 0;
        //        //    buildVirtual(pieces, mode, mode.Min, false, ref i1);
        //        //    foreach (var p in pieces)
        //        //    {
        //        //        p.setClassementVirtuelCombine();
        //        //    }
        //        //}
        //        ret = calcmedianneVirt(pieces, mode, modeVirt, main, nbAdd, System.Math.Min(i0, modeVirt.safe));
        //        if (mode.expEnabled != 0)
        //        {
        //            int _nb = pieces.Count<PieceExtended>(p => !p.Enabled);
        //            decimal _c = (decimal)_nb / (decimal)count;
        //            _c = Math.Pow(_c, mode.expEnabled);
        //            ret.d *= _c;
        //        }




        //    }
        //    finally
        //    {


        //    }

        //    return ret;
        //}

        private class PieceCmp0 : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.Piece.RapportClassement.CompareTo(y.Piece.RapportClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }


        private class PieceCmp : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.VirtualClassement.CompareTo(y.VirtualClassement);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }

        private class PieceCmp2 : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }

        private class PieceCmp3 : IComparer<PieceExtended>
        {
            private static PieceTrackNumberComparerE tn = new PieceTrackNumberComparerE();
            public int Compare(PieceExtended x, PieceExtended y)
            {
                int cmp = x.VirtualClassement2.CompareTo(y.VirtualClassement2);
                if (cmp != 0)
                    return -cmp;
                return tn.Compare(x, y);
            }
        }




        //private static DecimalIndex calcmedianneVirt(IList<decimal> list, ConfMedianne conf, int nbAdd, int nbDel)
        //{
        //    var _list = new List<decimal>(list);
        //    int count = _list.Count;

        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        if (_list[count - i - 1] > conf.zero)
        //        {

        //            if (conf.removeLast == removeLast.non)
        //                break;
        //            _nbSupp++;
        //            if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                break;
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}


        private DecimalPiece calcmedianneVirt(ConfMedianneVirt confc)
        {
            var _list = new List<PieceExtended>(pieces);
            var classes = _list.FindAll(p => p.VirtualClassement > mode.zero);

            if (confc.oldAsZero)
                classes = _list.FindAll(p => p.LastClassementRecent);

            int count = _list.Count;

            int nbEnabled = classes.Count<PieceExtended>(p => p.Enabled);
            int nbDisabled = classes.Count<PieceExtended>(p => !p.Enabled);
            int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


            DecimalPiece ret = new DecimalPiece() { d = 0m, index = null }; // 0m; // decimal ret = int.MinValue;
            if (pieces.Count > 0)
                ret.index = pieces[0];
            int _nbSupp = 0;

            bool beginBorder = false;
            for (int i = 0; i < count; i++)
            {
                if (i > 0)
                    _list.RemoveAt(count - i);

                var aux = getMedianne_(_list, mode.medianne);
                if (aux == 0m)
                    continue;
                if (!beginBorder)
                {
                    beginBorder = true;
                    ret.indexBorder = pieces[count - i - 1];
                }

                decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;

                if (mode.quasi)
                    coeff *= coeff;
                aux = aux * coeff;
                if (aux > ret.d)
                {
                    ret.d = aux;
                    ret.index = median;
                    ret.indexBorderEffect = pieces[count - i - 1];
                }

                ret.indexBorderMin = pieces[count - i - 1];
                var p = _list[count - i - 1];

                if (p.VirtualClassement > mode.zero && (!confc.oldAsZero || p.LastClassementRecent))
                {
                    // je regarde si le morceau est désactivé
                    // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
                    if (p.Enabled)
                        nbEnabled--;
                    else
                        nbDisabled--;
                    nbdispo--;

                    if (!p.Enabled || !mode.removeEnabled || mode.removeLast == removeLast.unselected)
                    {
                        //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
                        //if (priseEncompte)
                        //{
                        if ((mode.removeLast == removeLast.non || mode.removeLast == removeLast.unselected) && nbEnabled < 0)
                            break;

                        if (mode.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
                        {
                            if (nbdispo < 0)
                                break;
                        }
                        _nbSupp++;
                    }
                }


            }


            return ret;
        }

        //private static DecimalIndex calcmedianneVirt(IList<PieceExtended> list, ConfMedianne conf, ConfMedianneVirt confc, bool main, int nbAdd, int nbDel)
        //{
        //    var _list = new List<PieceExtended>(list);
        //    var classes = _list.FindAll(p => p.VirtualClassement > conf.zero);

        //    if (confc.oldAsZero)
        //        classes = _list.FindAll(p => p.LastClassementRecent);

        //    int count = _list.Count;

        //    int nbEnabled = classes.Count<PieceExtended>(p => p.Enabled);
        //    int nbDisabled = classes.Count<PieceExtended>(p => !p.Enabled);
        //    int nbdispo = System.Math.Min(nbEnabled, nbDisabled);


        //    DecimalIndex ret = new DecimalIndex() { d = 0m, index = 0 }; // 0m; // decimal ret = int.MinValue;
        //    int _nbSupp = 0;
        //    //int _nbSuppDisabled = 0;
        //    //int _nbSuppEnabled = 0;
        //    bool beginBorder = false;
        //    for (int i = 0; i < count; i++)
        //    {

        //        if (i > 0)
        //        {
        //            //var d = _list[count - i];
        //            //if (d.Enabled)
        //            //    nbEnabled--;
        //            //else
        //            //    nbDisabled--;

        //            _list.RemoveAt(count - i);

        //        }

        //        var aux = getMedianne_(_list, conf.medianne);
        //        if (aux == 0m)
        //            continue;
        //        if (!beginBorder)
        //        {
        //            beginBorder = true;
        //            ret.indexBorder = count - i - 1;
        //        }
        //        // aux = getLn(aux);
        //        //decimal coeff = 1; 
        //        //if (count >2)
        //        //coeff = (decimal)(count - 2 - i) / (decimal)(count - 2); 
        //        decimal coeff = 1 - (decimal)i / (decimal)count; // (decimal)count - i / (decimal)count;
        //        if (conf.removeFirst && !conf.deleteFirst && i > nbDel)
        //        {
        //            coeff = 1 - (decimal)(i - nbDel) / (decimal)count;
        //        }
        //        if (conf.quasi)
        //            coeff *= coeff;
        //        aux = aux * coeff;
        //        if (aux > ret.d)
        //        {
        //            ret.d = aux;
        //            ret.index = index;
        //            ret.indexBorderEffect = count - i - 1;
        //        }

        //        ret.indexBorderMin = count - i - 1;
        //        var p = _list[count - i - 1];

        //        if (p.VirtualClassement > conf.zero && (!confc.oldAsZero || p.LastClassementRecent))
        //        {
        //            // je regarde si le morceau est désactivé
        //            // si c'est coché, je ne regarde pas quand je considère qu'on peut supprimmer les morceaux activé
        //            if (p.Enabled)
        //                nbEnabled--;
        //            else
        //                nbDisabled--;
        //            nbdispo--;

        //            if (!p.Enabled || !conf.removeEnabled || conf.removeLast == removeLast.unselected)
        //            {
        //                //bool priseEncompte = true || nbEnabled <= 0 || !conf.removeEnabled || conf.removeLast == removeLast.unselected;
        //                //if (priseEncompte)
        //                //{
        //                if ((conf.removeLast == removeLast.non || conf.removeLast == removeLast.unselected) && nbEnabled < 0)
        //                    break;

        //                if (conf.removeLast == removeLast.unselected) //&& (nbEnabled <= 0 ||  nbDisabled <=0))
        //                {
        //                    if (nbdispo < 0)
        //                        break;
        //                }

        //                _nbSupp++;
        //                if (conf.removeLast == removeLast.virtuel && _nbSupp >= nbAdd)
        //                    break;
        //                // }


        //            }
        //        }


        //    }

        //    //     if (ret == int.MinValue)
        //    //         return 0m;
        //    return ret;
        //}



        //private static decimal getMedianne_(IList<PieceExtended> list, bool main, decimal coeffMedianne)
        //{
        //    var l = new List<decimal>();
        //    foreach (PieceExtended p in list)
        //    {
        //        if (main)
        //            l.Add(p.VirtualClassement); 
        //        else
        //            l.Add(p.VirtualClassement2); 
        //    }

        //    return CalcMedianne.getMedianneDec(l, coeffMedianne); 
        //}

        private static decimal getMedianne_(IList<Piece> list, bool main, decimal coeffMedianne)
        {
            var l = new List<decimal>();
            foreach (Piece p in list)
            {
                if (main)
                    l.Add(p.VirtualClassement);
                else
                    l.Add(p.VirtualClassement2);
            }

            return CalcMedianne.getMedianneDec(l, coeffMedianne);
        }


        private static decimal getMedianne_(IList<PieceExtended> list, decimal coeffMedianne)
        {

            if (list == null)
                throw new ArgumentException("liste nulle");
            int count = list.Count;
            if (count == 0)
                throw new ArgumentException("liste vide");
            if (coeffMedianne < 0 || coeffMedianne > 1)
                throw new ArgumentException("coeffMedianne doit être compris entre 0 et 1, valeur:" + coeffMedianne);
            if (count == 1 || coeffMedianne == 1)
            {
                median = list[0];
                return median.Value;
            }

            if (coeffMedianne == 1)
            {
                median = list[count - 1];
                return median.Value;
            }

            var medianne = coeffMedianne * (count - 1);

            var index = (int)medianne;
            int i1 = index + 1;
            var val0 = list[index].Value;
            var val1 = list[i1].Value;
            median = list[index];
            if (Math.Abs(medianne - Convert.ToDecimal(index)) < PRECISION)
            {
                return val0;
            }
            if (Math.Abs(medianne - i1) < PRECISION)
            {
                median = list[i1];
                return val1;
            }
            if (val1 < PRECISION)
            {
                median = list[i1];
                return val1;
            }
            var dx = medianne - index;


            // var ret = val0 + pente * dx;


            // moyenne avec calcul de log
            var log0 = Math.Log(val0 + EPSILON_LOG);
            var log1 = Math.Log(val1 + EPSILON_LOG);
            // pente = log1 - log0;
            var log = log0 + (log1 - log0) * dx;
            return Math.Exp(log) - EPSILON_LOG;


        }

    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\auto\MedianneDriver.cs">
    <content><![CDATA[using pdb.gen.medianne;
using pdb.gen.Tuning;

namespace pdb.gen.auto
{
    public static class MedianneDriver
    {
        /// <summary>
        /// Fait au besoin l'ajusement des paramètres de façon automatique
        /// </summary>
        /// <param name="conf"></param>
        /// <param name="p"></param>
        /// <returns>ok si les paramètres ont été modifiés</returns>
        public static bool auto(ConfAlbumSort conf, Piece p)
        {
            try
            {
                if (conf.checkStack && p.PieceAlbum != null && p.PieceAlbum.Empeached)
                    return false;
                if (p.Added > conf.newA)
                    return false;
                var motif = p.SelectedMotif;
                if (p.SelectedMotif == selectedCoeff.none)
                    return false;
                bool ret = false; 
                foreach (var cmp in conf.Composants)
                {
                   ret  = ret | auto(cmp, motif);                    
                }

                return ret; 
            }
            finally
            {
                foreach (Piece pp in p.Master)
                {
                    pp.Empeached = false;
                    pp.Empeached1 = false;
                }
            }
        }


        private static bool auto(ConfMedianne conf, selectedCoeff motif)
        {
            if (!conf.enabled)
                return false;
            if (motif == selectedCoeff.none)
                return false;
            var coeffPrisEncompte = motif > selectedCoeff.noCoeff;
            var _min = conf.Min;
            var _main = conf.Main; 
            if (_min == _main || (_min.coeffVirt == 1m && !_min.coeffOldSwap))
            {
                _main.calcAuto(coeffPrisEncompte);
            }
            else
            {
                _main.calcAuto(motif == selectedCoeff.main);
                _min.calcAuto(motif == selectedCoeff.min); 
                //if (coeffPrisEncompte)
                //{
                //    if (motif == selectedCoeff.main)
                //        _main.calcAuto(true);
                //    if (motif == selectedCoeff.min)
                //        _min.calcAuto(true);
                //}
                //else
                //{
                //    _main.calcAuto(false);
                //    _min.calcAuto(false);
                //}
            }

            return true; 

        }
    }
}
]]></content>
  </file>
</db>
