<db path="C:\bernard\db1\db4">
  <file path="\pdb.player\App.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using pdb.db;
using pdb.db.piece.data;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.ordo;
using pdb.player.ViewModel;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.player.ViewModel.gen;
using pdb.player.Vue;
using pdb.util;
using pdb.db.obj;
using pdb.gen.albums;
using System.Linq;
using System.Linq.Expressions;
using System.Windows.Input;

namespace pdb.player
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application, IIhm
    {
        public static Logger log = Logger.getLogger("Program");
        public static Logger logPerf = Logger.getLogger("Perf");
        public static CDb Db;
        public static Consolid gen;
        //  public static LegacyApp app;
        // internal static HomeLoader loader;
        internal static BibViewModel bib;
        static int step = -5;
        public const string PHASE1 = "PHASE1";
        public const string PHASE2 = "PHASE2";

        private static Export export;
        private static Import import;
        public const DispatcherPriority DISPATCHER_PRIORITY = DispatcherPriority.Background;


        private static Thread thLoop;
        private static bool __go;
        private static bool __end;
        private static volatile object _lock = new object();
        private static ListWriter listWriter;
        private static App _instance;
        public static App Instance { get { return _instance; } }
        private static DetailClassementViewModel detailClassementViewModel;
        internal static DetailClassementViewModel DetailClassementViewModel { set { detailClassementViewModel = value; } }

        public App()
            : base()
        {
            var xmlConf = CConf.loadConf();
            pdb.player.ViewModel.Colors.MementoColor.recover();
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
            this.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(App_DispatcherUnhandledException);
            Application.Current.DispatcherUnhandledException += new DispatcherUnhandledExceptionEventHandler(Current_DispatcherUnhandledException);
            TaskScheduler.UnobservedTaskException += new EventHandler<UnobservedTaskExceptionEventArgs>(TaskScheduler_UnobservedTaskException);
            _instance = this;
        }

        void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            e.SetObserved();
            CheckException("Task", sender, e.Exception);
        }

        void Current_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("AppDispatcher", sender, e.Exception);
        }

        void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            e.Handled = true;
            CheckException("Dispatcher", sender, e.Exception);
        }

        void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            CheckException("Domain", sender, e.ExceptionObject);
        }

        private bool displayMsg;
        private void CheckException(string from, object sender, object ex)
        {
            string message = string.Format("Erreur:\r\n from->{0}\r\nsender ->{1}\r\n{2}", from, sender, ex.ToString());  // "Erreur->sender:" + sender +" from:" + from + " " + ex.ToString();
            if (log != null)
                log.log(message);
            var msgBox = message;
            if (msgBox.Length > 2000)
                msgBox = msgBox.Substring(0, 1998);
            if (!displayMsg)
            {
                displayMsg = true;
                var result = MessageBox.Show(msgBox, "Erreur", MessageBoxButton.OK, MessageBoxImage.Error);
                displayMsg = false;
            }

        }
        private static bool changing;
        public static void setChanging() { changing = true; }
        public static void releaseChanging() { changing = false; }
        public static void invalidateAlbums()
        {
            if (gen == null)
                return;

            gen.invalidateAlbums();
            if (changing)
                return;
            go();
        }
        [STAThread]
        protected override void OnStartup(StartupEventArgs e)
        {
            try
            {
                var xmlConf = CConf.loadConf();

                base.OnStartup(e);
                Thread.CurrentThread.Name = "GUI";

                //   app = new LegacyApp(); 
                Logger.init(Environment.CurrentDirectory.Replace("\\", "_"));
                log = Logger.getLogger("Program");
                misc.init(log);

                //  IPlayerEngine player = PlayerBuilder.create("vlcplugin");



                Piece.Compact = CConf.Compact;
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                export = CConf.Export;
                import = CConf.Import;

                gen = new Consolid();
                gen.FilterNext = CConf.FilterNext;
                var mementoAlbum = Memento.Instance.confAlbum;
                if (mementoAlbum != null && mementoAlbum.Composants.Count > 0)
                    gen.SortAlbumMode = mementoAlbum;
                else
                    gen.SortAlbumMode = CConf.ConfGen.AlbumSort;
                Memento.Instance.confAlbum = gen.SortAlbumMode;
                CConf.ConfGen.AlbumSort = gen.SortAlbumMode;

                Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
                Piece.SeuilCompact = gen.SortAlbumMode.compact;

                BackGroundTaskMgr.Conf = CConf.ConfOrdo;
                BackGroundTaskMgr.Start();
                DataConf dbConf = new DataConf(xmlConf);
                CFile.DefaultFolder = dbConf.defaultFolder;
                ZipUtil.Exe = dbConf.sZip;
                Db = new CDb(dbConf);

                //  loader = new HomeLoader(Db);
                //  app.init(loader);
                Db.SovIni();
                Db.loadData();

                if (dbConf.compressID || dbConf.synchroID)
                {
                    Environment.Exit(0);
                }

                //ChronoData.refreshDate(DateTime.MinValue);
                //ChronoData.DateAuto = false;
                //Db.eraseClassementForEnabled();
                //Db.WriteDB1(); 
                //return;
                // app.loadData(Db, CConf.Scan);

                // Db.LegacyConsolid(app.LegacyList, DateTime.Now);




                goInit();

                //  Memento.Instance.save();
                thLoop = new Thread(loop);
                thLoop.Start();

                MemUtil.Start(CConf.GcCollect);
                //  go();
            }
            catch (Exception ex)
            {
                if (log != null)
                    log.log(ex.ToString());
            }



        }



        private static void loop()
        {
            Thread.CurrentThread.Name = "App";
            while (!__end)
            {
                Thread.Sleep(30);
                if (!__go)
                    continue;
                lock (_lock)
                {
                    if (!__go)
                        continue;
                    __go = false;
                }
                _go();

            }

        }
        private static bool _updateStats;
        private static TrackListViewModel _currentTrack;
        public static void go()
        {
            go(false);
        }
        public static void go(bool updateStats)
        {
            lock (_lock)
            {
                _updateStats |= updateStats;
                __go = true;
                if (bib != null)
                    bib.Aborted = true;
            }
        }

        public static void go(TrackListViewModel current)
        {
            lock (_lock)
            {
                _currentTrack = current;
                go(true);
            }
        }

        private static void resetOneCl()
        {
            lock (_lock)
            {
                try
                {
                    if (CConf.ResetOneCl)
                    {

                        // CPieceClassement.DateMin = DateTime.MinValue;
                        //   Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;
                        var oldKepp = new List<Piece>();

                        var _albums = gen.Albums;
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            foreach (Piece t in l)
                            {
                                if (t.Keep)
                                {
                                    t.setKeep(0); //t.Keep = false;
                                    oldKepp.Add(t);
                                    //t.resetMedianneCompact();
                                    //t.invalidateCache(true); 
                                }
                            }
                        }
                        foreach (var album in _albums.List)
                        {
                            var l = album.Tracks;
                            Classement pluspetitNonNull = null;
                            Piece min = null;
                            int nbnotes = 0;
                            foreach (Piece t in l)
                            {
                                //si on a au moins un noté on quitte

                                //var p = t.Track as CPiece;


                                var cl = t.DeepClassement; // p.Classement.DbValue;
                                // decimal clValue = obj.Classement.create(cl.ToString()).ClassementValueDecimal; //  Piece.classementHash.getCache(cl.ToString()).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                                if (cl.isPositive())// > zer0d)
                                {
                                    nbnotes++;
                                    if (t.LastClassementRecent || !t.Enabled)
                                    {
                                        min = null;
                                        break;
                                    }
                                    if (pluspetitNonNull == null || cl < pluspetitNonNull)
                                    {
                                        pluspetitNonNull = cl;
                                        min = t;
                                    }
                                }

                            }

                            if (min != null)
                            {
                                var coeff = (decimal)nbnotes / l.Count;
                                coeff *= coeff;
                                min.setKeep(coeff);
                            }
                        }

                        foreach (Piece t in oldKepp)
                        {

                            if (!t.Keep)
                            {
                                t.resetMedianneCompact();
                                t.invalidateCache(true);
                            }
                        }


                    }
                }
                finally
                {
                    //  CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
                }
            }
        }



        private static void goInit()
        {
            var client = new SimpleClient("goInit\t", logPerf);
            var root = gen.Root;

            ChronoData.DateAuto = false;
            DateTime now = DateTime.Now;
            gen.Now = now;
            gen.Step = -1;




            if (CConf.ResetOneCl)
            {
                gen.ConsolidInit(Db.List.getList());
                client.log(" gen.ConsolidInit(Db.List.getList());");
                resetOneCl();
                client.log("resetOneCl");
                //CPieceClassement.DateMin = DateTime.MinValue;
                ////Classement min = Classement.create("00003.0"); decimal mind = min.ClassementValueDecimal;
                //Classement zero = Classement.create("0.0"); decimal zer0d = zero.ClassementValueDecimal;

                ////foreach (Piece p in gen.sortByClass())
                ////{
                ////    decimal clValue = p.ClassementValueDecimal(false) ;
                ////    if (clValue > zer0d)
                ////    {
                ////        if (clValue >= zer0d)
                ////        {
                ////            var dPiece = Db.getPiece(p.PieceId);
                ////            var strNewCl = "0000" + dPiece.getClassement().ToString();
                ////            var newCl = Classement.create(strNewCl);
                ////            p.Enabled = true;

                ////            p.setClassement(newCl.ClassList, newCl.Rating);
                ////            dPiece.Classement.eraseClassement2(newCl);
                ////        }
                ////        else
                ////            p.Enabled = false;
                ////    }
                ////}

                //var _albums = gen.Albums;
                //foreach (var album in _albums.List)
                //{
                //    var l = album.Tracks;
                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in l)
                //    {
                //        decimal clValue = t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        (min.Track as CPiece).Classement.keepValue();
                //    }
                //}
                ////    foreach (Piece t in l)
                ////    {
                ////        if (t.Parent == null)
                ////        {
                ////            decimal clValue = t.ClassementValueDecimal(false);
                ////            if (t.isClassListNumeric && clValue > zer0d)
                ////            {
                ////                if (clValue > pluspetitNonNull)
                ////                {
                ////                    var dPiece = Db.getPiece(t.PieceId);
                ////                    t.Enabled = true;
                ////                    t.setClassement("0", 0);
                ////                    dPiece.Classement.eraseClassement2();
                ////                }
                ////            }
                ////        }
                ////    }
                ////}

                ////gen.MakeConsolid(Db.List.getList(), true);
                CPieceClassement.DateMin = CConf.ConfGen.MinClassDate;
            }

            gen.MakeConsolid(null, true, true, client);
            //  if (CConf.ConfGen.LimitList <= 0)
            gen.buildMusique();
            // gen.buildClassTree();
            gen.buildLists(Db.List.Listes);

            bib = new BibViewModel(root);
            client.log("creation bib");
            ChronoData.DateAuto = true;
            //  var classement = root.getOrCreate("classement");



            ListWriterMgr.Async = false;
            listWriter = new ListWriter(bib);
            //   gen.createRot(CConf.ListBase, listWriter); 
            //bib = new BibViewModel(Db.Root); 
            //gen.createRot(CConf.ListBase, bib);
            //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();


            //  gen.timeRanking();
            // gen.eraseGrouping();
            // gen.writeComment();
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;
            gen.createRot(CConf.ListBase, client, listWriter);
            PlayListViewModel.Log = true;
            //   gen.builStats();
            //gen.CommentGo = true;
            //gen.GroupinGO = true;
            //  PlayerViewModel.Instance.SortAlbumMode = gen.SortAlbumMode;
            PlayerViewModel.Instance.WithVirtualAlbum = gen.AlbumVirtual;
            PlayerViewModel.ConfAlbumSort = gen.SortAlbumMode;
            Memento.Instance.confAlbum = gen.SortAlbumMode;
            Piece.SeuilProvisoire = gen.SortAlbumMode.lastModif;


            //foreach (CPiece p in Db.List)
            //{
            //    if (p.DurationInSec == 0 && p.Exists)
            //    {
            //        try
            //        {
            //            PlayerViewModel.Instance.Player.getDuration(p);
            //            log.log("{0} duration {1} s", p, p.DurationInSec);
            //        }
            //        catch (Exception ex)
            //        {
            //            log.log(ex.ToString());
            //        }

            //    }
            //}


            // detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
            // new Thread(() =>
            gen.builStats(null);
            client.log("Fin goInit");
        }

        private static bool mustBuildCompleteAlbums(TrackListViewModel currentTrack)
        {
            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.RankAlbumReverse.CompareTo(y.RankAlbumReverse));
            int count = tracks.Count;
            int rank0 = currentTrack.RankAlbumReverse;

            int i = 0;
            // recherche trou avant ex rank0=3 pas de 1 ni de 2
            for (; i < count; i++)
            {
                var t = tracks[i];
                if (t.RankAlbumReverse >= rank0)
                    break;

                if (t.RankAlbumReverse > i + 1)
                    return true;
            }

            if (i + 1 < count && tracks[i + 1].RankAlbumReverse > rank0 + 1)
            {
                return true;
            }

            return false;
        }

        private static void buildAffectedAlbumsWhenCurrentTrackChange(TrackListViewModel currentTrack, IDictionary<string, Album> dict, HashSet<Album> depot)
        {
            if (currentTrack == null)
                return;
            TrackListViewModel item = currentTrack;
            var cl = item.PieceGen.getClassement(true);
            var _dict = dict;  // new Dictionary<string,Album>(); 

            //foreach (Album album in dict.Values)
            //{
            //    var current = album.PlusPetitEnabled; 
            //    if (current == null || cl<=current.getClassement(true))
            //        _dict.Add(album.Key, album); 
            //}

            var tracks = new List<TrackListViewModel>();
            foreach (TrackListViewModel t in PlayerViewModel.Instance.PresentationTracks)
            {
                tracks.Add(t);
            }
            tracks.Sort((x, y) => x.Index.CompareTo(y.Index));
            int count = tracks.Count;

            int index = -1;
            for (int i = 0; i < count; i++)
            {
                var t = tracks[i];
                if (t.PieceId == currentTrack.PieceId)
                {
                    index = i;
                    break;
                }
            }

            if (index < 0)
            {
                foreach (Album a in dict.Values)
                    depot.Add(a);
                return;
            }

            var hs = new HashSet<int>();
            hs.Add(item.MasterId);
            try
            {
                while (true)
                {
                    index++;
                    if (index >= count)
                        return;

                    var t = tracks[index];
                    if (!hs.Add(t.MasterId))
                        continue;
                    if (t.album == item.album)
                        continue;

                    if (_dict.ContainsKey(t.album.Key))
                    {
                        depot.Add(t.album);
                        if (depot.Count >= _dict.Count)
                            return;
                    }

                }
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
            finally
            {

            }
        }

        private void automateNextTrack()
        {
            if (!CheckAccess())
                Dispatcher.BeginInvoke(new Action(this.automateNextTrack), App.DISPATCHER_PRIORITY);
            else
            {
                ICommand forward = PlayerViewModel.Instance.Forward;
                if (forward.CanExecute(this))
                {
                    forward.Execute(this);
                }


            }
        }

        static int nbGo = 0;
        static bool classementChange;
        private static void _go()
        {
            nbGo++;
            bool urgence = false;
            var client = new SimpleClient("<--- chrono " + nbGo + "\t", logPerf);

            try
            {

                bool reInit = !gen.AlbumBuild;
                var confSort = PlayerViewModel.ConfAlbumSort;
                if (confSort != null)
                {
                    Piece.SeuilProvisoire = confSort.lastModif;
                    CConf.ConfGen.AlbumSort = confSort;
                }
                //   gen.compact(); 
                if (detailClassementViewModel != null)
                    detailClassementViewModel.IhmInDispo = ihmInDispo.rot;
                //gen.CommentGo = false;
                //gen.GroupinGO = false;
                bib.Aborted = true;
                Db.saveAsync();
                step++;
                gen.Step = step;

                ChronoData.DateAuto = false;
                DateTime now = DateTime.Now;
                gen.Now = now;
                ChronoData.DateAuto = false;
                bool classementChange = App.classementChange;
                urgence = gen.Urgence
                    && TrackListViewModel.CurrentPlaying == _currentTrack;
                if (!urgence)
                    Memento.Instance.save();
                client.log(string.Format("debut classementChange={0} gen.ClassementChanged={1} gen.Urgence={2} _currentTrack={3}", classementChange, gen.ClassementChanged, gen.Urgence, _currentTrack));
                if (PlayerViewModel.Instance.CreateRot)
                {

                    if (gen.ClassementChanged)
                    {
                        classementChange = true;
                        App.classementChange = true;
                    }

                    if (!urgence && classementChange)
                    {
                        resetOneCl();
                        client.log("resetOneCl");
                        App.classementChange = false;
                    }

                    if (_currentTrack != null)
                    {
                        int nbAlbums = 0;
                        bool sortDone = false;
                        if (urgence)
                        {
                            var affectedAlbums = gen.Albums.GetAndInvalidateAlbums(_currentTrack.PieceGen);
                            bool mustComplete = mustBuildCompleteAlbums(_currentTrack);

                            if (!mustComplete)
                            {

                                //}

                                //var depot = new HashSet<Album>();
                                //buildAffectedAlbumsWhenCurrentTrackChange(_currentTrack, affectedAlbums, depot);
                                //if (depot.Count == 0)
                                //{
                                //if ( _currentTrack == TrackListViewModel.CurrentPlaying) //_currentTrack.RankAlbumReverse == 1 
                                //{
                                log.log("pas de makeSort. on passe au suivant on verra après");
                                _currentTrack = null;
                                gen.Urgence = false;

                                App.Instance.automateNextTrack();
                                return;
                                //}
                                //}
                                //else
                                //{
                                //    log.log("depot:");
                                //    nbAlbums = gen.Albums.makeSort(depot, log);
                                //    sortDone = true;
                                //}

                            }
                            else
                            {
                                log.log("y a des trous dans la raquette on force le makesort");
                                gen.Urgence = false;
                            }
                            if (!sortDone)
                            {
                                log.log("affected albums");
                                nbAlbums = gen.Albums.makeSort(_currentTrack.PieceGen, log);
                            }
                            client.log(string.Format("makeSort partial {0} elt", nbAlbums));
                            _currentTrack.refresh();
                            if (refreshAlbum != null)
                                refreshAlbum("", EventArgs.Empty);
                            client.log("refreshAlbum");
                        }
                    }

                    _currentTrack = null;


                    // if (__end || __go) return;


                    //  gen.SortAlbumMode = PlayerViewModel.Instance.SortAlbumMode;
                    //    gen.AlbumVirtual = PlayerViewModel.Instance.WithVirtualAlbum; 


                    gen.MakeConsolid(null, _updateStats, classementChange, client); //   bib.Musique.Tracks);
                    if (reInit)
                        gen.buildMusiqueAgain();
                    //  if (__end || __go) return;
                    // AlbumCtl.Instance.init();
                    //   if (__end || __go) return;
                    //gen.timeRanking();
                    //  if (__end || __go) return;
                    ChronoData.DateAuto = true;

                    //bool navAuto = PlayerViewModel.Instance.NavAuto; 
                    //if (navAuto)
                    //{
                    //    if (refresh != null)
                    //        refresh(PHASE1, EventArgs.Empty);
                    //}



                    //      if (__end || __go) return;
                    bib.Aborted = false;
                    ListWriterMgr.Async = false;
                    //listWriter = new ListWriter(root);
                    try
                    {
                        CConf.loadConf();
                    }
                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                    // gen.SortByAlbum = PlayerViewModel.Instance.SortByAlbum;
                    gen.createRot(CConf.ListBase, client, App.bib);
                    if (reInit)
                        bib.syncMusique();
                    //if (refresh != null)
                    //    refresh(PHASE1, EventArgs.Empty);


                    //log.log("visibles"); 
                    //foreach (TrackListViewModel visible in Player.VisibleItems)
                    //{
                    //    if (__end || __go) return;
                    //    visible.PieceGen.writeCommentGrouping();
                    //    visible.refresh(); 
                    //}
                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);

                    //if (__end || __go) return;
                    //gen.writeComment();
                    //if (__end || __go) return;
                    //gen.writeGrouping();


                    if (refresh != null)
                        refresh(PHASE2, EventArgs.Empty);
                    client.log("refresh après createRot");


                    //if (__end || __go) return;

                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;



                    //if (refresh != null)
                    //    refresh(PHASE2, EventArgs.Empty);
                    // _refresh = true;
                    lock (_lock)
                    {
                        if (_updateStats)
                        {
                            if (detailClassementViewModel != null)
                                detailClassementViewModel.IhmInDispo = ihmInDispo.stat;
                            //new Thread(() =>
                            gen.builStats(() => { if (detailClassementViewModel != null) detailClassementViewModel.IhmInDispo = ihmInDispo.none; });

                        }
                        else
                            if (detailClassementViewModel != null)
                            detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                    }
                    //bib = new BibViewModel(Db.Root); 
                    //gen.createRot(CConf.ListBase, bib);
                    //   if (bgClass.IsEnd) BackGroundTaskMgr.Start();
                    //gen.CommentGo = true;
                    //gen.GroupinGO = true;


                }


            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }

            finally
            {
                //   gen.eraseGrouping(); 
                //if (refresh != null && PlayerViewModel.Instance.CreateRot)
                //    refresh(PHASE2, EventArgs.Empty);

                // detailClassementViewModel.IhmInDispo = ihmInDispo.none;
                lock (_lock)
                {
                    ExportCmd.CalculExport();
                    if (_updateStats)
                    {
                        _updateStats = false;
                    }
                }

                if (urgence && !DetailClassementViewModel.Instance.Auto)
                    go(false);
                client.log("FIN!");

            }


        }

        public static event EventHandler refresh;
        public static event EventHandler refreshAlbum;

        public static void shutdown()
        {
            MemUtil.End();
            __end = true;
            if (App.bib != null)
                App.bib.Aborted = true;
            Db.WriteDB1();
            if (App.bib != null)
                App.bib.Aborted = true;
            Environment.Exit(0);
        }

        public static List<TrackListViewModel> getAlbum(TrackListViewModel track)
        {
            if (gen == null)
                return null;

            var ll = new List<TrackListViewModel>();

            var l = gen.getTracksAlbum(track.PieceGen);
            if (l == null)
                return null;
            foreach (Piece p in l)
            {

                TrackListViewModel trackList = TrackListViewModel.getOrCreate(p); // PlayListViewModel.findTrack(bib.Musique, p.PieceId);
                if (trackList == null)
                    continue;
                ll.Add(trackList);
            }

            return ll;

        }

        public void InfoIHm(string message, string caption)
        {
            MessageBox.Show(message, caption, MessageBoxButton.OK);
        }

        public bool Confirm(string question, string caption)
        {
            return MessageBox.Show(question, caption, MessageBoxButton.YesNo) == MessageBoxResult.Yes;
        }

        public bool? TriChoix(string question, string caption)
        {
            var result = MessageBox.Show(question, caption, MessageBoxButton.YesNoCancel);
            switch (result)
            {
                case MessageBoxResult.Cancel:
                return null;
                case MessageBoxResult.No:
                return false;
                case MessageBoxResult.None:
                return null;
                case MessageBoxResult.OK:
                return true;
                case MessageBoxResult.Yes: return true;
                default: return null;

            }
        }
        public Export getConfExport(string question)
        {
            var dialog = new ConfExport(question, export);
            dialog.ShowDialog();
            return export;
        }

        public Import getConfImport(string question)
        {
            var dialog = new ConfImport(question, import);
            dialog.ShowDialog();
            return import;
        }

        public string folderDialog()
        {
            var dialog = new FolderBrowserDialogW(Db.DefaultFolder); // new System.Windows.Forms.FolderBrowserDialog();
            dialog.ShowDialog();
            //dialog.SelectedPath = Db.DefaultFolder;
            //System.Windows.Forms.DialogResult result = dialog.ShowDialog();
            //string dir = null;
            //if (result == System.Windows.Forms.DialogResult.OK)
            //{
            //    dir = dialog.SelectedPath;
            //}

            //return dir;
            return dialog.Dir;
        }

        public int getNb(string question)
        {
            var w = new getNb(question, 2);
            w.ShowDialog();
            return w.Nb;
        }


        public bool changeName(string title, IName data)
        {
            var stringDialog = new StringDialog(title, data);
            stringDialog.ShowDialog();
            return stringDialog.Ok;
        }

        public PlayListViewModel selectPlayList(string title)
        {
            var dialog = new BrowsePlayList(title);
            dialog.ShowDialog();
            if (dialog.Ok)
            {
                return dialog.Selected;
            }

            return null;
        }

        public static void buildList()
        {
            Db.List.buildLists(bib.Listes.PlayList);
        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\InfoViewModel.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using pdb.gen;
using System.Windows.Input;
using pdb.player.ViewModel.Commande;
using pdb.player.ViewModel.Commande.PlayList;
using pdb.util;

namespace pdb.player.ViewModel
{

    class InfoViewModel : ViewModelBase, ISelectedTracks
    {
        private List<TrackListViewModel> list = new List<TrackListViewModel>();
        private HashSet<int> hs = new HashSet<int>();


        private bool withAlbum;
        private bool real;
        private bool withParent;


        private string album;
        private string artist;
        private string name;
        private int? trackNumber;
        private int? year;

        private bool applyAlbum;
        private bool applyArtist;
        private bool applyName;
        private bool applyTrackNumber;
        private bool applyYear;

        private bool loading;

        private TrackListViewModel current;

        public InfoViewModel(TrackListViewModel current)
        {
            this.current = current;
            buidList();
            TrackListViewModel.CurrentHumanSelectedChanged += new EventHandler(TrackListViewModel_CurrentHumanSelectedChanged);
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            if (TrackListViewModel.HumanSelected != current)
            {
                this.current = TrackListViewModel.HumanSelected;
                buidList();
            }
        }

        public void init()
        {
            string album = null;
            string artist = null;
            string name = null;
            int? tn = null;
            int? y = null;

            for (int i = 0; i < list.Count; i++)
            {
                var t = list[i];
                if (i == 0)
                {
                    album = t.Album.toKey();
                    artist = t.Artist.toKey();
                    name = t.Name.toKey();
                    if (t.Year > 0)
                        y = t.Year;

                    if (t.TrackNumber > 0)
                        tn = t.TrackNumber;
                }

                else
                {
                    if (t.Album.toKey() != album)
                        album = null;
                    if (t.Artist.toKey() != artist)
                        artist = null;
                    if (t.Name.toKey() != name)
                        name = null;
                    if (!t.Year.Equals(y))// y != null && t.Year != y.Value)
                        y = null;
                    if (!t.TrackNumber.Equals(tn))
                        tn = null;
                }
                if (album == null && artist == null && name == null && tn == null && year == null)
                    break;
            }

            Album = album;
            Artist = artist;
            Name = name;
            // if (tn.HasValue)
            TrackNumber = tn;
            // if (y.HasValue)
            Year = y;



            applyAlbum = false;
            applyArtist = false;
            applyName = false;
            applyTrackNumber = false;
            applyYear = false;
            list.Sort(new TrackComparer());
            OnPropertyChanged("");
        }

        //private void buildAlbum(Piece t)
        //{
        //    foreach (Piece p in t.PieceAlbum)
        //    {
        //        TrackListViewModel tt = TrackListViewModel.getOrCreate(p);
        //        list.Add(tt);
        //    }
        //}



        private void add(Piece p)
        {
            Piece toInsert = p;
            if (real && p.Virtual)
                p = p.Parent;
            if (hs.Add(p.PieceId))
            {
                TrackListViewModel tt = TrackListViewModel.getOrCreate(p);
                list.Add(tt);
            }
            if (withParent && p.Parent != null)
            {
                p = p = p.Parent;
                if (hs.Add(p.PieceId))
                {
                    TrackListViewModel tt = TrackListViewModel.getOrCreate(p);
                    list.Add(tt);
                }
            }

        }

        private void buidList()
        {
            list.Clear();
            hs.Clear();
            loading = true;
            var source = current.PieceGen;
            if (source.Virtual && real)
                source = source.Parent;


            if (withAlbum)
            {
                foreach (Piece p in source.PieceAlbum)
                {
                    add(p);
                }
            }
            else
                add(source);

            init();
            loading = false;
            OnPropertyChanged("List");
        }

        public void Apply()
        {
            App.setChanging();
            foreach (TrackListViewModel t in list)
            {
                if (applyAlbum)
                    t.Album = album;
                if (applyArtist)
                    t.Artist = artist;
                if (applyName)
                    t.Name = name;
                if (applyTrackNumber)
                {
                    if (trackNumber == null)
                        t.TrackNumber = -1;
                    else
                        t.TrackNumber = trackNumber.Value;
                }

                if (applyYear)
                {
                    if (year == null)
                        t.Year = -1;
                    else
                        t.Year = year.Value;
                }

            }

            App.releaseChanging();
            App.invalidateAlbums();
            App.go();
        }

        private bool isUnique { get { return list.Count < 2; } }

        public List<TrackListViewModel> List { get { return list; } }

        public string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value != album)
                {
                    album = value;
                    ApplyAlbum = true;
                    if (!loading) OnPropertyChanged("Album");
                }
            }
        }

        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value != artist)
                {
                    artist = value;
                    ApplyArtist = true;
                    if (!loading) OnPropertyChanged("Artist");
                }
            }
        }


        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value != name)
                {
                    name = value;
                    ApplyName = true;
                    if (!loading) OnPropertyChanged("Name");
                }
            }
        }

        public int? TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (value != trackNumber)
                {
                    trackNumber = value;
                    ApplyTrackNumber = true;
                    if (!loading) OnPropertyChanged("TrackNumber");
                }
            }
        }

        public int? Year
        {
            get
            {
                return year;
            }
            set
            {
                if (value != year)
                {
                    year = value;
                    ApplyYear = true;
                    if (!loading) OnPropertyChanged("Year");
                }
            }
        }

        public bool ApplyAlbum
        {
            get
            {
                return applyAlbum;
            }
            set
            {

                if (value != applyAlbum)
                {
                    applyAlbum = value;
                    if (!loading) OnPropertyChanged("ApplyAlbum");
                }
            }
        }

        public bool ApplyArtist
        {
            get
            {
                return applyArtist;
            }
            set
            {
                if (value != applyArtist)
                {
                    applyArtist = value;
                    if (!loading) OnPropertyChanged("ApplyArtist");
                }
            }
        }

        public bool ApplyName
        {
            get
            {
                return applyName;
            }
            set
            {
                if (value != applyName)
                {
                    applyName = value;
                    if (!loading) OnPropertyChanged("ApplyName");
                }
            }
        }


        public bool ApplyTrackNumber
        {
            get
            {
                return applyTrackNumber;
            }
            set
            {
                if (value != applyTrackNumber)
                {
                    applyTrackNumber = value;
                    if (!loading) OnPropertyChanged("ApplyTrackNumber");
                }
            }
        }

        public bool ApplyYear
        {
            get
            {
                return applyYear;
            }
            set
            {
                if (value != applyYear)
                {
                    applyYear = value;
                    if (!loading) OnPropertyChanged("ApplyYear");
                }
            }
        }


        public bool WithAlbum
        {
            get
            {
                return withAlbum;
            }
            set
            {
                if (value != withAlbum)
                {
                    withAlbum = value;
                    buidList();
                    OnPropertyChanged("WithAlbum");
                }
            }
        }

        public bool WithParent
        {
            get
            {
                return withParent;
            }
            set
            {
                if (value != withParent)
                {
                    withParent = value;
                    buidList();
                    OnPropertyChanged("WithParent");
                }
            }
        }

        public bool Real
        {
            get
            {
                return real;
            }
            set
            {
                if (value != real)
                {
                    real = value;
                    buidList();
                    OnPropertyChanged("Real");
                }
            }
        }


        private ICommand _contextInfo;
        public ICommand Info { get { if (_contextInfo == null) _contextInfo = new InfoCmd(); return _contextInfo; } }

        private ICommand _ContextCmdAddToList;
        public ICommand ContextCmdAddToList { get { if (_ContextCmdAddToList == null) _ContextCmdAddToList = new AddToList(this, App.Instance); return _ContextCmdAddToList; } }






        List<TrackListViewModel> ISelectedTracks.SelectedTracks
        {
            get { return list; }
        }

        private class TrackComparer : IComparer<TrackListViewModel>

        {
            public int Compare(TrackListViewModel x, TrackListViewModel y)
            {
                var xx = x.PieceId;
                var yy = y.PieceId;
                if (xx > 0)
                {
                    if (yy > 0)
                        return xx.CompareTo(yy);
                    else
                        return -1;
                }
                else
                {
                    if (yy < 0)
                        return xx.CompareTo(yy);
                    else
                        return -1;
                }

            }


        }
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\PlayerViewModel.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Threading;
using System.Windows.Input;
using System.Windows.Threading;
using pdb.gen;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.player.engine;
using pdb.player.engine.build;
using pdb.player.ViewModel.Commande;
using pdb.util;
using pdb.gen.auto;
using pdb.gen.albums;

namespace pdb.player.ViewModel
{


    enum positionstate
    {
        free,
        cannotPrevious,
        cannotForward
    }

    class HiddenPlayList : ItrackProvider
    {
        private ICollectionView viewOrg;
        private PlayListViewModel pl;
        private static List<TrackListViewModel> hiddenSelected = new List<TrackListViewModel>();

        public HiddenPlayList(PlayListViewModel pl, ICollectionView viewOrg)
        {
            this.viewOrg = viewOrg;
            this.pl = pl;
        }
        public ICollectionView PresentationTracks
        {
            get { return viewOrg; }
        }

        public void Focus(TrackListViewModel t)
        {

        }

        public PlayListViewModel PlayList
        {
            get { return pl; }
        }


        public void doFilter(string filter)
        {
            PlayerViewModel.doFilter(PresentationTracks, filter);
        }


        public List<TrackListViewModel> SelectedTracks
        {
            get { return hiddenSelected; }
        }
    }



    class PlayerViewModel : ViewModelBase
    {
        private static PlayerViewModel _instance;
        private static volatile object _lock = new object();
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort { get { return confAlbumSort; } set { confAlbumSort = value; } }
        public static PlayerViewModel Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lock)
                    {
                        if (_instance == null)
                            _instance = new PlayerViewModel();
                    }
                }
                return _instance;
            }
        }

        public ConfFilter ConfFilter { get { return FilterTask.conf; } }
        private IPlayerEngine _player;

        public IPlayerEngine Player
        {
            get
            {
                if (_player == null)
                {
                    lock (_lock)
                    {
                        if (_player == null)
                        {
                            _player = PlayerBuilder.create("vlcplugin");
                            _player.mediaEndReached += player_mediaEndReached;
                            _player.Volume = volume;

                            new Thread(refreshLoop).Start();
                        }
                    }
                }
                return _player;
            }
        }

        private TrackListViewModel currentTrack;
        private PlayListViewModel currentPl;
        public event EventHandler currentTrackChange;
        public event EventHandler resumeChange;
        public static event EventHandler autoChange;
        private playerstate state;
        private positionstate _positionstate;
        private bool onlyEnabled = true;
        // private bool sortByAlbum = true;
        private bool withVirtualAlbum = CConf.ConfGen.AlbumVirtual;
        private bool withArtistVirtual = CConf.ConfGen.ArtistVirtual;
        private bool navAuto = CConf.ConfGen.NavAuto;
        public bool NavAuto
        {
            get { return navAuto; }
            set
            {
                if (value != navAuto)
                {
                    navAuto = value;
                    OnPropertyChanged("NavAuto");
                }
            }
        }

        private bool filterOnlyNext = false;
        public bool FilterNext
        {
            get { return filterOnlyNext; }
            set
            {
                if (value != filterOnlyNext)
                {
                    filterOnlyNext = value;
                    OnPropertyChanged("FilterNext");
                    App.gen.FilterNext = value;
                }
            }
        }
        ItrackProvider _real;
        private Logger log;
        // public static IPlayerEngine Player { get { return Instance.player; } }


        public bool OnlyEnabled
        {
            get
            {
                return onlyEnabled;
            }
            set
            {
                if (value != onlyEnabled)
                {
                    onlyEnabled = value;
                    OnPropertyChanged("OnlyEnabled");
                }
            }
        }
        private bool createRot = true;
        public bool CreateRot
        {
            get
            {
                return createRot;
            }
            set
            {
                if (value != createRot)
                {
                    createRot = value;
                    OnPropertyChanged("CreateRot");
                }
            }
        }

        public bool SortByAlbum
        {
            get
            {
                return confAlbumSort.Enabled;
            }
        }
        //private albumSortMode sortAlbumMode;
        //public albumSortMode SortAlbumMode
        //{
        //    get { return sortAlbumMode; }
        //    set
        //    {
        //        if (value != sortAlbumMode)
        //        {
        //            sortAlbumMode = value;
        //            OnPropertyChanged("SortAlbumMode");
        //            App.go();
        //        }
        //    }
        //}

        public bool WithVirtualAlbum
        {
            get { return withVirtualAlbum; }
            set
            {
                if (value != withVirtualAlbum)
                {
                    withVirtualAlbum = value;
                    OnPropertyChanged("WithVirtualAlbum");
                    App.go();
                }
            }
        }

        public bool WithVirtualArtist
        {
            get { return withArtistVirtual; }
            set
            {
                if (value != withArtistVirtual)
                {
                    withArtistVirtual = value;
                    OnPropertyChanged("WithVirtualArtist");
                    App.go();
                }
            }
        }



        private PlayerViewModel()
        {
            this.log = Logger.getLogger("PlayerViewModel");
            //player.mediaEndReached += player_mediaEndReached;
            //player.Volume = volume;

            TrackListViewModel.CurrentHumanSelectedChanged += TrackListViewModel_CurrentHumanSelectedChanged;


            //new Thread(refreshLoop).Start();
            this.currentPl = PlayListViewModel.SelectedPlayList;
        }

        void TrackListViewModel_CurrentHumanSelectedChanged(object sender, EventArgs e)
        {
            makeResume();
        }

        void player_mediaEndReached(object sender, EventArgs e)
        {
            var track = this.CurrentTrack;
            if (track != null)
                track.Piece.recordJustReadTrack();
            next();
            App.go();
        }

        #region commande
        private ICommand cmdPlayPause;
        private ICommand cmdForward;
        private ICommand cmdStop;
        private ICommand cmdBackWard;
        private readonly static TimeSpan LIMIT_BACK = TimeSpan.FromSeconds(5.1);

        public ICommand Play
        {
            get
            {
                if (cmdPlayPause == null)
                    cmdPlayPause = new PlayPause();
                return cmdPlayPause;
            }
        }

        public ICommand Forward
        {
            get
            {
                if (cmdForward == null)
                    cmdForward = new ForWard();
                return cmdForward;
            }
        }

        public ICommand BackWard
        {
            get
            {
                if (cmdBackWard == null)
                    cmdBackWard = new BackWard();
                return cmdBackWard;
            }
        }

        public bool canForward()
        {
            return canPlay() && _positionstate != positionstate.cannotForward;
        }
        public bool canBackWard()
        {
            if (!canPlay())
                return false;
            if (PlayJustStarted)
                return _positionstate != positionstate.cannotPrevious;
            return true;

        }

        public void backWard()
        {
            if (PlayJustStarted)
                movetoPrevious();
            else
                goStartTrack();
        }

        public void checkNavIni()
        {
            if (!navAuto)
                return;

            var tracks = PresentationTracks;
            bool foundFirst = false;
            TrackListViewModel f = null;

            foreach (TrackListViewModel t in tracks)
            {
                if (t.Index == 1)
                {
                    foundFirst = true;
                }
                if (foundFirst && t.PieceGen.IsNext)
                {
                    f = t;
                    break;
                }
            }

            if (f == null)
                return;

            tracks.MoveCurrentTo(f);
            focus(f);

        }

        public void forwardAuto()
        {

            try
            {
                var t = TrackListViewModel.HumanSelected;
                if (t != null)
                {
                    t.refresh();
                    //  var g = t.Grouping; 
                }

                var pl = PlayListViewModel.SelectedPlayList;
                if (pl == null)
                {
                    movetoNext(true);
                    return;
                }


                string _album = "";
                if (currentTrack != null)
                    _album = currentTrack.Album;
                movetoNext(true); // des fois le morceaux affiché n'est pas celui joué. Dommage...
                // d'autre part on doit aboutir au 1er élément

                if (currentTrack != null && currentTrack.Album == _album)
                {
                    if (state == playerstate.play)
                        play(false, true);
                    return;
                }

                if (currentTrack == null)
                    return;
                var album = App.gen.Albums.getAlbum(CurrentTrack.PieceGen);
                var tracks = album.Tracks;
                //    tracks.Sort(new PieceClassementComparer());
                //  decimal val = int.MaxValue;
                int i = 0;
                TrackListViewModel choose = null;
                if (confAlbumSort.ComposantsUtiles[0].cmpMin > modeMin.non)
                {
                    var next = album.Next;
                    if (next != null)
                        choose = TrackListViewModel.getOrCreate(next); // pl.FindTrack(next.PieceId);
                }
                else
                {
                    for (i = 0; i < tracks.Count; i++)
                    {
                        var item = tracks[i];
                        if (item != null && (!onlyEnabled || item.Enabled))
                        {
                            var tl = TrackListViewModel.getOrCreate(item); // pl.FindTrack(item.PieceId);
                            if (!tl.ExistsNow)
                                continue;
                            choose = tl;

                            //val = v;
                            // choose = tl;
                            if (!item.Classement.isPositive())
                            {
                                break;
                                //if (confAlbumSort.ComposantsUtiles[0].cmpMin != modeMin.toujours)
                                //    choose = tl;
                                //break;
                            }
                            // choose = tl;
                        }
                    }
                }

                if (choose != null)
                {
                    //var p = choose.PieceGen;
                    //if (p != null)
                    //   confAlbumSort.auto(p.AutoCoeff1, p.AutoCoeff2); 
                    if (choose != currentTrack)
                    {
                        reset(provider, choose, state == playerstate.play);
                        var coll = PresentationTracks;
                        coll.MoveCurrentTo(choose);
                    }

                    focus(choose);

                }
            }
            finally
            {
                refresh();
                doFilter(_lastFilter);
            }


        }

        public void forward()
        {
            if (!navAuto)
                movetoNext(true);
            else
            {
                try
                {
                    var t = TrackListViewModel.HumanSelected;
                    if (t != null)
                    {
                        t.refresh();
                        //  var g = t.Grouping; 
                    }

                    var pl = PlayListViewModel.SelectedPlayList;
                    if (pl == null || currentTrack == null)
                    {
                        movetoNext(true);
                        return;
                    }

                    var _track = new List<TrackListViewModel>();
                    var __collec = PresentationTracks;

                    int maxIndex = int.MaxValue;
                    int target = 1;
                    TrackListViewModel _next = null;

                    foreach (TrackListViewModel tt in __collec)
                    {
                        var index = tt.Index;
                        if (tt == currentTrack)
                        {
                            if (currentTrack.Index == 1)
                                target = 2;
                            continue;
                        }
                        if (tt.MasterId == currentTrack.MasterId)
                            continue;
                        if (index < maxIndex)
                        {
                            maxIndex = index;
                            _next = tt;
                            if (maxIndex == target)
                                break;
                        }

                    }

                    if (_next != null)
                    {
                        __collec.MoveCurrentTo(_next);
                        CurrentTrack = _next;

                        Player.play(_next.Location, true);                      
                        return;

                        // focus(item);

                    }



                    string _album = "";
                    if (currentTrack != null)
                        _album = currentTrack.Album;
                    movetoNext(true); // des fois le morceaux affiché n'est pas celui joué. Dommage...
                    if (currentTrack != null && currentTrack.Album == _album)
                    {
                        if (state == playerstate.play)
                            play(false, true);
                        return;
                    }

                    if (currentTrack == null)
                        return;
                    var album = App.gen.Albums.getAlbum(CurrentTrack.PieceGen);
                    var tracks = album.Tracks;
                    //    tracks.Sort(new PieceClassementComparer());
                    //  decimal val = int.MaxValue;
                    int i = 0;
                    TrackListViewModel choose = null;
                    if (confAlbumSort.ComposantsUtiles[0].cmpMin > modeMin.non)
                    {
                        var next = album.Next;
                        if (next != null)
                            choose = TrackListViewModel.getOrCreate(next); // pl.FindTrack(next.PieceId);
                    }
                    else
                    {
                        for (i = 0; i < tracks.Count; i++)
                        {
                            var item = tracks[i];
                            if (item != null && (!onlyEnabled || item.Enabled))
                            {
                                var tl = TrackListViewModel.getOrCreate(item); // pl.FindTrack(item.PieceId);
                                if (!tl.ExistsNow)
                                    continue;
                                choose = tl;

                                //val = v;
                                // choose = tl;
                                if (!item.Classement.isPositive())
                                {
                                    break;
                                    //if (confAlbumSort.ComposantsUtiles[0].cmpMin != modeMin.toujours)
                                    //    choose = tl;
                                    //break;
                                }
                                // choose = tl;
                            }
                        }
                    }

                    if (choose != null)
                    {
                        //var p = choose.PieceGen;
                        //if (p != null)
                        //   confAlbumSort.auto(p.AutoCoeff1, p.AutoCoeff2); 
                        if (choose != currentTrack)
                        {
                            reset(provider, choose, state == playerstate.play);
                            var coll = PresentationTracks;
                            coll.MoveCurrentTo(choose);
                        }

                        focus(choose);

                    }
                }
                finally
                {
                    refresh();
                    doFilter(_lastFilter);
                }

            }
        }

        public bool isHidden { get { return provider is HiddenPlayList; } }

        public void pause()
        {
            State = playerstate.pause;
            Player.pause();
        }

        private bool PlayJustStarted { get { return ElapsedTime < LIMIT_BACK; } }

        #endregion

        #region navigation
        public bool canPlay()
        {
            //if (currentPl == null)
            //    return false;
            var tracks = PresentationTracks;
            if (tracks == null)
                return false;
            if (tracks.IsEmpty)
                return false;
            return true;
        }



        private void movetoNext(bool autoPlay)
        {
            move(true, autoPlay);
            // doFilter(_lastFilter);
        }

        private void goStartTrack()
        {
            Position = 0;
        }

        private void move(bool _toNext, bool autoPlay)
        {
            bool playing = state == playerstate.play;
            TrackListViewModel item = null;



            var tracks = PresentationTracks;

            Func<bool> _move;
            if (_toNext)
                _move = tracks.MoveCurrentToNext;
            else
                _move = tracks.MoveCurrentToPrevious;
            try
            {

                int masterId = 0;
                if (currentTrack != null)
                {
                    tracks.MoveCurrentTo(currentTrack);
                    masterId = currentTrack.MasterId;
                }
                if (!_move())
                {
                    return;
                }

                while (true)
                {
                    item = tracks.CurrentItem as TrackListViewModel;
                    if (item != null && item.ExistsNow && (!onlyEnabled || item.Enabled) && item.MasterId != masterId)
                        break;
                    if (!_move())
                    {
                        item = null;
                        return;
                    }

                }



            }
            finally
            {
                if (item == null)
                    _positionstate = _toNext ? positionstate.cannotForward : positionstate.cannotPrevious;
                CurrentTrack = item;
                tracks.MoveCurrentTo(currentTrack);
                if (item != null)
                {
                    // focus(item);
                    if (playing && autoPlay)
                    {
                        Player.play(item.Location, true);
                    }
                    // focus(item);
                }

                refresh();

            }
        }


        private void movetoPrevious()
        {
            move(false, true);
            //bool playing = state == playerstate.play;
            //TrackListViewModel item = null;

            //var tracks = PresentationTracks;
            //try
            //{


            //    if (currentTrack != null)
            //        tracks.MoveCurrentTo(currentTrack);
            //    if (!tracks.MoveCurrentToPrevious())
            //    {
            //        _positionstate = positionstate.cannotPrevious;
            //        state = playerstate.stop;
            //        return;
            //    }

            //    while (true)
            //    {
            //        item = tracks.CurrentItem as TrackListViewModel;
            //        if (item.Enabled)
            //            break;
            //        if (!tracks.MoveCurrentToPrevious())
            //        {
            //            _positionstate = positionstate.cannotPrevious;
            //            state = playerstate.stop;
            //            return;
            //        }

            //    }



            //}
            //finally
            //{
            //    CurrentTrack = item;
            //    tracks.MoveCurrentTo(currentTrack);
            //    if (item != null)
            //    {
            //        focus(tracks.CurrentPosition);
            //        if (playing)
            //        {
            //            player.play(item.Location, true);

            //        }
            //    }

            //}
        }



        public void play(bool forceDisabled, bool reload)
        {

            TrackListViewModel item = currentTrack;
            var tracks = PresentationTracks;
            try
            {
                if (!canPlay())
                    return;

                while (true)
                {
                    if (item == null)
                    {
                        _positionstate = positionstate.cannotPrevious;

                        if (!tracks.MoveCurrentToFirst())
                        {
                            //_positionstate = positionstate.cannotPrevious; 
                            return;
                        }

                        while (true)
                        {
                            item = tracks.CurrentItem as TrackListViewModel;
                            if (item != null && item.ExistsNow && (!onlyEnabled || item.Enabled))
                                break;
                            else if (currentTrack != null)
                            {
                                item = currentTrack;
                                break;
                            }
                            if (!tracks.MoveCurrentToNext())
                            {
                                _positionstate = positionstate.cannotForward;
                                return;
                            }
                            _positionstate = positionstate.free;
                        }

                        if (item == null)
                            return;


                    }
                    tracks.MoveCurrentTo(item);
                    if (tracks.CurrentPosition >= 0)
                        break;
                    item = null;
                }

                CurrentTrack = item;

                //  focus(item);

                State = playerstate.play;
                //item.Playing = true;
                Player.play(currentTrack.Location, reload);
                // Volume = Volume;
                focus(item);
            }
            finally
            {
                if (!canPlay() || currentTrack == null)
                    stop();
                refresh();
            }
        }



        public void stop()
        {

            if (isHidden)
            {
                provider = _real;
                tracks = provider.PresentationTracks;
            }

            State = playerstate.stop;
            Player.stop();
            refresh();

        }

        private void next()
        {
            if (navAuto)
                forward();
            else
                movetoNext(true);
        }



        #endregion

        private ItrackProvider provider;
        //internal ItrackProvider Provider
        //{
        //    set
        //    {

        //        //if (state != playerstate.stop)
        //        //{
        //        //    if (provider != null)
        //        //    {
        //        //        if (provider is HiddenPlayList)
        //        //        {
        //        //        }
        //        //        else
        //        //        {
        //        //            provider = new HiddenPlayList(provider.PresentationTracks);
        //        //        }
        //        //    }
        //        //    else
        //        //        provider = value;
        //        //}
        //        provider = value;
        //    }
        //}
        public ICollectionView PresentationTracks
        {
            get
            {
                if (provider == null)
                    return null;
                return provider.PresentationTracks;
            }
        }

        public void focusHelp()
        {
            var t = TrackListViewModel.CurrentPlaying;
            if (t == null)
                t = TrackListViewModel.HumanSelected;
            if (t == null) return;
            focus(t);
        }
        private void focus(TrackListViewModel t)
        {
            if (provider == null)
                return;
            provider.Focus(t);
        }






        public playerstate State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    state = value;
                    OnPropertyChanged("State");
                    OnPropertyChanged("SrcPlayPause");
                }
            }
        }



        private bool bEnd;
        private void refreshLoop()
        {
            while (!bEnd)
            {
                Thread.Sleep(1000);
                refresh();
            }
        }

        private void refresh()
        {
            try
            {

                //  this.IndexList = infos.IndexList;
                var _position = _player.Position;
                if (_position != position) { position = _position; OnPropertyChanged("Position"); }

                this.ElapsedTime = _player.Elapsed;
                this.Length = _player.Duration;

                this.RemainingTime = Length - ElapsedTime;
                if (CurrentTrack == null)
                {
                    CurrentName = "";
                    CurrentAuthorAlbum = "";
                }
                else
                {
                    CurrentName = currentTrack.Name;
                    var sb = new System.Text.StringBuilder();
                    sb.Append(currentTrack.Artist);
                    sb.Append(" - ");
                    sb.Append(currentTrack.Album);
                    if (currentTrack.PieceGen != null)
                    {
                        if (currentTrack.PieceGen.Virtual)
                        {
                            sb.Append(" (");
                            sb.Append(currentTrack.PieceGen.Master.Album);
                            sb.Append(")");
                        }
                    }
                    CurrentAuthorAlbum = sb.ToString();
                    if (currentTrack.ExistsNow)
                        currentTrack.Duration = length;

                }

            }
            catch { }

        }


        public TrackListViewModel CurrentTrack
        {
            get { return currentTrack; }
            set
            {
                if (value != null)
                    value.Playing = true;
                if (value != currentTrack)
                {
                    if (currentTrack != null)
                        currentTrack.Playing = false;
                    currentTrack = value;
                    if (currentTrack == null)
                        stop();
                    if (currentTrackChange != null)
                        currentTrackChange(Instance, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track)
        {
            reset(provider, track, true);
        }

        public static void makeauto(TrackListViewModel current)
        {
            if (current != null)
            {
                var p = current.PieceGen;
                if (p != null)
                {
                    if (MedianneDriver.auto(confAlbumSort, p))
                        App.gen.Albums.invalidateAll(false);
                    if (autoChange != null)
                        autoChange(current, EventArgs.Empty);
                }
            }
        }

        public static void reset(ItrackProvider provider, TrackListViewModel track, bool autoPlay)
        {
            if (provider != null)
            {
                Instance.provider = provider;
                if (provider.PlayList != null)
                    Instance.currentPl = provider.PlayList;
                Instance.provider = provider;
                Instance.tracks = provider.PresentationTracks;

            }
            Instance._positionstate = positionstate.free;






            Instance.CurrentTrack = track;
            if (autoPlay)
                Instance.play(true, true);
            Instance.makeResume();
            App.go();
        }


        public PlayListViewModel PlayList
        {
            get
            {
                return currentPl;
            }
        }
        ICollectionView tracks = null;
        public void set(ItrackProvider provider)
        {
            try
            {
                if (provider == null)
                {
                    log.log("provider null");
                    this.provider = null;
                    this.currentPl = null;
                    return;
                }
                else if (this.provider == null)
                {
                    log.log("init provider " + provider);
                    this.provider = provider;
                    this.currentPl = provider.PlayList;
                    this.tracks = provider.PresentationTracks;
                }

                else
                {


                    if (provider.PlayList == currentPl || state == playerstate.stop)
                    {
                        if (isHidden)
                        {
                            log.log("retour au réel");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                            var currentPlaying = TrackListViewModel.CurrentPlaying;
                            tracks.MoveCurrentTo(currentPlaying);
                            provider.Focus(currentPlaying);
                        }
                        else
                        {
                            log.log("détection standart");
                            this.provider = provider;
                            this.currentPl = provider.PlayList;
                            this.tracks = provider.PresentationTracks;
                        }
                    }

                    else
                    {
                        if (isHidden)
                        {
                            log.log("toujours virtuel");
                        }
                        else
                        {


                            log.log("passage en virtuel");
                            this.provider = new HiddenPlayList(currentPl, tracks);
                            this._real = provider;
                            // this.currentPl = provider.PlayList;
                            //this.tracks = provider.PresentationTracks; 
                        }
                    }
                }

                _positionstate = positionstate.free;
                if (currentPl == null)
                {
                    CurrentTrack = null;
                    stop();
                    return;
                }

            }
            finally
            {
                OnPropertyChanged("State");
                OnPropertyChanged("SrcPlayPause");
                makeResume();
            }
        }
        //  private class filterTask
        //  {
        //      public filterTask()
        //      {
        //      }
        //      public string filter;
        //      //public string waitingFilter; 
        //      //private bool cancel; 
        //      //private Thread th;
        //      public Predicate<object> Filter;
        //      //public ICollectionView coll;
        //      //private bool busy;

        //      public void go()
        //      {

        //          if (!string.IsNullOrEmpty(filter))
        //              filter = filter.Trim().ToLower().removeAccent();

        //          var tab = filter.Split(' ');
        //          // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 
        //          lock (this)
        //              busy = true;
        //          coll.Filter = item =>
        //          {
        //              TrackListViewModel vitem = item as TrackListViewModel;
        //              if (vitem == null) return false;

        //              //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //              //    return vitem.Classement.StartsWith(filter);
        //              bool ok = true;
        //              var name = vitem.Name.Trim().ToLower().removeAccent();
        //              var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //              var album = vitem.Album.Trim().ToLower().removeAccent();
        //              var classement = vitem.Classement;
        //              foreach (string str in tab)
        //              {
        //                  if (!ok)
        //                      return false;
        //                  if (string.IsNullOrEmpty(str))
        //                      continue;
        //                  var str_ = str.Trim();
        //                  if (str_ == string.Empty)
        //                      continue;

        //                  ok = name.Contains(str_)
        //                      || artist.Contains(str_)
        //                      || album.Contains(str_)
        //                      || classement.StartsWith(str_);

        //              }

        //              return ok;

        //          };

        //          lock (this)
        //              busy = true;

        //      }
        //      private void getItems()
        //      {
        //          try
        //          {
        //              if (!string.IsNullOrEmpty(filter))
        //                  filter = filter.Trim().ToLower().removeAccent();
        //              if (cancel)
        //                  return;
        //              var tab = filter.Split(' ');
        //              if (cancel)
        //                  return;
        //              Filter = item =>
        //              {
        //                  TrackListViewModel vitem = item as TrackListViewModel;
        //                  if (vitem == null) return false;

        //                  //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
        //                  //    return vitem.Classement.StartsWith(filter);
        //                  bool ok = true;
        //                  var name = vitem.Name.Trim().ToLower().removeAccent();
        //                  var artist = vitem.Artist.Trim().ToLower().removeAccent();
        //                  var album = vitem.Album.Trim().ToLower().removeAccent();
        //                  var classement = vitem.Classement;
        //                  foreach (string str in tab)
        //                  {
        //                      if (!ok)
        //                          return false;
        //                      if (string.IsNullOrEmpty(str))
        //                          continue;
        //                      var str_ = str.Trim();
        //                      if (str_ == string.Empty)
        //                          continue;

        //                      ok = name.Contains(str_)
        //                          || artist.Contains(str_)
        //                          || album.Contains(str_)
        //                          || classement.StartsWith(str_);

        //                  }

        //                  return ok;

        //              };
        //          }
        //          catch (Exception ex)
        //          {
        //              App.log.log(ex.ToString()); 
        //          }
        //      }
        //  }
        ////  private static filterTask filtertask = new filterTask(); 
        private static IDisposable work;
        private static FilterTask filterTask = null;

        private static bool cancel;
        public static void doFilter0(ICollectionView coll, string filter)
        {

            ILogger log = App.log;
            log.log("filter=>{0}", filter);
            lock (_lock)
            {
                if (work == null)
                {
                    log.log("filter=>{0} verrou libre", filter);
                    work = coll.DeferRefresh();
                }
                else
                {
                    log.log("filter=>{0} verrou pris, abandon tâche en cours", filter);
                    cancel = true;
                }
            }

            var _cancel = cancel;
            if (_cancel)
                log.log("filter=>{0} verrou pris, attente fin tâche en cours", filter);
            while (cancel)
                Thread.Sleep(30);

            if (_cancel)
                log.log("filter=>{0} verrou pris, fin d'attente fin tâche en cours", filter);

            if (!string.IsNullOrEmpty(filter))
                filter = filter.Trim().ToLower().removeAccent();

            var tab = filter.Split(' ');
            // var coll = CollectionViewSource.GetDefaultView(dg.ItemsSource); 


            _cancel = cancel;
            if (!_cancel)
            {
                lock (_lock)
                    _cancel = cancel;
            }

            if (!_cancel)
            {
                log.log("filter=>{0} lancement filtre", filter);
                coll.Filter = item =>
                {
                    if (cancel)
                        return false;
                    TrackListViewModel vitem = item as TrackListViewModel;
                    if (vitem == null) return false;



                    //if (Regex.IsMatch(filter, @"[0-5]+\.?[0-5]?") || Regex.IsMatch(filter, @"\.[0-5]?"))
                    //    return vitem.Classement.StartsWith(filter);
                    bool ok = true;
                    var name = vitem.Name.Trim().ToLower().removeAccent();
                    var artist = vitem.Artist.Trim().ToLower().removeAccent();
                    var album = vitem.Album.Trim().ToLower().removeAccent();
                    List<string> paths = null;

                    var classement = vitem.Classement;
                    foreach (string str in tab)
                    {
                        if (!ok)
                            return false;
                        if (string.IsNullOrEmpty(str))
                            continue;
                        var str_ = str.Trim();
                        if (str_ == string.Empty)
                            continue;

                        ok = name.Contains(str_)
                            || artist.Contains(str_)
                            || album.Contains(str_)
                            || classement.StartsWith(str_);

                        if (!ok)
                        {
                            if (paths == null)
                            {
                                paths = new List<string>();
                                foreach (var f in vitem.Piece.Files)
                                {
                                    paths.Add(f.File.ToLower().removeAccent());
                                }
                            }

                            foreach (string path in paths)
                            {
                                if (path.Contains(str))
                                    return true;
                            }
                        }
                    }

                    return ok;

                };

                if (cancel)
                    log.log("filter=>{0} la tâche a été interrompue", filter);
            }
            else
            {
                log.log("filter=>{0} finalement pas de lancement", filter);
            }
            lock (_lock)
            {
                if (!cancel)
                {
                    if (work != null)
                    {
                        log.log("filter=>{0} application du filtre", filter);
                        work.Dispose();
                    }
                    else
                    {
                        log.log("filter=>{0} ben pourquoa le work était null ????", filter);
                    }
                    work = null;

                }
            }

            lock (_lock)
                cancel = false;

            log.log("filter=>{0} fin", filter);
        }




        private class FilterTask
        {
            public static ConfFilter conf = new ConfFilter();
            private ICollectionView coll;
            public readonly string filter0;
            public readonly bool filterNext;

            private string filter;
            private bool _cancel;
            private bool end;
            private Thread th;
            SimpleChrono log;
            public string step;
            private HashSet<int> l = new HashSet<int>();
            public FilterTask(string filter, bool filterNext, ICollectionView coll, SimpleChrono log)
            {
                this.filter0 = filter;
                this.filter = filter;
                this.filterNext = filterNext;

                this.coll = coll;
                this.log = log;
                step = "ini";
                th = new Thread(calc);
                th.Start();
            }

            public void cancel()
            {
                lock (_lock)
                    _cancel = true;
            }

            public bool End { get { return end; } }
            public bool Cancel { get { return _cancel; } }
            private bool toClear;

            private void calc()
            {
                step = "calc";
                try
                {
                    if (string.IsNullOrEmpty(filter) && !filterNext)
                    {
                        toClear = true;
                        apply();
                        return;
                    }
                    toClear = false;

                    filter = filter.Trim().ToLower().removeAccent();
                    //if (string.IsNullOrWhiteSpace(filter) && !filterNext && conf.includeVirtual && conf.includeVirtualArtist)
                    //{
                    //    clear(); 
                    //    return;
                    //}

                    var tab = filter.Split(' ');

                    int nb = 0;
                    int nbOk = 0;

                    foreach (TrackListViewModel vitem in coll.SourceCollection)
                    {
                        if (_cancel)
                            return;

                        if (filterNext && !vitem.PieceGen.IsNext)
                            continue;
                        if (conf.onlyMaster && vitem.Piece.Parent != null)
                            continue;
                        if (!filterNext)
                        {
                            if (vitem.PieceGen.Virtual && !conf.includeVirtual)
                                continue;
                            if (vitem.PieceGen.VirtualMode == pdb.gen.albums.virtualMode.artist && !conf.includeVirtualArtist)
                                continue;
                        }



                        bool ok = true;

                        if (conf.onlyId)
                        {
                            ok = filter == vitem.PieceId.ToString();
                        }
                        else
                        {

                            var name = vitem.Name.Trim().ToLower().removeAccent();
                            var artist = vitem.Artist.Trim().ToLower().removeAccent();
                            var album = vitem.Album.Trim().ToLower().removeAccent();
                            var masterAlbum = vitem.MasterAlbum.Trim().ToLower().removeAccent();
                            var classement = vitem.Classement;
                            List<string> paths = null;
                            foreach (string str in tab)
                            {
                                if (ok)
                                {
                                    if (string.IsNullOrEmpty(str))
                                        continue;
                                    var str_ = str.Trim();
                                    if (str_ == string.Empty)
                                        continue;

                                    ok = name.Contains(str_)
                                        || artist.Contains(str_)
                                        || album.Contains(str_)
                                        || masterAlbum.Contains(str_)
                                        || classement.StartsWith(str_)
                                        || (conf.includeId && str == vitem.PieceId.ToString())
                                        ;

                                    if (!ok)
                                    {
                                        if (paths == null)
                                        {
                                            paths = new List<string>();
                                            foreach (var f in vitem.Piece.Files)
                                            {
                                                paths.Add(f.File.ToLower().removeAccent());
                                            }
                                        }

                                        foreach (string path in paths)
                                        {
                                            if (path.Contains(str))
                                            {
                                                ok = true;
                                                break;
                                            }
                                        }
                                    }

                                }
                                else
                                    break;

                            }
                        }


                        nb++;
                        if (ok)
                        {
                            if (conf.family)
                            {
                                foreach (Piece p in vitem.PieceGen.Master)
                                {
                                    if (!filterNext)
                                    {
                                        if (p.Virtual && !conf.includeVirtual)
                                            continue;
                                        if (p.VirtualMode == pdb.gen.albums.virtualMode.artist && !conf.includeVirtualArtist)
                                            continue;
                                    }
                                    l.Add(p.PieceId);
                                }
                            }
                            else
                                l.Add(vitem.PieceId);

                            nbOk++;
                        }
                    }

                    log.log(string.Format("{0}/{1}", nbOk, nb));
                    // log.log(string.Format("calc:{0} item{1} {2} sélectionné{3}", nb, (nb > 1 ? "s" : ""), nbOk, (nbOk > 1 ? "s" : "")));   

                    lock (_lock)
                    {
                        if (_cancel)
                            return;
                    }


                    apply();


                }
                finally
                {
                    if (_cancel)
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par cancel");
                    }
                }





            }




            public void apply()
            {
                step = "apply";

                bool __cancel = _cancel;

                if (!__cancel)
                {
                    lock (_lock)
                        __cancel = _cancel;
                }


                if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
                {

                    if (__cancel)
                        return;
                    step = "applyAppDispatcher";
                    try
                    {
                        if (toClear)
                        {
                            log.log("clear filter");
                            coll.Filter = null;
                            log.log("fin clear filter");
                            return;
                        }

                        if (work == null)
                        {
                            log.log("creation du tempo");
                            work = coll.DeferRefresh();
                        }
                        else
                        {
                            log.log("tempo déjà créé ");

                        }


                        coll.Filter = item =>
                        {
                            if (_cancel)
                                return false;

                            var t = item as TrackListViewModel;
                            if (t == null)
                                return false;
                            if (!l.Contains(t.PieceId))
                                return false;
                            return true;
                        };




                        if (!__cancel)
                        {
                            log.log("application");
                            work.Dispose();
                            work = null;
                            log.log("fin application");
                        }
                        else
                        {
                            log.log("abandon application");
                        }
                    }
                    finally
                    {
                        lock (_lock)
                            end = true;
                        log.log("tache terminée par application");
                        PlayerViewModel.Instance.makeResume();
                        PlayerViewModel.Instance.focusHelp();
                    }
                }
                else
                {
                    App.Current.Dispatcher.BeginInvoke(new Action(apply), App.DISPATCHER_PRIORITY);
                }
            }

            public override string ToString()
            {
                return string.Format("en cours:{0} step:{1} end:{2} cancel:{3}", filter0, step, End, Cancel);
            }

        }


        public static void doFilter(ICollectionView coll, string filter)
        {
            SimpleChrono log = new SimpleChrono(string.Format("\tfilter=>{0}\t", filter), App.log);

            log.log("");
            lock (_lock)
            {
                bool _cancelCurrent = false;
                bool _same = false;

                if (filterTask != null)
                {
                    log.log(filterTask.ToString());
                }

                _cancelCurrent = filterTask != null && !filterTask.End;
                _same = _cancelCurrent && filterTask.filter0.Equals(filter) && filterTask.filterNext == Instance.FilterNext;
                if (_same)
                {
                    log.log("identique");
                    return;
                }
                else if (_cancelCurrent)
                {
                    log.log("abandon tâche en cours");
                    filterTask.cancel();
                }

                else
                {
                    log.log("verrou libre");
                }

                filterTask = new FilterTask(filter, Instance.filterOnlyNext, coll, log);

            }





        }



        //public void set(ItrackProvider provider)
        //{
        //    try
        //    {
        //        if (provider == null)
        //        {
        //            this.provider = null;
        //            this.currentPl = null;
        //            return;
        //        }
        //        else if (this.provider == null)
        //        {
        //            this.provider = provider;
        //            this.currentPl = provider.PlayList;
        //            this.tracks = provider.PresentationTracks;
        //        }

        //        else
        //        {
        //            if (provider.PlayList == currentPl || state == playerstate.stop)
        //            {
        //                this.provider = provider;
        //                this.currentPl = provider.PlayList;
        //                this.tracks = provider.PresentationTracks;
        //            }

        //            else
        //            {
        //                if (_real == null || _real.PlayList != provider.PlayList)
        //                {
        //                    this.provider = new HiddenPlayList(currentPl, tracks);
        //                    this._real = provider;
        //                }
        //                else
        //                {
        //                    this.provider = _real;
        //                }
        //            }
        //        }

        //        _positionstate = positionstate.free;
        //        if (currentPl == null)
        //        {
        //            CurrentTrack = null;
        //            stop();
        //            return;
        //        }

        //    }
        //    finally
        //    {
        //        OnPropertyChanged("State");
        //        OnPropertyChanged("SrcPlayPause");
        //    }
        //}
        string _lastFilter = "";
        //public void doFilter()
        //{
        //    if (this.navAuto)
        //        doFilter(_lastFilter);
        //}

        public void doFilter(String filter)
        {
            this._lastFilter = filter;
            var provider = DisplayProvider;

            if (provider == null)
                return;
            provider.doFilter(filter);

        }

        private ItrackProvider DisplayProvider
        {
            get
            {
                if (provider == null)
                    return null;
                if (isHidden && _real != null)
                {
                    return _real;
                }
                return provider;
            }
        }

        private string resume;

        public void makeResume()
        {
            if (Dispatcher.CurrentDispatcher == App.Current.Dispatcher)
            {
                string newResume = resume;
                try
                {

                    IEnumerable items = null;
                    var provider = DisplayProvider;
                    if (provider == null)
                        return;
                    var tracks = provider.PresentationTracks;
                    int nbOrg = -1;
                    items = tracks;
                    if (items == null)
                        return;

                    var selected = provider.SelectedTracks;
                    if (selected.Count > 1)
                    {
                        items = selected;
                        nbOrg = 0;
                        foreach (TrackListViewModel t in tracks)
                            nbOrg++;
                    }
                    int nb = 0, nbSelected = 0, nbPresent = 0;
                    TimeSpan duration = new TimeSpan(), durationSelected = new TimeSpan(), durationPresent = new TimeSpan();
                    HashSet<int> h = new HashSet<int>();

                    foreach (TrackListViewModel track in items)
                    {
                        if (!h.Add(track.PieceGen.MasterId))
                            continue;
                        nb++;
                        duration += track.Duration;
                        if (track.Enabled)
                        {
                            nbSelected++;
                            durationSelected += track.Duration;
                        }
                        if (true == track.Exists)
                        {
                            nbPresent++;
                            durationPresent += track.Duration;
                        }
                    }

                    ITextWriter sb = new pdb.util.StringBuilder();
                    sb.Append(nb);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nb > 1)
                        sb.Append("s");
                    if (nbOrg >= 0)
                    {
                        sb.Append(" sur ");
                        sb.Append(nbOrg);
                        sb.Append(",");
                    }
                    sb.Append(" ");
                    humanDuration(sb, duration);
                    sb.Append(" ( ");
                    sb.Append(nbSelected);
                    sb.Append(" ");
                    sb.Append("elt");
                    if (nbSelected > 1)
                        sb.Append("s");
                    sb.Append(" ");
                    humanDuration(sb, durationSelected);

                    sb.Append(" )");

                    if (nbPresent > 0)
                    {
                        sb.Append(" presents: ");
                        sb.Append(nbPresent);
                        sb.Append(" ");
                        sb.Append("elt");
                        if (nb > 1)
                            sb.Append("s");
                        sb.Append(" ");
                        humanDuration(sb, durationPresent);
                    }
                    sb.Append("\t");

                    var currentTrack = TrackListViewModel.HumanSelected;
                    if (currentTrack != null)
                    {
                        humanSize(sb, currentTrack.Size);
                        sb.Append(" ");
                        sb.Append(currentTrack.Piece.Files.PathReduc);
                    }

                    newResume = sb.ToString();

                }
                catch (Exception e0)
                {
                    App.log.log(e0.ToString());
                }
                finally
                {
                    if (newResume != resume)
                    {
                        resume = newResume;
                        if (resumeChange != null)
                        {
                            try
                            {
                                resumeChange(this, EventArgs.Empty);
                            }
                            catch (Exception ex)
                            {
                                App.log.log(ex.ToString());
                            }
                        }
                    }
                }
            }
            else
            {
                App.Current.Dispatcher.BeginInvoke(new Action(makeResume), App.DISPATCHER_PRIORITY);
            }

        }

        public string Resume
        {
            get
            {
                //if (resume == null)
                //    makeResume();
                return resume;
            }
        }

        private void humanSize(ITextWriter sb, long size)
        {
            sb.Append(size.HumanReadableSize(-1));
        }

        private void humanDuration(ITextWriter sb, TimeSpan duration)
        {
            TimeSpan courant = duration;
            TimeSpan reste = new TimeSpan();
            TimeSpan ts = new TimeSpan();
            double days = duration.TotalDays;
            int idays = (int)days;

            double hours = duration.TotalHours;
            int ihours = (int)hours;


            if (days >= 1)
            {
                ts = new TimeSpan(idays, 0, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(idays);
                sb.Append("j");
                //if (idays > 1)
                //    sb.Append("s");

                hours = reste.TotalHours;
                ihours = (int)hours;

                if (ihours == 0)
                    return;
                sb.Append(" ");
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");
                return;
            }

            double mins = duration.TotalMinutes;
            int imins = (int)mins;

            if (hours > 1)
            {
                ts = new TimeSpan(ihours, 0, 0);
                reste = courant.Subtract(ts);
                sb.Append(ihours);
                sb.Append("h");
                //if (ihours > 1)
                //    sb.Append("s");

                mins = reste.TotalMinutes;
                imins = (int)mins;

                if (imins == 0)
                    return;
                sb.Append(" ");
                sb.Append(imins);
                sb.Append("m");
                //if (imins > 1)
                //    sb.Append("s");
                return;

            }

            ts = new TimeSpan(0, imins, 0);
            reste = courant.Subtract(ts);
            sb.Append(imins);
            sb.Append("m");
            //if (imins > 1)
            //    sb.Append("s");

            double secs = reste.TotalSeconds;
            int isec = (int)secs;


            if (isec == 0)
                return;
            sb.Append(" ");
            sb.Append(isec);
            sb.Append("s");
            //if (imins > 1)
            //    sb.Append("s");
            return;



        }

        # region infos

        private bool transitionState = false;
        public bool TransitionState { set { transitionState = value; OnPropertyChanged("SrcPlayPause"); } }

        public String SrcPlayPause
        {
            get
            {
                if (isHidden)
                    return @"images\Toolbar-MP3-Stop-icon.png";
                if (state != playerstate.play)
                    return @"images\Toolbar-MP3-Play-icon.png";
                return @"images\Toolbar-MP3-Pause-icon.png";
            }
        }


        //private int indexList = -1;
        //public int IndexList
        //{
        //    get { return indexList; }
        //    set
        //    {
        //        if (value != indexList)
        //        {
        //            indexList = value;
        //            this.OnPropertyChanged("IndexList");
        //        }
        //    }
        //}

        private double position = 0;
        public double Position
        {
            get
            {

                return position;
            }
            set
            {
                if (value != position)
                {
                    position = value;
                    Player.Position = value;
                    this.OnPropertyChanged("Position");
                }
            }
        }

        private String currentName;
        public String CurrentName
        {
            get { return currentName; }
            set
            {
                if (value != currentName)
                {
                    currentName = value;
                    this.OnPropertyChanged("CurrentName");
                }
            }
        }

        private double volume = 0.5;
        public double Volume
        {
            get { return volume; }
            set
            {
                if (value != volume)
                {
                    volume = value;
                    Player.Volume = value;
                    OnPropertyChanged("Volume");
                }
            }
        }


        private String currentAuthorAlbum;
        public String CurrentAuthorAlbum
        {
            get { return currentAuthorAlbum; }
            set
            {
                if (value != currentAuthorAlbum)
                {
                    currentAuthorAlbum = value;
                    this.OnPropertyChanged("CurrentAuthorAlbum");
                }
            }
        }

        private TimeSpan sinceBeginReadTrack;
        public TimeSpan ElapsedTime
        {
            get { return sinceBeginReadTrack; }
            set
            {
                if (value != sinceBeginReadTrack)
                {
                    sinceBeginReadTrack = value;
                    this.OnPropertyChanged("ElapsedTime");
                }
            }
        }

        private TimeSpan remainingTime;
        public TimeSpan RemainingTime
        {
            get { return remainingTime; }
            set
            {
                if (value != remainingTime)
                {
                    remainingTime = value;
                    this.OnPropertyChanged("RemainingTime");
                }
            }
        }

        private TimeSpan length;
        public TimeSpan Length
        {
            get { return length; }
            set
            {
                if (value != length && value > TimeSpan.FromMilliseconds(100))
                {
                    length = value;
                    this.OnPropertyChanged("Length");
                }
            }
        }
        #endregion
    }
}
]]></content>
  </file>
  <file path="\pdb.player\ViewModel\Commande\RefreshAlbum.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.player.ViewModel.Commande
{
    class RefreshAlbum : CommandeBase
    {

        public override bool CanExecute(object parameter)
        {
            var track = TrackListViewModel.HumanSelected;
            if (track == null)
                return false;
            if (!track.ExistsNow)
                return false;
            return true;
        }

        public override void Execute(object parameter)
        {          
            App.gen.Albums.makeSort(TrackListViewModel.HumanSelected.PieceGen, Logger.defaultLogger);
        }
    }
}]]></content>
  </file>
  <file path="\pdb.util\Logger.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;

namespace pdb.util
{
    /// <summary>
    /// Logger
    /// </summary>
    public class Logger : ILogger
    {

        /// <summary>
        /// Thread de dépilage
        /// </summary>
        private static Thread th;
        /// <summary>
        /// Thread de cloture des flux
        /// </summary>
        private static Thread thDispose;
        /// <summary>
        /// Queue de logs à écrire
        /// </summary>
        private static Queue<KeyString> queue = new Queue<KeyString>();

        private static Queue<Logger> queueDispose = new Queue<Logger>();
        /// <summary>
        /// flux du log
        /// </summary>
        private StreamWriter sw;
        /// <summary>
        /// Chemin relatif du log
        /// </summary>
        private string logPath;
        /// <summary>
        /// Objet de synchro
        /// </summary>
        private static volatile object _lock = new object();
        /// <summary>
        /// Registre des logs
        /// </summary>
        private static Dict<string, Logger> loggers = new Dict<string, Logger>();
        /// <summary>
        /// Log par défaut
        /// </summary>
        public static Logger defaultLogger; //= new Logger("log");
        /// <summary>
        /// Log universel pour répercution sur tous les logs des principaux évènements
        /// </summary>
        private static Logger all = new Logger("all");

        private static LoggerConsole console = new LoggerConsole();

        private bool logConsole = true;

        private bool noReset;
        public static bool  LogConsole = true; 
       // public bool LogConsole { get { return logConsole; } set { logConsole = value; } }
        public bool NoReset { get { return noReset; } set { noReset = value; } }

        /// <summary>
        /// Logger aboné en sus
        /// </summary>
        private Logger parent;

        private static bool createNullLoggers;
        private readonly bool isNull;
        public static bool CreateNullLoggers { get { return false; } set {  } }


        /// <summary>
        /// Constructeur statique fait le ménage dans les logs
        /// </summary>
        public static void init(string name)
        {
            Locker.waitForSingleProcess(name);
            try
            {
                DirectoryInfo dir = new DirectoryInfo(@"..\Logs");
                new Thread(() =>
                {
                    misc.DeleteDir(dir);
                    Thread.Sleep(1000);
                    defaultLogger = getLogger("log", true);
                }).Start();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }
        }



        /// <summary>
        /// Création ou récupération d'un logger
        /// </summary>
        /// <param name="logPath"></param>
        /// <returns></returns>
        public static Logger getLogger(string logPath)
        {
            return getLogger(logPath, defaultLogger);
        }


        /// <summary>
        /// Création ou récupération d'un logger
        /// </summary>
        /// <param name="logPath"></param>
        /// <returns></returns>
        public static Logger getLogger(string logPath, bool logConsole)
        {
            var log = getLogger(logPath, defaultLogger);
            log.logConsole = logConsole;
            return log;
        }


        /// <summary>
        /// Création ou récupération d'un logger
        /// </summary>
        /// <param name="logPath"></param>
        /// <returns></returns>
        public static Logger getLogger(string logPath, Logger parent)
        {
            return getLogger(logPath, parent, null);
        }


        /// <summary>
        /// Création ou récupération d'un logger
        /// </summary>
        /// <param name="logPath"></param>
        /// <returns></returns>
        public static Logger getLogger(string logPath, Logger parent, bool? logConsole)
        {
            Logger log = loggers[logPath];
            if (log == null)
            {
                lock (_lock)
                {
                    if (loggers[logPath] == null)
                    {
                        log = new Logger(logPath);
                        if (logConsole.HasValue)
                            log.logConsole = logConsole.Value;
                        else if (parent != null)
                            log.logConsole = parent.logConsole;
                        log.parent = parent;
                        loggers[logPath] = log;
                    }
                }
            }
            return log;
        }

        private static ILogger _def = new DefaultLogger();
        public static ILogger getLogger()
        {
            if (defaultLogger == null)
                return _def;
            return defaultLogger;
        }

        /// <summary>
        /// Création du flux si besoin
        /// </summary>
        private void checkStream()
        {
            if (!_resetting && sw != null)
                return;
            lock (this)
            {
                if (!_resetting && sw != null)
                    return;
                if (_resetting)
                    return;
            }

            var _logPat = logPath;
            try
            {

                //foreach (char c in Path.GetInvalidPathChars())
                //    _logPat = _logPat.Replace(c, '_');
                //foreach (char c in Path.GetInvalidFileNameChars())
                //    _logPat = _logPat.Replace(c, '_');


                byte[] tempBytes;
                tempBytes = System.Text.Encoding.GetEncoding("ISO-8859-8").GetBytes(logPath);
                _logPat = System.Text.Encoding.UTF8.GetString(tempBytes);

                foreach (char c in Path.GetInvalidPathChars())
                    _logPat = _logPat.Replace(c, '_');

                //  _logPat = logPath.Normalize(System.Text.NormalizationForm.FormC).Normalize(System.Text.NormalizationForm.FormD);
                //FileInfo file = new FileInfo(@"..\Logs\" + _logPat + ".log");
                string fileBase = @"..\Logs\" + _logPat + ".log";

                String[] dirs = fileBase.Split(Path.DirectorySeparatorChar);

                for (int i = 0; i < dirs.GetLength(0); i++)
                {
                    string dir = dirs[i];
                    tempBytes = System.Text.Encoding.GetEncoding("ISO-8859-8").GetBytes(dir);
                    dir = System.Text.Encoding.UTF8.GetString(tempBytes);

                    foreach (char c in Path.GetInvalidFileNameChars())
                        dir = dir.Replace(c, '_');
                    dirs[i] = dir;
                }

                DirectoryInfo root = new DirectoryInfo(dirs[0] + Path.DirectorySeparatorChar);
                for (int i = 1; i < dirs.GetLength(0) - 1; i++)
                {
                    String strDir0 = dirs[i] + Path.DirectorySeparatorChar;
                    String StrDir = root.FullName + strDir0;
                    DirectoryInfo dir = new DirectoryInfo(StrDir);
                    if (!dir.Exists)
                        dir.Create();
                    root = dir;
                }
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < dirs.GetLength(0); i++)
                {
                    if (i > 0)
                        sb.Append(Path.DirectorySeparatorChar);
                    sb.Append(dirs[i]);
                }

                try
                {

                    sw = new StreamWriter(sb.ToString(), false);
                    sw.AutoFlush = true;
                    DisposableCounter.add(sw, logPath);
                }
                catch
                {
                    return;
                }
            }
            catch (Exception ex)
            {
                try
                {
                    Console.WriteLine("impossible de créer le flux " + logPath + "(" + _logPat + ") " + ex.ToString());
                    defaultLogger.log_("impossible de créer le flux " + logPath + "(" + _logPat + ") " + ex.ToString());
                }

                catch
                {
                }
            }

            return;

        }



        /// <summary>
        /// Constructeur privé. Initie la boucle de dépilage. bof
        /// </summary>
        /// <param name="logPath"></param>
        private Logger(string logPath)
        {
            this.logPath = logPath;
            if (createNullLoggers)
                isNull = true; 

            if (th == null)
            {
                lock (_lock)
                {
                    if (th == null)
                    {
                        th = new Thread(_loop);
                        th.Start();

                        thDispose = new Thread(_loopDispose);
                        thDispose.Start();
                    }
                }
            }




        }

        /// <summary>
        /// Ecrit la ligne
        /// </summary>
        /// <param name="txt"></param>
        private void log_(string txt)
        {
            if (isNull)
                return; 
            if (_end)
                return; 
            try
            {
                checkStream();
                if (sw == null || _resetting)
                {
                    relog(txt);
                    return;
                }
                lock (this)
                {
                    if (sw == null || _resetting)
                    {
                        relog(txt);
                        return;
                    }
                    sw.WriteLine(txt);
                    sw.Flush();
                }
            }
            catch (Exception ex)
            {
                console.log(ex.ToString());
                sw = null;
            }
        }

        private void relog(string txt)
        {
            if (isNull)
                return; 
            var ks = new KeyString(logPath, txt, false,false);
            lock (this)
                queue.EnQueue(ks);

        }

        /// <summary>
        /// Ecrit sur tous les loggers
        /// </summary>
        /// <param name="txt"></param>
        public static void LogAll(string txt)
        {
            all.log(txt);
        }

        private static void _loopDispose()
        {
            while (!_end)
            {
                try
                {
                    Thread.Sleep(30);
                    Logger log = queueDispose.Dequeue();
                    if (log != null)
                        Console.WriteLine("close " + log.logPath);
                    while (log != null)
                    {
                        if (_end)
                            return; 
                        try
                        {
                            var st = log.sw;
                            if (st != null)
                                st.Close();
                        }
                        catch (Exception ex1)
                        {
                            Console.WriteLine(ex1.ToString());
                            Thread.Sleep(1000);
                        }
                        lock (log)
                        {
                            log.sw = null;
                            log._resetting = false;
                        }
                        log = queueDispose.Dequeue();

                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                    Thread.Sleep(1000);
                }
            }
        }


        /// <summary>
        /// Boucle de dépilage
        /// </summary>
        private static void _loop()
        {
            while (!_end)
            {

                try
                {
                    Thread.Sleep(30);
                    // BOF
                    KeyString ks = null;
                    //lock (_lock)
                    //{
                    ks = queue.Dequeue();
                    //}

                    if (_end)
                        return; 
                    while (ks != null)
                    {
                        string defaultLog = ks.txt;  // ToString();

                    //    bool bLogConsole = ks.LogConsole; 

                        string key = ks.key;
                        // Cas log universel
                        if ("all".Equals(key))
                        {
                          //  bLogConsole = true;
                            List<Logger> list = null;
                            lock (_lock)
                            {
                                list = new List<Logger>(loggers.Values);
                            }
                            foreach (Logger _log in list)
                            {
                                if (_log.sw != null)
                                    _log.log_(ks.txt);

                            }
                        }
                        // cas standard : on indentifie le logger
                        else
                        {
                            Logger logger_ = loggers[key];
                            //if (logger_ != null)
                            //    bLogConsole = ks.LogConsole; // logger_.logConsole;
                            while (logger_ != null)
                            {
                                logger_.log_(ks.txt);
                                logger_ = logger_.parent;
                            }
                            //if (defaultLogger != logger)
                            //    defaultLogger.log_(defaultLog);
                        }

                        //lock (_lock)
                        //{

                        if (ks.LogConsole && ks.FirstTry)
                            console.log(defaultLog);
                        ks = queue.Dequeue();
                        //}
                    }
                }
                catch (Exception ex)
                {
                    console.log(ex.ToString());
                    Thread.Sleep(1000);
                }


            }
        }
        #region ILogger Membres

        private static string pre = "";
        public static string Pre { set { pre = value; } }

        private string getThreadName()
        {
            Thread th = Thread.CurrentThread;
            string name = th.Name;
            if (name == null)
                name = th.ManagedThreadId.ToString();
            return string.Format(" [{0}] ", name);
        }



        public void log(string txt)
        {
            if (isNull)
                return; 
            put(pre + DateTime.Now.ToLongTimeString() + getThreadName() + txt);
        }

        public void log(string txt, params object[] other)
        {
            if (isNull)
                return; 
            put(pre + DateTime.Now.ToLongTimeString() + getThreadName() + txt, other);
        }
        public void logNoDate(string txt, params object[] other)
        {
            if (isNull)
                return; 
            put(pre + getThreadName() + txt, other);
        }
        public void logNoDate(string txt)
        {
            if (isNull)
                return; 
            put(pre + getThreadName() + txt);
        }
        private void put(string txt, params object[] other)
        {
            if (isNull)
                return; 
            //string realTxt = txt; 
            // if (other.GetLength(0) == 0)
            //{ realTxt = txt; }
            //else
            //{   realTxt = String.Format(txt, other);}

            //log_(realTxt); 
            //Console.WriteLine(realTxt); 
            //return; 



            if (_end)
                return; 

            lock (this)
            {
                try
                {

                    if (other.GetLength(0) == 0)
                        queue.EnQueue(new KeyString(logPath, txt, true, logConsole && LogConsole));
                    else
                        queue.EnQueue(new KeyString(logPath, String.Format(txt, other), true, logConsole && LogConsole));
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.ToString());
                    var sb = new StringBuilder();
                    sb.Append(txt); sb.Append(":");
                    foreach (object o in other)
                        sb.Append(o); sb.Append(",");
                    queue.EnQueue(new KeyString(logPath, sb.ToString(), true,logConsole && LogConsole));

                }
            }
        }

        #endregion



        string ILogger.Pre
        {
            set { pre = value; }
        }

        private void end()
        {
            lock (this)
            {
                Console.WriteLine("end " + logPath);
                if (sw == null)
                    return;
                sw.Flush();
                sw.Dispose();
                DisposableCounter.remove(sw);
                sw = null;
            }
        }

        private bool _resetting;
        public void reset()
        {
            if (!noReset)
            {
                lock (this)
                {
                    _resetting = true;
                    queueDispose.EnQueue(this);
                }
            }
        }

        public static void Reset()
        {
            lock (_lock)
            {
                Console.WriteLine("logger::Reset");
                foreach (Logger logger in new List<Logger>(loggers.Values))
                    logger.reset();
                Console.WriteLine("logger::Reset OK");
            }
        }

        private static bool _end; 
        public static void End()
        {
            _end = true; 
            lock (_lock)
            {
                queueDispose.Clear(); 
                Console.WriteLine("logger::End");
                foreach (Logger logger in new List<Logger>(loggers.Values))
                    logger.end();
                Console.WriteLine("logger::End OK");
            }

        }


        public void Error(string txt)
        {
            log("Error " + txt);
        }

        public void Error(string txt, params object[] other)
        {
            log("Error " + txt, other);
        }
    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using pdb.gen.conf;
using System.Xml;
using System.Text;
using System.IO;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        public const string FILE_ALBUMS = @"..\conf\albums.xml";
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
        }

        /// <summary>
        /// référence constante des albums
        /// </summary>
     //   private BgDictString<Album> dict0 = new BgDictString<Album>();
        /// <summary>
        /// Albums réels ou virtuels
        /// </summary>
        private BgDictString<Album> dict = new BgDictString<Album>();
        public BgDictString<Album> Dict { get { return dict; } }
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object();
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }


        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                //foreach (Album album in dict0.Values)
                //{
                //    album.checkBuild();
                //}
                dict.Clear();
            }
        }

        private string getKey(string _album, virtualMode mode)
        {
            return Album.getKey(_album, mode);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                var confGen = CConf.ConfGen;
                var min1 = confGen.AlbumMin;
                var min2 = confGen.PathVirtualMin;
                var min3 = confGen.ArtistVirtualMin;
                foreach (Album album in new List<Album>(dict.Values))
                {
                    int count = album.Count;
                    bool toKeep = album.buildDone();
                    if (toKeep)
                    {

                        if (album.Virtual)
                        {
                            if (album.VirtualByArtist)
                            {
                                if (min3 > 1 && count < min3)
                                    toKeep = false;
                            }
                            else if (min2 > 1 && count < min2)
                                toKeep = false;
                        }
                        else if (min1 > 1 && count < min1)
                            toKeep = false;



                        if (!toKeep)
                        {
                            //album.Clear(); 
                            // misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }

                    }

                }


            }
        }



        private bool check_(Piece piece, string albumOrg, virtualMode mode, IDictionary<string, Album> dict)
        {
            string key = getKey(albumOrg, mode);


            var album = dict[key];
            if (album == null)
            {
                //album = dict0[key];
                //if (album == null)
                //{
                //  misc.log("creation album {0}", __album);
                album = new Album(albumOrg, key);
                album.setVirtual(mode);
                dict.Add(key, album);
                // dict0.Add(key, album);

            }

            //  }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualMode, dict);
        }

        public int Count { get { return dict.Count; } }
        public static int RankZero { get; set; }



        const char SEP = ';';
        const char SEP_TRACK = ',';

        public void sortVirtual()
        {
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }


            var listAlbums = new List<Album>(dict.Values);
            listAlbums.Sort(new VirtualAlbumComparer());

            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;

            //using (StreamWriter sw = new StreamWriter(FILE_ALBUMS + ".tmp"))
            //{
            //    foreach (Album album in listAlbums)
            //    {
            //        if (!album.Virtual)
            //            continue;

            //        sw.Write(album.VirtualMode);
            //        sw.Write(SEP);

            //        sw.Write(album.Name);
            //        sw.Write(SEP);

            //        var list = album.RawList;
            //        list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //        bool begin = false;
            //        foreach (Piece p in list)
            //        {
            //            if (begin)
            //                sw.Write(SEP_TRACK);
            //            else
            //                begin = true;
            //            sw.Write(p.MasterId);
            //        }
            //        sw.WriteLine();

            //    }

            //}

            using (XmlWriter writer = XmlWriter.Create(FILE_ALBUMS + ".tmp", settings))
            {
                writer.WriteStartElement("albums");
                foreach (Album album in listAlbums)
                {
                    if (!album.Virtual)
                        continue;
                    writer.WriteStartElement("a");
                    writer.WriteAttributeString("mode", album.VirtualMode.ToString());
                    writer.WriteAttributeString("name", album.Name);
                    var list = album.RawList;
                    list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
                    bool begin = false;
                    var sb = new System.Text.StringBuilder();
                    foreach (Piece p in list)
                    {
                        if (begin)
                            sb.Append(SEP_TRACK);
                        else
                            begin = true;
                        sb.Append(p.MasterId);
                    }

                    writer.WriteString(sb.ToString());

                    //foreach (Piece p in list)
                    //{
                    //    writer.WriteElementString("t", p.MasterId.ToString());
                    //}
                    writer.WriteEndElement();
                }


                writer.WriteEndDocument();
                writer.Flush();
            }

            System.IO.File.Copy(FILE_ALBUMS + ".tmp", FILE_ALBUMS, true);

        }

        public int load(IDictionary<int, Piece> dict)
        {

            //using (StreamReader sr = new StreamReader(FILE_ALBUMS))
            //{

            //    var line = sr.ReadLine();
            //    var tabs = line.Split(SEP);
            //    int count = tabs.GetLength(0); 

            //    var name = tabs[1];
            //    var mode = (virtualMode)Enum.Parse(typeof(virtualMode), tabs[0], true);
            //    Album current = new Album(name, mode);
            //    this.dict.Add(current.Key, current);
            //    int tn = 0;
            //    var tracks = tabs[2].Split(SEP_TRACK);
            //    foreach (string sid in tracks)
            //    {
            //        tn++;
            //        var id = Convert.ToInt32(sid);
            //        Piece track = dict[id];
            //        VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
            //        virt.TrackNumber = tn;
            //        current.add(virt);
            //    }


            //}
            int nbLoad = 0;
            using (XmlReader reader = XmlReader.Create(FILE_ALBUMS))
            {
                Album current = null;

                while (reader.Read())
                {
                    if (reader.NodeType == XmlNodeType.Element)
                    {

                        if (reader.Name == "a")
                        {
                            var name = reader.GetAttribute("name");
                            var mode = (virtualMode)Enum.Parse(typeof(virtualMode), reader.GetAttribute("mode"), true);
                            current = new Album(name, mode);
                            int tn = 0;
                            this.dict.Add(current.Key, current);


                            var line = reader.ReadElementString();
                            foreach (string sid in line.Split(SEP_TRACK))
                            {
                                tn++;
                                var id = Convert.ToInt32(sid);
                                Piece track = dict[id];
                                VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
                                virt.TrackNumber = tn;
                                current.add(virt);
                            }

                            nbLoad++;

                        }



                        //else if (reader.Name == "t")
                        //{
                        //    tn++;
                        //    var id = reader.ReadElementContentAsInt();
                        //    Piece track = dict[id];
                        //    VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
                        //    virt.TrackNumber = tn;
                        //    current.add(virt);

                        //}

                    }
                }

            }
            return nbLoad;
        }

        //public void consolidChilds()
        //{
        //    misc.log("consolidChilds");
        //    foreach (Album album in dict.Values)
        //    {
        //        album.ConsolidChilds();
        //    }
        //}

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {

            if (piece.Virtual)
            {
                if (!check_(piece, dict))
                {
                }
                // piece.setParent(null);
            }

        }

        public Album getAlbum(Piece piece)
        {
            return piece.PieceAlbum;
            //string __album = "-";
            //var _album = piece.Album;
            //if (!string.IsNullOrEmpty(_album))
            //{
            //    __album = _album.Trim();
            //    return dict[__album];
            //}
            //return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            var now = DateTime.Now;
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
            misc.log("buildStack; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
        }

       // private Dictionary<string, Album> invalidated;
        public IDictionary<string, Album> GetAndInvalidateAlbums(Piece piece)
        {
           var invalidated = new Dictionary<string, Album>();
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;

                album.refreshLight();
                invalidated.Add(album.Key, album);
            }
            return invalidated;
        }

        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public int makeSort(Piece piece, ILogger logger)
        {
            if (piece == null)
                return 0;
            int nb = 0;
            //var album = piece.PieceAlbum;
            //if (album == null)
            //    return;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;

                album.refreshLight();
                album.makeSort(confMedianne, conf0); //listRef, reference); 
                logger.log("make Sort " + album);
                nb++;
                //  album.mustRefresh();
                // pour futures mises au point avec la MAJ des classements( resetOneCl et Compact )
                album.refreshLight();
            }

            return nb;

        }

        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public int makeSort(IEnumerable<Album> _albums, ILogger logger)
        {
            int nb = 0;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Album album in _albums)
            {
                if (album == null)
                    continue;

                album.refreshLight();
                album.makeSort(confMedianne, conf0); //listRef, reference); 
                logger.log("make Sort " + album);
                nb++;
                //  album.mustRefresh();
                // pour futures mises au point avec la MAJ des classements( resetOneCl et Compact )
                // album.refreshLight();
            }

            foreach (Album album in _albums)
            {
                if (album == null)
                    continue;
                album.refreshLight();
            }

            return nb;

        }

        // private int nbSort=1;
        //private bool urgence;
        //public void setUrgence() { urgence = true; }
        //public bool Urgence { get { return urgence; } } 
        public void makeSort(bool sortAll, IClient client)
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var main = confMedianne.Main;
                var min = confMedianne.Min;
                var mainCoeffVirt = main.coeffVirt;
                var mainCoeffOld = main.CoeffOld;

                var minCoeffVirt = min.coeffVirt;
                var minCoeffOld = min.CoeffOld;




                if (confSort.reset)
                {
                    main.coeffVirt = 1;
                    main.CoeffOld = 1;
                    min.coeffVirt = 1;
                    min.CoeffOld = 1;
                }

                List<Album> list = new List<Album>(dict.Values);
                List<Album> listw = list;
                HashSet<Album> hs = null;
                DateTime now = DateTime.Now;
                DateTime debut = now;

                bool partial = false;
#if GEN2
                partial = !sortAll && confSort.optimSize > 0 && consolid.Urgence;
#endif

                int step = 0;
                Album last = null;
                // int coeffSort = 1;

                while (true)
                {
                    step++;

                    if (partial)
                    {
                        //nbSort++;
                        //coeffSort = 1; 

                        //int _nbSort = nbSort;
                        //while (_nbSort >=2 && _nbSort % 2 == 0)
                        //{
                        //    coeffSort *= 2;
                        //    _nbSort /= 2; 
                        //}
                        hs = new HashSet<Album>();
                        list.Sort(new AlbumClassComparer2());
                        list.Reverse();
                        listw = new List<Album>();
                        decimal equivLightMax = 0;
                        decimal equivLightZeroMax = 0;
                        int nb = 0;
                        int max = step * confSort.optimSize; // *coeffSort;

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                nb++;
                                listw.Add(a);
                                hs.Add(a);

                                var _classementValueLight = a.ClassementValueLight;
                                if (_classementValueLight > equivLightMax)
                                {
                                    equivLightMax = _classementValueLight;
                                    last = a;
                                }

                                var _classementValueLightZero = a.ClassementValueLightZero;

                                if (_classementValueLightZero > equivLightZeroMax)
                                {
                                    equivLightZeroMax = _classementValueLightZero;
                                    last = a;
                                }

                                if (nb >= max)
                                    break;
                            }
                        }


                        var equivZeroVerif = equivLightZeroMax * pdb.util.Math.Pow(main.coeffVirt, main.safe) * pdb.util.Math.Pow(min.coeffVirt, min.safe) * main.CoeffOld * min.CoeffOld;
                        var dxMin = min.dcoeff;
                        var dxMain = pdb.util.Math.Pow(main.dcoeff, main.safe);
                        var equivVerif = equivLightMax * (dxMain * dxMin);

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                var _classementValueLight = a.ClassementValueLight;


                                if (_classementValueLight < equivVerif && _classementValueLight < equivZeroVerif)
                                {
                                    if (hs.Add(a))
                                    {
                                        listw.Add(a);
                                        if (_classementValueLight > equivLightMax)
                                        {
                                            equivLightMax = _classementValueLight;
                                            last = a;
                                        }

                                    }
                                }

                            }
                        }

                    }
                    if (!consolid.Urgence)
                    {
                        int nbSorted = 0;
                        //if (invalidated != null && invalidated.Count > 0)
                        //{
                        //    listw = new List<Album>(invalidated.Values);
                        //    invalidated = null;
                        //}

                        foreach (Album album in listw)
                        {
                            if (client.Cancel)
                                return;
                            if (album.makeSort(confMedianne, conf0)) //listRef, reference); 
                                nbSorted++;
                        }

                        string infoAlbum = "";
                        if (last != null)
                        {
                            infoAlbum = string.Format("last={0} {1} {2} {3}", last.Tracks[0].RankAlbumReverse, last.EquivLight0, last.EquivLight, last);
                        }
                        //   misc.log(string.Format("makeSort : nbSort={0} coeffSort={1} step={2}  {3} albums {4} ms {5}", nbSort, coeffSort, step, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        misc.log(string.Format("makeSort : step={0}  {1}/{2} albums {3} ms {4}", step, nbSorted, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        client.log(string.Format("album.makeSort {0} elt", nbSorted));
                    }
                    now = DateTime.Now;
                    //if (confSort.reset)
                    //{
                    main.coeffVirt = mainCoeffVirt;
                    main.CoeffOld = mainCoeffOld;
                    min.coeffVirt = minCoeffVirt;
                    min.CoeffOld = minCoeffOld;

                    // }


                    list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                    misc.log("list.Sort(new AlbumClassComparer {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


                    list.Reverse();
                    misc.log("list.Reverse(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    client.log("AlbumClassComparer");

                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (album.AtLeastOneEnabled)
                            RankZero = i + 2;
                        album.Quality = i + 1;
                    }
                    client.log("album.Quality");
                    misc.log("album.Quality {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    if (!partial)
                        break;


                    list.Reverse();

                    int nbCheck = 0;
                    bool? check = null;
                    foreach (Album a in list)
                    {
                        if (!a.AtLeastOneEnabled)
                            continue;
                        if (hs.Contains(a))
                        {
                            nbCheck++;
                            if (nbCheck >= confSort.optimCheck) // * coeffSort)
                            {
                                check = true;
                                break;
                            }
                        }
                        else
                        {
                            check = false;
                            break;
                        }


                    }

                    if (check == null || check.Value)
                        break;

                }


                misc.log(string.Format("makeSort albums total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));

                List<Album> listSt = null;
                List<Album> list0 = null;
                List<Album> listSt0 = null;


                if (confSort.sortSt || confSort.correcMainRank || confSort.correcMainCoeff || confSort.correcMainZero)
                {
                    listSt = new List<Album>(list);

                    listSt.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                    listSt.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        listSt[i].RankSt = i + 1;
                    }
                    misc.log(string.Format("sort St : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sort0)
                {
                    now = DateTime.Now;
                    list0 = new List<Album>(list);

                    list0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                    list0.Reverse();
                    for (int i = 0; i < list0.Count; i++)
                    {
                        list0[i].RankZero = i + 1;
                    }
                    misc.log(string.Format("sort 0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sortSt0 || confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    listSt0 = new List<Album>(list);

                    listSt0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, conf0));
                    listSt0.Reverse();
                    for (int i = 0; i < listSt0.Count; i++)
                    {
                        listSt0[i].RankZeroSt = i + 1;
                    }
                    misc.log(string.Format("sort St0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                client.log("tri pour faire joli");
#if GEN2
                if (confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;

                                if (o.RankZero > un.RankZero)
                                {
                                    correc = false;
                                    break;
                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }
                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }



                    //now = DateTime.Now;
                    //for (int i = listSt.Count - 1; i >= 0; i--)
                    //{
                    //    Album un = listSt[i];
                    //    Album zero = listSt0[i];
                    //    if (un.DontTouchSelectedCoeff)
                    //        continue;
                    //    if (un == zero)
                    //        un.InvalidateMain();
                    //}
                    misc.log(string.Format("correcMainRank : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainCoeff)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLightSt * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLightSt;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }
                    misc.log(string.Format("correcMainCoeff : {0} ms", (DateTime.Now - now).TotalMilliseconds));

                }
                if (confSort.correcMainZero)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {




                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                if (o.Name == "Ill Communication")
                                {
                                }
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;


                                if (o.ClassementValueLightZeroSt < un.ClassementValueLightZeroSt)
                                {
                                    if (o.RankZero > un.RankZero)
                                    {
                                        correc = false;
                                        break;
                                    }
                                }

                                if (!unClassementRecent)
                                {
                                    if (o.ClassementValueLightZeroSt == un.ClassementValueLightZeroSt)
                                    {
                                        if (confSort.correcMainZeroCheckEquality)
                                        {
                                            if (onext.LastClassementRecent)
                                            {
                                                if (o.RankZero > un.RankZero)
                                                {
                                                    correc = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }


                                //if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //    break;
                                // }



                                //if (o.RankSt <= un.RankSt)
                                //{
                                //    if (o.RankZeroSt > un.RankZeroSt)
                                //    {
                                //        correc = false;
                                //        break;
                                //    }

                                //    if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //        break;
                                //}

                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }


                    misc.log(string.Format("correcMainZero : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

#endif


                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}
                var limit = CConf.ConfGen.LimitAlbums;
                if (limit > 0)
                {
                    var l = new List<Album>();
                    list.Sort(new AlbumClassComparer2());
                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (i < limit)
                        {
                            l.Add(album);
                            album.ConsolidChilds();
                            album.sortVirtual();
                        }
                        else
                        {
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }
                    }
                    list = l;

                }

                misc.log(string.Format("makeSort total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var now = DateTime.Now;
            var list = new List<Album>(dict.Values);

            //var confGen = CConf.ConfGen;
            //var min1 = confGen.AlbumMin;
            //var min2 = confGen.PathVirtualMin;
            //var min3 = confGen.AristVirtualMin;
            //foreach (Album album in dict.Values)
            //{
            //    int count = album.Count;
            //    bool toKeep = true;


            //    if (album.Virtual)
            //    {
            //        if (album.VirtualByArtist)
            //        {
            //            if (min3 > 1 && count < min3)
            //                toKeep = false;
            //        }
            //        else if (min2 > 1 && count < min2)
            //            toKeep = false;
            //    }
            //    else if (min1 > 1 && count < min1)
            //        toKeep = false;



            //    if (!toKeep)
            //    {
            //        misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
            //    }
            //    else
            //        list.Add(album);

            //}

            foreach (Album album in list)
            {
                album.makeSelection();
            }
            //list.Sort(new AlbumRestComparer());
            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankRest = i + 1;
            //}

            misc.log(string.Format("make selection : {0} ms", (DateTime.Now - now).TotalMilliseconds));
            return list;
        }

        //public void changeAlbum(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Album, false)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();
        //    check_(p, newA, false, this.dict);
        //    var newAlb = dict[getKey(newA, false)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();

        //    //  invalidate(p); 
        //}

        //public void changeArtist(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Artist, true)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();

        //    check_(p, newA, true, this.dict);
        //    var newAlb = dict[getKey(newA, true)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();
        //}

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                //if (candidat.VirtualMode == virtualMode.added)
                //{
                //    if (candidat.Name=="09/1012")
                //    {

                //    }
                //    if (candidat.Name =="22/09/2012")
                //    {

                //    }
                //}
                bool found = false;

                foreach (Piece p in candidat)
                {
                    var master = p.Master.PieceAlbum;
                    if (master.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    foreach (Album album in dict.Values)
                    {
                        if (album.isSameOf(candidat))
                        {
                            found = true;
                            break;
                        }
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.ClearAndMenage();
                }
                else
                {
                    // on le prend.
                    string key = getKey(candidat.Name, candidat.VirtualMode);
                    //if (!dict0.ContainsKey(key))
                    //    dict0.Add(key, candidat);
                    dict.Add(key, candidat);
                    foreach (Piece p in candidat)
                    {
                        //   p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }


        public List<Album> RawList
        {
            get
            {
                return new List<Album>(dict.Values);
            }
        }

        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(Piece track)
        {
            track.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track);

        }

        #region invalider


        public void invalidateAll(bool total)
        {
            foreach (var a in dict.Values)
            {
                if (total)
                    a.mustRefresh();
                else
                    a.refreshLight();
            }
        }
        //public void invalidate(Piece piece)
        //{
        //    foreach (var p in piece.Master)
        //    {
        //        var key = getKey(p.Album, p.VirtualByArtist);
        //        var a = dict[key];
        //        if (a == null)
        //        {
        //        }
        //        else
        //            a.invalidate();
        //        //if (p.Virtual)
        //        //    continue; 
        //        ////1. check standard
        //        //var key = getKey(p.Album, false);
        //        //var a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 
        //        ////2. check artiste
        //        //key = getKey(p.Artist, true);
        //        //a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 

        //        ////3. check paths
        //        //foreach (string path in p.getIntermediaryPath())
        //        //{
        //        //    key = getKey(path, false);
        //        //    a = dict[key];
        //        //    if (a == null)
        //        //    {
        //        //    }
        //        //    else
        //        //        a.invalidate(); 
        //        //}
        //    }
        //}
        #endregion






    }
}
]]></content>
  </file>
  <file path="\PieceDb.Consolid\Tuning\CConf.cs">
    <content><![CDATA[using System;
using System.IO;
using System.Xml;
using pdb.gen.Tuning;
using pdb.ordo.conf;
using pdb.util;
using pdb.gen.albums;
namespace pdb.gen.conf
{
    public enum rankingType
    {
        middle = 0,
        up = 1,
        bottom = 2
    }


    public class CConf
    {
        private static volatile object _lock = new object();
        private const string CONF_FILE = TuningBase.DIR_CONF + "pdb.conf.xml";
        private static string m_listBase = "classement";
        private static int m_before = 0;
        private static int m_after = 0;
        private static bool m_checkModifStrict = true;
        private static bool scan = false;
        private static string copyTo = "";
        private static bool copyModeFile = false;
        private static CConfSort m_sort = new CConfSort();
        private static int classementOffset = 0;
        private static rankingType _rankingType = rankingType.middle;
        // private static bool deleteFile;
        private static int maxTask = int.MaxValue;

        private static CConfSort m_select = new CConfSort();
        private static ConfGen confGen = new ConfGen();

        private static bool removeVersions;
        private static bool condensation;
        private static bool resetOneCl;

        // private static int taskDelayError = -1;

        private static bool menage = false;


        private static bool ordonnancement;

        //  private static DataConf dataConf;
        private static ConfOrdo ordoConf = new ConfOrdo();



        private static int volumeMin = -125;
        private static bool abortOpe;

        private static Export export = new Export();
        private static Import import = new Import();

        /// <summary>
        /// Temps en secondes entre deux gcCollect
        /// </summary>
        private static double gcCollect = int.MaxValue;

        private static int colorMotifSeuil = 1;

        private static bool compact;

        private static bool filterNext;

        public static XmlElement loadConf()
        {
            lock (_lock)
            {
                misc.log("load conf");
                if (!File.Exists(CONF_FILE))
                    return null;
                XmlDocument l_doc = new XmlDocument();
                l_doc.Load(CONF_FILE);
                XmlElement l_xmlRoot = l_doc.DocumentElement;
                XMLTool l_xmlConf = new XMLTool(l_xmlRoot);

                string l_str = l_xmlConf.getNodeValue("listBase");
                if (!string.IsNullOrEmpty(l_str))
                    m_listBase = l_str;

                l_str = l_xmlConf.getNodeValue("before");
                if (!string.IsNullOrEmpty(l_str))
                    m_before = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("after");
                if (!string.IsNullOrEmpty(l_str))
                    m_after = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("checkModifStrict");
                if (!string.IsNullOrEmpty(l_str))
                    m_checkModifStrict = Convert.ToBoolean(l_str);

                l_str = l_xmlConf.getNodeValue("scan");
                if (!string.IsNullOrEmpty(l_str))
                    scan = Convert.ToBoolean(l_str);

                l_str = l_xmlConf.getNodeValue("copyTo");
                if (!string.IsNullOrEmpty(l_str))
                {
                    copyTo = l_str;
                    l_str = l_xmlConf.getAttValue("copyTo", "copyModeFile");
                    if (!string.IsNullOrEmpty(l_str))
                        copyModeFile = Convert.ToBoolean(l_str);
                }

                l_str = l_xmlConf.getNodeValue("classementOffset");
                if (!string.IsNullOrEmpty(l_str))
                    classementOffset = Convert.ToInt32(l_str);
                l_str = l_xmlConf.getNodeValue("rankingType");
                if (!string.IsNullOrEmpty(l_str))
                    _rankingType = (rankingType)Enum.Parse(typeof(rankingType), l_str);



                l_str = l_xmlConf.getNodeValue("maxTask");
                if (!string.IsNullOrEmpty(l_str))
                    maxTask = Convert.ToInt32(l_str);







                l_str = l_xmlConf.getNodeValue("volumeMin");
                if (!string.IsNullOrEmpty(l_str))
                    volumeMin = Convert.ToInt32(l_str);

                l_str = l_xmlConf.getNodeValue("gcCollect");
                if (!string.IsNullOrEmpty(l_str))
                    gcCollect = Convert.ToDouble(l_str);


                l_str = l_xmlConf.getNodeValue("colorMotifSeuil");
                if (!string.IsNullOrEmpty(l_str))
                    colorMotifSeuil = Convert.ToInt32(l_str);



                removeVersions = l_xmlConf.getBoolValue("removeVersions", false);
                condensation = l_xmlConf.getBoolValue("condensation", false);
                resetOneCl = l_xmlConf.getBoolValue("resetOneCl", false);
                abortOpe = l_xmlConf.getBoolValue("abortOpe");



                ordonnancement = l_xmlConf.getBoolValue("ordonnancement");

                menage = l_xmlConf.getBoolValue("menage", false);



                m_sort = new CConfSort(l_xmlConf.NodeLookUp("sort"), 0.5m);
                m_select = new CConfSort(l_xmlConf.NodeLookUp("selection"), 1);

                confGen = new ConfGen(l_xmlConf.NodeLookUp("gen"));
                // Album.Medianne = confGen.Medianne; 


                //   dataConf = new DataConf(l_xmlConf.NodeLookUp("data"));

                ordoConf = new ConfOrdo(l_xmlConf.NodeLookUp("ordo"));

                export = new Export(l_xmlConf.NodeLookUp("export"));
                import = new Import(l_xmlConf.NodeLookUp("import"));

                compact = l_xmlConf.getBoolValue("compact");
                filterNext = l_xmlConf.getBoolValue("filterNext");







                return l_xmlRoot;
            }

        }


        public static string ListBase
        {
            get { return m_listBase; }
        }

        public static ConfGen ConfGen
        {
            get { return confGen; }
        }

        public static CConfSort Sort
        {
            get { return m_sort; }
        }
        public static CConfSort Select
        {
            get { return m_select; }
        }
        public static int Before
        {
            get { return m_before; }
        }
        public static int After
        {
            get { return m_after; }
        }
        public static bool CheckModifStrict
        {
            get { return m_checkModifStrict; }
        }
        public static int MaxTask { get { return maxTask; } }
        public static rankingType RankingType { get { return _rankingType; } }

        public static bool Scan { get { return scan; } }
        public static string CopyTo { get { return copyTo; } }

        public static bool CopyModeFile { get { return copyModeFile; } }

        public static int ClassementOffset { get { return classementOffset; } }

        // public static bool DeleteFile { get { return deleteFile; } }

        // public static DataConf DataConf { get { return dataConf; } }

        public static bool RemoveVersions { get { return removeVersions; } }
        public static bool Condensation { get { return condensation; } }
        public static bool ResetOneCl { get { return resetOneCl; } }



        //  public static int TaskDelayError { get { return taskDelayError; } }

        public static bool Menage { get { return menage; } }


        public static bool Ordonnancement { get { return ordonnancement; } }
        public static bool AbortOpe { get { return abortOpe; } }

        //public static int MaxScan { get { return maxScan; } }
        public static int VolumeMin { get { return volumeMin; } }


        public static ConfOrdo ConfOrdo { get { return ordoConf; } }

        public static Export Export { get { return export; } }
        public static Import Import { get { return import; } }
        public static double GcCollect { get { return gcCollect; } }
        public static bool Compact { get { return compact; } }

        public static bool FilterNext { get { return filterNext; } }
        public static int ColorMotifSeuil { get { return colorMotifSeuil; } }
        public static string display()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(String.Format("base:{0} before:{1} after: {2} select:{3} sort:{4}", m_listBase, m_before, m_after, m_select, m_sort));
            sb.AppendLine(confGen.ToString());
            sb.AppendLine(ordoConf.ToString());

            return sb.ToString();
        }

    }


    public enum ConfType
    {
        sort,
        selection
    }
}

]]></content>
  </file>
</db>
