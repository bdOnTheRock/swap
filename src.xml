<db path="C:\bernard\db2\">
  <file path="db4\pdb.player\Vue\AlbumCtl.xaml">
    <content><![CDATA[<UserControl x:Class="pdb.player.Vue.AlbumCtl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             xmlns:l="clr-namespace:pdb.player.Vue"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="3" />
            <RowDefinition Height="*" />
            <RowDefinition Height="3" />
            <RowDefinition Height="Auto" />

        </Grid.RowDefinitions>
        <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="album"
                       x:Name="dg" x:Uid="album"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="false" 
                                        
                       SelectedItem="{Binding SelectedTrackInAlbumView}">



            <!--<DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="DataGridRow.IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="DataGridRow.Background" Value="White" />
                    <Style.Triggers>
                        <Trigger Property="DataGridRow.IsSelected" Value="True">
                            <Setter Property="DataGridRow.Background" Value="Brown" />
                        </Trigger>
                    </Style.Triggers>

                </Style>
            </DataGrid.RowStyle>-->

            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" >
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox Style="{StaticResource cb}" IsChecked="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridCheckBoxColumn  ElementStyle="{StaticResource cb}" Header="" Binding="{Binding Exists,Mode=OneWay}" />
                <!--<DataGridCheckBoxColumn Header=""  Binding="{Binding Enabled,UpdateSourceTrigger=PropertyChanged}"  />-->
                <DataGridTextColumn Header="" Binding="{Binding Index,Mode=OneWay}" />
                <DataGridTextColumn Header="p" Binding="{Binding TrackNumber,Converter={StaticResource Int}}"/>
                <DataGridTextColumn Header="Nom" Binding="{Binding Name,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="" Binding="{Binding MedianneStatus,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Classement" Binding="{Binding Classement, Mode=OneWay, Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="MaxClassement" Binding="{Binding MaxClassement, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="DeepClassement" Binding="{Binding DeepClassement, Mode=OneWay,Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="CC" Binding="{Binding ClassementCompact, Converter={StaticResource cl} }"/>
                <DataGridTextColumn Header="Virtuel" Binding="{Binding ClassementVirtuel,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff" Binding="{Binding CoeffVirtuel, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Virtuel2" Binding="{Binding ClassementVirtuel2,Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Coeff2" Binding="{Binding CoeffVirtuel2,Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

                <DataGridTextColumn Header="Durée" Binding="{Binding Duration,Mode=OneWay,Converter={StaticResource TimeSpan}}"   >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Rank" Binding="{Binding Rank,Mode=OneWay,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Maj"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource date}}" />
                <DataGridTextColumn Header="MajAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource date}}" />

                <DataGridTextColumn Header="Delai"  Binding="{Binding UpdateClassement, Mode=OneWay,Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" />
                <DataGridTextColumn Header="Motif" Binding="{Binding SelectedMotif,  Mode=OneWay,UpdateSourceTrigger=PropertyChanged, Converter={StaticResource motif}}"/>
                <DataGridTextColumn Header="NbClassements"  Binding="{Binding NbClass,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterAlbum" Binding="{Binding MasterAlbum}"/>
                <DataGridTextColumn Header="Grouping" Binding="{Binding Grouping, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                <DataGridTextColumn Header="Artiste"  Binding="{Binding Artist}"/>
                <DataGridTextColumn Header="Année" Binding="{Binding Year,Converter={StaticResource Int}}" >
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>


                <DataGridTextColumn Header="Id"  Binding="{Binding PieceId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="ParentId"  Binding="{Binding PieceParentId,Converter={StaticResource Int}}" />
                <DataGridTextColumn Header="MasterId"  Binding="{Binding MasterId,Converter={StaticResource Int}}" />

                <DataGridTextColumn Binding="{Binding StrPlaying, Mode=OneWay}" />
                <DataGridTextColumn Header="Export" Binding="{Binding ExportStatus, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="IndexExport" Binding="{Binding IndexExport, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}" />
                <DataGridTextColumn Header="Rendement" Binding="{Binding Rendement, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>


                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="Keep" Binding="{Binding Keep,Mode=OneWay}" />
                <DataGridCheckBoxColumn   ElementStyle="{StaticResource cb}" Header="NoCompact" Binding="{Binding NoCompact,Mode=OneWay}" />

                <DataGridTextColumn Header="PisteMaster"  Binding="{Binding MainTrackNumber,Mode=OneWay,Converter={StaticResource Int}}">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Right" />
                            <Setter Property="Padding" Value="0,0,3,0" />
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>

                <DataGridTextColumn Header="KeepCoeff" Binding="{Binding KeepCoeff, Mode=OneWay, Converter={StaticResource decimalE},UpdateSourceTrigger=PropertyChanged}"/>

            </DataGrid.Columns>


            <DataGrid.ItemContainerStyle>

                <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />
                    <EventSetter Event="PreviewMouseLeftButtonDown" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <EventSetter Event="PreviewMouseRightButtonDown" Handler="dg_MouseClick" />
                    <Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />
                    <Setter Property="FontWeight" Value="Normal" />
                    <Setter Property="BorderThickness" Value="0" />
                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected" Value="True">
                            <Setter Property="FontWeight" Value="Bold" />
                        </Trigger>
                        <DataTrigger Binding="{Binding Exis
                    ts}" Value="False">
                            <Setter Property="Background" Value="LightGray" />
                        </DataTrigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.ItemContainerStyle>

            <DataGrid.CellStyle>
                <Style TargetType="DataGridCell">
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport},ConverterParameter=album,   UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="BorderThickness" Value="1" />
                    <Setter Property="BorderBrush" Value="Transparent" />



                    <EventSetter Event="MouseDoubleClick" Handler="dgAlbum_MouseDoubleClick" />




                    <!--<Style.Triggers>
                        <Trigger Property="IsSelected"  Value="True">-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Background"  Value="SteelBlue"/>-->
                    <!--<Setter Property="Foreground"  Value="White" />-->
                    <!--<Setter Property="BorderThickness" Value="1" />-->
                    <!--</Trigger>
                    </Style.Triggers>-->
                </Style>
            </DataGrid.CellStyle>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <!--<Setter Property="Height"  Value="20" />-->

                    <EventSetter Event="PreviewMouseLeftButtonUp" Handler="dg_MouseClick" />
                    <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=album,  UpdateSourceTrigger=PropertyChanged}" />
                    <Setter Property="Padding" Value="10,10,10,10" />
                </Style>
            </DataGrid.RowStyle>

            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Info"  Command="{Binding Info}" />
                    <MenuItem Header="{Binding LinkFather.Header, UpdateSourceTrigger=LostFocus}"   Command="{Binding LinkFather}" />
                    <MenuItem Header="{Binding LinkChild.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkChild}" />
                    <MenuItem Header="{Binding LinkFusion.Header, UpdateSourceTrigger=LostFocus}"  Command="{Binding LinkFusion}" />
                    <MenuItem Header="!!!Supprimer!!!"  Command="{Binding DeleteTrack}" />
                    <MenuItem Header="Ressaisir le premier"   Command="{Binding LinkReset}" />
                    <MenuItem Header="Cocher la sélection"  Command="{Binding ContextCmdCheck}" />
                    <MenuItem Header="Décocher la sélection"  Command="{Binding ContextCmdUnCheck}" />
                    <MenuItem Header="Invalider dernier classement"  Command="{Binding ContextCmdDbDeleteClassement}" />
                    <MenuItem Header="Invalider dernière lecture"  Command="{Binding ContextCmdDbDeleteRead}" />
                    <MenuItem Header="Ajouter à la liste"  Command="{Binding ContextCmdAddToList}" />
                    <MenuItem Header="Naviguer vers"  Command="{Binding Explorer}" />



                </ContextMenu>
            </DataGrid.ContextMenu>
        </l:EnhancedDataGrid>
        <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch"   ResizeBehavior="PreviousAndNext"  IsTabStop="True"  />
        <Grid Grid.Row="2" >
            <ContentControl MouseDoubleClick="ContentControl_MouseDoubleClick"  >
                <Image Source="{Binding ArtWork, UpdateSourceTrigger=PropertyChanged}" ></Image>
            </ContentControl>

        </Grid>
        <GridSplitter Grid.Row="3" HorizontalAlignment="Stretch" ResizeDirection="Rows"  ResizeBehavior="PreviousAndNext"  IsTabStop="True"  />
        <Grid Grid.Row="4" VerticalAlignment="Bottom">

            <l:EnhancedDataGrid Grid.Row="0"  Grid.Column="0" DockPanel.Dock="Bottom" ConfCouleur="albums"
                       x:Name="dgalbums" x:Uid="albums"
                       AutoGenerateColumns="False" 
                        IsSynchronizedWithCurrentItem="False" 
                                VerticalAlignment="Bottom"
                                SelectedItem="{Binding SelectedTrackInAlbumsView}">
                HeadersVisibility="All" 
                                
                                 >
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Album" Binding="{Binding Album,Mode=OneWay}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="RankRev" Binding="{Binding RankAlbumReverse,Mode=OneWay}" />
                    <DataGridTextColumn Header="StackIndex" Binding="{Binding StackIndex, Mode=OneWay}" />
                    <DataGridTextColumn Header="DelaiAlbum"  Binding="{Binding AlbumUpdateClassement, Mode=OneWay, Converter={StaticResource delai}}" >
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="EquivLight"  Binding="{Binding EquivLight, Mode=OneWay}" />
                    <DataGridTextColumn Header="AlbumCount"  Binding="{Binding AlbumCount, Mode=OneWay, Converter={StaticResource Int}}" />
                    <DataGridTextColumn Header="RankAlbum" Binding="{Binding RankAlbum, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                    <DataGridTextColumn Header="Rank0" Binding="{Binding RankAlbumZero, Mode=OneWay,UpdateSourceTrigger=PropertyChanged}"/>
                    <DataGridTextColumn Header="Recents"  Binding="{Binding NbRecentsInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="Notes"  Binding="{Binding NbNoteInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="Done"  Binding="{Binding NbDoneInAlbum,Mode=OneWay,Converter={StaticResource Int}}">
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="HorizontalAlignment" Value="Right" />
                                <Setter Property="Padding" Value="0,0,3,0" />
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>
                    <DataGridTextColumn Header="Current" Binding="{Binding PlusPetitEnabled,Mode=OneWay,Converter={StaticResource cl},UpdateSourceTrigger=PropertyChanged}"/>



                </DataGrid.Columns>
                <DataGrid.ItemContainerStyle>
                    <Style TargetType="{x:Type DataGridRow}" BasedOn="{StaticResource {x:Type DataGridRow}}">
                        <!--<Setter Property="IsSelected" Value="{Binding IsSelected, Mode=TwoWay}" />-->
                        <Setter Property="FontWeight" Value="Normal" />
                    </Style>
                </DataGrid.ItemContainerStyle>

                <DataGrid.CellStyle>
                    <Style TargetType="DataGridCell">
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="Foreground" Value="{Binding TV, Converter={StaticResource foreColor}, ConverterParameter=albums, UpdateSourceTrigger=PropertyChanged}" />
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="BorderBrush" Value="Transparent" />
                    </Style>
                </DataGrid.CellStyle>
                <DataGrid.RowStyle>
                    <Style TargetType="DataGridRow">
                        <Setter Property="BorderThickness" Value="0" />
                        <Setter Property="Background" Value="{Binding TV, Converter={StaticResource colorExport}, ConverterParameter=albums,  UpdateSourceTrigger=PropertyChanged}" />
                    </Style>
                </DataGrid.RowStyle>


            </l:EnhancedDataGrid>
            <ComboBox Name="cbx_mode" HorizontalAlignment="Right"  Width="20" Height="25" VerticalAlignment="Top" SelectionChanged="cbx_mode_SelectionChanged" >
                <ComboBoxItem  ToolTip="album du morceau sélectionné" >identique</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre" >origine</ComboBoxItem>
                <ComboBoxItem ToolTip="album du morceau maitre si virtuel" >origine si virtuel</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus long entre le maitre et le virtuel" >le plus long</ComboBoxItem>
                <ComboBoxItem ToolTip="album le plus court entre le maitre et le virtuel" >le plus court</ComboBoxItem>
            </ComboBox>



        </Grid>


    </Grid>
</UserControl>  
]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.IO;

namespace pdb.gen.albums
{
    public enum virtualMode
    {
        none = 0,
        artist = 1,
        path = 2,
        year = 3,
        extended = 4,
        extendedWord = 5,
        added = 6,
        list = 7,
        word = 8
    }

    public enum sortDone : byte
    {
        none,
        phaseUn,
        phaseDeux
    }

    public class Album : IEnumerable<Piece>
    {
        [Flags]
        private enum typeMove : byte
        {
            move = 1,
            empeached = 2,
            empeached1 = 4
        }
        const int NB_DEC = 3;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        const int A_REFAIRE_CAUSE_COMPACT = -10;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        //  private decimal classementValueLightSt = -1;
#if GEN2
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;
#endif
        private sortDone sortStatus;

        private int nbRecent;
        private int nbDone;
        public int Recents { get { return nbRecent; } }
        public int NbDone { get { return nbDone; } }
        private int nbNote;
        public int NbNotes { get { return nbNote; } }
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && InStackSize)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)StackIndex / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }

            return ret;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                return getSt(classementValueLight);
                //if (classementValueLightSt >= 0)
                //    return classementValueLightSt;
                //classementValueLightSt = getSt(classementValueLight);

                //if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                //{
                //    //      1       10      50      99
                //    //      0.99    0.9     0.5     0.01
                //    //1.    0.01    0.1     0.5     0.99
                //    //2.    0.02    0.19    0.75    0.9999
                //    //10    0.095   0.65    0.999   0.99999999999
                //    //0.5   0.005   0.05    0.29    0.9
                //    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                //    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                //    if (delta != 1)
                //        delta = pdb.util.Math.Pow(delta, stackPower);
                //    delta = 1 - delta;

                //    if (delta < 0.001m)
                //        delta = 0.001m;

                //    classementValueLightSt = classementValueLight / delta;
                //}
                //else
                //    classementValueLightSt = classementValueLight;

                //  return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
#if GEN2
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
#else
                return ClassementValueLightSt;
#endif
            }
        }
        //  private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero
        {
            get
            {
#if GEN2
                return classementValueLightZero;
#else
                return ClassementValueLight;
#endif
            }
        }
        public decimal Rendement
        {
            get
            {
#if GEN2
                if (classementValueLight == 0) return 1; return classementValueLightZero / classementValueLight;
#else
                return 1;
#endif
            }
        }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private virtualMode mode;
        public virtualMode VirtualMode { get { return mode; } }
        //  private bool _virtual;
        public bool Virtual { get { return mode > virtualMode.none; } }
        public void setVirtual(virtualMode mode) { this.mode = mode; }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return this.mode == virtualMode.artist; } }
        private Piece pluspetitEnabled;
        public Piece PlusPetitEnabled { get { return pluspetitEnabled; } }
        // private int stackValue;
        private DateTime majDate;
        public DateTime MajDate { get { return majDate; } }

        //public int StackValue
        //{
        //    get
        //    {

        //        return stackValue;
        //    }
        //    set
        //    {
        //        if (value > 0 && this.Name == "\\")
        //        {
        //        }
        //        else
        //            stackValue = value;
        //    }
        //}

        public bool InStackSize { get { return StackIndex < stackSize && name != "\\"; } }
        public bool InStackPeremption { get { return StackIndex < stackPeremption && name != "\\"; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, mode);
                return key;
            }
        }

        public Album(string name, virtualMode mode)
        {
            this.name = name;
            this.mode = mode;
            quality = CRank.MAX;
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            quality = CRank.MAX;
        }
        private int quality;
        public int Quality
        {
            get { return quality; }
            set { quality = value; }
        }

        public int RankAlbumReverse
        {
            get
            {
                return Albums.RankZero - quality; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
            }
        }

        private decimal timeRest = decimal.MaxValue;
        public decimal TimeRest { get { return timeRest; } set { timeRest = System.Math.Round(value, NB_DEC); } }
        public string Name { get { return name; } }

        public override string ToString()
        {
            return string.Format("{0} {1} {2} elts", name, mode, Count);
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0
        {
            get
            {
#if GEN2
                return Piece.getClassementEquiv(classementValueLightZero);
#else
                return EquivLight;
#endif
            }
        }

        //// private string moyenne = "";
        //public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        private static Dict<string, typeMove> dictMove = new Dict<string, typeMove>();

        public static void clearMove() { dictMove.Clear(); }

        private static bool HasMoveValue(string key, typeMove type)
        {
            return dictMove[key].HasFlag(type);
        }
        private static void SetMoveValue(string key, bool value, typeMove type)
        {
            var v = dictMove[key];
            if (value)
            {
                v |= type;
            }
            else
            {
                v &= ~type;
            }
            if (v == 0)
                dictMove.Remove(key);
            else
                dictMove[key] = v;
        }

        public bool Moved
        {
            get
            {
                return HasMoveValue(Key, typeMove.move);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.move);
            }
        }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return HasMoveValue(Key, typeMove.empeached);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.empeached);
            }
        }

        public void empeachedDecrement()
        { //nbEmpeached--; 
        }

        // public int EmpeachedNb { get { return nbEmpeached; } }

        //private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1
        {
            get
            {
                return HasMoveValue(Key, typeMove.empeached1);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.empeached1);
            }
        }
        private static int stackSize = 20;
        public static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return StackIndex == stackSize; } }
        public bool AlmostFree1 { get { return StackIndex == stackSize - 1; } }

        //private Piece equiv;

        public bool ContainsMaster(Piece p)
        {
            return masters.Contains(p.Master); 
        }

        public bool add(Piece piece)
        {
            if (build)
                throw new ApplicationException("déjà buildé");
            piece.PieceAlbum = this;


            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                quality = CRank.MAX;
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public void ClearAndMenage()
        {
            if (mode == virtualMode.word && name == "029")
            {
            }
            if (mode != virtualMode.none)
            {
                foreach (Piece p in list)
                    p.setParent(null);
            }
            Clear();
        }

        public void ConsolidChilds()
        {
            foreach (Piece p in list)
                p.consolidChild();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && !p.ClassmentPositive())
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                var exists = FileRegister.Exist(next.Location);
                return false == exists;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return false; } }// selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<IPieceAlbum> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {
                #region calcul virtuel



                DecimalPiece med = null;
#if GEN2
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;
#endif



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                // bool combineNow = mode.combine && mode.simple;
#if GEN2
                if (real)
                    _albumMedianne.buildVirtual(mode.combine, mode.simple);
                else
                {
#else
                if (mode.Main.coeffVirt > 1)
                    _albumMedianne.buildVirtual(true, mode.simple);
                else
                    list.Sort(new PieceClassementComparer(false));
#endif
#if GEN2
            }
#endif
#if GEN2

                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    med1 = med; med2 = med;

                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, pieceExtendedMode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }

                    if (mode.combine && !mode.simple)
                    {
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    }


                }

                
                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }
#else
                med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);
                var median = med.index;

                if (median != null)
                {
                    resultGlobalMin = median.getSimpleCause();
                }
#endif















                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, pieceExtendedMode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var cnext = cause.Next;
                if (cnext != null)
                {
                    if (cnext.UseCompact && !cnext.Empty)
                    {
                        if (cnext.Piece.ClassementRecentCompact)
                        {
                            cnext.UseCompact = false;
                            return A_REFAIRE_CAUSE_COMPACT;
                        }
                    }
                }
                classementValueLight = med.d;
                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    //if (mode.combine && !mode.simple)
                    //{
                    //    _albumMedianne.buildVirtual(true);
                    //    med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                    //    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    //}
                    //else
                    //{
                    //    if (true == cause.selectedMotifMin)
                    //        med = med2;
                    //    else
                    //        med = med1;
                    //}




                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

#if GEN2
                    foreach (var p in list)
                        p.finalyse();

#endif


                    if (cause.motifUp)
                    {
                        if (cause.selectedMotifMin.HasValue)
                        {
                            if (true == cause.selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else if (selectedMotifMin.HasValue)
                        {
                            if (true == selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else
                        {
                            if (true == resultGlobalMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }


                    }

                    try
                    {
                        if (med.index != null)
                            pluspetitEnabled = med.index.Piece;
                        if (med.index != null) med.index.Piece.MedianneLight = true;
                        if (med.indexBorder != null) med.indexBorder.Piece.Border = true;
                        if (med.indexBorderEffect != null) med.indexBorderEffect.Piece.BorderEffect = true;
                        if (med.indexBorderMin != null) med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public IPieceAlbum Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<IPieceAlbum> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;
            bool forceKeep = mode.forceKeep;
            bool forceKeep2 = mode.forceKeep2;
            bool dontDownByKeep = mode.dontDownByKeep;


            // PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            IPieceAlbum nextZero1 = null;
#if GEN2
            IPieceAlbum nextZero2 = null;
             IPieceAlbum min2 = null;
                Classement _min2 = null;
              Classement _minzero2 = null;
#endif

            IPieceAlbum min1 = null;

            IPieceAlbum min = null;
            Classement _min1 = null;

            Classement _minzero1 = null;

            bool realZero = false;
            IPieceAlbum Next = null;

            IPieceAlbum firstKeep = null;
            IPieceAlbum firstKeep2 = null;
            int index = 0;
            int count = list.Count;
            for (; index < count; index++)
            // foreach (IPieceAlbum p in list)
            {
                IPieceAlbum p = list[index];
                if (p.Piece.Keep)
                {
                    if (p.Piece.KeepCoeff > 0)
                    {
                        if (firstKeep == null)
                            firstKeep = p;
                    }
                    if (p.Piece.KeepCoeff < 0)
                    {
                        if (firstKeep2 == null)
                            firstKeep2 = p;
                    }

                    //min= firstInAlbumEmpty; 
                    //break;
                }
                var piece = p.Piece;
                Classement v1 = piece.LastClassementRecent ? piece.getClassement(true) : p.Classement;
                //  var v1 = p.Classement;
#if GEN2
                var v2 = p.Classement2;
#endif

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            if (!p.Piece.Keep || !dontDownByKeep)
                            {
                                _minzero1 = v1;
                                nextZero1 = p;
                                if (v1.isZero())
                                    realZero = true;
                            }
                        }
                    }
#if GEN2

                    if (v2.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2.isZero())
                                realZero = true;
                        }

                    }

#endif

                    if (v1.isPositive() && v1 < _min1)
                    {
                        if (!p.Piece.Keep || !dontDownByKeep)
                        {
                            _min1 = v1;
                            min1 = p;
                        }
                    }
#if GEN2
                    if (v2.isPositive() && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }
#endif

                    if (p.Empty)
                        break;
                }
            }
            Classement _min = null;
#if GEN2
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;

            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }
#else
            min = min1;
            _min = _min1;
#endif

            IPieceAlbum nextZero = null;
            Classement _minzero = null;
#if GEN2
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }
#else
            nextZero = nextZero1; _minzero = _minzero1;
#endif

            //if (firstInAlbumEmpty != null)
            //{
            //    Next = firstInAlbumEmpty;
            //    cause.selectedMotifMin = cause.resultByFirstMin;
            //    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
            //}
            //else
            //{

            if (nextZero != null)
            {
                decimal _minValue = _min == null ? int.MaxValue : _min.RapportClassement;
                decimal _minZeroValue = _minzero == null ? int.MaxValue : _minzero.RapportClassement;
                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane

                    if (_minValue < classementValueLight && min != null)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.ClassementValueLightZero > classementValueLight + EPSILON || (classementValueLight > 0 && this.ClassementValueLightZero / classementValueLight > 1 + EPSILON)) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            else
                            {
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                if (min != null)
                                    cause.motifUp = min.getCauseUp(cause.selectedMotifMin);
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_minValue < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minZeroValue < classementValueLight)
                    {
                        classementValueLight = _minZeroValue;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {

                        classementValueLight = _min == null ? int.MaxValue : _min.RapportClassement;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min.RapportClassement;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }
            //}

            if (Next == nextZero)
            {
                bool refact = false;

                if (firstKeep2 != null && firstKeep2 == min && Next != firstKeep2 && !firstKeep2.LastClassementRecent)
                {
                    if (forceKeep2)
                    {
                        Next = firstKeep2; refact = true;
                    }
                    else if (firstKeep2.Piece.DeepClassement.isZero())
                    {
                        Next = firstKeep2; refact = true;
                    }
                }
                else if (forceKeep && firstKeep != null && firstKeep == min && Next != firstKeep && !firstKeep.LastClassementRecent)
                {
                    {
                        Next = firstKeep; refact = true;
                    }
                }

                if (Next == nextZero && mode.deepZero)
                {
                    for (; index < count; index++)
                    {
                        IPieceAlbum p = list[index];
                        if (p.Enabled)// p.Piece.DeepClassement.isZero())
                        {
                            var cl = p.Piece.DeepClassement;
                            if (cl.isZero())
                            {
                                if (Next != p)
                                {
                                    Next = p;
                                }
                                break;
                            }
                        }
                    }
                    if (Next == nextZero && firstKeep != null && Next != firstKeep)
                        Next = firstKeep;
                }

                if (refact)
                {
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                }
            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            if (real && min != null)
                this.pluspetitEnabled = min.Piece;
            return cause;



        }


        private bool makesort(List<Piece> list, List<IPieceAlbum> listE, ConfMedianne mode, ConfMedianne mode0, int nbrepeat)
        {
            int count = list.Count;

            if (sortStatus == sortDone.none)   //(!sort0Done)
            {
                // list.Sort(new CPieceComparerByQualityAndLength());
                var listSortedValues = new List<decimal>();
                //classed = false;
                //for (int i = 0; i < count; i++)
                //{
                //    listSortedValues.Add(list[i].Rank.SortValue);
                //    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                //        classed = true;
                //}
                ////misc.log("make sort Duration {0}", name); 
                //m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                //  listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                {
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                }
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                //   decimal moy = 0m;
                decimal offset = Album.conf.AlbumMoyOffset;
#if GEN2
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement(true);

                    p.setClassementVirtuel(rapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;
#endif

                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }
                if (sortStatus < sortDone.phaseUn)
                    sortStatus = sortDone.phaseUn;
                //   sort0Done = true;

            }


            if (sortStatus >= sortDone.phaseDeux)
                return false;

            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            // classementValueLightSt = -1;
            selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;

#if GEN2
            classementValueLightZeroSt = -1;
           
            classementValueLightZero = makeSort(listE, mode0, false);
            if (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }
#endif
            classementValueLight = makeSort(listE, mode, true);
            if (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }

            //   classementValueLightZero = A_REFAIRE_CAUSE_COMPACT;


            //   while (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLightZero = makeSort(listE, mode0, false);
            //   }

            ////   var _classementValueLight = makeSort(listE, mode, true);

            //   while (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLight = makeSort(listE, mode, true);
            //   }
#if GEN2
            var coeff1 = mode.Main.coeffVirt;
            var coeff2 = mode.Min.CoeffOld;
            var rendementmax = 1m;

            if (mode.combine)
                rendementmax = coeff1 * coeff2;
            else
                rendementmax = pdb.util.Math.Max(coeff1, coeff2);
            if (Rendement > 6 * rendementmax + 1e-6m)
            {
                nbrepeat++;
                sortStatus = sortDone.none;
                if (nbrepeat >= 3)
                {
                    // classementValueLight = classementValueLightZero;
                    return true;
                }
                return makesort(list, listE, mode, mode0, nbrepeat);

            }
#endif
            return true;
        }



        public bool makeSort(ConfMedianne mode, ConfMedianne mode0, ILogger logger, double dureeMinToLog) //IList<double> reference, IList<Piece> pieces)
        {

            if (sortStatus >= sortDone.phaseDeux)
                return false;
            DateTime nowa = DateTime.Now;
            var ts = (nowa - majDate);
            try
            {

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return false;

                var listE = new List<IPieceAlbum>(count);

                //if (CConf.ResetOneCl)
                //{

                //    // CPieceClassement.DateMin = DateTime.MinValue;
                //    decimal zer0d = 0;
                //    Piece oldKeep = null;


                //    foreach (Piece t in list)
                //    {
                //        if (t.Keep)
                //        {
                //            t.Keep = false;
                //            oldKeep = t;
                //            break;
                //        }
                //    }


                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in list)
                //    {
                //        var cl = t.DeepClassement; // p.Classement.DbValue;
                //        decimal clValue = Piece.classementHash.getCache(cl).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {

                //            if (t.LastClassementRecent || !t.Enabled)
                //            {
                //                min = null;
                //                break;
                //            }
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        min.Keep = true;
                //        var r = min.RapportClassement(true);
                //        if (r <= 0)
                //        {
                //        }
                //    }



                //    if (oldKeep != null && !oldKeep.Keep)
                //    {
                //        oldKeep.resetMedianneCompact();
                //        oldKeep.invalidateCache(true);
                //    }
                //}


                atLeastOneEnabled = false;
                int _nbr = 0;
                int _nbdone = 0;
                int _nbNote = 0; 


                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    if (p.DeepClassement.isPositive())
                        _nbNote++; 

                    if (sortStatus < sortDone.phaseDeux) //  (!sortDone)
                        p.resetMedianneCompact();
                    if (p.Enabled)
                    {
                        atLeastOneEnabled = true;

                    }
                    if (!p.Enabled && p.ClassmentPositive())
                        _nbdone++;
                    if (p.LastClassementRecent)
                        _nbr++;
#if GEN2
                    var pp = new PieceExtended(p);
#else
                    var pp = p;
#endif

                    if (mode.Main.coeffVirt > 1)
                        listE.Add(new PieceExtendedSimple(pp));
                    else
                        listE.Add(pp);
                }

                nbRecent = _nbr;
                nbDone = _nbdone;
                nbNote = _nbNote; 


                bool ret = makesort(list, listE, mode, mode0, 0);

                sortStatus = sortDone.phaseDeux;

                majDate = DateTime.Now;
                var duree = (majDate - nowa);
                if (duree.TotalMilliseconds > dureeMinToLog)
                    logger.log(string.Format("make Sort {0}| {1} {2}", ts.toString(), duree.toString(), this));

                return ret;
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return false;
        }



        public void mustRefresh()
        {
            build = false;
            sortStatus = sortDone.none;

            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
            albumAdded = DateTime.MaxValue;
        }

        public void refreshLight()
        {
            if (sortStatus == sortDone.phaseDeux)
                sortStatus = sortDone.phaseUn;
            atLeastOneEnabled = null;
            dictMove.Remove(Key);
            _tracksSortByClassement = null;
        }



        //public decimal getTrackSortValue(int index, List<Piece> list)
        //{
        //    if (index < 0 || index >= list.Count)
        //        return 0;
        //    return list[index].RapportClassement(true);
        //}

        //decimal firstTrackSortValue = -1;
        //public decimal getFirstTrackSortValue()
        //{
        //    if (firstTrackSortValue == -1)
        //    {
        //        int count = list.Count;
        //        if (count == 0)
        //            return -1;
        //        var _list = new List<Piece>(list);
        //        _list.Sort(new PieceSortComparer());
        //        firstTrackSortValue = _list[count - 1].Rank.SortValue;
        //    }
        //    return firstTrackSortValue;
        //}
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            timeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> RawList
        {
            get
            {
                return new List<Piece>(list);
            }
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        //private CRank m_rank = new CRank();

        //public CRank Rank { get { return m_rank; } }



        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            quality = CRank.MAX;
            // rankStack = -1;
        }

        //public int QRank
        //{
        //    get { return m_rank.Quality; }
        //    set { m_rank.Quality = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}


        #endregion

        #region tri



        #endregion

        [Flags]
        private enum unsortMode : byte
        {
            album = 1,
            artist = 2

        }
        const char SEP = '\\';
        const int MAX_PATH_LEVEL = 10;

        public void addPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            paths.Add(p);
                        }
                        ilevel++;
                    }
                    // paths.Add(path);
                }
            }
        }

        public bool containsPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    if (paths.Contains(path))
                        return true; //paths.Add(path);
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            if (paths.Contains(p))
                                return true;
                        }
                        ilevel++;
                    }

                }
            }
            return false;
        }
        public void sortVirtual()
        {
            if (this.VirtualMode == virtualMode.none)
                return;
            var list = this.list.ToList<Piece>();
            int count = list.Count;
            if (count == 0)
                return;
            list.Sort((x, y) =>
            {
                var cmp = x.MasterTrackNumberForTri.CompareTo(y.MasterTrackNumberForTri);
                if (cmp != 0)
                    return cmp;
                return x.Location.CompareTo(y.Location);
            });
            var dictArtist = new Dictionary<string, List<Piece>>();
            var dictAlbum = new Dictionary<int, string>();
            var dictDir = new Dictionary<string, List<Piece>>();
            DirSort.reset();
            foreach (Piece p in list)
            {

                DirSort.record(p);
            }

            DirSort.go();


            foreach (Piece p in list)
            {
                if (p.TrackNumber == 0)
                {
                    p.TrackNumber = list.Count + p.MasterTrackNumber;
                }
            }

            list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;

            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}

            //var list2 = new List<Piece>(list);
            //list2.Sort(new VirtualPieceComparer());

            var hs = new HashSet<int>();
            var unsorted = new List<Piece>();
            Piece pp = list[0];
            hs.Add(pp.PieceId); unsorted.Add(pp);
            //string currentArtist = pp.Artist;
            //string currentAlbum = pp.Master.Album;


            int indexC = 0;
            //  bool singleAlbum = false;
            string currentArtist = Album.getKey(pp.Artist, virtualMode.artist);
            unsortMode mode = unsortMode.album | unsortMode.artist;
            if (VirtualByArtist)
                mode = unsortMode.album;

            HashSet<string> artists = new HashSet<string>();
            HashSet<string> albums = new HashSet<string>();
            artists.Add(currentArtist);
            albums.Add(pp.Master.PieceAlbum.Key);
            //  HashSet<string> paths = new HashSet<string>();
            //int pathlevel = 0;
            //  bool found = false;
            int nbc = 0;
            while (unsorted.Count < count)
            {
                nbc++;
                //int indexAlbum = -1;
                //int indexArtist = -1;


                // addPath(pp, paths, pathlevel);

                artists.Clear();
                albums.Clear();
                //    paths.Clear();
                artists.Add(currentArtist);
                albums.Add(pp.Master.PieceAlbum.Key);


                for (int i = 0; i < count; i++)
                {

                    var p = list[i];
                    if (hs.Contains(p.PieceId))
                        continue;

                    if (mode == 0)
                    {
                        hs.Add(p.PieceId);
                        unsorted.Add(p);
                        pp = p;
                        // indexAlbum = -1;
                        indexC = i;
                        continue;
                    }
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        var artist = p.Artist;
                        if (p.Artist != pp.Artist)
                        {
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            if (currentArtist != cartist)
                            {
                                if (!artists.Contains(cartist))
                                {
                                    if (mode.HasFlag(unsortMode.album))
                                    {
                                        if (albums.Contains(p.Master.PieceAlbum.Key))
                                        {
                                            //if (albums.Count <= 1)
                                            //    indexArtist = i;
                                            continue;
                                        }
                                    }

                                    //if (pathlevel <= MAX_PATH_LEVEL)
                                    //{
                                    //    if (containsPath(p, paths, pathlevel))
                                    //        continue;
                                    //}

                                    hs.Add(p.PieceId);
                                    unsorted.Add(p);
                                    pp = p;
                                    //indexAlbum = -1;
                                    //indexArtist = -1;

                                    albums.Add(pp.Master.PieceAlbum.Key);
                                    artists.Add(cartist);
                                    //  addPath(pp, paths, pathlevel); 
                                    indexC = i;
                                    currentArtist = cartist;
                                    //   found = true;
                                    continue;

                                }
                            }
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                    {
                        var album = p.Master.PieceAlbum.Key;
                        if (!albums.Contains(album))
                        {
                            //if (pathlevel <= MAX_PATH_LEVEL)
                            //{
                            //    if (containsPath(p, paths, pathlevel))
                            //        continue;
                            //}
                            hs.Add(p.PieceId);
                            unsorted.Add(p);
                            pp = p;
                            indexC = i;
                            //indexAlbum = -1;
                            albums.Add(album);
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            artists.Add(cartist);
                            currentArtist = cartist;
                            //   found = true;
                            //  addPath(pp, paths, pathlevel); 
                        }
                    }
                }


                //if (indexAlbum >= 0)
                //{
                //    // pas trouvé d'autre artiste, on se rabat sur l'album
                //    var p = list2[indexAlbum];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexAlbum;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else if (indexArtist >= 0)
                //{
                //    // on a trouvé un autre artiste sur le même album. pas si mal
                //    var p = list2[indexArtist];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexArtist;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else
                //{
                //    // rien trouvé de spécial
                //    if (indexC == 0 && !singleAlbum)
                //    {
                //        singleAlbum = true;
                //    }
                //    indexC = 0;

                //}

                if (indexC == 0)
                {

                    //if (found)
                    //{
                    //    found = false;
                    //}
                    //else
                    //{
                    //{
                    //    if (paths.Count == 0)
                    //    {
                    //        pathlevel = MAX_PATH_LEVEL; 
                    //    }
                    //    if (pathlevel < MAX_PATH_LEVEL)
                    //    {
                    //        pathlevel++;
                    //    }
                    //    else
                    //    {
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        if (mode.HasFlag(unsortMode.album))
                            // on cherche les artistes différents ( éventuellement même album ) 
                            mode &= ~unsortMode.album;
                        else
                        {
                            // on abandonne la recherche artiste et on réactive la recherche album
                            mode &= ~unsortMode.artist;
                            mode |= unsortMode.album;
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                        // on est en mode single album; 
                        mode &= ~unsortMode.album;

                    //pathlevel = 0;
                    //  }
                }
                //}
                // }
                indexC = 0;

            }

            for (int i = 0; i < unsorted.Count; i++)
            {
                unsorted[i].TrackNumber = i + 1;
            }



            //foreach (Piece p in list)
            //{
            //    if (p == null)
            //        continue;
            //    var artist = p.Artist;
            //    FileInfo file = null;
            //    try
            //    {
            //        file = new System.IO.FileInfo(p.Location);
            //    }
            //    catch
            //    {
            //        continue;
            //    }
            //    var dirAlbum = file.Directory;
            //    var dirArtist = dirAlbum.Parent;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = dirArtist.FullName;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = "-";
            //    if (!dictArtist.ContainsKey(artist))
            //        dictArtist.Add(artist, new List<Piece>());
            //    dictArtist[artist].Add(p);

            //    var _album = p.Master.Album;
            //    if (string.IsNullOrEmpty(_album))
            //        _album = dirAlbum.FullName;
            //    dictAlbum.Add(p.PieceId, _album);

            //    //if (!dictAlbum.ContainsKey(_album))
            //    //    dictAlbum.Add(_album, new List<Piece>());
            //    //dictAlbum[_album].Add(p);


            //}

            //foreach (List<Piece> l in dictArtist.Values)
            //{
            //    //
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //var listUnSortArtist = new List<Piece>(list);
            //listUnSortArtist.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));

            //var listUnSortAlbum = new List<Piece>();

            //List<Piece> aux = new List<Piece>();
            //int current = 0;

            //foreach (Piece p in listUnSortArtist)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {
            //        //aux.Add(p);
            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            string xa = x.Master.Album;
            //            string ya = y.Master.Album;
            //            if (dictAlbum.ContainsKey(x.PieceId))
            //                xa = dictAlbum[x.PieceId];
            //            else
            //            { }
            //            if (dictAlbum.ContainsKey(y.PieceId))
            //                ya = dictAlbum[y.PieceId];
            //            else
            //            { }
            //            var cmp = xa.CompareTo(ya);
            //            return cmp;
            //        });

            //        listUnSortAlbum.AddRange(aux);
            //        aux.Clear();

            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    string xa = x.Master.Album;
            //    string ya = y.Master.Album;
            //    if (dictAlbum.ContainsKey(x.PieceId))
            //        xa = dictAlbum[x.PieceId];
            //    else
            //    { }
            //    if (dictAlbum.ContainsKey(y.PieceId))
            //        ya = dictAlbum[y.PieceId];
            //    else
            //    { }
            //    var cmp = xa.CompareTo(ya);
            //    return cmp;
            //});

            //listUnSortAlbum.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnSortAlbum.Count; i++)
            //{
            //    listUnSortAlbum[i].TrackNumber = i + 1;
            //}

            //aux.Clear();
            //current = 0;
            //var listUnsortTrack = new List<Piece>();

            //foreach (Piece p in listUnSortAlbum)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {

            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            var xt = x.MasterTrackNumber;
            //            var yt = y.MasterTrackNumber;
            //            int cmp = 0;
            //            if (xt <= 0 || yt <= 0)
            //            {
            //                try
            //                {
            //                    cmp = x.Location.CompareTo(y.Location);
            //                }
            //                catch
            //                {
            //                }
            //            }
            //            cmp = xt.CompareTo(yt);
            //            return cmp;
            //        });

            //        listUnsortTrack.AddRange(aux);
            //        aux.Clear();
            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    var xt = x.MasterTrackNumber;
            //    var yt = y.MasterTrackNumber;
            //    int cmp = 0;
            //    if (xt <= 0 || yt <= 0)
            //    {
            //        try
            //        {
            //            cmp = x.Location.CompareTo(y.Location);
            //        }
            //        catch
            //        {
            //        }
            //    }
            //    cmp = xt.CompareTo(yt);
            //    return cmp;
            //});

            //listUnsortTrack.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnsortTrack.Count; i++)
            //{
            //    listUnsortTrack[i].TrackNumber = i + 1;
            //}




            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;
            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}
        }

        public bool isSameOf(Album o)
        {
            if (o == this)
                return false;
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && mode == o.mode;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }
        private DateTime albumAdded = DateTime.MaxValue;
        public DateTime AlbumAdded
        {
            get
            {
                if (albumAdded < DateTime.MaxValue)
                    return albumAdded;
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                albumAdded = min;
                return albumAdded;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public const string UNKNOWN = "-";
        public static string getKey(string _album, virtualMode mode)
        {
            string __album = UNKNOWN;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();
                __album = __album.Replace("compilations", "compilation");

                if (mode == virtualMode.word)
                {
                    __album = string.Format("¤¤[{0}]", __album);
                    return __album;
                }
                if (mode == virtualMode.list)
                {
                    __album = string.Format("/{0}", __album);
                    return __album;
                }

                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (mode == virtualMode.artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }
                else if (mode == virtualMode.year)
                {
                    if (_album.Length == 3)
                        __album = string.Format("£[{0}0']", __album);
                    else
                        __album = string.Format("£[{0}]", __album);
                }
                else if (mode == virtualMode.extended)
                {
                    __album = string.Format("¤[{0}]", __album);
                }
                else if (mode == virtualMode.extendedWord)
                {
                    __album = string.Format("¤[{0}]¤", __album);
                }
                else if (mode == virtualMode.added)
                {
                    __album = string.Format("<{0}>", __album);
                }

            }
            return __album;

        }



    }
}
]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\albums\Albums.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.util;
using pdb.gen.conf;
using System.Xml;
using System.Text;
using System.IO;
using System.Threading;

namespace pdb.gen.albums
{
    public class Albums // : IAlbumInit
    {
        private const string FILE_ALBUMS = "_albums.xml";
        public Albums(Consolid consolid)
        {
            this.consolid = consolid;
            new Thread(loop) { Priority = ThreadPriority.Lowest, Name = "scan albums" }.Start();
        }

        Logger logScan = Logger.getLogger("scan albums", true);

        /// <summary>
        /// référence constante des albums
        /// </summary>
        //   private BgDictString<Album> dict0 = new BgDictString<Album>();
        /// <summary>
        /// Albums réels ou virtuels
        /// </summary>
        private BgDictString<Album> dict = new BgDictString<Album>();
        public BgDictString<Album> Dict { get { return dict; } }
        private Consolid consolid;
        private StackAlbum stack = StackAlbum.Instance;
        private static volatile object _lock = new object();
        private static volatile object _lockSort = new object();
        public static object Lock { get { return _lock; } }
        public static object LockSort { get { return _lockSort; } }
        private volatile object _lockSort2 = new object();
        private Album currentSorted;



        public void checkBuild()
        {
            lock (_lock)
            {
                misc.log("albums.checkBuild();");
                //foreach (Album album in dict0.Values)
                //{
                //    album.checkBuild();
                //}
                dict.Clear();
            }
        }

        private string getKey(string _album, virtualMode mode)
        {
            return Album.getKey(_album, mode);
        }

        public void buildDone()
        {
            lock (_lock)
            {
                var confGen = CConf.ConfGen;
                var min1 = confGen.AlbumMin;
                var min2 = confGen.PathVirtualMin;
                var min3 = confGen.ArtistVirtualMin;
                foreach (Album album in new List<Album>(dict.Values))
                {
                    int count = album.Count;
                    bool toKeep = album.buildDone();
                    if (toKeep)
                    {

                        if (album.Virtual)
                        {
                            if (album.VirtualByArtist)
                            {
                                if (min3 > 1 && count < min3)
                                    toKeep = false;
                            }
                            else if (min2 > 1 && count < min2)
                                toKeep = false;
                        }
                        else if (min1 > 1 && count < min1)
                            toKeep = false;



                        if (!toKeep)
                        {
                            //album.Clear(); 
                            // misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }

                    }

                }


            }
        }



        private bool check_(Piece piece, string albumOrg, virtualMode mode, IDictionary<string, Album> dict)
        {
            string key = getKey(albumOrg, mode);


            var album = dict[key];
            if (album == null)
            {
                //album = dict0[key];
                //if (album == null)
                //{
                //  misc.log("creation album {0}", __album);
                album = new Album(albumOrg, key);
                album.setVirtual(mode);
                dict.Add(key, album);
                // dict0.Add(key, album);

            }

            //  }

            return album.add(piece);
        }

        private bool check_(Piece piece, IDictionary<string, Album> dict)
        {
            return check_(piece, piece.Album, piece.VirtualMode, dict);
        }

        public int Count { get { return dict.Count; } }
        public static int RankZero { get; set; }



        const char SEP = ';';
        const char SEP_TRACK = ',';


        public string getSortedAlbumFile()
        {
            var sb = new pdb.util.StringBuilder();
            sb.Append(TuningBase.DIR_CONF);
            var gen = CConf.ConfGen;
            if (gen.PathVirtual)
                sb.Append("Path");
            if (gen.PathVirtualE)
                sb.Append("PathE");
            if (gen.PathVirtualEW)
                sb.Append("PathEW");
            if (gen.ArtistVirtual)
                sb.Append("Artist");

            if (gen.YearVirtual)
                sb.Append("Year");
            if (gen.AddedVirtual)
                sb.Append("Added");
            if (gen.AddedVirtualSimu)
                sb.Append("AddedSimu");
            if (gen.WordVirtual)
                sb.Append("Word");
            if (gen.ListVirtual)
                sb.Append("List");
            if (gen.VirtualRoot)
                sb.Append("Root");
            sb.Append(FILE_ALBUMS);
            return sb.ToString();
        }

        public void sortVirtual()
        {
            if (!CConf.ConfGen.AlbumVirtual)
                return;
            misc.log("sortVirtual");
            foreach (Album album in dict.Values)
            {
                if (album.Virtual)
                    album.sortVirtual();
            }


            var listAlbums = new List<Album>(dict.Values);
            listAlbums.Sort(new VirtualAlbumComparerForWrite());

            var settings = new XmlWriterSettings();
            settings.Indent = true;
            settings.Encoding = Encoding.UTF8;

            //using (StreamWriter sw = new StreamWriter(FILE_ALBUMS + ".tmp"))
            //{
            //    foreach (Album album in listAlbums)
            //    {
            //        if (!album.Virtual)
            //            continue;

            //        sw.Write(album.VirtualMode);
            //        sw.Write(SEP);

            //        sw.Write(album.Name);
            //        sw.Write(SEP);

            //        var list = album.RawList;
            //        list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //        bool begin = false;
            //        foreach (Piece p in list)
            //        {
            //            if (begin)
            //                sw.Write(SEP_TRACK);
            //            else
            //                begin = true;
            //            sw.Write(p.MasterId);
            //        }
            //        sw.WriteLine();

            //    }

            //}
            var fileAlbum = getSortedAlbumFile();
            using (XmlWriter writer = XmlWriter.Create(fileAlbum + ".tmp", settings))
            {
                writer.WriteStartElement("albums");
                foreach (Album album in listAlbums)
                {
                    if (!album.Virtual)
                        continue;
                    writer.WriteStartElement("a");
                    writer.WriteAttributeString("mode", album.VirtualMode.ToString());
                    writer.WriteAttributeString("name", album.Name);
                    writer.WriteAttributeString("nb", album.Count.ToString());
                    var list = album.RawList;
                    list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
                    bool begin = false;
                    var sb = new System.Text.StringBuilder();
                    foreach (Piece p in list)
                    {
                        if (begin)
                            sb.Append(SEP_TRACK);
                        else
                            begin = true;
                        sb.Append(p.MasterId);
                    }

                    writer.WriteString(sb.ToString());

                    //foreach (Piece p in list)
                    //{
                    //    writer.WriteElementString("t", p.MasterId.ToString());
                    //}
                    writer.WriteEndElement();
                }


                writer.WriteEndDocument();
                writer.Flush();
            }

            System.IO.File.Copy(fileAlbum + ".tmp", fileAlbum, true);
            System.IO.File.Delete(fileAlbum + ".tmp");

        }

        public int load(IDictionary<int, Piece> dict)
        {

            //using (StreamReader sr = new StreamReader(FILE_ALBUMS))
            //{

            //    var line = sr.ReadLine();
            //    var tabs = line.Split(SEP);
            //    int count = tabs.GetLength(0); 

            //    var name = tabs[1];
            //    var mode = (virtualMode)Enum.Parse(typeof(virtualMode), tabs[0], true);
            //    Album current = new Album(name, mode);
            //    this.dict.Add(current.Key, current);
            //    int tn = 0;
            //    var tracks = tabs[2].Split(SEP_TRACK);
            //    foreach (string sid in tracks)
            //    {
            //        tn++;
            //        var id = Convert.ToInt32(sid);
            //        Piece track = dict[id];
            //        VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
            //        virt.TrackNumber = tn;
            //        current.add(virt);
            //    }


            //}
            int nbLoad = 0;
            var fileAlbum = getSortedAlbumFile();
            using (XmlReader reader = XmlReader.Create(fileAlbum))
            {
                Album current = null;

                while (reader.Read())
                {
                    if (reader.NodeType == XmlNodeType.Element)
                    {

                        if (reader.Name == "a")
                        {
                            var name = reader.GetAttribute("name");
                            var mode = (virtualMode)Enum.Parse(typeof(virtualMode), reader.GetAttribute("mode"), true);
                            current = new Album(name, mode);
                            int tn = 0;
                            this.dict.Add(current.Key, current);


                            var line = reader.ReadElementString();
                            foreach (string sid in line.Split(SEP_TRACK))
                            {

                                var id = Convert.ToInt32(sid);
                                Piece track = dict[id];
                                if (track == null)
                                    continue;
                                if (track.PieceParentId > 0)
                                    continue;
                                if (current.ContainsMaster(track))
                                    continue;
                                var virt = new VirtualAlbumPieceLight(track.Track, track);
                                // VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
                                tn++;
                                virt.TrackNumber = tn;
                                current.add(virt);
                            }

                            nbLoad++;

                        }



                        //else if (reader.Name == "t")
                        //{
                        //    tn++;
                        //    var id = reader.ReadElementContentAsInt();
                        //    Piece track = dict[id];
                        //    VirtualAlbumPiece virt = VirtualAlbumPiece.getVirtual(track.Track, track, current.Name, current.VirtualMode);
                        //    virt.TrackNumber = tn;
                        //    current.add(virt);

                        //}

                    }
                }

            }
            return nbLoad;
        }

        //public void consolidChilds()
        //{
        //    misc.log("consolidChilds");
        //    foreach (Album album in dict.Values)
        //    {
        //        album.ConsolidChilds();
        //    }
        //}

        public bool check(Piece piece)
        {
            return check_(piece, dict);
        }

        //public void check(Piece piece)
        //{
        //    check_(piece, dict);
        //    foreach (Piece child in piece.Childs)
        //        check_(child, dict);
        //}

        public void checkVirtual(Piece piece, IDictionary<string, Album> dict)
        {
            if (piece.Virtual)
            {
                if (!check_(piece, dict))
                {
                }
                // piece.setParent(null);
            }

        }

        public Album getAlbum(Piece piece)
        {
            return piece.PieceAlbum;
            //string __album = "-";
            //var _album = piece.Album;
            //if (!string.IsNullOrEmpty(_album))
            //{
            //    __album = _album.Trim();
            //    return dict[__album];
            //}
            //return null;
        }

        public void buildStack(bool incrementStack)
        {
            // prise en compte de la stack
            var now = DateTime.Now;
            misc.log("stack.build();");
            var confSort = consolid.SortAlbumMode;
            int stackSize = confSort.stackSize;
            stack.Capacity = stackSize;
            Album.ConfAlbumSort = confSort;
            stack.Enabled = confSort.stackEnabled;
            stack.build(incrementStack);
            misc.log("buildStack; {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;
        }

        // private Dictionary<string, Album> invalidated;
        public IDictionary<string, Album> GetAndInvalidateAlbums(Piece piece)
        {
            var invalidated = new Dictionary<string, Album>();
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;

                album.refreshLight();
                if (invalidated.ContainsKey(album.Key))
                { }
                else
                    invalidated.Add(album.Key, album);
            }
            return invalidated;
        }

        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public int makeSort(Piece piece, ILogger logger)
        {
            if (piece == null)
                return 0;
            int nb = 0;
            //var album = piece.PieceAlbum;
            //if (album == null)
            //    return;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Piece p in piece.Master)
            {
                var album = p.PieceAlbum;
                if (album == null)
                    continue;
                goParallel = false;
                while (currentSorted == album)
                    Thread.Sleep(30);
                lock (album)
                {
                    album.refreshLight();
                    album.makeSort(confMedianne, conf0, logger, 0); //listRef, reference);                
                    nb++;
                    //  album.mustRefresh();
                    // pour futures mises au point avec la MAJ des classements( resetOneCl et Compact )
                    album.refreshLight();
                }
            }

            return nb;

        }

        /// <summary>
        /// On fait en premier le makesort de l'album qui a changé
        /// </summary>
        /// <param name="album"></param>
        public int makeSort(IEnumerable<Album> _albums, ILogger logger)
        {
            int nb = 0;
            ConfMedianne confMedianne = null;
            var confSort = consolid.SortAlbumMode;
            foreach (var cmp in confSort.ComposantsUtiles)
            {
                if (cmp.type == medianneMode.light || confMedianne == null)
                    confMedianne = cmp;
            }

            var conf0 = new ConfMedianne(confMedianne, true);
            //var main = confMedianne.Main;
            //var coeffVirt = main.coeffVirt;
            //var safe = main.safe;
            //var coeffOld = main.CoeffOld;
            foreach (Album album in _albums)
            {
                if (album == null)
                    continue;

                goParallel = false;
                while (currentSorted == album)
                    Thread.Sleep(30);
                lock (album)
                {
                    album.refreshLight();

                    album.makeSort(confMedianne, conf0, logger, 0); //listRef, reference); 
                }

                nb++;
                //  album.mustRefresh();
                // pour futures mises au point avec la MAJ des classements( resetOneCl et Compact )
                // album.refreshLight();
            }

            foreach (Album album in _albums)
            {
                if (album == null)
                    continue;
                album.refreshLight();
            }

            return nb;

        }

        // private int nbSort=1;
        //private bool urgence;
        //public void setUrgence() { urgence = true; }
        //public bool Urgence { get { return urgence; } } 
        public void makeSort(bool sortAll, IClient client, ILogger logger)
        {
            lock (_lockSort)
            {
                misc.log("albums.make sort");

                ///check to find first light
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }

                var conf0 = new ConfMedianne(confMedianne, true);
                var main = confMedianne.Main;
                var min = confMedianne.Min;
                var mainCoeffVirt = main.coeffVirt;
                var mainCoeffOld = main.CoeffOld;

                var minCoeffVirt = min.coeffVirt;
                var minCoeffOld = min.CoeffOld;




                if (confSort.reset)
                {
                    main.coeffVirt = 1;
                    main.CoeffOld = 1;
                    min.coeffVirt = 1;
                    min.CoeffOld = 1;
                }

                List<Album> list = new List<Album>(dict.Values);
                List<Album> listw = list;
                HashSet<Album> hs = null;
                DateTime now = DateTime.Now;
                DateTime debut = now;

                bool partial = false;
#if GEN2
                partial = !sortAll && confSort.optimSize > 0 && consolid.Urgence;
#endif

                int step = 0;
                Album last = null;
                // int coeffSort = 1;

                while (true)
                {
                    step++;

                    if (partial)
                    {
                        //nbSort++;
                        //coeffSort = 1; 

                        //int _nbSort = nbSort;
                        //while (_nbSort >=2 && _nbSort % 2 == 0)
                        //{
                        //    coeffSort *= 2;
                        //    _nbSort /= 2; 
                        //}
                        hs = new HashSet<Album>();
                        list.Sort(new AlbumClassComparer2());
                        list.Reverse();
                        listw = new List<Album>();
                        decimal equivLightMax = 0;
                        decimal equivLightZeroMax = 0;
                        int nb = 0;
                        int max = step * confSort.optimSize; // *coeffSort;

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                nb++;
                                listw.Add(a);
                                hs.Add(a);

                                var _classementValueLight = a.ClassementValueLight;
                                if (_classementValueLight > equivLightMax)
                                {
                                    equivLightMax = _classementValueLight;
                                    last = a;
                                }

                                var _classementValueLightZero = a.ClassementValueLightZero;

                                if (_classementValueLightZero > equivLightZeroMax)
                                {
                                    equivLightZeroMax = _classementValueLightZero;
                                    last = a;
                                }

                                if (nb >= max)
                                    break;
                            }
                        }


                        var equivZeroVerif = equivLightZeroMax * pdb.util.Math.Pow(main.coeffVirt, main.safe) * pdb.util.Math.Pow(min.coeffVirt, min.safe) * main.CoeffOld * min.CoeffOld;
                        var dxMin = min.dcoeff;
                        var dxMain = pdb.util.Math.Pow(main.dcoeff, main.safe);
                        var equivVerif = equivLightMax * (dxMain * dxMin);

                        foreach (Album a in list)
                        {
                            if (a.AtLeastOneEnabled)
                            {
                                var _classementValueLight = a.ClassementValueLight;


                                if (_classementValueLight < equivVerif && _classementValueLight < equivZeroVerif)
                                {
                                    if (hs.Add(a))
                                    {
                                        listw.Add(a);
                                        if (_classementValueLight > equivLightMax)
                                        {
                                            equivLightMax = _classementValueLight;
                                            last = a;
                                        }

                                    }
                                }

                            }
                        }

                    }
                    if (!consolid.Urgence)
                    {
                        int nbSorted = 0;
                        //if (invalidated != null && invalidated.Count > 0)
                        //{
                        //    listw = new List<Album>(invalidated.Values);
                        //    invalidated = null;
                        //}
                        listw.Sort((x, y) => x.Count.CompareTo(y.Count));
                        foreach (Album album in listw)
                        {
                            if (client.Cancel)
                                return;

                            goParallel = false;
                            while (currentSorted == album)
                                Thread.Sleep(30);

                            if (album.makeSort(confMedianne, conf0, logger, 100)) //listRef, reference); 
                                nbSorted++;

                        }

                        string infoAlbum = "";
                        if (last != null)
                        {
                            infoAlbum = string.Format("last={0} {1} {2} {3}", last.Tracks[0].RankAlbumReverse, last.EquivLight0, last.EquivLight, last);
                        }
                        //   misc.log(string.Format("makeSort : nbSort={0} coeffSort={1} step={2}  {3} albums {4} ms {5}", nbSort, coeffSort, step, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        misc.log(string.Format("makeSort : step={0}  {1}/{2} albums {3} ms {4}", step, nbSorted, listw.Count, (DateTime.Now - now).TotalMilliseconds, infoAlbum));
                        client.log(string.Format("album.makeSort {0} elt", nbSorted));
                    }
                    now = DateTime.Now;
                    //if (confSort.reset)
                    //{
                    main.coeffVirt = mainCoeffVirt;
                    main.CoeffOld = mainCoeffOld;
                    min.coeffVirt = minCoeffVirt;
                    min.CoeffOld = minCoeffOld;

                    // }


                    list.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, null));
                    misc.log("list.Sort(new AlbumClassComparer {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;


                    list.Reverse();
                    misc.log("list.Reverse(); {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    client.log("AlbumClassComparer");

                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (album.AtLeastOneEnabled)
                            RankZero = i + 2;
                        album.Quality = i + 1;
                    }
                    client.log("album.Quality");
                    misc.log("album.Quality {0} ms", (DateTime.Now - now).TotalMilliseconds.ToString("0")); now = DateTime.Now;

                    if (!partial)
                        break;


                    list.Reverse();

                    int nbCheck = 0;
                    bool? check = null;
                    foreach (Album a in list)
                    {
                        if (!a.AtLeastOneEnabled)
                            continue;
                        if (hs.Contains(a))
                        {
                            nbCheck++;
                            if (nbCheck >= confSort.optimCheck) // * coeffSort)
                            {
                                check = true;
                                break;
                            }
                        }
                        else
                        {
                            check = false;
                            break;
                        }


                    }

                    if (check == null || check.Value)
                        break;

                }


                misc.log(string.Format("makeSort albums total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));

                List<Album> listSt = null;
                List<Album> list0 = null;
                List<Album> listSt0 = null;


                if (confSort.sortSt || confSort.correcMainRank || confSort.correcMainCoeff || confSort.correcMainZero)
                {
                    listSt = new List<Album>(list);

                    listSt.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, null));
                    listSt.Reverse();
                    for (int i = 0; i < list.Count; i++)
                    {
                        listSt[i].RankSt = i + 1;
                    }
                    misc.log(string.Format("sort St : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sort0)
                {
                    now = DateTime.Now;
                    list0 = new List<Album>(list);

                    list0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, false, conf0));
                    list0.Reverse();
                    for (int i = 0; i < list0.Count; i++)
                    {
                        list0[i].RankZero = i + 1;
                    }
                    misc.log(string.Format("sort 0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.sortSt0 || confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    listSt0 = new List<Album>(list);

                    listSt0.Sort(new AlbumClassComparer(consolid.SortAlbumMode, true, conf0));
                    listSt0.Reverse();
                    for (int i = 0; i < listSt0.Count; i++)
                    {
                        listSt0[i].RankZeroSt = i + 1;
                    }
                    misc.log(string.Format("sort St0 : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                client.log("tri pour faire joli");
#if GEN2
                if (confSort.correcMainRank)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;

                                if (o.RankZero > un.RankZero)
                                {
                                    correc = false;
                                    break;
                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }
                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }



                    //now = DateTime.Now;
                    //for (int i = listSt.Count - 1; i >= 0; i--)
                    //{
                    //    Album un = listSt[i];
                    //    Album zero = listSt0[i];
                    //    if (un.DontTouchSelectedCoeff)
                    //        continue;
                    //    if (un == zero)
                    //        un.InvalidateMain();
                    //}
                    misc.log(string.Format("correcMainRank : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

                if (confSort.correcMainCoeff)
                {
                    now = DateTime.Now;
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {
                            var next = un.Next;
                            if (next == null)
                                continue;
                            var coeff = next.CoeffVirtuel;
                            if (coeff == 1m)
                                continue;
                            var redresse = un.ClassementValueLightSt * coeff;
                            bool correc = false;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == next.MasterId)
                                    continue;
                                var cmp = o.ClassementValueLightSt;
                                if (cmp > redresse)
                                {
                                    correc = true;
                                    break;
                                }

                                if (cmp < redresse && o.SelectedCoeff == selectedCoeff.noCoeff)
                                {
                                    correc = false;
                                    break;
                                }

                                var coeff2 = onext.CoeffVirtuel;

                                var redresse2 = coeff2 * cmp;
                                if (redresse2 < redresse)
                                {
                                    correc = false;
                                    break;
                                }
                            }

                            if (correc)
                                un.InvalidateMain();

                        }
                    }
                    misc.log(string.Format("correcMainCoeff : {0} ms", (DateTime.Now - now).TotalMilliseconds));

                }
                if (confSort.correcMainZero)
                {
                    now = DateTime.Now;
                    var hsBefore = new HashSet<int>();
                    for (int i = list.Count - 1; i >= 0; i--)
                    {
                        Album un = listSt[i];
                        var unNext = un.Next;
                        if (unNext == null)
                            continue;
                        hsBefore.Add(unNext.MasterId);
                        if (un.DontTouchSelectedCoeff)
                            continue;
                        if (!confSort.dontTouchMain && un.SelectedCoeff > selectedCoeff.noCoeff || un.SelectedCoeff == selectedCoeff.min)
                        {




                            bool correc = true;
                            int nbTry = 0;
                            int nbMaxTry = confSort.correcMainZeroOptim;
                            if (nbMaxTry <= 0)
                                nbMaxTry = int.MaxValue;
                            var hsTestes = new HashSet<int>();
                            bool unClassementRecent = unNext.LastClassementRecent;
                            for (int j = i - 1; j >= 0; j--)
                            {
                                var o = listSt[j];
                                if (o.Name == "Ill Communication")
                                {
                                }
                                var onext = o.Next;
                                if (onext == null)
                                    continue;
                                if (onext.MasterId == unNext.MasterId)
                                    continue;
                                if (o.StackValue > 0)
                                    continue;
                                if (!hsTestes.Add(onext.MasterId))
                                    continue;
                                if (hsBefore.Contains(onext.MasterId))
                                    continue;


                                if (o.ClassementValueLightZeroSt < un.ClassementValueLightZeroSt)
                                {
                                    if (o.RankZero > un.RankZero)
                                    {
                                        correc = false;
                                        break;
                                    }
                                }

                                if (!unClassementRecent)
                                {
                                    if (o.ClassementValueLightZeroSt == un.ClassementValueLightZeroSt)
                                    {
                                        if (confSort.correcMainZeroCheckEquality)
                                        {
                                            if (onext.LastClassementRecent)
                                            {
                                                if (o.RankZero > un.RankZero)
                                                {
                                                    correc = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                }


                                if (nbMaxTry == int.MaxValue)
                                    continue;



                                if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                {
                                    nbTry++;
                                    if (nbTry > nbMaxTry)
                                        break;
                                }


                                //if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //    break;
                                // }



                                //if (o.RankSt <= un.RankSt)
                                //{
                                //    if (o.RankZeroSt > un.RankZeroSt)
                                //    {
                                //        correc = false;
                                //        break;
                                //    }

                                //    if (o.ClassementValueLightSt > un.ClassementValueLightZeroSt)
                                //        break;
                                //}

                            }



                            if (true == correc)
                                un.InvalidateMain();
                            else
                            {
                            }

                        }



                    }


                    misc.log(string.Format("correcMainZero : {0} ms", (DateTime.Now - now).TotalMilliseconds));
                }

#endif


                //var listStack = stack.Albums;
                //foreach (Album s in listStack)
                //{
                //    string key = getKey(s.Name);
                //    var alb = dict[key];
                //    stack.merge(s, alb);
                //}
                //list.Sort(new AlbumClassComparerStack());
                //for (int i = 0; i < list.Count; i++)
                //{
                //    list[i].Rank2 = i + 1; 
                //}
                var limit = CConf.ConfGen.LimitAlbums;
                if (limit > 0)
                {
                    var l = new List<Album>();
                    list.Sort(new AlbumClassComparer2());
                    for (int i = 0; i < list.Count; i++)
                    {
                        var album = list[i];
                        if (i < limit)
                        {
                            l.Add(album);
                            album.ConsolidChilds();
                            album.sortVirtual();
                        }
                        else
                        {
                            album.ClearAndMenage();
                            dict.Remove(album.Key);
                        }
                    }
                    list = l;

                }

                misc.log(string.Format("makeSort total : {0} ms", (DateTime.Now - debut).TotalMilliseconds));
            }
        }

        public List<Album> makeSelection()
        {
            misc.log("albums.makeSelection");
            var now = DateTime.Now;
            var list = new List<Album>(dict.Values);

            //var confGen = CConf.ConfGen;
            //var min1 = confGen.AlbumMin;
            //var min2 = confGen.PathVirtualMin;
            //var min3 = confGen.AristVirtualMin;
            //foreach (Album album in dict.Values)
            //{
            //    int count = album.Count;
            //    bool toKeep = true;


            //    if (album.Virtual)
            //    {
            //        if (album.VirtualByArtist)
            //        {
            //            if (min3 > 1 && count < min3)
            //                toKeep = false;
            //        }
            //        else if (min2 > 1 && count < min2)
            //            toKeep = false;
            //    }
            //    else if (min1 > 1 && count < min1)
            //        toKeep = false;



            //    if (!toKeep)
            //    {
            //        misc.log("mise au rencard de {0} {1}", album.Name, (count > 0 ? "" : count.ToString() + " éléments"));
            //    }
            //    else
            //        list.Add(album);

            //}

            foreach (Album album in list)
            {
                album.makeSelection();
            }
            //list.Sort(new AlbumRestComparer());
            //for (int i = 0; i < list.Count; i++)
            //{
            //    list[i].Rank.RankRest = i + 1;
            //}

            misc.log(string.Format("make selection : {0} ms", (DateTime.Now - now).TotalMilliseconds));
            return list;
        }

        //public void changeAlbum(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Album, false)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();
        //    check_(p, newA, false, this.dict);
        //    var newAlb = dict[getKey(newA, false)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();

        //    //  invalidate(p); 
        //}

        //public void changeArtist(Piece p, string newA)
        //{
        //    var currentAlb = dict[getKey(p.Artist, true)];
        //    if (currentAlb != null)
        //        currentAlb.mustRefresh();

        //    check_(p, newA, true, this.dict);
        //    var newAlb = dict[getKey(newA, true)];
        //    if (newAlb != null)
        //        newAlb.mustRefresh();
        //    p.albumMustRefresh();
        //}

        public void checkVirtuals(IEnumerable<Album> candidats, List<Piece> list)
        {
            foreach (Album candidat in candidats)
            {
                //if (candidat.VirtualMode == virtualMode.added)
                //{
                //    if (candidat.Name=="09/1012")
                //    {

                //    }
                //    if (candidat.Name =="22/09/2012")
                //    {

                //    }
                //}
                bool found = false;

                foreach (Piece p in candidat)
                {
                    var master = p.Master.PieceAlbum;
                    if (master.isSameOf(candidat))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    foreach (Album album in dict.Values)
                    {
                        if (album.isSameOf(candidat))
                        {
                            found = true;
                            break;
                        }
                    }
                }

                if (found)
                {
                    // on ne le prend pas (car identique à un existant)
                    // on n'oublie pas de supprimer les fils
                    candidat.ClearAndMenage();
                }
                else
                {
                    // on le prend.
                    string key = getKey(candidat.Name, candidat.VirtualMode);
                    //if (!dict0.ContainsKey(key))
                    //    dict0.Add(key, candidat);
                    dict.Add(key, candidat);
                    foreach (Piece p in candidat)
                    {
                        //   p.consolidChild();
                        list.Add(p);
                    }
                }
            }
        }


        public List<Album> RawList
        {
            get
            {
                return new List<Album>(dict.Values);
            }
        }

        public List<Album> List
        {
            get
            {
                var list = new List<Album>();
                foreach (Album album in dict.Values)
                    list.Add(album);
                list.Sort(new AlbumNameComparer());
                return list;
            }
        }
        //public List<Album> ListByUpdate
        //{
        //    get
        //    {
        //        var list = new List<Album>();
        //        foreach (Album album in dict.Values)
        //            list.Add(album);
        //        list.Sort(new AlbumLastModifClassementComparer());

        //        return list;
        //    }
        //}

        public void signalClassChange(Piece track)
        {
            track.albumMustRefresh();
            //var album = getAlbum(track);
            //if (album == null)
            //    return;
            //album.mustRefresh();

            //var master = track.Piece.Master;
            //master.PieceAlbum.mustRefresh();
            //foreach (Piece child in master)
            //    child.PieceAlbum.mustRefresh();
            stack.Add(track);

        }


        private bool goParallel;
        public void parallelSort()
        {
            goParallel = true;
        }
        public void endParallelSort()
        {
            goParallel = false;
        }
        private void loop()
        {
            while (true)
            {

                currentSorted = null;
                Thread.Sleep(3000);
                if (!goParallel)
                    continue;
                var list = new List<Album>(dict.Values);
                if (!goParallel)
                {
                    logScan.log("arret list = new List<Album>(dict.Values) ");
                    continue;
                }
                list.Sort((x, y) => (x.MajDate.CompareTo(y.MajDate)));
                if (!goParallel)
                {
                    logScan.log("arret list.Sort((x, y) => (x.MajDate.CompareTo(y.MajDate)));");
                    continue;
                }
                ConfMedianne confMedianne = null;
                var confSort = consolid.SortAlbumMode;
                foreach (var cmp in confSort.ComposantsUtiles)
                {
                    if (cmp.type == medianneMode.light || confMedianne == null)
                        confMedianne = cmp;
                }
                var conf0 = new ConfMedianne(confMedianne, true);
                if (!goParallel)
                {
                    logScan.log("arret confMedianne;");
                    continue;
                }


                foreach (Album album in list)
                {
                    if (!goParallel)
                    {
                        logScan.log("arret avant album " + album);
                        break;
                    }

                    lock (album)
                    {
                        if (!goParallel)
                        {
                            logScan.log("arret sur lock album " + album);
                            break;
                        }
                        currentSorted = album;
                        album.mustRefresh();
                        album.makeSort(confMedianne, conf0, logScan, 100);
                    }
                }
                if (goParallel)
                {
                    logScan.log("fin sans interruption");
                    goParallel = false;
                }
            }
        }

        #region invalider


        public void invalidateAll(bool total)
        {
            foreach (var a in dict.Values)
            {
                if (total)
                    a.mustRefresh();
                else
                    a.refreshLight();
            }
        }
        //public void invalidate(Piece piece)
        //{
        //    foreach (var p in piece.Master)
        //    {
        //        var key = getKey(p.Album, p.VirtualByArtist);
        //        var a = dict[key];
        //        if (a == null)
        //        {
        //        }
        //        else
        //            a.invalidate();
        //        //if (p.Virtual)
        //        //    continue; 
        //        ////1. check standard
        //        //var key = getKey(p.Album, false);
        //        //var a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 
        //        ////2. check artiste
        //        //key = getKey(p.Artist, true);
        //        //a = dict[key];
        //        //if (a == null)
        //        //{
        //        //}
        //        //else
        //        //    a.invalidate(); 

        //        ////3. check paths
        //        //foreach (string path in p.getIntermediaryPath())
        //        //{
        //        //    key = getKey(path, false);
        //        //    a = dict[key];
        //        //    if (a == null)
        //        //    {
        //        //    }
        //        //    else
        //        //        a.invalidate(); 
        //        //}
        //    }
        //}
        #endregion





    }
}
]]></content>
  </file>
  <file path="db4File\pieceDb.iT\TrackInfoItunes.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using iTunesLib;
using pdb.it.persistance;
using pdb.obj;
using pdb.ordo;
using pdb.util;
using System.Linq;
using System.Linq.Expressions;
using pdb.util.RelativePath;
//using pdb.it.Albums;

namespace pdb.it
{
    public class TrackInfoItunes : ITrackInfoItunes
    {
        protected static Logger log = Logger.getLogger("Track");
        private static Loader loader;
        //protected static IAlbumMgr albumMgr;
        //public static IAlbumMgr AlbumMgr { set { albumMgr = value; } get { return albumMgr; } }
        public static Loader Loader { set { loader = value; } }
        protected IITFileOrCDTrack track;
        protected IITFileOrCDTrack tracktrack;

        // private TrackPlayListManager listManager = new TrackPlayListManager();
        //  private string className = "";
        // private int index;

        private static BackGroundTaskMgr bg = BackGroundTaskMgr.getMgr("Track", 12);
        private static BackGroundTaskMgr bgg = BackGroundTaskMgr.getMgr("Group", 12);
        //private static BackGroundTaskMgr bgGroupPrior = BackGroundTaskMgr.getMgr("PriorG", 11);
        //private static BackGroundTaskMgr bgGroup2nd = BackGroundTaskMgr.getMgr("SeconG", 13);
        //private static BackGroundTaskMgr bgGroupDelta = BackGroundTaskMgr.getMgr("DeltaG", 11);
        // private static BackGroundTaskMgr bgFirstClass = BackGroundTaskMgr.getMgr("FirstClass", 10);
        //private static BackGroundTaskMgr bgSeconClass = BackGroundTaskMgr.getMgr("SeconClass", 10);
        protected static BackGroundTaskMgr bgClass = BackGroundTaskMgr.getMgr("Classement", 0);
        protected static BackGroundTaskMgr bgImport = BackGroundTaskMgr.getMgr("Import", 0);
        protected static BackGroundTaskMgr bgHibernate = BackGroundTaskMgr.getMgr("Hibernate", 0);
        // private TrackPersistantId persistentId;
        private bool loaded;

        // private ITrackNative local;
        // public void registerDependency(ITrackNative local) { this.local = local; }
        public void releaseDependency() { }

        //public TrackPersistantId PersistantId { set { persistentId = value; } }

        //public virtual void setAlbum(string album)
        //{
        //    albumMgr.setAlbum(this, album);
        //}

        public class TrackClassNameEventArgs : EventArgs
        {
            public TrackClassNameEventArgs(string value) { this.Value = value; }
            readonly public string Value;
        }

        public event EventHandler<TrackClassNameEventArgs> classNameChanged;

        private void OnClassNameChange(string value) { if (classNameChanged != null) classNameChanged(this, new TrackClassNameEventArgs(value)); }

#if VERIF
        public void verif()
        {
            var toto = loader.getTrack(this);
        }

#endif

        protected int playCount = 0;
        public int PlayCount { get { return playCount; } }
        //public TrackInfoItunes(IITFileOrCDTrack track)
        //{

        //    this.track = track;
        //    this.playedDate = track.PlayedDate;
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;

        //    Fill();


        //}

        private void Fill()
        {
            var track = this.track;
            if (track == null)
                track = this.tracktrack;
            if (track == null)
                return;

            this.id = track.TrackDatabaseID;

            this.artist = track.Artist;
            this.album = track.Album;

            this.name = track.Name;
            this.trackNumber = track.TrackNumber;
            this.rating = track.Rating;
            this.year = track.Year;
            // this.comment = track.Comment;
            this.enabled = track.Enabled;
            this._isPodCast = track.Podcast;
            // this.playedDate = track.PlayedDate;
            this.file = RelativeFileRegister.Get(track.Location);
            //this.grouping = track.Grouping;
            this.playCount = track.PlayedCount;

            fillDesc(track);




        }

        //private void FIll(IITURLTrack track)
        //{
        //    this.id = track.TrackDatabaseID;

        //    this.artist = track.Artist;
        //    this.album = track.Album;
        //    this.name = track.Name;
        //    this.trackNumber = track.TrackNumber;
        //    this.rating = track.Rating;
        //    this.year = track.Year;
        //    // this.comment = track.Comment;
        //    this.enabled = track.Enabled;
        //    // this._isPodCast = track.Podcast;
        //    // this.playedDate = track.PlayedDate;
        //    //  this.location = track.Location;
        //    //this.grouping = track.Grouping;
        //    this.playCount = track.PlayedCount;
        //    this.location = track.URL;
        //    if (string.IsNullOrEmpty(description))
        //        description = track.Description;
        //    if (string.IsNullOrEmpty(longDescription))
        //        longDescription = track.LongDescription;
        //}

        public virtual bool Played { get { return this.playCount > 0; } }


        //public TrackInfoItunes(XmlNode xTrack)
        //{
        //    build(xTrack);
        //}

        public TrackInfoItunes()
        {
        }

        protected bool present;
        public bool Present
        {
            get { return present; }
            set { present = value; }
        }

        public void makeRead()
        {
            var track = this.track;
            if (track == null)
                track = tracktrack;
            if (track == null)
                return;
            track.PlayedCount = 1;

        }

        public static int getID(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID": return Convert.ToInt32(value);


                }
            }
            return -1;
        }

        public static string getLocation(XmlNode xTrack)
        {

            string key = "";
            bool nextIgnore = false;

            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Location":
                    Uri uri = new Uri(value);
                    return uri.LocalPath.Replace(@"\\localhost\", "");



                }
            }
            return "";
        }

        public virtual void build(IITFileOrCDTrack track)
        {

            this.tracktrack = track;
            this.track = track;
            this.PlayedDate = track.PlayedDate;
            this.duration = TimeSpan.FromSeconds(track.Duration);
            this.comment = track.Comment;
            this.grouping = track.Grouping;
            this.added = track.DateAdded;


            Fill();
        }

        //public void build(IITURLTrack track)
        //{
        //    this.duration = TimeSpan.FromSeconds(track.Duration);
        //    this.comment = track.Comment;
        //    this.grouping = track.Grouping;
        //    this.added = track.DateAdded;
        //    FIll(track);
        //}



        public virtual void build(XmlNode xTrack)
        {
            enabled = true;
            playCount = 0;
            rating = 0;
            string key = "";
            bool nextIgnore = false;
            _isPodCast = false;


            foreach (XmlNode node in xTrack.ChildNodes)
            {
                string value = node.InnerText;
                if (node.Name == "key")
                {
                    key = value;
                    if (key == "Podcast")
                    {
                        _isPodCast = true; nextIgnore = true;
                        continue;
                    }

                    if (key == "Disabled")
                    {
                        enabled = false; nextIgnore = true; continue;
                    }
                    continue;
                }


                if (nextIgnore)
                {
                    nextIgnore = false;
                    continue;
                }


                if (string.IsNullOrEmpty(value))
                    continue;

                switch (key)
                {
                    case "Track ID":
                    id = Convert.ToInt32(value);
                    break;
                    case "Name":
                    name = value;
                    break;
                    case "Artist": artist = value; break;
                    case "Album": album = value; break; // albumMgr.setAlbum(this, value); break;
                    case "Total Time": duration = TimeSpan.FromMilliseconds(Convert.ToDouble(value)); break;
                    case "Track Number": trackNumber = Convert.ToInt32(value); break;
                    case "Comments": if (!loaded) comment = value; break;
                    case "Play Date UTC": PlayedDate = Convert.ToDateTime(value); break; // DateTime.SpecifyKind(Convert.ToDateTime(value), DateTimeKind.Utc); break;// Convert.ToDateTime(value); break;
                    case "Rating": rating = Convert.ToInt32(value); break;
                    case "Location":
                    Uri uri = new Uri(value);
                    var location = uri.LocalPath.Replace(@"\\localhost\", "");
                    file = RelativeFileRegister.Get(location);
                    break;
                    case "Year": year = Convert.ToInt32(value); break;
                    case "Grouping": if (!loaded) grouping = value; break;
                    case "Kind":
                    if (value.Equals("Flux audio sur Internet") || value.Equals("Flux audio MPEG"))
                        strange = true; break;
                    case "Track Type": if (!"File".Equals(value)) strange = true; break;
                    case "Play Count": playCount = Convert.ToInt32(value); break;

                    case "Volume Adjustment":
                    if (!loaded)
                        volume = Convert.ToInt32(value);

                    break;
                }

            }
            loaded = true;
        }

        public virtual void export(XmlWriter w)
        {

        }



        private int id;
        //public int TrackId { get { return track.trackID; } }
        public int ID { get { return id; } }

        public virtual IITFileOrCDTrack TrackTrack
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (tracktrack == null)
                {
                    var _t = loader.getTrackTrack(this);
                    if (_t != null)
                    {
                        tracktrack = _t.Track;
                        // persistentId = _t.Id;
                    }
                }
                fillDesc(tracktrack);
                return tracktrack;
            }
            set
            {
                tracktrack = value;
            }
        }

        private string description;
        private string longDescription;

        public string Description { get { return description; } protected set { description = value; } }
        public string LongDescription { get { return longDescription; } protected set { longDescription = value; } }


        public void fillDesc(IITFileOrCDTrack track)
        {
            if (track == null)
                return;
            if (string.IsNullOrEmpty(description))
                description = track.Description;
            if (string.IsNullOrEmpty(longDescription))
                longDescription = track.LongDescription;
        }
        public virtual IITFileOrCDTrack Track
        {
            get
            {
                if (!present)
                    return new NoTrack(this);
                if (track == null)
                {
                    var t = loader.getTrack(this);
                    if (t != null)
                    {
                        track = t;
                    }

                }

                if (track == null)
                    return TrackTrack;

                fillDesc(track);
                return track;

            }
            set
            {
                track = value;
            }
        }



        #region ITrackNative Membres
        private string artist = "";
        private static BackGroundTaskMgr bgArtist = BackGroundTaskMgr.getMgr("Artist", 0);
        public string Artist
        {
            get
            {
                return artist;
            }
            set
            {
                if (value == null || value.Equals(artist)) return;
                if (string.IsNullOrEmpty(file.file))
                    artist = value;
                else
                {
                    bgArtist.add(new Bgtask(() =>
                    {
                        Track.Artist = value;
                        artist = value;
                    }, this, "change artist from '{0}' to'{1}' {2}", artist, value, this
                    ));
                }


            }
        }
        //protected IAlbum _album;
        //public IAlbum TrackAlbum { get { return _album; } set { _album = value; } }
        private static BackGroundTaskMgr bgAlbum = BackGroundTaskMgr.getMgr("Album", 0);
        public virtual string AlbumKey { get { return Album.toKey(); } }
        protected string album;
        public virtual string Album
        {
            get
            {
                return album;
            }
            set
            {
                if (value == null || value.Equals(album)) return;
                if (string.IsNullOrEmpty(file.file))
                    album = value;
                else
                {
                    bgAlbum.add(new Bgtask(() =>
                    {
                        // log.log("change album from '{0}' to'{1}' {2}", album, value, this);
                        Track.Album = value;
                        // albumMgr.setAlbum(this, value);
                    }, this,
                    "change album from '{0}' to'{1}' {2}", Album, value, this
                    ));
                }

            }
        }
        protected string name = "";
        private static BackGroundTaskMgr bgName = BackGroundTaskMgr.getMgr("Name", 0);
        public virtual string Name
        {
            get
            {
                return name;
            }
            set
            {
                if (value == null || value.Equals(name)) return;
                if (string.IsNullOrEmpty(file.file))
                    name = value;
                else
                {

                    int lengh = 0;
                    if (name != null)
                        lengh = name.Length;

                    if (value.Length < lengh)
                    {
                        log.log("Attention On raccourcit le nom !!! {0}->{1} {2}", name, value, this);
                        // return; 
                    }




                    var bgtaskName = new BgTaskName(this, string.Format("change name from '{0}' to '{1}' {2}", name, value, this), value);
                    bgName.add(bgtaskName);
                }

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }

        protected string composer = "";
        private static BackGroundTaskMgr bgComposer = BackGroundTaskMgr.getMgr("Composer", 0);
        public virtual string Composer
        {
            get
            {
                if (present && string.IsNullOrEmpty(composer))
                {
                    var t = Track;
                    if (t != null)
                        composer = t.Composer;
                }
                return composer;
            }
            set
            {
                if (!present)
                {
                    composer = value;
                    return;
                }

                if (value == null || value.Equals(composer)) return;

                var t = Track;
                if (t != null)
                    composer = t.Composer;
                if (value.Equals(composer))
                    return;


                var bgtaskComposer = new BgTaskComposer(this, string.Format("change composer from '{0}' to '{1}' {2}", composer, value, this), value);
                bgComposer.add(bgtaskComposer);

                //bgClass.add(new Bgtask(() =>
                //{
                //    // log.log("change name from '{0}' to'{1}' {2}", name, value, this);
                //    Track.Name = value;
                //    name = value;
                //}, this,
                //   "change name from '{0}' to'{1}' {2}", name, value, this));
            }
        }


        private int trackNumber;
        public int TrackNumber
        {
            get
            {
                return trackNumber;
            }
            set
            {
                if (trackNumber != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //    log.log("change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this);
                        Track.TrackNumber = value;
                        trackNumber = value;
                    }, this,
                    "change trackNumber from '{0}' to'{1}' {2}", trackNumber, value, this));
                }
            }
        }
        protected int rating = 0;
        public int Rating
        {
            get
            {
                return rating;
            }
            set
            {
                if (rating != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        //     log.log("change rating from '{0}' to'{1}' {2}", rating, value, this);
                        Track.Rating = value;
                        rating = value;
                    }, this,
                     "change rating from '{0}' to'{1}' {2}", rating, value, this));
                }
            }
        }
        private int year;
        public int Year
        {
            get
            {
                return year;
            }
            set
            {
                if (year != value)
                {
                    bgClass.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.Year = value;
                        year = value;
                    }, this,
                    "change year from '{0}' to'{1}' {2}", year, value, this));

                }
            }
        }
        private string comment = "";
        //private bool firstClass;
        //public bool FirstClass { get { return firstClass; } set { firstClass = value; } }
        // public void makeFirstClass() { firstClass = true; }
        protected static BackGroundTaskMgr bgComment = BackGroundTaskMgr.getMgr("Comment", 0);
        public string Comment
        {
            get
            {
                if (present && string.IsNullOrEmpty(comment))
                {
                    var t = Track;
                    if (t != null)
                        comment = t.Comment;
                }
                return comment;
            }
            set
            {
                if (!present)
                {
                    comment = value;
                    return;
                }
                // firstClass = false;
                if (comment != value)
                {
                    //try
                    //{
                    //    var tab0 = comment.Split(' ');
                    //    var tab1 = value.Split(' ');

                    //    var count0 = tab0.GetLength(0);
                    //    var count1 = tab1.GetLength(0);

                    //    if (count0 != count1)
                    //        firstClass = true;

                    //    else if (comment.Length > 3)
                    //    {
                    //        string org = tab0[count0 - 1];
                    //        string fin = tab1[count1 - 1];

                    //        firstClass = !org.Equals(fin);
                    //    }
                    //}

                    //catch
                    //{
                    //    firstClass = true;
                    //}

                    //var sb = new StringBuilder();
                    //sb.Append(ClassName);
                    //sb.Append(".");
                    //sb.Append((Rating / 20).ToString());

                    var task = new BgTaskComment(this, string.Format(" change comment from '{0}' to '{1}' {2}", comment, value, this), value);

                    //if (firstClass)
                    //    bgFirstClass.add(task);
                    //else
                    bg.add(task);
                    // comment = value;
                }
            }
        }
        protected bool enabled = true;
        public virtual bool Enabled
        {
            get
            {
                return enabled;
            }
            set
            {
                if (enabled != value)
                {
                    bgClass.add(new BgTaskCheck(this, "uncheck " + this));

                    //bg.add(new Bgtask(() =>
                    //{
                    //    // log.log("change enbled from '{0}' to'{1}' {2}", enabled, value, this);
                    //    Track.Enabled = value;
                    //    enabled = value;
                    //}, this,
                    //"change enabled from '{0}' to'{1}' {2}", enabled, value, this));
                }
            }
        }
        protected bool _isPodCast;
        public bool isPodcast
        {
            get { return _isPodCast; }
        }
        protected List<DateTypee> dates = null;
        //  private DateTime playedDate;
        public const short TYPE_DATE = 0;
        public const short TYPE_DISABLE = 1;
        public DateTime PlayedDate
        {
            get
            {
                if (dates == null || dates.Count == 0)
                    return DateTime.MinValue;
                var date = dates.FirstOrDefault(d => d.type == TYPE_DATE); 
                if (date == null)
                    return DateTime.MinValue;
                return date.date; 
            }

            set
            {
                var playedDate = PlayedDate;
                if (value > playedDate && value > DateTime.MinValue)
                {
                    var dt = (value - playedDate).TotalHours;
                    if (dt > 2 || dt < -2)
                    {
                        if (dates == null)
                            dates = new List<DateTypee>();
                        dates.Insert(0, new DateTypee(value, TYPE_DATE)); 
                    }
                    else
                        return;

                }
                playedDate = value;
            }
        }

        public List<DateTypee> Dates
        {
            get
            {
                return dates;
            }
            set
            {
                dates = value;
                dates.Sort((x,y)=>-x.date.CompareTo(y.date));
               // dates.Reverse();
            }
        }

        //public List<DateTime> otherDates()
        //{
        //    var o = new List<DateTime>(); 
        //    if (dates.Count <=1)
        //        return o; 
        //    for (int i=1; i< dates.Count; i++)
        //    {
        //        o.Add(dates[i]); 
        //    }
        //    return o; 
        //}
       
        protected RelativeFile file;
        public string Location { get { if (file == null) return ""; return file.file; } }
        public RelativeFile File { get { return file; } set { file = value; } }

        protected string url;
        public string Url
        {
            get { return url; }
            set
            {
                if (string.IsNullOrEmpty(url))
                    url = value;
            }

        }

        private TimeSpan duration;
        public virtual TimeSpan Duration
        {
            get { return duration; }
            set { duration = value; }
        }


        private string artWork;
        public string ArtWork
        {
            get
            {
                return artWork;
            }
            set
            {
                if (value != artWork)
                {
                    log.log("change ArtWork from {0}  {1}  {2}", artWork, value, this);
                    IITArtworkCollection artworks = Track.Artwork;
                    string path = Track.Location + Path.DirectorySeparatorChar + artWork;
                    if (artworks == null || artworks.Count == 0)
                    {
                        Track.AddArtworkFromFile(path);
                    }
                    else
                    {
                        artworks[0].SetArtworkFromFile(path);
                    }
                    artWork = value;

                }

            }
        }

        private string grouping = "";
        public string Grouping
        {
            get
            {
                return grouping;
            }

            set
            {
                if (!present)
                {
                    grouping = value;
                    return;
                }
                if (grouping != value)
                {
                    var task = new BgTaskGrouping(this, string.Format("change grouping from '{0}' to'{1}' {2}", grouping, value, this), value);
                    bgg.add(task);
                }
            }


        }

        //public void setGrouping(string value, bool prior)
        //{
        //    if (!present)
        //    {
        //        grouping = value;
        //        return;
        //    }
        //    if (grouping != value)
        //    {
        //        bool _delta = false;
        //        // bool _deltaRank = false; 
        //        string rankAlbum = "";
        //        string equivAlbum = "";
        //        if (value != null)
        //        {
        //            string[] org = grouping.Split(' ');
        //            string[] _new = value.Split(' ');

        //            int count = org.GetLength(0);
        //            if (_new.GetLength(0) != count || count < 3)
        //                _delta = true;
        //            else
        //            {
        //                rankAlbum = _new[1];
        //                equivAlbum = _new[2];
        //                if (!org[1].Equals(_new[1]))
        //                {
        //                    _delta = true;
        //                }
        //            }
        //        }

        //        var sb = new StringBuilder();
        //        sb.Append(rankAlbum);
        //        sb.Append(" ");
        //        sb.Append(equivAlbum);
        //        sb.Append(" ");
        //        sb.Append(Album);
        //        //sb.Append(ClassName);
        //        //sb.Append(".");
        //        //sb.Append((Rating / 20).ToString());

        //        var task = new BgTaskGrouping(this, string.Format("{0} change grouping from '{1}' to'{2}' {3}", sb.ToString(), grouping, value, this), value);

        //        if (firstClass)
        //        {
        //            bgSeconClass.add(task);
        //            return;
        //        }

        //        //if (prior)
        //        //{
        //        //    bgGroupPrior.add(task);
        //        //    return;
        //        //}



        //        if (_delta)
        //        {
        //            if (prior)
        //                bgGroupPrior.add(task);
        //            else
        //                bgGroup2nd.add(task);
        //            return;
        //        }

        //        bgg.add(task);

        //        //if (_delta)
        //        //    bgGroupDelta.add(task);
        //        //else
        //        //{
        //        //    bgg.add(task);
        //        //}
        //        //  grouping = value;
        //    }
        //}



        private int volume;
        private static BackGroundTaskMgr bgVolume = BackGroundTaskMgr.getMgr("Volume", 0);
        public int Volume
        {

            get { return volume; }
            set
            {
                if (!present)
                {
                    volume = value;
                    return;
                }
                if (volume != value)
                {
                    int _value = loader.VolumeMin;
                    if (value > _value)
                        _value = value;
                    bgVolume.add(new Bgtask(() =>
                    {
                        // log.log("change year from '{0}' to'{1}' {2}", year, value, this);
                        Track.VolumeAdjustment = _value;
                        volume = _value;
                    }, this,
                    "change volume from '{0}' to '{1}' {2}", volume, _value, this));

                }
            }

        }

        #endregion

        private bool strange = false;
        public bool Strange { get { return strange; } }
        public override string ToString()
        {
            return file.file;
        }



        //public List<CPlayList> PLayLists
        //{
        //    get { return listManager.PLayLists; }
        //}

        //public List<CPlayList> ClassPlayLists
        //{
        //    get { return listManager.ClassPlayLists; }
        //}

        //public void AddPlayList(CPlayList a_playList)
        //{
        //    listManager.AddPlayList(a_playList);
        //    // className = listManager.ClassName;
        //}

        //public void removePlayList(CPlayList list)
        //{
        //    listManager.removePlayList(list);
        //    // className = listManager.ClassName;
        //}


        //public string ClassName
        //{
        //    get
        //    {
        //        className = listManager.ClassName;
        //        return className;
        //    }
        //    set
        //    {
        //        className = listManager.ClassName;
        //        if (className != value)
        //        {
        //            bgClass.add(new Bgtask(() =>
        //            {
        //                loader.setClassPlayList(this, className, value);
        //                className = value;
        //            }, this,
        //           "change className from '{0}' to'{1}' {2}", className, value, this));


        //            //log.log("change Class Name from '{0}' to'{1}' {2}", className, value, this);
        //            //className = value;
        //            //OnClassNameChange(value);
        //        }
        //    }
        //}
        public override bool Equals(object obj)
        {
            if (string.IsNullOrEmpty(Location))
                return false;
            if (obj is IFile)
            {
                IFile other = obj as IFile;
                return Location.Equals(other.Location);
            }
            return false;
        }
        public override int GetHashCode()
        {
            if (Location.isNullorEmpty()) return -1;
            return Location.GetHashCode();
        }
        private static BackGroundTaskMgr bgDelete = BackGroundTaskMgr.getMgr("Delete", 10);
        public void Delete()
        {
            if (tracktrack != null)
            {
                log.log("!delete! {0}", this);
                tracktrack.Delete();
            }
            else
                bgDelete.add(new BgTaskDeleteTrackTrack(this, "delete Track " + this));
        }

        private class Bgtask : pdb.ordo.BgTask
        {
            TrackInfoItunes info;
            public Bgtask(execDel impl, TrackInfoItunes info, string format, params object[] args)
                : base(impl, format, args)
            { this.info = info; }

            public override void exec()
            {
                base.exec();
                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }
            }



        }
        protected class BgTaskDeleteTrackTrack : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            public BgTaskDeleteTrackTrack(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
                //foreach (PlayList pl in info.PLayLists)
                //{
                //    var tInList = pl.getPieceInList(info) as TrackInList;
                //    //loader.removeTrackInList(pl.getPath(), tInList,pl._pl); 
                //}

            }

            public override void exec()
            {
                try
                {
                    var _track = info.TrackTrack;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Delete();
                    loader.removeTrack(info);
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.tracktrack != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComment : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComment(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Comment = value;
                    info.comment = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }


        private class BgTaskName : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskName(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Name = value;
                    info.name = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }

        private class BgTaskComposer : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskComposer(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        // Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Composer = value;
                    info.composer = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //Thread.Sleep(1000 * Try); 
                }

            }
        }



        public void invalidationTrack()
        {

            loader.invalidationTrack(this);
            track = null;
            //  persistentId = null; 
        }


        private class BgTaskGrouping : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;
            string value;
            public BgTaskGrouping(TrackInfoItunes info, string desc, string value)
                : base(desc)
            {
                this.info = info;
                this.value = value;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        //  Thread.Sleep(1000 * Try); 
                        return;
                    }

                    _track.Grouping = value;
                    info.grouping = value;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                    //   Thread.Sleep(1000 * Try); 
                }

            }
        }



        private class BgTaskCheck : pdb.ordo.BgTaskBase
        {
            TrackInfoItunes info;

            public BgTaskCheck(TrackInfoItunes info, string desc)
                : base(desc)
            {
                this.info = info;
            }

            public override void exec()
            {
                try
                {
                    var _track = info.Track;
                    if (_track == null)
                    {
                        success = false;
                        return;
                    }

                    _track.Enabled = false;
                    success = true;
                }
                catch (Exception e)
                { log.log("NIET " + e.Message); }

                if (!success && info.track != null)
                {
                    info.invalidationTrack();
                }

            }
        }




        private TrackInfoItunes parent;

        public virtual ITrackInfoItunes LinkedTo
        {
            get
            {
                return parent;
            }
            set
            {
                parent = value as TrackInfoItunes;
            }
        }


        public int PieceId
        {
            get { return -1; }
        }


        public int PieceParentId
        {
            get { return -1; }
            set { }
        }


        #region key
        private TrackIdentity key;
        public TrackIdentity Key
        {
            get
            {
                if (key == null)
                    keyGener();
                return key;
            }
        }
        private void keyGener()
        {
            key = new TrackIdentity(this);
        }

        #endregion



        public string getPath()
        {
            return file.getPath();
        }

        private DateTime added;
        public virtual DateTime Added
        {
            get { return added; }
            set { added = value; }
        }



        public string strClassement
        {
            get { throw new NotImplementedException(); }
        }

        public Classement DeepClassement
        {
            get { throw new NotImplementedException(); }
        }


        public Classement MaxClassement
        {
            get { throw new NotImplementedException(); }
        }

        public Classement Classement
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        public IMasterPiece MasterPiece
        {
            get
            {
                throw new NotImplementedException();
            }
        }
    }
}



]]></content>
  </file>
</db>
