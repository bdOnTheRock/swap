<db path="C:\bernard\db2\">
  <file path="db4\pdb.player\Vue\ClassementCtl.xaml.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using pdb.player.ViewModel;
using pdb.gen.stat;
using pdb.player.Vue.Adorn;
using System.ComponentModel;
using pdb.gen;
using System.Text.RegularExpressions;
using System.Windows.Threading;
using pdb.player.Vue.Util;
using pdb.player.ViewModel.Colors;
using pdb.util;
using System.Threading;

namespace pdb.player.Vue
{
    public class TB : UIElement
    {
        private Border border;
        private TextBlock tb;
        public TB()
        {
            border = new Border();
            border.BorderThickness = new Thickness(0.3);
            border.BorderBrush = Brushes.Gray;

            tb = new TextBlock();
            tb.TextAlignment = TextAlignment.Center;
            border.Child = tb;
            tb.FontSize = 10;
            tb.HorizontalAlignment = HorizontalAlignment.Stretch;
            tb.Visibility = System.Windows.Visibility.Visible;
        }

        public Brush Background { set { tb.Background = value; } }
        public string Content { set { tb.Text = value; } }

        protected override bool IsEnabledCore
        {
            get
            {
                return true;
            }
        }




    }


    /// <summary>
    /// Interaction logic for ClassementCtl.xaml
    /// </summary>
    public partial class ClassementCtl : UserControl, IGradiant, IClassementObserver
    {



        private DetailClassementViewModel model;
        private StatCtl[,] tbs = new StatCtl[DynamicStat.ROWS + 1, DynamicStatLigne.COLS];
        private Border[,] borders = new Border[DynamicStat.ROWS + 1, DynamicStatLigne.COLS];
        private ILogger log;
        private int loupe = 1;
        private void initBandeau(int row)
        {
            for (int c = 0; c < DynamicStatLigne.COLS; c++)
            {
                var border = new Border();
                border.BorderThickness = new Thickness(0.3);
                border.BorderBrush = Brushes.Gray;
                border.Background = Brushes.LightGray;
                border.VerticalAlignment = System.Windows.VerticalAlignment.Bottom;
                border.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                border.ClipToBounds = true;
                var tb = new TextBlock();
                tb.VerticalAlignment = System.Windows.VerticalAlignment.Stretch;
                tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                tb.Background = Brushes.LightGray;
                int cc = c;
                if (c >= DynamicStatLigne.SEMI_COLS)
                    cc = (c - DynamicStatLigne.SEMI_COLS);
                tb.Text = (cc).ToString();
                tb.TextAlignment = TextAlignment.Center;
                border.Child = tb;
                tab.Children.Add(border);
                Grid.SetRow(border, row);
                Grid.SetColumn(border, c);
            }
        }
        public ClassementCtl()
        {

            InitializeComponent();
            GradiantBuilder.Instance.Add(this);
            TbClass.PreviewTextInput += new TextCompositionEventHandler(TbClass_PreviewTextInput);

            for (int i = -DynamicStatLigne.SEMI_COLS; i <= DynamicStatLigne.SEMI_COLS; i++)
            {
                var col = new ColumnDefinition();
                col.Width = new GridLength(1, GridUnitType.Star);
                tab.ColumnDefinitions.Add(col);
            }

            for (int j = 0; j <= DynamicStat.ROWS + 1; j++)
            {
                var row = new RowDefinition();
                if (j == DynamicStat.ROWS+1 || j == 0)
                    row.Height = new GridLength(1, GridUnitType.Auto);
                else if (j == 1)
                    row.Height = new GridLength(1, GridUnitType.Star);
                else
                    continue;

                tab.RowDefinitions.Add(row);
            }

            initBandeau(0);
            initBandeau(2);

            int rr = 0;
            for (int r = 1; r <= DynamicStat.ROWS; r++)
            {
                if (r < 3)
                    continue;
                if (r > 3)
                    continue;
                rr++;
                for (int c = 0; c < DynamicStatLigne.COLS; c++)
                {

                    var tb = new StatCtl();
                    //var border = new Border();
                    //border.BorderThickness = new Thickness(0.3);
                    //border.BorderBrush = Brushes.Gray;

                    //border.VerticalAlignment = System.Windows.VerticalAlignment.Stretch;
                    ////var tb = new TextBlock();
                    ////tb.TextAlignment = TextAlignment.Center;

                    //////tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                    ////tb.VerticalAlignment = System.Windows.VerticalAlignment.Center;
                    ////tb.FontSize = 10;


                    //border.Child = tb;
                    //    border.ClipToBounds = true;
                    tbs[r, c] = tb;
                    // borders[r, c] = border;


                    // AdornedControl ac = new AdornedControl(); 

                    // tb.BorderThickness = new Thickness(0.2) ;
                    // tb.BorderBrush = Brushes.Gray;
                    // tb.FontSize = 10;


                    tb.HorizontalAlignment = System.Windows.HorizontalAlignment.Stretch;
                    tb.Margin = new Thickness(0);
                    tb.Padding = new Thickness(0);

                    //tab.Children.Add(border);

                    //Grid.SetRow(border, r);
                    //Grid.SetColumn(border, c);



                    tab.Children.Add(tb);
                    Grid.SetRow(tb, rr);

                    Grid.SetColumn(tb, c);

                    //if (r == 0)
                    //{
                    //    tb.Background = Brushes.LightGray;
                    //    tb.Text = (c - DynamicStatLigne.SEMI_COLS).ToString();
                    //}


                    if (c == DynamicStatLigne.SEMI_COLS || r == 3)
                        tb.FontWeight = FontWeights.Bold;
                }


            }




            this.Loaded += new RoutedEventHandler(ClassementCtl_Loaded);
        }
        Regex regex = new Regex(@"[0-5.\ ]+");
        void TbClass_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            var text = e.Text;
            if (!string.IsNullOrEmpty(text))
            {
                //regex that matches disallowed text
                if (!regex.IsMatch(text))
                    e.Handled = true;
            }

        }

        void ClassementCtl_Loaded(object sender, RoutedEventArgs e)
        {
            log = Logger.getLogger("ClassementCtl");
            this.classProvider = new Provider(dg);
            // this.albumProvider = new Provider(dgAlbum); 
            this.model = new DetailClassementViewModel(this);
            App.DetailClassementViewModel = model;
            //  model.PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(model_PropertyChanged);
            // TrackListViewModel.CurrentSelectedChanged += new EventHandler(TrackListViewModel_CurrentSelectedChanged);
            model.setClassment("", null);
            btRecord.IsDefault = true;

            init(null);

        }

        //void TrackListViewModel_CurrentSelectedChanged(object sender, EventArgs e)
        //{
        //    // init(); 
        //}

        //void model_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        //{
        //    init(NUllClient.NULL);
        //}

        private class CPieceComparerByQualityAndLength2 : IComparer<TrackListViewModel>
        {
            private static IComparer<Piece> qual = new CPieceComparerByQualityAndLength();
            int IComparer<TrackListViewModel>.Compare(TrackListViewModel x, TrackListViewModel y)
            {
                return -qual.Compare(x.PieceGen, y.PieceGen);
                // return -x.PieceGen.Rank.Twice.CompareTo(y.PieceGen.Rank.Twice);
            }
        }

        private void init(IClient client)
        {
            if (client == null)
                client = new SimpleClient("ClassementCtl", log);

            if (client.Cancel)
                return;
            App.Dispatch(() =>
                {
                    client.Start();
                    //SortDescriptionCollection sort = null;
                    //ICollectionView view = null;

                    int caretIndex = TbClass.CaretIndex;
                    // TbClass.IsReadOnly = true;

                    //view = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                    //if (view != null)
                    //    sort = view.SortDescriptions;

                    //List<SortDescription> _sort = null;
                    //if (sort != null)
                    //    _sort = new List<SortDescription>(sort);


                    if (client.Cancel)
                        return;
                    base.DataContext = null;
                    try
                    {
                        model.reset();
                        client.log("ClassementCtl::init: model.reset() ");
                        dg.ItemsSource = null;
                        if (client.Cancel)
                            return;
                        var tracks = model.getTracks(client);

                        if (tracks == null)
                            return;
                        if (client.Cancel)
                            return;
                        tracks.Sort(new CPieceComparerByQualityAndLength2());
                        dg.ItemsSource = tracks;
                        client.log("ClassementCtl::init: dg.ItemsSource ");
                        //foreach (TrackListViewModel t in tracks)
                        //    t.refresh(); 

                        //ICollectionView source = CollectionViewSource.GetDefaultView(dg.ItemsSource);
                        //if (source != null)
                        //{
                        //    if (source.SortDescriptions != null)
                        //        source.SortDescriptions.Clear();
                        //    source.SortDescriptions.Add(new SortDescription("Classement", ListSortDirection.Descending));
                        //}
                        //  tracks.init();
                        //dgAlbum.ItemsSource = null;
                        //object sel; 
                        //if (dgAlbum.Items.Count > 0)
                        //{
                        //    sel = dgAlbum.SelectedItem; 
                        //}
                        //dgAlbum.ItemsSource = model.Album;
                        //dgStat.ItemsSource = null;

                        //var stats = model.Stats;
                        //dgStat.DataContext = null; 
                        //dgStat.DataContext = stats.DefaultView;
                        //dgStat.ItemsSource = stats.DefaultView; 
                        if (client.Cancel)
                            return;
                        var stats = model.getStats(client);
                        if (stats == null)
                            return;

                        client.log("ClassementCtl::init: model.getStat ");

                        //for (int c = -DynamicStatLigne.SEMI_COLS; c <= DynamicStatLigne.SEMI_COLS; c++)
                        //{
                        //    var tb = tbs[0, c + DynamicStatLigne.SEMI_COLS];
                        //    tb.Background = Brushes.LightGray;
                        //    tb.Text = (c - DynamicStatLigne.SEMI_COLS).ToString();
                        //    tb.InvalidateVisual();
                        //}
                        if (client.Cancel)
                            return;


                        for (int r = 1; r <= DynamicStat.ROWS; r++)
                        {
                            var stat = stats[r - 1];
                            List<int> list = new List<int>(from c in stat select c);

                            list.Sort();
                            list.Reverse();
                            int count = list.Count;
                            int max0 = list[0];
                            int max=max0;

                            int _loupe = loupe;
                            if (_loupe < 1)
                                _loupe = 1;
                            if (_loupe > count - 2)
                                _loupe = count - 2;

                            int max2 = list[_loupe];
                            
                            double f = (double)max2 * 1.05;
                            f = System.Math.Round(f);
                            if (f > 0 && f < max0)
                                max = (int)f;
                            if (max==max2 && max+1 <=max0)
                                max++; 

                            for (int c = -DynamicStatLigne.SEMI_COLS; c <= DynamicStatLigne.SEMI_COLS; c++)
                            {
                                try
                                {
                                    //  var row = stats.Rows[r-1][c.ToString()]; 
                                    int nb = stats[r - 1][c];
                                    var tb = tbs[r, c + DynamicStatLigne.SEMI_COLS];
                                    if (tb == null)
                                        continue;
                                    if (nb > 0)
                                        tb.Text = nb.ToString();
                                    else
                                        tb.Text = "";
                                    tb.setValue(nb, max);
                                    tb.InvalidateVisual();
                                    //var b = borders[r, c + DynamicStatLigne.SEMI_COLS];
                                    //var layer = AdornerLayer.GetAdornerLayer(b);
                                    //try { layer.Remove((layer.GetAdorners(b))[0]); }
                                    //catch { }
                                    //layer.Add(new BarAdorner(b, nb, max));


                                }
                                catch (Exception ex)
                                {
                                    App.log.log(ex.ToString());
                                }


                                // tbs[r, c + DynamicStatLigne.SEMI_COLS].Text = stats.Rows[r - 1][c.ToString()].ToString(); 
                            }
                        }

                    }
                    catch (Exception ex)
                    {
                        App.log.log(ex.ToString());
                    }
                    finally
                    {
                        if (!client.Cancel)
                        {
                            base.DataContext = model;
                            // view = CollectionViewSource.GetDefaultView(dg.ItemsSource);

                            //   dg.ApplySort(_sort);
                            TbClass.CaretIndex = caretIndex;
                            // TbClass.IsReadOnly = false;

                            client.log("ClassementCtl::init: end ");
                        }
                    }
                }, client);
        }

        private void btRecord_Click(object sender, RoutedEventArgs e)
        {
            model.record();

        }

        private ItrackProvider classProvider;
        private ItrackProvider albumProvider;

        private void dgMouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            var r = sender as DataGridRow;
            var t = r.Item as TrackListViewModel;
            PlayerViewModel.reset(classProvider, t);
        }

        //private void dgAlbum_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        //{
        //    var r = sender as DataGridRow;
        //    var t = r.Item as TrackListViewModel;
        //    PlayerViewModel.reset(albumProvider, t);
        //}

        private class Provider : ItrackProvider
        {
            private DataGrid dt;
            public Provider(DataGrid dt)
            {
                this.dt = dt;
            }

            public System.ComponentModel.ICollectionView PresentationTracks
            {
                get { return CollectionViewSource.GetDefaultView(dt.ItemsSource); }
            }

            public PlayListViewModel PlayList
            {
                get { return null; }
            }

            public void Focus(TrackListViewModel t)
            {

            }


            public void doFilter(string filter)
            {

            }

            public List<TrackListViewModel> SelectedTracks
            {
                get
                {
                    var list = new List<TrackListViewModel>();
                    foreach (TrackListViewModel track in PresentationTracks)
                        list.Add(track);
                    return list;
                }
            }
        }

        //public System.ComponentModel.ICollectionView PresentationTracks
        //{
        //    get { return CollectionViewSource.GetDefaultView(dgAlbum.ItemsSource); }
        //}

        public PlayListViewModel PlayList
        {
            get { return null; }
        }

        public void Focus(int index)
        {

        }

        ViewModel.Colors.Gradient IGradiant.Conf
        {
            get { return Couleurs.Instance.classement.gradient; }
        }

        bool IGradiant.sensGradient
        {
            get { return true; }
        }

        void IBackGround.setBackground(Brush brush)
        {
            dg.Background = brush;
        }

        void IClassementObserver.signalClassementChange(IClient client)
        {
            init(client);
        }

        private void TbClass_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            log.log("TbClass_PreviewKeyDown");
            App.Indispo = true;
        }

        private void TbClass_MouseEnter(object sender, MouseEventArgs e)
        {
            log.log("TbClass_MouseEnter");
            App.Indispo = true;
        }

        private void TbClass_PreviewMouseDown(object sender, MouseButtonEventArgs e)
        {
            log.log("TbClass_PreviewMouseDown");
            App.Indispo = true;
        }

        private void TbClass_MouseLeave(object sender, MouseEventArgs e)
        {
            log.log("TbClass_MouseLeave");
            App.Indispo = false;
        }

        private void tab_MouseDown(object sender, MouseButtonEventArgs e)
        {

        }

        private void tab_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
        {
            loupe = 1;
            log.log("LOUPE " + loupe);
            init(null);
        }

        private void tab_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            loupe++;
            log.log("LOUPE " + loupe);
            init(null);
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Program.cs">
    <content><![CDATA[using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using iTunesLib;
using pdb.iit;
using pdb.it;
using pdb.obj;
using pdb.ordo;
using pdb.podcast.Albums;
using pdb.podcast.Auto;
using pdb.podcast.Delta;
using pdb.podcast.Load;
using pdb.podcast.Report;
using pdb.podcast.Sort;
using pdb.podcast.Tuning;
using pdb.util;
using Conf = pdb.podcast.Tuning.Conf;
using PlayList = pdb.it.PlayList;
using pdb.podcast.Date0;
using pdb.podcast.Notes;
using pdb.podcast.Stat;

namespace pdb.podcast
{
    /// <summary>
    /// crée des listes de lecture pour les Podcasts
    /// </summary>
    class Program : IAbortTask
    {
        //const char DIR_SEP = Path.DirectorySeparatorChar; 
        static ILoader loader;
        //private Feeds feeds;
        public static Logger log;
        public static Logger logAuto;
        static int step = -1;
        static Program _instance = new Program();
        // static bool calculRoots = false;
        static List<HashSet<int>> lists = null;
        static AlbumMgr albumMgr = AlbumMgr.Instance;

        private static AsyncFileWriter asyncFw = AsyncFileWriter.Instance;
        public static Chrono chrono = new Chrono();
        private static Logger logChrono;
        private static DB.Db db;
        static Hibernator hibernator = new Hibernator();

        //public static DB.Db Db { get { return db; } }


        private static XmlWriter writer;
        //DirConf root;
        //DirConf oldRoot;

        private string _empreinte;

        static void Main(string[] args)
        {
            Logger.init(Environment.CurrentDirectory.Replace("\\", "_") + string.Join("_", args));
            log = Logger.getLogger("Program");
            logChrono = Logger.getLogger("Chrono", true);
            logAuto = Logger.getLogger("Auto", true);
            logAuto.NoReset = true;

            FileRegister.init(new Dictionary<string, FileValue>());
            _instance.go(args);
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            Console.WriteLine("\nThe read operation has been interrupted.");
            Console.WriteLine("  Key pressed: {0}", e.SpecialKey);
            Console.WriteLine("  Cancel property: {0}", e.Cancel);
            if (loader == null)
                return;
            e.Cancel = true;


            if (e.SpecialKey == ConsoleSpecialKey.ControlC)
            {
                _end = true;

                loader.saveIds();
                //if (db != null)
                //    db.write();

                if (db != null)
                {
                    while (db.Writing)
                    {
                        misc.log("waiting db writing");
                        Thread.Sleep(1000);
                    }
                }
                Console.WriteLine("\nFin de l'opération d'enregistrement.");

                PlayList.AbortOpe();
                BackGroundTaskMgr.AbortSpecial();
                BackGroundTaskMgr.Reset();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();

                MemUtil.End();
                Logger.End();
                DisposableCounter.DisposeAll();
                Locker.releaseSingleProcess();
                AsyncFileWriter.End();
                Memory.End();
                Exporter.Abort();



                //if (_writeDb != null)
                //{
                //    misc.log("attente writeDb");
                //    _writeDb.Wait();
                //}
                Environment.Exit(0);
            }
            else
            {
                BackGroundTaskMgr.PlayPause();
                BackGroundTaskMgr.recordMsProc();
                loader.saveIds();
                if (db != null)
                    db.write();
                postReport(Conf.DirConf, true);
            }
        }

        //private void scandir(string dir)
        //{
        //    scanFiles(new DirectoryInfo(dir));
        //}

        //private void scanFiles(DirectoryInfo dir)
        //{
        //    log.log("scan " + dir.FullName);
        //    foreach (FileInfo file in dir.GetFiles())
        //    {
        //        //if (dict.ContainsKey(file.FullName))
        //        //    continue;

        //        // log.log("try to build track from " + file.FullName);

        //        try
        //        {
        //            var t = loader.createTrack(-1, file.FullName);
        //            if (t == null)
        //                continue;
        //            TrackInfoItunes track = t as TrackInfoItunes;

        //            if (track == null)
        //                continue;
        //            //if (!track.isPodcast)
        //            //    continue;

        //            log.log("\t==>track créé:" + track);
        //            feeds.checkAll(track);

        //        }
        //        catch (Exception ex)
        //        {
        //            log.log(ex.ToString());
        //        }
        //    }

        //    foreach (DirectoryInfo sub in dir.GetDirectories())
        //        scanFiles(sub);
        //}

        #region Task


        private List<ITrackInfoItunes> loadTracks(bool firstStep, bool forceLoad)
        {
            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();
            loader.loadTracks(firstStep, forceLoad, listTrack);

            return listTrack;

        }
        #endregion


        private static void SyncDb(List<TrackInfoItunes> list, bool checkInOut)
        {
            if (db == null)
                return;
            log.log("SyncDb checkInOut= " + checkInOut);
            foreach (TrackInfoItunes t in list)
            {
                if (checkInOut)
                    t.checkInOut();
                var tdb = db.get(t);
                if (tdb == null)
                {
                    log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                    continue;
                }
                tdb.synch(t);

            }
            log.log("Fin SyncDb checkInOut= " + checkInOut);

        }

        public void go(string[] args)
        {
            //  TrackInfoItunes.AlbumMgr = albumMgr;
            //int countArgs = args.GetLength(0);
            string confFile = "conf.xml";
            //if (countArgs > 0)
            //    confFile = args[0];
            bool _fin = false;

            bool modeDownLoad = false;
            foreach (string v in args)
            {
                if ("-download".Equals(v))
                {
                    modeDownLoad = true;
                    log.log("mode download");
                }
            }

            Album.logDebug = Logger.getLogger("pubDebug", false);
            Album.log = Logger.getLogger("pub2", Album.logDebug, true);
            Album.logDebug.NoReset = true;
            Album.log.NoReset = true;

            DateRefBuilder dateRefBuilder = new DateRefBuilder();
            try
            {

                //BackGroundTaskMgr.Sens = - 1; 
                Thread.CurrentThread.Name = "Main";
                Console.CancelKeyPress += Console_CancelKeyPress;
                ThreadUtil.Log = false;
                misc.init(Logger.getLogger);
                MemUtil.Start(60);

                // bool firstLoad = true;


                Conf.Instance.setConfFile(confFile);
                var xelt = Conf.Instance.load(false);
                // TrackInfoItunes.setDate0(Conf.Date0);
                if (Conf.Menage != menage.none)
                {
                    new Menage().go();
                    return;
                }
                BackGroundTaskMgr.Conf = Conf.Ordo;
                TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                //TrackInfoItunes.MaxPlayed = Conf.PlayedDates;
                TrackInfoItunes.PlayedLevel = Conf.DateLevel;
                var itConf = new pdb.it.Conf(xelt);

                // loader = new Loader(itConf, true);
                bool import = Conf.Import.enabled || Conf.Import.merge;
                db = new DB.Db();


                if (Conf.UseMock)
                    loader = new MockLoader(itConf.DefaultFolder);
                else
                    loader = new Loader(itConf, import, db,
                        () =>
                        {
                            misc.Pre = "[Load " + step + "] ";

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.AbortSpecial();
                            //   Thread.Sleep(1000); 
                            //  BackGroundTaskMgr.Start(); 
                        }, Conf.OnlyEnabled, Conf.OnlyUnRead)

                   ;
                // loader.init();
                TrackInfoItunes.DefaultFolder = loader.DefaultFolder;

                db.load();
                //  db.write(); return; 


                string ziqueOrg = loader.DefaultFolder;
                loader.PlayListFilter = new PlayListFilter(Conf.RootIt);

                BackGroundTaskMgr.Start();

                List<TrackInfoItunes> listIt = new List<TrackInfoItunes>();

                // var bgClass = BackGroundTaskMgr.getMgr("Classement", 0);




                bool firstlaunched = false;
                do
                {
                    try
                    {
                        chrono.end();
                        logChrono.log(chrono.display(3, "{0}:{1:#}"));
                        chrono.reset("Program");

                        step++;
                        Logger.Pre = "[" + step + "] ";
                        Logger.CreateNullLoggers = false;
                        xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                        loader.setConf(xelt);
                        //loader.Conf = new it.Conf(xelt);
                        // AutoBuilder.Log();
                        BackGroundTaskMgr.Conf = Conf.Ordo;
                        TrackInfoItunes.VolumeMin = Conf.VolumeMin;
                        ziqueOrg = loader.DefaultFolder;

#if vendee
                        listTrack = new List<ITrackInfoItunes>();
                        loader.reset(step == 0);

                        loader.ModeXml = false;
                        loader.loadTracks(listTrack);

                        var listV = new ArrayList();
                        loader.getNatives(listV);

                        new Vendee().go(listV);

                        return;

#endif

                        chrono.bip("debut", true);
                        List<TrackInfoItunes> list = null;
                        DirConf root = null;
                        if (step == 0 || !Conf.Simulation)
                        {
                            List<ITrackInfoItunes> listTrack = new List<ITrackInfoItunes>();



                            listTrack = loadTracks(step == 0, AutoBuilder.MustUpdate);


                            BackGroundTaskMgr.recordMsProc();
                            loader.Aborted = true;

                            PlayList.AbortOpe();
                            BackGroundTaskMgr.Reset();

                            BackGroundTaskMgr.recordMsProc();
                            Logger.Reset();
                            BackGroundTaskMgr.Start();


                            misc.Pre = "[" + step + "] ";


                            // listTrack = new List<ITrackInfoItunes>();


                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            //  AutoBuilder.Log();
                            BackGroundTaskMgr.Conf = Conf.Ordo;
                            TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            //xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            //loader.Conf = new it.Conf(xelt);
                            //BackGroundTaskMgr.Conf = Conf.Ordo;
                            //TrackInfoItunes.VolumeMin = Conf.VolumeMin;

                            if (Conf.DeleteDoublon)
                            {

                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            if (Conf.GetDescription)
                            {
                                loader.ModeXml = false;
                                loader.loadTracks(listTrack);
                                return;
                            }

                            string copyAll = Conf.CopyAll;
                            if (!string.IsNullOrEmpty(copyAll))
                            {
                                // loader.loadTracks(listTrack);
                                List<TrackInfoItunes> listToCopy = new List<TrackInfoItunes>();
                                foreach (ITrackInfoItunes _track in listTrack)
                                {

                                    if (_track.isPodcast)
                                    {
                                        var t = _track as TrackInfoItunes;
                                        listToCopy.Add(t);
                                    }


                                }
                                int count = listToCopy.Count;
                                int i = 0;
                                foreach (TrackInfoItunes track in listToCopy)
                                {
                                    i++;
                                    track.copy(copyAll, string.Format("{0}/{1}", i, count));
                                }
                                return;
                            }


                            //    loader.loadTracks(listTrack);

#if menage
                // var listC = new Dict<string, FileInfo>();
                var listD = new Dict<string, FileInfo>();

                Dict<string,ITrackInfoItunes> dict = new Dict<string, ITrackInfoItunes>();
                foreach (var track in listTrack)
                    dict[track.Location] = track;

               
                listFiles(listD, new DirectoryInfo(@"D:\zique\podcasts"));

                foreach (FileInfo file in listD)
                {
                    string location = file.FullName.Replace("D:", "C:");
                    FileInfo C = new FileInfo(location);
                    if (C.Exists)
                    {
                        //TrackInfoItunes track = dict[file.FullName] as TrackInfoItunes;
                        //if (track != null)
                        //{
                        //    log.log("suppression track" + track);
                        //    track.Delete();
                        //}
                        //else
                        //{
                            log.log("suppression simple de " + file.FullName);
                            file.Delete();
                        //}
                    }

                }

                return; 

#elif build

                            list = new List<TrackInfoItunes>();

                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location) || !File.Exists(location))
                                    {
                                        log.log("phase load :: tres bizarre sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }

                                    list.Add(t);
                                }

                            }
                            int nbIntegre = 0;
                            int nbSuppr = 0;
                            scanFiles(list, new DirectoryInfo(@"C:\zique\podcasts"), ref nbIntegre, ref nbSuppr);
                            log.log("fin scan : {0} intégrés, {1} supprimmés", nbIntegre, nbSuppr);
                            BackGroundTaskMgr.End();
                            return;
                        }
                    }


                    catch (Exception ex)
                    {
                        log.log(ex.ToString());
                    }
                }
                while (true);

#else
                            listIt = new List<TrackInfoItunes>();
                            Dict<string, TrackInfoItunes> dictLoc = new Dict<string, TrackInfoItunes>();
                            // GroupStat trackStat = new GroupStat();

                            loader.saveIds();
                            foreach (ITrackInfoItunes _track in listTrack)
                            {
                                if (_track.isPodcast)
                                {
                                    var t = _track as TrackInfoItunes;
                                    string location = t.Location;
                                    if (string.IsNullOrEmpty(location)) // || !FileRegister.Exist(location)) //  File.Exists(location))
                                    {
                                        //log.log("phase load :: suppression du track sans localisation " + t.Album + "/" + t.Name);
                                        //t.Delete();
                                        continue;
                                    }
                                    FileRegister.Push(location);
                                    dictLoc[t.Location] = t;
                                    listIt.Add(t);
                                    // if (!t.Played)
                                    //    trackStat.recordTrack(t, typeState.all);
                                    //trackStat.recordTrack(t, typeState.all);
                                }
                            }



                            db.recordIt(listIt);
                            chrono.bip("loadTracks", true);
                            var dedoubler = new Dedoubler();
                            dedoubler.checkDoublons(db.Tracks);
                            chrono.bip("Dedoubler", true);

                            //if (dedoubler.NbDoublons>0)
                            //{
                            //    db.write(); 
                            //}

                            Download.Downloader downloader = null;
                            if (modeDownLoad)
                            {
                                //new Thread(() => loader.updatePocasts()).Start();
                                downloader = new Download.Downloader(db);
                                downloader.go();

                                loader.loadTrackToDownload(downloader.ToDownload);
                                return;
                            }



                            // ici on peut faire la verification des doublons - track hibernés et re-téléchargés par ce con d'itunes
                            using (var albumConsolid = new AlbumConsolid())
                            {
                                foreach (TrackAlbum album in albumMgr.List)
                                {
                                    albumConsolid.consolid(album);
                                }
                            }

                            log.log("nb123={0} nb12={1} nb13={2} nb23={3} nb1={4} nb2={5} nb3={6} nb0={7}, nb3n={8}",
                                AlbumConsolid.nb123, AlbumConsolid.nb12, AlbumConsolid.nb13, AlbumConsolid.nb23,
                                AlbumConsolid.nb1, AlbumConsolid.nb2, AlbumConsolid.nb3, AlbumConsolid.nb0, AlbumConsolid.nb3n);

                            var scan = Conf.Scan;
                            if (!string.IsNullOrEmpty(scan))
                            {
                                var s = new Scanneur(scan, loader as Loader, db);
                                s.Scan();
                                db.write();
                                return;
                            }
                            root = Conf.DirConf;
                            var feeds = root.Feeds;

                            if (Conf.Freewheel)
                            {
                                PlayList.StartOpe();
                                Freewheel(root);
                                log.log("Freewheel : fin sans enregistrement DB");
                                return;
                            }



                            if (Conf.Import.enabled)
                            {
                                var listImport = new List<TrackInfoItunes>();
                                hibernator.select(Conf.Import, listImport, db.Tracks, true);

                                foreach (TrackInfoItunes tdb in listImport)
                                {
                                    loader.import(tdb);
                                }
                            }
                            else if (Conf.Import.merge)
                            {
                                foreach (TrackInfoItunes t in listIt)
                                    loader.merge(t);
                            }



                            list = db.Tracks;
                            var stat = new ListenerStatBuilder(list);
                            stat.build(DateTime.MinValue);
                            stat.build(DateTime.Now.AddYears(-1));

                            foreach (TrackInfoItunes track in list)
                            {
                                feeds.check(track);
                            }
                            chrono.bip("feeds", true);


                            var loaded = feeds.Loaded;
                            loaded.Sort(new PodCastComparer());

                            bool changeDate = false;
                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            {
                                dateRefBuilder.prepare(loaded);

                            }

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);



                            if (Conf.Sort.selectionBefore)
                            {



                                //***************** Lancement "pour de vrai" ***************************************

                                LimitItemLoader.ModeSelection = true;

                                loadCandidat(root);
                                chrono.bip("loadCandidat(root)");
                                //  AutoBuilder.test(); 
                                // standAlone(root); 
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root)");
                                //**********************************************************************************


                                ////****************************************
                                //// lancement des sorties xml et html en asynchrone
                                //postReport(root, true);
                                ////****************************************


                            }



                            if (Conf.Sort.checkBefore)
                            {
                                Album.Init();
                                var sorter = new Sorter(Conf.Sort, list);
                                sorter.build();
                                chrono.bip("sorter.build();", true);


                                changeDate = dateRefBuilder.autoSafe(loaded);
                                //TrackInfoItunes.setDate0(Conf.Date0);
                                double offsetIni = dateRefBuilder.getOffset();
                                AutoBuilder.Offset = offsetIni;

                                if (Album.NbRepeches > 0 && !Conf.DateRef.auto)
                                {
                                    log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                    _fin = true;
                                }
                            }


                            ContexteBuilder.Instance.init(loaded);
                            Conf.DateRef.contexte = ContexteBuilder.Instance.Debut;
                            dateRefBuilder.saveCurrent();

                            if (Conf.Import.enabled || Conf.Import.merge)
                            {
                                _fin = true;

                            }



                            if (_fin)
                            {
                                log.log("fin sans enregistrement DB");
                                //  db.write();


                                //****************************************
                                // lancement des sorties xml et html en asynchrone
                                postReport(root, true);
                                //****************************************
                                return;
                            }


                            if (Album.NbModif > 0)
                            {
                                resetLoad(root);

                            }
                            //bool changeDate = false;
                            //if (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all || !Conf.DateRef.offset)
                            //{
                            //    changeDate = dateRefBuilder.auto(loaded);
                            //    TrackInfoItunes.setDate0(Conf.Date0);
                            //    double offsetIni = dateRefBuilder.getOffset();
                            //    AutoBuilder.Offset = offsetIni;
                            //}
                            AutoBuilder.init(true);
                            if (Conf.Sort.stopOnOffset && changeDate)
                            {
                                log.log("fin cause stopOnOffset");
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                                return;
                            }

                            if (Conf.Sort.stopOnPub2 && Album.NbModifPertinent > 0)
                            {
                                log.log("fin cause stopOnPub2");
                                chrono.bip("SyncDb", true);
                                SyncDb(list, false);
                                chrono.bip("db.write()", true);
                                db.writeAsync();
                                return;
                            }

                            AutoBuilder.Offset = 0;
                            chrono.bip("AutoBuilder.init(true)");
                            xelt = Conf.Instance.load(step > 0 && Conf.Simulation);
                            loader.setConf(xelt);

                            //ContexteBuilder.Instance.init(loaded);

                            //Conf.DateRef.contexte = ContexteBuilder.Instance.Debut;
                            //   dateRefBuilder.saveCurrent();



                            var descTrack = DescBuilder.create("Tracks");

                            LimitItem.includeDetail = true;
                            //trackStat.report(descTrack);
                            //log.log(descTrack.ToString());

                            //var sbT = new StringBuilder();

                            //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\tracks.txt")))
                            //{
                            //var trackFile = DescBuilder.create("Tracks", sbT);
                            //trackStat.report(trackFile);
                            //sbT.Flush();

                            //asyncFw.post(@"..\Logs\tracks.txt", sbT.ToString());
                            //}
                            //chrono.bip("desc tracks", true);
                            //Logger.LogConsole = false;
                            //        loader.loadLists();
                            Logger.LogConsole = true;
                            chrono.bip("load list", true);

                        }
                        list = db.Tracks;


                        while (true)
                        {

                            chrono.end();
                            logChrono.log(chrono.display(3, "{0}:{1:#}"));
                            chrono.reset("Program");
                            root = Conf.DirConf;
                            var feeds = root.Feeds;
                            foreach (TrackInfoItunes track in feeds.getSelectedTracks())
                            {
                                track.clearLists();
                            }

                            feeds.clearSelectedTracks();

                            chrono.bip("track.clearLists", true);

                            xelt = Conf.Instance.load(false);
                            loader.setConf(xelt);
                            PlayList.StartOpe();
                            loader.Aborted = false;

                            Logger.CreateNullLoggers = !Conf.LogGen;


                            BackGroundTaskMgr.Conf = Conf.Ordo;




                            Exporter.TopRecord();
                            //***************** Lancement "pour de vrai" ***************************************
                            LimitItemLoader.ModeSelection = true;
                            AutoBuilder.init(true);
                            chrono.bip("AutoBuilder.init(true)");
                            loadCandidat(root);
                            chrono.bip("loadCandidat(root)");
                            //  AutoBuilder.test(); 
                            // standAlone(root); 
                            phase2(root);
                            Selection(root);
                            chrono.bip("Selection(root)");
                            //**********************************************************************************

                            Album.Init();

                            if (Conf.Sort.enabled == Tuning.Sort.sortMode.reset ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.once ||
                                Conf.Sort.enabled == Tuning.Sort.sortMode.white ||
                                (Conf.Sort.enabled == Tuning.Sort.sortMode.once_all && !firstlaunched))
                            {
                                if (Sorter.NbLaunch == 0 || (Conf.Sort.enabled != Tuning.Sort.sortMode.white && Conf.Sort.enabled != Tuning.Sort.sortMode.once))
                                {
                                    var sorter = new Sorter(Conf.Sort, list);
                                    sorter.build();
                                }
                                _fin = Conf.Sort.enabled == Tuning.Sort.sortMode.white || Conf.Sort.enabled == Tuning.Sort.sortMode.reset;
                                if (!_fin && Album.NbModif > 0)
                                    resetLoad(root);
                            }

                            firstlaunched = true;

                            if (Album.NbRepeches > 0)
                            {
                                log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                                _fin = true;
                            }



                            if (!_fin) // && Album.NbModif == 0)
                            {

                                //***************** Lancement "pour de faux" ***************************************
                                AutoBuilder.Init3();
                                chrono.bip("AutoBuilder.Init3()");
                                LimitItemLoader.ModeSelection = false;
                                phase2(root);
                                Selection(root);
                                chrono.bip("Selection(root) 2");
                                LimitItemLoader.ModeSelection = true;
                                //**********************************************************************************
                            }
                            Exporter.TopCopy();
                            chrono.bip("selection");




                            // Conf.date00Consume();
                            // TrackInfoItunes.setDate0(Conf.Date0);

                            int iii = 0;
                            while (!BackGroundTaskMgr.ConfirmEnd(10))
                            {
                                iii++;
                                if (iii == 60)
                                    iii = 0;
                                if (iii == 0)
                                {
                                    log.log("Attente Classement");
                                }
                                Thread.Sleep(100);
                            }






                            if (_fin || Album.NbModif > 0)
                            {
                                log.log("{0} éléments ont la Pub2 modifiée", Album.NbModif);

                                //foreach (TrackInfoItunes t in list)
                                //{
                                //    var tdb = db.get(t);
                                //    if (tdb == null)
                                //    {
                                //        log.log("impossible de trouver le track db correspondant à {0} {1} {2}", t.DbId, t.Location, t);
                                //        continue;
                                //    }
                                //    tdb.synch(t);

                                //}



                                if (_fin)
                                {
                                    SyncDb(list, true);
                                    db.writeAsync();
                                    log.log("fin");
                                    return;
                                }
                                // continue;
                            }




                            foreach (TrackInfoItunes s in feeds.getSelectedTracks())
                            {
                                var items = s.Providers;
                                int count = items.Count;
                                foreach (LimitItem item in items)
                                {
                                    item.recordTrackMoy(s, count);
                                    //if (count == 1)
                                    //    s.Exclu = item;
                                }
                            }
                            chrono.bip("selection exclu");

                            if (Conf.GenFeed)
                            {
                                foreach (RootItItem rootItem in Conf.RootIt)
                                {
                                    var fAuto = loader.TreePlayList.getComposite(rootItem.name);
                                    var fFeeds = fAuto.getComposite("Feed");

                                    if (fFeeds != null)
                                    {
                                        scanFeedsForRecordEmptyLists(feeds, fFeeds);
                                    }

                                }
                            }


                            //****************************************
                            // lancement des sorties xml et html en asynchrone
                            postReport(root, false);
                            //****************************************



                            //mem0.load();
                            //var listSe = feeds.getSelectedTracks(); 
                            //if (mem0.FileExists)
                            //{
                            //    foreach (TrackInfoItunes s in listSe)
                            //    {
                            //        var key = s.Location;
                            //        if (!mem0.dict.ContainsKey(key))
                            //            log.log("delta virtuel ajouté {0} ==> {1}", s, s.GetProvider());
                            //    }

                            //    foreach (string key in mem0.dict.Keys)
                            //    {
                            //        if (!feeds.existSelected(key))
                            //            log.log("delta virtuel supprimé {0}",mem0.dict[key]);
                            //    }
                            //}
                            //mem0.save(listSe); 

                            //  AutoBuilder.Log();
                            AutoBuilder.init(false);
                            chrono.bip("AutoBuilder.init(false)");
                            bool cangoAuto = AutoBuilder.Check(feeds);

                            chrono.bip("AutoBuilder");
                            AutoBuilder.Log();
                            if (!cangoAuto && Conf.AutoBlock)
                            {
                                logAuto.log("arret par auto");
                                //Thread.Sleep(1000);
                                continue;
                            }
                            else
                            {
                                string newEmpreinte = Conf.DirConf.getEmpreinte();
                                if (newEmpreinte == _empreinte && !AutoBuilder.Stable)
                                {
                                    logAuto.log("arret par empreinte");
                                    continue;
                                }

                                _empreinte = newEmpreinte;

                                Logger.LogAll("****************************************************************************************");
                                Logger.LogAll("arret");
                                Logger.LogAll("****************************************************************************************");

                                // postReport(root, true);

                                // BackGroundTaskMgr.End();

                                Logger.Pre = "";

                                //   log.log(sb.ToString());
                                var sb2 = DescBuilder.create();

                                if (Conf.Simulation)
                                {
                                    Logger.LogAll("****************************************************************************************");
                                    Logger.LogAll("TEST");
                                    Logger.LogAll("****************************************************************************************");
                                }

                                var feedsRapport = new StringBuilder();
                                feeds.rapport(feedsRapport);
                                Logger.LogConsole = false;
                                log.log(feedsRapport.ToString());
                                Logger.LogConsole = true;
                                var tw = new StringBuilder();
                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\history.txt")))
                                //{
                                feeds.rapportSelected(tw);
                                asyncFw.post(@"..\Logs\history.txt", tw.ToString());
                                // }

                                //using (pdb.util.TextWriter tw = new util.TextWriter(File.OpenWrite(@"..\Logs\historyPre.txt")))
                                //{
                                //  tw = new StringBuilder();
                                //feeds.rapportPreSelected(tw);
                                //asyncFw.post(@"..\Logs\historyPre.txt", tw.ToString());
                                //}

                                // rapport détaillé
                                LimitItem.includeDetail = true;
                                Conf.DirConf.rapport(sb2);
                                Logger.LogConsole = false;
                                log.log(sb2.ToString());
                                Logger.LogConsole = true;


                                // rapport plus concis
                                var sb3 = DescBuilder.create();
                                LimitItem.includeDetail = false;
                                Conf.DirConf.rapport(sb3);
                                Logger.LogConsole = false;
                                log.log(sb3.ToString());
                                Logger.LogConsole = true;
                                chrono.bip("rapport", true);
                                break;
                            }
                        }

                        //mem1.load();

                        //if (mem1.FileExists)
                        //{
                        //    foreach (TrackInfoItunes s in listSe)
                        //    {
                        //        var key = s.Location;
                        //        if (!mem1.dict.ContainsKey(key))
                        //            log.log("delta reel ajouté {0} ==> {1}", s, s.GetProvider());
                        //    }

                        //    foreach (string key in mem1.dict.Keys)
                        //    {
                        //        if (!feeds.existSelected(key))
                        //            log.log("delta reel supprimé {0}", mem1.dict[key]);
                        //    }
                        //}
                        //mem1.save(listSe); 



                        SyncDb(list, true);
                        db.writeAsync();


                        Logger.CreateNullLoggers = false;

                        int nbH = 0;
                        _fin = false;
                        if (Conf.Hibernate.enabled)
                        {
                            nbH = hibernator.go(loader, list);
                            if (nbH > 0)
                            {
                                log.log("{0} elements hibernés", nbH);
                                _fin = true;
                            }
                        }

                        lists = null;
                        WritePlayList(root);
                        postReport(root, true);




                        // Sélection du dernier podcast de chaque album
                        if (!Conf.Single)
                        {
                            var feeds = root.Feeds;
                            int prior = 2;
                            var listP = Conf.SelectParams;

                            var listS = new List<TrackInfoItunes>();
                            string[] folder = null;

                            Dictionary<string, Dictionary<int, TrackInfoItunes>> depots = new Dictionary<string, Dictionary<int, TrackInfoItunes>>();
                            foreach (SelectParam p in listP)
                            {

                                listS = new List<TrackInfoItunes>();
                                if (!string.IsNullOrEmpty(p.name))
                                {
                                    // Compatibilité anciennes listes
                                    folder = new string[] { "select", "tmp", p.name };
                                    feeds.buildFirstSelectedTrackLevel(listS, p);  //true, true, false, false);
                                    buildList("_" + p.level, listS, prior, folder);
                                }
                                else
                                {

                                    var pp = p.Clone() as SelectParam;
                                    feeds.buildFirstSelectedTrackLevel(listS, p);

                                    var l = new List<TrackInfoItunes>();

                                    pp.nb = int.MaxValue;
                                    var selector = new TrackSelector(pp);
                                    foreach (TrackInfoItunes t in listS)
                                    {
                                        if (selector.select(t))
                                            l.Add(t);
                                    }

                                    string path = p.path;
                                    if (!string.IsNullOrWhiteSpace(path))
                                        buildList(path, l, prior);

                                    string[] _depots = p.depot;
                                    if (_depots != null)
                                    {
                                        foreach (string depot in _depots)
                                        {
                                            if (!depots.ContainsKey(depot))
                                                depots.Add(depot, new Dictionary<int, TrackInfoItunes>());

                                            var dep = depots[depot];
                                            foreach (TrackInfoItunes t in l)
                                            {
                                                if (!dep.ContainsKey(t.DbId))
                                                    dep.Add(t.DbId, t);
                                            }
                                        }
                                    }
                                }
                            }

                            foreach (KeyValuePair<string, Dictionary<int, TrackInfoItunes>> kvp in depots)
                            {
                                string path = kvp.Key;

                                var l = new List<TrackInfoItunes>(kvp.Value.Values);
                                l.Sort(new PodcastComparerPubPub2());
                                buildList(path, l, prior);
                            }

                        }

                        var journal = Conf.Journal;
                        if (journal != null)
                        {
                            var feeds = root.Feeds;
                            for (int j = 1; j <= Journal.NB_JOUR_MAX; j++)
                            {
                                List<TrackInfoItunes> listJ = null;
                                if (journal.NbJour >= j)
                                {
                                    listJ = feeds.buildJournal(journal);
                                }
                                else
                                    listJ = new List<TrackInfoItunes>();

                                var name = j.ToString();
                                if (j < 10)
                                    name = "0" + name;
                                buildList(name, listJ, 3, "journal");

                            }
                        }

                        if (Conf.GenFeed)
                        {
                            var feeds = root.Feeds;
                            var prior = Conf.GenFeedPrior;
                            foreach (Feed feed in feeds.List)
                            {
                                var list0 = feed.getSelectedTracks;
                                buildList(feed.Name, list0, prior, "Feed");
                            }
                        }

                        string zique = Conf.Move.Zique;



                        BackGroundTaskMgr trackMgr = BackGroundTaskMgr.getMgr("Track", 12);
                        var trackList = BackGroundTaskMgr.getMgr("TrackList", 0);

                        var listSelected = root.Feeds.getSelectedTracks();

                        var sorterafter = new Sorter(Conf.Sort, list);
                        //    sorter.build();

                        foreach (TrackInfoItunes s in listSelected)
                        {
                            s.updateNative();
                        }






                        //if (Conf.Hibernate.enabled)
                        //{
                        //    Hibernator hibernator = new Hibernator();
                        //    var nb = hibernator.go(loader); 
                        //    if (nb >0)
                        //    {
                        //        misc.log("{0} elements hibernés", nb);
                        //        misc.log("fin ");
                        //        return; 
                        //    }

                        //}


                        int ii = 0;
                        while (!BackGroundTaskMgr.ConfirmEnd(10))
                        {
                            ii++;
                            if (ii == 60)
                                ii = 0;
                            if (ii == 0)
                            {
                                log.log("Attente Classement");
                            }
                            Thread.Sleep(100);
                        }



                        //if (Conf.Sort.enabled >= Tuning.Sort.sortMode.once_all)
                        //{
                        //    var sorter = new Sorter(Conf.Sort, list);
                        //    sorter.build();
                        //}

                        if (Conf.Hibernate.enabled)
                        {
                            hibernator.doH();
                        }

                        if (loader.NbTrackCreated > 0)
                        {
                            log.log("{0} éléments ont été recréés", loader.NbTrackCreated);
                            _fin = true;
                        }

                        if (Album.NbRepeches > 0)
                        {
                            log.log("{0} éléments ne sont plus protégés par Pub2", Album.NbRepeches);
                            _fin = true;
                        }

                        if (!Conf.Continue)
                        {
                            log.log("on s'arrete là");
                            _fin = true;
                        }



                        if (Conf.UseMock)
                            _fin = true;



                        if (_fin)
                        {


                            log.log("fin");

                            return;
                        }





                        // BackGroundTaskMgr.End();


                        misc.Pre = "[ OK " + step + "] ";
                        Logger.LogAll("*****************************************************************************************************");
                        Logger.LogAll("Pile Classement finie, attente nouvelle version");
                        Logger.LogAll("*****************************************************************************************************");
                        postReport(root, true);


                        Logger.LogAll("****************************************************************************************");
                        Logger.LogAll("arret 2");
                        Logger.LogAll("****************************************************************************************");

                        DateTime limit = DateTime.Now.AddDays(-Conf.Move.Delta);

                        if (!string.IsNullOrEmpty(zique))
                        {
                            foreach (TrackInfoItunes track in db.Tracks)
                            {
                                track.move(ziqueOrg, zique, limit);
                            }
                            return;
                        }
                        if (!Conf.Simulation)
                        {

                            Logger.Pre = "[ OK " + step + "] ";
                            Logger.LogAll("*****************************************************************************************************");
                            Logger.LogAll("attente nouvelle version");
                            Logger.LogAll("*****************************************************************************************************");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogAll(ex.ToString());
                        misc.log(ex.ToString());
                        log.log(ex.ToString());
                        Thread.Sleep(1000);
                    }


                }
                while (true);




#endif

                //while (!BackGroundTaskMgr.Finished)
                //    Thread.Sleep(30);
                //log.log("****************************************************************************************");
                //loader.SynchronizePodcast(); 
                //log.log("fin");
                //log.log("****************************************************************************************");
            }

            catch (Exception ex)
            {
                log.log(ex.ToString());
            }


        }

        #region report asynchrone

        //private DirConf _attenteWriteHtml;
        // private volatile object _lockReportHtml = new object();
        private bool _end;
        // ThreadUtil thReport;
        DateTime lastReport;

        private void postReport(DirConf dir, bool force)
        {
            if (force || (lastReport.AddSeconds(10) < DateTime.Now && Conf.PostReport))
            {
                try
                {
                    reportHtml(dir);
                }
                catch (Exception ex)
                {
                    misc.log(ex);
                }
                lastReport = DateTime.Now;
            }
            //if (thReport == null)
            //{
            //    lock (_lockReportHtml)
            //    {
            //        if (thReport == null)
            //        {
            //            thReport = new ThreadUtil(loopReportHtml, "ReportHtml");
            //            thReport.Start();
            //        }
            //    }
            //}

            //lock (_lockReportHtml)
            //    _attenteWriteHtml = dir;
        }

        //private void loopReportHtml()
        //{
        //    DirConf traite = null;
        //    while (!_end)
        //    {
        //        Thread.Sleep(1000);
        //        if (_attenteWriteHtml == null)
        //            continue;
        //        lock (_lockReportHtml)
        //        {
        //            if (_attenteWriteHtml == null)
        //                continue;
        //            traite = _attenteWriteHtml;
        //            _attenteWriteHtml = null;
        //        }
        //        reportHtml(traite);
        //    }
        //}


        private void reportHtml(DirConf root)
        {
            try
            {

                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = System.Text.Encoding.UTF8;
                var _sb = new System.Text.StringBuilder();
                using (writer = XmlWriter.Create(_sb, settings))
                {
                    LimitsLoader.Writer = new WriterXml(writer);
                    DoubleStat.ModeHtml = false;
                    writer.WriteStartElement("tracks");
                    WriteTracks(root);
                    writer.WriteEndDocument();
                    writer.Flush();
                }

                asyncFw.post(@"..\tracks.xml", _sb.ToString());
                //   chrono.bip("xml");

                string html = @"..\tracks.html";
                //if (File.Exists(html))
                //    File.Delete(html);
                var sbHtml = new StringBuilder();
                //using (pdb.util.TextWriter sbHtml = new pdb.util.TextWriter(new StreamWriter(File.OpenWrite(html), System.Text.Encoding.UTF8)))
                //{
                LimitsLoader.Writer = new WriterHtml(sbHtml);
                DoubleStat.ModeHtml = true;
                sbHtml.Append(@"<!DOCTYPE html>
<html>
<head>
	<title>"
+ Environment.CurrentDirectory + @"</title>
	
	<style type='text/css'>
		body{
			margin:10px 30px;
			font-family:verdana;
			font-size:12px;
		}
		h1{
			font-family:verdana;
			font-size:14px;
			font-weight:bold;
			text-decoration:underline;
		}
        .low {
			color: rgb(0,125,255);
		}

        .med {
			font-weight:bold;
			color: rgb(0,140,0);
		}

        .high {
			font-weight:bold;
			font-size:14px;
			color: rgb(240,155,0);
		}
        
		.big {
			font-weight:bold;
			font-size:14px;
			text-decoration:underline;
			color: rgb(255,32,0);
		}

        .album {
			color: rgb(0,125,255);
		}
        .track {
            font-weight:bold;
			color: rgb(0,40,80);
		}
		div.tree div {
			padding-left:16px;
		}
		div.tree div.parent div {
			 display:none;
			 cursor:default;
		}
		div.tree div.parent {
			 cursor:pointer !important;
			 background:transparent url(plus.gif) no-repeat top left;
		}
		div.tree div.expanded {
			background:transparent url(moins.gif) no-repeat top left;
		}
	</style>
	<link rel='stylesheet' type='text/css' href='treeview.css' media='screen' /> 
	<script type='text/javascript' src='jquery.js'></script>
	<script type='text/javascript'>
	$(function() {
		$('div.tree div:has(div)').addClass('parent');
		$('div.tree div').click(function() {
			var o = $(this);
			o.children('div').toggle();
			o.filter('.parent').toggleClass('expanded');
			return false;
		});
	});
	</script>
</head>
<body>");
                WriteTracks(root);
                sbHtml.Append(@"</body>
</html>");

                sbHtml.Flush();

                //}
                asyncFw.post(html, sbHtml.ToString());
                //  chrono.bip("html");
            }
            catch (Exception ex)
            {
                log.log(ex.ToString());
            }
        }

        #endregion


        public static void buildList(string name, List<TrackInfoItunes> list_, List<string> folders)
        {
            buildList(name, list_, int.MaxValue, folders, false);
        }

        public static void buildListPrior(string name, List<TrackInfoItunes> list_, List<string> folders, int prior)
        {
            buildList(name, list_, prior, folders, false);
        }


        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, params string[] folders)
        {
            var lfolders = new List<string>(folders);
            buildList(name, list_, prior, lfolders, false);
        }

        public static void buildList(string path, List<TrackInfoItunes> list_, int prior)
        {
            bool absolutePath = path.StartsWith(@"\");
            var tab = path.Split('\\');
            int count = tab.GetLength(0);
            var folder = new List<string>();

            foreach (string s in tab)
            {
                if (!string.IsNullOrWhiteSpace(s))
                    folder.Add(s);
            }

            buildList(list_, prior, folder, absolutePath);
        }



        public static void buildList(List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            var newf = new List<string>(folders);
            int count = newf.Count;

            string name = newf[count - 1];
            newf.RemoveAt(count - 1);
            buildList(name, list_, prior, newf, absolutePath);
        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildList(string name, List<TrackInfoItunes> list_, int prior, List<string> folders, bool absolutePath)
        {
            try
            {
                if (Conf.Simulation)
                    return;
                //if (Conf.UseMock)
                //{
                //    var sb = new StringBuilder();
                //    foreach (string f in folders)
                //    {
                //        sb.Append(f); sb.Append(@"\");
                //    }
                //    sb.Append(name);
                //    log.logNoDate("---------------------------");
                //    log.log("liste {0}", sb.ToString());
                //    if (list_ != null)
                //    {
                //        foreach (TrackInfoItunes t in list_)
                //        {
                //            log.logNoDate(t.ToString());
                //        }
                //    }
                //    return;
                //}

                if (list_ != null && !Conf.NoRevival)
                {
                    foreach (TrackInfoItunes track in list_)
                    {
                        loader.reviveIfNecessary(track);
                    }
                }



                var rootIt = Conf.RootIt;
                RootItItem currentRoot = rootIt.roots[0];
                int count = rootIt.roots.Count;

                if (list_ != null)
                {
                    //   log.log("build list {0}",name);
                    //  var list = new List<IFile>(list_);
                    if (lists == null)
                    {
                        lists = new List<HashSet<int>>();
                        foreach (var item in rootIt.roots)
                        {
                            lists.Add(new HashSet<int>());
                        }
                        var list__ = new List<TrackInfoItunes>(list_);
                        list__.Sort(new PodcastComparerPubPub2());



                        int countTrack = list_.Count;

                        long size = 0;
                        int j = 0;
                        int indexRoot = 0;

                        //    HashSet<int> current = lists[0]; 

                        while (true)
                        {
                            if (j >= countTrack)
                                break;
                            TrackInfoItunes track = list__[j];
                            size += track.Size;
                            if (size <= currentRoot.size)
                            {
                                lists[indexRoot].Add(track.DbId);
                                // track.IndexRoot = indexRoot;
                            }
                            else
                            {

                                size = 0;
                                //  size += track.Size;
                                indexRoot++;
                                if (indexRoot >= count)
                                    break;
                                currentRoot = rootIt.roots[indexRoot];
                                continue;
                            }
                            j++;
                        }

                    }
                }


                for (int r = 0; r < count; r++)
                {
                    currentRoot = rootIt.roots[r];
                    folders = new List<string>(folders);
                    PlayListComposite folder = null;

                    if (absolutePath)
                    {
                        if (r > 0)
                            throw new Exception("un chemin absolu ne peut pas être géré dans une partition");
                        // folders[0] = folders[0].Substring(1);
                        folder = loader.TreePlayList;

                    }
                    else
                        folder = loader.TreePlayList.getComposite(currentRoot.name);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(currentRoot.name);


                    var nname = name;
                    if (name.Contains(Path.DirectorySeparatorChar.ToString()))
                    {
                        var tab = name.Split(Path.DirectorySeparatorChar);
                        string str = null;
                        for (int i = 0; i < tab.GetLength(0); i++)
                        {
                            if (str != null)
                                folders.Add(str);
                            if (!string.IsNullOrEmpty(tab[i]))
                                str = tab[i];
                        }
                        if (!string.IsNullOrEmpty(str))
                            nname = str;
                    }
                    List<IFile> l = null;

                    if (list_ != null)
                    {
                        l = new List<IFile>();
                        foreach (TrackInfoItunes t in list_)
                        {
                            if (lists[r].Contains(t.DbId))
                            {
                                if (Conf.NoRevival)
                                {
                                    if (!t.Present)
                                        continue;
                                }

                                l.Add(t);
                            }
                        }
                    }


                    for (int i = 0; i < folders.Count; i++)
                    {
                        var aux = folder;
                        folder = folder.getComposite(folders[i]);
                        if (folder == null)
                            folder = loader.getOrCreateFolder(aux, folders[i], l == null ? true : l.Count > 0);
                        if (folder == null)
                            return;
                    }

                    //  var folder = loader.root.getComposite("auto").getComposite("PODUtil"); 
                    var playlist = loader.getPlayList(folder, nname, l == null ? true : l.Count > 0);
                    if (playlist != null)
                    {
                        if (prior < int.MaxValue && prior >= 0)
                            playlist.setPrior(prior);
                        //if (list.Count > 0)


                        playlist.mergeList(l, hibernator.Ignore, _instance, Conf.OnlyEnabled, Conf.OnlyUnRead);
                        //  loader.mergeList(playlist, l, false, _instance, null);
                        //else
                        //    loader.removeList(folder, name);
                    }



                    //log.log("clear list {0}", name); 
                    //loader.ClearList(playlist);
                    //log.log("add items {0}", name); 
                    //foreach (TrackInfoItunes track in list)
                    //    loader.addItemToList(playlist, track); 

                }
            }
            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }


        }

        /// <summary>
        /// création ou mise à jour d'une liste
        /// </summary>
        /// <param name="name"></param>
        /// <param name="list_"></param>
        /// <param name="folders"></param>
        public static void buildGlobalList(string path, List<TrackInfoItunes> list_, int prior)
        {
            PlayListComposite folder = null;
            List<string> folders = new List<string>();
            string nname = "";
            //if (Conf.UseMock)
            //    return;
            try
            {

                var tab = path.Split(Path.DirectorySeparatorChar);
                string str = null;
                for (int i = 0; i < tab.GetLength(0); i++)
                {
                    if (str != null)
                        folders.Add(str);
                    if (!string.IsNullOrEmpty(tab[i]))
                        str = tab[i];
                }
                if (!string.IsNullOrEmpty(str))
                    nname = str;

                folder = loader.TreePlayList;





                var l = new List<IFile>();
                foreach (TrackInfoItunes t in list_)
                {
                    if (t.Present || Conf.UseMock)
                        l.Add(t);
                }

                for (int i = 0; i < folders.Count; i++)
                {
                    var aux = folder;
                    folder = folder.getComposite(folders[i]);
                    if (folder == null)
                        folder = loader.getOrCreateFolder(aux, folders[i], l.Count > 0);
                    if (folder == null)
                        return;
                }


                var playlist = loader.getPlayList(folder, nname, l.Count > 0);
                if (playlist != null)
                {
                    if (prior < int.MaxValue && prior >= 0)
                        playlist.setPrior(prior);


                    playlist.mergeList(l, hibernator.Ignore, _instance, false, false);

                }



            }

            catch (Exception ex)
            {
                misc.log(ex.ToString());
            }




        }

        delegate void actionList(DirConf dir);
        private void recursif(DirConf dir, action pre, action post)
        {
            var fLoader = dir.Loader;
            DateTime now = DateTime.Now;

            fLoader.Action(pre);
            var ts = (DateTime.Now - now).TotalMilliseconds;
            if (ts > 1 && Conf.LogDir && pre > action.none && pre < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", pre, dir.getPath(), ts.ToString("0"));
            }

            //Construction récursive sur l'arbre
            foreach (DirConf child in dir)
            {
                // DescBuilder sub = sb.createChild(child.getPath());
                recursif(child, pre, post);
            }
            //if (post > action.none && post < action.writeTracksPre)
            //    log.log("{0} {1}", post, dir.getPath());

            now = DateTime.Now; ts = (DateTime.Now - now).TotalMilliseconds;
            fLoader.Action(post);

            if (ts > 1 && Conf.LogDir && post > action.none && post < action.writeTracksPre)
            {
                log.log("{0} {1} {2} ms", post, dir.getPath(), (DateTime.Now - now).TotalMilliseconds.ToString("0"));
            }


        }

        private void loadCandidat(DirConf dir)
        {
            recursif(dir, action.loadCandidat, action.none);
        }

        private void resetLoad(DirConf dir)
        {
            recursif(dir, action.resort, action.none);
        }


        //private void standAlone(DirConf dir)
        //{
        //    recursif(dir, action.standAlone, action.none); 
        //}

        private void phase2(DirConf dir)
        {
            recursif(dir, action.none, action.phase2);
        }



        /// <summary>
        /// Constitution d'un répertoire
        /// </summary>
        /// <param name="dir"></param>
        /// <param name="sb"></param>
        private void Selection(DirConf dir)
        {
            recursif(dir, action.selectionPre, action.selectionPost);

            // ne sert pas
            //dir.TransmissionListToParent();

        }

        private void Freewheel(DirConf dir)
        {
            dir.Loader.LimitsLoader.Freewheel();
        }

        private void WritePlayList(DirConf dir)
        {
            recursif(dir, action.writeLists, action.none);
            List<TrackInfoItunes> list = null;
            //  var list = db.Tracks.FindAll(t => t.Present);
            //var list = db.Tracks.FindAll(t => t.isConcernedBySelection); 
            var Fin1ereJournee = ContexteBuilder.Instance.Fin1ereJournee;
            var limitContexte = ContexteBuilder.Instance.LimitWriteList;
            if (Conf.UseMock)
                list = db.Tracks.FindAll(t => t.isConcernedBySelection && t.isPodcast);
            else
                list = db.Tracks.FindAll(t => t.Present && t.isConcernedBySelection && t.isPodcast && t.Pub2 <= limitContexte);
            foreach (SelectParamBase listeGlobal in Conf.GlobalListes)
            {
                var selector = new TrackSelector(listeGlobal);
                var l = new List<TrackInfoItunes>();
                foreach (TrackInfoItunes t in list)
                {
                    if (selector.select(t))
                        l.Add(t);
                }

                buildGlobalList(listeGlobal.path, l, 2);

            }

            //foreach (Note note in Conf.Notes)
            //{
            var builder = dir.NoteBuilder;
            if (builder == null)
                return;
            var note = builder.Note; // note.NoteBuilder; // new NoteBuilder(note);
            builder.build(list);
            builder.display();
            foreach (ListNote listNote in builder.Depot)
            {
                var path = string.Format(note.path, listNote.Note);
                var _l = listNote.List;
                if (note.histo)
                    _l.Sort(new PodCastComparer());
                else
                    _l.Sort(new PodCastComparerInv());
                buildGlobalList(path, _l, 2);

                if (!string.IsNullOrEmpty(note.single))
                {
                    var pathSingle = string.Format(note.single, listNote.Note);
                    var hs = new HashSet<string>();
                    var ls = new List<TrackInfoItunes>();
                    foreach (TrackInfoItunes t in _l)
                    {
                        if (!t.Selected)
                            continue;
                        if (!hs.Add(t.AlbumKey))
                            continue;
                        ls.Add(t);
                    }
                    buildGlobalList(pathSingle, ls, 2);
                }
            }
            // Sélection d'un unique item (preise encompte des niveaux précédents)
            if (!string.IsNullOrEmpty(note.unique))
            {
                Logger logger = Logger.getLogger("NotesU", false);
                //Dictionnaire global
                var hsGlobal = new HashSet<string>();
                var depot = new List<ListNote>(builder.Depot);
                int count = depot.Count;

                for (int i = count - 1; i >= 0; i--)
                {
                    ListNote listNote = depot[i];
                    var _l = listNote.List.FindAll(t => t.Selected && t.Pub <= Fin1ereJournee);
                    _l.Sort(new PodCastComparer());

                    var linv = _l.FindAll(t => t.Recent && ContexteBuilder.Instance.getRetard(t, note.date0Min) <= note.retardHisto);
                    linv.Sort(new PodCastComparerInv());

                    foreach (TrackInfoItunes t in _l)
                    {
                        if (linv.Contains(t))
                            continue;
                        linv.Add(t);
                    }

                    //if (note.histo)
                    //    _l.Sort(new PodCastComparer());
                    //else
                    //    _l.Sort(new PodCastComparerInv());
                    var ls = new List<TrackInfoItunes>();
                    var hs = new HashSet<string>();
                    var pathUnique = string.Format(note.unique, listNote.Note);
                    foreach (TrackInfoItunes t in linv)
                    {
                        //if (!t.Selected)
                        //    continue;
                        if (hsGlobal.Contains(t.AlbumKey))
                            continue;
                        if (hs.Contains(t.AlbumKey))
                            continue;
                        if (t.Pub <= ContexteBuilder.Instance.Zero)
                        {
                            hsGlobal.Add(t.AlbumKey);
                            hs.Add(t.AlbumKey);
                        }
                        else
                        {
                        }

                        ls.Add(t);

                        var tn = listNote.getTrackNote(t.DbId);
                        tn.log(logger);
                    }

                    buildGlobalList(pathUnique, ls, 2);
                }
            }

            //  }

            var contextB = ContexteBuilder.Instance;

            if (contextB.Enabled)
            {

                var selected = dir.getListe();
                selected.Sort(new PodCastComparer());
                var listContext = new List<TrackInfoItunes>();
                contextB.buildList(selected, listContext);

                buildList("_contexte", listContext, 2);
            }



        }

        private void WriteTracks(DirConf dir)
        {
            recursif(dir, action.writeTracksPre, action.writeTracksPost);
        }
#if build
        public void scanFiles(List<TrackInfoItunes> list, DirectoryInfo dir, ref int nbIntegre, ref int nbSuppr)
        {
            string album = dir.Name;
            var files = dir.GetFiles();
            if (files.GetLength(0) > 0)
            {
                foreach (FileInfo file in dir.GetFiles())
                {
                    string location = file.FullName.ToLower();
                    var trackByLocation = list.Find(t => t.Location != null && t.Location.ToLower().Equals(location));

                    if (trackByLocation != null)
                        continue;
                    var filePub = new FilePub(file.FullName);
                    new PubLoader(filePub).setPub();

                    TrackInfoItunes track = null;

                    foreach (TrackInfoItunes t in list)
                    {
                        if (album.Equals(t.Album))
                        {
                            if (filePub.Pub.Date == t.Pub.Date)
                            {
                                track = t;
                                break;
                            }
                        }
                    }
                    //  var track = list.Find(t => album.Equals(t) && filePub.Pub.Date.Equals(t.Pub.Date));
                    if (track == null)
                    {
                       
                        log.log("création Track à partir de " + file.FullName);
                        track = loader.createTrack(file.FullName) as TrackInfoItunes;

                        if (track == null)
                            continue;

                        // verif pub; 
                        TrackInfoItunes track2Verif = null;

                        if (track.Pub > TrackInfoItunes.MIN)
                        {
                            foreach (TrackInfoItunes t in list)
                            {
                                if (album.Equals(t.Album))
                                {
                                    if (track.Pub.Date == t.Pub.Date)
                                    {
                                        track2Verif = t;
                                        break;
                                    }
                                }
                            }
                        }

                        if (track2Verif != null)
                        {
                            log.log("Track créé {0} {1} {2} {3} MAIS doublon avec  {4} {5} {7} {8} {9} intégrés {10} supprimés", track.Name, track.Album, track.Pub, track.Location, 
                                track2Verif.Name, track2Verif.Album, track2Verif.Pub, track2Verif.Location, nbIntegre, nbSuppr);
                            track2Verif.Delete();
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                            nbSuppr++;
                            continue; 

                        }
                        log.log("Track créé {0} {1} {2} {3} {4} intégrés {5} supprimés", track.Name, track.Album, track.Pub, track.Location,nbIntegre,nbSuppr );
                        nbIntegre++;
                        list.Add(track);
                    }
                    else
                    {
                        if (track.Pub.DayOfYear > 1)
                        {
                            nbSuppr++;
                            log.log("suppression du track sur {0} en doublon avec {1} {2} {3} {4} {5} int�gr�s {6} supprim�s", file.FullName, track.Name, track.Album, track.Pub, track.Location, nbIntegre, nbSuppr);
                            file.moveTree(file.FullName.ToLower().Replace(@"c:\zique\podcasts", @"C:\zique\poubelle"), false);
                        }
                    }

                }
                log.log("fin scan {0}: {1} intégrés, {2} supprimmés", album, nbIntegre, nbSuppr);
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                scanFiles(list, subDir, ref nbIntegre, ref nbSuppr);
            }
        }
#endif

#if menage

        private void listFiles(Dict<string, FileInfo> dict, DirectoryInfo dir)
        {
           
            foreach (FileInfo file in dir.GetFiles())
            {
                dict[file.FullName] = file;
            }

            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                listFiles(dict, subDir);
            }
        }
#endif

        /// <summary>
        /// A checkquer
        /// </summary>
        /// <param name="feeds"></param>
        /// <param name="current"></param>
        private void scanFeedsForRecordEmptyLists(Feeds feeds, PlayListComposite current)
        {
            foreach (PlComponent pl in current)
            {
                var plC = pl as PlayListComposite;
                if (plC == null)
                {
                    // log.log("{0} {1} pas un PlayListComposite", pl, pl.GetType());
                    continue;
                }

                if (plC.LeafsCount > 0)
                {
                    string album = plC.Name;
                    feeds.check(album);
                }

                scanFeedsForRecordEmptyLists(feeds, plC);

            }
        }




        #region IAbortTask Members

        public bool Aborted
        {
            get
            {
                return false;
            }
            set
            {

            }
        }

        #endregion


        private class Vendee
        {
            //  "Emission du 02/11/2008"
            private static Regex regex1 = new Regex(@".*(\d\d\/\d\d\/\d\d\d\d).*");
            private static Regex regex2 = new Regex(@".*(\d\d\/\d\d\/\d\d).*");
            private static Regex regex3 = new Regex(@".*(\d\d\/\d\d).*");
            private enum vendeeType
            {
                none,
                vacation,
                hebdo,
                chronique,
                ponton

            }
            public void go(ArrayList list)
            {
                var listV = new ArrayList();
                string VENDEE = "vendee ";
                foreach (IITFileOrCDTrack t in list)
                {
                    if (t.Album.Contains("Vendée Globe") || t.Album.Contains(VENDEE))
                        listV.Add(t);
                }

                // listTrack.FindAll(t => t.Album.Contains("Vendee Globe"));



                foreach (IITFileOrCDTrack track in listV)
                {
                    string name = track.Name.ToLower();
                    vendeeType _type = vendeeType.none;
                    foreach (vendeeType type in Enum.GetValues(typeof(vendeeType)))
                    {
                        if (name.Contains(type.ToString()))
                        {
                            track.Album = VENDEE + type.ToString();
                            _type = type;
                            break;
                        }
                    }

                    DateTime? dt = null;
                    dt = getDate(track.Name);

                    if (!dt.HasValue)
                        dt = getDate(track.Description);

                    if (!dt.HasValue)
                        dt = getDate(track.LongDescription);

                    if (dt.HasValue)
                    {
                        string _comment = dt.Value.ToString("yyyy/MM/dd");
                        string plus = "";
                        switch (_type)
                        {
                            case vendeeType.none:
                            break;
                            case vendeeType.vacation:
                            case vendeeType.ponton: plus = " 11:00"; break;
                            case vendeeType.hebdo: plus = " 14:00"; break;
                            case vendeeType.chronique: plus = " 12:00"; break;

                        }
                        track.Grouping = _comment + plus;
                        track.Year = dt.Value.Year;
                    }



                }
            }

            private DateTime? getDate(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return null;
                string[] words = input.Split(' '); int count = words.GetLength(0);

                DateTime? ret = null;
                StringBuilder sb = null;
                int word = 0;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                        word++;

                        try
                        {
                            ret = Convert.ToDateTime(sb.ToString());
                        }
                        catch
                        {
                        }

                        if (ret.HasValue)
                        {
                            int month = ret.Value.Month;
                            int year = 2008;
                            if (month < 6)
                                year = 2009;
                            return new DateTime(year, month, ret.Value.Day);
                        }
                    }
                }
                try
                {
                    DateTime dt = Convert.ToDateTime(sb.ToString());
                    if (dt.Year < 2008 || dt.Year > 2009)
                        dt = new DateTime(2008, dt.Month, dt.Day);
                    return dt;
                }
                catch
                {
                    return null;
                }
                //if (regex1.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //else if (regex2.IsMatch(_input))
                //    return Convert.ToDateTime(regex2.Match(_input).Groups[1].Value); 
                //else if (regex3.IsMatch(_input))
                //    return Convert.ToDateTime(regex1.Match(_input).Groups[1].Value); 
                //return null; 
            }

            private string getDateString(string input)
            {
                if (string.IsNullOrEmpty(input))
                    return "";
                string[] words = input.Split(' '); int count = words.GetLength(0);


                StringBuilder sb = null;
                for (int i = 0; i < count; i++)
                {
                    string w = words[i];
                    if (string.IsNullOrEmpty(w))
                        continue;
                    if (sb == null)
                    {
                        if (w.ToLower().Equals("du"))
                            sb = new StringBuilder();
                    }

                    else
                    {
                        sb.Append(w);
                        sb.Append(" ");
                    }
                }

                if (sb == null)
                    return input;

                return sb.ToString().Replace(".", "");
            }


        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Auto\AutoBuilderItem.cs">
    <content><![CDATA[using pdb.podcast.Tuning;
using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using pdb.podcast.Delta;
using TimeSpan = pdb.util.timeSpan;
using pdb.podcast.Selection;
using pdb.podcast.Report;
using Math = System.Math;

namespace pdb.podcast.Auto
{
    class AutoBuilderItem //: IBorder
    {


        /// <summary>
        /// Valeur initiale de la valeur gérée
        /// </summary>
        private double org;
        private double pertinentOrg = -1;
        private timeSpan tpertinentOrg;
        public TimeSpan torg;
        private TimeSpan tmin;
        private TimeSpan tmax;
        /// <summary>
        /// Valeur modifiée
        /// </summary>
        private double newv;
        private double evolSize;
        public double NewV { get { return newv; } }
        internal TrackBorderItem rejected(bool real) { return real ? _rejected : _rejectedLight; }
        internal TrackBorderItem selected(bool real) { return real ? _selected : _selectedLight; }
        internal void makePertinent() { pertinentOrg = org; }

        public void checkAjout(IEnumerable<TrackInfoItunes> list)
        {
            if (pertinentOrg == org)
                return;

            var lcauses = _causes;


            foreach (Causes causes in lcauses)
            {
                foreach (TrackInfoItunes t in list)
                {
                    if (causes.candidat.Location == t.Location)
                    {
                        pertinentOrg = org;
                        return;
                    }
                }

            }


        }

        private string name;

        /// <summary>
        /// Attribut concerné
        /// </summary>
        XmlAttribute att;
        XmlAttribute attTension;
        XmlNode xml;
        XmlElement xitem;
        public double dd;
        public double d;
        private bool lastStrict;
        private bool lastUp;
        //private double lastDelta;

        private double lastOrg;

        private pdb.podcast.Tuning.Auto conf;
        public readonly borderType type;
        private AutoBuilder parent;
        private AutoBuilderItem(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            this.parent = parent;
            this.conf = conf;
            this.type = conf.type;
            this.name = getKey(conf); // string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                d = conf.max - conf.min;
            else
                d = conf.pente - conf.min;
            dd = d * d;
        }

        private static string getKey(pdb.podcast.Tuning.Auto conf) { return string.Format("{0}:{1}", conf.name, conf.type); }
        private static Dict<string, AutoBuilderItem> dict = new Dict<string, AutoBuilderItem>();

        public static AutoBuilderItem get(AutoBuilder parent, pdb.podcast.Tuning.Auto conf)
        {
            string key = getKey(conf);
            var i = dict[key];
            if (i == null)
            {
                i = new AutoBuilderItem(parent, conf);
                dict[key] = i;
            }

            i.parent = parent;
            i.conf = conf;
            //i.type = conf.type;
            // i.name = string.Format("{0}:{1}", conf.name, type);
            if (conf.pente == 0)
                i.d = conf.max - conf.min;
            else
                i.d = conf.pente - conf.min;
            i.dd = i.d * i.d;

            return i;

        }

        private bool _toSave;
        public bool ToSave { get { return _toSave; } }

        public double Org { get { return org; } }

        public void setConf(pdb.podcast.Tuning.Auto conf) { this.conf = conf; }

        #region border
        private TrackBorderItem _selected;
        private TrackBorderItem _selectedLight;
        private TrackBorderItem _rejected;
        private TrackBorderItem _rejectedLight;

        //private bool verify(TrackBorderItem tb)
        //{
        //    return true;
        //    double sourceValue = -1;
        //    var source = tb.source;
        //    switch (type)
        //    {
        //        case borderType.d: sourceValue = source.Duration; break;
        //        case borderType.fd: sourceValue = source.FeedDuration; break;
        //        case borderType.maxdate: sourceValue = (source.DateMax - Conf.Date0).TotalDays; break;
        //        default: return false;
        //    }

        //    if (Math.Abs(org - sourceValue) > 2.0E-7)
        //        return false;
        //    return true;
        //}
        private void setSelect(TrackBorderItem tb)
        {
            // pour down mémo des track sélectionnés

            _selected = tb;

        }

        private void setRejec(TrackBorderItem tb)
        {
            // A REVOIR

            //// pour up mémo des tracks rejetés
            ////1. S'il est par ailleurs déjà intégré, pas pertinent
            //if (parent.Source.contains(tb.candidat))
            //{
            //    return;
            //    if (_rejected != null)
            //    {
            //        if (_rejected.status > borderStatus.rejectedXtraLight)
            //            return;
            //        if (tb.val >= _rejected.val)
            //            return; 
            //    }

            //    tb.status = borderStatus.rejectedXtraLight; 
            //}


            ////2. On est en cours de construction donc il se peut que ce candidat soit in fine ajouté par d'autres
            //// intéret en up . S'il est dans la mémoire pas pertinent en up
            //if (parent.Mem.dict.ContainsKey(tb.candidat.Location))
            //    return;
            _rejected = tb;
        }


        public void signal(TrackBorderItem tb)
        {

            if (tb.Virtual && !Conf.BorderVirtual)
                return;
            if (tb.Selected)
            {
                if (tb.val >= torg)
                    return;
                if (tb.val <= tmin)
                    return;

                if (!tb.Virtual)
                {
                    if (_selected == null)
                        _selected = tb;
                    else if (tb.val > _selected.val)
                        _selected = tb;
                }

                if (_selectedLight == null)
                    _selectedLight = tb;
                else if (tb.val > _selectedLight.val)
                    _selectedLight = tb;

                //if (_selected == null)
                //    setSelect(tb);
                //else
                //{
                //    if (tb.status > _selected.status && !Conf.BorderIdem)
                //        setSelect(tb);
                //    else if (tb.status == _selected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val > _selected.val)
                //            setSelect(tb);
                //    }
                //}

            }
            else
            {

                if (tb.val <= torg)
                    return;
                if (tb.val >= tmax)
                    return;

                if (!tb.Virtual)
                {
                    if (_rejected == null)
                        _rejected = tb;
                    else if (tb.val < _rejected.val)
                        _rejected = tb;
                }

                if (_rejectedLight == null)
                    _rejectedLight = tb;
                else if (tb.val < _rejectedLight.val)
                    _rejectedLight = tb;


                //if (_rejected == null)
                //    setRejec(tb);
                //else
                //{
                //    if (tb.status > _rejected.status && !Conf.BorderIdem)
                //        setRejec(tb);
                //    else if (tb.status == _rejected.status || Conf.BorderIdem)
                //    {
                //        if (tb.val < _rejected.val)
                //            setRejec(tb);
                //    }
                //}

            }
        }
        #endregion

        public void setOrg(XmlElement xml)
        {
            // Program.logAuto.log(ToString());
            _rejected = null;
            _selected = null;
            _toSave = false;
            this.xml = xml;
            att = this.xml.Attributes[type.ToString()];

            if (xitem == null)
            {
                var xitems = this.xml.SelectNodes("auto/items/item");
                if (xitems != null)
                {
                    foreach (XmlNode x in xitems)
                    {
                        if (x.Attributes["type"].Value == type.ToString())
                        {
                            xitem = x as XmlElement;
                            break;
                        }
                    }
                }
            }

            if (xitem != null)
                attTension = this.xitem.Attributes["tension"];
            if (attTension == null && xitem != null)
            {
                xitem.SetAttribute("tension", "0");
                attTension = xitem.Attributes["tension"];
            }
            lastOrg = org;
            if (att == null)
                org = -1;
            else
                org = Convert.ToDouble(att.Value);

            if (type == borderType.maxdate && AutoBuilder.Offset > 0)
            {
                org = org - AutoBuilder.Offset;
                newv = org;
                save();
            }

            if (org < conf.min)
            {
                org = conf.min;
                newv = org;
                save();
            }
            else if (org > conf.max)
            {
                org = conf.max;
                newv = org;
                save();
            }
            torg = getValue(org);
            tmin = getValue(conf.min);
            tmax = getValue(conf.max);
            if (pertinentOrg < 0)
                pertinentOrg = org;
            tpertinentOrg = getValue(pertinentOrg);
            if (lastOrg == 0)
                lastOrg = org;
            //  misc.log(ToString());
        }
        private double dt = -1; public double Dt { get { return dt; } set { dt = value; } }
        private double tension; public double Tension { get { return tension; } }
        // private int _stop = AutoBuilder.STOP_MAX;
        public bool Stopped { get { return stopped; } }
        private bool stopped;
        public void stop()
        {
            stopped = true;
            newv = lastOrg;
            org = lastOrg;
            //if (_stop > level)
            //    _stop = level;
            save();
        }
        public void reset()
        {
            //  _stop = AutoBuilder.STOP_MAX;
        }
        public void setTension(bool up, bool real, bool checkSelect)
        {

            dt = getDt(up, real, checkSelect);
        }

        public void setTension()
        {
            tension = _getTension(org);
        }

        public double Pente { get { return conf.pente; } }

        private double getDt(bool up, bool real, bool checkSelect)
        {
            double t0 = _getTension(pertinentOrg);
            tension = _getTension(up, real, checkSelect);
            return (tension - t0) / conf.coeff;

        }

        private double getTension(bool up, bool real, bool selected)
        {
            return _getTension(up, real, selected) / conf.coeff;
        }

        public double getValue(TimeSpan val)
        {
            switch (type)
            {

                case borderType.d:
                case borderType.fd:
                case borderType.nb:
                case borderType.nbp:
                case borderType.c:
                    return val.TotalMinute;
                case borderType.maxdate: return val.TotalDay;
                default: return -1;

            }

        }

        private TimeSpan getValue(double val)
        {
            switch (type)
            {
                case borderType.d:
                case borderType.fd:
                case borderType.nb:
                case borderType.nbp:
                case borderType.c:
                    return TimeSpan.FromMinutes(val);
                case borderType.maxdate: return TimeSpan.FromDays(val);
                default: return new TimeSpan();

            }
        }
        public double EvolSize { get { return evolSize; } }

        public List<Causes> getCauses()
        {
            return _causes;
        }

        //public List<Causes> getcauses(bool up, bool strict)
        //{
        //    List<Causes> list = null;
        //    if (up)
        //    {
        //        if (strict)
        //            list = _causesRejetStrict;
        //        else
        //            list = _causesRejet;
        //    }
        //    else
        //    {
        //        if (strict)
        //            list = _causesSelectStrict;
        //        else
        //            list = _causesSelect;
        //    }
        //    return list;
        //}

        public void gap(bool up, bool fix, double _gap)
        {
            _gap = Math.Abs(_gap);
            lastOrg = org;
            if (fix)
            {
                newv = Math.Abs(_gap);
            }
            else
            {
                if (up)
                    newv = org + _gap;
                else
                    newv = org - _gap;
            }
            save();
        }

        private double _getTension(bool up, bool strict, bool checkSelect)
        {
            lastStrict = strict;
            lastUp = up;
            // double t0 = getTension(org, dd);
            newv = org;
            evolSize = 0;
            var list = _causes;


            if (list.Count > 0)
            {
                int ifin = 2;
                bool bselect = !up;
                if (checkSelect)
                {
                    ifin = 1;
                }

                CauseItem cause = null;

                for (int i = 0; i < ifin; i++)
                {
                    var _cause = list[0].getCause(type, strict, !up, bselect);
                    bselect = !bselect;
                    if (_cause == null)
                        continue;
                    if (cause == null)
                        cause = _cause;
                    else
                    {
                        if (up)
                        {
                            if (_cause.val < cause.val)
                                cause = _cause;
                        }
                        else
                        {
                            if (_cause.val > cause.val)
                                cause = _cause;
                        }
                    }
                }
                if (cause == null)
                    return int.MaxValue;
                // lastOrg = org; 
                newv = Math.Round(getValue(cause.val), 8);
                foreach (var c in list)
                {
                    var cand = c.candidat;
                    evolSize += Report.Stat.getSizeinMo(cand);
                }
            }
            else
                return int.MaxValue;


            //if (false)
            //{

            //    if (up)
            //    {
            //        var _rejected = strict ? this._rejected : this._rejectedLight;
            //        if (_rejected == null)
            //            return int.MaxValue;
            //        newv = Math.Abs(Math.Round(getValue(_rejected.val), 8));
            //        evolSize = Stat.getSizeinMo(_rejected.candidat);

            //    }
            //    else
            //    {
            //        var _selected = strict ? this._selected : this._selectedLight;
            //        if (_selected == null)
            //            return int.MaxValue;
            //        newv = Math.Round(getValue(_selected.val), 8);
            //    }
            //}

            return _getTension(newv);
        }

        public void save()
        {
            //  xml.SetAttribute(type.ToString(), newv.ToString()); 
            att.Value = newv.ToString();
            if (attTension != null)
                attTension.Value = tension.ToString("#.##");
            _toSave = true;
        }

        public void save(timeSpan val)
        {
            lastOrg = org;
            this.newv = Math.Round(getValue(val), 8);
            save();
        }

        //public void save(double _newv)
        //{
        //    this.newv = Math.Round(_newv, 8);
        //    save();
        //}

        public void modif(double tension)
        {
            var val = this.newv == 0 ? org : this.newv;
            val = (tension / Tension) * val;
            if (type == borderType.nb || type == borderType.nbp)
                val = Math.Round(val, 0);
            lastOrg = org;
            this.newv = Math.Round(val, 8);
            save();
        }




        private List<Causes> _causes = new List<Causes>();

        public TrackInfoItunes Candidat { get; set; }
        // public CauseDataValue Cause { get; set; }
        public LimitItemBase limit { get; set; }


        //private List<Causes> _causesRejet = new List<Causes>();
        //private List<Causes> _causesSelect = new List<Causes>();

        //private List<Causes> _causesRejetStrict = new List<Causes>();
        //private List<Causes> _causesSelectStrict = new List<Causes>();



        //public void after()
        //{            
        //    _causesRejet = new List<Causes>();
        //    _causesSelect = new List<Causes>();
        //    _causesRejetStrict = new List<Causes>();
        //    _causesSelectStrict = new List<Causes>();
        //    after(true, true);
        //    after(true, false);
        //    after(false, true);
        //    after(false, false);
        //}
        //public void after(bool up, bool strict, bool checkSelection)
        //{
        //    _causes = new List<Causes>();
        //    var list = parent.CauseRegister.getList(false);
        //    int min = int.MaxValue;
        //    //  int minStrict = int.MaxValue;
        //    if (!up)
        //    {
        //        min = 0;
        //        //   minStrict = 0; 
        //    }
        //    int orgValue = torg.Value;
        //    foreach (Causes causes in list)
        //    {
        //        var candidat = causes.candidat;
        //        if (checkSelection)
        //        {
        //            if (up && candidat.Selected)
        //                continue;
        //            if (!up && !candidat.Selected)
        //                continue;
        //        }
        //        int ifin = 2;
        //        bool bselect = !up;
        //        if (checkSelection)
        //        {
        //            ifin = 1;
        //        }

        //        for (int i = 0; i < ifin; i++)
        //        {


        //            var cause = causes.getCause(type, strict, !up, bselect);
        //            bselect = !bselect;
        //            if (cause == null)
        //                continue;
        //            if (up && cause.Ok)
        //                continue;
        //            if (!up && !cause.Ok)
        //                continue;
        //            //if (value < 0)
        //            //    value = -value;
        //            int value = cause.val.Value;

        //            if (up)
        //            {

        //                if (value == min)
        //                {
        //                    _causes.Add(causes);

        //                }
        //                else if (value < min)
        //                {
        //                    _causes.Clear();
        //                    _causes.Add(causes);
        //                    min = value;
        //                }

        //            }
        //            else
        //            {
        //                if (value >= orgValue)
        //                    continue;

        //                if (value == min)
        //                {
        //                    _causes.Add(causes);
        //                }
        //                else if (value > min)
        //                {
        //                    _causes.Clear();
        //                    _causes.Add(causes);
        //                    min = value;
        //                }


        //            }
        //        }

        //    }
        //}


        private double _getTension(double org)
        {
            var d2 = org - conf.min;
            if (conf.pente > 0)
                return (d2 / d);

            var d1 = org - conf.max;

            return -1 + 2 * (d1 * d1 + d2 * d2) / dd;
        }

        public double getTension(timeSpan org)
        {
            var _org = getValue(org);
            var t = _getTension(_org);
            // dt = t - _getTension(pertinentOrg); 

            return t;
        }





        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine();
            sb.Append(name); sb.Append(" ");
            sb.Append(org); sb.Append(" ");

            if (newv != 0 && newv != org)
            {
                sb.Append("==>");
                sb.Append(newv);
                sb.Append(" ");
            }

            //  sb.Append("stop="); sb.Append(_stop); sb.Append(" ");

            sb.Append("pertinent="); sb.Append(pertinentOrg); sb.Append(" ");
            sb.Append("tension="); sb.Append(tension); sb.Append(" ");
            if (dt != -1)
            {
                sb.Append("dt="); sb.Append(dt); sb.Append(" ");
            }


            if (newv != 0 && newv != org)
            {
                sb.Append("<== ");
            }
            var causes = _causes; // getcauses(lastUp, lastStrict);

            //  sb.AppendLine(); 

            if (Candidat != null)
            {
                sb.AppendLine();
                sb.Append(Candidat); sb.Append(" ");
            }
            if (limit != null)
            {
                // sb.AppendLine(); 
                sb.Append(limit);
            }



            foreach (Causes cause in causes)
            {
                sb.AppendLine();
                var strStrict = lastStrict ? "strict " : "light ";
                var strselect = lastUp ? "rejet " : "select ";
                sb.Append(strselect);
                sb.Append(strStrict);
                sb.Append(cause.getCause(type, lastStrict, !lastUp, !lastUp));
                sb.Append(" "); sb.Append(cause.candidat);
            }

            //if (_causesRejetStrict.Count > 0)
            //{


            //    foreach (Causes cause in _causesRejetStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet strict "); sb.Append(cause.getCause(type,true,false));                     
            //    }
            //}

            //else if (_causesRejet.Count > 0)
            //{

            //    foreach (Causes cause in _causesRejet)
            //    {
            //        sb.AppendLine();
            //        sb.Append("rejet light "); sb.Append(cause.getCause(type,false, false));      
            //    }
            //}

            //if (_causesSelectStrict.Count > 0)
            //{

            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select strict "); sb.Append(cause.getCause(type,true,true));      
            //    }
            //}

            //else if (_causesSelect.Count > 0)
            //{              
            //    foreach (Causes cause in _causesSelectStrict)
            //    {
            //        sb.AppendLine();
            //        sb.Append("select light "); sb.Append(cause.getCause(type,false,true));      
            //    }
            //}



            if (_selected != null)
            {
                sb.AppendLine();
                sb.Append(_selected);
            }

            if (_rejected != null)
            {
                sb.AppendLine();
                sb.Append(_rejected);
            }
            sb.AppendLine();
            return sb.ToString();
        }


        public void signal(CauseDatas cd)
        {
            throw new NotImplementedException();
        }
    }
}
]]></content>
  </file>
  <file path="db4\pdb.podcast\Stat\ListenerStatBuilder.cs">
    <content><![CDATA[using pdb.util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;

namespace pdb.podcast.Stat
{
    class ListenerStatBuilder
    {
        private List<TrackInfoItunes> list;
        public ListenerStatBuilder(List<TrackInfoItunes> list)
        {
            this.list = new List<TrackInfoItunes>(list);
        }
        public void build(DateTime limit)
        {
            Dictionary<DateTime, timeSpan> dict = new Dictionary<DateTime, timeSpan>();
            foreach (TrackInfoItunes t in list)
            {
                if (!t.BasePlayed)
                    continue;
                var reads = (from d in t.Dates where d.type == TrackInfoItunes.TYPE_DATE select d.date).ToList();
                reads.Sort();
                DateTime tt = DateTime.MinValue;
                foreach (DateTime dt in reads)
                {
                    if (dt < limit)
                        continue;
                    var d = dt.Date;
                    if (d == tt)
                        continue;
                    tt = d;
                    if (!dict.ContainsKey(d))
                    {
                        dict.Add(d, t.Duree);
                    }
                    else
                        dict[d] += t.Duree;
                }
            }

            var durees = new List<timeSpan>(dict.Values);
            durees.Sort();

            var dates = new List<DateTime>(dict.Keys);
            dates.Sort();

            if (dates.Count == 0)
                return;

            var firstDate = dates[0];
            if (limit > DateTime.MinValue)
                firstDate = limit.Date;

            double totalDays = (DateTime.Now.Date - firstDate).TotalDays;
            double middle = totalDays * 0.5;
            double firstQuarter = totalDays * 0.25;
            double thirdQuarter = totalDays * 0.75;
            timeSpan nbFirstQuarter = timeSpan.NULL;
            timeSpan nbMiddle = timeSpan.NULL;
            timeSpan nbThirdQuarter = timeSpan.NULL;
            timeSpan max = durees[durees.Count -1]; 
            int nb0 = 0;
            for (DateTime d = firstDate; d < DateTime.Now; d = d.AddDays(1))
            {
                if (!dict.ContainsKey(d))
                {
                    nb0++;
                }
            }

            int nb = nb0;

            foreach (timeSpan d in durees)
            {
                nb++;
                if (nbFirstQuarter == timeSpan.NULL && nb >= firstQuarter)
                    nbFirstQuarter = d;
                if (nbMiddle == timeSpan.NULL && nb >= middle)
                    nbMiddle = d;
                if (nbThirdQuarter == timeSpan.NULL && nb >= thirdQuarter)
                    nbThirdQuarter = d;

            }

            Dictionary<int, int> dictGraph = new Dictionary<int, int>();
            dictGraph.Add(0, 0);
            for (DateTime d = firstDate; d < DateTime.Now; d = d.AddDays(1))
            {
                if (!dict.ContainsKey(d))
                {
                    dictGraph[0]++;
                }
                else
                {
                    var minutes = dict[d].TotalMinute;
                }
            }

        }



    }
}
]]></content>
  </file>
  <file path="db4\pdb.util\TimeSpan.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace pdb.util
{
    public struct timeSpan : IComparable<timeSpan>
    {
        // public static DateTime Date0;
        const int MAX = int.MaxValue - 100;
        private readonly int sec;
        public const int SEC_IN_MIN = 60;
        public const int SEC_IN_HOUR = SEC_IN_MIN * 60;
        public const int SEC_IN_DAY = SEC_IN_HOUR * 24;
        private static timeSpan _NULL;

        static timeSpan()
        {
            _NULL = new timeSpan(); 
        }
        public static timeSpan NULL { get { return _NULL; } }

        public static timeSpan MaxValue { get { return new timeSpan(MAX); } }

        private int borne(double sec)
        {
            if (sec >= MAX)
                sec = MAX;
            else if (sec <= -MAX)
                sec = -MAX;
            return (int)Math.Round(sec);

        }

        private timeSpan(double sec) : this()
        {
            this.sec = borne(sec);
        }
        public timeSpan(System.TimeSpan ts) : this()
        {
            this.sec = borne(ts.TotalSeconds);
        }

        //public static timeSpan operator +(timeSpan t1, System.TimeSpan ts2)
        //{
        //    return new timeSpan(t1.sec + ts2.TotalSeconds);
        //}

        public static timeSpan operator +(timeSpan t1, timeSpan t2)
        {
            return new timeSpan(t1.sec + t2.sec);
        }

        //public static timeSpan operator -(timeSpan t1, System.TimeSpan ts2)
        //{
        //    return new timeSpan(t1.sec - ts2.TotalSeconds);
        //}

        public static timeSpan operator -(timeSpan t1, timeSpan t2)
        {
            return new timeSpan(t1.sec - t2.sec);
        }
        public static bool operator ==(timeSpan t1, timeSpan t2)
        {
            return t1.sec == t2.sec;
        }

        public static timeSpan operator *(timeSpan t, int i)
        {
            return new timeSpan(t.sec * i);
        }

        public static bool operator !=(timeSpan t1, timeSpan t2)
        {
            return t1.sec != t2.sec;
        }
        public static bool operator >(timeSpan t1, timeSpan t2)
        {
            return t1.sec > t2.sec;
        }
        public static bool operator >=(timeSpan t1, timeSpan t2)
        {
            return t1.sec >= t2.sec;
        }
        public static bool operator <(timeSpan t1, timeSpan t2)
        {
            return t1.sec < t2.sec;
        }
        public static bool operator <=(timeSpan t1, timeSpan t2)
        {
            return t1.sec <= t2.sec;
        }
        public static timeSpan FromMinutes(double d)
        {
            var s = d * SEC_IN_MIN;
            return new timeSpan(s);
        }

        public static timeSpan FromDays(double d)
        {
            var s = d * SEC_IN_DAY;
            return new timeSpan(s);
        }

        //public static timeSpan FromDate(DateTime t)
        //{
        //    return new timeSpan(t - Date0);
        //}

        public static timeSpan FromSecondes(int s)
        {
            return new timeSpan(s);
        }

        public double TotalMinute { get { return sec / 60.0; } }
        public double TotalHeure { get { return sec / 3600.0; } }
        public double TotalDay { get { return sec / 86400.0; } }
        public int Value { get { return sec; } }

        public override string ToString()
        {

            StringBuilder sb = new StringBuilder();
            sb.Append(TotalMinute.ToString("0.#")); sb.Append(" ");
            var sec = Math.Abs(this.sec);

            int d = sec / SEC_IN_DAY;
            int r = sec - d * SEC_IN_DAY;
            int h = r / SEC_IN_HOUR;
            r -= h * SEC_IN_HOUR;
            int m = r / SEC_IN_MIN;
            r -= SEC_IN_MIN * m;

            bool w = false;
            if (d > 0)
            {
                w = true;
                sb.Append(d); sb.Append("j ");
            }
            if (w || h > 0)
            {
                w = true;
                sb.Append(h); sb.Append("h ");
            }
            if (w || m > 0)
            {
                sb.Append(m); sb.Append("m ");
            }
            sb.Append(r); sb.Append("s");

            return sb.ToString();

        }
        public override bool Equals(object obj)
        {
            if (obj is int)
                return sec.Equals(obj);
            if (obj is timeSpan)
                return sec.Equals(((timeSpan)obj).sec);
            return false;
        }
        public override int GetHashCode()
        {
            return sec.GetHashCode();
        }

        public int CompareTo(timeSpan other)
        {
            return sec.CompareTo(other.sec); 
        }
    }


}
]]></content>
  </file>
  <file path="db4\PieceDb.Consolid\albums\Album.cs">
    <content><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using pdb.gen.conf;
using pdb.gen.medianne;
using pdb.gen.Tuning;
using pdb.obj;
using pdb.util;
using System.IO;

namespace pdb.gen.albums
{
    public enum virtualMode
    {
        none = 0,
        artist = 1,
        path = 2,
        year = 3,
        extended = 4,
        extendedWord = 5,
        added = 6,
        list = 7,
        word = 8
    }

    public enum sortDone : byte
    {
        none,
        phaseUn,
        phaseDeux
    }

    public class Album : IEnumerable<Piece>
    {
        [Flags]
        private enum typeMove : byte
        {
            move = 1,
            empeached = 2,
            empeached1 = 4
        }
        const int NB_DEC = 3;
        const decimal EPSILON = 0.001m * 0.001m * 0.001m * 0.001m * 0.001m * 0.001m;
        const int A_REFAIRE_CAUSE_COMPACT = -10;
        private static Logger logger = Logger.getLogger("album");
        private string name;
        private string key;
        private static decimal medianne = 0.5m;
        private static decimal medianneRest = 0.5m;
        // public static decimal Medianne { get { return medianne; } set { medianne = value; } }
        private decimal classementValue;
        private decimal classementValueLight;
        //  private decimal classementValueLightSt = -1;
#if GEN2
        private decimal classementValueLightZero = -1;
        private decimal classementValueLightZeroSt = -1;
#endif
        private sortDone sortStatus;

        private int nbRecent;
        private int nbDone;
        public int Recents { get { return nbRecent; } }
        public int NbDone { get { return nbDone; } }
        //public void invalidate(bool silent = false) { sortDone = false; if (!silent) misc.log("invalidate {0}", this); }

        public decimal getSt(decimal classementValueLight)
        {
            var ret = classementValueLight;
            if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && InStackSize)
            {
                if (next == null || !confAlbumSort.stackOnlyNew || next.LastClassementRecent)
                {
                    //      1       10      50      99
                    //      0.99    0.9     0.5     0.01
                    //1.    0.01    0.1     0.5     0.99
                    //2.    0.02    0.19    0.75    0.9999
                    //10    0.095   0.65    0.999   0.99999999999
                    //0.5   0.005   0.05    0.29    0.9
                    var delta = 1 - ((decimal)StackIndex / (decimal)stackSize);
                    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                    if (delta != 1)
                        delta = pdb.util.Math.Pow(delta, stackPower);
                    delta = 1 - delta;

                    if (delta < 0.001m)
                        delta = 0.001m;

                    ret = classementValueLight / delta;
                }
            }

            return ret;
        }
        /// <summary>
        /// classementValue redressé par la quarantaine
        /// </summary>     
        public decimal ClassementValueLightSt
        {
            get
            {
                return getSt(classementValueLight);
                //if (classementValueLightSt >= 0)
                //    return classementValueLightSt;
                //classementValueLightSt = getSt(classementValueLight);

                //if (confAlbumSort != null && confAlbumSort.stackEnabled && confAlbumSort.stackSize > 1 && stackValue < confAlbumSort.stackSize && stackValue > 0)
                //{
                //    //      1       10      50      99
                //    //      0.99    0.9     0.5     0.01
                //    //1.    0.01    0.1     0.5     0.99
                //    //2.    0.02    0.19    0.75    0.9999
                //    //10    0.095   0.65    0.999   0.99999999999
                //    //0.5   0.005   0.05    0.29    0.9
                //    var delta = 1 - ((decimal)stackValue / (decimal)stackSize);
                //    // 1 - 10/100=> 0.9-> 0.81 ==> 1/0.19
                //    if (delta != 1)
                //        delta = pdb.util.Math.Pow(delta, stackPower);
                //    delta = 1 - delta;

                //    if (delta < 0.001m)
                //        delta = 0.001m;

                //    classementValueLightSt = classementValueLight / delta;
                //}
                //else
                //    classementValueLightSt = classementValueLight;

                //  return classementValueLightSt;
            }
        }

        public decimal ClassementValueLightZeroSt
        {
            get
            {
#if GEN2
                if (classementValueLightZeroSt < 0)
                    classementValueLightZeroSt = getSt(classementValueLightZero);
                return classementValueLightZeroSt;
#else
                return ClassementValueLightSt;
#endif
            }
        }
        //  private decimal classMoy; public decimal ClassementMoy { get { return classMoy; } }
        public decimal ClassementValue { get { return classementValue; } }
        public decimal ClassementValueLight { get { return classementValueLight; } }
        public decimal ClassementValueLightZero
        {
            get
            {
#if GEN2
                return classementValueLightZero;
#else
                return ClassementValueLight;
#endif
            }
        }
        public decimal Rendement
        {
            get
            {
#if GEN2
                if (classementValueLight == 0) return 1; return classementValueLightZero / classementValueLight;
#else
                return 1;
#endif
            }
        }
        private decimal durationValue = 0;
        public decimal DurationValue { get { return durationValue; } }
        private static ConfGen conf = CConf.ConfGen;
        private virtualMode mode;
        public virtualMode VirtualMode { get { return mode; } }
        //  private bool _virtual;
        public bool Virtual { get { return mode > virtualMode.none; } }
        public void setVirtual(virtualMode mode) { this.mode = mode; }
        private bool _virtualByArtist;
        public bool VirtualByArtist { get { return this.mode == virtualMode.artist; } }
        private Piece pluspetitEnabled;
        public Piece PlusPetitEnabled { get { return pluspetitEnabled; } }
        // private int stackValue;
        private DateTime majDate;
        public DateTime MajDate { get { return majDate; } }

        //public int StackValue
        //{
        //    get
        //    {

        //        return stackValue;
        //    }
        //    set
        //    {
        //        if (value > 0 && this.Name == "\\")
        //        {
        //        }
        //        else
        //            stackValue = value;
        //    }
        //}

        public bool InStackSize { get { return StackIndex < stackSize && name != "\\"; } }
        public bool InStackPeremption { get { return StackIndex < stackPeremption && name != "\\"; } }
        public int StackIndex { get; set; }
        //  private int rankCorrig; public int Rank2 { get { return rankCorrig; } set { rankCorrig = value; } }
        private Piece next;


        public Piece Next
        {
            get { return next; }
            set
            {
                next = value;
            }
        }




        private HashSet<Piece> list = new HashSet<Piece>();
        private HashSet<Piece> masters = new HashSet<Piece>();

        #region cache
        HashList<Piece> trackSortedByExportPriority;
        private HashList<Piece> _tracksSortByClassement;
        #endregion

        private static int _sID = 0;
        private int _dID;

        public string Key
        {
            // set { key = value; }
            get
            {
                if (key == null)
                    key = getKey(name, mode);
                return key;
            }
        }

        public Album(string name, virtualMode mode)
        {
            this.name = name;
            this.mode = mode;
            quality = CRank.MAX;
        }

        public Album(string name, string key)
        {
            _sID++;
            _dID = _sID;
            this.name = name;
            this.key = key;

            quality = CRank.MAX;
        }
        private int quality;
        public int Quality
        {
            get { return quality; }
            set { quality = value; }
        }

        public int RankAlbumReverse
        {
            get
            {
                return Albums.RankZero - quality; // 1 + gen.Albums.Count - rank; //   AlbumZero = Count - i; 
            }
        }

        private decimal timeRest = decimal.MaxValue;
        public decimal TimeRest { get { return timeRest; } set { timeRest = System.Math.Round(value, NB_DEC); } }
        public string Name { get { return name; } }

        public override string ToString()
        {
            return string.Format("{0} {1} {2} elts", name, mode, Count);
        }

        // private string equiv = "";
        public string Equiv { get { return Piece.getClassementEquiv(classementValue); } }

        //  private string equivLight = "";
        public string EquivLight { get { return Piece.getClassementEquiv(classementValueLight); ; } }
        public string EquivLightSt { get { return Piece.getClassementEquiv(ClassementValueLightSt); ; } }

        //private string equivLight0 = "";
        public string EquivLight0
        {
            get
            {
#if GEN2
                return Piece.getClassementEquiv(classementValueLightZero);
#else
                return EquivLight;
#endif
            }
        }

        //// private string moyenne = "";
        //public string Moyenne { get { return Piece.getClassementEquiv(classMoy); } }

        private static Dict<string, typeMove> dictMove = new Dict<string, typeMove>();

        public static void clearMove() { dictMove.Clear(); }

        private static bool HasMoveValue(string key, typeMove type)
        {
            return dictMove[key].HasFlag(type);
        }
        private static void SetMoveValue(string key, bool value, typeMove type)
        {
            var v = dictMove[key];
            if (value)
            {
                v |= type;
            }
            else
            {
                v &= ~type;
            }
            if (v == 0)
                dictMove.Remove(key);
            else
                dictMove[key] = v;
        }

        public bool Moved
        {
            get
            {
                return HasMoveValue(Key, typeMove.move);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.move);
            }
        }
        /// <summary>
        /// Empeché par la quarantaine
        /// </summary>
        public bool Empeached
        {
            get
            {
                return HasMoveValue(Key, typeMove.empeached);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.empeached);
            }
        }

        public void empeachedDecrement()
        { //nbEmpeached--; 
        }

        // public int EmpeachedNb { get { return nbEmpeached; } }

        //private int nbEmpeached;
        /// <summary>
        /// Premier empêché
        /// </summary>
        public bool Empeached1
        {
            get
            {
                return HasMoveValue(Key, typeMove.empeached1);
            }
            set
            {
                SetMoveValue(Key, value, typeMove.empeached1);
            }
        }
        private static int stackSize = 20;
        public static int stackPeremption = 10;
        private static decimal stackPower = 2.0m;
        private static ConfAlbumSort confAlbumSort;
        public static ConfAlbumSort ConfAlbumSort
        {
            set
            {
                confAlbumSort = value;
                if (confAlbumSort != null)
                {
                    stackSize = confAlbumSort.stackSize;
                    stackPeremption = confAlbumSort.stackPeremption;
                    stackPower = confAlbumSort.stackPower;
                }
            }
        }

        public bool AlmostFree { get { return StackIndex == stackSize; } }
        public bool AlmostFree1 { get { return StackIndex == stackSize - 1; } }

        //private Piece equiv;



        public bool add(Piece piece)
        {
            if (build)
                throw new ApplicationException("déjà buildé");
            piece.PieceAlbum = this;


            // misc.log("{0} ajout {1}", name, piece); 
            //if (list.Contains(piece))
            //{
            //    int yoyo = 0;
            //}
            if (!masters.Add(piece.Master))
            {
                //var status = "";
                //if (_virtual)
                //    status = "v";
                //if (_virtualByArtist)
                //    status = "va";
                //logger.log("{0}\t{1}:doublon id=\"{2}\" parent=\"{3}\" Nom={4} {5}", status, name, piece.PieceId, piece.MasterId, piece.Name, piece);
                return false;
            }
            if (piece.Enabled)
                atLeastOneEnabled = true;
            list.Add(piece);

            return true;
        }

        private bool build;

        public void checkBuild()
        {
            if (!build)
            {
                Clear();
                quality = CRank.MAX;
            }
        }

        public void Clear()
        {
            //misc.log("album.Clear {0}",name);
            //foreach (Piece p in this)
            //{
            //    if (p.Virtual)
            //        p.Parent = null; 
            //}
            list.Clear();
            masters.Clear();
        }

        public void ClearAndMenage()
        {
            if (mode == virtualMode.word && name == "029")
            {
            }
            if (mode != virtualMode.none)
            {
                foreach (Piece p in list)
                    p.setParent(null);
            }
            Clear();
        }

        public void ConsolidChilds()
        {
            foreach (Piece p in list)
                p.consolidChild();
        }

        public bool buildDone()
        {
            build = true;
            return list.Count > 0;
        }


        public HashList<Piece> Tracks
        {
            get
            {
                if (_tracksSortByClassement == null)
                {
                    var l = new List<Piece>(list);
                    l.Sort(new PieceVirtualClassementComparer());
                    _tracksSortByClassement = new HashList<Piece>(l);
                }
                return _tracksSortByClassement;
            }
        }

        public int Count { get { return list.Count; } }

        //public int IndexClass(Piece p)
        //{
        //    return Tracks.IndexOf(p);
        //}

        //public List<Piece> TracksReverse
        //{
        //    get
        //    {
        //        var l = new List<Piece>(list);
        //        l.Sort(new PieceClassementComparerInv());
        //        return l;
        //    }
        //}

        private class PieceExportComparer : IComparer<Piece>
        {
            private HashList<Piece> source;
            private Piece next;
            private int inext = -1;
            private int ifirstZero = -1;
            private bool sortlasts;
            private bool sortFirsts;
            private Album album;
            public PieceExportComparer(Album album, HashList<Piece> source, Piece next)
            {
                this.album = album;
                this.source = source;
                this.next = next;
                if (next != null)
                    inext = source.IndexOf(next);
                sortlasts = CConf.Export.sortLasts;
                sortFirsts = CConf.Export.sortFirsts;
                int count = source.Count;
                for (int i = 0; i < count; i++)
                {
                    var p = source[i];
                    if (p.Enabled && !p.ClassmentPositive())
                    {
                        ifirstZero = i;
                        break;
                    }
                }

            }
            public int Compare(Piece x, Piece y)
            {
                //    t = 1.CompareTo(2) -> -1              
                //  t = true.CompareTo(false) ->1
                if (x == y)
                    return 0;
                if (x == next)
                    return -1;
                if (y == next)
                    return 1;
                int ix = source.IndexOf(x);
                int iy = source.IndexOf(y);
                if (ix == iy)
                    return 0;

                if (next != null)
                {
                    int cmp = 0;


                    cmp = (x.Enabled.CompareTo(y.Enabled));
                    if (cmp != 0)
                    {
                        if (sortFirsts)
                        {
                            //true puis false;
                            return -cmp;
                        }
                        if (sortlasts)
                        {
                            if (!x.Enabled && x.VirtualClassement < album.ClassementValueLight)
                                return 1;
                            if (!y.Enabled && y.VirtualClassement < album.ClassementValueLight)
                                return -1;
                        }
                    }

                    //if (dx * dy < 0)
                    //{
                    //    if (sortlasts)
                    //    {
                    //        if (dx > 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy > 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //    if (sortFirsts)
                    //    {
                    //        if (dx < 0 && !x.Enabled)
                    //            return 1;
                    //        if (dy < 0 && !y.Enabled)
                    //            return -1;
                    //    }
                    //}

                    int dx = ix - inext;
                    int dy = iy - inext;
                    dx *= dx;
                    dy *= dy;

                    if (ifirstZero >= 0)
                    {
                        dx += ((ix - ifirstZero) * (ix - ifirstZero));
                        dy += ((iy - ifirstZero) * (iy - ifirstZero));
                    }

                    cmp = dx.CompareTo(dy);
                    if (cmp != 0)
                        return cmp;
                    //ici même distance
                    cmp = x.Enabled.CompareTo(y.Enabled);
                    if (cmp != 0) return -cmp;

                    cmp = ix.CompareTo(iy);
                    return cmp;
                }

                return source.IndexOf(x).CompareTo(source.IndexOf(y));
            }
        }
        public HashList<Piece> TrackSortedByExportPriority
        {
            get
            {
                if (trackSortedByExportPriority == null)
                {

                    var source = new HashList<Piece>(Tracks);
                    if (next == null)
                        trackSortedByExportPriority = source;
                    else
                    {
                        var cmp = new PieceExportComparer(this, source, next);
                        var l = source.List;
                        l.Sort(cmp);

                        trackSortedByExportPriority = new HashList<Piece>(l);


                    }



                    //var source = Tracks;
                    //if (next == null)
                    //    trackSortedByExportPriority = new HashList<Piece>(source);
                    //else
                    //{
                    //    trackSortedByExportPriority = new HashList<Piece>();
                    //    int indexNext = source.IndexOf(next);
                    //    trackSortedByExportPriority.Add(next);

                    //    int count = source.Count;
                    //    int offset = 0;
                    //    while (true)
                    //    {
                    //        offset++;
                    //        bool _continue = false;
                    //        // on prend le précédent et le suivant
                    //        var index = indexNext - offset;

                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }
                    //        index = indexNext + offset;
                    //        if (index >= 0 && index < count)
                    //        {
                    //            trackSortedByExportPriority.Add(source[index]); _continue = true;
                    //        }

                    //        if (!_continue)
                    //            break;
                    //  }

                    //}
                }
                return trackSortedByExportPriority;
            }

        }



        public int IndexExport(Piece p)
        {
            return TrackSortedByExportPriority.IndexOf(p);
        }
        public List<Piece> TrackByNumber
        {
            get
            {
                var l = new List<Piece>(list);
                l.Sort(new PieceTrackNumberComparer());
                return l;
            }
        }
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        private bool classed;
        /// <summary>
        /// Au moins un track est classé
        /// </summary>
        public bool Classed { get { return classed; } }

        /// <summary>
        /// Le track Selectionné est malheureusement absent
        /// </summary>
        public bool Absent
        {
            get
            {
                if (next == null)
                    return true;
                var exists = FileRegister.Exist(next.Location);
                return false == exists;
            }
        }

        //public int nbInAlbum(exportState state)
        //{
        //    return list.Count(p => p.ExportStatus == state); 
        //}

        public int NbExportPresents { get { return list.Count(p => p.ExportStatus == exportState.present || p.ExportStatus == exportState.copy); } }

        private bool? atLeastOneEnabled;
        public bool AtLeastOneEnabled
        {
            get
            {
                if (atLeastOneEnabled == null)
                {
                    atLeastOneEnabled = false;
                    foreach (Piece p in list)
                    {
                        if (p.Enabled)
                        {
                            atLeastOneEnabled = true;
                            break;
                        }
                    }
                }

                return atLeastOneEnabled.Value;
            }
        }

        /// <summary>
        /// Facon dont est séléectionné le Next
        /// </summary>
        private selectedCoeff selectedCoeff;
        public selectedCoeff SelectedCoeff { get { return selectedCoeff; } }

        /// <summary>
        /// Empecher la dégradation du selectedCoeff
        /// </summary>
        private bool selectedSure;
        public bool DontTouchSelectedCoeff { get { return false; } }// selectedSure; } }
        public void InvalidateMain()
        {
            if (selectedCoeff > selectedCoeff.noCoeff)
                selectedCoeff = selectedCoeff.noCoeff;
        }


        //  private bool sortDone;
        //  DecimalIndex _med0 = null;
        DecimalPiece med = null;


        private decimal makeSort(List<IPieceAlbum> list, ConfMedianne mode, bool real)
        {
            decimal classementValueLight = 0m;
            try
            {
                #region calcul virtuel



                DecimalPiece med = null;
#if GEN2
                DecimalPiece med1 = null;
                DecimalPiece med2 = null;
#endif



                bool? resultGlobalMin = null;
                var _albumMedianne = new AlbumMedianne(list, mode);
                // bool combineNow = mode.combine && mode.simple;
#if GEN2
                if (real)
                    _albumMedianne.buildVirtual(mode.combine, mode.simple);
                else
                {
#else
                if (mode.Main.coeffVirt > 1)
                    _albumMedianne.buildVirtual(true, mode.simple);
                else
                    list.Sort(new PieceClassementComparer(false));
#endif
#if GEN2
            }
#endif
#if GEN2

                if (!real || (mode.combine && mode.simple || (!mode.Min.Use)))
                {
                    if (real && mode.combine && mode.simple)
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    else
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    med1 = med; med2 = med;

                }

                else
                {


                    med2 = _albumMedianne.getMedianneLight(mode.Min, pieceExtendedMode.min);  //AlbumMedianne.getMedianneLight(list, mode, mode.Min, false, false);
                    med1 = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);

                    //comparaison des médiannes
                    if (med2.d < med1.d && med2.d > 0)
                    {
                        resultGlobalMin = true;
                        med = med2;
                    }
                    else
                    {
                        resultGlobalMin = false;
                        med = med1;
                    }

                    if (mode.combine && !mode.simple)
                    {
                        med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.combine);
                    }


                }

                
                if (mode.combine && mode.simple)
                {

                    var median = med.index;

                    if (median != null)
                    {
                        resultGlobalMin = median.getSimpleCause();
                    }

                }
#else
                med = _albumMedianne.getMedianneLight(mode.Main, pieceExtendedMode.main);
                var median = med.index;

                if (median != null)
                {
                    resultGlobalMin = median.getSimpleCause();
                }
#endif















                #endregion


                var modeMin = mode.cmpMin;
                ////comparaison du premier non null
                //bool? resultByFirstMin = null;
                //// comparaison du premier null
                //bool? resultZeroMin = null;

                //// résultat : min ou main
                //bool? selectedMotifMin = null;

                AutoCause cause = null;

                if (modeMin == modeMin.orphelin)
                {
                    throw new NotImplementedException();
                    //PieceExtended min = null;
                    //decimal _min = int.MaxValue;
                    //foreach (PieceExtended p in list)
                    //{
                    //    var v = p.RapportClassement;

                    //    if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //    {
                    //        if (v < _min)
                    //        {
                    //            _min = v;
                    //            min = p;
                    //        }
                    //    }
                    //}

                    //if (min != null)
                    //{
                    //    Next = min.Piece;
                    //    _min = min.VirtualClassement2;
                    //    if (_min > classementValueLight)
                    //        classementValueLight = _min;
                    //}
                }
                else if (modeMin == modeMin.toujours)
                {

                    if (mode.Main.oldAsZero)
                        list.Sort(new PieceClassementComparer(true, pieceExtendedMode.main));

                    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    #region deporte
                    //    PieceExtended nextZero1 = null;
                    //    PieceExtended nextZero2 = null;

                    //    PieceExtended min1 = null;
                    //    PieceExtended min2 = null;
                    //    PieceExtended min = null;
                    //    decimal _min1 = int.MaxValue;
                    //    decimal _min2 = int.MaxValue;
                    //    decimal _minzero1 = int.MaxValue;
                    //    decimal _minzero2 = int.MaxValue;
                    //    bool realZero = false;
                    //    PieceExtended Next = null;
                    //    foreach (PieceExtended p in list)
                    //    {
                    //        var v1 = p.VirtualClassement;
                    //        var v2 = p.VirtualClassement2;

                    //        if (p.Enabled) // && FileRegister.Exist(p.Location))
                    //        {
                    //            if (v1 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v1 < _minzero1)
                    //                {
                    //                    _minzero1 = v1;
                    //                    nextZero1 = p;
                    //                    if (v1 == 0)
                    //                        realZero = true;
                    //                }
                    //            }

                    //            if (v2 == 0 || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    //            {
                    //                if (v2 < _minzero2)
                    //                {
                    //                    _minzero2 = v2;
                    //                    nextZero2 = p;
                    //                    if (v2 == 0)
                    //                        realZero = true;
                    //                }

                    //            }



                    //            if (v1 > 0 && v1 < _min1)
                    //            {
                    //                _min1 = v1;
                    //                min1 = p;
                    //            }

                    //            if (v2 > 0 && v2 < _min2)
                    //            {
                    //                _min2 = v2;
                    //                min2 = p;
                    //            }
                    //        }
                    //    }
                    //    decimal _min = 0;
                    //    if (_min1 <= _min2)
                    //    {
                    //        if (_min1 < _min2)
                    //            resultByFirstMin = false;
                    //        min = min1;
                    //        _min = _min1;
                    //    }
                    //    else
                    //    {
                    //        resultByFirstMin = true;
                    //        min = min2;
                    //        _min = _min2;
                    //    }

                    //    PieceExtended nextZero = null;
                    //    decimal _minzero = int.MaxValue;
                    //    if (_minzero1 <= _minzero2)
                    //    {
                    //        nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) resultZeroMin = false;
                    //    }
                    //    else
                    //    {
                    //        nextZero = nextZero2; _minzero = _minzero2; resultZeroMin = true;
                    //    }

                    //    if (nextZero != null)
                    //    {

                    //        if (realZero)
                    //        {
                    //            // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    //            // j'applique le seuil que s'il est inférieur à la médiane
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }
                    //            }
                    //            else
                    //            {
                    //                if (real)
                    //                {

                    //                    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                        selectedMotifMin = resultGlobalMin;
                    //                    // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                    Next = nextZero;

                    //                }
                    //            }
                    //        }
                    //        else
                    //        {
                    //            if (_min < classementValueLight)
                    //            {
                    //                if (min != null)
                    //                {
                    //                    classementValueLight = _min;
                    //                    if (real)
                    //                    {
                    //                        Next = min;
                    //                        selectedMotifMin = resultByFirstMin;
                    //                        //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.main;
                    //                        //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min;
                    //                        //if (_min < _min1 - EPSILON)
                    //                        //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                    }
                    //                }

                    //            }
                    //            else if (_minzero < classementValueLight)
                    //            {
                    //                if (real)
                    //                {
                    //                    Next = nextZero;
                    //                    classementValueLight = _minzero;
                    //                    selectedMotifMin = resultZeroMin;

                    //                    //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.main;
                    //                    //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min;
                    //                    //if (_min < _min1 - EPSILON)
                    //                    //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                    //                }
                    //            }

                    //            else
                    //            {
                    //                classementValueLight = _min;
                    //                if (real)
                    //                {
                    //                    Next = min;
                    //                    selectedMotifMin = resultGlobalMin;

                    //                    //    //  var p = list[med.index];
                    //                    //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.main;
                    //                    //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                    //                    //        selectedCoeff = selectedCoeff.min;
                    //                    //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                    //                    //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                    //                }

                    //            }
                    //        }
                    //    }
                    //    else
                    //    {
                    //        // tous notés => on prend le plus faible
                    //        if (real)
                    //            Next = min;
                    //        if (min != null)
                    //        {
                    //            classementValueLight = _min;
                    //            selectedMotifMin = resultByFirstMin;
                    //        }

                    //    }

                    //}

                    #endregion
                }

                var cnext = cause.Next;
                if (cnext != null)
                {
                    if (cnext.UseCompact && !cnext.Empty)
                    {
                        if (cnext.Piece.ClassementRecentCompact)
                        {
                            cnext.UseCompact = false;
                            return A_REFAIRE_CAUSE_COMPACT;
                        }
                    }
                }
                classementValueLight = med.d;
                var selectedMotifMin = cause.selectedMotifMin;
                classementValueLight = cause.classementValueLight;

                if (real)
                {

                    //if (mode.combine && !mode.simple)
                    //{
                    //    _albumMedianne.buildVirtual(true);
                    //    med = _albumMedianne.getMedianneLight(mode.Main, PieceExtended.mode.combine); // AlbumMedianne.getMedianneLight(list, mode, mode.Main, true, true);
                    //    cause = checkCause(list, mode, real, resultGlobalMin, med.d);
                    //}
                    //else
                    //{
                    //    if (true == cause.selectedMotifMin)
                    //        med = med2;
                    //    else
                    //        med = med1;
                    //}




                    this.Next = cause.Next == null ? null : cause.Next.Piece;
                    classementValueLight = cause.classementValueLight;
                    selectedSure = cause.motifSure;

#if GEN2
                    foreach (var p in list)
                        p.finalyse();

#endif


                    if (cause.motifUp)
                    {
                        if (cause.selectedMotifMin.HasValue)
                        {
                            if (true == cause.selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else if (selectedMotifMin.HasValue)
                        {
                            if (true == selectedMotifMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }
                        else
                        {
                            if (true == resultGlobalMin)
                                selectedCoeff = selectedCoeff.min;
                            else
                                selectedCoeff = selectedCoeff.main;
                        }


                    }

                    try
                    {
                        if (med.index != null)
                            pluspetitEnabled = med.index.Piece;
                        if (med.index != null) med.index.Piece.MedianneLight = true;
                        if (med.indexBorder != null) med.indexBorder.Piece.Border = true;
                        if (med.indexBorderEffect != null) med.indexBorderEffect.Piece.BorderEffect = true;
                        if (med.indexBorderMin != null) med.indexBorderMin.Piece.BorderMin = true;

                    }
                    catch { }
                }



            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return classementValueLight;


        }

        private class AutoCause
        {

            //comparaison du premier non null
            public bool? resultByFirstMin = null;
            // comparaison du premier null
            public bool? resultZeroMin = null;

            // résultat : min ou main
            public bool? selectedMotifMin = null;
            public IPieceAlbum Next = null;
            public bool motifUp;
            /// <summary>
            /// interdiction de dégradation en noCoeff
            /// </summary>
            public bool motifSure;
            public decimal classementValueLight;
        }

        private AutoCause checkCause(List<IPieceAlbum> list, ConfMedianne mode, bool real, bool? resultGlobalMin, decimal d)
        {
            var classementValueLight = d;
            bool forceKeep = mode.forceKeep;
            bool forceKeep2 = mode.forceKeep2;
            bool dontDownByKeep = mode.dontDownByKeep;


            // PieceExtended median = null;
            AutoCause cause = new AutoCause();
            //if (med.index > 0 && med.index < list.Count)
            //{
            //    median = list[med.index];
            //    if (mode.simple && resultGlobalMin == null)
            //    {
            //        resultGlobalMin = median.getSimpleCause();
            //    }
            //}
            var modeMin = mode.cmpMin;



            IPieceAlbum nextZero1 = null;
#if GEN2
            IPieceAlbum nextZero2 = null;
             IPieceAlbum min2 = null;
                Classement _min2 = null;
              Classement _minzero2 = null;
#endif

            IPieceAlbum min1 = null;

            IPieceAlbum min = null;
            Classement _min1 = null;

            Classement _minzero1 = null;

            bool realZero = false;
            IPieceAlbum Next = null;

            IPieceAlbum firstKeep = null;
            IPieceAlbum firstKeep2 = null;
            int index = 0;
            int count = list.Count;
            for (; index < count; index++)
            // foreach (IPieceAlbum p in list)
            {
                IPieceAlbum p = list[index];
                if (p.Piece.Keep)
                {
                    if (p.Piece.KeepCoeff > 0)
                    {
                        if (firstKeep == null)
                            firstKeep = p;
                    }
                    if (p.Piece.KeepCoeff < 0)
                    {
                        if (firstKeep2 == null)
                            firstKeep2 = p;
                    }

                    //min= firstInAlbumEmpty; 
                    //break;
                }
                var piece = p.Piece;
                Classement v1 = piece.LastClassementRecent ? piece.getClassement(true) : p.Classement;
                //  var v1 = p.Classement;
#if GEN2
                var v2 = p.Classement2;
#endif

                if (p.Enabled) // && FileRegister.Exist(p.Location))
                {
                    if (v1.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v1 < _minzero1)
                        {
                            if (!p.Piece.Keep || !dontDownByKeep)
                            {
                                _minzero1 = v1;
                                nextZero1 = p;
                                if (v1.isZero())
                                    realZero = true;
                            }
                        }
                    }
#if GEN2

                    if (v2.isZero() || (mode.Main.oldAsZero && !p.LastClassementRecent))
                    {
                        if (v2 < _minzero2)
                        {
                            _minzero2 = v2;
                            nextZero2 = p;
                            if (v2.isZero())
                                realZero = true;
                        }

                    }

#endif

                    if (v1.isPositive() && v1 < _min1)
                    {
                        if (!p.Piece.Keep || !dontDownByKeep)
                        {
                            _min1 = v1;
                            min1 = p;
                        }
                    }
#if GEN2
                    if (v2.isPositive() && v2 < _min2)
                    {
                        _min2 = v2;
                        min2 = p;
                    }
#endif

                    if (p.Empty)
                        break;
                }
            }
            Classement _min = null;
#if GEN2
            if (_min1 <= _min2)
            {
                if (_min1 < _min2)
                    cause.resultByFirstMin = false;
                min = min1;
                _min = _min1;

            }
            else
            {
                cause.resultByFirstMin = true;
                min = min2;
                _min = _min2;
            }
#else
            min = min1;
            _min = _min1;
#endif

            IPieceAlbum nextZero = null;
            Classement _minzero = null;
#if GEN2
            if (_minzero1 <= _minzero2)
            {
                nextZero = nextZero1; _minzero = _minzero1; if (_minzero1 < _minzero2) cause.resultZeroMin = false;
            }
            else
            {
                nextZero = nextZero2; _minzero = _minzero2; cause.resultZeroMin = true;
            }
#else
            nextZero = nextZero1; _minzero = _minzero1;
#endif

            //if (firstInAlbumEmpty != null)
            //{
            //    Next = firstInAlbumEmpty;
            //    cause.selectedMotifMin = cause.resultByFirstMin;
            //    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
            //}
            //else
            //{

            if (nextZero != null)
            {
                decimal _minValue = _min == null ? int.MaxValue : _min.RapportClassement;
                decimal _minZeroValue = _minzero == null ? int.MaxValue : _minzero.RapportClassement;
                if (realZero)
                {
                    // le min trouvé est éventuellement tres élevé (pas prise en compte des éléments non encore notés
                    // j'applique le seuil que s'il est inférieur à la médiane

                    if (_minValue < classementValueLight && min != null)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;
                            }
                        }
                    }
                    else
                    {
                        if (real)
                        {
                            //if (_med0 == null)
                            //    _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(list), mode0, mode0.Main, true, false);
                            if (this.ClassementValueLightZero > classementValueLight + EPSILON || (classementValueLight > 0 && this.ClassementValueLightZero / classementValueLight > 1 + EPSILON)) // if (p.CoeffVirtuel > 1)
                            {
                                cause.selectedMotifMin = resultGlobalMin;
                                cause.motifUp = true;
                                cause.motifSure = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !median.EffectMain;
                                //}
                            }
                            else
                            {
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                if (min != null)
                                    cause.motifUp = min.getCauseUp(cause.selectedMotifMin);
                            }
                            // selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 
                            Next = nextZero;

                        }
                    }
                }
                else
                {
                    if (_minValue < classementValueLight)
                    {
                        if (min != null)
                        {
                            classementValueLight = _minValue;
                            if (real)
                            {
                                Next = min;
                                cause.selectedMotifMin = cause.resultByFirstMin;
                                cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                                //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.main;
                                //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                                //    selectedCoeff = selectedCoeff.min;
                                //if (_min < _min1 - EPSILON)
                                //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                                //if (mode.simple)
                                //{
                                //    cause.selectedMotifMin = !min.EffectMain;
                                //}
                            }
                        }

                    }
                    else if (_minZeroValue < classementValueLight)
                    {
                        classementValueLight = _minZeroValue;
                        if (real)
                        {
                            Next = nextZero;

                            cause.selectedMotifMin = cause.resultZeroMin;
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);

                            //if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.main;
                            //if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //    selectedCoeff = selectedCoeff.min;
                            //if (_min < _min1 - EPSILON)
                            //    selectedCoeff = selectedCoeff.min; // selectedByCoeff2 = true;

                            //if (mode.simple)
                            //{
                            //    if (nextZero != null)
                            //        cause.selectedMotifMin = !nextZero.EffectMain;
                            //}
                        }
                    }

                    else
                    {

                        classementValueLight = _min == null ? int.MaxValue : _min.RapportClassement;
                        if (real)
                        {
                            Next = min;
                            cause.selectedMotifMin = resultGlobalMin;

                            cause.selectedMotifMin = Next.getSimpleCause();
                            cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                            //    //  var p = list[med.index];
                            //    if (!resultMin && Next.CoeffVirtuel > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.main;
                            //    if (resultMin && Next.CoeffVirtuel2 > 1 + EPSILON)
                            //        selectedCoeff = selectedCoeff.min;
                            //    if (_med0.d > med.d + EPSILON) // if (p.CoeffVirtuel > 1)
                            //        selectedCoeff = selectedCoeff.main; // selectedByCoeff = true; 

                            //if (mode.simple)
                            //{
                            //    cause.selectedMotifMin = !min.EffectMain;
                            //}
                        }

                    }
                }
            }
            else
            {
                // tous notés => on prend le plus faible
                if (real)
                    Next = min;
                if (min != null)
                {
                    classementValueLight = _min.RapportClassement;
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    if (Next != null)
                    {
                        cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                        //if (mode.simple)
                        //{
                        //    cause.selectedMotifMin = !Next.EffectMain;
                        //}
                    }
                }

            }
            //}

            if (Next == nextZero)
            {
                bool refact = false;

                if (firstKeep2 != null && firstKeep2 == min && Next != firstKeep2 && !firstKeep2.LastClassementRecent)
                {
                    if (forceKeep2)
                    {
                        Next = firstKeep2; refact = true;
                    }
                    else if (firstKeep2.Piece.DeepClassement.isZero())
                    {
                        Next = firstKeep2; refact = true;
                    }
                }
                else if (forceKeep && firstKeep != null && firstKeep == min && Next != firstKeep && !firstKeep.LastClassementRecent)
                {
                    {
                        Next = firstKeep; refact = true;
                    }
                }

                if (Next == nextZero && mode.deepZero)
                {
                    for (; index < count; index++)
                    {
                        IPieceAlbum p = list[index];
                        if (p.Enabled)// p.Piece.DeepClassement.isZero())
                        {
                            var cl = p.Piece.DeepClassement;
                            if (cl.isZero())
                            {
                                if (Next != p)
                                {
                                    Next = p;
                                }
                                break;
                            }
                        }
                    }
                    if (Next == nextZero && firstKeep != null && Next != firstKeep)
                        Next = firstKeep;
                }

                if (refact)
                {
                    cause.selectedMotifMin = cause.resultByFirstMin;
                    cause.motifUp = Next.getCauseUp(cause.selectedMotifMin);
                }
            }

            cause.Next = Next;
            cause.classementValueLight = classementValueLight;
            if (real && min != null)
                this.pluspetitEnabled = min.Piece;
            return cause;



        }


        private bool makesort(List<Piece> list, List<IPieceAlbum> listE, ConfMedianne mode, ConfMedianne mode0, int nbrepeat)
        {
            int count = list.Count;

            if (sortStatus == sortDone.none)   //(!sort0Done)
            {
                // list.Sort(new CPieceComparerByQualityAndLength());
                var listSortedValues = new List<decimal>();
                //classed = false;
                //for (int i = 0; i < count; i++)
                //{
                //    listSortedValues.Add(list[i].Rank.SortValue);
                //    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                //        classed = true;
                //}
                ////misc.log("make sort Duration {0}", name); 
                //m_rank.SortValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;

                //  listSortedValues = new List<decimal>();
                list.Sort(new PieceDurationValueComparer());
                for (int i = 0; i < count; i++)
                {
                    if (!classed && list[i].isClassListNumeric) // && FileRegister.Exist(list[i].Location))
                        classed = true;
                    listSortedValues.Add(list[i].Duration.TotalMilliseconds());
                }
                durationValue = CalcMedianne.getMedianne(listSortedValues, medianne).d;
                //}
                //   decimal moy = 0m;
                decimal offset = Album.conf.AlbumMoyOffset;
#if GEN2
                for (int i = 0; i < count; i++)
                {
                    var p = list[i];
                    var rapportClassement = p.RapportClassement(true);

                    p.setClassementVirtuel(rapportClassement);


                    moy += rapportClassement;
                    if (offset > 0m && rapportClassement > 0.0m)
                        moy += offset;
                }

                if (count > 0)
                    moy /= count;
                classMoy = moy;
#endif

                listE.Sort(new PieceClassementComparer(false));
                this.med = AlbumMedianne.getMedianne(listE, true, medianne);


                //   _med0 = AlbumMedianne.getMedianneLight(new List<PieceExtended>(listE), mode0, mode0.Main, true, false);


                classementValue = this.med.d;
                if (classementValue > 0m)
                {
                    if (med.index != null)
                        med.index.Piece.Medianne = true;
                    //if (this.med.index > 0 && this.med.index < list.Count)
                    //    list[this.med.index].Medianne = true;
                }
                if (sortStatus < sortDone.phaseUn)
                    sortStatus = sortDone.phaseUn;
                //   sort0Done = true;

            }


            if (sortStatus >= sortDone.phaseDeux)
                return false;

            trackSortedByExportPriority = null;
            _tracksSortByClassement = null;
            // classementValueLightSt = -1;
            selectedCoeff = selectedCoeff.noCoeff;
            selectedSure = false;

#if GEN2
            classementValueLightZeroSt = -1;
           
            classementValueLightZero = makeSort(listE, mode0, false);
            if (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }
#endif
            classementValueLight = makeSort(listE, mode, true);
            if (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            {
                sortStatus = sortDone.none; return makesort(list, listE, mode, mode0, nbrepeat);
            }

            //   classementValueLightZero = A_REFAIRE_CAUSE_COMPACT;


            //   while (classementValueLightZero == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLightZero = makeSort(listE, mode0, false);
            //   }

            ////   var _classementValueLight = makeSort(listE, mode, true);

            //   while (classementValueLight == A_REFAIRE_CAUSE_COMPACT)
            //   {
            //       classementValueLight = makeSort(listE, mode, true);
            //   }
#if GEN2
            var coeff1 = mode.Main.coeffVirt;
            var coeff2 = mode.Min.CoeffOld;
            var rendementmax = 1m;

            if (mode.combine)
                rendementmax = coeff1 * coeff2;
            else
                rendementmax = pdb.util.Math.Max(coeff1, coeff2);
            if (Rendement > 6 * rendementmax + 1e-6m)
            {
                nbrepeat++;
                sortStatus = sortDone.none;
                if (nbrepeat >= 3)
                {
                    // classementValueLight = classementValueLightZero;
                    return true;
                }
                return makesort(list, listE, mode, mode0, nbrepeat);

            }
#endif
            return true;
        }



        public bool makeSort(ConfMedianne mode, ConfMedianne mode0, ILogger logger, double dureeMinToLog) //IList<double> reference, IList<Piece> pieces)
        {

            if (sortStatus >= sortDone.phaseDeux)
                return false;
            DateTime nowa = DateTime.Now;
            var ts = (nowa - majDate);
            try
            {

                var list = this.list.ToList<Piece>();
                int count = list.Count;
                if (count == 0)
                    return false;

                var listE = new List<IPieceAlbum>(count);

                //if (CConf.ResetOneCl)
                //{

                //    // CPieceClassement.DateMin = DateTime.MinValue;
                //    decimal zer0d = 0;
                //    Piece oldKeep = null;


                //    foreach (Piece t in list)
                //    {
                //        if (t.Keep)
                //        {
                //            t.Keep = false;
                //            oldKeep = t;
                //            break;
                //        }
                //    }


                //    decimal pluspetitNonNull = int.MaxValue;
                //    Piece min = null;
                //    foreach (Piece t in list)
                //    {
                //        var cl = t.DeepClassement; // p.Classement.DbValue;
                //        decimal clValue = Piece.classementHash.getCache(cl).ClassementValueDecimal; // t.ClassementValueDecimal(false);
                //        if (clValue > zer0d)
                //        {

                //            if (t.LastClassementRecent || !t.Enabled)
                //            {
                //                min = null;
                //                break;
                //            }
                //            if (clValue < pluspetitNonNull)
                //            {
                //                pluspetitNonNull = clValue;
                //                min = t;
                //            }
                //        }

                //    }

                //    if (min != null)
                //    {
                //        min.Keep = true;
                //        var r = min.RapportClassement(true);
                //        if (r <= 0)
                //        {
                //        }
                //    }



                //    if (oldKeep != null && !oldKeep.Keep)
                //    {
                //        oldKeep.resetMedianneCompact();
                //        oldKeep.invalidateCache(true);
                //    }
                //}


                atLeastOneEnabled = false;
                int _nbr = 0;
                int _nbdone = 0;


                for (int i = 0; i < count; i++)
                {
                    var p = list[i];


                    if (sortStatus < sortDone.phaseDeux) //  (!sortDone)
                        p.resetMedianneCompact();
                    if (p.Enabled)
                    {
                        atLeastOneEnabled = true;

                    }
                    if (!p.Enabled && p.ClassmentPositive())
                        _nbdone++;
                    if (p.LastClassementRecent)
                        _nbr++;
#if GEN2
                    var pp = new PieceExtended(p);
#else
                    var pp = p;
#endif

                    if (mode.Main.coeffVirt > 1)
                        listE.Add(new PieceExtendedSimple(pp));
                    else
                        listE.Add(pp);
                }

                nbRecent = _nbr;
                nbDone = _nbdone;


                bool ret = makesort(list, listE, mode, mode0, 0);

                sortStatus = sortDone.phaseDeux;

                majDate = DateTime.Now;
                var duree = (majDate - nowa);
                if (duree.TotalMilliseconds > dureeMinToLog)
                    logger.log(string.Format("make Sort {0}| {1} {2}", ts.toString(), duree.toString(), this));

                return ret;
            }
            catch (Exception ex)
            {
                misc.log("impossible de faire le makeSort de l'album " + name + " " + ex.ToString());
            }

            return false;
        }



        public void mustRefresh()
        {
            build = false;
            sortStatus = sortDone.none;

            selectionDone = false;
            atLeastOneEnabled = null;
            _tracksSortByClassement = null;
            // misc.log("invalidation {0}", this); 
            albumAdded = DateTime.MaxValue;
        }

        public void refreshLight()
        {
            if (sortStatus == sortDone.phaseDeux)
                sortStatus = sortDone.phaseUn;
            atLeastOneEnabled = null;
            dictMove.Remove(Key);
            _tracksSortByClassement = null;
        }



        //public decimal getTrackSortValue(int index, List<Piece> list)
        //{
        //    if (index < 0 || index >= list.Count)
        //        return 0;
        //    return list[index].RapportClassement(true);
        //}

        //decimal firstTrackSortValue = -1;
        //public decimal getFirstTrackSortValue()
        //{
        //    if (firstTrackSortValue == -1)
        //    {
        //        int count = list.Count;
        //        if (count == 0)
        //            return -1;
        //        var _list = new List<Piece>(list);
        //        _list.Sort(new PieceSortComparer());
        //        firstTrackSortValue = _list[count - 1].Rank.SortValue;
        //    }
        //    return firstTrackSortValue;
        //}
        private bool selectionDone;
        public void makeSelection()
        {
            Moved = false;

            if (selectionDone)
                return;
            var list = this.list.ToList<Piece>();
            list.Sort(new PieceRestComparer());
            var listSortedValues = new List<decimal>();
            for (int i = 0; i < list.Count; i++)
                listSortedValues.Add(list[i].Rank.TimeRest);
            timeRest = CalcMedianne.getMedianne(listSortedValues, medianneRest).d;
            selectionDone = true;
        }

        public List<Piece> RawList
        {
            get
            {
                return new List<Piece>(list);
            }
        }

        public List<Piece> Sort()
        {
            var _list = new List<Piece>(list);
            _list.Sort(new PieceInAlbumComparer());
            return _list;
        }

        public TimeSpan Duration
        {
            get
            {
                TimeSpan d = new TimeSpan();
                foreach (Piece piece in list)
                    d += piece.Duration;
                return d;
            }
        }


        #region Rank
        //private CRank m_rank = new CRank();

        //public CRank Rank { get { return m_rank; } }



        private int rankStack = -1;
        public int RankSt { get { return rankStack; } set { rankStack = value; } }

        private int rankZero = -1;
        public int RankZero { get { return rankZero; } set { rankZero = value; } }

        private int rankZeroSt = -1;
        public int RankZeroSt { get { return rankZeroSt; } set { rankZeroSt = value; } }

        private void initRank()
        {
            quality = CRank.MAX;
            // rankStack = -1;
        }

        //public int QRank
        //{
        //    get { return m_rank.Quality; }
        //    set { m_rank.Quality = value; }
        //}

        //public int LRank
        //{
        //    get { return m_rank.Lenght; }
        //    set { m_rank.Lenght = value; }
        //}

        //public int QLRank
        //{
        //    get { return m_rank.Twice; }
        //    set { m_rank.Twice = value; }
        //}


        #endregion

        #region tri



        #endregion

        [Flags]
        private enum unsortMode : byte
        {
            album = 1,
            artist = 2

        }
        const char SEP = '\\';
        const int MAX_PATH_LEVEL = 10;

        public void addPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            paths.Add(p);
                        }
                        ilevel++;
                    }
                    // paths.Add(path);
                }
            }
        }

        public bool containsPath(Piece pp, HashSet<string> paths, int pathlevel)
        {
            foreach (string path in pp.RelativesPath)
            {
                bool go = VirtualByArtist;
                if (!VirtualByArtist)
                {
                    var _name = Name.Remove(0);
                    if (string.IsNullOrEmpty(_name) || path.StartsWith(_name))
                        go = true;
                }

                if (go)
                {
                    if (paths.Contains(path))
                        return true; //paths.Add(path);
                    var tab = path.Split(SEP);
                    int ilevel = 0;
                    var sb = new StringBuilder();
                    foreach (string d in tab)
                    {
                        if (string.IsNullOrEmpty(d))
                            continue;
                        if (sb.Length > 0)
                            sb.Append(SEP);
                        sb.Append(d);
                        if (ilevel >= pathlevel)
                        {
                            var p = sb.ToString();
                            if (paths.Contains(p))
                                return true;
                        }
                        ilevel++;
                    }

                }
            }
            return false;
        }
        public void sortVirtual()
        {
            if (this.VirtualMode == virtualMode.none)
                return;
            var list = this.list.ToList<Piece>();
            int count = list.Count;
            if (count == 0)
                return;
            list.Sort((x, y) =>
            {
                var cmp = x.MasterTrackNumberForTri.CompareTo(y.MasterTrackNumberForTri);
                if (cmp != 0)
                    return cmp;
                return x.Location.CompareTo(y.Location);
            });
            var dictArtist = new Dictionary<string, List<Piece>>();
            var dictAlbum = new Dictionary<int, string>();
            var dictDir = new Dictionary<string, List<Piece>>();
            DirSort.reset();
            foreach (Piece p in list)
            {

                DirSort.record(p);
            }

            DirSort.go();


            foreach (Piece p in list)
            {
                if (p.TrackNumber == 0)
                {
                    p.TrackNumber = list.Count + p.MasterTrackNumber;
                }
            }

            list.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));
            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;

            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}

            //var list2 = new List<Piece>(list);
            //list2.Sort(new VirtualPieceComparer());

            var hs = new HashSet<int>();
            var unsorted = new List<Piece>();
            Piece pp = list[0];
            hs.Add(pp.PieceId); unsorted.Add(pp);
            //string currentArtist = pp.Artist;
            //string currentAlbum = pp.Master.Album;


            int indexC = 0;
            //  bool singleAlbum = false;
            string currentArtist = Album.getKey(pp.Artist, virtualMode.artist);
            unsortMode mode = unsortMode.album | unsortMode.artist;
            if (VirtualByArtist)
                mode = unsortMode.album;

            HashSet<string> artists = new HashSet<string>();
            HashSet<string> albums = new HashSet<string>();
            artists.Add(currentArtist);
            albums.Add(pp.Master.PieceAlbum.Key);
            //  HashSet<string> paths = new HashSet<string>();
            //int pathlevel = 0;
            //  bool found = false;
            int nbc = 0;
            while (unsorted.Count < count)
            {
                nbc++;
                //int indexAlbum = -1;
                //int indexArtist = -1;


                // addPath(pp, paths, pathlevel);

                artists.Clear();
                albums.Clear();
                //    paths.Clear();
                artists.Add(currentArtist);
                albums.Add(pp.Master.PieceAlbum.Key);


                for (int i = 0; i < count; i++)
                {

                    var p = list[i];
                    if (hs.Contains(p.PieceId))
                        continue;

                    if (mode == 0)
                    {
                        hs.Add(p.PieceId);
                        unsorted.Add(p);
                        pp = p;
                        // indexAlbum = -1;
                        indexC = i;
                        continue;
                    }
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        var artist = p.Artist;
                        if (p.Artist != pp.Artist)
                        {
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            if (currentArtist != cartist)
                            {
                                if (!artists.Contains(cartist))
                                {
                                    if (mode.HasFlag(unsortMode.album))
                                    {
                                        if (albums.Contains(p.Master.PieceAlbum.Key))
                                        {
                                            //if (albums.Count <= 1)
                                            //    indexArtist = i;
                                            continue;
                                        }
                                    }

                                    //if (pathlevel <= MAX_PATH_LEVEL)
                                    //{
                                    //    if (containsPath(p, paths, pathlevel))
                                    //        continue;
                                    //}

                                    hs.Add(p.PieceId);
                                    unsorted.Add(p);
                                    pp = p;
                                    //indexAlbum = -1;
                                    //indexArtist = -1;

                                    albums.Add(pp.Master.PieceAlbum.Key);
                                    artists.Add(cartist);
                                    //  addPath(pp, paths, pathlevel); 
                                    indexC = i;
                                    currentArtist = cartist;
                                    //   found = true;
                                    continue;

                                }
                            }
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                    {
                        var album = p.Master.PieceAlbum.Key;
                        if (!albums.Contains(album))
                        {
                            //if (pathlevel <= MAX_PATH_LEVEL)
                            //{
                            //    if (containsPath(p, paths, pathlevel))
                            //        continue;
                            //}
                            hs.Add(p.PieceId);
                            unsorted.Add(p);
                            pp = p;
                            indexC = i;
                            //indexAlbum = -1;
                            albums.Add(album);
                            var cartist = Album.getKey(p.Artist, virtualMode.artist);
                            artists.Add(cartist);
                            currentArtist = cartist;
                            //   found = true;
                            //  addPath(pp, paths, pathlevel); 
                        }
                    }
                }


                //if (indexAlbum >= 0)
                //{
                //    // pas trouvé d'autre artiste, on se rabat sur l'album
                //    var p = list2[indexAlbum];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexAlbum;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else if (indexArtist >= 0)
                //{
                //    // on a trouvé un autre artiste sur le même album. pas si mal
                //    var p = list2[indexArtist];
                //    hs.Add(p.PieceId);
                //    unsorted.Add(p);
                //    pp = p;
                //    indexC = indexArtist;
                //    indexAlbum = -1;
                //    albums.Add(pp.Master.PieceAlbum.Key);
                //    var cartist = Album.getKey(p.Artist, true);
                //    artists.Add(cartist);
                //    currentArtist = cartist;
                //}
                //else
                //{
                //    // rien trouvé de spécial
                //    if (indexC == 0 && !singleAlbum)
                //    {
                //        singleAlbum = true;
                //    }
                //    indexC = 0;

                //}

                if (indexC == 0)
                {

                    //if (found)
                    //{
                    //    found = false;
                    //}
                    //else
                    //{
                    //{
                    //    if (paths.Count == 0)
                    //    {
                    //        pathlevel = MAX_PATH_LEVEL; 
                    //    }
                    //    if (pathlevel < MAX_PATH_LEVEL)
                    //    {
                    //        pathlevel++;
                    //    }
                    //    else
                    //    {
                    if (mode.HasFlag(unsortMode.artist))
                    {
                        if (mode.HasFlag(unsortMode.album))
                            // on cherche les artistes différents ( éventuellement même album ) 
                            mode &= ~unsortMode.album;
                        else
                        {
                            // on abandonne la recherche artiste et on réactive la recherche album
                            mode &= ~unsortMode.artist;
                            mode |= unsortMode.album;
                        }
                    }
                    else if (mode.HasFlag(unsortMode.album))
                        // on est en mode single album; 
                        mode &= ~unsortMode.album;

                    //pathlevel = 0;
                    //  }
                }
                //}
                // }
                indexC = 0;

            }

            for (int i = 0; i < unsorted.Count; i++)
            {
                unsorted[i].TrackNumber = i + 1;
            }



            //foreach (Piece p in list)
            //{
            //    if (p == null)
            //        continue;
            //    var artist = p.Artist;
            //    FileInfo file = null;
            //    try
            //    {
            //        file = new System.IO.FileInfo(p.Location);
            //    }
            //    catch
            //    {
            //        continue;
            //    }
            //    var dirAlbum = file.Directory;
            //    var dirArtist = dirAlbum.Parent;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = dirArtist.FullName;
            //    if (string.IsNullOrEmpty(artist))
            //        artist = "-";
            //    if (!dictArtist.ContainsKey(artist))
            //        dictArtist.Add(artist, new List<Piece>());
            //    dictArtist[artist].Add(p);

            //    var _album = p.Master.Album;
            //    if (string.IsNullOrEmpty(_album))
            //        _album = dirAlbum.FullName;
            //    dictAlbum.Add(p.PieceId, _album);

            //    //if (!dictAlbum.ContainsKey(_album))
            //    //    dictAlbum.Add(_album, new List<Piece>());
            //    //dictAlbum[_album].Add(p);


            //}

            //foreach (List<Piece> l in dictArtist.Values)
            //{
            //    //
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //var listUnSortArtist = new List<Piece>(list);
            //listUnSortArtist.Sort((x, y) => x.TrackNumber.CompareTo(y.TrackNumber));

            //var listUnSortAlbum = new List<Piece>();

            //List<Piece> aux = new List<Piece>();
            //int current = 0;

            //foreach (Piece p in listUnSortArtist)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {
            //        //aux.Add(p);
            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            string xa = x.Master.Album;
            //            string ya = y.Master.Album;
            //            if (dictAlbum.ContainsKey(x.PieceId))
            //                xa = dictAlbum[x.PieceId];
            //            else
            //            { }
            //            if (dictAlbum.ContainsKey(y.PieceId))
            //                ya = dictAlbum[y.PieceId];
            //            else
            //            { }
            //            var cmp = xa.CompareTo(ya);
            //            return cmp;
            //        });

            //        listUnSortAlbum.AddRange(aux);
            //        aux.Clear();

            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    string xa = x.Master.Album;
            //    string ya = y.Master.Album;
            //    if (dictAlbum.ContainsKey(x.PieceId))
            //        xa = dictAlbum[x.PieceId];
            //    else
            //    { }
            //    if (dictAlbum.ContainsKey(y.PieceId))
            //        ya = dictAlbum[y.PieceId];
            //    else
            //    { }
            //    var cmp = xa.CompareTo(ya);
            //    return cmp;
            //});

            //listUnSortAlbum.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnSortAlbum.Count; i++)
            //{
            //    listUnSortAlbum[i].TrackNumber = i + 1;
            //}

            //aux.Clear();
            //current = 0;
            //var listUnsortTrack = new List<Piece>();

            //foreach (Piece p in listUnSortAlbum)
            //{
            //    var tn = p.TrackNumber;
            //    if (tn == current)
            //    {

            //    }
            //    else
            //    {
            //        current = tn;
            //        aux.Sort((x, y) =>
            //        {
            //            if (x.PieceId == y.PieceId)
            //                return 0;
            //            var xt = x.MasterTrackNumber;
            //            var yt = y.MasterTrackNumber;
            //            int cmp = 0;
            //            if (xt <= 0 || yt <= 0)
            //            {
            //                try
            //                {
            //                    cmp = x.Location.CompareTo(y.Location);
            //                }
            //                catch
            //                {
            //                }
            //            }
            //            cmp = xt.CompareTo(yt);
            //            return cmp;
            //        });

            //        listUnsortTrack.AddRange(aux);
            //        aux.Clear();
            //    }
            //    aux.Add(p);
            //}

            //aux.Sort((x, y) =>
            //{
            //    if (x.PieceId == y.PieceId)
            //        return 0;
            //    var xt = x.MasterTrackNumber;
            //    var yt = y.MasterTrackNumber;
            //    int cmp = 0;
            //    if (xt <= 0 || yt <= 0)
            //    {
            //        try
            //        {
            //            cmp = x.Location.CompareTo(y.Location);
            //        }
            //        catch
            //        {
            //        }
            //    }
            //    cmp = xt.CompareTo(yt);
            //    return cmp;
            //});

            //listUnsortTrack.AddRange(aux);
            //aux.Clear();



            //for (int i = 0; i < listUnsortTrack.Count; i++)
            //{
            //    listUnsortTrack[i].TrackNumber = i + 1;
            //}




            //foreach (Piece p in list)
            //{
            //    if (p.MasterTrackNumber > 0)
            //        continue;
            //    try
            //    {
            //        var file = new System.IO.FileInfo(p.Location);
            //        var key = file.DirectoryName;

            //        if (!dictDir.ContainsKey(key))
            //            dictDir.Add(key, new List<Piece>());
            //        dictDir[key].Add(p);
            //    }
            //    catch
            //    {
            //    }
            //}

            //foreach (List<Piece> l in dictDir.Values)
            //{
            //    l.Sort((x, y) => x.Location.CompareTo(y.Location));
            //    for (int i = 0; i < l.Count; i++)
            //    {
            //        l[i].TrackNumber = i + 1;
            //    }
            //}

            //list.Sort(new PieceInVirtualAlbumComparer());
            //int nb = 0;
            //foreach (var piece in list)
            //{
            //    nb++;
            //    piece.TrackNumber = nb;
            //}
        }

        public bool isSameOf(Album o)
        {
            if (o == this)
                return false;
            if (list.Count != o.list.Count)
                return false;

            foreach (Piece p in masters)
            {
                if (!o.masters.Contains(p))
                    return false;
            }
            return true;

        }

        public override bool Equals(object obj)
        {
            var o = obj as Album;
            if (o == null)
                return false;
            return Key.Equals(o.Key) && mode == o.mode;
        }
        public override int GetHashCode()
        {
            return Key.GetHashCode();
        }

        public DateTime? UpdateClassement
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in new List<Piece>(list))
                {

                    var _dt = p.UpdateClassement; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public DateTime? LastRead
        {
            get
            {
                DateTime? dt = null;
                foreach (Piece p in list)
                {
                    var _dt = p.LastRead; // CalcDate.getLastModif(p.DatesClassement);
                    if (_dt != null && (dt == null || _dt > dt))
                        dt = _dt;
                }
                return dt;
            }
        }

        public IEnumerator<Piece> GetEnumerator()
        {
            return list.GetEnumerator();
        }
        private DateTime albumAdded = DateTime.MaxValue;
        public DateTime AlbumAdded
        {
            get
            {
                if (albumAdded < DateTime.MaxValue)
                    return albumAdded;
                DateTime min = DateTime.MaxValue;
                foreach (Piece p in list)
                {
                    var dt = p.Added;
                    if (dt > DateTime.MinValue)
                    {
                        if (dt < min)
                            min = dt;
                    }
                    else
                    {
                        dt = p.FirstAcces;
                        if (dt < min && dt > DateTime.MinValue)
                            min = dt;
                    }

                }
                albumAdded = min;
                return albumAdded;
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return list.GetEnumerator();
        }

        public const string UNKNOWN = "-";
        public static string getKey(string _album, virtualMode mode)
        {
            string __album = UNKNOWN;
            if (!string.IsNullOrEmpty(_album))
            {
                __album = _album.Trim().ToLower();

                if (mode == virtualMode.word)
                {
                    __album = string.Format("¤¤[{0}]", __album);
                    return __album;
                }
                if (mode == virtualMode.list)
                {
                    __album = string.Format("/{0}", __album);
                    return __album;
                }

                if (__album.StartsWith("the "))
                    __album = Regex.Replace(__album, @"the\ ", "");
                if (__album.StartsWith("les "))
                    __album = Regex.Replace(__album, @"les\ ", "");
                if (__album.Contains(" et "))
                    __album = __album.Replace(" et ", " ");
                if (__album.Contains(" and "))
                    __album = __album.Replace(" and ", " & ");
                __album = __album.removeAccent();
                __album = Regex.Replace(__album, @"\ +", " ");
                if (mode == virtualMode.artist)
                {
                    __album = string.Format("$[{0}]", __album);
                }
                else if (mode == virtualMode.year)
                {
                    if (_album.Length == 3)
                        __album = string.Format("£[{0}0']", __album);
                    else
                        __album = string.Format("£[{0}]", __album);
                }
                else if (mode == virtualMode.extended)
                {
                    __album = string.Format("¤[{0}]", __album);
                }
                else if (mode == virtualMode.extendedWord)
                {
                    __album = string.Format("¤[{0}]¤", __album);
                }
                else if (mode == virtualMode.added)
                {
                    __album = string.Format("<{0}>", __album);
                }

            }
            return __album;

        }



    }
}
]]></content>
  </file>
</db>
